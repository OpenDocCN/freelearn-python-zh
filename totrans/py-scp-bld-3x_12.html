<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-289"><a id="_idTextAnchor304"/>12</h1>
<h1 id="_idParaDest-290"><a id="_idTextAnchor305"/>Rendering and Shaders</h1>
<p>A process called <em class="italic">rendering</em> generates the pixels of finished images by evaluating the geometries, lights, and camera of the scene.</p>
<p>The renderers, or Render Engines, that handle those computations can be external programs, independent from the 3D application, or fully integrated features of the animation package. All renderers have strong and weak points and can be grouped into two categories: real time, which assume a few approximations to achieve immediate visualization, and offline, which take more time to take more details into account.</p>
<p>To generate images, renderers rely on shaders – that is, instructions on how an object reacts to the light and position of the observer, and how that translates into the rendered pixels.</p>
<p>Shaders can be complex and are a discipline of their own, but the basic concept of how they work is not hard to grasp.</p>
<p>In this chapter, you will learn where to set the render properties, how to automate the creation of shaders using Python, and how to use the <strong class="bold">File Browser</strong> for loading images.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Understanding the materials system</li>
<li>Loading images in the Shader Editor</li>
<li>Connecting and arranging shader nodes</li>
</ul>
<h1 id="_idParaDest-291"><a id="_idTextAnchor306"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created for this chapter, along with the media files, can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12</a>.</p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor307"/>Render and materials</h1>
<p>Blender comes with two render engines: <strong class="bold">Eevee</strong>, the real-time renderer that can be used in the Viewport, and <strong class="bold">Cycles</strong>, an offline renderer. Additional engines, including most of the commercial offerings, can be installed in the form of render add-ons. A third option, <strong class="bold">Workbench</strong>, can be used for quickly and simply displaying renders in the Viewport.</p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor308"/>Setting the Render Engine</h2>
<p>The current <strong class="bold">Render Engine</strong>, along <a id="_idIndexMarker779"/>with other render settings, can be found in the scene <strong class="bold">Render</strong> properties. It’s the first tab and is marked with an icon of a TV set:</p>
<div><div><img alt="Figure 12.1: Selecting the current Render Engine" height="317" src="img/Figure_12.01_B18375.jpg" width="396"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Selecting the current Render Engine</p>
<p>While <strong class="bold">Workbench</strong> is designed to have only a few render options and no shading system, <strong class="bold">Eevee</strong> and <strong class="bold">Cycles</strong> can combine images, colors, and attributes using a node-based system. This can be done in the <strong class="bold">Shader Editor</strong> area, available in the <strong class="bold">Shading</strong> workspace.</p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor309"/>The Shading workspace</h2>
<p>Shading involves <a id="_idIndexMarker780"/>disparate activities, such as accessing image files, checking the Viewport, and editing object properties. Once we set our <strong class="bold">Render Engine</strong> to Eeeve, Cycles, or an external engine that supports Blender’s shading system, we can carry out those tasks in the <strong class="bold">Shading</strong> workspace. It contains the following:</p>
<ul>
<li>A <strong class="bold">File Browser</strong> for importing images</li>
<li>The <strong class="bold">3D Viewport</strong> area for checking the materials</li>
<li>An <strong class="bold">Outliner</strong></li>
<li>Data <strong class="bold">Properties</strong>; by default, the <strong class="bold">World</strong> settings tab is active</li>
<li>The <strong class="bold">Shaders </strong><strong class="bold">Editor</strong> area</li>
<li>The <strong class="bold">Image </strong><strong class="bold">Editor</strong> area:</li>
</ul>
<div><div><img alt="Figure 12.2: The Shading workspace" height="928" src="img/Figure_12.02_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: The Shading workspace</p>
<p>The default material <a id="_idIndexMarker781"/>presents a few color attributes that can be set in the <strong class="bold">Material Properties</strong> area. To understand how to script articulated materials with a proper layout, we will provide a brief overview of how the shader components come together in the shader graph.</p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor310"/>Understanding object materials</h2>
<p>We can change the overall look of an object by specifying its material. The term <em class="italic">material</em> follows <a id="_idIndexMarker782"/>the analogy of real-world objects, whose look is affected by the material of which they are made or coated.</p>
<p>Object materials can be edited in the <strong class="bold">Material Properties</strong> area. In version 3.3, it’s the second-to-last property tab, marked with an icon of a sphere with a checkerboard pattern, as shown in <em class="italic">Figure 12</em><em class="italic">.3</em>.</p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor311"/>Setting Material Properties</h2>
<p>Materials exist <a id="_idIndexMarker783"/>independently from objects. One material can be shared among multiple objects and an object can have more materials assigned to different sets of faces.</p>
<p>Scrolling down to the material <strong class="bold">Settings</strong>, we can edit how the material is processed by Blender – for instance, how its transparent parts are rendered over the background:</p>
<div><div><img alt="Figure 12.3: Settings in the Material Properties area" height="620" src="img/Figure_12.03_B18375.jpg" width="396"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: Settings in the Material Properties area</p>
<p>The properties commonly associated with actual materials, such as roughness, color, and transparency, are displayed in the <strong class="bold">Surface</strong> panel. Those properties are part of the <strong class="bold">shader</strong>, a generic algorithm <a id="_idIndexMarker784"/>used for computing how a surface should look. Every material has a shader associated with it.</p>
<p>Shaders introduce <a id="_idIndexMarker785"/>a new concept to this book: a visual framework known <a id="_idIndexMarker786"/>as the <strong class="bold">nodes tree</strong>. We can learn how it works by looking at the <strong class="bold">Shader </strong><strong class="bold">Editor</strong> area.</p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor312"/>The Shader Editor</h1>
<p>The shading system <a id="_idIndexMarker787"/>supports different styles: realistic, cartoon, or technical drawings, to mention a few. Rather than providing a single interface with defined widgets, the functionalities <a id="_idIndexMarker788"/>of a renderer are scattered through interconnecting units called <strong class="bold">nodes</strong>.</p>
<p>Much like a function, a node performs a specific operation on one or more inputs and makes the results available through one or more outputs. Nodes are visual representations of functions, allowing non-programmers to combine logic blocks to get custom results.</p>
<p>Nodes are not unique to shading – they are used for <strong class="bold">Compositing</strong> and for generating meshes in the <strong class="bold">Geometry </strong><strong class="bold">Nodes</strong> modifier.</p>
<p>By default, a Blender material presents a <strong class="bold">Material Output</strong> node in the <strong class="bold">Shader Editor</strong> area, with a <strong class="bold">Principled BSDF</strong> node as its <strong class="bold">Surface</strong> input. <strong class="bold">Bidirectional Scattering Distribution Function</strong> (<strong class="bold">BSFD</strong>) is a mathematical model of how a surface receives and reflects light <a id="_idIndexMarker789"/>rays. It is a form of <strong class="bold">Physically-Based Rendering</strong> (<strong class="bold">PBR</strong>), an approach based on how visual properties <a id="_idIndexMarker790"/>such as color, roughness, and permeability interact with light in the real world.</p>
<p><strong class="bold">Material Output</strong> is the last node of the graph and transfers the shading to an object.</p>
<p>Only one output can be <a id="_idIndexMarker791"/>active at any time, so the shader graph is also called the <strong class="bold">Node Tree</strong>, with the output as the root from which all the other branches stem.</p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor313"/>Understanding the Node Tree</h2>
<p>The inputs and <a id="_idIndexMarker792"/>outputs of a node are displayed as colored circles <a id="_idIndexMarker793"/>called <strong class="bold">sockets</strong>. Input sockets are on the left-hand <a id="_idIndexMarker794"/>side of the node, while output sockets are on the right. Their color depends on the data type of the socket. For instance, the <strong class="bold">Base Color</strong> socket of a <strong class="bold">Principled</strong> node, which is yellow, assigns a color to a material, while <strong class="bold">Roughness</strong>, a gray socket, is a float number to denote how far from smooth it is.</p>
<p>Purple sockets, such as <strong class="bold">Normal</strong>, are vectors and can contain directional data.</p>
<p>Output sockets are on the right-hand side of a node, and can be connected, or linked, to the input sockets on the left-hand side of another node:</p>
<div><div><img alt="Figure 12.4: A principled node receiving color, roughness, and normal inputs" height="705" src="img/Figure_12.04_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: A principled node receiving color, roughness, and normal inputs</p>
<p>So, the color attribute of a <strong class="bold">Base Color</strong> is an input socket and can be connected to any color output from another node. For instance, the input of a <strong class="bold">Principled</strong> node’s <strong class="bold">Base Color</strong> can come from an <strong class="bold">RGB</strong> node, as shown in <em class="italic">Figure 12</em><em class="italic">.4</em>, but also from an <strong class="bold">Image Texture</strong>, as shown in <em class="italic">Figure 12</em><em class="italic">.5</em>:</p>
<div><div><img alt="Figure 12.5: A principled node, with an image as the input of Base Color" height="631" src="img/Figure_12.05_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5: A principled node, with an image as the input of Base Color</p>
<p class="callout-heading">Connection is conversion!</p>
<p class="callout">We can connect sockets of different types, such as vectors and colors; the data is converted automatically. The <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> vector components are converted into the red, green, and blue elements of color, while the brightness of colors is converted into float values.</p>
<p>Now that we know <a id="_idIndexMarker795"/>how materials work, we will write a script that helps <a id="_idIndexMarker796"/>load <strong class="bold">Image Textures</strong>.</p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor314"/>Writing the Textament add-on</h1>
<p>While creating a <a id="_idIndexMarker797"/>shader can take time, we can automate some of the simpler operations. For instance, we can write an add-on to ease the task of loading images from disk and connecting them to the shader.</p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor315"/>Using texture images</h2>
<p>With the <strong class="bold">Texture Image</strong> node, we <a id="_idIndexMarker798"/>can use an image for coloring an object. That adds variation to how a material looks, as images can vary along the extension of an object and are not limited to a single color:</p>
<div><div><img alt="Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube" height="928" src="img/Figure_12.06_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube</p>
<p>The operator that we are going to write will load multiple images from disk and guess their usage <a id="_idIndexMarker799"/>from the image’s filename. For instance, an image named <code>Metallic.png</code> would be loaded as a <strong class="bold">Texture Image</strong> and connected to the <strong class="bold">Metallic</strong> input of a <strong class="bold">Principled</strong> node.</p>
<p>As usual, we will set up an environment for developing a new add-on.</p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor316"/>Setting up the environment</h2>
<p>We will create <a id="_idIndexMarker800"/>a Python script for our add-on and make it known to Blender by performing these steps:</p>
<ol>
<li>Create a folder called <code>PythonScriptingBlender/ch12/addons</code>. We can use the file manager or the file tab of our IDE for this, such as <strong class="bold">VS Code</strong>.</li>
<li>Create a new file in that folder and name it <code>textament.py</code>. We can use the file manager or the <strong class="bold">New File</strong> button of our IDE to do this.</li>
<li>Open the file in your editor of choice.</li>
<li>Set the <code>PythonScriptingBlender/ch12</code> in Blender’s <strong class="bold">File </strong><strong class="bold">Paths</strong> preferences.</li>
<li>Restart Blender <a id="_idIndexMarker801"/>to update the search paths.</li>
</ol>
<p>Now, we will start writing the add-on information as usual.</p>
<h3>Writing the Textament add-on information</h3>
<p>In the information, we <a id="_idIndexMarker802"/>must specify what the add-on is for and where its tools can be found:</p>
<pre class="source-code">
bl_info = {
    "name": "Textament",
    "author": "Packt Man",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Load and connect node textures",
    "location": "Node-Graph header",
    "category": "Learning"
}</pre>
<p>The add-on contains just one class – an import operator for loading images.</p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor317"/>Writing an import operator</h2>
<p>Our operator <a id="_idIndexMarker803"/>loads the image textures from <a id="_idIndexMarker804"/>disk, so we will need the <code>os</code> module to handle disk paths. Besides <code>bpy</code>, this operator will inherit from the <code>ImportHelper</code> utility class so that it can access Blender’s <strong class="bold">File Browser</strong></p>
<pre class="source-code">
import os
import bpy
<strong class="bold">from bpy_extras.io_utils import ImportHelper</strong></pre>
<p>Operators that <a id="_idIndexMarker805"/>derive from <code>ImportHelper</code> store <a id="_idIndexMarker806"/>the selected file paths in a few extra properties.</p>
<h3>Using Blender’s File Browser</h3>
<p>Like all operators, <code>AddTextures</code> is based on <code>bpy.types.Operator</code>, but since it operates <a id="_idIndexMarker807"/>on files, it inherits from the <code>ImportHelper</code> class too. By inheriting from both classes, when it is launched, <code>AddTextures</code> runs the <code>invoke</code> method of <code>ImportHelper</code>, which opens the <code>execute</code> method runs as usual:</p>
<pre class="source-code">
Class AddTextures(bpy.types.Operator, <strong class="bold">ImportHelper</strong>):
    """Load and connect material textures"""
    bl_idname = "texture.textament_load"
    bl_label = "Load and connect textures"
    bl_description = "Load and connect material textures"</pre>
<p>Deriving from <code>ImportHelper</code> adds a <code>filepath</code> attribute to <code>AddTexture</code>, in which the path to the selected file is stored.</p>
<p>The <code>filepath</code> attribute stores the disk path to a single file, which is not enough in our case as we intend to load multiple files at once. For that reason, we need to store the selected <code>directory</code> in a <code>StringProperty</code>, and the selected <code>files</code> as a collection of <code>OperatorFileListElement</code>:</p>
<pre class="source-code">
    <strong class="bold">directory</strong>: bpy.props.StringProperty()
    <strong class="bold">files</strong>: bpy.props.<strong class="bold">CollectionProperty</strong>(
                    name="File Path",
            <a id="_idTextAnchor318"/>        type=bpy.types.<strong class="bold">OperatorFileListElement</strong>,
                   )</pre>
<p>In another <code>StringProperty</code>, <code>filter_glob</code>, set the extensions of the files that should be displayed in the <code>.png</code> and <code>.jpg</code> images. This property is <code>"HIDDEN"</code>: we don’t want it to show up in the operator’s options:</p>
<pre class="source-code">
    filter_glob: bpy.props.StringProperty(
                                    default="*.png; *.jpg",
                                    options={"HIDDEN"})</pre>
<p>Now, we can <a id="_idIndexMarker808"/>write the operator method. We will start with <code>poll</code>, the method that checks if the operator can be launched.</p>
<h3>Checking the existence of an active node</h3>
<p>This operator <a id="_idIndexMarker809"/>works on the current node, so we need to check for the following:</p>
<ul>
<li>An active object exists</li>
<li>There is an active material</li>
<li>A material node tree has been found</li>
<li>The material tree has an active node</li>
</ul>
<p>So, the <code>poll</code> method returns <code>False</code> unless all the aforementioned conditions apply:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        ob = context.object
        if not ob:
            return False
        mat = ob.active_material
        if not ob:
            return False
        tree = mat.node_tree
        if not tree:
            return False
        return <strong class="bold">tree.nodes.active</strong></pre>
<p>If the operator is <a id="_idIndexMarker810"/>launched and files are selected, they will be stored to be used in the <code>execute</code> method.</p>
<h3>Matching texture filenames</h3>
<p>At the <a id="_idIndexMarker811"/>beginning of <code>execute</code>, we store the currently active node in a variable:</p>
<pre class="source-code">
    def execute(self, context):
        mat = context.object.active_material
        target_node = mat.node_tree.nodes.active</pre>
<p>Operators that inherit from <code>ImportHelper</code> display the <code>execute</code> method after a choice in the <strong class="bold">File Browser</strong> is confirmed.</p>
<p>For that reason, at the time when <code>execute</code> is run, the <code>self.files</code> attribute will contain the file selection from the user. We can iterate <code>self.files</code> and compare each filename with the shader inputs. Rather than looking for an exact match, we will be happy to find a filename and an input name that are similar at large.</p>
<p>For instance, <code>"baseColor.png"</code> should connect with the <code>"Base Color"</code> socket. In other words, we want case-insensitive and space-insensitive matching.</p>
<p>A quick way to achieve this is by using a combination of the <code>lower</code> and <code>replace</code> methods. We can test this in any Python console; for example:</p>
<pre class="source-code">
&gt;&gt;&gt; "Base Color".lower().replace(" ", "")
'basecolor'
&gt;&gt;&gt; "baseColor".lower().replace(" ", "")
'basecolor'</pre>
<p>We will need to perform this operation for every file, on any input, so we should create a function for that.</p>
<p>The <code>lambda</code> statement is a quick way to create a function by just stating its arguments and one expression. For instance, putting an input, <em class="italic">x</em>, into lowercase and as a non-spaced string can be written in this form:</p>
<pre class="source-code">
        match_rule = lambda x : x.<strong class="bold">lower().replace(" ", "")</strong></pre>
<p>Unlike <code>def</code>, <code>lambda</code> doesn’t assign a name to the function as names are not a requirement of the syntax:</p>
<pre class="source-code">
lambda arguments : expression</pre>
<p>Since we <a id="_idIndexMarker812"/>are storing its result in the <code>match_rule</code> variable, our example is equivalent to writing the following lines:</p>
<pre class="source-code">
def match_rule(x):
    return x.lower().replace(" ", "")</pre>
<p><code>lambda</code> can be used to write more compact code, or if a function is required as an argument but is not supposed to be called directly.</p>
<p>We will use <code>match_rule</code> on every filename and every potential socket and compare the results while looking for a match.</p>
<p>Node sockets are stored in <code>inputs</code>, a dictionary-like collection attribute of every node. We can get a list of the socket names using the <code>keys</code> method:</p>
<pre class="source-code">
        input_names = target_node.inputs.keys()</pre>
<p>Now, it’s time to look for textures to link. We can combine two for loops and scroll all the inputs for each entry in <code>self.files</code>. If a match is found, the input/filename pair will be added to the <code>matching_names</code> dictionary:</p>
<pre class="source-code">
        matching_names = {}
        for f in self.files:
            for inp in input_names:
                if match_rule(inp) in match_rule(f.name):
                    <strong class="bold">matching_names[inp] = f.name</strong>
                    break</pre>
<p>The <code>break</code> statement aborts the <code>input_names</code> loop when a match is found so that we can proceed to the next file.</p>
<p>Once the <code>matching_names</code> dictionary contains the input for which textures were found and <a id="_idIndexMarker813"/>the relative filenames, we can load the images from disk and add them to the graph.</p>
<h3>Loading image files</h3>
<p>The elements <a id="_idIndexMarker814"/>of <code>self.file</code> are not full disk paths. We can build this from <code>directory</code> and <code>os.path.join</code> so that we can use <code>bpy.<a id="_idTextAnchor319"/>data.images.load</code>:</p>
<pre class="source-code">
        for inp, fname in matching_names.items():
            img_path = os.path.join(self.directory, fname)
            img = bpy.data.images.load(img_path,
                                       check_existing=True)</pre>
<p>The <code>check_existing</code> parameter avoids loading the same image more than once: if it is already present in <code>bpy.data.images</code>, the <code>load</code> method returns the existing entry.</p>
<p>We have mentioned that not all sockets are colors, but also that vectors, colors, and float sockets are converted automatically when they are connected. Therefore, non-color data such as metallic (a float number) or normal (a vector) can be stored in images.</p>
<p>One of the main points of a node graph is that we should be able to connect sockets of different, but broadly similar, types.</p>
<h3>Getting non-color attributes from images</h3>
<p>The colors of <a id="_idIndexMarker815"/>an image are not different from vectors in terms of their information, which consists of three channels or components: <strong class="bold">red</strong>, <strong class="bold">green</strong>, and <strong class="bold">blue</strong>.</p>
<p>Connecting a <strong class="bold">Color</strong> socket to a <strong class="bold">Vector</strong> socket will use the red, green, and blue channels as the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> coordinates of a three-dimensional vector, respectively.</p>
<p>If a color output is connected to a float socket, the brightness, also called its <strong class="bold">luminance</strong> or <strong class="bold">value</strong>, will be used as float input.</p>
<p>Whenever an image is used for storing values rather than colors, it’s important to inform Blender about that; otherwise, color adjustments from the renderer would alter the image information.</p>
<p>We can do that by setting the image color space to <code>NonColor</code> if a socket is not of the <code>"</code><code>RGBA"</code> type:</p>
<pre class="source-code">
            if target_node.inputs[inp].type != "RGBA":
                img.colorspace_settings.name = "Non-Color"</pre>
<p>If we don’t <a id="_idIndexMarker816"/>do that, even correct textures will produce render artifacts.</p>
<p>At this stage, the images have been loaded into Blender but they are not present in the node tree yet: we need to create an <strong class="bold">Image Texture</strong> for that.</p>
<h3>Creating image texture nodes</h3>
<p>New material nodes <a id="_idIndexMarker817"/>can be added to a material shading graph by accessing the <code>nodes</code> collection of its <code>node_tree</code>. The <code>new</code> collection method requires the node to be of the <code>argument</code> type. In this case, <code>ShaderNodeTexImage</code> is the type that we use for creating image textures, but we can find the Python type of every shading node by looking at the menu tooltips.</p>
<p>If <strong class="bold">Python Tooltips</strong> is enabled in <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong>, like we learned to do in <a href="B18375_02.xhtml#_idTextAnchor033"><em class="italic">Chapter 2</em></a>, we can view the node type by hovering over the menu entry:</p>
<div><div><img alt="Figure 12.7: Hovering over the Add menu entries displays the node type in the tooltip" height="583" src="img/Figure_12.7_B18375.jpg" width="1163"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7: Hovering over the Add menu entries displays the node type in the tooltip</p>
<p>This way, we <a id="_idIndexMarker818"/>can create a new texture node and set its <code>image</code> attribute to the image that we have loaded from disk:</p>
<pre class="source-code">
            tree = mat.node_tree
            tex_img = tree.nodes.new(<strong class="bold">"ShaderNodeTexImage"</strong>)
            tex_img.image = img</pre>
<p>The texture nodes added to the graph are now ready for connection links.</p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor320"/>Connecting nodes</h2>
<p>While most texture <a id="_idIndexMarker819"/>output can be connected directly to a <a id="_idIndexMarker820"/>shading node, some input types might require helper nodes in between. The most prominent case is that of detail, or <strong class="bold">normal maps</strong>. Before creating new connections, our code should check that no additional nodes are required.</p>
<h3>Connecting image colors</h3>
<p>Connection links <a id="_idIndexMarker821"/>can be created using the <code>node_tree.links.new</code> method. Its arguments are as follows:</p>
<ul>
<li>The output socket of the outgoing node</li>
<li>The input socket of the receiving node</li>
</ul>
<p>If we are not dealing with a normal map, we can connect the <code>"Color"</code> output of the texture to the input of the active node. No other action is required, so we can use <code>continue</code> to pass to the next input:</p>
<pre class="source-code">
            if inp != "Normal":
                tree.links.new(tex_img.outputs["Color"],
                               target_node.inputs[inp])
                continue
            # normal map code follows</pre>
<p>A <code>normal</code> input <a id="_idIndexMarker822"/>would not trigger <code>continue</code>, so we don’t need an <code>else</code> statement for it: the normal map code follows, without additional indentation.</p>
<h3>Connecting normal maps</h3>
<p>Rendering a detailed <a id="_idIndexMarker823"/>surface using geometry alone would require so many polygons that the resulting model would be too heavy to store or display.</p>
<p><strong class="bold">Normal mapping</strong> stores geometric<a id="_idIndexMarker824"/> details in the pixels of an image using the RGB-to-XYZ conversion.</p>
<p>Since the normals stored in this way must be merged with the original ones, a <strong class="bold">Normal</strong> texture should not connect directly to a shader node; instead, it should pass through a <strong class="bold">NormalMap</strong> node.</p>
<p>We can add a <code>"ShaderNodeNormalMap"</code> to the tree using <code>new</code>:</p>
<pre class="source-code">
            normal_map = tree.nodes.new(
                                      <strong class="bold">"ShaderNodeNormalMap"</strong>
                                     )</pre>
<p>The <code>"Normal"</code> output of <code>normal_map</code> can be connected to the node input using the following code:</p>
<pre class="source-code">
            tree.links.new(normal_map.outputs["Normal"],
                           target_node.inputs[inp])</pre>
<p>Then, we must connect <code>tex_img</code> to the <code>normal_map</code> node:</p>
<pre class="source-code">
            tree.links.new(tex_img.outputs["Color"],
                           normal_map.inputs["Color"])</pre>
<p>Once the <code>inp, fname</code> loop is over, we can return the <code>'FINISHED'</code> status and exit:</p>
<pre class="source-code">
        return {'FINISHED'}</pre>
<p>Since this script <a id="_idIndexMarker825"/>aims to make setting up the texture faster, we can add an operator button for quick execution.</p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor321"/>Adding a header button</h2>
<p>We have used <a id="_idIndexMarker826"/>menus for most of the operators in this book, but this time, we will add a button in the <strong class="bold">Shader Editor</strong> area’s top bar – that is, its header. The steps are the same as those we used to add menu entries:</p>
<ol>
<li>Create a function that accepts two arguments, <code>self</code> and <code>context</code>.</li>
<li>Append that function to the header type when the add-on registers.</li>
</ol>
<p>Using <code>NODE_TEXTURE</code>. The <code>layout.operator</code> method will display <code>AddTextures</code> as a header button:</p>
<pre class="source-code">
def shader_header_button(self, context):
    self.layout.operator(AddTextures.bl_idname,
                         icon="NODE_TEXTURE",
                         text="Load Textures")</pre>
<p>Now, it’s time to register the operator and the header function. We can find the header class we are looking for, <code>NODE_HT_header</code>, by looking in Blender’s source file, <code>space_node.py</code>. This file can be loaded into Blender’s text editor by right-clicking and choosing <strong class="bold">Edit Source</strong>. We can do this on any element of the <strong class="bold">Shader Editor</strong> area’s header:</p>
<div><div><img alt="Figure 12.8: NODE_HT_header is the first class in space_node.py" height="501" src="img/Figure_12.8_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8: NODE_HT_header is the first class in space_node.py</p>
<p>As an alternative, we <a id="_idIndexMarker827"/>can print a list of all the header types using a <code>comprehension</code> in Blender’s Python console. We learned how to do this in <a href="B18375_08.xhtml#_idTextAnchor206"><em class="italic">Chapter 8</em></a>:</p>
<pre class="source-code">
&gt;&gt;&gt; [c for c in dir(bpy.types) if
     "header" in c]
['CLIP_HT_header', 'CONSOLE_HT_header', 'DOPESHEET_HT_header', 'FILEBROWSER_HT_header', 'GRAPH_HT_header', 'IMAGE_HT_header', 'IMAGE_HT_tool_header', 'INFO_HT_header', 'NLA_HT_header', 'NODE_HT_header', 'OUTLINER_HT_header', 'PROPERTIES_HT_header', 'SEQUENCER_HT_header', 'SEQUENCER_HT_tool_header', 'SPREADSHEET_HT_header', 'STATUSBAR_HT_header', 'TEXT_HT_header', 'USERPREF_HT_header', 'VIEW3D_HT_header', 'VIEW3D_HT_tool_header']</pre>
<p><code>NODE_HT_header</code> is in the middle of the list. We must append our entry to it inside the <code>register</code> function:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(AddTextures)
    bpy.types.NODE_HT_header.append(shader_header_button)</pre>
<p>In <code>unregister</code>, we must remove our interface and class when the add-on is disabled:</p>
<pre class="source-code">
def unregister():
    bpy.types.NODE_HT_header.remove(shader_header_button)
    bpy.utils.unregiser_class(AddTextures)</pre>
<p>Now that the <a id="_idIndexMarker828"/>add-on is ready, we can use it for loading textures instantly.</p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor322"/>Using Load Textures</h2>
<p>If the <code>ch12</code> folder <a id="_idIndexMarker829"/>was added to the <strong class="bold">Scripts</strong> path, we can enable <strong class="bold">Textament</strong> in the <strong class="bold">Learning</strong> category of the <strong class="bold">Add-ons</strong> preferences:</p>
<div><div><img alt="Figure 12.9: Enabling the “Textament” add-on" height="386" src="img/Figure_12.09_B18375.jpg" width="940"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9: Enabling the “Textament” add-on</p>
<p>Once it’s enabled, a button called <strong class="bold">Load Textures</strong> will be added to the <strong class="bold">Shader </strong><strong class="bold">Editor</strong> header:</p>
<div><div><img alt="Figure 12.10: The Load Textures button in the Shader Editor header" height="336" src="img/Figure_12.10_B18375.jpg" width="947"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10: The Load Textures button in the Shader Editor header</p>
<p>Selecting a node allows you to click the <strong class="bold">Load Textures</strong> button, which opens the <strong class="bold">File </strong><strong class="bold">Browser</strong> area.</p>
<p>To test this add-on on a simple model, we can apply a brick wall material to the default cube by following these steps:</p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">General</strong>.</li>
<li>Switch to the <strong class="bold">Shading</strong> workspace using the tabs at the top of the window.</li>
<li>Click <strong class="bold">Load Textures</strong> in the <strong class="bold">Shader Editor</strong> area’s header.</li>
<li>In the <strong class="bold">File Browser</strong> area, navigate to a folder containing images. The textures accompanying this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures</a>.</li>
<li>Optionally, we <a id="_idIndexMarker830"/>can switch the <strong class="bold">File Browser</strong> area to <strong class="bold">thumbnails</strong> mode by clicking the thumbnails button on the top right. This is useful for looking for textures:</li>
</ol>
<div><div><img alt="Figure 12.11: “Load and connect” thumbnails in the File Browser area" height="431" src="img/Figure_12.11_B18375.jpg" width="1374"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11: “Load and connect” thumbnails in the File Browser area</p>
<ol>
<li value="6">We can select multiple files by using the lasso, <em class="italic">Ctrl</em> + clicking, or pressing <em class="italic">A</em> to select all.</li>
<li>Press <strong class="bold">Load and connect</strong> to add the textures to the graph.</li>
</ol>
<p>The <code>bricks_baseColor</code>, <code>bricks_normal</code>, and <code>bricks_roughness</code> textures are now the inputs of the material and make the cube look like a brick wall:</p>
<div><div><img alt="Figure 12.12: Brick textures loaded into the Shader Editor area" height="933" src="img/Figure_12.12_B18375.jpg" width="1112"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12: Brick textures loaded into the Shader Editor area</p>
<p>The operator was <a id="_idIndexMarker831"/>successful but all the nodes were created at the center of the graph. We can improve this considerably by adding code that rearranges the nodes.</p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor323"/>Improving Load Textures</h1>
<p>Nodes can be moved to <a id="_idIndexMarker832"/>a different position by setting the <code>x</code> and <code>y</code> attributes of their <code>location</code> property. This allows us to arrange them in our scripts.</p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor324"/>Arranging shader nodes</h2>
<p>Even if we can move <a id="_idIndexMarker833"/>our nodes freely, the <a id="_idIndexMarker834"/>API poses a few limitations:</p>
<ul>
<li>We can’t access the exact location of the sockets</li>
<li>The width and height of new nodes are not available in the scripts</li>
</ul>
<p>One of those two issues at a time would be tolerable, as we could either move our nodes at the height <a id="_idIndexMarker835"/>of their inputs or get the space <a id="_idIndexMarker836"/>required by a new node on the fly. Since they occur together, we will resort to a workaround.</p>
<h3>Assuming node spacing</h3>
<p>We cannot get <a id="_idIndexMarker837"/>the size of new nodes in a script, but we can learn the default size of a texture node beforehand by looking at an existing shader tree. For instance, after we use <code>dimensions</code> property of an <code>'Image </code><code>Texture'</code> node:</p>
<pre class="source-code">
&gt;&gt;&gt; node_tree = C.object.active_material.node_tree
&gt;&gt;&gt; node_tree.nodes['Image Texture'].dimensions
Vector((360.0, 410.0))</pre>
<p>The <code>Vector</code> property returned by <code>dimensions</code> contains the bounding box of the node, not the node’s exact measures. We can verify that by querying the node’s <code>width</code> instead:</p>
<pre class="source-code">
&gt;&gt;&gt; node_tree = C.object.active_material.node_tree
&gt;&gt;&gt; node_tree.nodes['Image Texture'].width
240.0</pre>
<p>Even if it is present, the <code>height</code> attribute does not help because it hasn’t been updated and its value stays fixed at <code>100.0</code>.</p>
<p>Despite that weakness in the API, we have enough information to rearrange our tree: leaving <code>100.0</code> units between two nodes leaves enough room for connections, so we can use a spacing of <code>340.0</code> units between our textures and the initial node.</p>
<p>We must store that value in the declaration of our operator:</p>
<pre class="source-code">
class AddTextures(bpy.types.Operator, ImportHelper):
    """Load and connect material textures"""
    bl_idname = "texture.textament_load"
    bl_label = "Load and connect textures"
    bl_description = "Load and connect material textures"
    <strong class="bold">_spacing = 340.0</strong></pre>
<p>To arrange <a id="_idIndexMarker838"/>our nodes vertically, we need to process them in the correct order.</p>
<h3>Sorting the node creation</h3>
<p>To space the <a id="_idIndexMarker839"/>nodes vertically in the correct way, we need to process them while following the sockets order in the target node layout; otherwise, the connection links will cross each other:</p>
<div><div><img alt="Figure 12.13: An unordered vertical arrangement leads to tangled, confusing links" height="885" src="img/Figure_12.13_B18375.jpg" width="996"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13: An unordered vertical arrangement leads to tangled, confusing links</p>
<p>Python dictionaries are unordered by design, so <code>matching_names</code> doesn’t follow any order, but the <code>input_names</code> list does. This list contains the ordered names of all sockets. By filtering it with <code>matching_names</code>, we can obtain an ordered list of the matching inputs:</p>
<pre class="source-code">
        sorted_inputs = [
              i for i in input_names if i in matching_names
             ]</pre>
<p>We must replace the <code>for inp, fname in matching_names.items()</code> loop with an <a id="_idIndexMarker840"/>iteration of <code>sorted_inputs</code>. Since we need an ordinal for vertical spacing, we must use <code>enumerate</code> to get the index of the current input. Here is the new image loop:</p>
<pre class="source-code">
        <strong class="bold">for i, inp in enumerate(sorted_inputs):</strong>
            img_path = os.path.join(self.directory,
                                    matching_names[inp])
            img = bpy.data.images.load(img_path,
                                       check_existing=True)
            if target_node.inputs[inp].type != 'RGBA':
                img.colorspace_settings.name = 'Non-Color'
            img_node = mat.node_tree.nodes.new(
                                      "ShaderNodeTexImage")
            img_node.image = img</pre>
<p>After a texture nodes is connected, we can change its location. We start with the same coordinates as <code>target_node</code>, then move the texture to the left by subtracting <code>_spacing</code> from <code>location.x</code>:</p>
<pre class="source-code">
            img_node.location = target_node.location
            img_node.location.x -= self._spacing</pre>
<p>We can move the texture nodes downwards by subtracting <code>self._spacing</code> from <code>location.y</code>. We are stacking the nodes vertically, so their <code>y</code> coordinates depend on their ordinal indexes. The first node, which has an index of <code>0</code>, will not move at all from the initial position, the second node moves down by <code>self._spacing</code> times <code>1</code>, the third by <code>self._spacing</code> times <code>2</code>, and so on:</p>
<pre class="source-code">
            img_node.location.y -= <code>i</code> * self._spacing</pre>
<p>Connecting <code>ShaderNodeNormalMap</code> requires horizontal space, so, after we align <code>normal_map</code> with its <code>img_node</code>, we must make some room by moving the texture to the left and <code>normal_map</code> to the right, by an amount of half <code>_spacing</code>:</p>
<pre class="source-code">
            normal_map = mat.node_tree.nodes.new(
                                      "ShaderNodeNormalMap"
                                     )
            normal_map.location = img_node.location
            <strong class="bold">img_node.location.x -= self._spacing / 2</strong>
            <strong class="bold">normal_map.location.x += self._spacing / 2</strong></pre>
<p>Now, we must <a id="_idIndexMarker841"/>save the add-on and update it by clicking <em class="italic">F3</em> and choosing <strong class="bold">Reload Scripts</strong>. Launching <strong class="bold">Load Textures</strong> sets up a properly arranged node tree:</p>
<div><div><img alt="Figure 12.14: Texture set up, with arranged nodes" height="924" src="img/Figure_12.14_B18375.jpg" width="943"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14: Texture set up, with arranged nodes</p>
<p>Now that the <a id="_idIndexMarker842"/>basic functionality is complete, we can implement an option for customizing the color of the material.</p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor325"/>Mixing the Base Color</h2>
<p>Sometimes, even <a id="_idIndexMarker843"/>if we are happy with our texture setup, we want to change <a id="_idIndexMarker844"/>the color while retaining the texture pattern. We can do that by adding a <strong class="bold">MixRGB</strong> node before the <strong class="bold">Base Color</strong> property of a principled node:</p>
<div><div><img alt="Figure 12.15: Affecting the material color with a MixRGB node" height="928" src="img/Figure_12.15_B18375.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15: Affecting the material color with a MixRGB node</p>
<p>The <strong class="bold">MixRGB</strong> node features a factor slider (<strong class="bold">Fac</strong>) for blending two colors. The default blending type, <strong class="bold">Mix</strong>, replaces <strong class="bold">Color1</strong> with <strong class="bold">Color2</strong>, but other blending modes known in computer graphics, such as <strong class="bold">Multiply</strong>, <strong class="bold">Overlay</strong>, and <strong class="bold">Color Dodge</strong>, are also available.</p>
<p>The Python setup for a <code>ShaderNodeMixRGB</code> node is similar to that of a <code>"Base Color"</code>, we create an intermediate node:</p>
<pre class="source-code">
            if inp == "Base Color":
                mix = mat.node_tree.nodes.new(
                                        "ShaderNodeMixRGB")</pre>
<p>Then, we align the image texture and the <strong class="bold">Mix</strong> node, and make room for additional connection links:</p>
<pre class="source-code">
                mix.location = img_node.location
                img_node.location.x -= self._spacing / 2
                mix.location.x += self._spacing / 2</pre>
<p>We connect the image color to the <code>"Color1"</code> input of the <strong class="bold">Mix</strong> node:</p>
<pre class="source-code">
                mat.node_tree.links.new(
                                 img_node.outputs["Color"],
                                 mix.inputs["Color1"])</pre>
<p>At this point, we <a id="_idIndexMarker845"/>would connect the <code>img_node</code> variable instead.</p>
<p>This way, the connection to <code>target_node</code> is made by the same line of code that connects all the other inputs except <code>"Normal"</code>:</p>
<pre class="source-code">
                img_node = mix
            if inp != "Normal":
                tree.links.new(tex_img.outputs["Color"],
                               target_node.inputs[inp])
                continue</pre>
<p>If we execute <strong class="bold">Reload Scripts</strong> and then launch <strong class="bold">Load Textures</strong> again, a mixed layout like the one displayed in <em class="italic">Figure 12</em><em class="italic">.15</em> is created. We can click on the <strong class="bold">Color2</strong> attribute and select a color from the picker or change the <strong class="bold">Mix</strong> node’s <strong class="bold">Blending Mode</strong> from its drop-down menu.</p>
<p>We can also experiment with different solutions. For instance, we can use <code>"ShaderNodeMixRGB"</code> with <code>"ShaderNodeHueSaturation"</code> and <code>"Color1"</code> with <code>"Color"</code>.</p>
<p>Node trees are interesting as they can be considered visual programming, but even the trivial operation of loading a few textures, if done manually, can take time.</p>
<p>This time, we didn’t have <a id="_idIndexMarker847"/>to create an interface for manipulating the blended <a id="_idIndexMarker848"/>color as the mix node already provides it, so we could combine the best of two procedural approaches.</p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor326"/>Summary</h1>
<p>In this chapter, we learned how materials work and how nodes are created and connected in the <strong class="bold">Shader Editor</strong> area. We also learned how image textures can change the appearance of shaded objects and how they can store non-color data.</p>
<p>This was our first encounter with node trees, a generic visual programming approach that is not limited to shaders and is planned to expand to deformation and rigging in the future.</p>
<p>Node-based systems are flexible and powerful, but they benefit from scripted tools, like all other aspects of Blender.</p>
<p>Rendering is not the final step of production as compositing and editing follow in the computer graphics pipeline. But since this stage converts three-dimensional data into images, it’s usually considered the last step of the 3D workflow.</p>
<p>That ends our journey into how Blender scripting works. We have covered object creation, deformation, animation, and rendering, but most importantly, how tools are designed and implemented, and how the software limitations can be overcome.</p>
<p>Those skills, combined with individual talent and experience, allow technical directors to bridge between artistic needs and software capabilities, empower their teams, and improve their abilities and understanding in the process.</p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor327"/>Questions</h1>
<ol>
<li>How many render engines are present in Blender?</li>
<li>Do the words <em class="italic">material</em> and <em class="italic">shader</em> have the same meaning?</li>
<li>Are the shader nodes predefined values that determine how objects look or separate units performing independent operations?</li>
<li>Can we use images for coloring objects?</li>
<li>Can we make connections between different data types?</li>
<li>How do we arrange nodes in a graph?</li>
<li>In our shaders, can we alter the colors coming from an image?</li>
</ol>
</div>
</div>

<div><div><h1 id="_idParaDest-311"><a id="_idTextAnchor328"/>Appendix</h1>
<p>Blender and Python are so vast that even writing scripts for a shortlist of use cases encompasses a wide range of skills and disciplines. This book contains elements of animation, rigging, and shading and introduces programming techniques while exploring those processes.</p>
<p>This appendix contains a comprehensive summary that can be useful as a recap to help with the retention of the concepts explored in this book and help the reader navigate through the chapters.</p>
<h1 id="_idParaDest-312"><a id="_idTextAnchor329"/>Part 1: An Introduction to Python</h1>
<p>This section covers the fundamentals of scripting and helps you become familiar with Blender’s Python utilities. Besides providing a solid base for the chapters ahead, it contains all the information required for writing fully working tools.</p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor330"/><a href="B18375_01.xhtml#_idTextAnchor014">Chapter 1</a>, Python’s Integration with Blender</h2>
<p>This chapter introduces the tools used for scripting, internal and external text editors, and version control.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Installing multiple versions of Blender on the main operating systems</h3>
<p>Blender 3.3 is the <em class="italic">long-term support</em> release used in the writing process. Although the content of this book is valid for all the 3. x series of blender, if you want to install version 3.3 alongside other versions, the following instructions are provided:</p>
<ul>
<li>Using Windows Installer</li>
<li>Using the Microsoft Store</li>
<li>Downloading a portable archive</li>
<li>Installing on macOS</li>
</ul>
<h3>Using Python in Blender</h3>
<p>The <strong class="bold">Scripting</strong> workspace is a Blender layout optimized for running Python quickly. It consists of an interactive console, a logger listing the commands of past actions, and a Text Editor that can run scripts. We will become familiar with it through these topics:</p>
<ul>
<li>Producing console output with the <em class="italic">“Hello </em><em class="italic">World!”</em> example</li>
<li>How to copy and paste Python instructions from the <strong class="bold">Info Log</strong></li>
<li>Checking the current version of Blender and Python using scripts</li>
<li>An explanation of functions and arguments</li>
</ul>
<h3>Using external editors and version control tools</h3>
<p>Even though the Text Editor is quick and useful, programmers usually take advantage of external code editors as well. <strong class="bold">Visual Studio Code</strong>, a multiplatform editor from <strong class="bold">Microsoft</strong>, is used in this book, but there are plenty of alternatives. <strong class="bold">Version control</strong> tools are useful tools that for storing the history of code changes. We learn how to use these tools by going through the following topics:</p>
<ul>
<li>Loading folders in Visual Studio Code</li>
<li>Refreshing text files in the Blender Text Editor</li>
<li>Initializing and using a <strong class="bold">Git</strong> repository</li>
</ul>
<h2 id="_idParaDest-314"><a id="_idTextAnchor331"/><a href="B18375_02.xhtml#_idTextAnchor033">Chapter 2</a>, Python Entities and API</h2>
<p>This chapter explains how to interact with Blender using scripts, how to take advantage of features for developers, and how the <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) works.</p>
<p>The following sections are a summary of the topics discussed in the chapter.</p>
<h3>User interface features for developers</h3>
<p>There are two useful options in the <strong class="bold">Interface</strong> section of Blender’s preferences:</p>
<ul>
<li><strong class="bold">Developer Extras</strong>: This displays the <strong class="bold">Edit Source</strong> option when we right-click on an element of the interface so that we can easily access the Python source code of the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). It also makes non-UI operators available in the search bar.</li>
<li><strong class="bold">Python Tooltips</strong>: This displays the Python property relative to the UI element under the mouse cursor.</li>
</ul>
<h3>Console features for developers</h3>
<p>The interactive console provides two handy features for quick scripting:</p>
<ul>
<li>Code auto-completion by pressing the <em class="italic">Tab</em> key</li>
<li>Commands history by pressing the Up-arrow key</li>
</ul>
<h3>Viewport features for developers</h3>
<p>The <strong class="bold">Math Vis (Console)</strong> add-on included with Blender and available in the <strong class="bold">3D View</strong> section of the <strong class="bold">Preferences</strong> &gt; <strong class="bold">Add-ons</strong> dialog displays three-dimensional mathematical entities such as <em class="italic">vectors</em> and <em class="italic">matrices</em> in the 3D Viewport. It can be useful when working with object location and rotation values.</p>
<h3>Using Blender modules</h3>
<p>Blender’s Python module, <code>bpy</code>, is accessed in scripts using the <code>import</code> statement. Each of its components covers a specific aspect of the 3D app. Most notably, <code>data</code> contains all the objects available in the current session, while <code>context</code> contains the current state of the user interaction, such as the current selection. The API documentation is available online but can also be viewed using the <code>help()</code> function.</p>
<h3>Using object collections</h3>
<p>Lists of objects are accessed through <code>bpy_collection</code>, an aggregate type similar to a Python <code>dictionary</code>. Elements of a collection can be accessed with numeral indices or keywords and can be iterated in Python loops.</p>
<p>Operations such as renaming can reorder the elements of a collection, so a conversion to <code>list</code> is advised when the order is critical.</p>
<p>Blender collections don’t have an <code>append()</code> method: the <code>new()</code> method is used for creating a new object, which is automatically appended. The <code>remove()</code> method removes an element from a collection and deletes it from Blender.</p>
<h3>Context and user activity</h3>
<p>Users can change the current state or context of Blender by adding or selecting objects. The last selected object is considered <em class="italic">active</em> and is the main target of object-related actions.</p>
<p>Context information is available as properties of <code>bpy.context</code>, is read-only, and can only be changed indirectly. For instance, <code>ob.select_set(True)</code> is used to select an object, as it’s impossible to append to the <code>bpy.context.selected_objects</code> list.</p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor332"/><a href="B18375_03.xhtml#_idTextAnchor049">Chapter 3</a>, Creating Your Add-Ons</h2>
<p>This chapter illustrates the process of creating Blender add-ons: Python scripts that can be installed as Blender plugins to add custom functions.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Writing scripts that are add-ons</h3>
<p>Add-ons are Python modules or packages containing a dictionary named <code>bl_info</code>. This dictionary contains information such as the author and name of the add-on. Add-ons must provide two functions, <code>register()</code> and <code>unregister()</code>, used when an add-on is enabled or disabled.</p>
<p>Add-ons can be installed in Blender preferences, but setting the folder where they are developed as <code>Reload Scripts</code> in the <em class="italic">F3</em> key search bar.</p>
<h3>Writing Object Collector, an add-on that groups objects in the Outliner</h3>
<p>Adding features to Blender involves the creation of an operator, that is, an instruction that can be launched from the user interface. The <code>bl_idname</code> and <code>bl_label</code> attributes determine how an operator is found and displayed in Blender, while the <code>poll()</code> and <code>execute()</code> functions regulate when it can be launched and what happens when it runs.</p>
<p>Add-ons add operators to Blender in their <code>register()</code> and <code>unregister()</code> functions.</p>
<h3>Tips for working on add-ons</h3>
<p>When using an external editor, enabling auto-save might help ensure that the Python script always includes the latest changes.</p>
<p>Enabling add-ons from the development folder might leave <em class="italic">bytecode</em>, that is, Python-compiled files in a folder named <code>__pycache__</code>. If we use Git version control, we can create a text file named <code>.gitignore</code> that contains <code>__pycache__</code> to avoid bytecode files ever being versioned.</p>
<h3>Avoiding duplicates using try and except</h3>
<p>To prevent our script from creating the same collection twice, resulting in duplicates, we look for a collection inside a <code>try</code> statement and add an <code>except KeyError</code> block that is triggered when no collection is found. By creating new collections under the <code>except</code> statement, we ensure that collections with a given name are only created once. The try/except pattern is called <em class="italic">forgiveness rather than permission</em>, as it focuses on pulling back from non-allowed actions rather than checking whether an action is possible in the first place.</p>
<p>We use the <code>title()</code> string method for nicely formatted names with a capital first letter. We can create functions for adding our operator to Blender menus. They accept the <code>self</code> and <code>context</code> arguments and add operators to <code>self.layout</code>. Menu functions are added to Blender in the <code>register()</code> and <code>unregister()</code> functions of the add-on.</p>
<h2 id="_idParaDest-316"><a id="_idTextAnchor333"/><a href="B18375_04.xhtml#_idTextAnchor075">Chapter 4</a>, Exploring Object Transformations</h2>
<p>This chapter shows how to affect <code>location</code>, <code>rotation</code>, and <code>scale</code> of an object using Python and how the transform information is stored in Blender.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Moving and scaling objects with Python</h3>
<p><code>location</code> is stored as the <code>x</code>, <code>y</code>, and <code>z</code> coordinates of a three-dimensional vector. The coordinates of a vector can be changed individually or together, using tuple assignment.</p>
<p><code>scale</code> is stored as an <code>x</code>, <code>y</code>, <code>z</code> vector too. While the rest value of <code>location</code> has the <code>(0.0, 0.0, 0.0)</code> coordinates, a non-scaled object’s <code>scale</code> attribute is <code>(1.0, </code><code>1.0, 1.0)</code>.</p>
<h3>Peculiarities of rotations</h3>
<p>Rotations are less straightforward than <code>location</code> and <code>scale</code>, as the <code>rotation</code> values over the three axes can affect each other, causing an issue known as <em class="italic">gimbal lock</em>.</p>
<p>There is more than one way to represent rotations; some involve multidimensional entities such as quaternions or rotation matrices, and two measure units for angles: <em class="italic">degrees</em> and <em class="italic">radians</em>. Blender objects have attributes for each notation system, which can be set via Python. Conversion utilities are provided for switching from one notation system to another.</p>
<h3>Indirect transformations with parents and constraints</h3>
<p>Objects can be arranged in hierarchies. Transformations of an object higher in the hierarchy (<em class="italic">parent</em>) affect all the objects under them (<em class="italic">children</em>).</p>
<p>Constraints are another way to transform an object without affecting its channels. They can be added using the <code>new()</code> method of the <code>constraints</code> collection.</p>
<h3>Transforming objects with matrices</h3>
<p>Setting values for the <code>location</code>, <code>rotation</code>, and <code>scale</code> channels affects the relative coordinates of an object. Assigning a transformation matrix allows us to use world-space coordinates instead. Matrix values are lazy-copied unless stated otherwise; if we store a matrix as a variable and don’t want its values to change we need to use its <code>copy()</code> method.</p>
<p>Parenting to a transformed object in Python changes the object location unless a reverse transformation is set in the <code>matrix_parent_inverse</code> attribute.</p>
<h3>Writing Elevator, an add-on that sets a floor for the selected objects</h3>
<p>The operator from the <code>FloatProperty</code> that can be set when it’s launched. Optional behaviors can be enabled by switching its <code>BoolProperty</code> members.</p>
<p>Editable properties must be added as <em class="italic">annotations</em>, Python arbitrary attributes.</p>
<p>Parent objects at the top of the hierarchy are moved first to avoid duplicate transformations. Constraints can be used optionally.</p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor334"/><a href="B18375_05.xhtml#_idTextAnchor100">Chapter 5</a>, Designing Graphical Interfaces</h2>
<p>This chapter explains how to add custom panels and add them to the Blender interface.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Components of the UI</h3>
<p>The Blender window is structured into areas, regions, and panels. Panels have a layout that is populated with text, icons, and buttons using Python.</p>
<h3>Writing the Simple Panel add-on</h3>
<p>This add-on registers a simple <code>Panel</code> class that displays text and icons in the <code>row()</code> or <code>column()</code>methods, non-uniform columns using <code>split()</code>, and uniform tables using <code>grid_flow()</code>.</p>
<p>Blender icon names can be looked up using the <strong class="bold">Icon Viewer</strong> add-on or, in some cases, built using Python’s string formatting.</p>
<p>Red and gray colors can be used to give visual feedback using the <code>alert</code> or <code>enabled</code> flags of a widget.</p>
<p>Operators added to a layout using the <code>operator()</code> method are displayed as buttons.</p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor335"/>Part 2: Interactive Tools and Animation</h1>
<p>This section explains how to write add-ons as folders rather than single files, interact with the animation system, and write modal operators that wait for user input. By the end of this section, you will be able to write advanced, interactive tools.</p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor336"/><a href="B18375_06.xhtml#_idTextAnchor129">Chapter 6</a>, Structuring Our Code and Add-Ons</h2>
<p>This chapter explains how to write and distribute addons containing multiple files in a folder.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>The relationship between modules, packages, and add-ons</h3>
<p>While a single <code>.py</code> file is a Python module, a folder containing <code>.py</code> files is a Python package. Packages contain a file named <code>__init__.py</code>. If our package is an add-on, this file must contain the <code>bl_info</code> dictionary.</p>
<h3>Guidelines for partitioning code</h3>
<p>Some criteria for separating the code through different <code>.py</code> files are as follows:</p>
<ul>
<li>Media loaders</li>
<li>Generic code versus specific code</li>
<li>Interface code</li>
<li>Operator modules</li>
<li>Use of imported modules</li>
</ul>
<p>For example, all the code used for loading custom icons, as explained in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, can be moved to a module named <code>img_loader.py</code>.</p>
<p>Only <code>__init__.py</code> is reloaded by the <code>importlib.reload()</code> function.</p>
<p>A panel to display the add-on preferences can be written in a <code>preferences.py</code> file, while <code>panel.py</code> and <code>operators.py</code> contain, respectively, the UI and the add-on operators.</p>
<p>Add-on folders compressed as <code>.zip</code> archives can be installed using the <strong class="bold">Preferences</strong> | <strong class="bold">Addons</strong> | <strong class="bold">Install</strong> button.</p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor337"/><a href="B18375_07.xhtml#_idTextAnchor171">Chapter 7</a>, The Animation System</h2>
<p>This chapter explains how to animate objects in Blender and how to create and edit animations with Python.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>The Animation system</h3>
<p>The <strong class="bold">Layout</strong> and <strong class="bold">Animation</strong> Workspaces display animation keyframes on a <strong class="bold">Timeline</strong> including the scene actions, keyframes, and range. Keyframes establish the value of a property at a certain time.</p>
<h3>Writing the Action to Range add-on</h3>
<p>This add-on sets the start and end of the playback to the first and last frame of the current action of the active object. If a timeline is displayed onscreen, it is recentered to the new range. To do that, <code>context.temp_override()</code> is used to pass a timeline region to the <code>bpy.ops.action.view_all()</code> factory operator.</p>
<h3>Writing the Vert Runner add-on</h3>
<p>This add-on animates the selected objects along the vertices of the active object. The vertex coordinates stored in <code>context.object.data.vertices</code> are read, while trigonometric functions are used for computing the shortest rotation arc that orients an object toward its next position.</p>
<h2 id="_idParaDest-321"><a id="_idTextAnchor338"/><a href="B18375_08.xhtml#_idTextAnchor206">Chapter 8</a>, Animation Modifiers</h2>
<p>This chapter covers non-destructive modifiers for animation f-curves and their use in animating procedural effects.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Adding f-curve modifiers</h3>
<p>F-curve modifiers can be added by selecting a curve in the graph editor and clicking <code>new()</code> method from the <code>modifiers</code> collection of f-curves.</p>
<h3>Writing the Shaker add-on</h3>
<p>This add-on uses a <strong class="bold">Noise</strong> f-modifier to add a trembling effect on the active object and allows to set the duration and amount of the trembling. <em class="italic">Soft limits</em> set an initial limitation on the noise strength parameter while still allowing you to type out-of-range values using the keyboard. We add a menu entry for invoking this operator using the right-click menu in the Viewport.</p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor339"/><a href="B18375_09.xhtml#_idTextAnchor226">Chapter 9</a>, Animation Drivers</h2>
<p>This chapter introduces animation drivers, which are the connections between different properties used to control complex actions. Drivers can incorporate short Python expressions in their logic.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Creating and setting drivers</h3>
<p>Drivers can be created quickly by selecting <strong class="bold">Copy As New Driver</strong> and <strong class="bold">Paste Driver</strong> from the right-click menu of Blender properties. Using an object’s location as input for its rotation creates a wheel setup since the object rotates when it’s moved.</p>
<h3>Using Python drivers</h3>
<p>Python expression-based drivers can be created quickly by pressing the <em class="italic">#</em> key, followed by Python code while editing a Blender property. Oscillatory motions can be created using trigonometric cyclic functions such as <code>sin</code>, and the pendulum equation from the physics classroom can be implemented as a driver expression. Object custom properties can be used as parameters in driver expressions.</p>
<h3>Writing the Pendulum add-on</h3>
<p>This add-on instantly sets up the pendulum expression and parameters. Drivers are added using the <code>object.driver_add()</code> method.</p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor340"/><a href="B18375_10.xhtml#_idTextAnchor247">Chapter 10</a>, Advanced and Modal Operators</h2>
<p>This chapter explains how to write advanced operators by enriching their execution flow and implementing optional methods.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Operator execution details</h3>
<p>The <code>invoke()</code> method of <code>Operator</code>, if defined, runs when the operator is launched. Inside <code>invoke()</code>, we can switch either to the <code>execute()</code> method or to the <code>modal()</code> method. The latter listens to user inputs such as key presses or mouse movements.</p>
<h3>Writing the PunchClock add-on</h3>
<p>This add-on creates time-formatted text in the scene. Its operator sets the initial values of its hour and minute parameters in <code>invoke()</code> using Python <code>datetime</code> utilities. When adding the operator to a menu, <code>operator_context</code> of the layout is set to <code>"INVOKE_DEFAULT"</code> so that the execution of <code>invoke()</code> is never skipped.</p>
<h3>Modal behavior</h3>
<p>The operator is added to the modal handlers so that its <code>modal()</code> method is run at every update of the UI. Inside the modal, the <code>"MOUSEMOVE"</code> events change the displayed hour and minute.</p>
<h3>Customizing the undo panel</h3>
<p>The undo panel displays the operator properties after the execution is customized by implementing the <code>draw()</code> method. With this method, we can design a graphic interface using the same techniques learned in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>.</p>
<h1 id="_idParaDest-324"><a id="_idTextAnchor341"/>Part 3: Delivering Output</h1>
<p>This section covers the final stages of the 3D pipeline: deformation and rendering.</p>
<h2 id="_idParaDest-325"><a id="_idTextAnchor342"/><a href="B18375_11.xhtml#_idTextAnchor265">Chapter 11</a>, Object Modifiers</h2>
<p>This chapter covers object modifiers and their use in animation.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>Adding object modifiers</h3>
<p>Modifiers are grouped into four categories: <strong class="bold">Modify</strong>, <strong class="bold">Generate</strong>, <strong class="bold">Deform</strong>, and <strong class="bold">Physics</strong>. They are created by clicking the <strong class="bold">Add Modifier</strong> button in the <strong class="bold">Modifiers</strong> property.</p>
<h3>Adding modifiers in Python</h3>
<p>The <code>new()</code> method of the <code>object.modifiers</code> collection requires the <code>type</code> modifier as an argument. A list of the possible <code>type</code> keywords can be found by accessing the <code>bpy.types.ObjectModifiers.bl_rna.functions["new"]</code> function and querying its <code>parameters["type"].enum_items</code>.</p>
<h3>Writing the Latte Express add-on</h3>
<p>This add-on sets up a <strong class="bold">Lattice</strong> modifier to deform an object using a three-dimensional grid cage. It finds the center of the model by querying its bounding box and has input parameters for changing the lattice and the object’s resolutions.</p>
<h3>Using armature deformers</h3>
<p>Armatures affect characters using a deformation skeleton. Bones can be created in Python using <code>object.data.edit_bones.new()</code> after switching to <code>bpy.ops.object.mode_set()</code>.</p>
<p>Vertex groups are created on the lattice object to bind the lattice vertices to the armature bones. This way, a lattice deformed by an armature can be created via a script.</p>
<h3>Creating control shapes</h3>
<p>Replacing the default octahedral shape with custom wireframe shapes makes an armature more animator friendly. For that reason, a simple mesh can be created in Python using the <code>mesh.from_pydata</code> method, and assigned to the <code>pose_bone.custom_shape</code> attribute.</p>
<h2 id="_idParaDest-326"><a id="_idTextAnchor343"/><a href="B18375_12.xhtml#_idTextAnchor304">Chapter 12</a>, Rendering and Shaders</h2>
<p>This chapter introduces rendering and materials, the shader editor, and its node tree. Although some steps such as post-processing and video encoding may follow, rendering is commonly regarded as the last stage of a 3D process.</p>
<p>Here’s a summary of the topics discussed in the chapter.</p>
<h3>How rendering works</h3>
<p>A render engine such as Blender’s <strong class="bold">Eevee</strong> or <strong class="bold">Cycles</strong> converts the 3D geometry to finished images using <em class="italic">shaders</em> to determine how objects look. Blender shaders are networks of operations called nodes, that is, blocks that elaborate and exchange color and geometry information by connecting their input/output sockets.</p>
<h3>Writing the Textament add-on</h3>
<p>This add-on imports images from disk and creates the <code>ImportHelper</code> and <code>Operator</code>, and display the Blender file browser when invoked. The files the user selecteds are accessed as the <code>directory</code> and <code>files</code> member attributes.</p>
<h3>Looking for case-insensitive matches in file names</h3>
<p>Uppercase letters and spaces might cause unwanted mismatches, such as the <code>"base color"</code> strings not being associated with <code>"Base Color"</code>. A function for string manipulation can be written with the usual syntax or defined in one line using a <code>lambda</code> expression. Removing all spaces and converting all letters to lowercase becomes the following:</p>
<p><code>lambda x : x.lower().replace(" ", "")</code></p>
<h3>Non-color data in images</h3>
<p>Images can contain geometric or masking information. In that case, the <code>colorspace_setting.name</code> image attribute must be set to <code>"Non-Color"</code>, or Blender will apply color filters that pollute the information.</p>
<h3>Connecting images in shaders</h3>
<p>Creating a <code>"ShaderNodeTexImage"</code> as an argument of <code>node_tree.nodes.new("ShaderNodeTexImage")</code> allows you to use images in shaders. The connection between a texture node and a shader node input is created using <code>node_tree.links.new()</code>.</p>
<p><em class="italic">Normal map</em> textures give the illusion of detail. They must connect to <strong class="bold">Normal Map</strong>, which is then connected to the <strong class="bold">Normal</strong> input of a shader.</p>
<h3>Adding custom buttons to headers</h3>
<p>Operators can be added to headers in the same way as they are added to menus: using a function that takes the <code>self</code> and <code>context</code> arguments, and adds elements to <code>self.layout</code>. This function is appended to a <em class="italic">Header Type</em> in the <code>register()</code> function of the add-on.</p>
<h3>Arranging nodes in the node editor</h3>
<p>Nodes created in Python are positioned at the center of the editor and overlap each other. They can be moved by setting their <code>location</code> <code>x</code> and <code>y</code> coordinates. They should be placed on the left-hand side of their output node and sorted vertically according to the order of their output node sockets.</p>
<h3>Altering texture colors</h3>
<p>The color of a texture can be manipulated by adding a <strong class="bold">Mix</strong> node between a texture and its output node. That allows you to change the overall color of an object while retaining the details coming from the image.</p>
</div>
</div></body></html>