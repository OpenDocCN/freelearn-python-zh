<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer219">
<h1 class="chapter-number" id="_idParaDest-289"><a id="_idTextAnchor304"/>12</h1>
<h1 id="_idParaDest-290"><a id="_idTextAnchor305"/>Rendering and Shaders</h1>
<p>A process called <em class="italic">rendering</em> generates the pixels of finished images by evaluating the geometries, lights, and camera of <span class="No-Break">the scene.</span></p>
<p>The renderers, or Render Engines, that handle those computations can be external programs, independent from the 3D application, or fully integrated features of the animation package. All renderers have strong and weak points and can be grouped into two categories: real time, which assume a few approximations to achieve immediate visualization, and offline, which take more time to take more details <span class="No-Break">into account.</span></p>
<p>To generate images, renderers rely on shaders – that is, instructions on how an object reacts to the light and position of the observer, and how that translates into the <span class="No-Break">rendered pixels.</span></p>
<p>Shaders can be complex and are a discipline of their own, but the basic concept of how they work is not hard <span class="No-Break">to grasp.</span></p>
<p>In this chapter, you will learn where to set the render properties, how to automate the creation of shaders using Python, and how to use the <strong class="bold">File Browser</strong> for <span class="No-Break">loading images.</span></p>
<p>This chapter covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding the <span class="No-Break">materials system</span></li>
<li>Loading images in the <span class="No-Break">Shader Editor</span></li>
<li>Connecting and arranging <span class="No-Break">shader nodes</span></li>
</ul>
<h1 id="_idParaDest-291"><a id="_idTextAnchor306"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created for this chapter, along with the media files, can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor307"/>Render and materials</h1>
<p>Blender comes with two render engines: <strong class="bold">Eevee</strong>, the real-time renderer that can be used in the Viewport, and <strong class="bold">Cycles</strong>, an offline renderer. Additional engines, including most of the commercial offerings, can be installed in the form of render add-ons. A third option, <strong class="bold">Workbench</strong>, can be used for quickly and simply displaying renders in <span class="No-Break">the Viewport.</span></p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor308"/>Setting the Render Engine</h2>
<p>The current <strong class="bold">Render Engine</strong>, along <a id="_idIndexMarker779"/>with other render settings, can be found in the scene <strong class="bold">Render</strong> properties. It’s the first tab and is marked with an icon of a <span class="No-Break">TV set:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 12.1: Selecting the current Render Engine" height="317" src="image/Figure_12.01_B18375.jpg" width="396"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Selecting the current Render Engine</p>
<p>While <strong class="bold">Workbench</strong> is designed to have only a few render options and no shading system, <strong class="bold">Eevee</strong> and <strong class="bold">Cycles</strong> can combine images, colors, and attributes using a node-based system. This can be done in the <strong class="bold">Shader Editor</strong> area, available in the <span class="No-Break"><strong class="bold">Shading</strong></span><span class="No-Break"> workspace.</span></p>
<h2 id="_idParaDest-294"><a id="_idTextAnchor309"/>The Shading workspace</h2>
<p>Shading involves <a id="_idIndexMarker780"/>disparate activities, such as accessing image files, checking the Viewport, and editing object properties. Once we set our <strong class="bold">Render Engine</strong> to Eeeve, Cycles, or an external engine that supports Blender’s shading system, we can carry out those tasks in the <strong class="bold">Shading</strong> workspace. It contains <span class="No-Break">the following:</span></p>
<ul>
<li>A <strong class="bold">File Browser</strong> for <span class="No-Break">importing images</span></li>
<li>The <strong class="bold">3D Viewport</strong> area for checking <span class="No-Break">the materials</span></li>
<li><span class="No-Break">An </span><span class="No-Break"><strong class="bold">Outliner</strong></span></li>
<li>Data <strong class="bold">Properties</strong>; by default, the <strong class="bold">World</strong> settings tab <span class="No-Break">is active</span></li>
<li>The <strong class="bold">Shaders </strong><span class="No-Break"><strong class="bold">Editor</strong></span><span class="No-Break"> area</span></li>
<li>The <strong class="bold">Image </strong><span class="No-Break"><strong class="bold">Editor</strong></span><span class="No-Break"> area:</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 12.2: The Shading workspace" height="928" src="image/Figure_12.02_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: The Shading workspace</p>
<p>The default material <a id="_idIndexMarker781"/>presents a few color attributes that can be set in the <strong class="bold">Material Properties</strong> area. To understand how to script articulated materials with a proper layout, we will provide a brief overview of how the shader components come together in the <span class="No-Break">shader graph.</span></p>
<h2 id="_idParaDest-295"><a id="_idTextAnchor310"/>Understanding object materials</h2>
<p>We can change the overall look of an object by specifying its material. The term <em class="italic">material</em> follows <a id="_idIndexMarker782"/>the analogy of real-world objects, whose look is affected by the material of which they are made <span class="No-Break">or coated.</span></p>
<p>Object materials can be edited in the <strong class="bold">Material Properties</strong> area. In version 3.3, it’s the second-to-last property tab, marked with an icon of a sphere with a checkerboard pattern, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-296"><a id="_idTextAnchor311"/>Setting Material Properties</h2>
<p>Materials exist <a id="_idIndexMarker783"/>independently from objects. One material can be shared among multiple objects and an object can have more materials assigned to different sets <span class="No-Break">of faces.</span></p>
<p>Scrolling down to the material <strong class="bold">Settings</strong>, we can edit how the material is processed by Blender – for instance, how its transparent parts are rendered over <span class="No-Break">the background:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 12.3: Settings in the Material Properties area" height="620" src="image/Figure_12.03_B18375.jpg" width="396"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: Settings in the Material Properties area</p>
<p>The properties commonly associated with actual materials, such as roughness, color, and transparency, are displayed in the <strong class="bold">Surface</strong> panel. Those properties are part of the <strong class="bold">shader</strong>, a generic algorithm <a id="_idIndexMarker784"/>used for computing how a surface should look. Every material has a shader associated <span class="No-Break">with it.</span></p>
<p>Shaders introduce <a id="_idIndexMarker785"/>a new concept to this book: a visual framework known <a id="_idIndexMarker786"/>as the <strong class="bold">nodes tree</strong>. We can learn how it works by looking at the <strong class="bold">Shader </strong><span class="No-Break"><strong class="bold">Editor</strong></span><span class="No-Break"> area.</span></p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor312"/>The Shader Editor</h1>
<p>The shading system <a id="_idIndexMarker787"/>supports different styles: realistic, cartoon, or technical drawings, to mention a few. Rather than providing a single interface with defined widgets, the functionalities <a id="_idIndexMarker788"/>of a renderer are scattered through interconnecting units <span class="No-Break">called </span><span class="No-Break"><strong class="bold">nodes</strong></span><span class="No-Break">.</span></p>
<p>Much like a function, a node performs a specific operation on one or more inputs and makes the results available through one or more outputs. Nodes are visual representations of functions, allowing non-programmers to combine logic blocks to get <span class="No-Break">custom results.</span></p>
<p>Nodes are not unique to shading – they are used for <strong class="bold">Compositing</strong> and for generating meshes in the <strong class="bold">Geometry </strong><span class="No-Break"><strong class="bold">Nodes</strong></span><span class="No-Break"> modifier.</span></p>
<p>By default, a Blender material presents a <strong class="bold">Material Output</strong> node in the <strong class="bold">Shader Editor</strong> area, with a <strong class="bold">Principled BSDF</strong> node as its <strong class="bold">Surface</strong> input. <strong class="bold">Bidirectional Scattering Distribution Function</strong> (<strong class="bold">BSFD</strong>) is a mathematical model of how a surface receives and reflects light <a id="_idIndexMarker789"/>rays. It is a form of <strong class="bold">Physically-Based Rendering</strong> (<strong class="bold">PBR</strong>), an approach based on how visual properties <a id="_idIndexMarker790"/>such as color, roughness, and permeability interact with light in the <span class="No-Break">real world.</span></p>
<p><strong class="bold">Material Output</strong> is the last node of the graph and transfers the shading to <span class="No-Break">an object.</span></p>
<p>Only one output can be <a id="_idIndexMarker791"/>active at any time, so the shader graph is also called the <strong class="bold">Node Tree</strong>, with the output as the root from which all the other <span class="No-Break">branches stem.</span></p>
<h2 id="_idParaDest-298"><a id="_idTextAnchor313"/>Understanding the Node Tree</h2>
<p>The inputs and <a id="_idIndexMarker792"/>outputs of a node are displayed as colored circles <a id="_idIndexMarker793"/>called <strong class="bold">sockets</strong>. Input sockets are on the left-hand <a id="_idIndexMarker794"/>side of the node, while output sockets are on the right. Their color depends on the data type of the socket. For instance, the <strong class="bold">Base Color</strong> socket of a <strong class="bold">Principled</strong> node, which is yellow, assigns a color to a material, while <strong class="bold">Roughness</strong>, a gray socket, is a float number to denote how far from smooth <span class="No-Break">it is.</span></p>
<p>Purple sockets, such as <strong class="bold">Normal</strong>, are vectors and can contain <span class="No-Break">directional data.</span></p>
<p>Output sockets are on the right-hand side of a node, and can be connected, or linked, to the input sockets on the left-hand side of <span class="No-Break">another node:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 12.4: A principled node receiving color, roughness, and normal inputs" height="705" src="image/Figure_12.04_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: A principled node receiving color, roughness, and normal inputs</p>
<p>So, the color attribute of a <strong class="bold">Base Color</strong> is an input socket and can be connected to any color output from another node. For instance, the input of a <strong class="bold">Principled</strong> node’s <strong class="bold">Base Color</strong> can come from an <strong class="bold">RGB</strong> node, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.4</em>, but also from an <strong class="bold">Image Texture</strong>, as shown in <span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 12.5: A principled node, with an image as the input of Base Color" height="631" src="image/Figure_12.05_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5: A principled node, with an image as the input of Base Color</p>
<p class="callout-heading">Connection is conversion!</p>
<p class="callout">We can connect sockets of different types, such as vectors and colors; the data is converted automatically. The <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> vector components are converted into the red, green, and blue elements of color, while the brightness of colors is converted into <span class="No-Break">float values.</span></p>
<p>Now that we know <a id="_idIndexMarker795"/>how materials work, we will write a script that helps <a id="_idIndexMarker796"/>load <span class="No-Break"><strong class="bold">Image Textures</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-299"><a id="_idTextAnchor314"/>Writing the Textament add-on</h1>
<p>While creating a <a id="_idIndexMarker797"/>shader can take time, we can automate some of the simpler operations. For instance, we can write an add-on to ease the task of loading images from disk and connecting them to <span class="No-Break">the shader.</span></p>
<h2 id="_idParaDest-300"><a id="_idTextAnchor315"/>Using texture images</h2>
<p>With the <strong class="bold">Texture Image</strong> node, we <a id="_idIndexMarker798"/>can use an image for coloring an object. That adds variation to how a material looks, as images can vary along the extension of an object and are not limited to a <span class="No-Break">single color:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube" height="928" src="image/Figure_12.06_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6: An image texture of a Rubik’s cube, applied to a plain cube</p>
<p>The operator that we are going to write will load multiple images from disk and guess their usage <a id="_idIndexMarker799"/>from the image’s filename. For instance, an image named <strong class="source-inline">Metallic.png</strong> would be loaded as a <strong class="bold">Texture Image</strong> and connected to the <strong class="bold">Metallic</strong> input of a <span class="No-Break"><strong class="bold">Principled</strong></span><span class="No-Break"> node.</span></p>
<p>As usual, we will set up an environment for developing a <span class="No-Break">new add-on.</span></p>
<h2 id="_idParaDest-301"><a id="_idTextAnchor316"/>Setting up the environment</h2>
<p>We will create <a id="_idIndexMarker800"/>a Python script for our add-on and make it known to Blender by performing <span class="No-Break">these steps:</span></p>
<ol>
<li>Create a folder called <strong class="source-inline">PythonScriptingBlender/ch12/addons</strong>. We can use the file manager or the file tab of our IDE for this, such as <span class="No-Break"><strong class="bold">VS Code</strong></span><span class="No-Break">.</span></li>
<li>Create a new file in that folder and name it <strong class="source-inline">textament.py</strong>. We can use the file manager or the <strong class="bold">New File</strong> button of our IDE to <span class="No-Break">do this.</span></li>
<li>Open the file in your editor <span class="No-Break">of choice.</span></li>
<li>Set the <strong class="bold">Scripts</strong> path to <strong class="source-inline">PythonScriptingBlender/ch12</strong> in Blender’s <strong class="bold">File </strong><span class="No-Break"><strong class="bold">Paths</strong></span><span class="No-Break"> preferences.</span></li>
<li>Restart Blender <a id="_idIndexMarker801"/>to update the <span class="No-Break">search paths.</span></li>
</ol>
<p>Now, we will start writing the add-on information <span class="No-Break">as usual.</span></p>
<h3>Writing the Textament add-on information</h3>
<p>In the information, we <a id="_idIndexMarker802"/>must specify what the add-on is for and where its tools can <span class="No-Break">be found:</span></p>
<pre class="source-code">
bl_info = {
    "name": "Textament",
    "author": "Packt Man",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Load and connect node textures",
    "location": "Node-Graph header",
    "category": "Learning"
}</pre>
<p>The add-on contains just one class – an import operator for <span class="No-Break">loading images.</span></p>
<h2 id="_idParaDest-302"><a id="_idTextAnchor317"/>Writing an import operator</h2>
<p>Our operator <a id="_idIndexMarker803"/>loads the image textures from <a id="_idIndexMarker804"/>disk, so we will need the <strong class="source-inline">os</strong> module to handle disk paths. Besides <strong class="source-inline">bpy</strong>, this operator will inherit from the <strong class="source-inline">ImportHelper</strong> utility class so that it can access Blender’s <span class="No-Break"><strong class="bold">File Browser</strong></span></p>
<pre class="source-code">
import os
import bpy
<strong class="bold">from bpy_extras.io_utils import ImportHelper</strong></pre>
<p>Operators that <a id="_idIndexMarker805"/>derive from <strong class="source-inline">ImportHelper</strong> store <a id="_idIndexMarker806"/>the selected file paths in a few <span class="No-Break">extra properties.</span></p>
<h3>Using Blender’s File Browser</h3>
<p>Like all operators, <strong class="source-inline">AddTextures</strong> is based on <strong class="source-inline">bpy.types.Operator</strong>, but since it operates <a id="_idIndexMarker807"/>on files, it inherits from the <strong class="source-inline">ImportHelper</strong> class too. By inheriting from both classes, when it is launched, <strong class="source-inline">AddTextures</strong> runs the <strong class="source-inline">invoke</strong> method of <strong class="source-inline">ImportHelper</strong>, which opens the <strong class="bold">File Browser</strong>. After a choice is made, our <strong class="source-inline">execute</strong> method runs <span class="No-Break">as usual:</span></p>
<pre class="source-code">
Class AddTextures(bpy.types.Operator, <strong class="bold">ImportHelper</strong>):
    """Load and connect material textures"""
    bl_idname = "texture.textament_load"
    bl_label = "Load and connect textures"
    bl_description = "Load and connect material textures"</pre>
<p>Deriving from <strong class="source-inline">ImportHelper</strong> adds a <strong class="source-inline">filepath</strong> attribute to <strong class="source-inline">AddTexture</strong>, in which the path to the selected file <span class="No-Break">is stored.</span></p>
<p>The <strong class="source-inline">filepath</strong> attribute stores the disk path to a single file, which is not enough in our case as we intend to load multiple files at once. For that reason, we need to store the selected <strong class="source-inline">directory</strong> in a <strong class="source-inline">StringProperty</strong>, and the selected <strong class="source-inline">files</strong> as a collection <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">OperatorFileListElement</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    <strong class="bold">directory</strong>: bpy.props.StringProperty()
    <strong class="bold">files</strong>: bpy.props.<strong class="bold">CollectionProperty</strong>(
                    name="File Path",
            <a id="_idTextAnchor318"/>        type=bpy.types.<strong class="bold">OperatorFileListElement</strong>,
                   )</pre>
<p>In another <strong class="source-inline">StringProperty</strong>, <strong class="source-inline">filter_glob</strong>, set the extensions of the files that should be displayed in the <strong class="bold">File Browser</strong> – in our case, <strong class="source-inline">.png</strong> and <strong class="source-inline">.jpg</strong> images. This property is <strong class="source-inline">"HIDDEN"</strong>: we don’t want it to show up in the <span class="No-Break">operator’s options:</span></p>
<pre class="source-code">
    filter_glob: bpy.props.StringProperty(
                                    default="*.png; *.jpg",
                                    options={"HIDDEN"})</pre>
<p>Now, we can <a id="_idIndexMarker808"/>write the operator method. We will start with <strong class="source-inline">poll</strong>, the method that checks if the operator can <span class="No-Break">be launched.</span></p>
<h3>Checking the existence of an active node</h3>
<p>This operator <a id="_idIndexMarker809"/>works on the current node, so we need to check for <span class="No-Break">the following:</span></p>
<ul>
<li>An active <span class="No-Break">object exists</span></li>
<li>There is an <span class="No-Break">active material</span></li>
<li>A material node tree has <span class="No-Break">been found</span></li>
<li>The material tree has an <span class="No-Break">active node</span></li>
</ul>
<p>So, the <strong class="source-inline">poll</strong> method returns <strong class="source-inline">False</strong> unless all the aforementioned <span class="No-Break">conditions apply:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        ob = context.object
        if not ob:
            return False
        mat = ob.active_material
        if not ob:
            return False
        tree = mat.node_tree
        if not tree:
            return False
        return <strong class="bold">tree.nodes.active</strong></pre>
<p>If the operator is <a id="_idIndexMarker810"/>launched and files are selected, they will be stored to be used in the <span class="No-Break"><strong class="source-inline">execute</strong></span><span class="No-Break"> method.</span></p>
<h3>Matching texture filenames</h3>
<p>At the <a id="_idIndexMarker811"/>beginning of <strong class="source-inline">execute</strong>, we store the currently active node in <span class="No-Break">a variable:</span></p>
<pre class="source-code">
    def execute(self, context):
        mat = context.object.active_material
        target_node = mat.node_tree.nodes.active</pre>
<p>Operators that inherit from <strong class="source-inline">ImportHelper</strong> display the <strong class="bold">File Browser</strong> area when they are invoked and run their <strong class="source-inline">execute</strong> method after a choice in the <strong class="bold">File Browser</strong> <span class="No-Break">is confirmed.</span></p>
<p>For that reason, at the time when <strong class="source-inline">execute</strong> is run, the <strong class="source-inline">self.files</strong> attribute will contain the file selection from the user. We can iterate <strong class="source-inline">self.files</strong> and compare each filename with the shader inputs. Rather than looking for an exact match, we will be happy to find a filename and an input name that are similar <span class="No-Break">at large.</span></p>
<p>For instance, <strong class="source-inline">"baseColor.png"</strong> should connect with the <strong class="source-inline">"Base Color"</strong> socket. In other words, we want case-insensitive and <span class="No-Break">space-insensitive matching.</span></p>
<p>A quick way to achieve this is by using a combination of the <strong class="source-inline">lower</strong> and <strong class="source-inline">replace</strong> methods. We can test this in any Python console; <span class="No-Break">for example:</span></p>
<pre class="source-code">
&gt;&gt;&gt; "Base Color".lower().replace(" ", "")
'basecolor'
&gt;&gt;&gt; "baseColor".lower().replace(" ", "")
'basecolor'</pre>
<p>We will need to perform this operation for every file, on any input, so we should create a function <span class="No-Break">for that.</span></p>
<p>The <strong class="source-inline">lambda</strong> statement is a quick way to create a function by just stating its arguments and one expression. For instance, putting an input, <em class="italic">x</em>, into lowercase and as a non-spaced string can be written in <span class="No-Break">this form:</span></p>
<pre class="source-code">
        match_rule = lambda x : x.<strong class="bold">lower().replace(" ", "")</strong></pre>
<p>Unlike <strong class="source-inline">def</strong>, <strong class="source-inline">lambda</strong> doesn’t assign a name to the function as names are not a requirement of <span class="No-Break">the syntax:</span></p>
<pre class="source-code">
lambda arguments : expression</pre>
<p>Since we <a id="_idIndexMarker812"/>are storing its result in the <strong class="source-inline">match_rule</strong> variable, our example is equivalent to writing the <span class="No-Break">following lines:</span></p>
<pre class="source-code">
def match_rule(x):
    return x.lower().replace(" ", "")</pre>
<p><strong class="source-inline">lambda</strong> can be used to write more compact code, or if a function is required as an argument but is not supposed to be <span class="No-Break">called directly.</span></p>
<p>We will use <strong class="source-inline">match_rule</strong> on every filename and every potential socket and compare the results while looking for <span class="No-Break">a match.</span></p>
<p>Node sockets are stored in <strong class="source-inline">inputs</strong>, a dictionary-like collection attribute of every node. We can get a list of the socket names using the <span class="No-Break"><strong class="source-inline">keys</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
        input_names = target_node.inputs.keys()</pre>
<p>Now, it’s time to look for textures to link. We can combine two for loops and scroll all the inputs for each entry in <strong class="source-inline">self.files</strong>. If a match is found, the input/filename pair will be added to the <span class="No-Break"><strong class="source-inline">matching_names</strong></span><span class="No-Break"> dictionary:</span></p>
<pre class="source-code">
        matching_names = {}
        for f in self.files:
            for inp in input_names:
                if match_rule(inp) in match_rule(f.name):
                    <strong class="bold">matching_names[inp] = f.name</strong>
                    break</pre>
<p>The <strong class="source-inline">break</strong> statement aborts the <strong class="source-inline">input_names</strong> loop when a match is found so that we can proceed to the <span class="No-Break">next file.</span></p>
<p>Once the <strong class="source-inline">matching_names</strong> dictionary contains the input for which textures were found and <a id="_idIndexMarker813"/>the relative filenames, we can load the images from disk and add them to <span class="No-Break">the graph.</span></p>
<h3>Loading image files</h3>
<p>The elements <a id="_idIndexMarker814"/>of <strong class="source-inline">self.file</strong> are not full disk paths. We can build this from <strong class="source-inline">directory</strong> and <strong class="source-inline">os.path.join</strong> so that we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">bpy.<a id="_idTextAnchor319"/>data.images.load</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
        for inp, fname in matching_names.items():
            img_path = os.path.join(self.directory, fname)
            img = bpy.data.images.load(img_path,
                                       check_existing=True)</pre>
<p>The <strong class="source-inline">check_existing</strong> parameter avoids loading the same image more than once: if it is already present in <strong class="source-inline">bpy.data.images</strong>, the <strong class="source-inline">load</strong> method returns the <span class="No-Break">existing entry.</span></p>
<p>We have mentioned that not all sockets are colors, but also that vectors, colors, and float sockets are converted automatically when they are connected. Therefore, non-color data such as metallic (a float number) or normal (a vector) can be stored <span class="No-Break">in images.</span></p>
<p>One of the main points of a node graph is that we should be able to connect sockets of different, but broadly <span class="No-Break">similar, types.</span></p>
<h3>Getting non-color attributes from images</h3>
<p>The colors of <a id="_idIndexMarker815"/>an image are not different from vectors in terms of their information, which consists of three channels or components: <strong class="bold">red</strong>, <strong class="bold">green</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="bold">blue</strong></span><span class="No-Break">.</span></p>
<p>Connecting a <strong class="bold">Color</strong> socket to a <strong class="bold">Vector</strong> socket will use the red, green, and blue channels as the <em class="italic">X</em>, <em class="italic">Y</em>, and <em class="italic">Z</em> coordinates of a three-dimensional <span class="No-Break">vector, respectively.</span></p>
<p>If a color output is connected to a float socket, the brightness, also called its <strong class="bold">luminance</strong> or <strong class="bold">value</strong>, will be used as <span class="No-Break">float input.</span></p>
<p>Whenever an image is used for storing values rather than colors, it’s important to inform Blender about that; otherwise, color adjustments from the renderer would alter the <span class="No-Break">image information.</span></p>
<p>We can do that by setting the image color space to <strong class="source-inline">NonColor</strong> if a socket is not of the <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">RGBA"</strong></span><span class="No-Break"> type:</span></p>
<pre class="source-code">
            if target_node.inputs[inp].type != "RGBA":
                img.colorspace_settings.name = "Non-Color"</pre>
<p>If we don’t <a id="_idIndexMarker816"/>do that, even correct textures will produce <span class="No-Break">render artifacts.</span></p>
<p>At this stage, the images have been loaded into Blender but they are not present in the node tree yet: we need to create an <strong class="bold">Image Texture</strong> <span class="No-Break">for that.</span></p>
<h3>Creating image texture nodes</h3>
<p>New material nodes <a id="_idIndexMarker817"/>can be added to a material shading graph by accessing the <strong class="source-inline">nodes</strong> collection of its <strong class="source-inline">node_tree</strong>. The <strong class="source-inline">new</strong> collection method requires the node to be of the <strong class="source-inline">argument</strong> type. In this case, <strong class="source-inline">ShaderNodeTexImage</strong> is the type that we use for creating image textures, but we can find the Python type of every shading node by looking at the <span class="No-Break">menu tooltips.</span></p>
<p>If <strong class="bold">Python Tooltips</strong> is enabled in <strong class="bold">Edit</strong> | <strong class="bold">Preferences</strong>, like we learned to do in <a href="B18375_02.xhtml#_idTextAnchor033"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we can view the node type by hovering over the <span class="No-Break">menu entry:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer210">
<img alt="Figure 12.7: Hovering over the Add menu entries displays the node type in the tooltip" height="583" src="image/Figure_12.7_B18375.jpg" width="1163"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7: Hovering over the Add menu entries displays the node type in the tooltip</p>
<p>This way, we <a id="_idIndexMarker818"/>can create a new texture node and set its <strong class="source-inline">image</strong> attribute to the image that we have loaded <span class="No-Break">from disk:</span></p>
<pre class="source-code">
            tree = mat.node_tree
            tex_img = tree.nodes.new(<strong class="bold">"ShaderNodeTexImage"</strong>)
            tex_img.image = img</pre>
<p>The texture nodes added to the graph are now ready for <span class="No-Break">connection links.</span></p>
<h2 id="_idParaDest-303"><a id="_idTextAnchor320"/>Connecting nodes</h2>
<p>While most texture <a id="_idIndexMarker819"/>output can be connected directly to a <a id="_idIndexMarker820"/>shading node, some input types might require helper nodes in between. The most prominent case is that of detail, or <strong class="bold">normal maps</strong>. Before creating new connections, our code should check that no additional nodes <span class="No-Break">are required.</span></p>
<h3>Connecting image colors</h3>
<p>Connection links <a id="_idIndexMarker821"/>can be created using the <strong class="source-inline">node_tree.links.new</strong> method. Its arguments are <span class="No-Break">as follows:</span></p>
<ul>
<li>The output socket of the <span class="No-Break">outgoing node</span></li>
<li>The input socket of the <span class="No-Break">receiving node</span></li>
</ul>
<p>If we are not dealing with a normal map, we can connect the <strong class="source-inline">"Color"</strong> output of the texture to the input of the active node. No other action is required, so we can use <strong class="source-inline">continue</strong> to pass to the <span class="No-Break">next input:</span></p>
<pre class="source-code">
            if inp != "Normal":
                tree.links.new(tex_img.outputs["Color"],
                               target_node.inputs[inp])
                continue
            # normal map code follows</pre>
<p>A <strong class="source-inline">normal</strong> input <a id="_idIndexMarker822"/>would not trigger <strong class="source-inline">continue</strong>, so we don’t need an <strong class="source-inline">else</strong> statement for it: the normal map code follows, without <span class="No-Break">additional indentation.</span></p>
<h3>Connecting normal maps</h3>
<p>Rendering a detailed <a id="_idIndexMarker823"/>surface using geometry alone would require so many polygons that the resulting model would be too heavy to store <span class="No-Break">or display.</span></p>
<p><strong class="bold">Normal mapping</strong> stores geometric<a id="_idIndexMarker824"/> details in the pixels of an image using the <span class="No-Break">RGB-to-XYZ conversion.</span></p>
<p>Since the normals stored in this way must be merged with the original ones, a <strong class="bold">Normal</strong> texture should not connect directly to a shader node; instead, it should pass through a <span class="No-Break"><strong class="bold">NormalMap</strong></span><span class="No-Break"> node.</span></p>
<p>We can add a <strong class="source-inline">"ShaderNodeNormalMap"</strong> to the tree <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
            normal_map = tree.nodes.new(
                                      <strong class="bold">"ShaderNodeNormalMap"</strong>
                                     )</pre>
<p>The <strong class="source-inline">"Normal"</strong> output of <strong class="source-inline">normal_map</strong> can be connected to the node input using the <span class="No-Break">following code:</span></p>
<pre class="source-code">
            tree.links.new(normal_map.outputs["Normal"],
                           target_node.inputs[inp])</pre>
<p>Then, we must connect <strong class="source-inline">tex_img</strong> to the <span class="No-Break"><strong class="source-inline">normal_map</strong></span><span class="No-Break"> node:</span></p>
<pre class="source-code">
            tree.links.new(tex_img.outputs["Color"],
                           normal_map.inputs["Color"])</pre>
<p>Once the <strong class="source-inline">inp, fname</strong> loop is over, we can return the <strong class="source-inline">'FINISHED'</strong> status <span class="No-Break">and exit:</span></p>
<pre class="source-code">
        return {'FINISHED'}</pre>
<p>Since this script <a id="_idIndexMarker825"/>aims to make setting up the texture faster, we can add an operator button for <span class="No-Break">quick execution.</span></p>
<h2 id="_idParaDest-304"><a id="_idTextAnchor321"/>Adding a header button</h2>
<p>We have used <a id="_idIndexMarker826"/>menus for most of the operators in this book, but this time, we will add a button in the <strong class="bold">Shader Editor</strong> area’s top bar – that is, its header. The steps are the same as those we used to add <span class="No-Break">menu entries:</span></p>
<ol>
<li>Create a function that accepts two arguments, <strong class="source-inline">self</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">context</strong></span><span class="No-Break">.</span></li>
<li>Append that function to the header type when the <span class="No-Break">add-on registers.</span></li>
</ol>
<p>Using <strong class="bold">Icon Viewer</strong>, which we introduced in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we can find an icon that suits our tool, such as <strong class="source-inline">NODE_TEXTURE</strong>. The <strong class="source-inline">layout.operator</strong> method will display <strong class="source-inline">AddTextures</strong> as a <span class="No-Break">header button:</span></p>
<pre class="source-code">
def shader_header_button(self, context):
    self.layout.operator(AddTextures.bl_idname,
                         icon="NODE_TEXTURE",
                         text="Load Textures")</pre>
<p>Now, it’s time to register the operator and the header function. We can find the header class we are looking for, <strong class="source-inline">NODE_HT_header</strong>, by looking in Blender’s source file, <strong class="source-inline">space_node.py</strong>. This file can be loaded into Blender’s text editor by right-clicking and choosing <strong class="bold">Edit Source</strong>. We can do this on any element of the <strong class="bold">Shader Editor</strong> <span class="No-Break">area’s header:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 12.8: NODE_HT_header is the first class in space_node.py" height="501" src="image/Figure_12.8_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8: NODE_HT_header is the first class in space_node.py</p>
<p>As an alternative, we <a id="_idIndexMarker827"/>can print a list of all the header types using a <strong class="source-inline">comprehension</strong> in Blender’s Python console. We learned how to do this in <a href="B18375_08.xhtml#_idTextAnchor206"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; [c for c in dir(bpy.types) if
     "header" in c]
['CLIP_HT_header', 'CONSOLE_HT_header', 'DOPESHEET_HT_header', 'FILEBROWSER_HT_header', 'GRAPH_HT_header', 'IMAGE_HT_header', 'IMAGE_HT_tool_header', 'INFO_HT_header', 'NLA_HT_header', 'NODE_HT_header', 'OUTLINER_HT_header', 'PROPERTIES_HT_header', 'SEQUENCER_HT_header', 'SEQUENCER_HT_tool_header', 'SPREADSHEET_HT_header', 'STATUSBAR_HT_header', 'TEXT_HT_header', 'USERPREF_HT_header', 'VIEW3D_HT_header', 'VIEW3D_HT_tool_header']</pre>
<p><strong class="source-inline">NODE_HT_header</strong> is in the middle of the list. We must append our entry to it inside the <span class="No-Break"><strong class="source-inline">register</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
def register():
    bpy.utils.register_class(AddTextures)
    bpy.types.NODE_HT_header.append(shader_header_button)</pre>
<p>In <strong class="source-inline">unregister</strong>, we must remove our interface and class when the add-on <span class="No-Break">is disabled:</span></p>
<pre class="source-code">
def unregister():
    bpy.types.NODE_HT_header.remove(shader_header_button)
    bpy.utils.unregiser_class(AddTextures)</pre>
<p>Now that the <a id="_idIndexMarker828"/>add-on is ready, we can use it for loading <span class="No-Break">textures instantly.</span></p>
<h2 id="_idParaDest-305"><a id="_idTextAnchor322"/>Using Load Textures</h2>
<p>If the <strong class="source-inline">ch12</strong> folder <a id="_idIndexMarker829"/>was added to the <strong class="bold">Scripts</strong> path, we can enable <strong class="bold">Textament</strong> in the <strong class="bold">Learning</strong> category of the <span class="No-Break"><strong class="bold">Add-ons</strong></span><span class="No-Break"> preferences:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer212">
<img alt="Figure 12.9: Enabling the “Textament” add-on" height="386" src="image/Figure_12.09_B18375.jpg" width="940"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9: Enabling the “Textament” add-on</p>
<p>Once it’s enabled, a button called <strong class="bold">Load Textures</strong> will be added to the <strong class="bold">Shader </strong><span class="No-Break"><strong class="bold">Editor</strong></span><span class="No-Break"> header:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer213">
<img alt="Figure 12.10: The Load Textures button in the Shader Editor header" height="336" src="image/Figure_12.10_B18375.jpg" width="947"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10: The Load Textures button in the Shader Editor header</p>
<p>Selecting a node allows you to click the <strong class="bold">Load Textures</strong> button, which opens the <strong class="bold">File </strong><span class="No-Break"><strong class="bold">Browser</strong></span><span class="No-Break"> area.</span></p>
<p>To test this add-on on a simple model, we can apply a brick wall material to the default cube by following <span class="No-Break">these steps:</span></p>
<ol>
<li>Open Blender or go back to the default scene via <strong class="bold">File</strong> | <strong class="bold">New</strong> | <span class="No-Break"><strong class="bold">General</strong></span><span class="No-Break">.</span></li>
<li>Switch to the <strong class="bold">Shading</strong> workspace using the tabs at the top of <span class="No-Break">the window.</span></li>
<li>Click <strong class="bold">Load Textures</strong> in the <strong class="bold">Shader Editor</strong> <span class="No-Break">area’s header.</span></li>
<li>In the <strong class="bold">File Browser</strong> area, navigate to a folder containing images. The textures accompanying this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch12/_media_/textures</span></a><span class="No-Break">.</span></li>
<li>Optionally, we <a id="_idIndexMarker830"/>can switch the <strong class="bold">File Browser</strong> area to <strong class="bold">thumbnails</strong> mode by clicking the thumbnails button on the top right. This is useful for looking <span class="No-Break">for textures:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer214">
<img alt="Figure 12.11: “Load and connect” thumbnails in the File Browser area" height="431" src="image/Figure_12.11_B18375.jpg" width="1374"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11: “Load and connect” thumbnails in the File Browser area</p>
<ol>
<li value="6">We can select multiple files by using the lasso, <em class="italic">Ctrl</em> + clicking, or pressing <em class="italic">A</em> to <span class="No-Break">select all.</span></li>
<li>Press <strong class="bold">Load and connect</strong> to add the textures to <span class="No-Break">the graph.</span></li>
</ol>
<p>The <strong class="source-inline">bricks_baseColor</strong>, <strong class="source-inline">bricks_normal</strong>, and <strong class="source-inline">bricks_roughness</strong> textures are now the inputs of the material and make the cube look like a <span class="No-Break">brick wall:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer215">
<img alt="Figure 12.12: Brick textures loaded into the Shader Editor area" height="933" src="image/Figure_12.12_B18375.jpg" width="1112"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.12: Brick textures loaded into the Shader Editor area</p>
<p>The operator was <a id="_idIndexMarker831"/>successful but all the nodes were created at the center of the graph. We can improve this considerably by adding code that rearranges <span class="No-Break">the nodes.</span></p>
<h1 id="_idParaDest-306"><a id="_idTextAnchor323"/>Improving Load Textures</h1>
<p>Nodes can be moved to <a id="_idIndexMarker832"/>a different position by setting the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> attributes of their <strong class="source-inline">location</strong> property. This allows us to arrange them in <span class="No-Break">our scripts.</span></p>
<h2 id="_idParaDest-307"><a id="_idTextAnchor324"/>Arranging shader nodes</h2>
<p>Even if we can move <a id="_idIndexMarker833"/>our nodes freely, the <a id="_idIndexMarker834"/>API poses a <span class="No-Break">few limitations:</span></p>
<ul>
<li>We can’t access the exact location of <span class="No-Break">the sockets</span></li>
<li>The width and height of new nodes are not available in <span class="No-Break">the scripts</span></li>
</ul>
<p>One of those two issues at a time would be tolerable, as we could either move our nodes at the height <a id="_idIndexMarker835"/>of their inputs or get the space <a id="_idIndexMarker836"/>required by a new node on the fly. Since they occur together, we will resort to <span class="No-Break">a workaround.</span></p>
<h3>Assuming node spacing</h3>
<p>We cannot get <a id="_idIndexMarker837"/>the size of new nodes in a script, but we can learn the default size of a texture node beforehand by looking at an existing shader tree. For instance, after we use <strong class="bold">Load Texture</strong>, we can switch to the <strong class="bold">Scripting</strong> workspace and get the <strong class="source-inline">dimensions</strong> property of an <strong class="source-inline">'Image </strong><span class="No-Break"><strong class="source-inline">Texture'</strong></span><span class="No-Break"> node:</span></p>
<pre class="source-code">
&gt;&gt;&gt; node_tree = C.object.active_material.node_tree
&gt;&gt;&gt; node_tree.nodes['Image Texture'].dimensions
Vector((360.0, 410.0))</pre>
<p>The <strong class="source-inline">Vector</strong> property returned by <strong class="source-inline">dimensions</strong> contains the bounding box of the node, not the node’s exact measures. We can verify that by querying the node’s <span class="No-Break"><strong class="source-inline">width</strong></span><span class="No-Break"> instead:</span></p>
<pre class="source-code">
&gt;&gt;&gt; node_tree = C.object.active_material.node_tree
&gt;&gt;&gt; node_tree.nodes['Image Texture'].width
240.0</pre>
<p>Even if it is present, the <strong class="source-inline">height</strong> attribute does not help because it hasn’t been updated and its value stays fixed <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">100.0</strong></span><span class="No-Break">.</span></p>
<p>Despite that weakness in the API, we have enough information to rearrange our tree: leaving <strong class="source-inline">100.0</strong> units between two nodes leaves enough room for connections, so we can use a spacing of <strong class="source-inline">340.0</strong> units between our textures and the <span class="No-Break">initial node.</span></p>
<p>We must store that value in the declaration of <span class="No-Break">our operator:</span></p>
<pre class="source-code">
class AddTextures(bpy.types.Operator, ImportHelper):
    """Load and connect material textures"""
    bl_idname = "texture.textament_load"
    bl_label = "Load and connect textures"
    bl_description = "Load and connect material textures"
    <strong class="bold">_spacing = 340.0</strong></pre>
<p>To arrange <a id="_idIndexMarker838"/>our nodes vertically, we need to process them in the <span class="No-Break">correct order.</span></p>
<h3>Sorting the node creation</h3>
<p>To space the <a id="_idIndexMarker839"/>nodes vertically in the correct way, we need to process them while following the sockets order in the target node layout; otherwise, the connection links will cross <span class="No-Break">each other:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer216">
<img alt="Figure 12.13: An unordered vertical arrangement leads to tangled, confusing links" height="885" src="image/Figure_12.13_B18375.jpg" width="996"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.13: An unordered vertical arrangement leads to tangled, confusing links</p>
<p>Python dictionaries are unordered by design, so <strong class="source-inline">matching_names</strong> doesn’t follow any order, but the <strong class="source-inline">input_names</strong> list does. This list contains the ordered names of all sockets. By filtering it with <strong class="source-inline">matching_names</strong>, we can obtain an ordered list of the <span class="No-Break">matching inputs:</span></p>
<pre class="source-code">
        sorted_inputs = [
              i for i in input_names if i in matching_names
             ]</pre>
<p>We must replace the <strong class="source-inline">for inp, fname in matching_names.items()</strong> loop with an <a id="_idIndexMarker840"/>iteration of <strong class="source-inline">sorted_inputs</strong>. Since we need an ordinal for vertical spacing, we must use <strong class="source-inline">enumerate</strong> to get the index of the current input. Here is the new <span class="No-Break">image loop:</span></p>
<pre class="source-code">
        <strong class="bold">for i, inp in enumerate(sorted_inputs):</strong>
            img_path = os.path.join(self.directory,
                                    matching_names[inp])
            img = bpy.data.images.load(img_path,
                                       check_existing=True)
            if target_node.inputs[inp].type != 'RGBA':
                img.colorspace_settings.name = 'Non-Color'
            img_node = mat.node_tree.nodes.new(
                                      "ShaderNodeTexImage")
            img_node.image = img</pre>
<p>After a texture nodes is connected, we can change its location. We start with the same coordinates as <strong class="source-inline">target_node</strong>, then move the texture to the left by subtracting <strong class="source-inline">_spacing</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">location.x</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
            img_node.location = target_node.location
            img_node.location.x -= self._spacing</pre>
<p>We can move the texture nodes downwards by subtracting <strong class="source-inline">self._spacing</strong> from <strong class="source-inline">location.y</strong>. We are stacking the nodes vertically, so their <strong class="source-inline">y</strong> coordinates depend on their ordinal indexes. The first node, which has an index of <strong class="source-inline">0</strong>, will not move at all from the initial position, the second node moves down by <strong class="source-inline">self._spacing</strong> times <strong class="source-inline">1</strong>, the third by <strong class="source-inline">self._spacing</strong> times <strong class="source-inline">2</strong>, and <span class="No-Break">so on:</span></p>
<pre class="source-code">
            img_node.location.y -= <strong class="source-inline">i</strong> * self._spacing</pre>
<p>Connecting <strong class="source-inline">ShaderNodeNormalMap</strong> requires horizontal space, so, after we align <strong class="source-inline">normal_map</strong> with its <strong class="source-inline">img_node</strong>, we must make some room by moving the texture to the left and <strong class="source-inline">normal_map</strong> to the right, by an amount of <span class="No-Break">half </span><span class="No-Break"><strong class="source-inline">_spacing</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
            normal_map = mat.node_tree.nodes.new(
                                      "ShaderNodeNormalMap"
                                     )
            normal_map.location = img_node.location
            <strong class="bold">img_node.location.x -= self._spacing / 2</strong>
            <strong class="bold">normal_map.location.x += self._spacing / 2</strong></pre>
<p>Now, we must <a id="_idIndexMarker841"/>save the add-on and update it by clicking <em class="italic">F3</em> and choosing <strong class="bold">Reload Scripts</strong>. Launching <strong class="bold">Load Textures</strong> sets up a properly arranged <span class="No-Break">node tree:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 12.14: Texture set up, with arranged nodes" height="924" src="image/Figure_12.14_B18375.jpg" width="943"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.14: Texture set up, with arranged nodes</p>
<p>Now that the <a id="_idIndexMarker842"/>basic functionality is complete, we can implement an option for customizing the color of <span class="No-Break">the material.</span></p>
<h2 id="_idParaDest-308"><a id="_idTextAnchor325"/>Mixing the Base Color</h2>
<p>Sometimes, even <a id="_idIndexMarker843"/>if we are happy with our texture setup, we want to change <a id="_idIndexMarker844"/>the color while retaining the texture pattern. We can do that by adding a <strong class="bold">MixRGB</strong> node before the <strong class="bold">Base Color</strong> property of a <span class="No-Break">principled node:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 12.15: Affecting the material color with a MixRGB node" height="928" src="image/Figure_12.15_B18375.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.15: Affecting the material color with a MixRGB node</p>
<p>The <strong class="bold">MixRGB</strong> node features a factor slider (<strong class="bold">Fac</strong>) for blending two colors. The default blending type, <strong class="bold">Mix</strong>, replaces <strong class="bold">Color1</strong> with <strong class="bold">Color2</strong>, but other blending modes known in computer graphics, such as <strong class="bold">Multiply</strong>, <strong class="bold">Overlay</strong>, and <strong class="bold">Color Dodge</strong>, are <span class="No-Break">also available.</span></p>
<p>The Python setup for a <strong class="source-inline">ShaderNodeMixRGB</strong> node is similar to that of a <strong class="bold">Normal Map</strong> node – when the input is <strong class="source-inline">"Base Color"</strong>, we create an <span class="No-Break">intermediate node:</span></p>
<pre class="source-code">
            if inp == "Base Color":
                mix = mat.node_tree.nodes.new(
                                        "ShaderNodeMixRGB")</pre>
<p>Then, we align the image texture and the <strong class="bold">Mix</strong> node, and make room for additional <span class="No-Break">connection links:</span></p>
<pre class="source-code">
                mix.location = img_node.location
                img_node.location.x -= self._spacing / 2
                mix.location.x += self._spacing / 2</pre>
<p>We connect the image color to the <strong class="source-inline">"Color1"</strong> input of the <span class="No-Break"><strong class="bold">Mix</strong></span><span class="No-Break"> node:</span></p>
<pre class="source-code">
                mat.node_tree.links.new(
                                 img_node.outputs["Color"],
                                 mix.inputs["Color1"])</pre>
<p>At this point, we <a id="_idIndexMarker845"/>would connect the <strong class="bold">Mix</strong> node to the color input, but <a id="_idIndexMarker846"/>we can store it in the <strong class="source-inline">img_node</strong> <span class="No-Break">variable instead.</span></p>
<p>This way, the connection to <strong class="source-inline">target_node</strong> is made by the same line of code that connects all the other inputs <span class="No-Break">except </span><span class="No-Break"><strong class="source-inline">"Normal"</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
                img_node = mix
            if inp != "Normal":
                tree.links.new(tex_img.outputs["Color"],
                               target_node.inputs[inp])
                continue</pre>
<p>If we execute <strong class="bold">Reload Scripts</strong> and then launch <strong class="bold">Load Textures</strong> again, a mixed layout like the one displayed in <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.15</em> is created. We can click on the <strong class="bold">Color2</strong> attribute and select a color from the picker or change the <strong class="bold">Mix</strong> node’s <strong class="bold">Blending Mode</strong> from its <span class="No-Break">drop-down menu.</span></p>
<p>We can also experiment with different solutions. For instance, we can use <strong class="bold">Hue Saturation Value</strong> rather than <strong class="bold">MixRGB</strong> by replacing <strong class="source-inline">"ShaderNodeMixRGB"</strong> with <strong class="source-inline">"ShaderNodeHueSaturation"</strong> and <strong class="source-inline">"Color1"</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">"Color"</strong></span><span class="No-Break">.</span></p>
<p>Node trees are interesting as they can be considered visual programming, but even the trivial operation of loading a few textures, if done manually, can <span class="No-Break">take time.</span></p>
<p>This time, we didn’t have <a id="_idIndexMarker847"/>to create an interface for manipulating the blended <a id="_idIndexMarker848"/>color as the mix node already provides it, so we could combine the best of two <span class="No-Break">procedural approaches.</span></p>
<h1 id="_idParaDest-309"><a id="_idTextAnchor326"/>Summary</h1>
<p>In this chapter, we learned how materials work and how nodes are created and connected in the <strong class="bold">Shader Editor</strong> area. We also learned how image textures can change the appearance of shaded objects and how they can store <span class="No-Break">non-color data.</span></p>
<p>This was our first encounter with node trees, a generic visual programming approach that is not limited to shaders and is planned to expand to deformation and rigging in <span class="No-Break">the future.</span></p>
<p>Node-based systems are flexible and powerful, but they benefit from scripted tools, like all other aspects <span class="No-Break">of Blender.</span></p>
<p>Rendering is not the final step of production as compositing and editing follow in the computer graphics pipeline. But since this stage converts three-dimensional data into images, it’s usually considered the last step of the <span class="No-Break">3D workflow.</span></p>
<p>That ends our journey into how Blender scripting works. We have covered object creation, deformation, animation, and rendering, but most importantly, how tools are designed and implemented, and how the software limitations can <span class="No-Break">be overcome.</span></p>
<p>Those skills, combined with individual talent and experience, allow technical directors to bridge between artistic needs and software capabilities, empower their teams, and improve their abilities and understanding in <span class="No-Break">the process.</span></p>
<h1 id="_idParaDest-310"><a id="_idTextAnchor327"/>Questions</h1>
<ol>
<li>How many render engines are present <span class="No-Break">in Blender?</span></li>
<li>Do the words <em class="italic">material</em> and <em class="italic">shader</em> have the <span class="No-Break">same meaning?</span></li>
<li>Are the shader nodes predefined values that determine how objects look or separate units performing <span class="No-Break">independent operations?</span></li>
<li>Can we use images for <span class="No-Break">coloring objects?</span></li>
<li>Can we make connections between different <span class="No-Break">data types?</span></li>
<li>How do we arrange nodes in <span class="No-Break">a graph?</span></li>
<li>In our shaders, can we alter the colors coming from <span class="No-Break">an image?</span></li>
</ol>
</div>
</div>

<div id="sbo-rt-content"><div id="_idContainer220">
<h1 id="_idParaDest-311"><a id="_idTextAnchor328"/>Appendix</h1>
<p>Blender and Python are so vast that even writing scripts for a shortlist of use cases encompasses a wide range of skills and disciplines. This book contains elements of animation, rigging, and shading and introduces programming techniques while exploring <span class="No-Break">those processes.</span></p>
<p>This appendix contains a comprehensive summary that can be useful as a recap to help with the retention of the concepts explored in this book and help the reader navigate through <span class="No-Break">the chapters.</span></p>
<h1 id="_idParaDest-312"><a id="_idTextAnchor329"/>Part 1: An Introduction to Python</h1>
<p>This section covers the fundamentals of scripting and helps you become familiar with Blender’s Python utilities. Besides providing a solid base for the chapters ahead, it contains all the information required for writing fully <span class="No-Break">working tools.</span></p>
<h2 id="_idParaDest-313"><a id="_idTextAnchor330"/><a href="B18375_01.xhtml#_idTextAnchor014">Chapter 1</a>, Python’s Integration with Blender</h2>
<p>This chapter introduces the tools used for scripting, internal and external text editors, and <span class="No-Break">version control.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Installing multiple versions of Blender on the main operating systems</h3>
<p>Blender 3.3 is the <em class="italic">long-term support</em> release used in the writing process. Although the content of this book is valid for all the 3. x series of blender, if you want to install version 3.3 alongside other versions, the following instructions <span class="No-Break">are provided:</span></p>
<ul>
<li>Using <span class="No-Break">Windows Installer</span></li>
<li>Using the <span class="No-Break">Microsoft Store</span></li>
<li>Downloading a <span class="No-Break">portable archive</span></li>
<li>Installing <span class="No-Break">on macOS</span></li>
</ul>
<h3>Using Python in Blender</h3>
<p>The <strong class="bold">Scripting</strong> workspace is a Blender layout optimized for running Python quickly. It consists of an interactive console, a logger listing the commands of past actions, and a Text Editor that can run scripts. We will become familiar with it through <span class="No-Break">these topics:</span></p>
<ul>
<li>Producing console output with the <em class="italic">“Hello </em><span class="No-Break"><em class="italic">World!”</em></span><span class="No-Break"> example</span></li>
<li>How to copy and paste Python instructions from the <span class="No-Break"><strong class="bold">Info Log</strong></span></li>
<li>Checking the current version of Blender and Python <span class="No-Break">using scripts</span></li>
<li>An explanation of functions <span class="No-Break">and arguments</span></li>
</ul>
<h3>Using external editors and version control tools</h3>
<p>Even though the Text Editor is quick and useful, programmers usually take advantage of external code editors as well. <strong class="bold">Visual Studio Code</strong>, a multiplatform editor from <strong class="bold">Microsoft</strong>, is used in this book, but there are plenty of alternatives. <strong class="bold">Version control</strong> tools are useful tools that for storing the history of code changes. We learn how to use these tools by going through the <span class="No-Break">following topics:</span></p>
<ul>
<li>Loading folders in Visual <span class="No-Break">Studio Code</span></li>
<li>Refreshing text files in the Blender <span class="No-Break">Text Editor</span></li>
<li>Initializing and using a <span class="No-Break"><strong class="bold">Git</strong></span><span class="No-Break"> repository</span></li>
</ul>
<h2 id="_idParaDest-314"><a id="_idTextAnchor331"/><a href="B18375_02.xhtml#_idTextAnchor033">Chapter 2</a>, Python Entities and API</h2>
<p>This chapter explains how to interact with Blender using scripts, how to take advantage of features for developers, and how the <strong class="bold">Application Programming Interface</strong> (<span class="No-Break"><strong class="bold">API</strong></span><span class="No-Break">) works.</span></p>
<p>The following sections are a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>User interface features for developers</h3>
<p>There are two useful options in the <strong class="bold">Interface</strong> section of <span class="No-Break">Blender’s preferences:</span></p>
<ul>
<li><strong class="bold">Developer Extras</strong>: This displays the <strong class="bold">Edit Source</strong> option when we right-click on an element of the interface so that we can easily access the Python source code of the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). It also makes non-UI operators available in the <span class="No-Break">search bar.</span></li>
<li><strong class="bold">Python Tooltips</strong>: This displays the Python property relative to the UI element under the <span class="No-Break">mouse cursor.</span></li>
</ul>
<h3>Console features for developers</h3>
<p>The interactive console provides two handy features for <span class="No-Break">quick scripting:</span></p>
<ul>
<li>Code auto-completion by pressing the <span class="No-Break"><em class="italic">Tab</em></span><span class="No-Break"> key</span></li>
<li>Commands history by pressing the <span class="No-Break">Up-arrow key</span></li>
</ul>
<h3>Viewport features for developers</h3>
<p>The <strong class="bold">Math Vis (Console)</strong> add-on included with Blender and available in the <strong class="bold">3D View</strong> section of the <strong class="bold">Preferences</strong> &gt; <strong class="bold">Add-ons</strong> dialog displays three-dimensional mathematical entities such as <em class="italic">vectors</em> and <em class="italic">matrices</em> in the 3D Viewport. It can be useful when working with object location and <span class="No-Break">rotation values.</span></p>
<h3>Using Blender modules</h3>
<p>Blender’s Python module, <strong class="source-inline">bpy</strong>, is accessed in scripts using the <strong class="source-inline">import</strong> statement. Each of its components covers a specific aspect of the 3D app. Most notably, <strong class="source-inline">data</strong> contains all the objects available in the current session, while <strong class="source-inline">context</strong> contains the current state of the user interaction, such as the current selection. The API documentation is available online but can also be viewed using the <span class="No-Break"><strong class="source-inline">help()</strong></span><span class="No-Break"> function.</span></p>
<h3>Using object collections</h3>
<p>Lists of objects are accessed through <strong class="source-inline">bpy_collection</strong>, an aggregate type similar to a Python <strong class="source-inline">dictionary</strong>. Elements of a collection can be accessed with numeral indices or keywords and can be iterated in <span class="No-Break">Python loops.</span></p>
<p>Operations such as renaming can reorder the elements of a collection, so a conversion to <strong class="source-inline">list</strong> is advised when the order <span class="No-Break">is critical.</span></p>
<p>Blender collections don’t have an <strong class="source-inline">append()</strong> method: the <strong class="source-inline">new()</strong> method is used for creating a new object, which is automatically appended. The <strong class="source-inline">remove()</strong> method removes an element from a collection and deletes it <span class="No-Break">from Blender.</span></p>
<h3>Context and user activity</h3>
<p>Users can change the current state or context of Blender by adding or selecting objects. The last selected object is considered <em class="italic">active</em> and is the main target of <span class="No-Break">object-related actions.</span></p>
<p>Context information is available as properties of <strong class="source-inline">bpy.context</strong>, is read-only, and can only be changed indirectly. For instance, <strong class="source-inline">ob.select_set(True)</strong> is used to select an object, as it’s impossible to append to the <span class="No-Break"><strong class="source-inline">bpy.context.selected_objects</strong></span><span class="No-Break"> list.</span></p>
<h2 id="_idParaDest-315"><a id="_idTextAnchor332"/><a href="B18375_03.xhtml#_idTextAnchor049">Chapter 3</a>, Creating Your Add-Ons</h2>
<p>This chapter illustrates the process of creating Blender add-ons: Python scripts that can be installed as Blender plugins to add <span class="No-Break">custom functions.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Writing scripts that are add-ons</h3>
<p>Add-ons are Python modules or packages containing a dictionary named <strong class="source-inline">bl_info</strong>. This dictionary contains information such as the author and name of the add-on. Add-ons must provide two functions, <strong class="source-inline">register()</strong> and <strong class="source-inline">unregister()</strong>, used when an add-on is enabled <span class="No-Break">or disabled.</span></p>
<p>Add-ons can be installed in Blender preferences, but setting the folder where they are developed as <strong class="bold">Scripts</strong> in <strong class="bold">Preferences</strong> &gt; <strong class="bold">File Paths</strong> is more convenient for developers. Changes in our scripts are loaded by looking up <strong class="source-inline">Reload Scripts</strong> in the <em class="italic">F3</em> key <span class="No-Break">search bar.</span></p>
<h3>Writing Object Collector, an add-on that groups objects in the Outliner</h3>
<p>Adding features to Blender involves the creation of an operator, that is, an instruction that can be launched from the user interface. The <strong class="source-inline">bl_idname</strong> and <strong class="source-inline">bl_label</strong> attributes determine how an operator is found and displayed in Blender, while the <strong class="source-inline">poll()</strong> and <strong class="source-inline">execute()</strong> functions regulate when it can be launched and what happens when <span class="No-Break">it runs.</span></p>
<p>Add-ons add operators to Blender in their <strong class="source-inline">register()</strong> and <span class="No-Break"><strong class="source-inline">unregister()</strong></span><span class="No-Break"> functions.</span></p>
<h3>Tips for working on add-ons</h3>
<p>When using an external editor, enabling auto-save might help ensure that the Python script always includes the <span class="No-Break">latest changes.</span></p>
<p>Enabling add-ons from the development folder might leave <em class="italic">bytecode</em>, that is, Python-compiled files in a folder named <strong class="source-inline">__pycache__</strong>. If we use Git version control, we can create a text file named <strong class="source-inline">.gitignore</strong> that contains <strong class="source-inline">__pycache__</strong> to avoid bytecode files ever <span class="No-Break">being versioned.</span></p>
<h3>Avoiding duplicates using try and except</h3>
<p>To prevent our script from creating the same collection twice, resulting in duplicates, we look for a collection inside a <strong class="source-inline">try</strong> statement and add an <strong class="source-inline">except KeyError</strong> block that is triggered when no collection is found. By creating new collections under the <strong class="source-inline">except</strong> statement, we ensure that collections with a given name are only created once. The try/except pattern is called <em class="italic">forgiveness rather than permission</em>, as it focuses on pulling back from non-allowed actions rather than checking whether an action is possible in the <span class="No-Break">first place.</span></p>
<p>We use the <strong class="source-inline">title()</strong> string method for nicely formatted names with a capital first letter. We can create functions for adding our operator to Blender menus. They accept the <strong class="source-inline">self</strong> and <strong class="source-inline">context</strong> arguments and add operators to <strong class="source-inline">self.layout</strong>. Menu functions are added to Blender in the <strong class="source-inline">register()</strong> and <strong class="source-inline">unregister()</strong> functions of <span class="No-Break">the add-on.</span></p>
<h2 id="_idParaDest-316"><a id="_idTextAnchor333"/><a href="B18375_04.xhtml#_idTextAnchor075">Chapter 4</a>, Exploring Object Transformations</h2>
<p>This chapter shows how to affect <strong class="source-inline">location</strong>, <strong class="source-inline">rotation</strong>, and <strong class="source-inline">scale</strong> of an object using Python and how the transform information is stored <span class="No-Break">in Blender.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Moving and scaling objects with Python</h3>
<p><strong class="source-inline">location</strong> is stored as the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">z</strong> coordinates of a three-dimensional vector. The coordinates of a vector can be changed individually or together, using <span class="No-Break">tuple assignment.</span></p>
<p><strong class="source-inline">scale</strong> is stored as an <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, <strong class="source-inline">z</strong> vector too. While the rest value of <strong class="source-inline">location</strong> has the <strong class="source-inline">(0.0, 0.0, 0.0)</strong> coordinates, a non-scaled object’s <strong class="source-inline">scale</strong> attribute is <strong class="source-inline">(1.0, </strong><span class="No-Break"><strong class="source-inline">1.0, 1.0)</strong></span><span class="No-Break">.</span></p>
<h3>Peculiarities of rotations</h3>
<p>Rotations are less straightforward than <strong class="source-inline">location</strong> and <strong class="source-inline">scale</strong>, as the <strong class="source-inline">rotation</strong> values over the three axes can affect each other, causing an issue known as <span class="No-Break"><em class="italic">gimbal lock</em></span><span class="No-Break">.</span></p>
<p>There is more than one way to represent rotations; some involve multidimensional entities such as quaternions or rotation matrices, and two measure units for angles: <em class="italic">degrees</em> and <em class="italic">radians</em>. Blender objects have attributes for each notation system, which can be set via Python. Conversion utilities are provided for switching from one notation system <span class="No-Break">to another.</span></p>
<h3>Indirect transformations with parents and constraints</h3>
<p>Objects can be arranged in hierarchies. Transformations of an object higher in the hierarchy (<em class="italic">parent</em>) affect all the objects under <span class="No-Break">them (</span><span class="No-Break"><em class="italic">children</em></span><span class="No-Break">).</span></p>
<p>Constraints are another way to transform an object without affecting its channels. They can be added using the <strong class="source-inline">new()</strong> method of the <span class="No-Break"><strong class="source-inline">constraints</strong></span><span class="No-Break"> collection.</span></p>
<h3>Transforming objects with matrices</h3>
<p>Setting values for the <strong class="source-inline">location</strong>, <strong class="source-inline">rotation</strong>, and <strong class="source-inline">scale</strong> channels affects the relative coordinates of an object. Assigning a transformation matrix allows us to use world-space coordinates instead. Matrix values are lazy-copied unless stated otherwise; if we store a matrix as a variable and don’t want its values to change we need to use its <span class="No-Break"><strong class="source-inline">copy()</strong></span><span class="No-Break"> method.</span></p>
<p>Parenting to a transformed object in Python changes the object location unless a reverse transformation is set in the <span class="No-Break"><strong class="source-inline">matrix_parent_inverse</strong></span><span class="No-Break"> attribute.</span></p>
<h3>Writing Elevator, an add-on that sets a floor for the selected objects</h3>
<p>The operator from the <strong class="bold">Elevator</strong> add-on brings all the selected objects above a certain height. To do so, it implements <strong class="source-inline">FloatProperty</strong> that can be set when it’s launched. Optional behaviors can be enabled by switching its <span class="No-Break"><strong class="source-inline">BoolProperty</strong></span><span class="No-Break"> members.</span></p>
<p>Editable properties must be added as <em class="italic">annotations</em>, Python <span class="No-Break">arbitrary attributes.</span></p>
<p>Parent objects at the top of the hierarchy are moved first to avoid duplicate transformations. Constraints can be <span class="No-Break">used optionally.</span></p>
<h2 id="_idParaDest-317"><a id="_idTextAnchor334"/><a href="B18375_05.xhtml#_idTextAnchor100">Chapter 5</a>, Designing Graphical Interfaces</h2>
<p>This chapter explains how to add custom panels and add them to the <span class="No-Break">Blender interface.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Components of the UI</h3>
<p>The Blender window is structured into areas, regions, and panels. Panels have a layout that is populated with text, icons, and buttons <span class="No-Break">using Python.</span></p>
<h3>Writing the Simple Panel add-on</h3>
<p>This add-on registers a simple <strong class="source-inline">Panel</strong> class that displays text and icons in the <strong class="bold">Object</strong> properties. Arrangements can be created using the <strong class="source-inline">row()</strong> or <strong class="source-inline">column()</strong>methods, non-uniform columns using <strong class="source-inline">split()</strong>, and uniform tables <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">grid_flow()</strong></span><span class="No-Break">.</span></p>
<p>Blender icon names can be looked up using the <strong class="bold">Icon Viewer</strong> add-on or, in some cases, built using Python’s <span class="No-Break">string formatting.</span></p>
<p>Red and gray colors can be used to give visual feedback using the <strong class="source-inline">alert</strong> or <strong class="source-inline">enabled</strong> flags of <span class="No-Break">a widget.</span></p>
<p>Operators added to a layout using the <strong class="source-inline">operator()</strong> method are displayed <span class="No-Break">as buttons.</span></p>
<h1 id="_idParaDest-318"><a id="_idTextAnchor335"/>Part 2: Interactive Tools and Animation</h1>
<p>This section explains how to write add-ons as folders rather than single files, interact with the animation system, and write modal operators that wait for user input. By the end of this section, you will be able to write advanced, <span class="No-Break">interactive tools.</span></p>
<h2 id="_idParaDest-319"><a id="_idTextAnchor336"/><a href="B18375_06.xhtml#_idTextAnchor129">Chapter 6</a>, Structuring Our Code and Add-Ons</h2>
<p>This chapter explains how to write and distribute addons containing multiple files in <span class="No-Break">a folder.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>The relationship between modules, packages, and add-ons</h3>
<p>While a single <strong class="source-inline">.py</strong> file is a Python module, a folder containing <strong class="source-inline">.py</strong> files is a Python package. Packages contain a file named <strong class="source-inline">__init__.py</strong>. If our package is an add-on, this file must contain the <span class="No-Break"><strong class="source-inline">bl_info</strong></span><span class="No-Break"> dictionary.</span></p>
<h3>Guidelines for partitioning code</h3>
<p>Some criteria for separating the code through different <strong class="source-inline">.py</strong> files are <span class="No-Break">as follows:</span></p>
<ul>
<li><span class="No-Break">Media loaders</span></li>
<li>Generic code versus <span class="No-Break">specific code</span></li>
<li><span class="No-Break">Interface code</span></li>
<li><span class="No-Break">Operator modules</span></li>
<li>Use of <span class="No-Break">imported modules</span></li>
</ul>
<p>For example, all the code used for loading custom icons, as explained in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, can be moved to a module <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">img_loader.py</strong></span><span class="No-Break">.</span></p>
<p>Only <strong class="source-inline">__init__.py</strong> is reloaded by the <strong class="bold">Reload Scripts</strong> operator introduced in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>; the other files must be reloaded explicitly using Python’s <span class="No-Break"><strong class="source-inline">importlib.reload()</strong></span><span class="No-Break"> function.</span></p>
<p>A panel to display the add-on preferences can be written in a <strong class="source-inline">preferences.py</strong> file, while <strong class="source-inline">panel.py</strong> and <strong class="source-inline">operators.py</strong> contain, respectively, the UI and the <span class="No-Break">add-on operators.</span></p>
<p>Add-on folders compressed as <strong class="source-inline">.zip</strong> archives can be installed using the <strong class="bold">Preferences</strong> | <strong class="bold">Addons</strong> | <span class="No-Break"><strong class="bold">Install</strong></span><span class="No-Break"> button.</span></p>
<h2 id="_idParaDest-320"><a id="_idTextAnchor337"/><a href="B18375_07.xhtml#_idTextAnchor171">Chapter 7</a>, The Animation System</h2>
<p>This chapter explains how to animate objects in Blender and how to create and edit animations <span class="No-Break">with Python.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>The Animation system</h3>
<p>The <strong class="bold">Layout</strong> and <strong class="bold">Animation</strong> Workspaces display animation keyframes on a <strong class="bold">Timeline</strong> including the scene actions, keyframes, and range. Keyframes establish the value of a property at a <span class="No-Break">certain time.</span></p>
<h3>Writing the Action to Range add-on</h3>
<p>This add-on sets the start and end of the playback to the first and last frame of the current action of the active object. If a timeline is displayed onscreen, it is recentered to the new range. To do that, <strong class="source-inline">context.temp_override()</strong> is used to pass a timeline region to the <strong class="source-inline">bpy.ops.action.view_all()</strong> <span class="No-Break">factory operator.</span></p>
<h3>Writing the Vert Runner add-on</h3>
<p>This add-on animates the selected objects along the vertices of the active object. The vertex coordinates stored in <strong class="source-inline">context.object.data.vertices</strong> are read, while trigonometric functions are used for computing the shortest rotation arc that orients an object toward its <span class="No-Break">next position.</span></p>
<h2 id="_idParaDest-321"><a id="_idTextAnchor338"/><a href="B18375_08.xhtml#_idTextAnchor206">Chapter 8</a>, Animation Modifiers</h2>
<p>This chapter covers non-destructive modifiers for animation f-curves and their use in animating <span class="No-Break">procedural effects.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Adding f-curve modifiers</h3>
<p>F-curve modifiers can be added by selecting a curve in the graph editor and clicking <strong class="bold">Add Modifier</strong> in its properties or using the <strong class="source-inline">new()</strong> method from the <strong class="source-inline">modifiers</strong> collection <span class="No-Break">of f-curves.</span></p>
<h3>Writing the Shaker add-on</h3>
<p>This add-on uses a <strong class="bold">Noise</strong> f-modifier to add a trembling effect on the active object and allows to set the duration and amount of the trembling. <em class="italic">Soft limits</em> set an initial limitation on the noise strength parameter while still allowing you to type out-of-range values using the keyboard. We add a menu entry for invoking this operator using the right-click menu in <span class="No-Break">the Viewport.</span></p>
<h2 id="_idParaDest-322"><a id="_idTextAnchor339"/><a href="B18375_09.xhtml#_idTextAnchor226">Chapter 9</a>, Animation Drivers</h2>
<p>This chapter introduces animation drivers, which are the connections between different properties used to control complex actions. Drivers can incorporate short Python expressions in <span class="No-Break">their logic.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Creating and setting drivers</h3>
<p>Drivers can be created quickly by selecting <strong class="bold">Copy As New Driver</strong> and <strong class="bold">Paste Driver</strong> from the right-click menu of Blender properties. Using an object’s location as input for its rotation creates a wheel setup since the object rotates when <span class="No-Break">it’s moved.</span></p>
<h3>Using Python drivers</h3>
<p>Python expression-based drivers can be created quickly by pressing the <em class="italic">#</em> key, followed by Python code while editing a Blender property. Oscillatory motions can be created using trigonometric cyclic functions such as <strong class="source-inline">sin</strong>, and the pendulum equation from the physics classroom can be implemented as a driver expression. Object custom properties can be used as parameters in <span class="No-Break">driver expressions.</span></p>
<h3>Writing the Pendulum add-on</h3>
<p>This add-on instantly sets up the pendulum expression and parameters. Drivers are added using the <span class="No-Break"><strong class="source-inline">object.driver_add()</strong></span><span class="No-Break"> method.</span></p>
<h2 id="_idParaDest-323"><a id="_idTextAnchor340"/><a href="B18375_10.xhtml#_idTextAnchor247">Chapter 10</a>, Advanced and Modal Operators</h2>
<p>This chapter explains how to write advanced operators by enriching their execution flow and implementing <span class="No-Break">optional methods.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Operator execution details</h3>
<p>The <strong class="source-inline">invoke()</strong> method of <strong class="source-inline">Operator</strong>, if defined, runs when the operator is launched. Inside <strong class="source-inline">invoke()</strong>, we can switch either to the <strong class="source-inline">execute()</strong> method or to the <strong class="source-inline">modal()</strong> method. The latter listens to user inputs such as key presses or <span class="No-Break">mouse movements.</span></p>
<h3>Writing the PunchClock add-on</h3>
<p>This add-on creates time-formatted text in the scene. Its operator sets the initial values of its hour and minute parameters in <strong class="source-inline">invoke()</strong> using Python <strong class="source-inline">datetime</strong> utilities. When adding the operator to a menu, <strong class="source-inline">operator_context</strong> of the layout is set to <strong class="source-inline">"INVOKE_DEFAULT"</strong> so that the execution of <strong class="source-inline">invoke()</strong> is <span class="No-Break">never skipped.</span></p>
<h3>Modal behavior</h3>
<p>The operator is added to the modal handlers so that its <strong class="source-inline">modal()</strong> method is run at every update of the UI. Inside the modal, the <strong class="source-inline">"MOUSEMOVE"</strong> events change the displayed hour <span class="No-Break">and minute.</span></p>
<h3>Customizing the undo panel</h3>
<p>The undo panel displays the operator properties after the execution is customized by implementing the <strong class="source-inline">draw()</strong> method. With this method, we can design a graphic interface using the same techniques learned in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-324"><a id="_idTextAnchor341"/>Part 3: Delivering Output</h1>
<p>This section covers the final stages of the 3D pipeline: deformation <span class="No-Break">and rendering.</span></p>
<h2 id="_idParaDest-325"><a id="_idTextAnchor342"/><a href="B18375_11.xhtml#_idTextAnchor265">Chapter 11</a>, Object Modifiers</h2>
<p>This chapter covers object modifiers and their use <span class="No-Break">in animation.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>Adding object modifiers</h3>
<p>Modifiers are grouped into four categories: <strong class="bold">Modify</strong>, <strong class="bold">Generate</strong>, <strong class="bold">Deform</strong>, and <strong class="bold">Physics</strong>. They are created by clicking the <strong class="bold">Add Modifier</strong> button in the <span class="No-Break"><strong class="bold">Modifiers</strong></span><span class="No-Break"> property.</span></p>
<h3>Adding modifiers in Python</h3>
<p>The <strong class="source-inline">new()</strong> method of the <strong class="source-inline">object.modifiers</strong> collection requires the <strong class="source-inline">type</strong> modifier as an argument. A list of the possible <strong class="source-inline">type</strong> keywords can be found by accessing the <strong class="source-inline">bpy.types.ObjectModifiers.bl_rna.functions["new"]</strong> function and querying <span class="No-Break">its </span><span class="No-Break"><strong class="source-inline">parameters["type"].enum_items</strong></span><span class="No-Break">.</span></p>
<h3>Writing the Latte Express add-on</h3>
<p>This add-on sets up a <strong class="bold">Lattice</strong> modifier to deform an object using a three-dimensional grid cage. It finds the center of the model by querying its bounding box and has input parameters for changing the lattice and the <span class="No-Break">object’s resolutions.</span></p>
<h3>Using armature deformers</h3>
<p>Armatures affect characters using a deformation skeleton. Bones can be created in Python using <strong class="source-inline">object.data.edit_bones.new()</strong> after switching to <strong class="bold">Edit Mode</strong> <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.ops.object.mode_set()</strong></span><span class="No-Break">.</span></p>
<p>Vertex groups are created on the lattice object to bind the lattice vertices to the armature bones. This way, a lattice deformed by an armature can be created via <span class="No-Break">a script.</span></p>
<h3>Creating control shapes</h3>
<p>Replacing the default octahedral shape with custom wireframe shapes makes an armature more animator friendly. For that reason, a simple mesh can be created in Python using the <strong class="source-inline">mesh.from_pydata</strong> method, and assigned to the <span class="No-Break"><strong class="source-inline">pose_bone.custom_shape</strong></span><span class="No-Break"> attribute.</span></p>
<h2 id="_idParaDest-326"><a id="_idTextAnchor343"/><a href="B18375_12.xhtml#_idTextAnchor304">Chapter 12</a>, Rendering and Shaders</h2>
<p>This chapter introduces rendering and materials, the shader editor, and its node tree. Although some steps such as post-processing and video encoding may follow, rendering is commonly regarded as the last stage of a <span class="No-Break">3D process.</span></p>
<p>Here’s a summary of the topics discussed in <span class="No-Break">the chapter.</span></p>
<h3>How rendering works</h3>
<p>A render engine such as Blender’s <strong class="bold">Eevee</strong> or <strong class="bold">Cycles</strong> converts the 3D geometry to finished images using <em class="italic">shaders</em> to determine how objects look. Blender shaders are networks of operations called nodes, that is, blocks that elaborate and exchange color and geometry information by connecting their <span class="No-Break">input/output sockets.</span></p>
<h3>Writing the Textament add-on</h3>
<p>This add-on imports images from disk and creates the <strong class="bold">Image Texture</strong> nodes for the current shader. File-import operators derive from two classes, <strong class="source-inline">ImportHelper</strong> and <strong class="source-inline">Operator</strong>, and display the Blender file browser when invoked. The files the user selecteds are accessed as the <strong class="source-inline">directory</strong> and <strong class="source-inline">files</strong> <span class="No-Break">member attributes.</span></p>
<h3>Looking for case-insensitive matches in file names</h3>
<p>Uppercase letters and spaces might cause unwanted mismatches, such as the <strong class="source-inline">"base color"</strong> strings not being associated with <strong class="source-inline">"Base Color"</strong>. A function for string manipulation can be written with the usual syntax or defined in one line using a <strong class="source-inline">lambda</strong> expression. Removing all spaces and converting all letters to lowercase becomes <span class="No-Break">the following:</span></p>
<p><strong class="source-inline">lambda x : x.lower().replace(" ", "")</strong></p>
<h3>Non-color data in images</h3>
<p>Images can contain geometric or masking information. In that case, the <strong class="source-inline">colorspace_setting.name</strong> image attribute must be set to <strong class="source-inline">"Non-Color"</strong>, or Blender will apply color filters that pollute <span class="No-Break">the information.</span></p>
<h3>Connecting images in shaders</h3>
<p>Creating a <strong class="bold">Texture</strong> node, with <strong class="source-inline">"ShaderNodeTexImage"</strong> as an argument of <strong class="source-inline">node_tree.nodes.new("ShaderNodeTexImage")</strong> allows you to use images in shaders. The connection between a texture node and a shader node input is created <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">node_tree.links.new()</strong></span><span class="No-Break">.</span></p>
<p><em class="italic">Normal map</em> textures give the illusion of detail. They must connect to <strong class="bold">Normal Map</strong>, which is then connected to the <strong class="bold">Normal</strong> input of <span class="No-Break">a shader.</span></p>
<h3>Adding custom buttons to headers</h3>
<p>Operators can be added to headers in the same way as they are added to menus: using a function that takes the <strong class="source-inline">self</strong> and <strong class="source-inline">context</strong> arguments, and adds elements to <strong class="source-inline">self.layout</strong>. This function is appended to a <em class="italic">Header Type</em> in the <strong class="source-inline">register()</strong> function of <span class="No-Break">the add-on.</span></p>
<h3>Arranging nodes in the node editor</h3>
<p>Nodes created in Python are positioned at the center of the editor and overlap each other. They can be moved by setting their <strong class="source-inline">location</strong> <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> coordinates. They should be placed on the left-hand side of their output node and sorted vertically according to the order of their output <span class="No-Break">node sockets.</span></p>
<h3>Altering texture colors</h3>
<p>The color of a texture can be manipulated by adding a <strong class="bold">Mix</strong> node between a texture and its output node. That allows you to change the overall color of an object while retaining the details coming from <span class="No-Break">the image.</span></p>
</div>
</div></body></html>