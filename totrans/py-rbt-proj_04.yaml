- en: Basics of Motors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right then! We have made a robot that takes care of your garden and I hope
    it's working fine. It's time to take things to another level.
  prefs: []
  type: TYPE_NORMAL
- en: We have always thought that robots are like WALL-E, moving around and doing
    things for us. Well, my friend, now that dream is not far away. In fact, in this
    chapter we will be going ahead and making one. Let's see how it's done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting it rolling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we talk about moving from one place to another, we think about wheels
    and similarly whenever we think about moving the wheels of a robot, we think about
    motors. There are various different types of motors that exist. So let''s firstly
    look at the most basic type of motor, which is called a brushed DC motor. As the
    name suggests, it works on a direct current. You may find such motors like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7fd7980-d47b-4ab1-b5c1-4ee766d7bbf1.png)'
  prefs: []
  type: TYPE_IMG
- en: Trust me, these things are omnipresent, from the Christmas gift you bought for
    your neighbor to the biggest baddest machines out there—you will find these motors
    hiding under the hood. These motors are common for a reason and that is because
    they are very, very simple. So simple that powering them up only requires a battery
    and two wires. Simply connect the positive to one terminal and negative to the
    other, and the motor will start spinning. Interchange those connections and the
    direction of the rotation will change. Take two cells and double the voltage and
    the motor will spin even faster. It is that simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now you might assume that we would simply connect this motor to Raspberry Pi
    and that we would be good to go. But unfortunately this is not going to be the
    case. As you may remember from the previous chapters, Raspberry Pi can only supply
    around 50 milliamps, but the consumption of a motor can be much higher. Hence,
    to run one we need an intermediate device.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing that will come to your mind will be to use a relay, and why
    not? They can channel a huge amount of current and can handle high voltages. This
    should be the ideal choice. You would be right if you thought so, but only to
    some extent, and that is because a relay is simply a switch we can use to turn
    the motor on or off. We would not be able to control the speed or the direction
    of rotation of the motor. Now, you would think that this problem is not new and
    that we can very easily solve it by using **pulse width modulation** (**PWM**),
    right? Well, the answer is no! Because these relays are mechanical devices, and
    due to their mechanical nature, there are some maximum limits in terms of it being
    switched on or off in a second. Hence, it would not be able to cope with the frequency
    of PWM. Finally, we would still be left with the problem of changing the direction
    and the speed of the motor. So what do we do now?
  prefs: []
  type: TYPE_NORMAL
- en: 'As I always say, the beauty of a problem is that it always has a solution,
    and the solution here is called a motor driver. A motor driver is primarily a
    set of electronic relays—a switch that can allow high currents yet is not mechanical.
    Hence, we can switch it hundreds of times every second. These electronic relays
    are either made of simple transistors or, in high power applications, they can
    even use MOSFETs for switching. We can simply give PWM to these electronic switches
    and get the voltage to modulate while making sure that enough current is being
    delivered to the circuit. Further, as I mentioned earlier, the motor driver is
    made of a set of these electronic relays. The most common and workable fashion
    in which they are arranged is called a full bridge or an H Bridge. Before I explain
    any further, let''s see what this is, exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f250030-b631-4351-9746-c38e7caf0222.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In a full bridge we have four switching circuits across the connected motor;
    these can be independently switched on or off based on the requirements. In the
    off state, all of these switching circuits are in an open state, hence keeping
    the motor switched off. Now, whenever we want to start the motor, we will have
    to switch on two switches in such a way that the circuit is complete and the motor
    starts working. So let''s see what it would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61cf5d12-fe36-447a-b233-1304060c39cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we have switched on the switching circuit **S2** and **S3**; this in
    turn completes the circuit and lets the current flow in the motor. Now, to control
    the speed, these same switching circuits can be switched on and off at a very
    high frequency at varying duty cycles to achieve a specific mean voltage. Now
    that we can achieve a specific speed for the motor by changing the voltage via
    these two switching circuits, let''s see how we are going to change the direction  of
    rotation of the motor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d887368-95b7-4bfb-aba6-31c27cf7ef13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this circuit we have switched off the previously connected **S2** and **S3**
    and instead switched on **S1** and **S4**, hence the polarity to the motor is
    reversed. As we discussed earlier, whenever the polarity of a DC-brushed motor
    is changed, the direction also changes subsequently. There are various types of
    motor drivers you can find on the market. What we have understood here is called
    a brushed DC H-bridge motor driver; there are other types of motor drivers as
    well for controlling other types of motors, but currently we will stick to the
    brushed motor only. While selecting a motor driver, you should examine the specification
    sheet of the motor driver very carefully. Some of the key specifications that
    will be mentioned are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Voltage rating**: There will be a minimum and maximum limit to the voltage
    that the motor driver can handle and modulate between. Make sure your motor lies
    in between this specific voltage range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Current rating**: There will be an absolute maximum current that the motor
    driver can handle; going anywhere beyond it will burn or damage the motor driver.
    This can be a little deceptive. Let''s see why. Except for the absolute maximum,
    there will be many other current ratings that might be specified. These might
    be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repetitive maximum current**: This is the current rating that can be the
    maximum current the motor driver can handle, but not continuously. This rating
    is given because at times the load on the motor might increase and there might
    be a higher current requirement for a brief moment. The motor driver will provide
    the adequate current on a repetitive basis without getting damaged. But this current
    requirement should not be continuous.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Burst maximum current**: This is the absolute maximum current that the motor
    driver can handle; anything beyond it will damage the motor driver. The DC motors
    might have a very high current requirement when it starts from a standstill. Hence,
    the motor drivers are designed to handle these currents. But this surge of current
    should not be repetitive, otherwise heating and subsequent damage can happen.
    Often, burst maximum current is referred to as the maximum current by the manufacturers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous maximum current**: This is the real deal; the continuous maximum
    current is the maximum continuous current that the motor driver can mange on a
    continuous basis.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supply voltage**: This is the operating voltage of the motor driver—this
    voltage must be given to the motor driver for its own internal workings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logic supply voltage**: This is the control signal given to the motor driver,
    and can be given at various voltages such as 5V, 3.3V, and 12V. Hence, the motor
    driver will specify the maximum logical voltage that it can accept in the signal
    line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s see what we have got. During the course of this book, we will be
    using the L298N motor driver module, which currently is one of the most common
    motor driver modules available on the market. It has two channels—you have two
    H-bridges and hence you can connect two motors onto it. Further, the specifications
    for this motor driver are also decent for the price. Here are the specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Voltage rating**: 2.5V to 46V'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repetitive maximum current**: 2.5 amp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Burst maximum current**: 3 amp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous maximum current**: 2 amp'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supply voltage**: 4.5V to 7V'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logic supply voltage**: 4.5V to 7V'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have the physical motor driver with you, you will notice the following
    pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Motor A**: This is channel 1 of the motor driver. You can connect the first
    motor to this port.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Motor B**: This is channel 2 of the motor driver. You can connect a second
    motor to this port. If you only have one motor, you can simply leave this port
    unconnected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GND**: This is the ground of the power supply that you will attach for the
    motor. It is very important that you not only connect the ground of the power
    supply but also connect the ground of Raspberry Pi to this port so that the circuit
    is complete between Raspberry Pi and the motor driver.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VCC**: This is the positive port of the motor driver. This is where the positive
    terminal of your battery or power adapter will go.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IN 1 and IN 2**: These are the two logical inputs that we need to provide
    from the microcontroller for motor A. Whenever IN 1 receives the signal, one part
    of the H-bridge is activated—the motor starts spinning in one direction. Whenever
    IN 2 receives the signal, the other part of the H-bridge is activated, making
    the motor spin in the opposite direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IN 3 and IN 4**: This is the logical input of the motor B, which will work
    in exactly the same way as IN 1 and IN 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EN A and EN B**: These are the enable pins for both the channels. If these
    pins are not high, the respective channels will not work despite any signal that
    you give over the input ports. You might notice that there is a small cap on the
    EN ports. This is called a shunt. What it does is that it makes contact between
    the two pins that it has been connected on. This cap, when present over the EN
    pin, means that it would permanently be high as long as this shunt is connected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting it rolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'OK, that''s a lot of theory, so now let''s fire up one of our motors via Raspberry
    Pi. To do that, go ahead and connect the motor and the motor driver as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e0b5815-8180-4424-ab8c-8dbcd4d0d7fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, once you are done with it, let''s upload the code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s understand the code a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Pin number `20` is connected to IN 1 of the motor driver. For convenience,
    we have changed motor 1 right to `Motor1R`; in reality, the motor can spin in
    any direction but we have just written this for convenience and understanding.
    Similarly, we have done this for `Motor1L` as well. This is connected to IN 2,
    hence this will lead to the motor spinning in the other direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are making the `Motor1R` or the pin number `20` high, which means
    that the input motor driver is getting is:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Motor** | **Pin** | **Input** | **State** |'
  prefs: []
  type: TYPE_TB
- en: '| `Motor 1R` | Pin number 20 of Raspberry Pi | IN 1 | `HIGH` |'
  prefs: []
  type: TYPE_TB
- en: '| `Motor 1L` | Pin number 21 of Raspberry Pi | IN 2 | `LOW` |'
  prefs: []
  type: TYPE_TB
- en: 'Now, after a delay of 5 seconds, the following code will run, which will change
    the state of the pins as depicted in the below table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| **Motor** | **Pin** | **Input** | **State** |'
  prefs: []
  type: TYPE_TB
- en: '| `Motor 1R` | Pin number 20 of Raspberry Pi | IN 1 | `LOW` |'
  prefs: []
  type: TYPE_TB
- en: '| `Motor 1L` | Pin number 21 of Raspberry Pi | IN 2 | `HIGH` |'
  prefs: []
  type: TYPE_TB
- en: Now, let's see what happens once we run it. The motor will spin firstly in one
    direction and then it will go in the other direction. The code is very straightforward
    and I don't think there is any need for explanation. All we are doing here is
    simply turning either of the two GPIOs connected to the motor driver on and off.
    Once the input IN 1 of the motor driver is activated, a part of the H-bridge is
    switched on, causing the motor to spin in one direction. Whenever the IN 2 of
    the motor driver is high, then the opposite part of H-bridge is turned on, causing
    the polarity at the output end of the motor driver to change, and hence the motor
    turns in the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have understood how to change the direction of the motor using the
    motor driver, it's time to take it a step further and control the speed of the
    motor using the motor driver. To do this, we don't really have to do much. The
    motor drivers are built to understand the PWM signals. Once the PWM signal to
    the motor driver is provided, then the motor driver in turn adjusts the output
    voltage for the motor and hence changes the speed of the motor driver. The PWM
    has to be provided on the same input ports IN 1 and IN 2 for motor A, and IN 3
    and IN 4 for motor B. It is obvious that the pin on which the PWM is provided
    will decide the direction in which the motor will move, and the duty cycle of
    the PWM will decide the speed at which the motor will be spinning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have understood how speed control in motor driver works. It''s time
    to do it by ourselves. To do so, we do not need to make any changes to the connections;
    all we need to do is to upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened after you ran this code? I''m sure the motor started slowly and
    then started increasing its speed and, upon reaching its top speed, it eventually
    stopped—exactly what we wanted it to do. If you remember, this code looks very
    familiar. Remember changing the brightness of the LED in the first chapter? It
    is almost the same; there are a few differences, though, so let''s see what they
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this line, we are simply defining the pin we have to give the PWM on—as
    in, on `Motor1R`, which corresponds to pin number `20`. Also, we are are defining
    the frequency of the PWM as `100` hertz or 100 times in a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remember, the preceding command from the previous chapters, `pwm.start()`,
    is primarily used for defining the duty cycle of the  signal. Here, we are giving
    it the duty cycle as `0` that is the pin would be off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are running motor in one specific direction and which is `1R` hence the
    other half of the H bridge should be turned off. this would be done by the above
    line by putting the line `1L` LOW. If we don''t do this then the pin `21` can
    be in an arbitrary state, hence it can be either on or off. This might conflict
    with the direction in which the motor is moving and the hardware would not work
    properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here comes the real deal; this line, `for i in range(0,101):`, will keep on
    running the program contained in it until the time the value of `i` is between
    `0` to `101`. It will also increment the value of `i` every time this loop runs.
    Here, every time, the value will increase by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, this is a slightly new command. Previously, we have used the line `pwm.start(0)`
    to assign a duty cycle to the PWM. As we have already assigned a duty cycle value
    to the PWM, to change it we would use the previously mentioned command. The duty
    cycle would be the same as the value of `i`.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, every time the code passes through the `for` loop, the value or the duty
    cycle will increase by one. Super easy, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Everything in robotics is very easy if you do it right. The idea is to break
    your problem into small pieces and solve them one by one; trust me, once you do
    that, nothing will look difficult to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked on the various aspects of a motor. Moving on, by
    using all the basics, we will study the interaction of Bluetooth with mobile devices
    and build a Bluetooth-controlled robotic car.
  prefs: []
  type: TYPE_NORMAL
