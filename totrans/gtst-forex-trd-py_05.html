<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-85"><a id="_idTextAnchor086"/>5</h1>
<h1 id="_idParaDest-86"><a id="_idTextAnchor087"/>Retrieving and Handling Market Data with Python</h1>
<p>If you look at the general logical diagram of a trading application’s architecture, which we devised in <a href="B19145_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Developing Trading Strategies – Why They Are Different</em>, you can see that now we’re moving from the very first module named <code>Receive data</code> to the second one, <code>Cleanup and filter</code>, which features the <strong class="bold">Store</strong> and <strong class="bold">Retrieve</strong> functionality.</p>
<p>In previous chapters, we mentioned many times that any algo trading application is based on market data, and success in algo trading (that is, the ability to make money and not lose it) depends on the quality of the data and its consistency. So, let’s proceed to determine which data we really need to collect and how to make sure the collected data is consistent, then decide about the internal format for the trading app, and the way to store, update, retrieve, and delete data (if necessary).</p>
<p>Upon finishing this chapter, you will have a clear understanding of the most efficient ways of handling and processing market data, and, most importantly, you will learn how to keep your trading app universal so that it could be connected to virtually any data source, live or historical, without rewriting all your code.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Navigating through data</li>
<li>Data compression—keeping the amounts to a reasonable minimum</li>
<li>Working with saved and live data—keeping your app universal</li>
</ul>
<h1 id="_idParaDest-87"><a id="_idTextAnchor088"/>Navigating through data</h1>
<p>The problem<a id="_idIndexMarker269"/> with data collection starts at the very beginning: every data provider offers its own data, quite often in its own format. Some data providers offer only compressed data or snapshots (see later in this chapter) while others broadcast tick-by-tick data; very few data providers also offer order book (<strong class="bold">depth of market</strong> or <strong class="bold">DOM</strong>; see <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s </em><em class="italic">Standpoint</em>) data.</p>
<p>So, first and above all, you <a id="_idIndexMarker270"/>should decide on the data granularity: whether your trading algorithm requires tick-by-tick or compressed data, and if you need DOM data or not. At this stage, you may feel lost with these questions, but don’t worry—you will get a very clear understanding of your data needs when you’ve accomplished further chapters of this book.</p>
<p>Let’s consider all three cases and see how we can actually handle ticks, snapshots, and DOM market data.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/>Tick data and snapshots</h2>
<p>I would like to<a id="_idIndexMarker271"/> reiterate that when we talk about third-party data, formats, and protocols, the ultimate source of the exact information about what is supported and how the third-party documentation is done is your broker.</p>
<p>However, in general, all data providers support two types of market data: tick and snapshots.</p>
<p>Let’s quickly recap the terminology:</p>
<ul>
<li>A <strong class="bold">tick</strong> is a <a id="_idIndexMarker272"/>recorded change in any of the three prices of the traded asset: bid, ask (offer), and last</li>
<li><strong class="bold">Bid</strong> is the<a id="_idIndexMarker273"/> price at which market makers, liquidity providers, and other price givers agree to buy—and consequently, this is the price at which price takers can sell</li>
<li><strong class="bold">Ask</strong> or <strong class="bold">offer</strong> is the price at which price givers are ready to sell—and consequently, this is the price at which price takers can buy</li>
<li>And <strong class="bold">last</strong> is the price at which the latest actual trade was made</li>
</ul>
<p>Let’s consider an example. This is sample tick data that you can receive from LMAX (see the previous chapter for more examples of connecting and retrieving data <a id="_idIndexMarker274"/>from this <strong class="bold">electronic communication </strong><strong class="bold">network</strong> (<strong class="bold">ECN</strong>)):</p>
<pre class="source-code">
{
    "type": "TICKER",
    "instrument_id": "eur-usd",
    "timestamp": "2022-07-29T11:10:54.755Z",
    "best_bid": "1.180970",
    "best_ask": "1.181010",
    "trade_id": "0B5WMAAAAAAAAAAS",
    "last_quantity": "1000.0000",
    "last_price": "1.180970",
    "session_open": "1.181070",
    "session_low": "1.180590",
    "session_high": "1.181390"
}</pre>
<p>First, the <a id="_idIndexMarker275"/>preceding JSON specifies the type of data. In this example, <code>type</code> is <code>TICKER</code>, which means that we’re dealing with a single tick. It is followed by the instrument name.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Many data providers use different notations for the same names of instruments. For example, EUR/USD can be represented by <code>eur-usd</code>, <code>EURUSD</code>, <code>EUR/USD</code>, and even <code>@EURUSD</code>. So, always check the data provider’s documentation, and don’t forget to replace the instrument’s name in the provider’s notation with the internal name used in your application.</p>
<p>For example, if you use the traditional <code>CCY1/CCY2</code> notation, then you may want to use the following code, which will transform the <code>ccy1-ccy2</code> notation used by LMAX to the traditional one:</p>
<pre class="source-code">
instrument_id.replace("-", "/").upper()</pre>
<p>Here, <code>instrument_id</code> is the name of the instrument received with a tick from the data provider, <code>replace()</code> is the built-in sting method that replaces one character with another, and <code>upper()</code> is another built-in method that makes the entire string uppercase.</p>
<p>Next comes<a id="_idIndexMarker276"/> the timestamp, and with timestamps comes another degree of uncertainty because data providers use different standards for timestamps. We will discuss timestamps for market data a bit later in this section.</p>
<p>The following fields are self-explanatory:</p>
<ul>
<li><code>best_bid</code> and <code>best_ask</code> mean the top of the book</li>
<li><code>trade_id</code> is the ID of the latest trade made at this ECN</li>
<li><code>last_quantity</code> and <code>last_price</code> are the size and price at which this latest trade was made</li>
<li><code>session_open</code>, <code>session_low</code>, and <code>session_high</code> mean the first price of the trading session (when the market opens), and the lowest and the highest price from the time the market opened till the time the tick is received</li>
</ul>
<p>As we can see, most of the fields in a tick are self-explanatory and easy to use, but there’s one important exception: <code>timestamp</code>.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/>Timestamps – be careful comparing apples to apples!</h2>
<p>In the<a id="_idIndexMarker277"/> previous section, when we were analyzing the structure of a tick, we noted that it contained a timestamp and that this timestamp may become another source of headache for the developer. This happens because every data provider thinks they’re using the most convenient data format. As always, refer to the provider’s documentation and refer to any tutorial on working with timestamps. If you’re not familiar with timestamps and their standards, I’d recommend starting with an excellent tutorial on working with timestamps in Python by Avinash Navlani on <em class="italic">Dataquest</em> (<a href="https://www.dataquest.io/blog/python-datetime-tutorial">https://www.dataquest.io/blog/python-datetime-tutorial</a>).</p>
<p>Anyway, to keep things simple, a timestamp is a string formatted to one of the standards, and this formatting is normally done by whitespaces, special characters, or regular characters. In the LMAX example in the previous section, the date part is separated from the time part by the letter <code>T</code>, and the entire timestamp is ended with the letter <code>Z</code>.</p>
<p>Python<a id="_idIndexMarker278"/> provides a <code>datetime</code> library that covers flexible handling of timestamps. This library introduces the eponymous <code>datetime</code> object, which has multiple methods to convert strings into timestamps and vice versa. In the upcoming example, we’re going to use <code>strptime</code><code>()</code> to convert the timestamp from a string to a native <code>datetime</code> object.</p>
<p>By using <code>strptime()</code> and other methods, all you need is to specify the format of the input timestamp using correct specifiers (see the Python documentation at <a href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior">https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior</a> for a complete list of specifiers).</p>
<p>So, let’s convert the timestamp from our LMAX example into a native <code>datetime</code> object. First, we import <code>datetime</code> from the <code>datetime</code> library (yes—it does look ridiculous, but what to do?) and then make the conversion:</p>
<pre class="source-code">
from datetime import datetime
ts_str1 = '2022-07-29T11:10:54.755Z'
ts1 = datetime.strptime(ts_str1, '%Y-%m-%dT%H:%M:%S.%fZ')</pre>
<p>Here, we assume that <code>ts_str1</code> is the timestamp already extracted from the tick received from LMAX as XML (JSON). If we run this code and check the value of <code>ts1</code>, then we will see the following:</p>
<pre class="source-code">
In [21]: ts1
Out[21]: datetime.datetime(2022, 7, 29, 11, 10, 54, 755000)</pre>
<p>This means that the conversion was made correctly, and now we can access any component of the timestamp separately. For example, <code>ts1.day</code> returns <code>29</code> (the day of the month), and <code>ts1.microsecond</code> returns <code>755000</code>, which is actually <code>755</code> milliseconds.</p>
<p>The real advantage of using <code>datetime</code> objects is that they can be sorted like numbers. For example, if we receive a new timestamp that is just 1 millisecond past the original one (<code>ts_str2 = '2022-07-29T11:10:54.756Z'</code>) and convert it into a new <code>datetime</code> object (<code>ts2 = datetime.strptime(ts_str2, '%Y-%m-%dT%H:%M:%S.%fZ')</code>), then we can easily compare two timestamps, as follows:</p>
<pre class="source-code">
In [27]: ts1 &gt; ts2
Out[27]: False</pre>
<p>Subsequently, we<a id="_idIndexMarker279"/> can sort them in ascending or descending order.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Never use strings as IDs of timestamps for market data time series. You won’t be able to easily sort data by the exact time it’s arrived, and thus handling data will be extremely inefficient. Use native <code>datetime</code> or pandas timestamps (see the next section).</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/>Storing and retrieving tick data</h2>
<p>There are<a id="_idIndexMarker280"/> three main approaches to storing and processing tick data in Python:</p>
<ul>
<li>Using high-level objects</li>
<li>Using low-level objects</li>
<li>Using pandas</li>
</ul>
<p>High-level objects<a id="_idIndexMarker281"/> are normally created for storing considerable amounts of data or processing the entire historical data (see <a href="B19145_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a><em class="italic">, Using Python for Trading Strategies</em>). In this case, we create a single object whose properties include lists (in case we’re going to store data samples one by one and refer to them by index) or dictionaries (in case we use timestamps to refer to a data sample).</p>
<p>Using dictionaries allows for quick and easy handling of data by timestamp, so this is the preferred method of storing market data. Let’s see an example:</p>
<ol>
<li>Let’s begin with creating a general class:<pre class="source-code">
class data:</pre><pre class="source-code">
    def __init__ (self):</pre><pre class="source-code">
        self.series = {}</pre></li>
</ol>
<p>This <code>main</code> dictionary will store all data samples with timestamps used as keywords.</p>
<ol>
<li value="2">Now, let’s add a method that adds a new data sample to the <code>main</code> dictionary:<pre class="source-code">
def add(self, sample):</pre><pre class="source-code">
        ts = datetime.strptime(sample["timestamp"], '%Y-%m-%dT%H:%M:%S.%fZ')</pre><pre class="source-code">
        self.series[ts] = sample</pre></li>
</ol>
<p>Here, we <a id="_idIndexMarker282"/>assume that the data sample comes<a id="_idIndexMarker283"/> in a form similar to that used by LMAX—that is, JSON, which contains a timestamp in <em class="italic">ISO 8601</em> format. Since the JSON (or XML in general) is basically the same as native Python dictionaries, we add a dictionary to the dictionary. Now, referring to <code>self.series</code> by the timestamp as the keyword will return another dictionary that contains the data sample itself. This is what we referred to as <em class="italic">low-level objects</em> at the beginning of this section.</p>
<p class="callout-heading">Important note</p>
<p class="callout">We can refer to ticks by timestamp only in case the data feed doesn’t send ticks with identical timestamps. This is mostly the case with direct feeds from trading venues. The suggested code will always rewrite the contents of a tick with the last received value with the same timestamp, so if you really need to keep all ticks stored, consider adding <strong class="bold">unique IDs</strong> (<strong class="bold">UIDs</strong>) to<a id="_idIndexMarker284"/> them. The public LMAX data feeds that we’re using throughout the book for development and testing purposes never send ticks with identical timestamps.</p>
<ol>
<li value="3">So, now, let’s add a basic function that finds a data sample by its timestamp:<pre class="source-code">
def get(self, ts, key):</pre><pre class="source-code">
        return self.series[ts][key]</pre></li>
</ol>
<p>Note that two keywords (<code>[ts]</code> and <code>[key]</code>) are used here, one immediately after another. This is exactly because of the data structure just explained: we have dictionaries in a dictionary, so the first keyword <code>[ts]</code> retrieves the data sample dictionary, and the second one—<code>[key]</code>—actually returns the value.</p>
<p>It is important to note here that such a method of retrieving ticks by their timestamps<a id="_idIndexMarker285"/> assumes that we know the exact timestamp<a id="_idIndexMarker286"/> with milliseconds precision. If we are unsure about it or want to extract a few ticks that came—for example—in 1 second or even 1 minute, we can use the following code, which will return a list of ticks whose timestamps start with the same time (actually, we look for a substring in the <code>timestamp</code> key):</p>
<pre class="source-code">
result = [(key, value) for key, value in self.series.items() if key.startswith("2022-07-29T11:10:54")]
return result</pre>
<ol>
<li value="4">OK—let’s give our code a try. Let’s use the same example as before—create a new data series object, add a sample to it, and read the <code>trade_id</code> value:<pre class="source-code">
sample = {</pre><pre class="source-code">
    "type": "TICKER",</pre><pre class="source-code">
    "instrument_id": "eur-usd",</pre><pre class="source-code">
    "timestamp": "2022-07-29T11:10:54.755Z",</pre><pre class="source-code">
    "best_bid": "1.180970",</pre><pre class="source-code">
    "best_ask": "1.181010",</pre><pre class="source-code">
    "trade_id": "0B5WMAAAAAAAAAAS",</pre><pre class="source-code">
    "last_quantity": "1000.0000",</pre><pre class="source-code">
    "last_price": "1.180970",</pre><pre class="source-code">
    "session_open": "1.181070",</pre><pre class="source-code">
    "session_low": "1.180590",</pre><pre class="source-code">
    "session_high": "1.181390"</pre><pre class="source-code">
}</pre><pre class="source-code">
series = data()</pre><pre class="source-code">
series.add(sample)</pre><pre class="source-code">
timestamp = datetime.strptime(sample["timestamp"], '%Y-%m-%dT%H:%M:%S.%fZ')</pre><pre class="source-code">
print(series.get(timestamp, "trade_id"))</pre></li>
</ol>
<p>If we run this code (not forgetting to add <code>from datetime import datetime</code> at the very beginning), we will get <code>0B5WMAAAAAAAAAAS</code>, which is indeed the trade ID of the stored tick data sample.</p>
<p>This way, we<a id="_idIndexMarker287"/> can easily implement creating, adding, and reading<a id="_idIndexMarker288"/> data from our storage without using any database. Of course, this approach will somewhat limit the capabilities of retrieving and aggregating data by other keys—for example, retrieving all ticks with the same price or with a trade quantity that lies in a certain range.</p>
<p class="callout-heading">Remember</p>
<p class="callout">Ignoring or messing with the data, especially the order in which ticks or bars are received, will most likely lead you to develop a strategy which will work only on this damaged data, and won’t work with real market data.</p>
<p>So, for most practical trading applications, it is even better not to be able to get data by any other keyword except for the timestamp. However, if you’re into some kind of academic research and do need special modes of data retrieval, there’s good news for you: pandas will allow you to do even this (we will have a surface look at pandas in <a href="B19145_08.xhtml#_idTextAnchor130"><em class="italic">Chapter 8</em></a>, <em class="italic">Data Visualization in FX Trading </em><em class="italic">with Python</em>).</p>
<p>An alternative way to store tick market data would be in a list, not a dictionary. This way, we could forget about timestamps and read data samples one by one, using an index—which is especially useful when running backtests using historical data.</p>
<p>However, there’s one significant problem with storing market data in lists. In case you need to add any data sample <em class="italic">in the past</em>, you will have to scan the list to find the correct place where to insert the new sample, and this operation is quite time-consuming. So, using dictionaries with timestamps as keywords is always preferable.</p>
<p>You may argue that inserting a sample <em class="italic">in the past</em> sounds ridiculous and is hardly required. Well, just go on reading this chapter, and in the section dedicated to cleaning up the market data, you will see how in demand such a capability may be.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/>Order book (depth of market)</h2>
<p>Some data <a id="_idIndexMarker289"/>providers (not many, actually) are kind enough to provide not only top of book (the best bid and ask prices), but also some depth of market (see the <em class="italic">Exchange and order book</em> section of <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>). In general, receiving order book data is not much different from receiving ticker data. The only difference is that ticker data contains a single value for each bid, ask, and last price, whereas order book data contains multiple values for bids and asks and does not contain any last value.</p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/>Storing and retrieving order book data</h2>
<p>If we look at <a id="_idIndexMarker290"/>the example provided by LMAX in its API documentation, we can see that the JSON representing the order book information can <a id="_idIndexMarker291"/>be interpreted by Python as follows:</p>
<ul>
<li><strong class="bold">Highest level</strong>: A <a id="_idIndexMarker292"/>dictionary similar to that of ticker data, but without last trade and session information</li>
<li><strong class="bold">Lower level</strong>: A<a id="_idIndexMarker293"/> list of bids and asks, sorted by price in descending and ascending order, respectively</li>
<li><strong class="bold">Lowest level</strong>: Another<a id="_idIndexMarker294"/> dictionary that contains the actual price and quantity for each bid and ask:<pre class="source-code">
{</pre><pre class="source-code">
    "type": "ORDER_BOOK",</pre><pre class="source-code">
    "instrument_id": "eur-usd",</pre><pre class="source-code">
    "timestamp": "2022-07-29T11:10:54.755Z",</pre><pre class="source-code">
    "status": "OPEN",</pre><pre class="source-code">
    "bids":</pre><pre class="source-code">
      [</pre><pre class="source-code">
            {</pre><pre class="source-code">
                "price": "1.181060",</pre><pre class="source-code">
                "quantity": "500000.0000"</pre><pre class="source-code">
            },</pre><pre class="source-code">
            {</pre><pre class="source-code">
                "price": "1.181050",</pre><pre class="source-code">
                "quantity": "200000.0000"</pre><pre class="source-code">
            }</pre><pre class="source-code">
      ],</pre><pre class="source-code">
      "asks": [</pre><pre class="source-code">
            {</pre><pre class="source-code">
                "price": "1.181100",</pre><pre class="source-code">
                "quantity": "250000.0000"</pre><pre class="source-code">
            },</pre><pre class="source-code">
            {</pre><pre class="source-code">
                "price": "1.181110",</pre><pre class="source-code">
                "quantity": "350000.0000"</pre><pre class="source-code">
            }</pre><pre class="source-code">
      ]</pre><pre class="source-code">
}</pre></li>
</ul>
<p>Therefore, we can use exactly the same code as we originally used for storing, adding, and reading tick data. We will only need to add another level of indexes and keywords to access actual values. For example, if we add the preceding sample, then we can retrieve the best bid price by the timestamp using the following code:</p>
<pre class="source-code">
best_bid = series.get(timestamp, "bids")[0]["price"]</pre>
<p>The beginning of this line is identical to that of the example with ticker data from the previous section, then<a id="_idIndexMarker295"/> follows the index <code>[0]</code>, which is used to<a id="_idIndexMarker296"/> retrieve the best bid (as both bids and asks are sorted, the first element in the list always contains the best bid or ask), and finally, another keyword—<code>price</code>, used to retrieve the price information out of the price/volume pair.</p>
<p>Now, we can retrieve tick data, but remember that it may occupy too much space in memory or on disk. So, it would be nice to use only the required amount of data for a specific trading strategy. That’s why we proceed with data compression.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/>Data compression – keeping the amounts to a reasonable minimum</h1>
<p>In the <a id="_idIndexMarker297"/>previous section, we already considered one of the most popular data compression techniques used by data providers: snapshots. The difference is that a tick represents a single event (such as a new trade or a change in bid or ask) and a single price value, but a snapshot instead discards information about individual ticks and replaces it with the following prices per period:</p>
<ul>
<li>Price of the first tick of the period (or <strong class="bold">open</strong>)</li>
<li>Maximum price for the period (or <strong class="bold">high</strong>)</li>
<li>Minimum price for the period (or <strong class="bold">low</strong>)</li>
<li>Price of the last tick of the period (or <strong class="bold">close</strong>)</li>
</ul>
<p>For example, if the period is 1 minute and during this minute 100 trades were placed, then the snapshot will replace 100 ticks (or 100 prices) with just 4 prices.</p>
<p>The resulting snapshots are called bars when plotted on charts. Very frequently, traders and developers use <em class="italic">bars</em> instead of <em class="italic">snapshots</em>. Graphically, a bar is typically presented as a vertical line with two dashes. As you can see in the following diagram, the one pointing to the left means the opening (first) price of the interval represented by this bar, and the one pointing to the right means the last (closing) price of the same interval, while the top and bottom of the vertical line represent the maximum and the minimum prices of the interval, respectively. These<a id="_idIndexMarker298"/> bars are called <strong class="bold">Open-High-Low-Close bars</strong> or <strong class="bold">OHLC bars</strong>:</p>
<div><div><img alt="Figure 5.1 – Bars and Japanese candlesticks as a visual representation of data compression" src="img/B19145_5_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Bars and Japanese candlesticks as a visual representation of data compression</p>
<p>In case the left dash is lower than the right one, we say that the bar <em class="italic">closes up</em> or the price movement was upward during that period of time (during that bar). If the right dash is lower than the left one, we say that the bar <em class="italic">closes down</em> or the price movement was downward.</p>
<p>There is another<a id="_idIndexMarker299"/> way of presenting bars, which is known as <strong class="bold">Japanese candlesticks</strong>. They <a id="_idIndexMarker300"/>don’t have dashes to the left and to the right, but instead the range between the open and close prices is drawn as a rectangle. And to show whether the opening price was greater or less than the closing one, we use color coding: white or green normally means that the bar closes up (that the closing price was greater than the opening one), and black or red means that the bar closes down.</p>
<p>Then, is data compression good or bad?</p>
<p>Of course, the answer depends on the intended purpose of using the data compression. In general, data compression allows us to dramatically reduce storage space. Just to give you an idea: 4 years’ worth of historical market data compressed into 1-minute bars takes about 152 MB if saved as an American Standard Code for Information Interchange (ASCII) CSV file. The same time span of tick data will take about 1.4 to 3 GB depending on the type of tick data (whether only the last trade is transmitted as a tick or every change in bid or ask price is included).</p>
<p>Besides that, using data in compressed format radically speeds up the backtesting process (remember that backtesting means simulating trades generated by the algorithm using pre-stored historical price data). No surprise that processing 100,000 records is much faster than processing 1 million.</p>
<p>Therefore, when<a id="_idIndexMarker301"/> you use historical data from a data vendor or download it from your broker’s website, most likely it will be compressed down to 1 minute, 10 seconds, or 1 second, but anyway it’s unlikely to be raw tick data.</p>
<p>When developing trading strategies, we often use much less granular resolutions, such as 1 hour, 4 hours, 1 day, and sometimes even 1 week or 1 month.</p>
<p>However, using compressed data has a serious disadvantage for developers. Since individual ticks are gone, we cannot say which price came first, second, and so on inside an individual bar. In <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation in Python</em>, we will consider serious issues related to using compressed data in trade simulation and see how we can minimize the risk of making a mistake.</p>
<p>As we are now familiar with the concept of data compression, let’s see how we can practically use it. We will start with retrieving already compressed data and then see how we can compress data in our own code.</p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/>Retrieving compressed data</h2>
<p>Some <a id="_idIndexMarker302"/>data vendors, brokers, and trading venues use compressed data for live streaming, but most use it for historical data. In this case, you can download it as XML or—more frequently—as traditional CSV files. Contents again (as always!) depend on the data provider’s free will, but at the very least it should contain the timestamp and the OHLC price data. Some data providers also include the trading volume data and even the number of upticks and downticks (moments when the price changed up or down respectively), as follows:</p>
<pre class="source-code">
Date,Time,Open,High,Low,Close,UpVolume,DownVolume,TotalVolume,
UpTicks,DownTicks,TotalTicks
1/27/2015,13:29:00,1.12942,1.12950,1.12942,1.12949,200,150,639,3,2,8
1/27/2015,13:30:00,1.12947,1.12959,1.12941,1.12941,230,438,888,4,7,12
1/27/2015,13:31:00,1.12953,1.12970,1.12951,1.12965,400,240,650,9,4,14
1/27/2015,13:32:00,1.12944,1.12944,1.12883,1.12883,90,609,749,2,10,13</pre>
<p>Now, let’s see how<a id="_idIndexMarker303"/> we can efficiently read, store, and retrieve historical compressed price data:</p>
<ol>
<li value="1">First, we need some preparations. We will obviously need the <code>datetime</code> module, storage for all data (dictionary), and storage for an individual data sample (another dictionary):<pre class="source-code">
from datetime import datetime</pre><pre class="source-code">
historical_data = {}</pre><pre class="source-code">
sample = {}</pre></li>
<li>Then, we need to read the data. If we’re working with a CSV file, it can be done very easily, as shown here:<pre class="source-code">
file_name = '/path/to/the/data/file'</pre><pre class="source-code">
f = open(file_name)</pre></li>
<li>Let’s read the first line (the header) to avoid possible errors when parsing price data:<pre class="source-code">
f.readline()</pre></li>
<li>Next, we’re going to read lines from the file, one by one:<pre class="source-code">
for line in f:</pre></li>
<li>In the body of this loop, we remove any ending newline characters and parse the received line into a <code>values</code> list:<pre class="source-code">
    values = line.rstrip("\n").split(",")</pre></li>
<li>Now, we’re going to merge the date and the time into a single string and convert it to a <code>datetime</code> object:<pre class="source-code">
    timestamp_string = values[0] + " " + values[1]</pre><pre class="source-code">
    ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S")</pre></li>
<li>After that, we will gather the rest of the info into a dictionary:<pre class="source-code">
    sample["open"] = float(values[2])</pre><pre class="source-code">
    sample["high"] = float(values[3])</pre><pre class="source-code">
    sample["low"]  = float(values[4])</pre><pre class="source-code">
    sample["close"]= float(values[5])</pre><pre class="source-code">
    sample["UpVolume"] = int(values[6])</pre><pre class="source-code">
    sample["DownVolume"] = int(values[7])</pre></li>
<li>Now, add<a id="_idIndexMarker304"/> the new sample to the global dataset dictionary using <code>timestamp</code> as a keyword:<pre class="source-code">
      historical_data[ts] = sample</pre></li>
<li>Now, if we check the data for the first record in the dataset, we will get the following:<pre class="source-code">
{'open': 1.12942, 'high': 1.1295, 'low': 1.12942, 'close': 1.12949, 'UpVolume': 200, 'DownVolume': 150}</pre></li>
<li>Now, if I want to retrieve a particular value for the closing price on a certain date and at a certain time, I may want to use something like the following:<pre class="source-code">
historical_data[timestamp]['close']</pre></li>
</ol>
<p>Where timestamp stands for the timestamp at which you'd like to retrieve the closing price.</p>
<p>When running backtests, we do not retrieve data samples by their timestamp, though; instead, we’d like to have a method to continuously get samples one by one in strict chronological order. Native Python dictionaries normally contain unsorted data; however, there’s a workaround that allows us to sort data by keywords—making dictionary keys sorted and automatically getting data samples sorted always in correct chronological order. Alternatively, you can use the <code>OrderedDict</code> subclass of the Python native <code>dict</code> object, which implements a dictionary with keys pre-sorted (you can find a simple tutorial on <code>OrderedDict</code> at <a href="https://www.tutorialspoint.com/ordereddict-in-python">https://www.tutorialspoint.com/ordereddict-in-python</a>).</p>
<p>To do that, we<a id="_idIndexMarker305"/> use the built-in <code>sorted</code> method, which returns a list of the sorted values for any iterable in ascending order by default—exactly what we want:</p>
<pre class="source-code">
for ts in sorted(historical_data):
    print(historical_data[ts])</pre>
<p>The preceding code will print all data samples from the very first to the very last in strict chronological order (don’t run this code with massive datasets as it will take a lot of time to display!).</p>
<p>Now, we can read historical data, sort it in correct chronological order, and retrieve it one by one—that’s all we need to be ready for backtesting of our algorithms.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/>Compressing market data in Python</h2>
<p>It is quite possible<a id="_idIndexMarker306"/> that even though a full tick data stream is available from the data provider, we still want to compress it, and not only to save disk storage space. The reason for this compression could be much more important, such as our trading algorithm can possibly generate some signals or calculate some auxiliary metrics using historical data that is compressed. Therefore, we also need to feed the algorithm with data compressed in a similar manner. And although tick data provides much more information as such, we may still want to compress it to make it compatible with the trading logic.</p>
<p>The most correct way to compress the data from tick to OHLC bars would be to have a method that receives ticks, recalculates OHL (open-high-low) values with each tick, and then adds the C (close) value when the time comes. For example, if we want to compress ticks into 1-minute bars, this method would create a new bar at the beginning of each minute and complete it when the minute’s interval has passed. Let’s look at an example to understand this better:</p>
<ol>
<li value="1">Let’s assume we have historical tick data in a local file (we will see how properly written code allows us to quickly switch from files to any other source of data):<pre class="source-code">
file_name = '&lt;your_path_name&gt;/EURUSD 1 Tick.csv'</pre><pre class="source-code">
f = open(file_name)</pre><pre class="source-code">
f.readline()</pre></li>
</ol>
<p>We immediately read the first line of the file and never use it as the first line as just the header.</p>
<ol>
<li value="2">Next, we <a id="_idIndexMarker307"/>don’t forget to import <code>datetime</code> and create two dictionaries—one for the entire data series and another for an individual bar:<pre class="source-code">
from datetime import datetime</pre><pre class="source-code">
bars = {}</pre><pre class="source-code">
bar = {}</pre></li>
<li>Next, we set the resolution for our newly formed time-based bars. I recommend using a universal measurement unit here. For example, if you work with relatively slow trading strategies, then you may want to count time in minutes. For greater precision and granularity, you may want to go down to seconds. So, let’s use seconds as units and form 1-minute bars (1-minute bar equals to 60 seconds):<pre class="source-code">
resolution = 60</pre></li>
<li>Next, we should read another line from the file, still outside the main loop, to get the first timestamp. We are going to compare all further timestamps with this one, and as soon as the distance (in time) between the two becomes greater than the resolution (60 seconds in our case), we will start a new bar:<pre class="source-code">
values = f.readline().rstrip("\n").split(",")</pre><pre class="source-code">
timestamp_string = values[0] + " " + values[1]</pre><pre class="source-code">
last_sample_ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S.%f")</pre></li>
</ol>
<p>At last, the main loop starts:</p>
<pre class="source-code">
for line in f:
    values = line.rstrip("\n").split(",")
    timestamp_string = values[0] + " " + values[1]
    ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S.%f")</pre>
<p>Until <a id="_idIndexMarker308"/>this point, the code of the loop body is identical to what we already did—we read a new line and parse it. But then, we compare the received timestamp with the timestamp of the last formed bar or sample:</p>
<pre class="source-code">
    delta = ts - last_sample_ts</pre>
<p>Here, you can feel all the beauty of using timestamps in datetime format. You can add or subtract them as if they were just regular numbers.</p>
<p class="callout-heading">Note for nerds</p>
<p class="callout">Python supports multiple types that handle dates and times. Besides <code>datetime</code>, there is another useful type—<code>timedelta</code>, which allows easily defining time spans. If you want to learn more about <code>timedelta</code> and how to efficiently use it, try this tutorial: <a href="https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/">https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/</a>.</p>
<ol>
<li value="5">Now, when the time delta between the new tick timestamp and the previous fully formed bar timestamp is greater than the resolution, we add the current bar to our <code>bars</code> global dictionary and start a new bar by replacing its values with the same price—the price of the last tick. Don’t forget to convert strings to numbers down the road:<pre class="source-code">
    if delta.seconds &gt;= resolution:</pre><pre class="source-code">
        bars[ts] = bar</pre><pre class="source-code">
        bar["open"]  = float(values[2])</pre><pre class="source-code">
        bar["high"]  = float(values[2])</pre><pre class="source-code">
        bar["low"]   = float(values[2])</pre><pre class="source-code">
        last_sample_ts = ts</pre></li>
</ol>
<p>Alternatively, if <a id="_idIndexMarker309"/>the time delta is still less than the resolution (in our example, it’s under 1 minute), then we just update the values of the current bar:</p>
<pre class="source-code">
    else:
       bar["high"] = max([bar["high"], float(values[2])])
       bar["low"] = min([bar["low"], float(values[2])])
       bar["close"] = float(values[2])</pre>
<p>Seems like we’re done with coding. Alright—let’s run our code, and we will immediately get an error:</p>
<pre class="source-code">
File "/.../example5.py", line 36, in &lt;module&gt;
    bar["high"] = max([bar["high"], float(values[2])])
KeyError: 'high'</pre>
<p>This means that the dictionary in which we form the current bar does not have the <code>high</code> keyword. How can this happen? Of course, it happens during the forming of the very first bar: until we save at least one bar, none of its properties (open, high, low, or close) is available. So, we fix our code by adding a <code>try</code>...<code>except</code> statement:</p>
<pre class="source-code">
else:
        try:
            bar["high"] = max([bar["high"], float(values[2])])
            bar["low"] = min([bar["low"], float(values[2])])
            bar["close"] = float(values[2])
        except:
            print('first bar forming...')</pre>
<p>Now, during the formation of the very first bar, we can see only <code>First bar forming...</code> on the screen. You can replace this message with anything or completely remove it by replacing the <code>print</code> statement with <code>pass</code>.</p>
<ol>
<li value="6">Let’s run <a id="_idIndexMarker310"/>the code again, and we can see that now it’s executed successfully. If we check the last 4 records in the <code>bars</code> variable, we can see that the timestamps of bars indeed have a delta of approximately 1 minute:<pre class="source-code">
datetime.datetime(2022, 8, 8, 18, 53, 8, 64000): {'open': 1.01973,</pre><pre class="source-code">
  'high': 1.01984,</pre><pre class="source-code">
  'low': 1.01972,</pre><pre class="source-code">
  'close': 1.01972},</pre><pre class="source-code">
 datetime.datetime(2022, 8, 8, 18, 54, 8, 347000): {'open': 1.01973,</pre><pre class="source-code">
  'high': 1.01984,</pre><pre class="source-code">
  'low': 1.01972,</pre><pre class="source-code">
  'close': 1.01972},</pre><pre class="source-code">
 datetime.datetime(2022, 8, 8, 18, 55, 10, 731000): {'open': 1.01973,</pre><pre class="source-code">
  'high': 1.01984,</pre><pre class="source-code">
  'low': 1.01972,</pre><pre class="source-code">
  'close': 1.01972},</pre><pre class="source-code">
 datetime.datetime(2022, 8, 8, 18, 56, 12, 81000): {'open': 1.01973,</pre><pre class="source-code">
  'high': 1.01984,</pre><pre class="source-code">
  'low': 1.01972,</pre><pre class="source-code">
  'close': 1.01972}}</pre></li>
</ol>
<p>But wait! The timestamps are OK, but why are all respective prices (comparing open to open, close to close, and so on) in all bars identical?!</p>
<p>Here, we <a id="_idIndexMarker311"/>have an issue that actually is one of the most prominent features of Python as a very well-developed object-oriented language. What we actually do in our code is the following sequence of actions:</p>
<ol>
<li value="1">We create <code>object1</code> (<code>bars</code> dictionary).</li>
<li>We create <code>object2</code> (<code>bar</code> dictionary).</li>
<li>We add <code>object2</code> to <code>object1</code> with a <code>new</code> keyword.</li>
<li>Then, we <em class="italic">modify</em> <code>object2</code>.</li>
<li>Again, we add <code>object2</code> to <code>object1</code> with a <code>new</code> keyword.</li>
<li>...and then repeat this loop.</li>
</ol>
<p>See the point? We thought we’d add a new object every time we wanted to add a new bar to <code>bars</code>, but in reality, we add <em class="italic">the same</em> object—the same <code>bar</code> dictionary—only with modified values. I know that at first, it’s hard to understand, so try to think this way: the <code>bars[ts] = bar</code> assignment means saving a <em class="italic">link</em> to the <code>bar</code> object into the <code>bars</code> object with the <code>ts</code> keyword. In this case, once the <code>bar</code> object itself is modified, the reference to it in the <code>bars</code> object remains the same, so we always get modified values when we try to retrieve the <code>bar</code> object from <code>bars</code>.</p>
<p>But what do we actually want here? Of course, we want to save <em class="italic">every bar individually</em> so that if we update the <code>bar</code> object outside the <code>bars</code> object, its new values <em class="italic">will not affect</em> whatever is already stored in the <code>bars</code> object.</p>
<p>In fact, we want to save not the <code>bar</code> object itself, but <em class="italic">a copy of it,</em> which will remain unmodified when we update the <code>bar</code> object in the future. To do that, we just replace <code>bars[ts] = bar</code> with <code>bars[ts] = dict(bar)</code>. Here, <code>dict</code> is a class that generates a <em class="italic">new</em> dictionary out of any iterable, mapping object, or keyword arguments. In our case, it’s quite simplified as we use a ready dictionary (<code>bar</code>) as the mapping object.</p>
<p>If we run<a id="_idIndexMarker312"/> the code now, with this edit, we can see that not only timestamps are correct, but the price data in <code>bars</code> is correct as well:</p>
<pre class="source-code">
datetime.datetime(2022, 8, 8, 18, 53, 8, 64000): {'open': 1.01982,
  'high': 1.02007,
  'low': 1.01982,
  'close': 1.02001},
 datetime.datetime(2022, 8, 8, 18, 54, 8, 347000): {'open': 1.01996,
  'high': 1.01998,
  'low': 1.01979,
  'close': 1.01981},
 datetime.datetime(2022, 8, 8, 18, 55, 10, 731000): {'open': 1.01977,
  'high': 1.01982,
  'low': 1.01965,
  'close': 1.01965},
 datetime.datetime(2022, 8, 8, 18, 56, 12, 81000): {'open': 1.01968,
  'high': 1.01971,
  'low': 1.01964,
  'close': 1.01968}}</pre>
<p>So, now, we have 1-minute bars formed from tick data.</p>
<p><em class="italic">But what do their </em><em class="italic">timestamps mean?</em></p>
<p><em class="italic">Which time do they </em><em class="italic">actually reference?</em></p>
<p><em class="italic">And why is the seconds value of these timestamps not zero (as we would expect for a 1-minute resolution), but also differs slightly from bar </em><em class="italic">to bar?</em></p>
<p>To answer the first question, our algorithm in its present form saves the timestamp <em class="italic">of the last tick of the time interval</em>. This happens because the trigger by which we start forming a new bar is <code>if delta.seconds &gt;= resolution</code>. So, <code>if</code> starts a new bar as soon as (and no earlier than!) a new tick is received, and the timestamp of this new tick differs from its immediate predecessor by a value (which is called <code>timedelta</code>) that is greater than <code>resolution</code>. In other words, if we set <code>resolution</code> to 1 second, then we start a new bar only when we receive a tick whose timestamp differs from the start (open) of the currently forming bar by 1,000 milliseconds or more.</p>
<p>This <a id="_idIndexMarker313"/>also answers two remaining questions. Since the timestamp of the very first received tick (the first tick in the data file) may not be a <em class="italic">round</em> number and minutes with zero seconds, we start counting 60 seconds not from the beginning of a minute, but from an arbitrary moment.</p>
<p><em class="italic">“Is it good or bad?”</em> you may ask.</p>
<p>Neither.</p>
<p>The correct question here would be “<em class="italic">Does it suit my </em><em class="italic">trading algorithm?</em>”.</p>
<p>And the answer depends on the logic of your algorithm. If it only analyzes the sequence of prices (or maybe volume, if the volume is provided by the data provider) then yes—this method works well and is really easy to implement. However, if your strategy logic assumes triggering orders or doing calculations at the real edge of a minute (or any other time interval), then this method won’t fit.</p>
<p>Luckily, we can easily modify our code so that it’s generating bars with the exact 1-minute resolution. The problem is that there’s no universal way of doing that, and the choice depends on whether you work with a live data stream or with saved tick data. To better understand it, let’s first quickly go back to the problem of retrieving data from external data sources and keeping your trading application modular and scalable. Then, you will understand how the problem of generating correct timestamps can be elegantly solved within this paradigm. All this, coming up in the next section!</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/>Working with saved and live data – keeping your app universal</h1>
<p>In the previous <a id="_idIndexMarker314"/>chapter, we quickly observed various methods to get market data from LMAX, one of the most important ECNs in the FX market. Without going into too much technical detail, we can assume that most other brokers, trading venues, and data vendors use more or less the same protocols and APIs based on socket connections. So, it should not be a problem to re-adapt your code to start retrieving data from a new source.</p>
<p>However, from the previous chapter, I hope you also remember that despite similarities in the transport layer of the connection, almost every data source has its own features that can only be found in its documentation (and sometimes, unfortunately, only in direct talks with its technical support).</p>
<p>This means that even<a id="_idIndexMarker315"/> if you implemented—for example—<strong class="bold">Financial Information eXchange</strong> (<strong class="bold">FIX</strong>) protocol version 4.4 with one broker, it is quite possible that you will have to modify something in your code or FIX dictionary when you want to connect to another broker. With proprietary APIs, the situation is obviously more complex, and sometimes the entire code should be rewritten (everything on top of the transport layer, such as the socket connection).</p>
<p>So, a good practice when building a trading application is to make sure that it has a modular structure where modules have interfaces talking to each other using an internal, built-in, universal transport infrastructure. Such an infrastructure should transfer price information between modules regardless of their particular implementation, even if they are provided by third parties. In this case, you don’t have to modify the entire application once you want to switch to another data source: you just need to write a new module, and a new plugin if you want, which would connect to the new source but deliver data in the same internal format compatible with the rest of the app’s modules.</p>
<p>In general, we want to <a id="_idIndexMarker316"/>create an architecture as shown in <em class="italic">Figure 5</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 5.2 – The most simplistic data transport infrastructure for a trading app" src="img/B19145_5_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The most simplistic data transport infrastructure for a trading app</p>
<p>However, this simplistic<a id="_idIndexMarker317"/> architecture has prominent flaws:</p>
<ul>
<li>It supports only one source of data</li>
<li>It supports only one trading algorithm</li>
</ul>
<p>So, we may <a id="_idIndexMarker318"/>want to upgrade our architecture a bit to add multiple data streams to our trading algorithm, as follows:</p>
<div><div><img alt="Figure 5.3 – Multiple data sources with a single trading algorithm" src="img/B19145_5_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Multiple data sources with a single trading algorithm</p>
<p>Well, this architecture reveals a new problem: how to sync multiple data streams? How to decide which tick to pass to the algo if we have multiple sources? How do we request these sources? If we do that from our global infinite loop (<code>for line in file</code> for data read from a file or <code>while True</code> for socket connections), then we will have a really hard time switching to another data source because it will require rewriting almost the entire code.</p>
<p>Moreover, if we want to run a number of trading algorithms in parallel using a number of data sources, we quickly come to a complete mess:</p>
<div><div><img alt="Figure 5.4 – Using multiple data sources with multiple algorithms in a bad way" src="img/B19145_5_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Using multiple data sources with multiple algorithms in a bad way</p>
<p>Now, we clearly understand <a id="_idIndexMarker319"/>what we actually need to build a robust infrastructure. We need:</p>
<ul>
<li>To be able to run multiple processes of retrieving data <em class="italic">concurrently</em> without interfering with one another</li>
<li>To be able to store received data in universal elastic storage that is being filled with new data and then emptied as older ticks are processed by the trading algorithms</li>
</ul>
<p>So, we are talking about<a id="_idIndexMarker320"/> an architecture as shown in <em class="italic">Figure 5</em><em class="italic">.5</em> with multiple data connectors, each of them having methods to connect, get data, and write it to a kind of a queue, and multiple trading algorithms (about whose internal architecture we don’t know anything yet) exchanging information using universal <em class="italic">elastic storage</em>, as described in the preceding list:</p>
<div><div><img alt="Figure 5.5 – A better architecture of the data transport layer of a trading application" src="img/B19145_5_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – A better architecture of the data transport layer of a trading application</p>
<p>Python<a id="_idIndexMarker321"/> does offer native solutions to both problems in an<a id="_idIndexMarker322"/> exceptionally streamlined and convenient way (as always, though). The ability to run data connectors concurrently is provided by <em class="italic">threads</em>, while the “elastic storage” mentioned previously is a <em class="italic">queue</em>. Let’s give both some insight.</p>
<p>A <strong class="bold">thread</strong> is a <a id="_idIndexMarker323"/>separate branch of execution of the program’s code that runs <em class="italic">concurrently</em> with the main code or in parallel with other threads. It can be implemented only within <a id="_idIndexMarker324"/>the paradigm of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) where we no longer have a single algorithm with a single start and a single end point, but instead, we have objects with their own behavior that can co-exist without interfering with one another or interacting with each other, depending on the will of their creator. So, a thread is an object that runs a function (a method) in parallel with everything else. Exactly what we need for retrieving data from multiple sources without syncing, right?</p>
<p>A <strong class="bold">queue</strong> is... well, a <a id="_idIndexMarker325"/>queue that you can see at a cash desk around Christmas time. Customers are served on a first-come, first-served basis. The data in a Python queue is treated the same way: whatever gets into the queue is moving along as older data is being processed. The moment a new element is retrieved, it is removed from the queue, freeing up space for newer data.</p>
<p>To better understand <a id="_idIndexMarker326"/>how queues work, let’s consider a very simple example:</p>
<pre class="source-code">
import queue
q = queue.Queue()
q.put("Sample 1")
q.put("Sample 2")
print(q.get())</pre>
<p>If you run this code, it will print <code>Sample 1</code> because the very first element in the queue was the <code>Sample 1</code> string. However, if you work in an interactive console and type <code>print(q.get())</code> again (or just add another <code>print(q.get())</code> statement to the code), then this second <code>print</code> statement will print <code>Sample 2</code> because <code>Sample 1</code> was already retrieved by the <code>.get()</code> method and deleted from the queue.</p>
<p>Now that we know what threads and queues are, we can suggest a final draft for the architecture of the data transport layer of our trading application:</p>
<div><div><img alt="Figure 5.6 – The final draft of the architecture of the data transport layer of a trading app" src="img/B19145_5_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The final draft of the architecture of the data transport layer of a trading app</p>
<p>Let’s now try to implement it in code.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/>Universal data connector</h2>
<p>Let’s start with <a id="_idIndexMarker327"/>the necessary preparations:</p>
<ol>
<li value="1">We will need to specify the source data file, read the header, and do some imports:<pre class="source-code">
file_name = '&lt;your_file_path&gt;/EURUSD 1 Tick.csv'</pre><pre class="source-code">
f = open(file_name)</pre><pre class="source-code">
f.readline()</pre><pre class="source-code">
from datetime import datetime</pre><pre class="source-code">
import threading</pre><pre class="source-code">
import queue</pre><pre class="source-code">
import time</pre></li>
<li>Now, let’s create a <a id="_idIndexMarker328"/>universal data stream, something into which all retrieved data will be written. Of course, it’s an instance of Python’s <code>queue</code> class:<pre class="source-code">
datastream = queue.Queue()</pre></li>
<li>And now, let’s create our first method that retrieves data, this time from a local file:<pre class="source-code">
def get_tick():</pre><pre class="source-code">
    tick = {}</pre><pre class="source-code">
    values = f.readline().rstrip("\n").split(",")</pre><pre class="source-code">
    timestamp_string = values[0] + " " + values[1]</pre><pre class="source-code">
    ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S.%f")</pre><pre class="source-code">
    tick[ts] = float(values[2])</pre><pre class="source-code">
    return tick</pre></li>
</ol>
<p>Can you see the already familiar code? Yes, of course—this is just a copy of what we did in the previous section, but this time wrapped into a function. So far, no different from what we did before. The difference comes with the following two functions:</p>
<pre class="source-code">
def emulate_tick_stream():
    while True:
        time.sleep(1)
        temp = get_tick()
        datastream.put(temp)
def trading_algo():
    while True:
      temp = datastream.get()
        print('Received tick ', temp)</pre>
<p>The <a id="_idIndexMarker329"/>first function, <code>emulate_tick_stream()</code>, reads a new tick from the file every second and puts it into the <code>datastream</code> queue.</p>
<p class="callout-heading">Note</p>
<p class="callout">This 1-second delay is added here only for demonstration purposes—real data retrieval methods should not contain any delays!</p>
<p>The second function is simply a prototype—a dummy trading algorithm. It does nothing but report that it successfully received a new data sample.</p>
<ol>
<li value="4">Now, it’s time to run both processes—retrieving and processing data—in parallel. The time has come for Python threads:<pre class="source-code">
data_source_thread = threading.Thread(target = emulate_tick_stream)</pre><pre class="source-code">
data_receiver_thread = threading.Thread(target = trading_algo)</pre></li>
</ol>
<p>This way, we create two instances of the <code>Thread</code> class, one for retrieving data (<code>data_source_thread</code>) and one for processing data (<code>data_receiver_thread</code>). As the only argument, we pass the name of the function that we would like to run within this thread.</p>
<p class="callout-heading">Note</p>
<p class="callout">We pass the function name and do not call the function itself! If you type something such as <code>threading.Thread(target = trading_algo())</code>, the function will be called right <em class="italic">at the point it is passed</em> into the thread, so <em class="italic">the thread will never </em><em class="italic">actually start</em>!</p>
<ol>
<li value="5">All we <a id="_idIndexMarker330"/>need to do now is to run the two threads concurrently:<pre class="source-code">
data_source_thread.start()</pre><pre class="source-code">
data_receiver_thread.start()</pre></li>
</ol>
<p>That’s it! Now if we run the code in a new console window, we will see something like this:</p>
<pre class="source-code">
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 30, 446000): 1.01896})
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 31, 505000): 1.01895})
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 33, 619000): 1.019})
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 36, 793000): 1.01901})</pre>
<p>A new line will appear every second (because we have a delay of 1 second in the <code>get_tick()</code> function).</p>
<p>Even in this simple example, we can see the power of using an object-oriented approach to developing trading apps and especially using threads and queues. Now, you can rewrite the <code>get_tick()</code> function to connect to a totally different data source, and the rest of your code will remain completely, absolutely untouched! You can replace reading from a file with reading from a socket, from a REST API, or from whatever you (or your broker) might imagine. It won’t ever affect the rest of your code, given your new <code>get_tick()</code> function returns data in the same format.</p>
<p>And now, we can get back to the discussion on data compression, which we somehow abruptly dropped in the previous section.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/>Data compression revisited</h2>
<p>Remember <a id="_idIndexMarker331"/>that we compressed tick data into 1-minute bars, but the actual beginning and end of a minute was not when the number of seconds was zero, but at an arbitrary point inside a minute interval? That time, we were unable to solve this problem because we only read data samples one by one from a file at a speed that was unknown to us.</p>
<p>But with the power of threading and queuing, we can form <em class="italic">correct</em> 1-minute (or any N-minute) bars with perfect precision when the new bar starts at exactly 00 seconds. All we need is to add a new function and run it in a thread.</p>
<p class="callout-heading">Note</p>
<p class="callout">Note how easy it is now to customize data processing. We no longer rewrite the entire code—we only add new functionality or modify a single function.</p>
<p>So, let’s create a function that will break our incoming data stream into 1-minute bars simply by using a system timer:</p>
<ol>
<li value="1">We will start with creating a dictionary for the currently forming bar (as in the previous example), and, as always with functions that are supposed to work inside threads, we start with an infinite loop:<pre class="source-code">
def compressor():</pre><pre class="source-code">
      bar = {}</pre><pre class="source-code">
      while True:</pre></li>
<li>Then, we will read data from the data stream:<pre class="source-code">
          tick = datastream.get()</pre></li>
</ol>
<p>Note that this call is universal for any data recipient, be it a trading strategy, a data compressor, a database, or whatever.</p>
<ol>
<li value="3">Next, we will check the current time (system time), and if its seconds value is zero, we will save the formed bar and start a new one:<pre class="source-code">
          current_time = datetime.now()</pre><pre class="source-code">
          if current_time.second == 0:</pre><pre class="source-code">
              bars[current_time] = dict(bar)</pre><pre class="source-code">
              bar["open"]  = tick.values()[0]</pre><pre class="source-code">
              bar["high"]  = tick.values()[0]</pre><pre class="source-code">
              bar["low"]   = tick.values()[0]</pre><pre class="source-code">
              print(bars)</pre></li>
</ol>
<p>The<a id="_idIndexMarker332"/> rest of the code is the same as in the aforementioned example and handles exceptions that are raised when the first bar is not complete:</p>
<pre class="source-code">
            else:
                try:
                    bar["high"] = max([bar["high"], tick.values()[0]])
                    bar["low"] = min([bar["low"], tick.values()[0]])
                    bar["close"] = tick.values()[0]
                except:
                    print(str(current_time), ' bar forming...')</pre>
<p>You can see that this function almost completely copies the code we used in the <em class="italic">Compressing market data in Python</em> section, with the only important modification being that now, instead of comparing timestamps of individual ticks, we finalize the bar <em class="italic">by a system timer</em>. As soon as the <em class="italic">system time</em> passes a minute, which means that its seconds value is zero, we start a new bar.</p>
<p>In fact, synching time is one of the greatest problems in algo trading. The system time on the trading server may differ from the clock at the data vendor’s, and the clock at the broker or ECN may again differ from both. Luckily, in the further examples, we are going to use only 1-second snapshots of live data and 1-minute bars of historical data, so the problem of clock synchronization can be set aside for now.</p>
<p>If you run this code using pre-saved historical tick data, you will see something like this:</p>
<pre class="source-code">
{datetime.datetime(2022, 8, 10, 20, 4, 0, 287224): {}, datetime.datetime(2022, 8, 10, 20, 5, 0, 456837): {'high': 1.01947, 'close': 1.01947, 'open': 1.01918, 'low': 1.01918}, datetime.datetime(2022, 8, 10, 20, 6, 0, 639863): {'high': 1.0195, 'close': 1.01925, 'open': 1.01945, 'low': 1.01925}}</pre>
<p>You can see that<a id="_idIndexMarker333"/> the first bar does not have price data as it was started before the first minute ended. All the following bars have OHLC values that correspond to the <em class="italic">last ticks of the minute</em> by the time the system timer triggered a new bar.</p>
<p>Now, I hope you understand why historical compressed data from a broker always has nice <em class="italic">round</em> timestamps: they do not correspond to actual ticks; they are simply split into bars by the system timer.</p>
<p>You can see that this method works perfectly with live data that is received from a broker, a trading venue, or a similar source. It doesn’t really suit for processing pre-saved historical data because it can be read back from disk at speeds that seriously exceed the real speed at which ticks are being received from the market. So, with historical data, it’s better to use the <em class="italic">tick-to-tick timestamp compare</em> approach that we considered in the <em class="italic">Compressing market data in Python</em> section earlier in this chapter.</p>
<p>If you are not familiar with threads and queues and want to learn more about the ways you can use them in your trading apps, I’d recommend starting with a simple tutorial here (<a href="https://realpython.com/intro-to-python-threading/">https://realpython.com/intro-to-python-threading/</a>) and then referring to the official Python documentation here (<a href="https://docs.python.org/3/library/threading.html">https://docs.python.org/3/library/threading.html</a>) for tips and tricks and deeper understanding.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/>Summary</h1>
<p>In this chapter, we learned how to process both live and historical market data and, most importantly, how to do it in an efficient way. We are now familiar with time-based bars, which are most heavily used in trading strategies. We also learned about the solution that helps keep our trading applications flexible and quickly switch from one data source to another, which will help when switching from testing to production in the future.</p>
<p>Now, we are ready to move on to using the processed market data in our trading strategies. Let’s see how we can do this in the next chapter.</p>
</div>
</body></html>