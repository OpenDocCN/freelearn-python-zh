<html><head></head><body>
<div id="_idContainer026">
<h1 class="chapter-number" id="_idParaDest-85"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-86"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.2.1">Retrieving and Handling Market Data with Python</span></h1>
<p><span class="koboSpan" id="kobo.3.1">If you look at the general logical diagram of a trading application’s architecture, which we devised in </span><a href="B19145_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Developing Trading Strategies – Why They Are Different</span></em><span class="koboSpan" id="kobo.7.1">, you can see that now we’re moving from the very first module named </span><strong class="source-inline"><span class="koboSpan" id="kobo.8.1">Receive data</span></strong><span class="koboSpan" id="kobo.9.1"> to the second one, </span><strong class="source-inline"><span class="koboSpan" id="kobo.10.1">Cleanup and filter</span></strong><span class="koboSpan" id="kobo.11.1">, which features the </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Store</span></strong><span class="koboSpan" id="kobo.13.1"> and </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.14.1">Retrieve</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.15.1"> functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In previous chapters, we mentioned many times that any algo trading application is based on market data, and success in algo trading (that is, the ability to make money and not lose it) depends on the quality of the data and its consistency. </span><span class="koboSpan" id="kobo.16.2">So, let’s proceed to determine which data we really need to collect and how to make sure the collected data is consistent, then decide about the internal format for the trading app, and the way to store, update, retrieve, and delete data (</span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">if necessary).</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">Upon finishing this chapter, you will have a clear understanding of the most efficient ways of handling and processing market data, and, most importantly, you will learn how to keep your trading app universal so that it could be connected to virtually any data source, live or historical, without rewriting all </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">your code.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.22.1">Navigating </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">through data</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Data compression—keeping the amounts to a </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">reasonable minimum</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Working with saved and live data—keeping your </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">app universal</span></span></li>
</ul>
<h1 id="_idParaDest-87"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.28.1">Navigating through data</span></h1>
<p><span class="koboSpan" id="kobo.29.1">The problem</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.30.1"> with data collection starts at the very beginning: every data provider offers its own data, quite often in its own format. </span><span class="koboSpan" id="kobo.30.2">Some data providers offer only compressed data or snapshots (see later in this chapter) while others broadcast tick-by-tick data; very few data providers also offer order book (</span><strong class="bold"><span class="koboSpan" id="kobo.31.1">depth of market</span></strong><span class="koboSpan" id="kobo.32.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">DOM</span></strong><span class="koboSpan" id="kobo.34.1">; see </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.36.1">, </span><em class="italic"><span class="koboSpan" id="kobo.37.1">FX Market Overview from a Developer’s </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.38.1">Standpoint</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">) data.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">So, first and above all, you </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.41.1">should decide on the data granularity: whether your trading algorithm requires tick-by-tick or compressed data, and if you need DOM data or not. </span><span class="koboSpan" id="kobo.41.2">At this stage, you may feel lost with these questions, but don’t worry—you will get a very clear understanding of your data needs when you’ve accomplished further chapters of </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">Let’s consider all three cases and see how we can actually handle ticks, snapshots, and DOM </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">market data.</span></span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.45.1">Tick data and snapshots</span></h2>
<p><span class="koboSpan" id="kobo.46.1">I would like to</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.47.1"> reiterate that when we talk about third-party data, formats, and protocols, the ultimate source of the exact information about what is supported and how the third-party documentation is done is </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">your broker.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">However, in general, all data providers support two types of market data: tick </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">and snapshots.</span></span></p>
<p><span class="koboSpan" id="kobo.51.1">Let’s quickly recap </span><span class="No-Break"><span class="koboSpan" id="kobo.52.1">the terminology:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.53.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">tick</span></strong><span class="koboSpan" id="kobo.55.1"> is a </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.56.1">recorded change in any of the three prices of the traded asset: bid, ask (offer), </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">and last</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.58.1">Bid</span></strong><span class="koboSpan" id="kobo.59.1"> is the</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.60.1"> price at which market makers, liquidity providers, and other price givers agree to buy—and consequently, this is the price at which price takers </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">can sell</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.62.1">Ask</span></strong><span class="koboSpan" id="kobo.63.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">offer</span></strong><span class="koboSpan" id="kobo.65.1"> is the price at which price givers are ready to sell—and consequently, this is the price at which price takers </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">can buy</span></span></li>
<li><span class="koboSpan" id="kobo.67.1">And </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">last</span></strong><span class="koboSpan" id="kobo.69.1"> is the price at which the latest actual trade </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">was made</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.71.1">Let’s consider an example. </span><span class="koboSpan" id="kobo.71.2">This is sample tick data that you can receive from LMAX (see the previous chapter for more examples of connecting and retrieving data </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.72.1">from this </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">electronic communication </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.74.1">network</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.75.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.76.1">ECN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">)):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
{
    "type": "TICKER",
    "instrument_id": "eur-usd",
    "timestamp": "2022-07-29T11:10:54.755Z",
    "best_bid": "1.180970",
    "best_ask": "1.181010",
    "trade_id": "0B5WMAAAAAAAAAAS",
    "last_quantity": "1000.0000",
    "last_price": "1.180970",
    "session_open": "1.181070",
    "session_low": "1.180590",
    "session_high": "1.181390"
}</span></pre>
<p><span class="koboSpan" id="kobo.79.1">First, the </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.80.1">preceding JSON specifies the type of data. </span><span class="koboSpan" id="kobo.80.2">In this example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">type</span></strong><span class="koboSpan" id="kobo.82.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">TICKER</span></strong><span class="koboSpan" id="kobo.84.1">, which means that we’re dealing with a single tick. </span><span class="koboSpan" id="kobo.84.2">It is followed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">instrument name.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.86.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.87.1">Many data providers use different notations for the same names of instruments. </span><span class="koboSpan" id="kobo.87.2">For example, EUR/USD can be represented by </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">eur-usd</span></strong><span class="koboSpan" id="kobo.89.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">EURUSD</span></strong><span class="koboSpan" id="kobo.91.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">EUR/USD</span></strong><span class="koboSpan" id="kobo.93.1">, and even </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">@EURUSD</span></strong><span class="koboSpan" id="kobo.95.1">. </span><span class="koboSpan" id="kobo.95.2">So, always check the data provider’s documentation, and don’t forget to replace the instrument’s name in the provider’s notation with the internal name used in </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">For example, if you use the traditional </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">CCY1/CCY2</span></strong><span class="koboSpan" id="kobo.99.1"> notation, then you may want to use the following code, which will transform the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">ccy1-ccy2</span></strong><span class="koboSpan" id="kobo.101.1"> notation used by LMAX to the </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">traditional one:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.103.1">
instrument_id.replace("-", "/").upper()</span></pre>
<p><span class="koboSpan" id="kobo.104.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">instrument_id</span></strong><span class="koboSpan" id="kobo.106.1"> is the name of the instrument received with a tick from the data provider, </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">replace()</span></strong><span class="koboSpan" id="kobo.108.1"> is the built-in sting method that replaces one character with another, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">upper()</span></strong><span class="koboSpan" id="kobo.110.1"> is another built-in method that makes the entire </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">string uppercase.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Next comes</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.113.1"> the timestamp, and with timestamps comes another degree of uncertainty because data providers use different standards for timestamps. </span><span class="koboSpan" id="kobo.113.2">We will discuss timestamps for market data a bit later in </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">this section.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">The following fields </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">are self-explanatory:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">best_bid</span></strong><span class="koboSpan" id="kobo.118.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">best_ask</span></strong><span class="koboSpan" id="kobo.120.1"> mean the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the book</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">trade_id</span></strong><span class="koboSpan" id="kobo.123.1"> is the ID of the latest trade made at </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">this ECN</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">last_quantity</span></strong><span class="koboSpan" id="kobo.126.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">last_price</span></strong><span class="koboSpan" id="kobo.128.1"> are the size and price at which this latest trade </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">was made</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">session_open</span></strong><span class="koboSpan" id="kobo.131.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">session_low</span></strong><span class="koboSpan" id="kobo.133.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">session_high</span></strong><span class="koboSpan" id="kobo.135.1"> mean the first price of the trading session (when the market opens), and the lowest and the highest price from the time the market opened till the time the tick </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">is received</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.137.1">As we can see, most of the fields in a tick are self-explanatory and easy to use, but there’s one important </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">exception: </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">timestamp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">.</span></span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.141.1">Timestamps – be careful comparing apples to apples!</span></h2>
<p><span class="koboSpan" id="kobo.142.1">In the</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.143.1"> previous section, when we were analyzing the structure of a tick, we noted that it contained a timestamp and that this timestamp may become another source of headache for the developer. </span><span class="koboSpan" id="kobo.143.2">This happens because every data provider thinks they’re using the most convenient data format. </span><span class="koboSpan" id="kobo.143.3">As always, refer to the provider’s documentation and refer to any tutorial on working with timestamps. </span><span class="koboSpan" id="kobo.143.4">If you’re not familiar with timestamps and their standards, I’d recommend starting with an excellent tutorial on working with timestamps in Python by Avinash Navlani on </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.144.1">Dataquest</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.145.1"> (</span></span><a href="https://www.dataquest.io/blog/python-datetime-tutorial"><span class="No-Break"><span class="koboSpan" id="kobo.146.1">https://www.dataquest.io/blog/python-datetime-tutorial</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.147.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">Anyway, to keep things simple, a timestamp is a string formatted to one of the standards, and this formatting is normally done by whitespaces, special characters, or regular characters. </span><span class="koboSpan" id="kobo.148.2">In the LMAX example in the previous section, the date part is separated from the time part by the letter </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">T</span></strong><span class="koboSpan" id="kobo.150.1">, and the entire timestamp is ended with the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">letter </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">Z</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">Python</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.155.1"> provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">datetime</span></strong><span class="koboSpan" id="kobo.157.1"> library that covers flexible handling of timestamps. </span><span class="koboSpan" id="kobo.157.2">This library introduces the eponymous </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">datetime</span></strong><span class="koboSpan" id="kobo.159.1"> object, which has multiple methods to convert strings into timestamps and vice versa. </span><span class="koboSpan" id="kobo.159.2">In the upcoming example, we’re going to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">strptime</span></strong><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">()</span></strong><span class="koboSpan" id="kobo.162.1"> to convert the timestamp from a string to a native </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">datetime</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.164.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">By using </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">strptime()</span></strong><span class="koboSpan" id="kobo.167.1"> and other methods, all you need is to specify the format of the input timestamp using correct specifiers (see the Python documentation at </span><a href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior"><span class="koboSpan" id="kobo.168.1">https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior</span></a><span class="koboSpan" id="kobo.169.1"> for a complete list </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">of specifiers).</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">So, let’s convert the timestamp from our LMAX example into a native </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">datetime</span></strong><span class="koboSpan" id="kobo.173.1"> object. </span><span class="koboSpan" id="kobo.173.2">First, we import </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">datetime</span></strong><span class="koboSpan" id="kobo.175.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">datetime</span></strong><span class="koboSpan" id="kobo.177.1"> library (yes—it does look ridiculous, but what to do?) and then make </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">the conversion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.179.1">
from datetime import datetime
ts_str1 = '2022-07-29T11:10:54.755Z'
ts1 = datetime.strptime(ts_str1, '%Y-%m-%dT%H:%M:%S.%fZ')</span></pre>
<p><span class="koboSpan" id="kobo.180.1">Here, we assume that </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">ts_str1</span></strong><span class="koboSpan" id="kobo.182.1"> is the timestamp already extracted from the tick received from LMAX as XML (JSON). </span><span class="koboSpan" id="kobo.182.2">If we run this code and check the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">ts1</span></strong><span class="koboSpan" id="kobo.184.1">, then we will see </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
In [21]: ts1
Out[21]: datetime.datetime(2022, 7, 29, 11, 10, 54, 755000)</span></pre>
<p><span class="koboSpan" id="kobo.187.1">This means that the conversion was made correctly, and now we can access any component of the timestamp separately. </span><span class="koboSpan" id="kobo.187.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">ts1.day</span></strong><span class="koboSpan" id="kobo.189.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">29</span></strong><span class="koboSpan" id="kobo.191.1"> (the day of the month), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">ts1.microsecond</span></strong><span class="koboSpan" id="kobo.193.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">755000</span></strong><span class="koboSpan" id="kobo.195.1">, which is actually </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">755</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.197.1"> milliseconds.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">The real advantage of using </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">datetime</span></strong><span class="koboSpan" id="kobo.200.1"> objects is that they can be sorted like numbers. </span><span class="koboSpan" id="kobo.200.2">For example, if we receive a new timestamp that is just 1 millisecond past the original one (</span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">ts_str2 = '2022-07-29T11:10:54.756Z'</span></strong><span class="koboSpan" id="kobo.202.1">) and convert it into a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">datetime</span></strong><span class="koboSpan" id="kobo.204.1"> object (</span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">ts2 = datetime.strptime(ts_str2, '%Y-%m-%dT%H:%M:%S.%fZ')</span></strong><span class="koboSpan" id="kobo.206.1">), then we can easily compare two timestamps, </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
In [27]: ts1 &gt; ts2
Out[27]: False</span></pre>
<p><span class="koboSpan" id="kobo.209.1">Subsequently, we</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.210.1"> can sort them in ascending or </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">descending order.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.212.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.213.1">Never use strings as IDs of timestamps for market data time series. </span><span class="koboSpan" id="kobo.213.2">You won’t be able to easily sort data by the exact time it’s arrived, and thus handling data will be extremely inefficient. </span><span class="koboSpan" id="kobo.213.3">Use native </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">datetime</span></strong><span class="koboSpan" id="kobo.215.1"> or pandas timestamps (see the </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">next section).</span></span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.217.1">Storing and retrieving tick data</span></h2>
<p><span class="koboSpan" id="kobo.218.1">There are</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.219.1"> three main approaches to storing and processing tick data </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">in Python:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.221.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">high-level objects</span></span></li>
<li><span class="koboSpan" id="kobo.223.1">Using </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">low-level objects</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.225.1">Using pandas</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.226.1">High-level objects</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.227.1"> are normally created for storing considerable amounts of data or processing the entire historical data (see </span><a href="B19145_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">Chapter 2</span></em></span></a><em class="italic"><span class="koboSpan" id="kobo.229.1">, Using Python for Trading Strategies</span></em><span class="koboSpan" id="kobo.230.1">). </span><span class="koboSpan" id="kobo.230.2">In this case, we create a single object whose properties include lists (in case we’re going to store data samples one by one and refer to them by index) or dictionaries (in case we use timestamps to refer to a </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">data sample).</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">Using dictionaries allows for quick and easy handling of data by timestamp, so this is the preferred method of storing market data. </span><span class="koboSpan" id="kobo.232.2">Let’s see </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">an example:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.234.1">Let’s begin with creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">general class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.236.1">
class data:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.237.1">
    def __init__ (self):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.238.1">
        self.series = {}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.239.1">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">main</span></strong><span class="koboSpan" id="kobo.241.1"> dictionary will store all data samples with timestamps used </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">as keywords.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.243.1">Now, let’s add a method that adds a new data sample to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.245.1"> dictionary:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.246.1">
def add(self, sample):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.247.1">
        ts = datetime.strptime(sample["timestamp"], '%Y-%m-%dT%H:%M:%S.%fZ')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.248.1">
        self.series[ts] = sample</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.249.1">Here, we </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.250.1">assume that the data sample comes</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.251.1"> in a form similar to that used by LMAX—that is, JSON, which contains a timestamp in </span><em class="italic"><span class="koboSpan" id="kobo.252.1">ISO 8601</span></em><span class="koboSpan" id="kobo.253.1"> format. </span><span class="koboSpan" id="kobo.253.2">Since the JSON (or XML in general) is basically the same as native Python dictionaries, we add a dictionary to the dictionary. </span><span class="koboSpan" id="kobo.253.3">Now, referring to </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">self.series</span></strong><span class="koboSpan" id="kobo.255.1"> by the timestamp as the keyword will return another dictionary that contains the data sample itself. </span><span class="koboSpan" id="kobo.255.2">This is what we referred to as </span><em class="italic"><span class="koboSpan" id="kobo.256.1">low-level objects</span></em><span class="koboSpan" id="kobo.257.1"> at the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">this section.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.259.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.260.1">We can refer to ticks by timestamp only in case the data feed doesn’t send ticks with identical timestamps. </span><span class="koboSpan" id="kobo.260.2">This is mostly the case with direct feeds from trading venues. </span><span class="koboSpan" id="kobo.260.3">The suggested code will always rewrite the contents of a tick with the last received value with the same timestamp, so if you really need to keep all ticks stored, consider adding </span><strong class="bold"><span class="koboSpan" id="kobo.261.1">unique IDs</span></strong><span class="koboSpan" id="kobo.262.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.263.1">UIDs</span></strong><span class="koboSpan" id="kobo.264.1">) to</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.265.1"> them. </span><span class="koboSpan" id="kobo.265.2">The public LMAX data feeds that we’re using throughout the book for development and testing purposes never send ticks with </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">identical timestamps.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.267.1">So, now, let’s add a basic function that finds a data sample by </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">its timestamp:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.269.1">
def get(self, ts, key):</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.270.1">
        return self.series[ts][key]</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.271.1">Note that two keywords (</span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">[ts]</span></strong><span class="koboSpan" id="kobo.273.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">[key]</span></strong><span class="koboSpan" id="kobo.275.1">) are used here, one immediately after another. </span><span class="koboSpan" id="kobo.275.2">This is exactly because of the data structure just explained: we have dictionaries in a dictionary, so the first keyword </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">[ts]</span></strong><span class="koboSpan" id="kobo.277.1"> retrieves the data sample dictionary, and the second one—</span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">[key]</span></strong><span class="koboSpan" id="kobo.279.1">—actually returns </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">the value.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">It is important to note here that such a method of retrieving ticks by their timestamps</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.282.1"> assumes that we know the exact timestamp</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.283.1"> with milliseconds precision. </span><span class="koboSpan" id="kobo.283.2">If we are unsure about it or want to extract a few ticks that came—for example—in 1 second or even 1 minute, we can use the following code, which will return a list of ticks whose timestamps start with the same time (actually, we look for a substring in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">timestamp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.285.1"> key):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.286.1">
result = [(key, value) for key, value in self.series.items() if key.startswith("2022-07-29T11:10:54")]
return result</span></pre>
<ol>
<li value="4"><span class="koboSpan" id="kobo.287.1">OK—let’s give our code a try. </span><span class="koboSpan" id="kobo.287.2">Let’s use the same example as before—create a new data series object, add a sample to it, and read the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">trade_id</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1"> value:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.290.1">
sample = {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.291.1">
    "type": "TICKER",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.292.1">
    "instrument_id": "eur-usd",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.293.1">
    "timestamp": "2022-07-29T11:10:54.755Z",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.294.1">
    "best_bid": "1.180970",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.295.1">
    "best_ask": "1.181010",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.296.1">
    "trade_id": "0B5WMAAAAAAAAAAS",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.297.1">
    "last_quantity": "1000.0000",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.298.1">
    "last_price": "1.180970",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.299.1">
    "session_open": "1.181070",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.300.1">
    "session_low": "1.180590",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
    "session_high": "1.181390"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.302.1">
}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.303.1">
series = data()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.304.1">
series.add(sample)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.305.1">
timestamp = datetime.strptime(sample["timestamp"], '%Y-%m-%dT%H:%M:%S.%fZ')</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.306.1">
print(series.get(timestamp, "trade_id"))</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.307.1">If we run this code (not forgetting to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">from datetime import datetime</span></strong><span class="koboSpan" id="kobo.309.1"> at the very beginning), we will get </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">0B5WMAAAAAAAAAAS</span></strong><span class="koboSpan" id="kobo.311.1">, which is indeed the trade ID of the stored tick </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">data sample.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">This way, we</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.314.1"> can easily implement creating, adding, and reading</span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.315.1"> data from our storage without using any database. </span><span class="koboSpan" id="kobo.315.2">Of course, this approach will somewhat limit the capabilities of retrieving and aggregating data by other keys—for example, retrieving all ticks with the same price or with a trade quantity that lies in a </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">certain range.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.317.1">Remember</span></p>
<p class="callout"><span class="koboSpan" id="kobo.318.1">Ignoring or messing with the data, especially the order in which ticks or bars are received, will most likely lead you to develop a strategy which will work only on this damaged data, and won’t work with real </span><span class="No-Break"><span class="koboSpan" id="kobo.319.1">market data.</span></span></p>
<p><span class="koboSpan" id="kobo.320.1">So, for most practical trading applications, it is even better not to be able to get data by any other keyword except for the timestamp. </span><span class="koboSpan" id="kobo.320.2">However, if you’re into some kind of academic research and do need special modes of data retrieval, there’s good news for you: pandas will allow you to do even this (we will have a surface look at pandas in </span><a href="B19145_08.xhtml#_idTextAnchor130"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.321.1">Chapter 8</span></em></span></a><span class="koboSpan" id="kobo.322.1">, </span><em class="italic"><span class="koboSpan" id="kobo.323.1">Data Visualization in FX Trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.324.1">with Python</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">An alternative way to store tick market data would be in a list, not a dictionary. </span><span class="koboSpan" id="kobo.326.2">This way, we could forget about timestamps and read data samples one by one, using an index—which is especially useful when running backtests using </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">historical data.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">However, there’s one significant problem with storing market data in lists. </span><span class="koboSpan" id="kobo.328.2">In case you need to add any data sample </span><em class="italic"><span class="koboSpan" id="kobo.329.1">in the past</span></em><span class="koboSpan" id="kobo.330.1">, you will have to scan the list to find the correct place where to insert the new sample, and this operation is quite time-consuming. </span><span class="koboSpan" id="kobo.330.2">So, using dictionaries with timestamps as keywords is </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">always preferable.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">You may argue that inserting a sample </span><em class="italic"><span class="koboSpan" id="kobo.333.1">in the past</span></em><span class="koboSpan" id="kobo.334.1"> sounds ridiculous and is hardly required. </span><span class="koboSpan" id="kobo.334.2">Well, just go on reading this chapter, and in the section dedicated to cleaning up the market data, you will see how in demand such a capability </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">may be.</span></span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.336.1">Order book (depth of market)</span></h2>
<p><span class="koboSpan" id="kobo.337.1">Some data </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.338.1">providers (not many, actually) are kind enough to provide not only top of book (the best bid and ask prices), but also some depth of market (see the </span><em class="italic"><span class="koboSpan" id="kobo.339.1">Exchange and order book</span></em><span class="koboSpan" id="kobo.340.1"> section of </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.341.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.342.1">, </span><em class="italic"><span class="koboSpan" id="kobo.343.1">FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.344.1">). </span><span class="koboSpan" id="kobo.344.2">In general, receiving order book data is not much different from receiving ticker data. </span><span class="koboSpan" id="kobo.344.3">The only difference is that ticker data contains a single value for each bid, ask, and last price, whereas order book data contains multiple values for bids and asks and does not contain any </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">last value.</span></span></p>
<h2 id="_idParaDest-92"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.346.1">Storing and retrieving order book data</span></h2>
<p><span class="koboSpan" id="kobo.347.1">If we look at </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.348.1">the example provided by LMAX in its API documentation, we can see that the JSON representing the order book information can </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.349.1">be interpreted by Python </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.351.1">Highest level</span></strong><span class="koboSpan" id="kobo.352.1">: A </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.353.1">dictionary similar to that of ticker data, but without last trade and </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">session information</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.355.1">Lower level</span></strong><span class="koboSpan" id="kobo.356.1">: A</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.357.1"> list of bids and asks, sorted by price in descending and ascending </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">order, respectively</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.359.1">Lowest level</span></strong><span class="koboSpan" id="kobo.360.1">: Another</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.361.1"> dictionary that contains the actual price and quantity for each bid </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">and ask:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.363.1">
{</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.364.1">
    "type": "ORDER_BOOK",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.365.1">
    "instrument_id": "eur-usd",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.366.1">
    "timestamp": "2022-07-29T11:10:54.755Z",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.367.1">
    "status": "OPEN",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.368.1">
    "bids":</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.369.1">
      [</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.370.1">
            {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.371.1">
                "price": "1.181060",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.372.1">
                "quantity": "500000.0000"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.373.1">
            },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.374.1">
            {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.375.1">
                "price": "1.181050",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.376.1">
                "quantity": "200000.0000"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.377.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.378.1">
      ],</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.379.1">
      "asks": [</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.380.1">
            {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.381.1">
                "price": "1.181100",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.382.1">
                "quantity": "250000.0000"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.383.1">
            },</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.384.1">
            {</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.385.1">
                "price": "1.181110",</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.386.1">
                "quantity": "350000.0000"</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.387.1">
            }</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.388.1">
      ]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.389.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.390.1">Therefore, we can use exactly the same code as we originally used for storing, adding, and reading tick data. </span><span class="koboSpan" id="kobo.390.2">We will only need to add another level of indexes and keywords to access actual values. </span><span class="koboSpan" id="kobo.390.3">For example, if we add the preceding sample, then we can retrieve the best bid price by the timestamp using the </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
best_bid = series.get(timestamp, "bids")[0]["price"]</span></pre>
<p><span class="koboSpan" id="kobo.393.1">The beginning of this line is identical to that of the example with ticker data from the previous section, then</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.394.1"> follows the index </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">[0]</span></strong><span class="koboSpan" id="kobo.396.1">, which is used to</span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.397.1"> retrieve the best bid (as both bids and asks are sorted, the first element in the list always contains the best bid or ask), and finally, another keyword—</span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">price</span></strong><span class="koboSpan" id="kobo.399.1">, used to retrieve the price information out of the </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">price/volume pair.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">Now, we can retrieve tick data, but remember that it may occupy too much space in memory or on disk. </span><span class="koboSpan" id="kobo.401.2">So, it would be nice to use only the required amount of data for a specific trading strategy. </span><span class="koboSpan" id="kobo.401.3">That’s why we proceed with </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">data compression.</span></span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.403.1">Data compression – keeping the amounts to a reasonable minimum</span></h1>
<p><span class="koboSpan" id="kobo.404.1">In the </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.405.1">previous section, we already considered one of the most popular data compression techniques used by data providers: snapshots. </span><span class="koboSpan" id="kobo.405.2">The difference is that a tick represents a single event (such as a new trade or a change in bid or ask) and a single price value, but a snapshot instead discards information about individual ticks and replaces it with the following prices </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">per period:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.407.1">Price of the first tick of the period (</span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.409.1">open</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.411.1">Maximum price for the period (</span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.413.1">high</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.415.1">Minimum price for the period (</span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.417.1">low</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.419.1">Price of the last tick of the period (</span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">or </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.421.1">close</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.423.1">For example, if the period is 1 minute and during this minute 100 trades were placed, then the snapshot will replace 100 ticks (or 100 prices) with just </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">4 prices.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">The resulting snapshots are called bars when plotted on charts. </span><span class="koboSpan" id="kobo.425.2">Very frequently, traders and developers use </span><em class="italic"><span class="koboSpan" id="kobo.426.1">bars</span></em><span class="koboSpan" id="kobo.427.1"> instead of </span><em class="italic"><span class="koboSpan" id="kobo.428.1">snapshots</span></em><span class="koboSpan" id="kobo.429.1">. </span><span class="koboSpan" id="kobo.429.2">Graphically, a bar is typically presented as a vertical line with two dashes. </span><span class="koboSpan" id="kobo.429.3">As you can see in the following diagram, the one pointing to the left means the opening (first) price of the interval represented by this bar, and the one pointing to the right means the last (closing) price of the same interval, while the top and bottom of the vertical line represent the maximum and the minimum prices of the interval, respectively. </span><span class="koboSpan" id="kobo.429.4">These</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.430.1"> bars are called </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Open-High-Low-Close bars</span></strong><span class="koboSpan" id="kobo.432.1"> or </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.433.1">OHLC bars</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer020">
<span class="koboSpan" id="kobo.435.1"><img alt="Figure 5.1 – Bars and Japanese candlesticks as a visual representation of data compression" src="image/B19145_5_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.436.1">Figure 5.1 – Bars and Japanese candlesticks as a visual representation of data compression</span></p>
<p><span class="koboSpan" id="kobo.437.1">In case the left dash is lower than the right one, we say that the bar </span><em class="italic"><span class="koboSpan" id="kobo.438.1">closes up</span></em><span class="koboSpan" id="kobo.439.1"> or the price movement was upward during that period of time (during that bar). </span><span class="koboSpan" id="kobo.439.2">If the right dash is lower than the left one, we say that the bar </span><em class="italic"><span class="koboSpan" id="kobo.440.1">closes down</span></em><span class="koboSpan" id="kobo.441.1"> or the price movement </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">was downward.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">There is another</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.444.1"> way of presenting bars, which is known as </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">Japanese candlesticks</span></strong><span class="koboSpan" id="kobo.446.1">. </span><span class="koboSpan" id="kobo.446.2">They </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.447.1">don’t have dashes to the left and to the right, but instead the range between the open and close prices is drawn as a rectangle. </span><span class="koboSpan" id="kobo.447.2">And to show whether the opening price was greater or less than the closing one, we use color coding: white or green normally means that the bar closes up (that the closing price was greater than the opening one), and black or red means that the bar </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">closes down.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Then, is data compression good </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">or bad?</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">Of course, the answer depends on the intended purpose of using the data compression. </span><span class="koboSpan" id="kobo.451.2">In general, data compression allows us to dramatically reduce storage space. </span><span class="koboSpan" id="kobo.451.3">Just to give you an idea: 4 years’ worth of historical market data compressed into 1-minute bars takes about 152 MB if saved as an American Standard Code for Information Interchange (ASCII) CSV file. </span><span class="koboSpan" id="kobo.451.4">The same time span of tick data will take about 1.4 to 3 GB depending on the type of tick data (whether only the last trade is transmitted as a tick or every change in bid or ask price </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">is included).</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">Besides that, using data in compressed format radically speeds up the backtesting process (remember that backtesting means simulating trades generated by the algorithm using pre-stored historical price data). </span><span class="koboSpan" id="kobo.453.2">No surprise that processing 100,000 records is much faster than processing </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">1 million.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Therefore, when</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.456.1"> you use historical data from a data vendor or download it from your broker’s website, most likely it will be compressed down to 1 minute, 10 seconds, or 1 second, but anyway it’s unlikely to be raw </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">tick data.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">When developing trading strategies, we often use much less granular resolutions, such as 1 hour, 4 hours, 1 day, and sometimes even 1 week or </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">1 month.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">However, using compressed data has a serious disadvantage for developers. </span><span class="koboSpan" id="kobo.460.2">Since individual ticks are gone, we cannot say which price came first, second, and so on inside an individual bar. </span><span class="koboSpan" id="kobo.460.3">In </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.461.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.462.1">, </span><em class="italic"><span class="koboSpan" id="kobo.463.1">Types of Orders and Their Simulation in Python</span></em><span class="koboSpan" id="kobo.464.1">, we will consider serious issues related to using compressed data in trade simulation and see how we can minimize the risk of making </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">a mistake.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">As we are now familiar with the concept of data compression, let’s see how we can practically use it. </span><span class="koboSpan" id="kobo.466.2">We will start with retrieving already compressed data and then see how we can compress data in our </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">own code.</span></span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.468.1">Retrieving compressed data</span></h2>
<p><span class="koboSpan" id="kobo.469.1">Some </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.470.1">data vendors, brokers, and trading venues use compressed data for live streaming, but most use it for historical data. </span><span class="koboSpan" id="kobo.470.2">In this case, you can download it as XML or—more frequently—as traditional CSV files. </span><span class="koboSpan" id="kobo.470.3">Contents again (as always!) depend on the data provider’s free will, but at the very least it should contain the timestamp and the OHLC price data. </span><span class="koboSpan" id="kobo.470.4">Some data providers also include the trading volume data and even the number of upticks and downticks (moments when the price changed up or down respectively), </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.472.1">
Date,Time,Open,High,Low,Close,UpVolume,DownVolume,TotalVolume,
UpTicks,DownTicks,TotalTicks
1/27/2015,13:29:00,1.12942,1.12950,1.12942,1.12949,200,150,639,3,2,8
1/27/2015,13:30:00,1.12947,1.12959,1.12941,1.12941,230,438,888,4,7,12
1/27/2015,13:31:00,1.12953,1.12970,1.12951,1.12965,400,240,650,9,4,14
1/27/2015,13:32:00,1.12944,1.12944,1.12883,1.12883,90,609,749,2,10,13</span></pre>
<p><span class="koboSpan" id="kobo.473.1">Now, let’s see how</span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.474.1"> we can efficiently read, store, and retrieve historical compressed </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">price data:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.476.1">First, we need some preparations. </span><span class="koboSpan" id="kobo.476.2">We will obviously need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">datetime</span></strong><span class="koboSpan" id="kobo.478.1"> module, storage for all data (dictionary), and storage for an individual data sample (</span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">another dictionary):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.480.1">
from datetime import datetime</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.481.1">
historical_data = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.482.1">
sample = {}</span></pre></li>
<li><span class="koboSpan" id="kobo.483.1">Then, we need to read the data. </span><span class="koboSpan" id="kobo.483.2">If we’re working with a CSV file, it can be done very easily, as </span><span class="No-Break"><span class="koboSpan" id="kobo.484.1">shown here:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.485.1">
file_name = '/path/to/the/data/file'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.486.1">
f = open(file_name)</span></pre></li>
<li><span class="koboSpan" id="kobo.487.1">Let’s read the first line (the header) to avoid possible errors when parsing </span><span class="No-Break"><span class="koboSpan" id="kobo.488.1">price data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.489.1">
f.readline()</span></pre></li>
<li><span class="koboSpan" id="kobo.490.1">Next, we’re going to read lines from the file, one </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">by one:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.492.1">
for line in f:</span></pre></li>
<li><span class="koboSpan" id="kobo.493.1">In the body of this loop, we remove any ending newline characters and parse the received line into a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">values</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.495.1"> list:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.496.1">
    values = line.rstrip("\n").split(",")</span></pre></li>
<li><span class="koboSpan" id="kobo.497.1">Now, we’re going to merge the date and the time into a single string and convert it to a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">datetime</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.499.1"> object:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.500.1">
    timestamp_string = values[0] + " " + values[1]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.501.1">
    ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S")</span></pre></li>
<li><span class="koboSpan" id="kobo.502.1">After that, we will gather the rest of the info into </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">a dictionary:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.504.1">
    sample["open"] = float(values[2])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.505.1">
    sample["high"] = float(values[3])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.506.1">
    sample["low"]  = float(values[4])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.507.1">
    sample["close"]= float(values[5])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.508.1">
    sample["UpVolume"] = int(values[6])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.509.1">
    sample["DownVolume"] = int(values[7])</span></pre></li>
<li><span class="koboSpan" id="kobo.510.1">Now, add</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.511.1"> the new sample to the global dataset dictionary using </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">timestamp</span></strong><span class="koboSpan" id="kobo.513.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">a keyword:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.515.1">
      historical_data[ts] = sample</span></pre></li>
<li><span class="koboSpan" id="kobo.516.1">Now, if we check the data for the first record in the dataset, we will get </span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.518.1">
{'open': 1.12942, 'high': 1.1295, 'low': 1.12942, 'close': 1.12949, 'UpVolume': 200, 'DownVolume': 150}</span></pre></li>
<li><span class="koboSpan" id="kobo.519.1">Now, if I want to retrieve a particular value for the closing price on a certain date and at a certain time, I may want to use something like </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.521.1">
historical_data[timestamp]['close']</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.522.1">Where timestamp stands for the timestamp at which you'd like to retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">closing price.</span></span></p>
<p><span class="koboSpan" id="kobo.524.1">When running backtests, we do not retrieve data samples by their timestamp, though; instead, we’d like to have a method to continuously get samples one by one in strict chronological order. </span><span class="koboSpan" id="kobo.524.2">Native Python dictionaries normally contain unsorted data; however, there’s a workaround that allows us to sort data by keywords—making dictionary keys sorted and automatically getting data samples sorted always in correct chronological order. </span><span class="koboSpan" id="kobo.524.3">Alternatively, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">OrderedDict</span></strong><span class="koboSpan" id="kobo.526.1"> subclass of the Python native </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">dict</span></strong><span class="koboSpan" id="kobo.528.1"> object, which implements a dictionary with keys pre-sorted (you can find a simple tutorial on </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">OrderedDict</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.530.1">at </span></span><a href="https://www.tutorialspoint.com/ordereddict-in-python"><span class="No-Break"><span class="koboSpan" id="kobo.531.1">https://www.tutorialspoint.com/ordereddict-in-python</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.532.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">To do that, we</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.534.1"> use the built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.535.1">sorted</span></strong><span class="koboSpan" id="kobo.536.1"> method, which returns a list of the sorted values for any iterable in ascending order by default—exactly what </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">we want:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.538.1">
for ts in sorted(historical_data):
    print(historical_data[ts])</span></pre>
<p><span class="koboSpan" id="kobo.539.1">The preceding code will print all data samples from the very first to the very last in strict chronological order (don’t run this code with massive datasets as it will take a lot of time </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">to display!).</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">Now, we can read historical data, sort it in correct chronological order, and retrieve it one by one—that’s all we need to be ready for backtesting of </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">our algorithms.</span></span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.543.1">Compressing market data in Python</span></h2>
<p><span class="koboSpan" id="kobo.544.1">It is quite possible</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.545.1"> that even though a full tick data stream is available from the data provider, we still want to compress it, and not only to save disk storage space. </span><span class="koboSpan" id="kobo.545.2">The reason for this compression could be much more important, such as our trading algorithm can possibly generate some signals or calculate some auxiliary metrics using historical data that is compressed. </span><span class="koboSpan" id="kobo.545.3">Therefore, we also need to feed the algorithm with data compressed in a similar manner. </span><span class="koboSpan" id="kobo.545.4">And although tick data provides much more information as such, we may still want to compress it to make it compatible with the </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">trading logic.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">The most correct way to compress the data from tick to OHLC bars would be to have a method that receives ticks, recalculates OHL (open-high-low) values with each tick, and then adds the C (close) value when the time comes. </span><span class="koboSpan" id="kobo.547.2">For example, if we want to compress ticks into 1-minute bars, this method would create a new bar at the beginning of each minute and complete it when the minute’s interval has passed. </span><span class="koboSpan" id="kobo.547.3">Let’s look at an example to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">this better:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.549.1">Let’s assume we have historical tick data in a local file (we will see how properly written code allows us to quickly switch from files to any other source </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">of data):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.551.1">
file_name = '&lt;your_path_name&gt;/EURUSD 1 Tick.csv'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.552.1">
f = open(file_name)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.553.1">
f.readline()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.554.1">We immediately read the first line of the file and never use it as the first line as just </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">the header.</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.556.1">Next, we </span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.557.1">don’t forget to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">datetime</span></strong><span class="koboSpan" id="kobo.559.1"> and create two dictionaries—one for the entire data series and another for an </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">individual bar:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.561.1">
from datetime import datetime</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.562.1">
bars = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.563.1">
bar = {}</span></pre></li>
<li><span class="koboSpan" id="kobo.564.1">Next, we set the resolution for our newly formed time-based bars. </span><span class="koboSpan" id="kobo.564.2">I recommend using a universal measurement unit here. </span><span class="koboSpan" id="kobo.564.3">For example, if you work with relatively slow trading strategies, then you may want to count time in minutes. </span><span class="koboSpan" id="kobo.564.4">For greater precision and granularity, you may want to go down to seconds. </span><span class="koboSpan" id="kobo.564.5">So, let’s use seconds as units and form 1-minute bars (1-minute bar equals to </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">60 seconds):</span></span><pre class="source-code"><span class="koboSpan" id="kobo.566.1">
resolution = 60</span></pre></li>
<li><span class="koboSpan" id="kobo.567.1">Next, we should read another line from the file, still outside the main loop, to get the first timestamp. </span><span class="koboSpan" id="kobo.567.2">We are going to compare all further timestamps with this one, and as soon as the distance (in time) between the two becomes greater than the resolution (60 seconds in our case), we will start a </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">new bar:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.569.1">
values = f.readline().rstrip("\n").split(",")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.570.1">
timestamp_string = values[0] + " " + values[1]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.571.1">
last_sample_ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S.%f")</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.572.1">At last, the main </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">loop starts:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.574.1">
for line in f:
    values = line.rstrip("\n").split(",")
    timestamp_string = values[0] + " " + values[1]
    ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S.%f")</span></pre>
<p><span class="koboSpan" id="kobo.575.1">Until </span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.576.1">this point, the code of the loop body is identical to what we already did—we read a new line and parse it. </span><span class="koboSpan" id="kobo.576.2">But then, we compare the received timestamp with the timestamp of the last formed bar </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">or sample:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
    delta = ts - last_sample_ts</span></pre>
<p><span class="koboSpan" id="kobo.579.1">Here, you can feel all the beauty of using timestamps in datetime format. </span><span class="koboSpan" id="kobo.579.2">You can add or subtract them as if they were just </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">regular numbers.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.581.1">Note for nerds</span></p>
<p class="callout"><span class="koboSpan" id="kobo.582.1">Python supports multiple types that handle dates and times. </span><span class="koboSpan" id="kobo.582.2">Besides </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">datetime</span></strong><span class="koboSpan" id="kobo.584.1">, there is another useful type—</span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">timedelta</span></strong><span class="koboSpan" id="kobo.586.1">, which allows easily defining time spans. </span><span class="koboSpan" id="kobo.586.2">If you want to learn more about </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">timedelta</span></strong><span class="koboSpan" id="kobo.588.1"> and how to efficiently use it, try this </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">tutorial: </span></span><a href="https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/"><span class="No-Break"><span class="koboSpan" id="kobo.590.1">https://tutorial.eyehunts.com/python/python-timedelta-difference-two-date-time-datetime/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.591.1">.</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.592.1">Now, when the time delta between the new tick timestamp and the previous fully formed bar timestamp is greater than the resolution, we add the current bar to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.593.1">bars</span></strong><span class="koboSpan" id="kobo.594.1"> global dictionary and start a new bar by replacing its values with the same price—the price of the last tick. </span><span class="koboSpan" id="kobo.594.2">Don’t forget to convert strings to numbers down </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">the road:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.596.1">
    if delta.seconds &gt;= resolution:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.597.1">
        bars[ts] = bar</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.598.1">
        bar["open"]  = float(values[2])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.599.1">
        bar["high"]  = float(values[2])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.600.1">
        bar["low"]   = float(values[2])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.601.1">
        last_sample_ts = ts</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.602.1">Alternatively, if </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.603.1">the time delta is still less than the resolution (in our example, it’s under 1 minute), then we just update the values of the </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">current bar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.605.1">
    else:
       bar["high"] = max([bar["high"], float(values[2])])
       bar["low"] = min([bar["low"], float(values[2])])
       bar["close"] = float(values[2])</span></pre>
<p><span class="koboSpan" id="kobo.606.1">Seems like we’re done with coding. </span><span class="koboSpan" id="kobo.606.2">Alright—let’s run our code, and we will immediately get </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">an error:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.608.1">
File "/.../example5.py", line 36, in &lt;module&gt;
    bar["high"] = max([bar["high"], float(values[2])])
KeyError: 'high'</span></pre>
<p><span class="koboSpan" id="kobo.609.1">This means that the dictionary in which we form the current bar does not have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">high</span></strong><span class="koboSpan" id="kobo.611.1"> keyword. </span><span class="koboSpan" id="kobo.611.2">How can this happen? </span><span class="koboSpan" id="kobo.611.3">Of course, it happens during the forming of the very first bar: until we save at least one bar, none of its properties (open, high, low, or close) is available. </span><span class="koboSpan" id="kobo.611.4">So, we fix our code by adding a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">try</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">...</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">except</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.615.1"> statement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.616.1">
else:
        try:
            bar["high"] = max([bar["high"], float(values[2])])
            bar["low"] = min([bar["low"], float(values[2])])
            bar["close"] = float(values[2])
        except:
            print('first bar forming...')</span></pre>
<p><span class="koboSpan" id="kobo.617.1">Now, during the formation of the very first bar, we can see only </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">First bar forming...</span></strong><span class="koboSpan" id="kobo.619.1"> on the screen. </span><span class="koboSpan" id="kobo.619.2">You can replace this message with anything or completely remove it by replacing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">print</span></strong><span class="koboSpan" id="kobo.621.1"> statement </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">pass</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">.</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.625.1">Let’s run </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.626.1">the code again, and we can see that now it’s executed successfully. </span><span class="koboSpan" id="kobo.626.2">If we check the last 4 records in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">bars</span></strong><span class="koboSpan" id="kobo.628.1"> variable, we can see that the timestamps of bars indeed have a delta of approximately </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">1 minute:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.630.1">
datetime.datetime(2022, 8, 8, 18, 53, 8, 64000): {'open': 1.01973,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.631.1">
  'high': 1.01984,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.632.1">
  'low': 1.01972,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.633.1">
  'close': 1.01972},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.634.1">
 datetime.datetime(2022, 8, 8, 18, 54, 8, 347000): {'open': 1.01973,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.635.1">
  'high': 1.01984,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.636.1">
  'low': 1.01972,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.637.1">
  'close': 1.01972},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.638.1">
 datetime.datetime(2022, 8, 8, 18, 55, 10, 731000): {'open': 1.01973,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.639.1">
  'high': 1.01984,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.640.1">
  'low': 1.01972,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.641.1">
  'close': 1.01972},</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.642.1">
 datetime.datetime(2022, 8, 8, 18, 56, 12, 81000): {'open': 1.01973,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.643.1">
  'high': 1.01984,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.644.1">
  'low': 1.01972,</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.645.1">
  'close': 1.01972}}</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.646.1">But wait! </span><span class="koboSpan" id="kobo.646.2">The timestamps are OK, but why are all respective prices (comparing open to open, close to close, and so on) in all </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">bars identical?!</span></span></p>
<p><span class="koboSpan" id="kobo.648.1">Here, we </span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.649.1">have an issue that actually is one of the most prominent features of Python as a very well-developed object-oriented language. </span><span class="koboSpan" id="kobo.649.2">What we actually do in our code is the following sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.650.1">of actions:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.651.1">We create </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">object1</span></strong><span class="koboSpan" id="kobo.653.1"> (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">bars</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1"> dictionary).</span></span></li>
<li><span class="koboSpan" id="kobo.656.1">We create </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">object2</span></strong><span class="koboSpan" id="kobo.658.1"> (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">bar</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.660.1"> dictionary).</span></span></li>
<li><span class="koboSpan" id="kobo.661.1">We add </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">object2</span></strong><span class="koboSpan" id="kobo.663.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">object1</span></strong><span class="koboSpan" id="kobo.665.1"> with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">new</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1"> keyword.</span></span></li>
<li><span class="koboSpan" id="kobo.668.1">Then, we </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.669.1">modify</span></em></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">object2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.672.1">Again, we add </span><strong class="source-inline"><span class="koboSpan" id="kobo.673.1">object2</span></strong><span class="koboSpan" id="kobo.674.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">object1</span></strong><span class="koboSpan" id="kobo.676.1"> with a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.677.1">new</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.678.1"> keyword.</span></span></li>
<li><span class="koboSpan" id="kobo.679.1">...and then repeat </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">this loop.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.681.1">See the point? </span><span class="koboSpan" id="kobo.681.2">We thought we’d add a new object every time we wanted to add a new bar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">bars</span></strong><span class="koboSpan" id="kobo.683.1">, but in reality, we add </span><em class="italic"><span class="koboSpan" id="kobo.684.1">the same</span></em><span class="koboSpan" id="kobo.685.1"> object—the same </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">bar</span></strong><span class="koboSpan" id="kobo.687.1"> dictionary—only with modified values. </span><span class="koboSpan" id="kobo.687.2">I know that at first, it’s hard to understand, so try to think this way: the </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">bars[ts] = bar</span></strong><span class="koboSpan" id="kobo.689.1"> assignment means saving a </span><em class="italic"><span class="koboSpan" id="kobo.690.1">link</span></em><span class="koboSpan" id="kobo.691.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">bar</span></strong><span class="koboSpan" id="kobo.693.1"> object into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">bars</span></strong><span class="koboSpan" id="kobo.695.1"> object with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">ts</span></strong><span class="koboSpan" id="kobo.697.1"> keyword. </span><span class="koboSpan" id="kobo.697.2">In this case, once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">bar</span></strong><span class="koboSpan" id="kobo.699.1"> object itself is modified, the reference to it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">bars</span></strong><span class="koboSpan" id="kobo.701.1"> object remains the same, so we always get modified values when we try to retrieve the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">bar</span></strong><span class="koboSpan" id="kobo.703.1"> object </span><span class="No-Break"><span class="koboSpan" id="kobo.704.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">bars</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.707.1">But what do we actually want here? </span><span class="koboSpan" id="kobo.707.2">Of course, we want to save </span><em class="italic"><span class="koboSpan" id="kobo.708.1">every bar individually</span></em><span class="koboSpan" id="kobo.709.1"> so that if we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">bar</span></strong><span class="koboSpan" id="kobo.711.1"> object outside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">bars</span></strong><span class="koboSpan" id="kobo.713.1"> object, its new values </span><em class="italic"><span class="koboSpan" id="kobo.714.1">will not affect</span></em><span class="koboSpan" id="kobo.715.1"> whatever is already stored in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">bars</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.717.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.718.1">In fact, we want to save not the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">bar</span></strong><span class="koboSpan" id="kobo.720.1"> object itself, but </span><em class="italic"><span class="koboSpan" id="kobo.721.1">a copy of it,</span></em><span class="koboSpan" id="kobo.722.1"> which will remain unmodified when we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">bar</span></strong><span class="koboSpan" id="kobo.724.1"> object in the future. </span><span class="koboSpan" id="kobo.724.2">To do that, we just replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">bars[ts] = bar</span></strong><span class="koboSpan" id="kobo.726.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">bars[ts] = dict(bar)</span></strong><span class="koboSpan" id="kobo.728.1">. </span><span class="koboSpan" id="kobo.728.2">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.729.1">dict</span></strong><span class="koboSpan" id="kobo.730.1"> is a class that generates a </span><em class="italic"><span class="koboSpan" id="kobo.731.1">new</span></em><span class="koboSpan" id="kobo.732.1"> dictionary out of any iterable, mapping object, or keyword arguments. </span><span class="koboSpan" id="kobo.732.2">In our case, it’s quite simplified as we use a ready dictionary (</span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">bar</span></strong><span class="koboSpan" id="kobo.734.1">) as the </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">mapping object.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">If we run</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.737.1"> the code now, with this edit, we can see that not only timestamps are correct, but the price data in </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">bars</span></strong><span class="koboSpan" id="kobo.739.1"> is correct </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">as well:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.741.1">
datetime.datetime(2022, 8, 8, 18, 53, 8, 64000): {'open': 1.01982,
  'high': 1.02007,
  'low': 1.01982,
  'close': 1.02001},
 datetime.datetime(2022, 8, 8, 18, 54, 8, 347000): {'open': 1.01996,
  'high': 1.01998,
  'low': 1.01979,
  'close': 1.01981},
 datetime.datetime(2022, 8, 8, 18, 55, 10, 731000): {'open': 1.01977,
  'high': 1.01982,
  'low': 1.01965,
  'close': 1.01965},
 datetime.datetime(2022, 8, 8, 18, 56, 12, 81000): {'open': 1.01968,
  'high': 1.01971,
  'low': 1.01964,
  'close': 1.01968}}</span></pre>
<p><span class="koboSpan" id="kobo.742.1">So, now, we have 1-minute bars formed from </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">tick data.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.744.1">But what do their </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.745.1">timestamps mean?</span></em></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.746.1">Which time do they </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.747.1">actually reference?</span></em></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.748.1">And why is the seconds value of these timestamps not zero (as we would expect for a 1-minute resolution), but also differs slightly from bar </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.749.1">to bar?</span></em></span></p>
<p><span class="koboSpan" id="kobo.750.1">To answer the first question, our algorithm in its present form saves the timestamp </span><em class="italic"><span class="koboSpan" id="kobo.751.1">of the last tick of the time interval</span></em><span class="koboSpan" id="kobo.752.1">. </span><span class="koboSpan" id="kobo.752.2">This happens because the trigger by which we start forming a new bar is </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">if delta.seconds &gt;= resolution</span></strong><span class="koboSpan" id="kobo.754.1">. </span><span class="koboSpan" id="kobo.754.2">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">if</span></strong><span class="koboSpan" id="kobo.756.1"> starts a new bar as soon as (and no earlier than!) a new tick is received, and the timestamp of this new tick differs from its immediate predecessor by a value (which is called </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">timedelta</span></strong><span class="koboSpan" id="kobo.758.1">) that is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">resolution</span></strong><span class="koboSpan" id="kobo.760.1">. </span><span class="koboSpan" id="kobo.760.2">In other words, if we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">resolution</span></strong><span class="koboSpan" id="kobo.762.1"> to 1 second, then we start a new bar only when we receive a tick whose timestamp differs from the start (open) of the currently forming bar by 1,000 milliseconds </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">or more.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">This </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.765.1">also answers two remaining questions. </span><span class="koboSpan" id="kobo.765.2">Since the timestamp of the very first received tick (the first tick in the data file) may not be a </span><em class="italic"><span class="koboSpan" id="kobo.766.1">round</span></em><span class="koboSpan" id="kobo.767.1"> number and minutes with zero seconds, we start counting 60 seconds not from the beginning of a minute, but from an </span><span class="No-Break"><span class="koboSpan" id="kobo.768.1">arbitrary moment.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.769.1">“Is it good or bad?”</span></em><span class="koboSpan" id="kobo.770.1"> you </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">may ask.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.772.1">Neither.</span></span></p>
<p><span class="koboSpan" id="kobo.773.1">The correct question here would be “</span><em class="italic"><span class="koboSpan" id="kobo.774.1">Does it suit my </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.775.1">trading algorithm?</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">”.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">And the answer depends on the logic of your algorithm. </span><span class="koboSpan" id="kobo.777.2">If it only analyzes the sequence of prices (or maybe volume, if the volume is provided by the data provider) then yes—this method works well and is really easy to implement. </span><span class="koboSpan" id="kobo.777.3">However, if your strategy logic assumes triggering orders or doing calculations at the real edge of a minute (or any other time interval), then this method </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">won’t fit.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">Luckily, we can easily modify our code so that it’s generating bars with the exact 1-minute resolution. </span><span class="koboSpan" id="kobo.779.2">The problem is that there’s no universal way of doing that, and the choice depends on whether you work with a live data stream or with saved tick data. </span><span class="koboSpan" id="kobo.779.3">To better understand it, let’s first quickly go back to the problem of retrieving data from external data sources and keeping your trading application modular and scalable. </span><span class="koboSpan" id="kobo.779.4">Then, you will understand how the problem of generating correct timestamps can be elegantly solved within this paradigm. </span><span class="koboSpan" id="kobo.779.5">All this, coming up in the </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">next section!</span></span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.781.1">Working with saved and live data – keeping your app universal</span></h1>
<p><span class="koboSpan" id="kobo.782.1">In the previous </span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.783.1">chapter, we quickly observed various methods to get market data from LMAX, one of the most important ECNs in the FX market. </span><span class="koboSpan" id="kobo.783.2">Without going into too much technical detail, we can assume that most other brokers, trading venues, and data vendors use more or less the same protocols and APIs based on socket connections. </span><span class="koboSpan" id="kobo.783.3">So, it should not be a problem to re-adapt your code to start retrieving data from a </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">new source.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">However, from the previous chapter, I hope you also remember that despite similarities in the transport layer of the connection, almost every data source has its own features that can only be found in its documentation (and sometimes, unfortunately, only in direct talks with its </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">technical support).</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">This means that even</span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.788.1"> if you implemented—for example—</span><strong class="bold"><span class="koboSpan" id="kobo.789.1">Financial Information eXchange</span></strong><span class="koboSpan" id="kobo.790.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.791.1">FIX</span></strong><span class="koboSpan" id="kobo.792.1">) protocol version 4.4 with one broker, it is quite possible that you will have to modify something in your code or FIX dictionary when you want to connect to another broker. </span><span class="koboSpan" id="kobo.792.2">With proprietary APIs, the situation is obviously more complex, and sometimes the entire code should be rewritten (everything on top of the transport layer, such as the </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">socket connection).</span></span></p>
<p><span class="koboSpan" id="kobo.794.1">So, a good practice when building a trading application is to make sure that it has a modular structure where modules have interfaces talking to each other using an internal, built-in, universal transport infrastructure. </span><span class="koboSpan" id="kobo.794.2">Such an infrastructure should transfer price information between modules regardless of their particular implementation, even if they are provided by third parties. </span><span class="koboSpan" id="kobo.794.3">In this case, you don’t have to modify the entire application once you want to switch to another data source: you just need to write a new module, and a new plugin if you want, which would connect to the new source but deliver data in the same internal format compatible with the rest of the </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">app’s modules.</span></span></p>
<p><span class="koboSpan" id="kobo.796.1">In general, we want to </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.797.1">create an architecture as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.798.1">Figure 5</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.799.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.800.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.801.1"><img alt="Figure 5.2 – The most simplistic data transport infrastructure for a trading app" src="image/B19145_5_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.802.1">Figure 5.2 – The most simplistic data transport infrastructure for a trading app</span></p>
<p><span class="koboSpan" id="kobo.803.1">However, this simplistic</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.804.1"> architecture has </span><span class="No-Break"><span class="koboSpan" id="kobo.805.1">prominent flaws:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.806.1">It supports only one source </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">of data</span></span></li>
<li><span class="koboSpan" id="kobo.808.1">It supports only one </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">trading algorithm</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.810.1">So, we may </span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.811.1">want to upgrade our architecture a bit to add multiple data streams to our trading algorithm, </span><span class="No-Break"><span class="koboSpan" id="kobo.812.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.813.1"><img alt="Figure 5.3 – Multiple data sources with a single trading algorithm" src="image/B19145_5_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.814.1">Figure 5.3 – Multiple data sources with a single trading algorithm</span></p>
<p><span class="koboSpan" id="kobo.815.1">Well, this architecture reveals a new problem: how to sync multiple data streams? </span><span class="koboSpan" id="kobo.815.2">How to decide which tick to pass to the algo if we have multiple sources? </span><span class="koboSpan" id="kobo.815.3">How do we request these sources? </span><span class="koboSpan" id="kobo.815.4">If we do that from our global infinite loop (</span><strong class="source-inline"><span class="koboSpan" id="kobo.816.1">for line in file</span></strong><span class="koboSpan" id="kobo.817.1"> for data read from a file or </span><strong class="source-inline"><span class="koboSpan" id="kobo.818.1">while True</span></strong><span class="koboSpan" id="kobo.819.1"> for socket connections), then we will have a really hard time switching to another data source because it will require rewriting almost the </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">entire code.</span></span></p>
<p><span class="koboSpan" id="kobo.821.1">Moreover, if we want to run a number of trading algorithms in parallel using a number of data sources, we quickly come to a </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">complete mess:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.823.1"><img alt="Figure 5.4 – Using multiple data sources with multiple algorithms in a bad way" src="image/B19145_5_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.824.1">Figure 5.4 – Using multiple data sources with multiple algorithms in a bad way</span></p>
<p><span class="koboSpan" id="kobo.825.1">Now, we clearly understand </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.826.1">what we actually need to build a robust infrastructure. </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">We need:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.828.1">To be able to run multiple processes of retrieving data </span><em class="italic"><span class="koboSpan" id="kobo.829.1">concurrently</span></em><span class="koboSpan" id="kobo.830.1"> without interfering with </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">one another</span></span></li>
<li><span class="koboSpan" id="kobo.832.1">To be able to store received data in universal elastic storage that is being filled with new data and then emptied as older ticks are processed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">trading algorithms</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.834.1">So, we are talking about</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.835.1"> an architecture as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.836.1">Figure 5</span></em></span><em class="italic"><span class="koboSpan" id="kobo.837.1">.5</span></em><span class="koboSpan" id="kobo.838.1"> with multiple data connectors, each of them having methods to connect, get data, and write it to a kind of a queue, and multiple trading algorithms (about whose internal architecture we don’t know anything yet) exchanging information using universal </span><em class="italic"><span class="koboSpan" id="kobo.839.1">elastic storage</span></em><span class="koboSpan" id="kobo.840.1">, as described in the </span><span class="No-Break"><span class="koboSpan" id="kobo.841.1">preceding list:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.842.1"><img alt="Figure 5.5 – A better architecture of the data transport layer of a trading application" src="image/B19145_5_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.843.1">Figure 5.5 – A better architecture of the data transport layer of a trading application</span></p>
<p><span class="koboSpan" id="kobo.844.1">Python</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.845.1"> does offer native solutions to both problems in an</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.846.1"> exceptionally streamlined and convenient way (as always, though). </span><span class="koboSpan" id="kobo.846.2">The ability to run data connectors concurrently is provided by </span><em class="italic"><span class="koboSpan" id="kobo.847.1">threads</span></em><span class="koboSpan" id="kobo.848.1">, while the “elastic storage” mentioned previously is a </span><em class="italic"><span class="koboSpan" id="kobo.849.1">queue</span></em><span class="koboSpan" id="kobo.850.1">. </span><span class="koboSpan" id="kobo.850.2">Let’s give both </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">some insight.</span></span></p>
<p><span class="koboSpan" id="kobo.852.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.853.1">thread</span></strong><span class="koboSpan" id="kobo.854.1"> is a </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.855.1">separate branch of execution of the program’s code that runs </span><em class="italic"><span class="koboSpan" id="kobo.856.1">concurrently</span></em><span class="koboSpan" id="kobo.857.1"> with the main code or in parallel with other threads. </span><span class="koboSpan" id="kobo.857.2">It can be implemented only within </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.858.1">the paradigm of </span><strong class="bold"><span class="koboSpan" id="kobo.859.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.860.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.861.1">OOP</span></strong><span class="koboSpan" id="kobo.862.1">) where we no longer have a single algorithm with a single start and a single end point, but instead, we have objects with their own behavior that can co-exist without interfering with one another or interacting with each other, depending on the will of their creator. </span><span class="koboSpan" id="kobo.862.2">So, a thread is an object that runs a function (a method) in parallel with everything else. </span><span class="koboSpan" id="kobo.862.3">Exactly what we need for retrieving data from multiple sources without </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">syncing, right?</span></span></p>
<p><span class="koboSpan" id="kobo.864.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.865.1">queue</span></strong><span class="koboSpan" id="kobo.866.1"> is... </span><span class="koboSpan" id="kobo.866.2">well, a </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.867.1">queue that you can see at a cash desk around Christmas time. </span><span class="koboSpan" id="kobo.867.2">Customers are served on a first-come, first-served basis. </span><span class="koboSpan" id="kobo.867.3">The data in a Python queue is treated the same way: whatever gets into the queue is moving along as older data is being processed. </span><span class="koboSpan" id="kobo.867.4">The moment a new element is retrieved, it is removed from the queue, freeing up space for </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">newer data.</span></span></p>
<p><span class="koboSpan" id="kobo.869.1">To better understand </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.870.1">how queues work, let’s consider a very </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">simple example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.872.1">
import queue
q = queue.Queue()
q.put("Sample 1")
q.put("Sample 2")
print(q.get())</span></pre>
<p><span class="koboSpan" id="kobo.873.1">If you run this code, it will print </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">Sample 1</span></strong><span class="koboSpan" id="kobo.875.1"> because the very first element in the queue was the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">Sample 1</span></strong><span class="koboSpan" id="kobo.877.1"> string. </span><span class="koboSpan" id="kobo.877.2">However, if you work in an interactive console and type </span><strong class="source-inline"><span class="koboSpan" id="kobo.878.1">print(q.get())</span></strong><span class="koboSpan" id="kobo.879.1"> again (or just add another </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">print(q.get())</span></strong><span class="koboSpan" id="kobo.881.1"> statement to the code), then this second </span><strong class="source-inline"><span class="koboSpan" id="kobo.882.1">print</span></strong><span class="koboSpan" id="kobo.883.1"> statement will print </span><strong class="source-inline"><span class="koboSpan" id="kobo.884.1">Sample 2</span></strong><span class="koboSpan" id="kobo.885.1"> because </span><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">Sample 1</span></strong><span class="koboSpan" id="kobo.887.1"> was already retrieved by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.888.1">.get()</span></strong><span class="koboSpan" id="kobo.889.1"> method and deleted from </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.891.1">Now that we know what threads and queues are, we can suggest a final draft for the architecture of the data transport layer of our </span><span class="No-Break"><span class="koboSpan" id="kobo.892.1">trading application:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.893.1"><img alt="Figure 5.6 – The final draft of the architecture of the data transport layer of a trading app" src="image/B19145_5_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.894.1">Figure 5.6 – The final draft of the architecture of the data transport layer of a trading app</span></p>
<p><span class="koboSpan" id="kobo.895.1">Let’s now try to implement it </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">in code.</span></span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.897.1">Universal data connector</span></h2>
<p><span class="koboSpan" id="kobo.898.1">Let’s start with </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.899.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">necessary preparations:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.901.1">We will need to specify the source data file, read the header, and do </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">some imports:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.903.1">
file_name = '&lt;your_file_path&gt;/EURUSD 1 Tick.csv'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.904.1">
f = open(file_name)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.905.1">
f.readline()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.906.1">
from datetime import datetime</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.907.1">
import threading</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.908.1">
import queue</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.909.1">
import time</span></pre></li>
<li><span class="koboSpan" id="kobo.910.1">Now, let’s create a </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.911.1">universal data stream, something into which all retrieved data will be written. </span><span class="koboSpan" id="kobo.911.2">Of course, it’s an instance of Python’s </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">queue</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.913.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.914.1">
datastream = queue.Queue()</span></pre></li>
<li><span class="koboSpan" id="kobo.915.1">And now, let’s create our first method that retrieves data, this time from a </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">local file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.917.1">
def get_tick():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.918.1">
    tick = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.919.1">
    values = f.readline().rstrip("\n").split(",")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.920.1">
    timestamp_string = values[0] + " " + values[1]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.921.1">
    ts = datetime.strptime(timestamp_string, "%m/%d/%Y %H:%M:%S.%f")</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.922.1">
    tick[ts] = float(values[2])</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.923.1">
    return tick</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.924.1">Can you see the already familiar code? </span><span class="koboSpan" id="kobo.924.2">Yes, of course—this is just a copy of what we did in the previous section, but this time wrapped into a function. </span><span class="koboSpan" id="kobo.924.3">So far, no different from what we did before. </span><span class="koboSpan" id="kobo.924.4">The difference comes with the following </span><span class="No-Break"><span class="koboSpan" id="kobo.925.1">two functions:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.926.1">
def emulate_tick_stream():
    while True:
        time.sleep(1)
        temp = get_tick()
        datastream.put(temp)
def trading_algo():
    while True:
      temp = datastream.get()
        print('Received tick ', temp)</span></pre>
<p><span class="koboSpan" id="kobo.927.1">The </span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.928.1">first function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">emulate_tick_stream()</span></strong><span class="koboSpan" id="kobo.930.1">, reads a new tick from the file every second and puts it into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">datastream</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.932.1"> queue.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.933.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.934.1">This 1-second delay is added here only for demonstration purposes—real data retrieval methods should not contain </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">any delays!</span></span></p>
<p><span class="koboSpan" id="kobo.936.1">The second function is simply a prototype—a dummy trading algorithm. </span><span class="koboSpan" id="kobo.936.2">It does nothing but report that it successfully received a new </span><span class="No-Break"><span class="koboSpan" id="kobo.937.1">data sample.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.938.1">Now, it’s time to run both processes—retrieving and processing data—in parallel. </span><span class="koboSpan" id="kobo.938.2">The time has come for </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">Python threads:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.940.1">
data_source_thread = threading.Thread(target = emulate_tick_stream)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.941.1">
data_receiver_thread = threading.Thread(target = trading_algo)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.942.1">This way, we create two instances of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">Thread</span></strong><span class="koboSpan" id="kobo.944.1"> class, one for retrieving data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">data_source_thread</span></strong><span class="koboSpan" id="kobo.946.1">) and one for processing data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">data_receiver_thread</span></strong><span class="koboSpan" id="kobo.948.1">). </span><span class="koboSpan" id="kobo.948.2">As the only argument, we pass the name of the function that we would like to run within </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">this thread.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.950.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.951.1">We pass the function name and do not call the function itself! </span><span class="koboSpan" id="kobo.951.2">If you type something such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">threading.Thread(target = trading_algo())</span></strong><span class="koboSpan" id="kobo.953.1">, the function will be called right </span><em class="italic"><span class="koboSpan" id="kobo.954.1">at the point it is passed</span></em><span class="koboSpan" id="kobo.955.1"> into the thread, so </span><em class="italic"><span class="koboSpan" id="kobo.956.1">the thread will never </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.957.1">actually start</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">!</span></span></p>
<ol>
<li value="5"><span class="koboSpan" id="kobo.959.1">All we </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.960.1">need to do now is to run the two </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">threads concurrently:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.962.1">
data_source_thread.start()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.963.1">
data_receiver_thread.start()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.964.1">That’s it! </span><span class="koboSpan" id="kobo.964.2">Now if we run the code in a new console window, we will see something </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.966.1">
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 30, 446000): 1.01896})
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 31, 505000): 1.01895})
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 33, 619000): 1.019})
('Received tick ', {datetime.datetime(2022, 8, 8, 13, 50, 36, 793000): 1.01901})</span></pre>
<p><span class="koboSpan" id="kobo.967.1">A new line will appear every second (because we have a delay of 1 second in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">get_tick()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.969.1"> function).</span></span></p>
<p><span class="koboSpan" id="kobo.970.1">Even in this simple example, we can see the power of using an object-oriented approach to developing trading apps and especially using threads and queues. </span><span class="koboSpan" id="kobo.970.2">Now, you can rewrite the </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">get_tick()</span></strong><span class="koboSpan" id="kobo.972.1"> function to connect to a totally different data source, and the rest of your code will remain completely, absolutely untouched! </span><span class="koboSpan" id="kobo.972.2">You can replace reading from a file with reading from a socket, from a REST API, or from whatever you (or your broker) might imagine. </span><span class="koboSpan" id="kobo.972.3">It won’t ever affect the rest of your code, given your new </span><strong class="source-inline"><span class="koboSpan" id="kobo.973.1">get_tick()</span></strong><span class="koboSpan" id="kobo.974.1"> function returns data in the </span><span class="No-Break"><span class="koboSpan" id="kobo.975.1">same format.</span></span></p>
<p><span class="koboSpan" id="kobo.976.1">And now, we can get back to the discussion on data compression, which we somehow abruptly dropped in the </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">previous section.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.978.1">Data compression revisited</span></h2>
<p><span class="koboSpan" id="kobo.979.1">Remember </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.980.1">that we compressed tick data into 1-minute bars, but the actual beginning and end of a minute was not when the number of seconds was zero, but at an arbitrary point inside a minute interval? </span><span class="koboSpan" id="kobo.980.2">That time, we were unable to solve this problem because we only read data samples one by one from a file at a speed that was unknown </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">to us.</span></span></p>
<p><span class="koboSpan" id="kobo.982.1">But with the power of threading and queuing, we can form </span><em class="italic"><span class="koboSpan" id="kobo.983.1">correct</span></em><span class="koboSpan" id="kobo.984.1"> 1-minute (or any N-minute) bars with perfect precision when the new bar starts at exactly 00 seconds. </span><span class="koboSpan" id="kobo.984.2">All we need is to add a new function and run it in </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">a thread.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.986.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.987.1">Note how easy it is now to customize data processing. </span><span class="koboSpan" id="kobo.987.2">We no longer rewrite the entire code—we only add new functionality or modify a </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">single function.</span></span></p>
<p><span class="koboSpan" id="kobo.989.1">So, let’s create a function that will break our incoming data stream into 1-minute bars simply by using a </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">system timer:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.991.1">We will start with creating a dictionary for the currently forming bar (as in the previous example), and, as always with functions that are supposed to work inside threads, we start with an </span><span class="No-Break"><span class="koboSpan" id="kobo.992.1">infinite loop:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.993.1">
def compressor():</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.994.1">
      bar = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.995.1">
      while True:</span></pre></li>
<li><span class="koboSpan" id="kobo.996.1">Then, we will read data from the </span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">data stream:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.998.1">
          tick = datastream.get()</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.999.1">Note that this call is universal for any data recipient, be it a trading strategy, a data compressor, a database, </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">or whatever.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.1001.1">Next, we will check the current time (system time), and if its seconds value is zero, we will save the formed bar and start a </span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">new one:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1003.1">
          current_time = datetime.now()</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1004.1">
          if current_time.second == 0:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1005.1">
              bars[current_time] = dict(bar)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1006.1">
              bar["open"]  = tick.values()[0]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1007.1">
              bar["high"]  = tick.values()[0]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1008.1">
              bar["low"]   = tick.values()[0]</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
              print(bars)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.1010.1">The</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.1011.1"> rest of the code is the same as in the aforementioned example and handles exceptions that are raised when the first bar is </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">not complete:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
            else:
                try:
                    bar["high"] = max([bar["high"], tick.values()[0]])
                    bar["low"] = min([bar["low"], tick.values()[0]])
                    bar["close"] = tick.values()[0]
                except:
                    print(str(current_time), ' bar forming...')</span></pre>
<p><span class="koboSpan" id="kobo.1014.1">You can see that this function almost completely copies the code we used in the </span><em class="italic"><span class="koboSpan" id="kobo.1015.1">Compressing market data in Python</span></em><span class="koboSpan" id="kobo.1016.1"> section, with the only important modification being that now, instead of comparing timestamps of individual ticks, we finalize the bar </span><em class="italic"><span class="koboSpan" id="kobo.1017.1">by a system timer</span></em><span class="koboSpan" id="kobo.1018.1">. </span><span class="koboSpan" id="kobo.1018.2">As soon as the </span><em class="italic"><span class="koboSpan" id="kobo.1019.1">system time</span></em><span class="koboSpan" id="kobo.1020.1"> passes a minute, which means that its seconds value is zero, we start a </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">new bar.</span></span></p>
<p><span class="koboSpan" id="kobo.1022.1">In fact, synching time is one of the greatest problems in algo trading. </span><span class="koboSpan" id="kobo.1022.2">The system time on the trading server may differ from the clock at the data vendor’s, and the clock at the broker or ECN may again differ from both. </span><span class="koboSpan" id="kobo.1022.3">Luckily, in the further examples, we are going to use only 1-second snapshots of live data and 1-minute bars of historical data, so the problem of clock synchronization can be set aside </span><span class="No-Break"><span class="koboSpan" id="kobo.1023.1">for now.</span></span></p>
<p><span class="koboSpan" id="kobo.1024.1">If you run this code using pre-saved historical tick data, you will see something </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1026.1">
{datetime.datetime(2022, 8, 10, 20, 4, 0, 287224): {}, datetime.datetime(2022, 8, 10, 20, 5, 0, 456837): {'high': 1.01947, 'close': 1.01947, 'open': 1.01918, 'low': 1.01918}, datetime.datetime(2022, 8, 10, 20, 6, 0, 639863): {'high': 1.0195, 'close': 1.01925, 'open': 1.01945, 'low': 1.01925}}</span></pre>
<p><span class="koboSpan" id="kobo.1027.1">You can see that</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.1028.1"> the first bar does not have price data as it was started before the first minute ended. </span><span class="koboSpan" id="kobo.1028.2">All the following bars have OHLC values that correspond to the </span><em class="italic"><span class="koboSpan" id="kobo.1029.1">last ticks of the minute</span></em><span class="koboSpan" id="kobo.1030.1"> by the time the system timer triggered a </span><span class="No-Break"><span class="koboSpan" id="kobo.1031.1">new bar.</span></span></p>
<p><span class="koboSpan" id="kobo.1032.1">Now, I hope you understand why historical compressed data from a broker always has nice </span><em class="italic"><span class="koboSpan" id="kobo.1033.1">round</span></em><span class="koboSpan" id="kobo.1034.1"> timestamps: they do not correspond to actual ticks; they are simply split into bars by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">system timer.</span></span></p>
<p><span class="koboSpan" id="kobo.1036.1">You can see that this method works perfectly with live data that is received from a broker, a trading venue, or a similar source. </span><span class="koboSpan" id="kobo.1036.2">It doesn’t really suit for processing pre-saved historical data because it can be read back from disk at speeds that seriously exceed the real speed at which ticks are being received from the market. </span><span class="koboSpan" id="kobo.1036.3">So, with historical data, it’s better to use the </span><em class="italic"><span class="koboSpan" id="kobo.1037.1">tick-to-tick timestamp compare</span></em><span class="koboSpan" id="kobo.1038.1"> approach that we considered in the </span><em class="italic"><span class="koboSpan" id="kobo.1039.1">Compressing market data in Python</span></em><span class="koboSpan" id="kobo.1040.1"> section earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.1041.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.1042.1">If you are not familiar with threads and queues and want to learn more about the ways you can use them in your trading apps, I’d recommend starting with a simple tutorial here (</span><a href="https://realpython.com/intro-to-python-threading/"><span class="koboSpan" id="kobo.1043.1">https://realpython.com/intro-to-python-threading/</span></a><span class="koboSpan" id="kobo.1044.1">) and then referring to the official Python documentation here (</span><a href="https://docs.python.org/3/library/threading.html"><span class="koboSpan" id="kobo.1045.1">https://docs.python.org/3/library/threading.html</span></a><span class="koboSpan" id="kobo.1046.1">) for tips and tricks and </span><span class="No-Break"><span class="koboSpan" id="kobo.1047.1">deeper understanding.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.1048.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1049.1">In this chapter, we learned how to process both live and historical market data and, most importantly, how to do it in an efficient way. </span><span class="koboSpan" id="kobo.1049.2">We are now familiar with time-based bars, which are most heavily used in trading strategies. </span><span class="koboSpan" id="kobo.1049.3">We also learned about the solution that helps keep our trading applications flexible and quickly switch from one data source to another, which will help when switching from testing to production in </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">the future.</span></span></p>
<p><span class="koboSpan" id="kobo.1051.1">Now, we are ready to move on to using the processed market data in our trading strategies. </span><span class="koboSpan" id="kobo.1051.2">Let’s see how we can do this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">next chapter.</span></span></p>
</div>
</body></html>