<html><head></head><body>
		<div><h1 id="_idParaDest-14"><em class="italic"><a id="_idTextAnchor013"/>Chapter 1</em>: Optimal Python Development Life Cycle</h1>
			<p>Keeping in mind your prior experience with Python, we have skipped the introductory details of the Python language in this chapter. First, we will have a short discussion of the broader open source Python community and its specific culture. That introduction is important, as this culture is reflected in code being written and shared by the Python community. Then, we will present the different phases of a typical Python project. Next, we will look at different ways of strategizing the development of a typical Python project.</p>
			<p>Moving on, we will explore different ways of documenting the Python code. Later, we will look into various options of developing an effective naming scheme that can greatly help improve the maintenance of the code. We will also look into various options for using source control for Python projects, including situations where developers are mainly using Jupyter notebooks for development. Finally, we explore the best practices to deploy the code for use, once it is developed and tested.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Python culture and community</li>
				<li>Different phases of a Python project</li>
				<li>Strategizing the development process</li>
				<li>Effectively documenting Python code</li>
				<li>Developing an effective naming scheme</li>
				<li>Exploring choices for source control</li>
				<li>Understanding strategies for deploying the code</li>
				<li>Python development environments</li>
			</ul>
			<p>This chapter will help you understand the life cycle of a typical Python project and its phases so that you can fully utilize the power of Python.</p>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>Python culture and community</h1>
			<p>Python<a id="_idIndexMarker000"/> is an interpreted high-level language that was originally developed by Guido van Rossum in 1991. The Python community<a id="_idIndexMarker001"/> is special in the sense<a id="_idIndexMarker002"/> that it pays close attention to how the code is written. For that, since the early days of Python, the Python community has created and maintained a particular flavor in its design philosophy. Today, Python is used in a wide variety of industries, ranging from education to medicine. But regardless of the industry in which it is used, the particular culture of the vibrant Python community is usually seen to be part and parcel of Python projects.</p>
			<p>In particular, the Python community wants us to write simple code and avoid complexity wherever possible. In fact, there is an adjective, <em class="italic">Pythonic</em>, which means there are multiple ways to accomplish a certain task but there is a preferred way as per the Python community conventions and as per the founding philosophy of the language. Python nerds try their best to create artifacts that are as Pythonic as possible. Obviously, <em class="italic">unpythonic code</em> means that we are not good coders in the eyes of these nerds. In this book, we will try to go as Pythonic as possible as we can in our code and design.</p>
			<p>And there is something official about being Pythonic as well. Tim Peters has concisely written the philosophy of Python in a short document, <em class="italic">The Zen of Python</em>. We know that Python is said to be one of the easiest languages to read, and <em class="italic">The Zen of Python</em> wants to keep it that way. It expects Python to be explicit through good documentation and as clean and clear as possible. We can read <em class="italic">The Zen of Python</em> ourselves, as explained next.</p>
			<p>In order to read <em class="italic">The Zen of Python</em>, open up a Python console and run the <code>import this</code> command, as shown in the following screenshot:</p>
			<div><div><img src="img/B17189_01_01.jpg" alt="Figure 1.1 – The Zen of Python&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – The Zen of Python</p>
			<p><em class="italic">The Zen of Python</em> seems to be a cryptic text discovered in an old Egyptian tomb. Although it is deliberately written in this casual cryptic way, there is a deeper meaning to each line of text. Actually, look closer—it can be used as a guideline to code in Python. We will refer to different lines from <em class="italic">The Zen of Python</em> throughout the book. Let's first look into some excerpts<a id="_idIndexMarker003"/> from it, as follows:</p>
			<ul>
				<li><strong class="bold">Beautiful is better than ugly</strong>: It is important to write code that is well-written, readable, and self-explanatory. Not only should it work—it should be beautifully written. While coding, we should avoid using shortcuts in favor of a style that is self-explanatory.</li>
				<li><strong class="bold">Simple is better than complex</strong>: We should not unnecessarily complicate things. Whenever facing a choice, we should prefer the simpler solution. Nerdy, unnecessary, and complicated ways of writing code are discouraged. Even when it adds some more lines to the source code, simpler remains better than the complex alternative.</li>
				<li><strong class="bold">There should be one-- and preferably only one --obvious way to do it</strong>: In broader terms, for a given problem there should be one possible best solution. We should strive to discover this. As we iterate through the design to improve it, regardless of our approach, our solution is expected to evolve and converge toward that preferable solution.</li>
				<li><strong class="bold">Now is better than never</strong>: Instead<a id="_idIndexMarker004"/> of waiting for perfection, let's start solving the given problem using the information, assumptions, skills, tools, and infrastructure we have. Through the process of iteration, we will keep improving the solution. Let's keep things moving instead of idling. Do not slack while waiting for the perfect time. Chances are that the perfect time will never come.</li>
				<li><strong class="bold">Explicit is better than implicit</strong>: The code should be as self-explanatory as possible. This should be reflected in the choice of variable names, the class, and the function design, as well<a id="_idIndexMarker005"/> as in the overall <strong class="bold">end-to-end</strong> (<strong class="bold">E2E</strong>) architecture. It is better to err on the side of caution. Always make it more explicit whenever facing a choice.</li>
				<li><strong class="bold">Flat is better than nested</strong>: A nested structure is concise but also creates confusion. Prefer a flat structure wherever possible.</li>
			</ul>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Different phases of a Python project</h1>
			<p>Before we discuss the optimal<a id="_idIndexMarker006"/> development life cycle, let's start by identifying<a id="_idIndexMarker007"/> the different phases of a Python project. Each phase can be thought of as a group of activities that are similar in nature, as illustrated in the following diagram:</p>
			<div><div><img src="img/B17189_01_02.jpg" alt="Figure 1.2 – Various phases of a Python project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Various phases of a Python project</p>
			<p>The various phases of a typical Python project are outlined here:</p>
			<ul>
				<li><strong class="bold">Requirement analysis</strong>: This phase is about collecting<a id="_idIndexMarker008"/> the requirements from all key<a id="_idIndexMarker009"/> stakeholders and then analyzing them to understand <em class="italic">what</em> needs to be done and later think about the <em class="italic">how</em> part of it. The stakeholders can be our actual users of the software or business owners. It is important to collect the requirements in as much detail as possible. Wherever possible, requirements should be fully laid out, understood, and discussed with the end user and stakeholders before starting the design and development.<p>An important point is to ensure that the requirement-analysis phase should be kept out of the iterative loop of the design, development, and testing phases. Requirement analysis should be fully conducted and complete before moving on to<a id="_idIndexMarker010"/> the next phases. The requirements<a id="_idIndexMarker011"/> should include both <strong class="bold">functional requirements</strong> (<strong class="bold">FRs</strong>) and <strong class="bold">non-functional requirements</strong> (<strong class="bold">NFRs</strong>). FRs should be grouped into modules. Within each module, the requirements should be numbered in an effort to map them as closely as possible with the code modules. </p></li>
				<li><strong class="bold">Design</strong>: Design is our technical response to the requirements as laid out in the requirement phase. In<a id="_idIndexMarker012"/> the design phase, we figure<a id="_idIndexMarker013"/> out the <em class="italic">how</em> part of the equation. It is a creative process where we use our experience and skills to come up with the right set and structure of modules and the interactions between them in the most efficient and optimal way.<p>Note that coming up with the right design is an important part of a Python project. Any missteps in the design phase will be much more expensive to correct than missteps in later phases. By some measure, it takes 20 times more effort to change the design and implement the design changes in the subsequent phases (for example, coding phase), as compared to a similar degree of changes if they happen in the coding phase—for example, the inability to correctly identify classes or figure out the right data and compute the dimension of the project will have a major impact as compared to a mistake when implementing a function. Also, because coming up with the right design is a conceptual process, mistakes may not be obvious and cannot be caught by testing. On the other hand, errors in the coding will be caught by a well-thought-out exception-handling system.</p><p>In the design phase, we perform the following activities:</p><p>a) We design the structure of the code and identify the modules within the code.</p><p>b) We decide the fundamental approach and decide whether we should be using functional programming, OOP, or a hybrid approach. </p><p>c) We also identify the classes and functions and choose the names of these higher-level components. </p><p>We also produce higher-level documentation.</p></li>
				<li><strong class="bold">Coding</strong>: This is the phase<a id="_idIndexMarker014"/> where we will implement<a id="_idIndexMarker015"/> the design using Python. We start by implementing the higher-level abstractions, components, and modules identified by the design first, followed by the detailed coding. We will keep a discussion about the coding phase to a minimum in this section as we will discuss<a id="_idIndexMarker016"/> it extensively<a id="_idIndexMarker017"/> throughout the book.</li>
				<li><strong class="bold">Testing</strong>: Testing<a id="_idIndexMarker018"/> is the process of verifying<a id="_idIndexMarker019"/> our code.</li>
				<li><strong class="bold">Deployment</strong>: Once thoroughly tested, we <a id="_idIndexMarker020"/>need to hand over the solution to the end user. The end user<a id="_idIndexMarker021"/> should not see the details of our design, coding, or testing. Deployment is the process of providing a solution to the end user that can be used to solve the problem as detailed in the requirements. For example, if<a id="_idIndexMarker022"/> we are working to develop a <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) project to predict rainfall in Ottawa, the deployment is about figuring out how to provide a usable solution to the end user.</li>
			</ul>
			<p>Having understood what the different phases of a project are, we will move on to see how we can strategize the overall process.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Strategizing the development process</h1>
			<p>Strategizing the development process<a id="_idIndexMarker023"/> is about planning each of the phases and looking into the process flow from one phase to another. To strategize the development process, we need to first answer the following questions:</p>
			<ol>
				<li>Are we looking for a minimal design approach and going straight to the coding phase with little design?</li>
				<li>Do we want <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>), whereby we first create<a id="_idIndexMarker024"/> tests using the requirements and then code them?</li>
				<li>Do we want to create a <strong class="bold">minimum viable product</strong> (<strong class="bold">MVP</strong>) first and iteratively evolve<a id="_idIndexMarker025"/> the solution?</li>
				<li>What is the strategy for validating NFRs such as security and performance?</li>
				<li>Are we looking for a single-node development, or do we want to develop and deploy on the cluster or in the cloud?</li>
				<li>What<a id="_idIndexMarker026"/> are the volume, velocity, and<a id="_idIndexMarker027"/> variety of our <strong class="bold">input and output</strong> (<strong class="bold">I/O</strong>) data? Is it a <strong class="bold">Hadoop distributed file system</strong> (<strong class="bold">HDFS</strong>) or <strong class="bold">Simple Storage Service</strong> (<strong class="bold">S3</strong>) file-based<a id="_idIndexMarker028"/> structure, or a <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) or NoSQL database? Is the data<a id="_idIndexMarker029"/> on-premises or in the cloud?</li>
				<li>Are we working on specialized use cases such as ML with specific requirements for creating data pipelines, testing models, and deploying and maintaining them?</li>
			</ol>
			<p>Based on the answers<a id="_idIndexMarker030"/> to these questions, we can strategize the steps for our development process. In more recent times, it is always preferred to use iterative development processes in one form or another. The concept of MVP as a starting goal is also popular. We will discuss these in the next subsections, along with the domains'<a id="_idTextAnchor017"/> specific development needs.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>Iterating through the phases</h2>
			<p>Modern software<a id="_idIndexMarker031"/> development philosophy is based on short iterative cycles of design, development, and testing. The traditional waterfall model that was used in code development is long dead. Selecting the right granularity, emphasis, and frequency of these phases depends on the nature of the project and our choice of code development strategy. If we want to choose a code development strategy with minimum design and want to go straight to coding, then the design phase is thin. But even starting the code straight away will require some thought in terms of the design of modules that will eventually be implemented.</p>
			<p>No matter what strategy we choose, there is an inherent iterative relationship between the design, development, and testing phases. We initially start with the design phase, implement it in the coding phase, and then validate it by testing it. Once we have flagged the deficiencies, we need to go back to the drawing board by<a id="_idTextAnchor019"/> revisiting the design phase.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>Aiming for MVP first</h2>
			<p>Sometimes, we select<a id="_idIndexMarker032"/> a small subject of the most important requirements to first implement the MVP with the aim of iteratively improving it. In an iterative process, we design, code, and test, until we create a final product that can be deployed and used.</p>
			<p>Now, let's talk about how we will implement the solution of some <a id="_idTextAnchor021"/>specialized domains in Python.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor022"/>Strategizing development for specialized domains</h2>
			<p>Python is currently being<a id="_idIndexMarker033"/> used for a wide variety of scenarios. Let's look into the following five important use cases to see how we can strategize the development process for each of them according to their specific needs:</p>
			<ul>
				<li>ML</li>
				<li>Cloud computing and cluster computing</li>
				<li>Systems programming</li>
				<li>Networking programming</li>
				<li>Serverless computing</li>
			</ul>
			<p>We will discuss each of <a id="_idTextAnchor023"/>them in the following sections.</p>
			<h3>ML</h3>
			<p>Over<a id="_idIndexMarker034"/> the years, Python<a id="_idIndexMarker035"/> has become the most common language used for implementing ML algorithms. ML projects need to have a well-structured environment. Python has an extensive collection of high-quality libraries that are available for use for ML.</p>
			<p>For a typical ML project, there is a <strong class="bold">Cross-Industry Standard Process for Data Mining</strong> (<strong class="bold">CRISP-DM</strong>) life cycle that specifies various<a id="_idIndexMarker036"/> phases of an ML project. A CRISP-DM life cycle looks like this:</p>
			<div><div><img src="img/B17189_01_03.jpg" alt="Figure 1.3 – A CRISP-DM life cycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – A CRISP-DM life cycle</p>
			<p>For ML<a id="_idIndexMarker037"/> projects, designing and implementing<a id="_idIndexMarker038"/> data pipelines is estimated to be almost 70% of the development effort. While designing data processing pipelines, we should keep in mind that the pipelines<a id="_idIndexMarker039"/> will ideally have these characteristics:</p>
			<ul>
				<li>They should be scalable.</li>
				<li>They should be reusable as far as possible.</li>
				<li>They should process both streaming and batch data by conforming to <strong class="bold">Apache Beam</strong> standards.</li>
				<li>They should mostly be a concatenation of fit and transform functions, as we will discuss in <a href="B17189_06_Final_PG_ePub.xhtml#_idTextAnchor188"><em class="italic">Chapter 6</em></a>, <em class="italic">Advanced Tips and Tricks in Python</em>.</li>
			</ul>
			<p>Also, an important part of the testing phase for ML projects is the model evaluation. We need to figure out which of the performance metrics is the best one to quantify the performance of the model according to the requirement of the problem, nature of the data, and type of algorithm<a id="_idIndexMarker040"/> being implemented. Are we looking at accuracy, precision, recall, F1 score, or a combination of these performance metrics? Model evaluation is an important part of the testing process and needs to be conducted in addition to the standard tes<a id="_idTextAnchor024"/>ting done in other software projects.</p>
			<h3>Cloud computing and cluster computing</h3>
			<p>Cloud computing and cluster computing<a id="_idIndexMarker041"/> add additional complexity<a id="_idIndexMarker042"/> to the underlying<a id="_idIndexMarker043"/> infrastructure. Cloud service<a id="_idIndexMarker044"/> providers offer services that need specialized libraries. The architecture of Python, which starts with bare-minimum core packages and the ability to import any further package, makes it well suited for cloud computing. The platform independence offered by a Python environment is critical<a id="_idIndexMarker045"/> for cloud and cluster computing. <strong class="bold">Python</strong> is the language<a id="_idIndexMarker046"/> of choice for <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), Windows Azure, and Google Cloud Platform (GCP).</p>
			<p>Cloud computing and cluster computing projects have separate development, testing, and production environments. It is important to keep the development and production environments in sync.</p>
			<p>When using <strong class="bold">infrastructure-as-a-service</strong> (<strong class="bold">IaaS</strong>), Docker<a id="_idIndexMarker047"/> containers can help a lot, and it is recommended to use them. Once we are using the Docker container, it does not matter where we are running the code as the code will have ex<a id="_idTextAnchor025"/>actly the same environment and dependencies.</p>
			<h3>Systems programming</h3>
			<p>Python has interfaces to operating system services. Its core libraries have <strong class="bold">Portable Operating System Interface</strong> (<strong class="bold">POSIX</strong>) bindings that allow<a id="_idIndexMarker048"/> developers to create so-called shell tools, which<a id="_idIndexMarker049"/> can be used for system administration<a id="_idIndexMarker050"/> and various utilities. Shell tools written in Python are compatible across various platforms. The same tool can be used in Linux, Windows, and macOS without any change, making them quite powerful and maintainable.</p>
			<p>For example, a shell tool that copies a complete directory developed and tested in Linux can run<a id="_idIndexMarker051"/> unchanged in Windows. Python's support for systems programming<a id="_idIndexMarker052"/> includes the following:</p>
			<ul>
				<li>Defining environment variables</li>
				<li>Support for files, sockets, pipes, processes, and multiple threads</li>
				<li>Ability<a id="_idIndexMarker053"/> to specify a <strong class="bold">regular expression</strong> (<strong class="bold">regex</strong>) for pattern matching</li>
				<li>Ability to provide command-line arguments</li>
				<li>Support for standard stream interfaces, shell-command launchers, and filename expansion</li>
				<li>Ability to zip file utilities</li>
				<li>Ability to parse <strong class="bold">Extensible Markup Language</strong> (<strong class="bold">XML</strong>) and <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) files</li>
			</ul>
			<p>When using Python<a id="_idIndexMarker054"/> for system<a id="_idIndexMarker055"/> development, the deployment<a id="_idIndexMarker056"/> phase is minimal and may be as simple as packaging the code as an executable file. It is important to mention that Python is not intended to be used for the development of system-level drivers or operating system libraries.</p>
			<h3>Network programming</h3>
			<p>In the digital transformation<a id="_idIndexMarker057"/> era where <strong class="bold">Information Technology</strong> (<strong class="bold">IT</strong>) systems are moving quickly toward<a id="_idIndexMarker058"/> automation, networks<a id="_idIndexMarker059"/> are considered the main bottleneck in full-stack automation. The reason for this is the propriety network operating systems from different vendors and a lack of openness, but the prerequisites of digital transformation are changing this trend and a lot of work is in progress to make<a id="_idIndexMarker060"/> the network programmable and consumable as a service (<strong class="bold">network-as-a-service</strong>, or <strong class="bold">NaaS</strong>). The real question is: <em class="italic">Can we use Python for network programming?</em> The answer is a big <em class="italic">YES</em>. In fact, it is one of the most popular languages in use for network automation. </p>
			<p>Python support for network programming<a id="_idIndexMarker061"/> includes the following:</p>
			<ul>
				<li>Socket<a id="_idIndexMarker062"/> programming<a id="_idIndexMarker063"/> including <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) and <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>) sockets</li>
				<li>Support for client and server communication</li>
				<li>Support for port listening and processing data</li>
				<li>Executing<a id="_idIndexMarker064"/> commands on a remote <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) system</li>
				<li>Uploading<a id="_idIndexMarker065"/> and downloading<a id="_idIndexMarker066"/> files using <strong class="bold">Secure Copy Protocol</strong> (<strong class="bold">SCP</strong>)/<strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>)</li>
				<li>Support<a id="_idIndexMarker067"/> for the<a id="_idIndexMarker068"/> library for <strong class="bold">Simple Network Management Protocol</strong> (<strong class="bold">SNMP</strong>)</li>
				<li>Support<a id="_idIndexMarker069"/> for the <strong class="bold">REpresentational State Transfer</strong> (<strong class="bold">RESTCONF</strong>) and <strong class="bold">Network Configuration</strong> (<strong class="bold">NETCONF</strong>) protocols for retrieving<a id="_idIndexMarker070"/> and updating configuration</li>
			</ul>
			<h3>Serverless computing</h3>
			<p>Serverless computing is a cloud-based<a id="_idIndexMarker071"/> application execution<a id="_idIndexMarker072"/> model in which the <strong class="bold">cloud service providers</strong> (<strong class="bold">CSPs</strong>) provide the computer resources<a id="_idIndexMarker073"/> and application servers to allow developers to deploy and execute the applications without any hassle of managing the computing resources and servers themselves. All of the major public cloud vendors (Microsoft Azure Serverless Functions, AWS Lambda, and <strong class="bold">Google Cloud Platform</strong>, or <strong class="bold">GCP</strong>) support serverless computing<a id="_idIndexMarker074"/> for Python.</p>
			<p>We need to understand<a id="_idIndexMarker075"/> that there are still servers in a serverless environment, but those servers are managed by CSPs. As an application developer, we are not responsible for installing and maintaining the servers as well as having no direct responsibility for the scalability and performance of the servers. </p>
			<p>There are popular serverless libraries and frameworks<a id="_idIndexMarker076"/> available for Python. These are described next:</p>
			<ul>
				<li><strong class="bold">Serverless</strong>: The Serverless Framework is an open source framework for serverless<a id="_idIndexMarker077"/> functions or AWS Lambda services and is written using Node.js. Serverless is the first framework developed for building applications on AWS Lambda.</li>
				<li><strong class="bold">Chalice</strong>: This is a Python<a id="_idIndexMarker078"/> serverless microframework developed by AWS. This is a default choice for developers who want to quickly spin up and deploy their Python applications using AWS Lambda Services, as this enables you to quickly spin up and deploy a working serverless application that scales up and down on its own as required, using AWS Lambda. Another key feature of Chalice is that it provides a utility to simulate your application locally before pushing it to the cloud.</li>
				<li><strong class="bold">Zappa</strong>: This is more of a deployment<a id="_idIndexMarker079"/> tool built into Python<a id="_idIndexMarker080"/> and makes the deployment<a id="_idIndexMarker081"/> of your <strong class="bold">Web Server Gateway Interface</strong> (<strong class="bold">WSGI</strong>) ap<a id="_idTextAnchor026"/>plication easy.</li>
			</ul>
			<p>Now, let's look into effective ways of developing Python code.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor027"/>Effectively documenting Python code</h1>
			<p>Finding an effective way to document<a id="_idIndexMarker082"/> code is always important. The challenge is to develop a comprehensive yet simple way to <a id="_idTextAnchor028"/>develop Python code. Let's first look into Python comments and then docstrings.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor029"/>Python comments</h2>
			<p>In contrast with a docstring, Python comments<a id="_idIndexMarker083"/> are not visible to the runtime<a id="_idIndexMarker084"/> compiler. They are used as a note to explain the code. Comments start with a <code>#</code> sign in Python, as sho<a id="_idTextAnchor030"/>wn in the following screenshot:</p>
			<div><div><img src="img/B17189_01_04.jpg" alt="Figure 1.4 – An example of a comment in Python"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – An example of a comment in Python</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor031"/>Docstring</h2>
			<p>The main workhorse for documenting<a id="_idIndexMarker085"/> the code is the multiline<a id="_idIndexMarker086"/> comments block called a <code>"""</code>).</p>
			<p>Here are some general guidelines<a id="_idIndexMarker088"/> when creating a docstring:</p>
			<ul>
				<li>A docstring should be placed right after the function or the class definition.</li>
				<li>A docstring should be given a one-line summary followed by a more detailed description.</li>
				<li>Blank spaces should be strategically used to organize the comments but they should not be overused. You can use blank lines to organize code, but don't use them excessively.</li>
			</ul>
			<p>I<a id="_idTextAnchor032"/>n the following sections, let's take a look at more detailed concepts of docStrings.</p>
			<h3>Docstring styles</h3>
			<p>A Python docstring<a id="_idIndexMarker089"/><a id="_idTextAnchor033"/> has the following slightly different styles:</p>
			<ul>
				<li>Google</li>
				<li>NumPy/SciPy</li>
				<li>Epytext</li>
				<li>Restructured</li>
			</ul>
			<h3>Docstring types</h3>
			<p>While developing the code, various types<a id="_idIndexMarker090"/> of documentation need to be produced, including the following:</p>
			<ul>
				<li>Line-by-line commentary</li>
				<li>Funct<a id="_idTextAnchor034"/>ional or class-level documentation</li>
				<li>Algorithmic details</li>
			</ul>
			<p>Let's discuss them, one by one.</p>
			<h3>Line-by-line commentary</h3>
			<p>One simple use of a docstring<a id="_idIndexMarker091"/> is to use it to create multiline comments<a id="_idTextAnchor035"/>, as shown here:</p>
			<div><div><img src="img/B17189_01_05.jpg" alt="Figure 1.5 – An example of a line-by-line commentary-type docstring&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – An example of a line-by-line commentary-type docstring</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor036"/>Functional or class-level documentation</h2>
			<p>A powerful use of a docstring<a id="_idIndexMarker092"/> is for functional or class-level documentation. If we place the docstring just after the definition<a id="_idIndexMarker093"/> of a function or a class, Python associates<a id="_idIndexMarker094"/> the docstring with the function or a class. This is placed in the <code>__doc__</code> attribute of that particular function or class. We can print that out at runtime by either using the <code>__doc__</code> attribute or by using the <code>help</code> fun<a id="_idTextAnchor037"/>ction, as shown in the following example:</p>
			<div><div><img src="img/B17189_01_06.jpg" alt="Figure 1.6 – An example of the help function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – An example of the help function</p>
			<p>When using a docstring for documenting classes, the recommended structure is as follows:</p>
			<ul>
				<li>A summary: usually a single line</li>
				<li>First blank line</li>
				<li>Any further explanation regarding the docstring</li>
				<li>Second blank line</li>
			</ul>
			<p>An example of using a docstring<a id="_idTextAnchor038"/> on the class level is shown here:</p>
			<div><div><img src="img/B17189_01_07.jpg" alt="Figure 1.7 – An example of a class-level docstring"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – An example of a class-level docstring</p>
			<h3>Algorithmic details</h3>
			<p>More and<a id="_idIndexMarker095"/> more often, Python projects use descriptive<a id="_idIndexMarker096"/> or predictive analytics and other complex logic. The details of the algorithm that is used need to be clearly specified with all the assumptions that were made. If an algorithm is implemented as a function, then the best place to<a id="_idTextAnchor039"/> write the summary of the logic of the algorithm is before the signature of the function.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor040"/>Developing an effective naming scheme</h1>
			<p>If developing<a id="_idIndexMarker097"/> and implementing the right logic in code is science, then making it pretty and readable is an art. Python developers are famous for paying special attention to the naming scheme and bringing <em class="italic">The Zen of Python</em> into it. Python is one of the few languages that have comprehensive guidelines on the naming scheme written by Guido van Rossum. They are written in a <em class="italic">PEP 8</em> document that has a complete section on naming conventions, which is followed by many code bases. <em class="italic">PEP 8</em> has naming and style<a id="_idIndexMarker098"/> guidelines that are suggested. You can read more about it at <a href="https://www.Python.org/dev/peps/pep-0008/">https://www.Python.org/dev/peps/pep-0008/</a>.</p>
			<p>The naming scheme<a id="_idIndexMarker099"/> suggested in <em class="italic">PEP 8</em> can be summarized<a id="_idIndexMarker100"/> as follows:</p>
			<ul>
				<li>In general, all module names should be <code>all_lower_case</code>.</li>
				<li>All class names and exception names should be <code>CamelCase</code>.</li>
				<li>All global and local variables should be <code>all_lower_case</code>.</li>
				<li>All functions and method names should be <code>all_lower_case</code>.</li>
				<li>All constants should be <code>ALL_UPPER_CASE</code>.</li>
			</ul>
			<p>Some guidelines about the structure<a id="_idIndexMarker101"/> of the code from <em class="italic">PEP 8</em> are given here:</p>
			<ul>
				<li>Indentation is important in Python. Do not use <em class="italic">Tab</em> for indentation. Instead, use four spaces.</li>
				<li>Limit nesting to four levels.</li>
				<li>Remember to limit the number of lines to 79 characters. Use the <code>\</code> symbol to break long lines.</li>
				<li>To make code readable, insert two blank lines to separate functions.</li>
				<li>Insert a single black line between various logical sections.</li>
			</ul>
			<p>Remember that <em class="italic">PEP</em> guidelines are just suggestions that may be customized by different teams. Any customized naming scheme should still use <em class="italic">PEP 8</em> as the basic guideline.</p>
			<p>Now, let's <a id="_idTextAnchor041"/>look in more detail at the naming scheme in the context of various Python language structures.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor042"/>Methods</h2>
			<p>Method names<a id="_idIndexMarker102"/> should use lowercase. The name should<a id="_idIndexMarker103"/> consist of a single word or more than one word separated by underscores. You can see an example of this here:</p>
			<pre>calculate_sum</pre>
			<p>To make the code readable, the method should preferably be a verb, related to the processing that the method is supposed to perform.</p>
			<p>If a method is non-public, it should have a leading underscore. Here's an example of this:</p>
			<pre>_my_calculate_sum</pre>
			<p><strong class="bold">Dunder</strong> or <strong class="bold">magic methods</strong> are methods that have a leading<a id="_idIndexMarker104"/> and trailing<a id="_idIndexMarker105"/> underscore. Examples of Dunder or magic methods are shown here:</p>
			<ul>
				<li><code>__init__</code></li>
				<li><code>__add__</code></li>
			</ul>
			<p>It is never a good idea to use two leading and trailing underscores to name a method, and t<a id="_idTextAnchor043"/>he use of these by developers is discouraged. Such a naming scheme is designed for Python methods.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor044"/>Variables</h2>
			<p>Use a lowercase<a id="_idIndexMarker106"/> word or words<a id="_idIndexMarker107"/> separated by an underscore to represent variables. The variables should be nouns that correspond to the entity they are representing.</p>
			<p>Examples of variables are given here:</p>
			<ul>
				<li><code>x</code></li>
				<li><code>my_v<a id="_idTextAnchor045"/>ar</code></li>
			</ul>
			<p>The names of private variables should start with an underscore. An example is <code>_my_secret_variable</code>.</p>
			<h3>Boolean variables</h3>
			<p>Starting a Boolean variable<a id="_idIndexMarker108"/> with <code>is</code> or <code>has</code> makes it more readable. You can se<a id="_idTextAnchor046"/>e a couple of examples of this here:</p>
			<pre>class Patient:
    is_admitted = False
    has_heartbeat = False</pre>
			<h3>Collection variables</h3>
			<p>As collections<a id="_idIndexMarker109"/> are buckets of variables, it is a good idea to name<a id="_idTextAnchor047"/> them in a plural format, as illustrated here:</p>
			<pre>class Patient:
    admitted_patients = ['John','Peter']</pre>
			<h3>Dictionary variables</h3>
			<p>The name of the dictionary<a id="_idIndexMarker110"/> is recommended to be as explicit as possible. For example, if we have a dictionary of people mapped to the cities they are living in, the<a id="_idTextAnchor048"/>n a dictionary can be created as follows:</p>
			<pre><code>persons_cities = {'Imran': 'Ottawa', 'Steven': 'Los Angeles'}</code></pre>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor049"/>Constant</h2>
			<p>Python<a id="_idIndexMarker111"/> does not have immutable<a id="_idIndexMarker112"/> variables. For example, in C++, we can specify a <code>const</code> keyword to specify that the variable is immutable and is a constant. Python relies on naming conventions to specify constants. If the code tries to treat a constant as a regular variable, Python will not give an error.</p>
			<p>For constants, the recommendation<a id="_idIndexMarker113"/> is to use uppe<a id="_idTextAnchor050"/>rcase words or words separated by an underscore. An example of a constant is given here:</p>
			<pre><code>CONVERSION_FACTOR</code></pre>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor051"/>Classes</h2>
			<p>Classes<a id="_idIndexMarker114"/> should follow the CamelCase style—in other words, they<a id="_idIndexMarker115"/> should start with a capital letter. If we need to use more than one word, the words should not be separated by an underscore, but each word that is appended should have an initial capital letter. Classes should use a noun and should be named in a way to best represent the entity the class corresponds to. One way of making the code readable is to use classes with suffixes that have something to do with their type or nature, such as the following:</p>
			<ul>
				<li><code>HadoopEngine</code></li>
				<li><code>ParquetType</code></li>
				<li><code>TextboxWidget</code></li>
			</ul>
			<p>Here are some points to keep in mind:</p>
			<ul>
				<li>There are exception classes that handle errors. Their names should always have <code>Error</code> as the trailing word. Here's an example of this:<pre><code>FileNotFoundError</code></pre></li>
				<li>Some of Python's built-in classes do not follow this naming guideline.</li>
				<li>To make it more readable, for base<a id="_idTextAnchor052"/> or abstract classes, a <code>Base</code> or <code>Abstract</code> prefix can be used. An example could be this:<pre>AbstractCar
BaseClass</pre></li>
			</ul>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor053"/>Packages</h2>
			<p>The use of an underscore is not encouraged<a id="_idIndexMarker116"/> while naming a package. The name<a id="_idIndexMarker117"/> should be short and all lowercase. If more than one word<a id="_idTextAnchor054"/> needs to be used, the additional word or words should also be lowercase. Here's an example of this:</p>
			<pre><code>mypackage</code></pre>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor055"/>Modules</h2>
			<p>When naming a module, short<a id="_idIndexMarker118"/> and to-the-point<a id="_idIndexMarker119"/> names should be used. Th<a id="_idTextAnchor056"/>ey need to be lowercase, and more than one word will be joined by underscores. Here's an example:</p>
			<pre><code>main_module.py</code></pre>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor057"/>Import conventions</h2>
			<p>Over the years, the Python community<a id="_idIndexMarker120"/> has developed a convention<a id="_idIndexMarker121"/> for aliases that are used for commonly used packages. You can see an example of this here:</p>
			<pre>impo<a id="_idTextAnchor058"/>rt numpy as np
import pandas as pd
import seaborn as sns
import statsmodels as sm
import matplotlib.pyplot as plt </pre>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor059"/>Arguments</h2>
			<p>Arguments are recommended<a id="_idIndexMarker122"/> t<a id="_idTextAnchor060"/>o have a naming convention similar to variables, because arguments<a id="_idIndexMarker123"/> of a function are, in fact, temporary variables.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor061"/>Useful tools</h2>
			<p>There are a couple of <a id="_idTextAnchor062"/>tools<a id="_idIndexMarker124"/> that can be used to test how closely your code conforms to <em class="italic">PEP 8</em> guidelines. Let's look into them, one by one.</p>
			<h3>Pylint</h3>
			<p>Pylint<a id="_idIndexMarker125"/> can be installed by running the following command:</p>
			<pre>$ pip install pylint</pre>
			<p>Pylint is a source code analyzer that checks the naming convention of th<a id="_idTextAnchor063"/>e code with respect to <em class="italic">PEP 89</em>. Then, it prints a report. It can be customized to be used for other naming conventions.</p>
			<h3>PEP 8</h3>
			<p><em class="italic">PEP 8</em> can be installed by running<a id="_idIndexMarker126"/> the following command:</p>
			<pre> pip: $ pip install pep8</pre>
			<p><code>pep8</code> checks the code with respect to <em class="italic">PEP 8</em>.</p>
			<p>So far, we have learned about the various naming conventions in Python. Next, we will explore different choices for using source control for Python.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor064"/>Exploring choices for source control</h1>
			<p>First, we will see<a id="_idIndexMarker127"/> a brief history of source control systems to provide a context. Modern source control systems are quite powerful. The evolution of the source control systems went through the following stages:</p>
			<ul>
				<li><strong class="bold">Stage 1</strong>: The source code<a id="_idIndexMarker128"/> was initially started by local source control systems<a id="_idIndexMarker129"/> that were stored on a hard drive. This local code collection was called a local repository.</li>
				<li><strong class="bold">Stage 2</strong>: But using source control locally was not suitable for larger teams. This solution eventually evolved into a central server-based repository that was shared by the members of the team working on a particular project. It solved the problem of code sharing among team members, but it also created an additional challenge of locking the files for the multiuser environment.</li>
				<li><strong class="bold">Stage 3</strong>: Modern version<a id="_idIndexMarker130"/> control repositories such as Git evolved this model further. All members of a team now have a full copy of the repository that is stored. The members of<a id="_idTextAnchor065"/> the team now work offline on the code. They need to connect to the repository only when there is a need to share the code.</li>
			</ul>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor066"/>What does not belong to the source control repository?</h2>
			<p>Let's look into what should<a id="_idIndexMarker131"/> not be checked into the source control repository.</p>
			<p>Firstly, anything other than the source code file shouldn't be checked in. The computer-generated files should not be checked into source control. For example, let's assume that we have a Python source file named <code>main.py</code>. If we compile it, the generated code does not belong to the repository. The compiled code is a derived file and should not be checked into source control. There are three reasons for this, outlined as follows:</p>
			<ul>
				<li>The derived file can be generated by any member of the team once we have the source code.</li>
				<li>In many cases, the compiled code is much larger than the source code, and adding it to the repository will make it slow and sluggish. Also, remember that if there are 16 members in the team, then all of them unnecessarily get a copy of that generated file, which will unnecessarily slow down the whole system.</li>
				<li>Source control systems are designed to store the delta or the changes you have made to the source files since your last commit. Files other than the source code files are usually binary files. The source control system is most likely unable to have a <code>diff</code> tool for that, and it will need to store the whole file each time it is committed. It will have a negative effect on the performance of the source control framework.</li>
			</ul>
			<p>Secondly, anything that is confidential does not belong to the source control. This includes API keys and passwords.</p>
			<p>For the source repository, GitHub is the preferred choice of the Python community. Much of the source control of the famous Python packages also resides on GitHub. If<a id="_idTextAnchor067"/> the Python code is to be utilized across teams,<a id="_idTextAnchor068"/><a id="_idTextAnchor069"/> then the right protocol and procedures need to be developed and maintained.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor070"/>Understanding strategies for deploying the code</h1>
			<p>For projects<a id="_idIndexMarker132"/> where the development team is not the end user, it is important to come up with a strategy to deploy the code for the end user. For relatively large-scale projects, when there is a well-defined <code>DEV</code> and <code>PROD</code> environment, deploying the code and strategizing it becomes important.</p>
			<p>Python is the language of choice for cloud and cluster computing environments as well.</p>
			<p>Issues related to deploying<a id="_idIndexMarker133"/> the code are listed as follows:</p>
			<ul>
				<li>Exactly the same<a id="_idIndexMarker134"/> transformations need to happen in <code>DEV</code>, <code>TEST</code>, and <code>PROD</code> environments.</li>
				<li>As the code keeps getting updated in the <code>DEV</code> environment, how will the changes be synced to the <code>PROD</code> environment?</li>
				<li>What <a id="_idTextAnchor071"/>type of testing do you plan to do in the <code>DEV</code> and <code>PROD</code> environments?</li>
			</ul>
			<p>Let's look into two main strategies for deploying the code.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor072"/>Batch development</h2>
			<p>This is the traditional<a id="_idIndexMarker135"/> development process. We develop the code, compile it, <a id="_idTextAnchor073"/>and then test it. This process is repeated iteratively until all the requirements are met. Then, the developed code is deployed.</p>
			<h3>Employing continuous integration and continuous delivery </h3>
			<p><strong class="bold">Continuous integration/continuous delivery</strong> (<strong class="bold">CI/CD</strong>) in the context of Python<a id="_idIndexMarker136"/> refers to continuous<a id="_idIndexMarker137"/> integration and deployment instead of conducting it as a batch process. It helps to create a <strong class="bold">development-operations</strong> (<strong class="bold">DevOps</strong>) environment by bridging the gap<a id="_idIndexMarker138"/> between development and operations. </p>
			<p><strong class="bold">CI</strong> refers to continuously<a id="_idIndexMarker139"/> integrating, building, and testing various modules of the code as they are being updated. For a team, this means that the code developed individually by each team member is integrated, built, and tested, typically many times a day. Once they are tested, the repository in the source control is updated. </p>
			<p>An advantage of CI is that problems or bugs are fixed right in the beginning. A typical bug fixed on the day it was created takes much less time to resolve right away instead of resolving it days, weeks, or months later when it has already trickled down to other modules and those affected may have created multilevel dependencies. </p>
			<p>Unlike Java or C++, Python<a id="_idIndexMarker140"/> is an interpreted<a id="_idIndexMarker141"/> language, which means the built code is executable on any target machine with an interpreter. In comparison, the compiled code is typically built for one type of target machine and may be developed by different members of the team. Once we have figured out which steps need to be followed each time a change is made, we can automate it.</p>
			<p>As Python code is dependent on external packages, keeping track of their names and versions is part of automating the build process. A good practice is to list all these packages in a file named <code>requirements.txt</code>. The name can be anything, but the Python community typically tends to call it <code>requirements.txt</code>.</p>
			<p>To install the packages, we will execute the following command:</p>
			<pre>$pip install -r requirements.txt</pre>
			<p>To create a <code>requirements</code> file that represents the packages used in our code, we can use the following command:</p>
			<pre>$pip freeze &gt; requirements.txt</pre>
			<p>The goal of integration is to catch errors and defects early, but it has the potential to make the development process unstable. There will be times when a member of the team has introduced a major bug, thus <em class="italic">breaking the code</em>, if other team members may have to wait until that bug is resolved. Robust self-testing by team members and choosing the right frequency for integration will help to resolve the issue. For robust testing, running testing each time a change is made should be implemented. This testing process should be eventually completely automated. In the case of errors, the build should fail and the team member responsible for the defective module should be notified. The team member can choose to first provide a quick fix before taking time to resolve and fully test the problem to make sure other team members are not blocked.</p>
			<p>Once the code is built and tested, we can choose to update the deployed code as well. That will<a id="_idIndexMarker142"/> implement the <strong class="bold">CD</strong> part. If we choose to have a complete CI/CD process, it means that each<a id="_idIndexMarker143"/> time a change is made, it is built and tested and the changes are reflected in the deployed code. If managed properly, the end user will benefit from having a constantly evolving solution. In some use cases, each CI/CD cycle may be an iterative move from MVP to a full solution. In other use cases, we are trying to capture and formulate a fast-changing real-world problem, discarding obsolete assumptions, and incorporating new information. An example is the pattern analysis of the COVID-19 situation, which is changing by the hour. Also, new information is coming at a rapid pace, and any use case related to it may benefit from CI/CD, whereby developers are constantly updating their solutions based on new emerging facts and information.</p>
			<p>Next, we will discuss commonly used development environments for Python.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor074"/>Python development environments</h1>
			<p>Text editors are a tempting<a id="_idIndexMarker144"/> choice for editing Python code. But for any medium-to-large-sized project, we have to seriously consider Python <strong class="bold">integrated development environments</strong> (<strong class="bold">IDEs</strong>), which are very helpful<a id="_idIndexMarker145"/> for writing, debugging, and troubleshooting the code using the version control and facilitating ease of deployments. There are many IDEs available, mostly free, on the market. In this section, we will review a few of them. Note that we will not try to rank them in any order but will emphasize the value each of them brings, and it is up to the reader to make the best choice based on their past experience, project requirements, and the complexity of their projects.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor075"/>IDLE</h2>
			<p><strong class="bold">Integrated Development and Learning Environment</strong> (<strong class="bold">IDLE</strong>) is a default editor that comes<a id="_idIndexMarker146"/> with Python and<a id="_idIndexMarker147"/> is available for all main platforms (Windows, macOS, and Linux). It is free and is a decent IDE for beginners for learning purposes. It is not recommended for advanced programming.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor076"/>Sublime Text</h2>
			<p><strong class="bold">Sublime Text</strong> is another popular code editor and can be used for multiple languages. It is free for evaluation purposes<a id="_idIndexMarker148"/> only. It is also available<a id="_idIndexMarker149"/> for all main platforms (Windows, macOS, and Linux). It comes with basic Python support but with its powerful extensions framework, we can customize it to make a full development environment that needs extra skills and time. Integration with a version control system such as Git or <strong class="bold">Subversion</strong> (<strong class="bold">SVN</strong>) is possible with plugins<a id="_idIndexMarker150"/> but may not expose full version control features.</p>
			<p><strong class="bold">Atom</strong> is another popular editor<a id="_idIndexMarker151"/> that is also in the same category as Sublime Text. It is free.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor077"/>PyCharm</h2>
			<p><strong class="bold">PyCharm</strong> is one of the best Python IDE<a id="_idIndexMarker152"/> editors available for Python<a id="_idIndexMarker153"/> programming and it is available for Windows, macOS, and Linux. It is a complete IDE tailored for Python programming, which helps programmers with code completion, debugging, refactoring, smart search, access to popular database servers, integration with version control systems, and many more features. The IDE provides a plugin platform for developers to extend the base functionalities as needed. PyCharm is available in the following formats:</p>
			<ul>
				<li>Community version, which is free and comes for pure Python development</li>
				<li>Professional<a id="_idIndexMarker154"/> version, which is not free<a id="_idIndexMarker155"/> and comes with support for web development such as <strong class="bold">HyperText Markup Language</strong> (<strong class="bold">HTML</strong>), JavaScript, and SQL</li>
			</ul>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor078"/>Visual Studio Code</h2>
			<p><strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) is an open source environment developed by Microsoft. For Windows, VS Code<a id="_idIndexMarker156"/> is the best Python IDE. It does<a id="_idIndexMarker157"/> not come with a Python development environment by default. The Python extensions for VS Code can make it a Python development environment.</p>
			<p>It is lightweight<a id="_idIndexMarker158"/> and full of powerful features. It is free and is also available for macOS and Linux. It comes with powerful features such as code completion, debugging, refactoring, searching, accessing database servers, version control system integration, and much more.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor079"/>PyDev</h2>
			<p>If you are using or have used Eclipse, you<a id="_idIndexMarker159"/> may like to consider PyDev, which is a third-party editor for Eclipse. It is in<a id="_idIndexMarker160"/> the category of one of the best Python IDEs and can also be used for Jython and IronPython. It is free. As PyDev is just a plugin on top of Eclipse, it is available for all major platforms, such as Eclipse. This IDE comes with all the bells and whistles of Eclipse, and on top of that, it streamlines<a id="_idIndexMarker161"/> integration with Django, unit testing, and <strong class="bold">Google App Engine</strong> (<strong class="bold">GAE</strong>).</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor080"/>Spyder</h2>
			<p>If you are planning to use Python for data science and ML, you may want to consider <strong class="bold">Spyder</strong> as your IDE. Spyder<a id="_idIndexMarker162"/> is written in Python. This IDE<a id="_idIndexMarker163"/> offers tools for full editing, debugging, interactive execution, deep inspection, and advanced visualization capabilities. Additionally, it supports integration with Matplotlib, SciPy, NumPy, Pandas, Cython, IPython, and SymPy to make it a default IDE for data scientists.</p>
			<p>Based on the review of different IDEs in this section,<a id="_idTextAnchor081"/> we can recommend PyCharm and PyDev for professional application developers. But if you are more into data science and ML, Spyder is surely worth exploring.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor082"/>Summary</h1>
			<p>In this chapter, we laid down the groundwork for the advanced Python concepts discussed in the later chapters of this book. We started by presenting the flavor, guidance, and ambience of a Python project. We started the technical discussion by first identifying different phases of the Python project and then exploring different ways of optimizing it based on the use cases we are working on. For a terse language such as Python, good-quality documentation goes a long way to make the code readable and explicit.</p>
			<p>We also looked into various ways of documenting the Python code. Next, we investigated the recommended ways of creating documentation in Python. We also studied the naming schemes that can help us in making code more readable. Next, we looked into the different ways we can use source control. We also figured out what are the different ways of deploying Python code. Finally, we reviewed a few development environments for Python to help you choose a development environment based on the background they have and the type of project you are going to work on.</p>
			<p>The topics we covered in this chapter are beneficial for anyone who is starting a new project involving Python. These discussions help to make the strategy and design decision of a new project promptly and efficiently. In the next chapter, we will investigate how we can modularize the code of a Python project.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor083"/>Questions</h1>
			<ol>
				<li value="1">What is <em class="italic">The Zen of Python</em>?</li>
				<li>In Python, what sort of documentation is available at runtime?</li>
				<li>What is a CRISP-DM life cycle?</li>
			</ol>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor084"/>Further reading</h1>
			<ul>
				<li><em class="italic">Modern Python Cookbook – Second Edition</em>, by <em class="italic">Steven F. Lott</em></li>
				<li><em class="italic">Python Programming Blueprints</em>, by <em class="italic">Daniel Furtado</em></li>
				<li><em class="italic">Secret Recipes of the Python Ninja</em>, by <em class="italic">Cody Jackson</em></li>
			</ul>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor085"/>Answers</h1>
			<ol>
				<li value="1">A collection of 19 guidelines written by Tim Peters that apply to the design of Python projects.</li>
				<li>As opposed to regular comments, docstrings are available at runtime to the compiler.</li>
				<li><strong class="bold">CRISP-DM</strong> stands for <strong class="bold">Cross-Industry Standard Process for Data Mining</strong>. It applies to a Python project life cycle in the ML domain and identifies different phases of a project.</li>
			</ol>
		</div>
	</body></html>