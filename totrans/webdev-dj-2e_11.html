<html><head></head><body>
		<div>
			<div id="_idContainer362" class="Content">
			</div>
		</div>
		<div id="_idContainer363" class="Content">
			<h1 id="_idParaDest-303"><a id="_idTextAnchor318"/>11. Advanced Templating and Class-Based Views</h1>
		</div>
		<div id="_idContainer374" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn how to use Django's templating API to create custom template tags and filters. You will also write <strong class="bold">class-based views</strong> that will help you perform CRUD operations. By the end of this chapter, you will have a clear understanding of how Django handles advanced templating and how you can build custom views that support CRUD-based operations. You will be able to use classes to define views inside Django and be able to build custom tags and filters to complement the powerful templating engine provided by Django.</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor319"/>Introduction</h1>
			<p>In <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, we learned how to build views and create templates in Django. Then, we learned how to use those views to render the templates we built. In this chapter, we will build upon our knowledge of developing views by using <strong class="bold">class-based views</strong>, which allow us to write views that can group logical methods into a single entity. This skill comes in handy when developing a view that maps to multiple HTTP request methods for the same <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) endpoint. With method-based views, we may end up using a lot of <strong class="source-inline">if-else</strong> conditions to successfully handle the different types of HTTP request methods. In contrast, class-based views allow us to define separate methods for every HTTP request method we want to handle. Then, based on the type of request received, Django takes care of calling the correct method in the class-based view.</p>
			<p>Beyond the ability to build views based on different development techniques, Django also comes packed with a powerful templating engine. This engine allows developers to build reusable templates for their web applications. This reusability of the templating engine is further enhanced by using <strong class="bold">template tags</strong> and <strong class="bold">filters</strong>, which help easily implement commonly used features inside templates, features such as iterating over lists of data, formatting the data in a given style, extracting a piece of text from a variable to display, and overriding the content in a specific block of a template. All these features also expand the reusability of a Django template.</p>
			<p>As we go through this chapter, we will look at how we can expand the default set of template filters and template tags provided by Django by leveraging Django's ability to define our own custom template tags and filters. These custom template tags and filters can then be used to implement some common features in a reusable fashion across our web application. For example, while building a user profile badge that can be shown in several places inside a web application, it is better to leverage the ability to write a custom template inclusion tag that just inserts the template of the badge in any of the views we desire, rather than rewriting the entire code for the badge template or by introducing additional complexity to the templates.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor320"/>Template Filters</h1>
			<p>While developing templates, developers often just want to change the value of a template variable before rendering it to the user. For example, consider that we are building a profile page for a Bookr user. There, we want to show the number of books the user has read. Below that, we also want to show a table listing the books they have read.</p>
			<p>To achieve this, we can pass two separate variables from our view to the HTML template. One can be named <strong class="source-inline">books_read</strong>, which denotes the number of books read by the user. The other can be <strong class="source-inline">book_list</strong>, containing the list of names of the books read by the user, for example:</p>
			<p class="source-code">&lt;span class="books_read"&gt;You have read {{ <strong class="bold">books_read</strong> }} books&lt;/span&gt;</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">{% for book in <strong class="bold">book_list</strong> %}</p>
			<p class="source-code">&lt;li&gt;{{ book }} &lt;/li&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p>Or we can use <strong class="bold">Template filters</strong>. Template filters in Django are simple Python-based functions that accept a variable as an argument (and any additional data in the context of the variable), change its value as per our requirements, and then render the changed value. </p>
			<p>Now, the same outcome from writing the previous snippet can also be obtained without the use of two separate variables by using template filters in Django, as follows:</p>
			<p class="source-code">&lt;span class="books_read"&gt;You have read {{ <strong class="bold">book_list</strong>|<strong class="bold">length</strong> }}&lt;/span&gt;</p>
			<p class="source-code">&lt;ul&gt;</p>
			<p class="source-code">{% for book in book_list %}</p>
			<p class="source-code">&lt;li&gt;{{ book }}&lt;/li&gt;</p>
			<p class="source-code">{% endfor %}</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p>Here, we used the built-in <strong class="source-inline">length</strong> filter provided by Django. The use of this filter causes the length of the <strong class="source-inline">book_list</strong> variable to be evaluated and returned, which is then inserted into our HTML template during rendering.</p>
			<p>Like <strong class="source-inline">length</strong>, there are a lot of other template filters that come pre-packaged with Django and that are ready to be used. For example, the <strong class="source-inline">lowercase</strong> filter converts the text to all lowercase format, the <strong class="source-inline">last</strong> filter can be used to return the last item in the list, and the <strong class="source-inline">json_script</strong> filter can be used to output a Python object passed to the template as a JSON value wrapped in a <strong class="source-inline">&lt;script&gt;</strong> tag in your template.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can refer to Django's official documentation for the complete list of template filters offered by Django: <a href="https://docs.djangoproject.com/en/3.1/ref/templates/builtins/">https://docs.djangoproject.com/en/3.1/ref/templates/builtins/</a>. </p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor321"/>Custom Template Filters</h1>
			<p>Django supplies a lot of useful filters that we can use in our templates while we are working on our projects. But what if someone wants to format a specific piece of text and render it with different fonts? Or say if someone wants to translate an error code to a user-friendly error message based on the mapping of the error code in the backend. In these cases, predefined filters do not suffice, and we would like to write our own filter that we can reuse across the project.</p>
			<p>Luckily, Django supplies an easy-to-use API that we can use to write custom filters. This API provides developers with some useful decorator functions that can be used to quickly register a Python function as a custom template filter. Once a Python function is registered as a custom filter, a developer can start using the function in templates.</p>
			<p>An instance of this <strong class="source-inline">template</strong> library method is required to access these filters. This instance can be created by instantiating the <strong class="source-inline">Library()</strong> class in Django from Django's <strong class="source-inline">template</strong> module, as shown here:</p>
			<p class="source-code">from django import template</p>
			<p class="source-code">register = template.Library()</p>
			<p>Once the instance is created, we can now use the filter decorator from the template library instance to register our filters.</p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor322"/>Template Filters</h2>
			<p>To create custom template filters, there are a couple of steps we need to take. Let's try to understand what these steps are and how they help us with the creation of a custom template filter.</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor323"/>Setting Up the Directory for Storing Template Filters</h2>
			<p>It is important to note that when creating a custom template filter or template tag, we need to put them in a directory named <strong class="source-inline">templatetags</strong> under the application directory. This requirement arises because Django is internally configured to look for custom template tags and filters when loading a web application. A failure to name the directory as <strong class="source-inline">templatetags</strong> will result in Django not loading the custom template filters and tags created by us.</p>
			<p>To create this directory, first, navigate to the application folder inside which you want to create custom template filters, and then run the following command in the terminal:</p>
			<p class="source-code">mkdir templatetags</p>
			<p>Once the directory is created, the next step is to create a new file inside the <strong class="source-inline">templatetags</strong> directory to store the code for our custom filters. This can be done by executing the following command inside the <strong class="source-inline">templatetags</strong> directory:</p>
			<p class="source-code">touch custom_filter.py</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The aforementioned command won't work on Windows. You can, however, navigate to the desired directory and create a new file using Windows Explorer. </p>
			<p>Alternatively, this can be done by using the GUI interface provided by PyCharm.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor324"/>Setting Up the Template Library</h2>
			<p>Once the file for storing the code for the custom filter is created, we can now start working on implementing our custom filter code. For custom filters to work in Django, they need to be registered to Django's template library before they can be used inside templates. To that end, the first step is to set up an instance of the template library, which will be used to register our custom filters. For this, inside the <strong class="source-inline">custom_filters.py</strong> file we created in the previous section, we first need to import the template module from the Django project:</p>
			<p class="source-code">from django import template</p>
			<p>Once the import is resolved, the next step is to create an instance of the template library by adding the following line of code:</p>
			<p class="source-code">register = template.Library()</p>
			<p>The <strong class="source-inline">Library</strong> class from Django's template module is implemented as a <strong class="bold">Singleton</strong> class that returns the same object that is only initialized once at the start of the application.</p>
			<p>Once the template library instance is set up, we are now good to proceed with implementing our custom filter.</p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor325"/>Implementing the Custom Filter Function</h2>
			<p>Custom filters inside Django are nothing more than simple Python functions that essentially take the following parameters:</p>
			<ol>
				<li>The value on which the filter is being applied (mandatory)</li>
				<li>Any additional parameters (zero or more) that need to be passed to the filter (optional)</li>
			</ol>
			<p>To behave as template filters, these functions need to be decorated with the <strong class="source-inline">filter</strong> attribute from Django's template library instance. For example, the generic implementation of a custom filter will look like the following:</p>
			<p class="source-code">@register.filter</p>
			<p class="source-code">def my_filter(value, arg):</p>
			<p class="source-code">    # Implementation logic of the filter</p>
			<p>With this, we have learned the basics of how to implement custom filters. Before we head to our first exercise, let's quickly learn how to use them.</p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor326"/>Using Custom Filters inside Templates</h2>
			<p>Once the filter is created, it's simple to start using it inside our templates. To do that, the filter first needs to be imported into the template. This can be easily done by adding the following line to the top of the template file:</p>
			<p class="source-code">{% load custom_filter %}</p>
			<p>When Django's templating engine is parsing the template files, the preceding line is automatically resolved by Django to find the correct module specified under the <strong class="source-inline">templatetags</strong> directory. Consequently, all the filters mentioned inside the <strong class="source-inline">custom_filter</strong> module are automatically made available inside the template.</p>
			<p>Using our custom filter inside the template is as simple as adding the following line:</p>
			<p class="source-code">{{ some_value|generic_filter:"arg" }}</p>
			<p>Equipped with this knowledge, let's now create our first custom filter.</p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor327"/>Exercise 11.01: Creating a Custom Template Filter</h2>
			<p>In this exercise, you will write a custom filter named <strong class="source-inline">explode</strong>, which, when provided with a string and a user-supplied separator, returns a list of strings. For example, consider the following string:</p>
			<p class="source-code">names = "john,doe,mark,swain"</p>
			<p>You will apply the following filter to this string:</p>
			<p class="source-code">{{ names|explode:"," }}</p>
			<p>The output after applying this filter should be as follows:</p>
			<p class="source-code">["john", "doe", "mark", "swain"]</p>
			<ol>
				<li value="1">Create a new application inside the <strong class="source-inline">bookr</strong> project that you can use for demo purposes:<p class="source-code">python manage.py startapp filter_demo</p><p>The preceding command will set up a new application inside your Django project.</p></li>
				<li>Now, create a new directory named <strong class="source-inline">templatetags</strong> inside your <strong class="source-inline">filter_demo</strong> application directory to store the code for your custom template filters. To create the directory, run the following command from inside the <strong class="source-inline">filter_demo</strong> directory from the terminal app or command prompt:<p class="source-code">mkdir templatetags</p></li>
				<li>Once the directory is created, create a new file named <strong class="source-inline">explode_filter.py</strong> inside the <strong class="source-inline">templatetags</strong> directory. </li>
				<li>Open the file and add the following lines to it:<p class="source-code">from django import template</p><p class="source-code">register = template.Library()</p><p>The preceding code creates an instance of the Django library that can be used to register our custom filter with Django.</p></li>
				<li>Add the following code to implement the <strong class="source-inline">explode</strong> filter:<p class="source-code">@register.filter</p><p class="source-code">def explode(value, separator):</p><p class="source-code">    return value.split(separator)</p><p>The <strong class="source-inline">explode</strong> filter takes two arguments; one is <strong class="source-inline">value</strong> on which the filter was used, and the second is <strong class="source-inline">separator</strong> passed from the template to the filter. The filter will use this separator to convert the string into a list.</p></li>
				<li>With the custom filter ready, create a template where this filter can be applied. For this, first, create a new folder named <strong class="source-inline">templates</strong> under the <strong class="source-inline">filter_demo</strong> directory and then create a new file named <strong class="source-inline">index.html</strong> inside it with the following contents:<p class="source-code">&lt;html&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;title&gt;Custom Filter Example&lt;/title&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code"><strong class="bold">{% load explode_filter %}</strong></p><p class="source-code"><strong class="bold">{{ names|explode:"," }}</strong></p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>In the first line, Django's template engine loads the custom filter from the <strong class="source-inline">explode_filter</strong> module so that it can be used inside the templates. To achieve this, Django will look for the <strong class="source-inline">explode_filter</strong> module under the <strong class="source-inline">templatetags</strong> directory and if, found, will load it for use.</p><p>In the next line, you pass the <strong class="source-inline">names</strong> variable passed to the template and apply the <strong class="source-inline">explode</strong> filter to it, while also passing in the comma "<strong class="source-inline">,</strong>" as a separator value to the filter.</p></li>
				<li>Now, with the template created, the next thing is to create a Django view that can render this template and pass the <strong class="source-inline">name</strong> variable to the template. For this, open the <strong class="source-inline">views.py</strong> file and add the following highlighted code:<p class="source-code">from django.shortcuts import render</p><p class="source-code"><strong class="bold">def index(request):</strong></p><p class="source-code"><strong class="bold">    names = "john,doe,mark,swain"</strong></p><p class="source-code"><strong class="bold">    return render(request, "index.html", {'names': names})</strong></p><p>The preceding code snippet performs some basic operations. It first imports the <strong class="source-inline">render</strong> helper from the <strong class="source-inline">django.shortcuts</strong> module, which helps render the templates. Once the import is complete, it defines a new view function named <strong class="source-inline">index()</strong>, which renders <strong class="source-inline">index.html</strong>.</p></li>
				<li>Now map the view to a URL that can then be used to render the results in the browser. To do this, create a new file named <strong class="source-inline">urls.py</strong> inside the <strong class="source-inline">filter_demo</strong> directory and add the following code to it:<p class="source-code">from django.urls import path</p><p class="source-code">from . import views</p><p class="source-code">urlpatterns = [path('', views.index, name='index')]</p></li>
				<li>Add the <strong class="source-inline">filter_demo</strong> application to the project URL mapping. To do this, open <strong class="source-inline">urls.py</strong> in the <strong class="source-inline">bookr</strong> project directory and add the following highlighted line inside <strong class="source-inline">urlpatterns</strong>:<p class="source-code">urlpatterns = [<strong class="bold">path('filter_demo/', include('filter_demo.urls')),\</strong></p><p class="source-code">               ….] </p></li>
				<li>Finally, add the application under the <strong class="source-inline">INSTALLED_APPS</strong> section under <strong class="source-inline">settings.py</strong> of the <strong class="source-inline">bookr</strong> project:<p class="source-code">INSTALLED_APPS = [….,\</p><p class="source-code">                  <strong class="bold">'filter_demo'</strong>]</p><p>This requirement arises due to the security guidelines implemented by Django, which require that the application implementing custom filters/tags needs to be added to the <strong class="source-inline">INSTALLED_APPS</strong> section.</p></li>
				<li>To view whether the custom filter works, run the following command:<p class="source-code">python manage.py runserver localhost:8000</p><p>Now, navigate to the following page in your browser: <strong class="source-inline">http://localhost:8000/filter_demo</strong> (or <strong class="source-inline">127.0.0.1</strong> instead of <strong class="source-inline">localhost</strong>).</p><p>This page should appear as shown in <em class="italic">Figure 11.1</em>:</p><div id="_idContainer364" class="IMG---Figure"><img src="image/B15509_11_01.jpg" alt="Figure 11.1: Index page displayed by using the explode filter"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.1: Index page displayed by using the explode filter</p>
			<p>With this, we saw how we can quickly create a custom filter inside Django and then use it in our templates. Now, let's take a look at another type of filter, namely, string filters, which work solely on string type values.</p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor328"/>String Filters</h2>
			<p>In <em class="italic">Exercise 11.01</em>, <em class="italic">Creating a Custom Template Filter</em>, we built a custom filter, which allowed us to split a provided string with a separator and generate a list from it. This filter can take any kind of variable and split it as a list of values based on a delimiter provided. But what if we wanted to restrict our filter to work only with strings and not with any other type of values, such as integers?</p>
			<p>To develop filters that work only on <em class="italic">strings</em>, we can use the <strong class="source-inline">stringfilter</strong> decorator provided by Django's template library. When the <strong class="source-inline">stringfilter</strong> decorator is used to register a Python method as a filter in Django, the framework ensures that the value being passed to the filter is converted to a string before the filter executes. This reduces any potential issues that may arise when non-string values are passed to our filter.</p>
			<p>The steps to implement a <strong class="bold">String Filter</strong> are similar to the ones we followed for building a custom filter, with some minor changes. Remember the <strong class="source-inline"> custom_filter.py</strong> file we created in the <em class="italic">Setting Up the Directory for Storing Template Filters</em> section? We can add a new Python function inside it that will act as our string filter.</p>
			<p>Before we can implement a string filter though, we first need to import the <strong class="source-inline">stringfilter</strong> decorator, which demarcates a custom filter function as a string filter. We can add this decorator by adding the following <strong class="source-inline">import</strong> statement inside the <strong class="source-inline">custom_filters.py</strong> file:</p>
			<p class="source-code">from django.template.defaultfilters import stringfilter</p>
			<p>Now, to implement our custom string filter, the following syntax can be used:</p>
			<p class="source-code">@register.filter</p>
			<p class="source-code">@stringfilter</p>
			<p class="source-code">def generic_string_filter(value, arg):</p>
			<p class="source-code">    # Logic for string filter implementation</p>
			<p>With this approach, we can build as many string filters as we want and use them just like any other filter.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor329"/>Template Tags</h1>
			<p>Template tags are a powerful feature of Django's templating engine. They allow developers to build powerful templates by generating HTML through the evaluation of certain conditions and help avoid the repetitive writing of common code. </p>
			<p>One example where we may use template tags is the sign up/login options in the navigation bar of a website. In this case, we can use template tags to evaluate whether the visitor on the current page is logged in. Based on that, we can render either a profile banner or a sign up/login banner.</p>
			<p>Tags are also a common occurrence while developing templates. For example, consider the following line of code, which we used to import the custom filters inside our templates in <em class="italic">Exercise 11.01</em>, <em class="italic">Creating a Custom Template Filter</em>:</p>
			<p class="source-code">{% load explode_filter %}</p>
			<p>This uses a template tag known as <strong class="source-inline">load</strong>, which is responsible for loading the <strong class="source-inline">explode</strong> filter into the template. Template tags are much more powerful compared to filters. While filters have access only to the values they are operating on, template tags have access to the context of the whole template and hence they can be used to build a lot of complex functionalities inside a template.</p>
			<p>Let's look at the different types of template tags that are supported by Django and how we can build our own custom template tags.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor330"/>Types of Template Tags</h2>
			<p>Django majorly supports two types of template tags:</p>
			<ul>
				<li><strong class="bold">Simple tags</strong>: These are the tags that operate on the variable data provided (and any additional variables to them) and render in the same template they have been called in. For example, one such use case can include the rendering of a custom welcome message to the user based on their username or displaying the last login time of the user based on their username.</li>
				<li><strong class="bold">Inclusion tags</strong>: These tags take in the provided data variables and generate an output by rendering another template. For example, the tag can take in a list of objects and iterate over them to generate an HTML list.</li>
			</ul>
			<p>In the next sections, we will take a look at how we can create these different types of tags and use them in our application.</p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor331"/>Simple Tags</h2>
			<p>Simple tags provide a way for developers to build template tags that take in one or more variables from the template, process them, and return a response. The response returned from the template tag is used to replace the template tag definition provided inside the HTML template. These kinds of tags can be used to build several useful functionalities, for example, the parsing of dates, or displaying any active alerts, if there are any, that we want to show to the user.</p>
			<p>The simple tags can be created easily using the <strong class="source-inline">simple_tag</strong> decorator provided by the template library, by decorating the Python method that should act as a template tag. Now, let us look at how we can implement a custom simple tag using Django's template library.</p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor332"/>How to Create a Simple Template Tag</h2>
			<p>Creating simple template tags follows the same conventions we discussed in the <em class="italic">Custom Template Filters</em> section, with some subtle differences. Let us go over the process of understanding how template tags can be created for use in our Django templates.</p>
			<h3 id="_idParaDest-318"><a id="_idTextAnchor333"/>Setting Up the Directory</h3>
			<p>Just like custom filters, custom template tags also need to be created inside the same <strong class="source-inline">templatetags</strong> directory to make them discoverable by Django's templating engine. The directory can be created either directly using the PyCharm GUI or by running the following command inside the application directory where we want to create our custom tags:</p>
			<p class="source-code">mkdir templatetags</p>
			<p>Once this is done, we can now create a new file that will store the code for our custom template tags by using the following command:</p>
			<p class="source-code">touch custom_tags.py</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The aforementioned command won't work on Windows. You can, however, create a new file using Windows Explorer. </p>
			<h3 id="_idParaDest-319"><a id="_idTextAnchor334"/>Setting Up the Template Library</h3>
			<p>Once the directory structure is set up and we have a file in place for keeping the code for our custom template tags, we can now proceed and start creating our template tags. But before that, we need to set up an instance of Django's template library as we did earlier. This can be done by adding the following lines of code to our <strong class="source-inline">custom_tag.py</strong> file:</p>
			<p class="source-code">from django import template</p>
			<p class="source-code">register = template.Library()</p>
			<p>Like custom filters, the template library instance is used here to register the custom template tags for use inside Django templates.</p>
			<h3 id="_idParaDest-320"><a id="_idTextAnchor335"/>Implementing a Simple Template Tag</h3>
			<p>Simple template tags inside Django are Python functions that can take any number of arguments as desired by us. These Python functions need to be decorated with the <strong class="source-inline">simple_tag</strong> decorator from the template library such that those functions are registered as simple template tags. The following snippet of code shows how a simple template tag is implemented:</p>
			<p class="source-code">@register.simple_tag</p>
			<p class="source-code">def generic_simple_tag(arg1, arg2):</p>
			<p class="source-code">    # Logic to implement a generic simple tag</p>
			<h3 id="_idParaDest-321"><a id="_idTextAnchor336"/>Using Simple Tags inside Templates</h3>
			<p>Using simple tags inside Django templates is quite easy. Inside the template file, we need to first make sure that we have the tag imported inside the template by adding the following to the top of the template file:</p>
			<p class="source-code">{% load custom_tag %}</p>
			<p>The preceding statement will load all the tags from the <strong class="source-inline">custom_tag.py</strong> file we defined earlier and make them available inside our template. Then we can use our custom simple tag by adding the following command:</p>
			<p class="source-code">{% custom_simple_tag "argument1" "argument2" %}</p>
			<p>Now, let's put this knowledge into practice and create our first custom simple tag.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor337"/>Exercise 11.02: Creating a Custom Simple Tag</h2>
			<p>In this exercise, you will create a simple tag that will take in two arguments: the first one will be a greeting message, and the second will be the name of the user. This tag will print a formatted greeting message:</p>
			<ol>
				<li value="1">Following up on the example shown in <em class="italic">Exercise 11.01</em>, <em class="italic">Creating a Custom Template Filter</em>, let us re-use the same directory structure to store the code for the simple tag inside. So, first, create a new file named <strong class="source-inline">simple_tag.py</strong> under the <strong class="source-inline">filter_demo/template_tags</strong> directory. Inside this file, add the following code:<p class="source-code">from django import template</p><p class="source-code">register = template.Library()</p><p class="source-code">@register.simple_tag</p><p class="source-code">def greet_user(message, username):</p><p class="source-code">    return\</p><p class="source-code">    "{greeting_message},\</p><p class="source-code">     {user}!!!".format(greeting_message=message, user=username)</p><p>In this case, you create a new Python method, <strong class="source-inline">greet_user()</strong>, which takes in two arguments, <strong class="source-inline">message</strong>, the message to use for the greeting, and <strong class="source-inline">username</strong>, the name of the user who should be greeted. This method is then decorated with <strong class="source-inline">@register.simple_tag</strong>, which indicates that this method is a simple tag and can be used as a template tag in the templates.</p></li>
				<li>Now, create a new template that will use your simple tag. For this, create a new file named <strong class="source-inline">simple_tag_template.html</strong> under the <strong class="source-inline">filter_demo/templates</strong> directory and add the following code to it:<p class="source-code">&lt;html&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">&lt;title&gt;Simple Tag Template Example&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">{% load simple_tag %}</p><p class="source-code">{% greet_user "Hey there" username %}</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>In the preceding code snippet, you just created a bare-bones HTML page that will use your custom simple tag. The semantics of loading a custom template tag is similar to that of loading a custom template filter and requires the use of a <strong class="source-inline">{% load %}</strong> tag in the template. The process will look for the <strong class="source-inline">simple_tag.py</strong> module under the <strong class="source-inline">templatetags</strong> directory and, if found, will load the tags that have been defined under the module.</p><p>The following line shows how you can use the custom template tag:</p><p class="source-code">{% greet_user "Hey there" username %}</p><p>In this, you first used Django's tag specifier, <strong class="source-inline">{% %}</strong>, and inside it, the first argument you passed is the name of the tag that needs to be used, followed by the first argument, <strong class="source-inline">Hey there</strong>, which is the greeting message, and the second argument, <strong class="source-inline">username</strong>, which will be passed to the template from the view function.</p></li>
				<li>With the template created, the next step involves creating a view that will render your template. For this, add the following code under the <strong class="source-inline">views.py</strong> file under the <strong class="source-inline">filter_demo</strong> directory:<p class="source-code">def greeting_view(request):</p><p class="source-code">    return render(request),\</p><p class="source-code">                 ('simple_tag_template.html', {'username': 'jdoe'})</p><p>In the preceding code snippet, you created a simple function-based view, which will render your <strong class="source-inline">simple_tag_template</strong> defined in <em class="italic">step 2</em> and pass the value <strong class="source-inline">'jdoe'</strong> to the variable called <strong class="source-inline">username</strong>.</p></li>
				<li>With the view created, the next step is to map it to a URL endpoint in your application. To do this, open the <strong class="source-inline">urls.py</strong> file under the <strong class="source-inline">filter_demo</strong> directory and add the following inside the <strong class="source-inline">urlpatterns</strong> list:<p class="source-code">path('greet', views.greeting_view, name='greeting')</p><p>With this, <strong class="source-inline">greeting_view</strong> is now mapped to the URL endpoint <strong class="source-inline">/greet</strong> for your <strong class="source-inline">filter_demo</strong> application.</p></li>
				<li>To see the custom tag in action, start your web server by running the following command:<p class="source-code">python manage.py runserver localhost:8000</p><p>After visiting <strong class="source-inline">http://localhost:8000/filter_demo/greet</strong> in the browser (or <strong class="source-inline">127.0.0.1</strong> instead of <strong class="source-inline">localhost</strong>), you should see the following page:</p><div id="_idContainer365" class="IMG---Figure"><img src="image/B15509_11_02.jpg" alt="Figure 11.2: Greeting message generated with the help of the custom simple tag"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.2: Greeting message generated with the help of the custom simple tag</p>
			<p>With this, we have created our first custom template tag and used it successfully to render our template, as shown in <em class="italic">Figure 11.2</em>. Now, let's look at another important aspect of simple tags, which is associated with passing the context variables available in the template to the template tag.</p>
			<h3 id="_idParaDest-323"><a id="_idTextAnchor338"/>Passing the Template Context in a Custom Template Tag</h3>
			<p>In the previous exercise, we created a simple tag to which we passed two arguments, namely, the greeting message and the username. But what if we wanted to pass a large number of variables to the tag? Or simply, what if we did not want to pass the username of the user explicitly to the tag?</p>
			<p>There are times when developers would like to have access to all the variables and data that is present in the template to be available inside the custom tag. Fortunately for us, this is easy to implement.</p>
			<p>Using our previous example of the <strong class="source-inline">greet_user</strong> tag, let's create a new tag named <strong class="source-inline">contextual_greet_user</strong> and see how we can pass the data available in the template directly to the tag instead of passing it manually as an argument.</p>
			<p>The first modification we need to make is to modify our decorator to look like the following:</p>
			<p class="source-code">@register.simple_tag(takes_context=True)</p>
			<p>With this, we tell Django that when our <strong class="source-inline">contextual_greet_user</strong> tag is used, Django should also pass it the template context, which has all the data that is passed from the view to the template. With this addition done, the next thing we need to do is to change our <strong class="source-inline">contextual_greet_user</strong> implementation to accept the added context as an argument. The following code shows the modified form of the <strong class="source-inline">contextual_greet_user</strong> tag, which uses our template context to render a greeting message:</p>
			<p class="source-code">@register.simple_tag(takes_context=True)</p>
			<p class="source-code">def contextual_greet_user(context, message):</p>
			<p class="source-code">    username = context['username']</p>
			<p class="source-code">    return "{greeting_message},\</p>
			<p class="source-code">            {user}".format(greeting_message=message, user=username)</p>
			<p>In the preceding code example, we can see how the <strong class="source-inline">contextual_greet_user()</strong> method was modified to accept the passed context as the first argument, followed by the greeting message passed by the user.</p>
			<p>To leverage this modified template tag, all we need to do is to change our call to the <strong class="source-inline">contextual_greet_user</strong> tag inside <strong class="source-inline">simple_tag_template.html</strong> under <strong class="source-inline">filter_demo</strong> to look like this:</p>
			<p class="source-code">{% contextual_greet_user "Hey there" %}</p>
			<p>Then, when we reload our Django web application, the output at <strong class="source-inline">http://localhost:8000/filter_demo/greet</strong> should look similar to what was shown in <em class="italic">step 5</em> of <em class="italic">Exercise 11.02</em>, <em class="italic">Creating a Custom Simple Tag</em>.</p>
			<p>With this, we got to know how we can build a simple tag and handle passing the template context to the tag. Now, let us look at how we can build an inclusion tag that can be used to render data in a certain format as described by another template.</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor339"/>Inclusion Tags</h2>
			<p>Simple tags allow us to build tags that accept one or more input variables, do some processing on them, and return an output. This output is then inserted at the place where the simple tag was used.</p>
			<p>But what if we wanted to build tags that, instead of returning text output, return an HTML template, which can then be used to render the parts of the page. For example, a lot of web applications allow users to add custom widgets to their profiles. These individual widgets can be built as an inclusion tag and rendered over independently. This kind of approach keeps the code for the base page template and the individual templates separate and hence allows for easy reuse as well as refactoring.</p>
			<p>Developing custom inclusion tags is a similar process to how we develop our simple tags. This involves the use of the <strong class="source-inline">inclusion_tag</strong> decorator provided by the template library. So, let's take a look at how we can do it.</p>
			<h3 id="_idParaDest-325"><a id="_idTextAnchor340"/>Implementing Inclusion Tags</h3>
			<p>Inclusion tags are those tags that are used for rendering a template as a response to their usage inside a template. These tags can be implemented in a similar manner to how other custom template tags are implemented, with some minor modifications.</p>
			<p>Inclusion tags are also simple Python functions that can take multiple parameters, where each parameter maps to an argument passed from the template where the tag was called. These tags are decorated using the <strong class="source-inline">inclusion_tag</strong> decorator from Django's template library. The <strong class="source-inline">inclusion_tag</strong> decorator takes a single parameter, the name of the template, which should be rendered as a response to the processing of the inclusion tag.</p>
			<p>A generic implementation of an inclusion tag will look like the one shown in the following code snippet:</p>
			<p class="source-code">@register.inclusion_tag('template_file.html')</p>
			<p class="source-code">def my_inclusion_tag(arg):</p>
			<p class="source-code">    # logic for processing</p>
			<p class="source-code">    return {'key1': 'value1'}</p>
			<p>Notice the return value in this case. An inclusion tag is supposed to return a dictionary of values that will be used to render the <strong class="source-inline">template_file.html</strong> file specified as an argument in the <strong class="source-inline">inclusion_tag</strong> decorator.</p>
			<h3 id="_idParaDest-326"><a id="_idTextAnchor341"/>Using an Inclusion Tag inside a Template</h3>
			<p>An inclusion tag can easily be used inside a template file. This can be done by first importing the tag as follows:</p>
			<p class="source-code">{% load custom_tags %}</p>
			<p>And then by using the tag like any other tag:</p>
			<p class="source-code">{% my_inclusion_tag "argument1" %}</p>
			<p>The response of the rendering of this tag will be a sub-template that will be rendered inside our primary template where the inclusion tag was used.</p>
			<h2 id="_idParaDest-327"><a id="_idTextAnchor342"/>Exercise 11.03: Building a Custom Inclusion Tag</h2>
			<p>In this exercise, we are going to build a custom <strong class="source-inline">inclusion</strong> tag, which will render the list of books read by a user:</p>
			<ol>
				<li value="1">For this exercise, you will continue to use the same demo folders as in earlier exercises. First, create a new file named <strong class="source-inline">inclusion_tag.py</strong> under the <strong class="source-inline">filter_demo/templatetags</strong> directory and write the following code inside it:<p class="source-code">from django import template</p><p class="source-code">register = template.Library()</p><p class="source-code">@register.inclusion_tag('book_list.html')</p><p class="source-code">def book_list(books):</p><p class="source-code">    book_list = [book_name for book_name, \</p><p class="source-code">                 book_author in books.items()]</p><p class="source-code">    return {'book_list': book_list}</p><p>The <strong class="source-inline">@register.inclusion_tag</strong> decorator is used to mark the method as a custom inclusion tag. This decorator takes the name of the template as an argument that should be used to render the data returned by the tag function.</p><p>After the decorator, you define a function that implements the logic of your custom inclusion tag. This function takes a single argument called <strong class="source-inline">books</strong>. This argument will be passed from the template file and will contain a list of books that the reader has read (in the form of a <strong class="source-inline">Python</strong> dictionary). Inside the definition, you convert the dictionary into a Pythonic list of book names. The key in the dictionary is mapped to the name of the book and the value is mapped to the author:</p><p class="source-code">books_list = [book_name for book_name, \</p><p class="source-code">              book_author in books.items()]</p><p>Once the list is formed, the following code returns the list as a context for the template passed to the inclusion tag (in this example, <strong class="source-inline">book_list.html</strong>):</p><p class="source-code">return {'book_list': books_list}</p><p>The value returned by this method will be passed by Django to the <strong class="source-inline">book_list.html</strong> template and the contents will then be rendered.</p></li>
				<li>Next, create the actual template, which will contain the rendering structure for the template tag. For this, create a new template file, <strong class="source-inline">book_list.html</strong>, under the <strong class="source-inline">filter_demo/templates</strong> directory, and add the following content to it:<p class="source-code">&lt;ul&gt;</p><p class="source-code">  {% for book in book_list %}</p><p class="source-code">&lt;li&gt;{{ book }}&lt;/li&gt;</p><p class="source-code">  {% endfor %}</p><p class="source-code">&lt;/ul&gt;</p><p>Here, in the new template file, you created an unordered list that will hold the list of books a user has read. Next, using the <strong class="source-inline">for</strong> template tag, you iterate over the values within <strong class="source-inline">book_list</strong> that will be provided by the custom template function:</p><p class="source-code">{% for book in book_list %}</p><p>This iteration results in the creation of several list items, as defined by the following:</p><p class="source-code">&lt;li&gt;{{ book }}&lt;/li&gt;</p><p>The list item is generated with the contents from <strong class="source-inline">book_list</strong>, which was passed to the template. The <strong class="source-inline">for</strong> tag executes as many times as the number of items present in <strong class="source-inline">book_list</strong>.</p></li>
				<li>With the template defined for the <strong class="source-inline">book_list</strong> tag, modify the existing greeting template to make this tag available inside it and use it to show a list of books that the user has read. For this, modify the <strong class="source-inline">simple_tag_template.html</strong> file under the <strong class="source-inline">filter_demo/templates</strong> directory and change the code to look as follows:<p class="source-code">&lt;html&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;title&gt;Simple Tag Template Example&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">{% load simple_tag inclusion_tag %}</p><p class="source-code">{% greet_user "Hey" username %}</p><p class="source-code">  &lt;br /&gt;</p><p class="source-code">  &lt;span class="message"&gt;You have read the following books     till date&lt;/span&gt;</p><p class="source-code">{% book_list books %}</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>In this snippet, the first thing you did was load the <strong class="source-inline">inclusion_tag</strong> module by writing the following:</p><p class="source-code">{% load simple_tag inclusion_tag %}</p><p>Once the tag is loaded, you can now use it anywhere in the template. To use it, you added the <strong class="source-inline">book_list</strong> tag in the following format:</p><p class="source-code">{% book_list books %}</p><p>This tag takes a single argument, which is a dictionary of the books, inside which the key is the book title and the value of the key is the author of the book. At this point, you can even customize the greeting message; in this step, we have gone with a simple "<strong class="source-inline">Hey</strong>" instead of "<strong class="source-inline">Hey there</strong>".</p></li>
				<li>With the template now modified, the final step involves passing the required data to the template. To achieve this, modify <strong class="source-inline">views.py</strong> in the <strong class="source-inline">filter_demo</strong> directory and change the greeting view function to look like this:<p class="source-code">def greeting_view(request):</p><p class="source-code">    books = {"The night rider": "Ben Author",\</p><p class="source-code">             "The Justice": "Don Abeman"}</p><p class="source-code">    return render(request),\</p><p class="source-code">                 ('simple_tag_template.html'),\</p><p class="source-code">                 ({'username': 'jdoe', 'books': books})</p><p>Here, you modified the <strong class="source-inline">greeting_view</strong> function to add a dictionary of books and their authors and then you passed it to the <strong class="source-inline">simple_tag_template</strong> context.</p></li>
				<li>With the preceding changes implemented, it's time to render the modified template. To do this, restart your Django application server by running the following command:<p class="source-code">python manage.py runserver localhost:8080</p><p>Navigate to <strong class="source-inline">http://localhost:8080/filter_demo/greet</strong>, which should now render a page similar to the following screenshot:</p><div id="_idContainer366" class="IMG---Figure"><img src="image/B15509_11_03.jpg" alt="Figure 11.3: List of books read by a user when they visit the greeting endpoint"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.3: List of books read by a user when they visit the greeting endpoint</p>
			<p>The page shows the list of books read by a user when they visit the greeting endpoint. The list you see on the page is rendered using inclusion tags. The template for listing these books is created separately first and then, using the inclusion tag, it is added to the page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Our work with the <strong class="source-inline">filter_demo</strong> app is complete. You can continue to customize this app further if you wish to practice the concepts you learned. Since the app was created solely to explain the concepts of custom template filters and template tags, and is unrelated to the <strong class="source-inline">bookr</strong> app we're building, you won't find it included in the <strong class="source-inline">final/bookr</strong> application folder on the GitHub repository. </p>
			<p>With this, we now have the foundations on which we can build highly complex template filters or custom tags that can be helpful in the development of the projects we want to work on.</p>
			<p>Now, let's revisit Django views and dive into a new territory of views called <strong class="bold">Class-Based Views</strong>. Provided by Django, these help us leverage the power of object-oriented programming and allow the re-use of code for the rendering of a view.</p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor343"/>Django Views</h1>
			<p>To recall, a view in Django is a piece of Python code that allows a request to be taken in, performs an action based on the request, and then returns a response to the user, and hence forms an important part of our Django applications.</p>
			<p>Inside Django, we have the option of building our views by following two different methodologies, one of which we have already seen in the preceding examples and is known as function-based views, while the other one, which we will be covering soon, is known as class-based views:</p>
			<ul>
				<li><strong class="bold">Function-Based Views</strong> (<strong class="bold">FBVs</strong>): FBVs inside Django are nothing more than generic Python functions that are supposed to take an <strong class="source-inline">HTTPRequest</strong> type object as their first positional parameter and return an <strong class="source-inline">HTTPResponse</strong> type object, which corresponds to the action the view wants to perform once the request is processed by it. In the preceding exercise, <strong class="source-inline">index()</strong> and <strong class="source-inline">greeting_view()</strong> were examples of FBVs.</li>
				<li><strong class="bold">Class-Based Views</strong> (<strong class="bold">CBVs</strong>): CBVs are views that closely adhere to the Python object-oriented principles and allow mapping of the view calls in a class-based representation. These views are specialized in nature and a given type of CBV performs a specific operation. The benefits that CBVs provide include easy extensibility of the view and the re-use of code, which may turn out to be a complex task with FBVs.</li>
			</ul>
			<p>Now, with the basic definitions clear, and with knowledge of FBVs already in our arsenal, let's look at CBVs and see what they have in store for us.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor344"/>Class-Based Views</h1>
			<p>Django provides different ways in which developers can write views for their applications. One way is to map a Python function to act as a view function to create FBVs. Another way of creating views is to use Python object instances (which are based on top of Python classes). These are known as CBVs. An important question that arises is, what is the need for a CBV when we can already create views using the FBV approach?</p>
			<p>The idea here, when creating FBVs, is that at times, we may be replicating the same logic again and again, for example, the processing of certain fields, or logic for handling certain request types. Although it is completely possible to create logically separate functions that handle a particular piece of logic, the task becomes difficult to manage as the complexity of the application increases.</p>
			<p>This is where CBVs come in handy, where they abstract away implementation of the common repetitive code that we need to write to handle certain tasks, such as the rendering of templates. At the same time, they also make it easy to re-use pieces of code through the use of inheritance and mix-ins. For example, the following code snippet shows the implementation of a CBV:</p>
			<p class="source-code">from django.http import HttpResponse</p>
			<p class="source-code">from django.views import View</p>
			<p class="source-code">class IndexView(View):</p>
			<p class="source-code">    def get(self, request):</p>
			<p class="source-code">        return HttpResponse("Hey there!")</p>
			<p>In the preceding example, we built a simple CBV by inheriting from the built-in view class, which is provided by Django.</p>
			<p>Using these CBVs is also quite easy. For example, let's say we wanted to map <strong class="source-inline">IndexView</strong> to a URL endpoint in our application. In this case, all we need to do is to add the following line to our <strong class="source-inline">urlpatterns</strong> list inside the <strong class="source-inline">urls.py</strong> file of the application:</p>
			<p class="source-code">urlpatterns = [<strong class="bold">path('my_path', IndexView.as_view(), \</strong></p>
			<p class="source-code"><strong class="bold">                    name='index_view')</strong>]</p>
			<p>In this, as we can observe, we used the <strong class="source-inline">as_view()</strong> method of the CBV we created. Every CBV implements the <strong class="source-inline">as_view()</strong> method, which allows the view class to be mapped to a URL endpoint by returning the instance of the view controller from the view class.</p>
			<p>Django provides a couple of built-in CBVs that provide the implementation of a lot of common tasks, such as how to render a template, or how to process a particular request. The built-in CBVs help to avoid the rewriting of code from scratch when handling basic functionality, thereby enabling the reusability of code. Some of these in-built views include the following:</p>
			<ul>
				<li><strong class="bold">View</strong>: The base class for all CBVs available in Django that allows a custom CBV to be written with all the features provided and overridable. A user can implement their own definitions for different HTTP <strong class="source-inline">Request</strong> methods, such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>, and the view will automatically delegate the call to the method that is responsible for handling the request based on the type of request received.</li>
				<li><strong class="bold">TemplateView</strong>: A view that can be used to render a template based on the parameters for the template data provided in the URL of the call. This allows developers to easily render a template without writing any logic related to how the rendering should be handled.</li>
				<li><strong class="bold">RedirectView</strong>: A view that can be used to automatically redirect a user to the correct resource based on the request they have made.</li>
				<li><strong class="bold">DetailView</strong>: A view that is mapped to a Django model and can be used to render the data obtained from the model using a template of choice.</li>
			</ul>
			<p>The preceding views are just some of the built-in views that Django provides by default and we will cover more of them as we move through the chapter.</p>
			<p>Now, to better understand how CBVs work inside Django, let's try to build our first CBV.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor345"/>Exercise 11.04: Creating a Book Catalog Using a CBV</h2>
			<p>In this exercise, you will create a class-based form view that will help build a book catalog. This catalog will consist of the name of the book and the name of the author of the book. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">To understand the concept of class-based views, we will create a separate application inside Bookr with its own set of models and forms such that our existing code from previous exercises is not affected. Just like <strong class="source-inline">filter_demo</strong>, we won't be including this app in the <strong class="source-inline">final/bookr</strong> folder on our GitHub repo.</p>
			<ol>
				<li value="1">To get started, create a new application inside our <strong class="source-inline">bookr</strong> project and name it <strong class="source-inline">book_management</strong>. This can be done by simply running the following command:<p class="source-code">python manage.py startapp book_management</p></li>
				<li>Now, before building the book catalog, you first need to define a Django model that will help you store the records inside the database. To do this, open the <strong class="source-inline">models.py</strong> file under the <strong class="source-inline">book_management</strong> app you just created and define a new model named <strong class="source-inline">Book</strong>, as shown here:<p class="source-code">from django.db import models</p><p class="source-code">class Book(models.Model):</p><p class="source-code">    name = models.CharField(max_length=255)</p><p class="source-code">    author = models.CharField(max_length=50)</p><p>The model contains two fields, the name of the book and the name of the author. With the model in place, you'll need to migrate the model to your database such that you can start storing your data inside the database.</p></li>
				<li>Once all the preceding steps are complete, add your book_management application to the <strong class="source-inline">INSTALLED_APPS</strong> list such that it can be discovered by Django and you can use your model properly. For this, open the <strong class="source-inline">settings.py</strong> file under the bookr directory and add the following code at the final position in the <strong class="source-inline">INSTALLED_APPS</strong> section:<p class="source-code">INSTALLED_APPS = [….,\</p><p class="source-code">                  <strong class="bold">'book_management'</strong>]</p></li>
				<li>Migrate your model to the database by running the following two commands. These will first create a Django migrations file and then create a table in your database:<p class="source-code">python manage.py makemigrations</p><p class="source-code">python manage.py migrate</p></li>
				<li>Now, with the database model in place, let's create a new form that we will use to capture information about the books, such as the book title, author, and ISBN. For this, create a new file named <strong class="source-inline">forms.py</strong> under the <strong class="source-inline">book_management</strong> directory and add the following code inside it:<p class="source-code">from django import forms</p><p class="source-code">from .models import Book</p><p class="source-code">class BookForm(forms.ModelForm):</p><p class="source-code">    class Meta:</p><p class="source-code">        model = Book</p><p class="source-code">        fields = ['name', 'author']</p><p>In the preceding code snippet, you first imported Django's forms module, which will allow you to easily create forms and will also provide the rendering capability for the form. The next line imports the model that will store the data for the form:</p><p class="source-code">from django import forms</p><p class="source-code">from .models import Book</p><p>In the next line, you created a new class named <strong class="source-inline">BookForm</strong>, which inherits from the <strong class="source-inline">ModelForm</strong>. This is nothing but a class that maps the fields of the model to the form. To successfully achieve this mapping between the model and the form, you defined a new subclass named <strong class="source-inline">Meta</strong> under the <strong class="source-inline">BookForm</strong> class and set the attribute model to point to the <strong class="source-inline">Book</strong> model and the attribute fields to the list of fields that you want to display in the form:</p><p class="source-code">class Meta:</p><p class="source-code">    model = Book</p><p class="source-code">    fields = ['name', 'author']</p><p>This allows for <strong class="source-inline">ModelForm</strong> to render the correct form HTML when expected to do so. The <strong class="source-inline">ModelForm</strong> class provides a built-in <strong class="source-inline">Form.save()</strong> method, which, when used, writes the data in the form to the database, and so helps avoid having to write redundant code.</p></li>
				<li>Now that you have both your model and the form ready, go ahead and implement a view that will render the form and accept input from the user. For this, open <strong class="source-inline">views.py</strong> under the book_management directory and add the following lines of code to the file:<p class="source-code">from django.http import HttpResponse</p><p class="source-code">from django.views.generic.edit import FormView</p><p class="source-code">from django.views import View</p><p class="source-code">from .forms import BookForm</p><p class="source-code">class BookRecordFormView(FormView):</p><p class="source-code">    template_name = 'book_form.html'</p><p class="source-code">    form_class = BookForm</p><p class="source-code">    success_url = '/book_management/entry_success'</p><p class="source-code">    def form_valid(self, form):</p><p class="source-code">        form.save()</p><p class="source-code">        return super().form_valid(form)</p><p class="source-code">class FormSuccessView(View):</p><p class="source-code">    def get(self, request, *args, **kwargs):</p><p class="source-code">        return HttpResponse("Book record saved successfully")</p><p>In the preceding code snippet, you created two major views, one being <strong class="source-inline">BookRecordFormView</strong>, which is also responsible for rendering the book catalog entry form, and the other being <strong class="source-inline">FormSuccessView</strong>, which you will use to render the success message if the form data is saved successfully. Let's now look at both the views individually and understand what we are doing.</p><p>First, you created a new view named the <strong class="source-inline">BookRecordFormView</strong> CBV, which inherits from <strong class="source-inline">FormView</strong>:</p><p class="source-code">class BookRecordFormView(FormView)</p><p>The <strong class="source-inline">FormView</strong> class allows you to easily create views that deal with forms. To this class, you need to provide certain parameters, such as the name of the template it will render to show the form, the form class that it should use to render the form, and the success URL to redirect to when the form is processed successfully:</p><p class="source-code">template_name = 'book_form.html'</p><p class="source-code">form_class = BookForm</p><p class="source-code">success_url = '/book_management/entry_success'</p><p>The <strong class="source-inline">FormView</strong> class also provides a <strong class="source-inline">form_valid()</strong> method, which is called when the form successfully finishes the validation. Inside the <strong class="source-inline">form_valid()</strong> method, we can decide what we want to do. For our use case, when the form validation completes successfully, we first call the <strong class="source-inline">form.save()</strong> method, which persists the data for our form into the database, and then call the base class <strong class="source-inline">form_valid()</strong> method, which will cause the form view to redirect to the successful URL if form validation was a success:</p><p class="source-code">def form_valid(self, form):</p><p class="source-code">    form.save()</p><p class="source-code">    return super().form_valid(form)</p><p class="callout-heading">Note </p><p class="callout">The <strong class="source-inline">form_valid()</strong> method should always return an <strong class="source-inline">HttpResponse</strong> object.</p><p>This completes the implementation of <strong class="source-inline">BookRecordFormView</strong>. The next thing we have to do is to build a view named <strong class="source-inline">FormSuccessView</strong>, which we will use to render the success message once the data is saved successfully for the book record form we just created. This is done by creating a new view class named <strong class="source-inline">FormSuccessView</strong>, which inherits from the view base class of Django CBVs:</p><p class="source-code">class FormSuccessView(View)</p><p>Inside this class, we override the <strong class="source-inline">get()</strong> method, which will be rendered when the form is saved successfully. Inside the <strong class="source-inline">get()</strong> method, we render a simple success message by returning a new <strong class="source-inline">HttpResponse</strong>:</p><p class="source-code">    def get(self, request, *args, **kwargs):</p><p class="source-code">        return HttpResponse("Book record saved successfully")</p></li>
				<li>Now, create a template that will be used to render the form. For this, create a new <strong class="source-inline">templates</strong> folder under the <strong class="source-inline">book_management</strong> directory and create a new file named <strong class="source-inline">book_form.html</strong>. Add the following lines of code inside the file:<p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;title&gt;Book Record Insertion&lt;/title&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;form method="POST"&gt;</p><p class="source-code">      {% csrf_token %}</p><p class="source-code">      {{ form.as_p }}</p><p class="source-code">      &lt;input type="submit" value="Save record" /&gt;</p><p class="source-code">    &lt;/form&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p><p>Inside this code snippet, two important things need to be discussed.</p><p>The first is the use of the <strong class="source-inline">{% csrf_token %}</strong> tag. This tag is inserted to prevent the form from running into <strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>) attacks. The <strong class="source-inline">csrf_token</strong> tag is one of the built-in template tags provided by Django to avoid such attacks. It does so by generating a unique token for every form instance that is rendered.</p><p>The second is the use of the <strong class="source-inline">{{ form.as_p }}</strong> template variable. The data for this variable is provided by our <strong class="source-inline">FormView</strong>-based view automatically. The <strong class="source-inline">as_p</strong> call causes the form fields to be rendered inside the <strong class="source-inline">&lt;p&gt;&lt;/p&gt;</strong> tags.</p></li>
				<li>With the CBVs now built, go ahead and map them to URLs, such that you can start using them to add new book records. To do this, create a new file named <strong class="source-inline">urls.py</strong> under the book_management directory and add the following code to it:<p class="source-code">from django.urls import path</p><p class="source-code">from .views import BookRecordFormView, FormSuccessView</p><p class="source-code">urlpatterns = [path('new_book_record',\</p><p class="source-code">               BookRecordFormView.as_view(),\</p><p class="source-code">               name='book_record_form'),\</p><p class="source-code">               path('entry_success', FormSuccessView.as_view()),\</p><p class="source-code">                   (name='form_success')]</p><p>Most parts of the preceding snippet are similar to the ones that you have written earlier, but there is one thing different in the way we map our CBVs under the URL patterns. When using CBVs, instead of directly adding the function name, we use the class name and use its <strong class="source-inline">as_view</strong> method, which maps the class object to the view. For example, to map <strong class="source-inline">BookRecordFormView</strong> as a view, we will use <strong class="source-inline">BookRecordFormView.as_view()</strong>.</p></li>
				<li>With the URLs added to our <strong class="source-inline">urls.py</strong> file, the next thing is to add our application URL mapping to our <strong class="source-inline">bookr</strong> project. To do this, open the <strong class="source-inline">urls.py</strong> file under the <strong class="source-inline">bookr</strong> application and add the following line to <strong class="source-inline">urlpatterns</strong>:<p class="source-code">urlpatterns = [<strong class="bold">path('book_management/',\</strong></p><p class="source-code"><strong class="bold">               include('book_management.urls')),\</strong></p><p class="source-code">               ….]</p></li>
				<li>Now, start your development server by running the following command:<p class="source-code">python manage.py runserver localhost:8080</p><p>Then, visit <strong class="source-inline">http://localhost:8080/book_management/new_book_record</strong> (or <strong class="source-inline">127.0.0.1 </strong>instead of <strong class="source-inline">localhost</strong>.)</p><p>If everything works fine, you will see a page as shown here:</p><div id="_idContainer367" class="IMG---Figure"><img src="image/B15509_11_04.jpg" alt="Figure 11.4: View for adding a new book to the database"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.4: View for adding a new book to the database</p>
			<p>Upon clicking <strong class="source-inline">Save record</strong>, your record will be written to the database and the following page will show up:</p>
			<div>
				<div id="_idContainer368" class="IMG---Figure">
					<img src="image/B15509_11_05.jpg" alt="Figure 11.5: Template rendered when the record is successfully inserted"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5: Template rendered when the record is successfully inserted</p>
			<p>With this, we have created our own CBV, which allows us to save records for new books. With our knowledge of CBVs in tow, let's now take a look at how we can perform Create, Read, Update, Delete (CRUD) operations with the help of CBVs.</p>
			<h2 id="_idParaDest-331"><a id="_idTextAnchor346"/>CRUD Operations with CBVs</h2>
			<p>While working with Django models, one of the most common patterns we run into involves the creation, reading, updating, and deletion of objects that are stored inside our database. The Django admin interface allows us to achieve these CRUD operations easily, but what if we wanted to build custom views to give us the same capability?</p>
			<p>As it turns out, Django's CBVs allow us to achieve this quite easily. All we need to do is to write our custom CBVs and inherit from the built-in base classes provided by Django. Building on our existing example of book record management, let's see how we can build CRUD-based views in Django.</p>
			<h3 id="_idParaDest-332"><a id="_idTextAnchor347"/>Create View</h3>
			<p>To build a view that helps in object creation, we'll need to open the <strong class="source-inline">view.py</strong> file under the <strong class="source-inline">book_management</strong> directory and add the following lines of code to it:</p>
			<p class="source-code">from django.views.generic.edit import CreateView</p>
			<p class="source-code">from .models import Book</p>
			<p class="source-code">class BookCreateView(CreateView):</p>
			<p class="source-code">model = Book</p>
			<p class="source-code">    fields = ['name', 'author']</p>
			<p class="source-code">    template_name = 'book_form.html'</p>
			<p class="source-code">    success_url = '/book_management/entry_success'</p>
			<p>With this, we have created our <strong class="source-inline">CreateView</strong> for the book resource. Before we can use it, we will need to map it to a URL. To do this, we can open the <strong class="source-inline">urls.py</strong> file under the book_management directory and add the following entry under the <strong class="source-inline">urlpatterns</strong> list:</p>
			<p class="source-code">urlpatterns = [….,\</p>
			<p class="source-code">               path('book_record_create'),\</p>
			<p class="source-code">                    (BookCreateView.as_view(), name='book_create')]</p>
			<p>Now, when we visit <strong class="source-inline">http://127.0.0.1:8000/book_management/book_record_create</strong>, we will be greeted with the following page:</p>
			<div>
				<div id="_idContainer369" class="IMG---Figure">
					<img src="image/B15509_11_06.jpg" alt="Figure 11.6: A view to insert a new book record based on Create view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6: A view to insert a new book record based on Create view</p>
			<p>This looks similar to the one that we got when using the Form view. On filling in the data and clicking <strong class="source-inline">Save record</strong>, Django will save the data to the database.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor348"/>Update View</h2>
			<p>In this view, we want to update the data for a given record. To do this, we would need to open the <strong class="source-inline">view.py</strong> file under the <strong class="source-inline">book_management</strong> directory and add the following lines of code to it:</p>
			<p class="source-code">from django.views.generic.edit import UpdateView</p>
			<p class="source-code">from .models import Book</p>
			<p class="source-code">class BookUpdateView(UpdateView):</p>
			<p class="source-code">    model = Book</p>
			<p class="source-code">    fields = ['name', 'author']</p>
			<p class="source-code">    template_name = 'book_form.html'</p>
			<p class="source-code">    success_url = '/book_management/entry_success'</p>
			<p>In the preceding code snippet, we have used the built-in <strong class="source-inline">UpdateView</strong> template, which allows us to update the stored records. The fields attribute here should take in the name of the fields that we would like to allow the user to update.</p>
			<p>Once the view is created, the next step is to add the URL mapping. To do this, we can open the <strong class="source-inline">urls.py</strong> file under the <strong class="source-inline">book_management</strong> directory and add the following lines of code:</p>
			<p class="source-code">urlpatterns = [path('book_record_update/&lt;int:pk&gt;'),\</p>
			<p class="source-code">                   (BookUpdateView.as_view(), name='book_update')]</p>
			<p>In this example, we have appended <strong class="source-inline">&lt;int:pk&gt;</strong> to the URL field. This signifies the field input we are going to have to retrieve the record for. Inside Django models, Django inserts a primary key of the integer type, which is used to uniquely identify the records. Inside the URL mapping, this is the field that we have been asking to insert.</p>
			<p>Now, when we try to open <strong class="source-inline">http://127.0.0.1:8000/book_management/book_record_update/1</strong>, it should show us a record of the first record that we inserted into our database and allow us to edit it:</p>
			<div>
				<div id="_idContainer370" class="IMG---Figure">
					<img src="image/B15509_11_07.jpg" alt="Figure 11.7: View displaying the book record update template based on the Update view"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7: View displaying the book record update template based on the Update view</p>
			<h3 id="_idParaDest-334"><a id="_idTextAnchor349"/>Delete View</h3>
			<p>Delete view, as the name suggests, is a view that deletes the record from our database. To implement such a view for our <strong class="source-inline">Book</strong> model, you will need to open the <strong class="source-inline">views.py</strong> file under the <strong class="source-inline">book_management</strong> directory and add the following code snippet to it:</p>
			<p class="source-code">from django.views.generic.edit import DeleteView</p>
			<p class="source-code">from .models import Book</p>
			<p class="source-code">class BookDeleteView(DeleteView):</p>
			<p class="source-code">    model = Book</p>
			<p class="source-code">    template_name = 'book_delete_form.html'</p>
			<p class="source-code">    success_url = '/book_management/delete_success</p>
			<p>With this, we have just created a Delete view for our book records. As we can see, this view uses a different template where all we would like to confirm from the user is, do they really want to delete the record or not? To achieve this, you can create a new template file, <strong class="source-inline">book_delete_form.html</strong>, and add the following code to it:</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">  &lt;head&gt;</p>
			<p class="source-code">    &lt;title&gt;Delete Book Record&lt;/title&gt;</p>
			<p class="source-code">  &lt;/head&gt;</p>
			<p class="source-code">  &lt;body&gt;</p>
			<p class="source-code">    &lt;p&gt;Delete Book Record&lt;/p&gt;</p>
			<p class="source-code">    &lt;form method="POST"&gt;</p>
			<p class="source-code">      {% csrf_token %}</p>
			<p class="source-code">      Do you want to delete the book record?</p>
			<p class="source-code">      &lt;input type="submit" value="Delete record" /&gt;</p>
			<p class="source-code">    &lt;/form&gt;</p>
			<p class="source-code">  &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Then we can add a mapping for our Delete view by modifying the <strong class="source-inline">urlpatterns</strong> list inside the <strong class="source-inline">urls.py</strong> file under the <strong class="source-inline">book_management</strong> directory as follows:</p>
			<p class="source-code">urlpatterns = [….,\</p>
			<p class="source-code">               path('book_record_delete/&lt;int:pk&gt;'),\</p>
			<p class="source-code">               (BookDeleteView.as_view(), name='book_delete')]</p>
			<p>Now, when visiting <strong class="source-inline">http://127.0.0.1:8000/book_management/book_record_delete/1</strong>, we should be greeted with the following page:</p>
			<div>
				<div id="_idContainer371" class="IMG---Figure">
					<img src="image/B15509_11_08.jpg" alt="Figure 11.8: Delete Book Record view based on the Delete view class"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8: Delete Book Record view based on the Delete view class</p>
			<p>Upon clicking the <strong class="source-inline">Delete record</strong> button, the record will be deleted from the database and the Deletion success page will be rendered.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor350"/>Read View</h2>
			<p>In this view, we would like to see a list of records that our database stores for the books. To achieve this, we are going to build a view named <strong class="source-inline">DetailView</strong>, which will render details about the book we are requesting. To build this view, we can add the following lines of code to our <strong class="source-inline">views.py</strong> file under the <strong class="source-inline">book_management</strong> directory:</p>
			<p class="source-code">from django.views.generic import DetailView</p>
			<p class="source-code">class BookRecordDetailView(DetailView):</p>
			<p class="source-code">    model = Book</p>
			<p class="source-code">    template_name = 'book_detail.html'</p>
			<p>In the preceding code snippet, we are creating <strong class="source-inline">DetailView</strong>, which will help us to render the details about the book ID we are asking for. The Detail view internally queries our database model with the book ID we provide to it and, if a record is found, renders the template with the data stored inside the record by passing it as an object variable inside the template context.</p>
			<p>Once this is done, the next step is to create the template for our book details. For this we'll need to create a new template file named <strong class="source-inline">book_detail.html</strong> under our <strong class="source-inline">templates</strong> directory inside the <strong class="source-inline">book_management</strong> application with the following contents:</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">  &lt;head&gt;</p>
			<p class="source-code">    &lt;title&gt;Book List&lt;/title&gt;</p>
			<p class="source-code">  &lt;/head&gt;</p>
			<p class="source-code">  &lt;body&gt;</p>
			<p class="source-code">    &lt;span&gt;Book Name: {{ object.name }}&lt;/span&gt;&lt;br /&gt;</p>
			<p class="source-code">    &lt;span&gt;Author: {{ object.author }}&lt;/span&gt;</p>
			<p class="source-code">  &lt;/body&gt;</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>Now, with the template created, the last thing we need to do is to add a URL mapping for the Detail view. This can be done by appending the following to the <strong class="source-inline">urlpatterns</strong> list under the <strong class="source-inline">urls.py</strong> file of the <strong class="source-inline">book_management</strong> application:</p>
			<p class="source-code">path('book_record_detail/&lt;int:pk&gt;'),\</p>
			<p class="source-code">     (BookRecordDetail.as_view(), name='book_detail')</p>
			<p>Now, with all of this configured, if we now go and open <strong class="source-inline">http://127.0.0.1:8000/book_management/book_record_detail/1</strong>, we will get to see the details pertaining to our book, as shown here:</p>
			<div>
				<div id="_idContainer372" class="IMG---Figure">
					<img src="image/B15509_11_09.jpg" alt="Figure 11.9: View rendered when we try to access a previously stored book record"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9: View rendered when we try to access a previously stored book record</p>
			<p>With the preceding examples, we just enabled CRUD operations for our <strong class="source-inline">Book</strong> model, and all of that while using CBVs.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor351"/>Activity 11.01: Rendering Details on the User Profile Page Using Inclusion Tags</h2>
			<p>In this activity, you will create a custom inclusion tag that helps to develop a user profile page that renders not only the users' details but also lists the books they have read. </p>
			<p>The following steps should help you to complete this activity successfully:</p>
			<ol>
				<li value="1">Create a new <strong class="source-inline">templatetags</strong> directory under the <strong class="source-inline">reviews</strong> application inside the <strong class="source-inline">bookr</strong> project to provide a place where you can create your custom template tags.</li>
				<li>Create a new file named <strong class="source-inline">profile_tags.py</strong>, which will store the code for your inclusion tag.</li>
				<li>Inside the <strong class="source-inline">profile_tags.py</strong> file, import Django's template library and use it to initialize an instance of the template library class.</li>
				<li>Import the <strong class="source-inline">Review</strong> model from the reviews application to fetch the reviews written by a user. This will be used to filter the reviews for the current user to render on the user profile page.</li>
				<li>Next, create a new Python function named <strong class="source-inline">book_list</strong>, which will contain the logic for your inclusion tag. This function should only take a single parameter, the username of the currently logged-in user.</li>
				<li>Inside the body of the <strong class="source-inline">book_list</strong> function, add the logic for fetching the reviews for this user and extract the name of the books this user has read. Assume that a user has read all those books for which they have provided a review.</li>
				<li>Decorate this <strong class="source-inline">book_list</strong> function with the <strong class="source-inline">inclusion_tag</strong> decorator and provide it with a template name <strong class="source-inline">book_list.html</strong>.</li>
				<li>Create a new template file named <strong class="source-inline">book_list.html</strong>, which was specified to the inclusion tag decorator in <em class="italic">step 7</em>. Inside this file, add code to render a list of books. This can be done by using a <strong class="source-inline">for</strong> loop construct and rendering HTML list tags for every item inside the list provided.</li>
				<li>Modify the existing <strong class="source-inline">profile.html</strong> file under the <strong class="source-inline">templates</strong> directory, which will be used to render the user profile. Inside this template file, include the custom template tag and use it to render the list of books read by the user.<p>Once you implement all the aforementioned steps, starting the application server and visiting the user profile page should render a page that is similar to the one shown in <em class="italic">Figure 11.10</em>:</p><div id="_idContainer373" class="IMG---Figure"><img src="image/B15509_11_10.jpg" alt="Figure 11.10: User profile page with the list of books read by the user"/></div></li>
			</ol>
			<p class="figure-caption">Figure 11.10: User profile page with the list of books read by the user</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor352"/>Summary</h1>
			<p>In this chapter, we learned about the advanced templating concepts in Django and understood how we can create custom template tags and filters to fit a myriad of use cases and support the reusability of components across the application. We then looked at how Django provides us with the flexibility to implement FBVs and CBVs to render our responses.</p>
			<p>While exploring CBVs, we learned how they can help us avoid code duplication and how we can leverage the built-in CBVs to render forms that save data, help us update existing records, and implement CRUD operations on our database resources.</p>
			<p>As we move to the next chapter, we will now utilize our knowledge of building CBVs to work on implementing REST APIs in Django. This will allow us to perform well-defined HTTP operations on our data inside our Bookr application without maintaining any state inside the application.</p>
		</div>
	</body></html>