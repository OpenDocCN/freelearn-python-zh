- en: Introduction to Python and Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand the process of creating a **graphical user interface** (**GUI**)
    with Python and Qt, we need to know the basic syntax and structure of the language
    and framework. This chapter will cover the basics of the Python programming language—the
    most common methods and operations that will be used for GUI creation, and the
    basic C++ syntax that is used by the Qt library. In addition, there will be an
    introduction to the Qt framework. Without an explanation of this, developers may
    encounter some problems in the early stages of the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the Qt framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a programming language that is implemented as a high-level interpreter.
    It's easy to learn, with proficient high-level data structures, and is simple,
    with a productive approach to object-oriented programming. It has elegant syntax,
    with dynamic typing and an interpreted nature, as described in the official source.
    It is the best language for scripting and rapid application development. We can
    effortlessly extend the Python interpreter using new functions and data types
    implemented in C or C++ (or other languages that are callable from C). With this
    in mind, the creation of a GUI with the Qt library and Python is a good option. To
    start using Python, you need to download the Python interpreter from the official
    source (if it is not already installed) and install it by following the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to install PyQt and PySide, you need to run the following commands in
    the Linux/Unix Terminal or Windows command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can download and install the PySide2 binding from the Qt official source
    by following the instructions, or you can install it from **PyPI** (**Python Package
    Index**) through `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: During this book, `>` will be used when you need to run a command from the Terminal/Command
    Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to program and to create GUIs using Python is to use the Anaconda
    toolkit, which is the best Python-based programming ecosystem. Installing Anaconda
    is highly recommended. When you install Python, you get IDLE, which is a simple
    editor. Anaconda has the Spyder editor by default, which is superior to IDLE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the IDLE editor, just type the following command in your Terminal/Command
    Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to open Anaconda''s Spyder editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once Anaconda is installed, you can also find it in the OS's start menu.
  prefs: []
  type: TYPE_NORMAL
- en: Python syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a short introduction to Python. Here, you will find the most useful
    and popular definitions and operations that will be used throughout this book.
    For complete information about the Python programming language, you need to look
    at the official documentation ([https://docs.python.org/3/](https://docs.python.org/3/)).
    Let''s focus our attention on the most common things that appear in a Python development
    process. To start, open a Terminal/Command Prompt and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, type `idle` in Command Prompt/Terminal. Either commands will
    run the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Variables and values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The fundamentals of any programming language, not just in Python and perhaps
    not just in programming either, are the definitions and rules of variables and
    values. Variables and values are elements that describe an object in the world
    and the relations among them. The concept of variables and values is commonly
    used in a form such as—some values have some relation to the variable depending
    on the operator used. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, `name` and `number` are variables. Similarly, `"Name"` and `1` are the
    values of these variables. In the Python programming language, the variables have
    rules of definition. They must be defined before use, and they cannot be numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following definition is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, variables cannot begin with a number. This definition is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Variable names cannot have spaces. It is also undesirable to use the names of
    built-in functions in the standard Python library or any imported and defined
    names in the Python module as variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following definition is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also, any other names of imported modules, functions, and classes should be
    avoided, because using them can lead to an unexpected result. You cannot use Python
    keyword names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following definition is incorrect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A complete list of keywords, built-in functions, and constants is available
    in the Python documentation. Values must be Python data types, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings**: `str(1)`, `"string"`, `''string''`, and `"""documented_string"""`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boolean** **values:** `True` or `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numbers:** `int(1.1)`, `float(1)`, `complex(1)`, and `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binary** **data:** `bytes("string", encoding=''utf-8'')` immutable and `bytearray("string",
    encoding=''utf-8'')` mutable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuples:** `(1, "string")` and `tuple("string")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lists:** `[1, "string"]` and `list("string")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dictionaries:** `{"key1": 1, "key2": "value"}` and `dict(key1=1, key2="value")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sets** **of unique elements:** `set("string")` and `frozenset("string")` immutable sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functions:** `def func():pass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Classes:** `class C:pass`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules:** Files with extensions such as `file_name.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NoneType** **objects****: **`None`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When they are created, strings need to use quotes, `''some text''`, double
    quotes `"some text"`, or documented strings `"""some text"""`. Strings in Python
    are interpreted as a sequence of characters and can be used for the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Slicing—the result is a string, starting from `0` to the 2 character. The first
    character is `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Reversed slicing—the result is a string, starting from the specified index
    of the character in the string to the 0 character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenation—the result is a merged string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplication—the `"string"` result is multiplied by the second value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Splitting—the result is a list split by a separator, such as a space or a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacing—the result is a string with new characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The most useful string methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversion integer to the string, the result of which is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Length of the string—the result is an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Encoding with UTF—the result is an encoded binary object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Decoding with UTF—the result is a decoded string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Very often, we have to work with strings and solve problems with different encoding
    that is required to understand the manipulation of different texts in the application.
    This is just a short description of strings; it is recommended that you study
    strings in detail in the Python documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python provides logical constants, such as `True` and `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a definition of the `var` variable with a value equal to `True`, and
    when we call the `var` variable, the result is a Boolean value, which is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the `var` variable with a `False` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `bool` function from the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The final logical operations return `True` if the variable exists, or if its
    value is equal to `1`. If it doesn't exist or is equal to `0`, then it returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Python interpreter can be used as a simple calculator, and provides some
    useful tools for working with numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code defines the `num` variable, with a value equal to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When we perform operations with numbers using the division operator (`/`),
    the result in Python 2.x is an integer, whereas in Python 3.x it''s a float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When we perform operations with numbers using the floor division operator (`//`),
    the result in Python 2.x is an integer, and with Python 3.x it''s an integer also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, and throughout the book, we will try to clarify the differences between
    the major versions of Python with examples. As we can see, Python 2.x returns
    an `int()` value with classic division, and Python 3.x returns a `float()` value.
    With floor division, all versions return an `int()` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outcome of the following operation is an integer (remainder of the division):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some operations with numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When converting the string value to the integer, the result is an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`int` to `float`—the result is a `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Complex number—the result is a number with a real number and an imaginary part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Binary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start working with images, videos, photos, and other graphical objects,
    we need to understand that this data is binary, and the most useful tools for
    this are `bytes()` and `bytearray()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert a string to a binary object; the result is a binary object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert a string to a bytearray; the result is a bytearray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the binary array (this operation is available only with `bytearray()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tuples are an immutable sequence of elements in Python. Elements can be strings,
    numbers, or other Python data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create and call the following tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A tuple is a sequence of elements separated by commas, and, hence, defining
    a tuple in the form `("string")` is incorrect. If the tuple consists of only one
    element, it needs a comma, for example, `("string",)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuple slices—all elements of the tuple `tu[0:]`, the last element, element
    with index `[2]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the amount of specified elements present in the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the index of the specified element that is present in the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most useful tool for data processing is the list. Let''s look at some methods
    and operations involving lists:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a list. The result is a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns all elements of the list. The result is a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the first element of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the last element of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a list with the last object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the first character of the second item of the list. The item must
    be in sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is incorrect. Integer objects are not subscriptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a list of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Define a list with name `var` and then define a new list with `var` list inside
    this list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet shows how to change the first and second elements
    of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists can be concatenated in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This is list multiplication. The list must be multiplied by a number (integer)
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The most popular operations with lists are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a new item is added to the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how a new item is inserted at the `0` position of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether an item is in the list, the `in` operator could be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This finds the element index and returns the index of the first element with
    a specified value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This removes the element with the specified index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This removes the element with the specified value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Python provides list generators that work faster than other list creation mechanisms,
    such as the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lists can be generated in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Join the list to the string with a specified separator. The list items must
    be strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to create data in Python is with a dictionary. In reality, a dictionary
    is not a sequence; it is a mapping of data, and, because of this, operations that
    are available for tuples and lists are not applicable to the dictionary. Commonly
    used methods and operations involving dictionaries are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary implies the presence of a key and value, and each key/value pair needs
    to be separated with a comma in the dictionary, for example, {key: value, key:
    value, ...}.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This gets the dictionary value by the key. The result is the value of the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The most useful operations with dictionaries are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gets the dictionary value by the key, and we just get the value for the
    key that exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets all the keys of the dictionary. The result is a `dict_keys` object
    with keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets all the values of the dictionary, and the result is a `dict_values`
    object with values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets all the keys and values of the dictionary in tuple form, and the
    result is `dict_items`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds a new item to the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This deletes the value with the specified key of the dictionary. The result
    is the deleted value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key does not exist, then the second value is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This clears the dictionary. The result is an empty dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also, in some cases, we can use sets. The set is a complex (or group) of unique
    elements that can be used with data creation. Sets in Python can be created in
    the following way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a set from the elements of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Sets are mutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a set as `se`, and change the set by adding a new element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: To create an immutable set, we need to use `frozenset()` from the Python standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can treat functions as the result of complex variables and their related
    operations. A function in Python can receive parameters, return a result, and/or
    provide some actions with variables and values. To build functions in Python,
    use the following approach to function definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the function—`param` is a parameter of the function that is set as `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code increments the parameter and returns, and then calls the
    function with the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern styles of application creation follow the **object-oriented programming**
    (**OOP**) approach, so it is mandatory to use and understand classes. The easiest
    way to create a class using Python is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__()` method is a constructor of the class, `self.var` is an attribute
    of the class, `self.func()` calls the function, and `def func1(self)` and `def
    func2(self)` are methods of the class. The first `print()` function is used with
    Python 3.x, and the second, commented `print` function is used with Python 2.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates an instance of the class, and calls `func2()` of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, classes allow us to build code with broad functionality. By means
    of the `self` argument, we can use our variables at any place in the class, making
    use of the dynamic nature of Python. In addition, classes provide fundamental
    methods, such as inheritance, that make classes the basis of OOP, which we will
    discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on from Command Prompt/Terminal typing and try to create a standard
    Python module that will demonstrate the standard syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Python module, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your favorite editor, such as Notepad, PyCharm, Eclipse, or Emacs. Anaconda
    has a preinstalled Python editor called Spyder, which we mentioned in the *Basics
    of Python* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new directory called `App/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file with the future name of our GUI application, such as `u_app.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch our attention to this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Python module is a file containing Python definitions and instructions that
    has the `.py` extension. There are also other extensions, such as `.pyc`, `.pyw`,
    and `.pyd`, which will be explained later on in the book. One of the differences
    between a simple file and a module in Python is that a module has the ability
    to import definitions from one module into another. To demonstrate this, let's
    create another new file in the `App/` directory, named `u_tools.py`.
  prefs: []
  type: TYPE_NORMAL
- en: According to the generally accepted Python coding rules, described in the **Python
    Enhancement Proposals** (**PEP8**) Python language style guide, modules should
    have short, lowercase names such as `u_app.py`. Classes should be in upper camel
    case, such as `UTool():`. For functions, lowercase is preferred, such as `def
    func():;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that the files have been created, incorporate the following lines in
    the `u_app.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the import section, import the `UTools` class from the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Create the `UApp` class that inherits `UTools`**:**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In the `__init__()` constructor, call the `UTools` class constructor and attribute
    as a string variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `u_app1()` function to the `UApp` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This function will concatenate the strings from the `UApp` and `UTools` classes
    and print the results. The commented `print` function is used in Python 2.x and
    can be used if you uncomment it and then comment the previous line, with the `print()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `u_app2()` function to the `UApp` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This function creates a new list; the `for` statement is a loop for the list
    from the `UTools` class, and it checks whether it is a digit or a letter. If it
    is not equal to `"."`, it sets all letters to lowercase. Then, join the list to
    the string and print.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This instruction is used to define how the code will be running in this file.
    If this module is imported, `__name__` will not be `"__main__"`, and we can use
    the parts of this module in another place. If this module is run as a file (from
    the terminal, as a subprocess), `__name__` will be `"__main__"` and the class
    instance will be created with a call of the first and second functions. So, now
    we need to add the `UTools` class to the `u_tools.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `u_tools.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In this module, the `UTools` class has been created with a string variable in
    the `__init__()` method. The `u_list()` function converts a string to a list.
    The code matches the PEP8 style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at some Python syntax. It is recommended to add two
    blank lines, one before the definition of the class, and one before the function
    within the class. Along with this, it is recommended to add two blank lines between
    function definitions if you are not using classes. The Python interpreter executes
    a script as a block. The block of code starts with four spaces fewer than the
    previous line. The interpreter can decide that this is the end of the block, when
    the spaces before the next block are smaller than the previous ones, by four spaces.
    As you can see, `#` marks a comment on the line, and the comment text is ignored
    by the interpreter. The definitions of classes, functions, and statements are
    implemented using `:`. The ends of lines are marked with `;`, and the execution
    of several commands on one line is possible, but not recommended. It is preferable
    to write each line of the script on a new line, for ease of comprehension. So,
    we can read these two files and try to start them. To do this, we need to open
    the Terminal/Command Prompt and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23f40b69-af2a-4bd7-af27-cf4a44d65855.png)'
  prefs: []
  type: TYPE_IMG
- en: If you can see a similar result, then everything is correct. And what does Python
    do when running this file?
  prefs: []
  type: TYPE_NORMAL
- en: Python interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Global Interpreter Lock** (**GIL**) is a mechanism that's used by the
    interpreter to ensure that only one thread executes Python bytecode at a time. Locking
    the interpreter to one real-time thread helps the interpreter to be multithreaded,
    to the side of parallelism of the multiprocessor machines. The GIL is always released
    when performing I/O operations. The Python interpreter is a program that translates
    and launches other programs that contain instructions.
  prefs: []
  type: TYPE_NORMAL
- en: It is sometimes called the **Python Virtual Machine** (**PVM**), along the lines
    of the **Java Virtual Machine** (**JVM**), and it provides procedures to translate
    code to bytecode and execute the next step, in contrast to languages such as C++
    that translate code into instructions that run directly on hardware. It is important
    to understand languages such as Python and Java, which constitute a forward step
    in the advancement of programming technology.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how the Python interpreter runs code lines. First, it starts to execute
    the code line by line, from top to bottom. Python 3.x compiles the import modules
    in the `_pycache_` directory where the file is located, and adds the `.pyc` extension
    to the compiled files. Then, the PVM will translate the instructions into bytecode
    and execute them.
  prefs: []
  type: TYPE_NORMAL
- en: Qt framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is a cross-platform application framework and widget toolkit for creating
    GUI applications that run on all major desktop, mobile, and embedded platforms.
    Most GUI programs developed with Qt have a native-looking interface. In such cases,
    Qt is classified as a widget toolkit. To use Qt as a development framework, you
    need to download Qt from the official source ([https://www.qt.io/](https://www.qt.io/))
    and then install it on your device. Qt supports compilers such as the GCC C++
    compiler and the Visual Studio suite. Qt provides powerful IDEs and tools such
    as Qt Creator, Qt Designer, Qt Assistant, and Qt Linguist. To create a GUI with
    Qt, simply open Qt Creator, and welcome to creating graphics applications! However,
    this book will not describe how to create a GUI with an IDE such as Qt Creator
    or Qt Designer. This book is primarily concerned with creating GUIs with Qt and
    Python. But if you want to start with Qt Creator, then you are welcome to move
    ahead. Because Qt is basically a C++ library, we first need to understand the
    basic methods and syntax of C++.
  prefs: []
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have probably guessed from the name, C++ is a C-based language and has
    a similar syntax. We can assume that Python is also related to C, but do not confuse
    these languages. If C++ is a C-callable language and has similar syntax, we can
    call the Python interpreter a C-based, low-level virtual machine, as we discussed
    earlier. Python syntax and C syntax are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we need to create a file named `cpp_file1.cpp` in the
    `App/` directory, created for application development, and add the following lines
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Lines with # are directives that are read and interpreted, known as the preprocessor.
    Then, there is the declaration of a function in C++, `main()`. Everything inside
    braces ({}) is a body function. To get the result of this code, you need to install
    a C ++ compiler. IDEs such as DEV-C++, Code::blocks, and Visual Studio Express
    allow us to compile the code. If you''re a Linux/Mac user, the C++ compiler can
    be installed on your system (such as GCC or Clang) and you can compile this code
    using a Terminal. After downloading and installing the C++ compiler, you need
    to compile this code according to the compiler''s features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, a file such as `cpp_file1.exe` will be compiled, and then you
    need to type the following in the Terminal/Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the result of the program in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae613d36-dcbe-4759-a343-753585cd70eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's describe some C++ syntax that can be found as we advance with our learning
    of the Qt library.
  prefs: []
  type: TYPE_NORMAL
- en: C++ operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following operators are available in C ++:'
  prefs: []
  type: TYPE_NORMAL
- en: '`::`: Scope qualifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`++ --`: Postfix increment/decrement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()`: Functional forms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[]`: Subscript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`. ->`: Member access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`++ --`: Prefix increment/decrement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`~ !` : Bitwise NOT/logical NOT'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+ -`: Unary prefix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`& *`: Reference/dereference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new delete`: Allocation/deallocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizeof`: Parameter pack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(type)`: C-style type casting`.* ->*`: Access pointer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`* / %`: Multiply, divide, and modulo'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+ -`:Addition and subtraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<< >>`: Shift left and shift right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`< > <= >=`: Comparison operators'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`== !=`: Equality/inequality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`& ^ | && ||`: Bitwise AND, bitwise XOR, bitwise OR, logical AND, and logical
    OR'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`= *= /= %= += -= >>= <<= &= ^= |=`: Assignment/compound assignment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?:`: Conditional operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`,`: Comma separator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ syntax requires every variable to be declared with its type before being
    used for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `cpp_file2.cpp` file in the `App/` folder with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This code declares the `a` variable as an `int` type and with a value of `7`,
    and then declares the `b` variable as a `float` type. It declares the `result` variable as
    a `float` type. Then, it adds the variables. The result goes to the Terminal/cmd. Compile
    and run the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/515c7a94-8d84-4f3c-a8cd-5003726daa3f.png)'
  prefs: []
  type: TYPE_IMG
- en: Create the `cpp_file3.cpp`file in the `App/` folder with the following lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `cpp_file3.cpp` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This code begins by defining an array and constructing an `if` statement. It
    prints the result if true, with a new line. The `for` statement is constructed,
    along with the **`if else`** statement. Then, break the loop and compile and run
    `cpp_file3.exe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61930752-b066-4f0d-bab8-666a112faaf7.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's  have a look at the C++ functions.
  prefs: []
  type: TYPE_NORMAL
- en: C++ functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions in C ++ have the syntax `type name ( parameters ) { statements }`,where
    `type` is the type of value returned by the function, `name` is the identifier
    of the function, `parameters` are the parameters of the function, such as `int
    x` and `int y`, and finally `statements` are the function's body, which is a block
    of statements that specify what the function actually does. In C++, variables
    can be accessed inside the namespace where they are declared, but if they are
    accessed from outside, they have to be properly qualified with `::`—the scope
    operator. Create the `cpp_file4.cpp`file in the `App/` folder with the following
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `cpp_file4.cpp` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables, types, constants, and functions of the standard C++ library are
    declared within the `std` namespace. Compile and run it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52497f3f-01a4-4f05-b1ac-dd8c8145ec92.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's have a look at the functions without any type.
  prefs: []
  type: TYPE_NORMAL
- en: Functions with no type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating functions in C++, you need to declare the type of the value returned
    by the function. If the function does not need to return a value, `void` is used,
    which is a special type used to represent the absence of a value. Create the `cpp_file5.cpp` file in
    the `App/` folder with the following lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the `cpp_file5.cpp` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: It defines a `void` type of function and prints the result when the function
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile and run it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f619584f-6309-4b3d-9f3c-ba63826d119f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's move on to the C++ classes.
  prefs: []
  type: TYPE_NORMAL
- en: C++ classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the end of this short demonstration of C ++ syntax, let''s describe the
    classes. Here''s an example of a class with an inheritance construction in the
    `cpp_file6.cpp` file. Create this in the `App/` folder with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a83c1b57-9b87-44ba-9243-3e4c38473a2f.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have a result like this, everything is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have briefly described the basics of C++ syntax. Now, let's take a look at
    the structure of Qt. The currently supported versions of Qt are 5.6-5.13. Versions
    such as 4.x or below have some differences, but these differences are not fundamental,
    and code written with versions lower than 5 can be easily transformed. This book
    will consider versions 5.9-5.13 of Qt and, where possible, other versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As described previously, Qt is a powerful framework that supports Windows 10/8/7,
    most of Linux/X11-RHEL6/7, Ubuntu, openSUSE, Android, macOS, and iOS. When it''s
    downloaded and installed, the Qt framework provides tools such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Qt Creator**: This is an IDE, and it consists of the following integrated
    tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Designer:** This is for designing and building GUIs from Qt widgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**qmake:** This is for building applications for different platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Linguist:** This comprises localization tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Assistant:** This is the Qt documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Qt framework also provides the following integrated instruments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**makeqpf**: This is for creating pre-rendered fonts for embedded devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meta-Object Compiler** (**moc**): This is for generating meta-object information
    for QObject subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Interface Compiler** (**uic**): This is for generating C++ code from
    UI files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Compiler** (**rcc**): This is for embedding resources into Qt applications
    during the build process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt D-Bus XML compiler** (**qdbusxml2cpp**): This converts D-Bus interface
    descriptions to C++ source code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D-Bus Viewer**: This is for inspecting D-Bus objects and messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick Compiler**: This is a compiler for **Qt Modeling Language** (**QML**),
    which builds Qt Quick applications without the deployment of QML sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt VS Tools**: This is for creating Qt applications using the Visual Studio
    IDE instead of Qt Creator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt 5 provides the following modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Qt Core**: This contains core non-graphical classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt GUI**: This contains classes for GUI components, including OpenGL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Multimedia**: This contains classes for audio, video, radio, and camera
    functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Multimedia Widgets**: This provides multimedia functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Network**: This is for networking support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt QML**: This contains classes for QML and JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick**: This is a framework for building highly dynamic applications.**Qt
    Quick Controls**: This contains UI controls that you can use to create classic
    desktop-style UIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick Dialogs**: This is for making system dialogs from a Qt Quick application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick Layouts**: This is for making layouts for Qt Quick-based items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt SQL**: This is used for SQL database integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Test**: This contains testing libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Widgets**: This is for making Qt GUIs with C++ widgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, it provides add-ons that are relevant for different platforms and/or
    under commercial license:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ActiveQt**: ActiveX and COM (Windows).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt 3D**: Two-dimensional and three-dimensional rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Android Extras**: Platform-specific APIs for Android.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Bluetooth**: Access to the Bluetooth hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Canvas 3D**: OpenGL-like 3D drawing calls from Qt Quick.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Concurrent**: Multithreaded programs without using low-level threading
    primitives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt D-Bus**: Inter-process communication over the D-Bus protocol..'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Gamepad**: Gamepad hardware Qt applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Graphical Effects**: Graphical effects for Qt Quick 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Location API**: Maps, navigation, and place content in a QML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Mac Extras**: Platform-specific APIs for macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt NFC**: Access to **near-field communication** (**NFC**) hardware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Platform Headers**: Encapsulation of the platform-specific information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Positioning API**: Position, satellite, and area monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt PrintSupport**: Printing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Purchasing**: In-app purchase of products in Qt applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick Controls 2**: Embedded and mobile devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Quick Extras**: Set of controls to build interfaces in Qt Quick.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt SCXML:** Creating state machines from **State Chart XML** (**SCXML**)
    files and embedding them in applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Sensors API**: Sensor hardware and motion gesture recognition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Serial Bus API**: Access to the serial industrial bus interface (Linux).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Serial Port**: Access to hardware and virtual serial ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt SVG**: Displaying the contents of SVG files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt WebChannel**: Access to QObject or QML objects from HTML clients for the
    integration of Qt applications with HTML/JavaScript clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt WebEngine**: Embedding web content using the Chromium browser project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt WebSockets**: WebSocket communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt WebView**: Displays web content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Win Extras**: Platform-specific APIs for Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt XML**: C++ implementations of the **Simple API for XML** (**SAX**) and
    the **Document Object Model** (**DOM**) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt XML Patterns**: XPath, XQuery, XSLT, and XML schema validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt Wayland Compositor**: Framework to develop a Wayland compositor (Linux).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these modules, including C++ classes, QML types (which we will be covering
    in the next chapter), additional packages, and tools, provide a mechanism for
    the application creation process with the Qt framework. In this book, we can't
    describe all the classes of the library in detail. That is impossible, because
    there are more than 1,500 of them. We'll look at the most useful and popular ones
    that a developer will use when they try to create an application with a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The principles described previously are very important for the programming process
    with Qt and Python. We covered the basic syntax and rules of Python, C++, and
    Qt modules, which are the main tools we will use to create a GUI. The official
    Qt documentation usually provides a description of the classes in C++. It is highly
    recommended to read this documentation, both for Qt ([https://doc.qt.io/](https://doc.qt.io/qt-5.9))
    and for C++ ([http://www.cplusplus.com/doc/tutorial/](http://www.cplusplus.com/doc/tutorial/)). Python
    was described very briefly, so it's recommended that you look through the official
    Python documentation ([https://docs.python.org/3/](https://docs.python.org/3/)).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's read some of the official examples and try to understand them. We
    need to find the `QtWidgets` module on the official website. Open and view the
    first few lines of the documentation. Note `#include <QtWidgets>`—this line can
    be represented as `import QtWidgets` in Python code, but when we start using Python,
    we will use a Python binding to Qt or PyQt5 as a package. So, we will need to
    write `from PyQt5 import QtWidgets`. Then, to create a new widget in Python, we
    need to use `widget = QtWidgets.QWidget(parent)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for using layout in the application is `void QWidget::setLayout(QLayout
    *layout)` with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''ve created a new `QVBoxLayout` class, added a widget
    to the layout, and set the layout. This can be implemented using PyQt5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Qt is the largest and most powerful library for creating graphic applications.
    And Python provides the world's largest set of functional tools that can handle
    any modern programming task. Together, they can produce the greatest applications.
    The use of threads, multiprocessing, and asynchronous programming can make the
    application productive and efficient. The paradigm of the Python programming language
    lies in the real-time universe and this is a strong side.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described the basics of the instruments and tools to start
    GUI development. This is the introduction to the first stage of learning about
    development with Python. Of course, this is not enough, but it will help with
    the coming chapters. Python, C++, and Qt are most commonly used when a developer
    wants to create an application with PyQt and PySide. For detailed information
    about the syntax of these languages, it is highly recommended to study the official
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about QML—the powerful markup language for
    the implementation of different features.
  prefs: []
  type: TYPE_NORMAL
