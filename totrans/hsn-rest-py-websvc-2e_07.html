<html><head></head><body><div><h1 class="header-title">Improving Our API and Adding Authentication to it with Django</h1>
                
            
            
                
<p>In this chapter, we will improve the Django RESTful API with a PostgreSQL 10.5 database that we started in the previous chapter. We will use many of the features included in Django REST framework to add new functions to the API and will add authentication-related security to it. We will do the following:</p>
<ul>
<li>Add unique constraints to the models</li>
<li>Update a single field for a resource with the <kbd>PATCH</kbd> method</li>
<li>Take advantage of pagination</li>
<li>Customize pagination classes</li>
<li>Understand authentication, permissions, and throttling</li>
<li>Add security-related data to the models</li>
<li>Create a customized permission class for object-level permissions</li>
<li>Persist the user that makes a request and configure permission policies</li>
<li>Set a default value for a new required field in migrations</li>
<li>Compose requests with the necessary authentication</li>
<li>Browse the API with authentication credentials</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Adding unique constraints to the models</h1>
                
            
            
                
<p>Our API has some important issues that we need to solve quickly. Right now, we can create many ESRB ratings with the same description. We shouldn't be able to do so, and therefore, we will make the necessary changes to the <kbd>EsrbRating</kbd> model to add a unique constraint on the <kbd>description</kbd> field. We will also add a unique constraint on the <kbd>name</kbd> field for the <kbd>Game</kbd> and <kbd>Player</kbd> models. This way, we will learn the necessary steps to make changes to the constraints for many models and reflect the changes in the underlying database schema through migrations.</p>
<p>Make sure you quit the Django development server. Remember that you just need to press <em>Ctrl</em> + <em>C</em> in the Terminal or Command Prompt window in which it is running. ...</p></div>



  
<div><h1 class="header-title">Updating a single field for a resource with the PATCH method</h1>
                
            
            
                
<p>Due to the usage of generic class-based views, our API is able to update a single field for an existing resource, and therefore, we provide an implementation for the <kbd>PATCH</kbd> method. For example, we can use the <kbd>PATCH</kbd> method to update an existing game and set the value for its <kbd>played_once</kbd> and <kbd>played_times</kbd> field to <kbd>True</kbd> and <kbd>1</kbd>. We don't want to use the <kbd>PUT</kbd> method because this method is meant to replace an entire game. Remember that the <kbd>PATCH</kbd> method is meant to apply a delta to an existing game, and therefore, it is the appropriate method to just change the value of the <kbd>played_once</kbd> and <kbd>played_times</kbd> fields.</p>
<p>Now we will compose and send an HTTP <kbd>PATCH</kbd> request to update an existing game, specifically, to update the value of the <kbd>played_once</kbd> and <kbd>played_times</kbd> fields and set them to <kbd>True</kbd> and <kbd>10</kbd>. Make sure you replace <kbd>2</kbd> with <kbd>id</kbd> of an existing game in your configuration. The code file for the sample is included in the <kbd>restful_python_2_07_01</kbd> folder, in the <kbd>Django01/cmd/cmd703.txt</kbd> file:</p>
<pre>    <strong>http PATCH ":8000/games/2/" played_once=true played_times=10</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_07_01</kbd> folder, in the <kbd>Django01/cmd/cmd704.txt</kbd> file:</p>
<pre> <strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"played_once":"true", "played_times": 10}' "localhost:8000/games/2/"</strong>
  </pre>
<p>The previous command will compose and send an HTTP <kbd>PATCH</kbd> request with the specified JSON key-value pairs. The request has a number after <kbd>/games/</kbd>, and therefore, it will match <kbd>'^games/(?P&lt;pk&gt;[0-9]+)/$'</kbd> and run the <kbd>patch</kbd> method for the <kbd>views.GameDetail</kbd> class-based view. Remember that the <kbd>patch</kbd> method is defined in the <kbd>RetrieveUpdateDestroyAPIView</kbd> superclass and it ends up calling the <kbd>update</kbd> method defined in <kbd>mixins.UpdateModelMixin</kbd>. If the <kbd>Game</kbd> instance with the updated values for the <kbd>played_once</kbd> and <kbd>played_times</kbd> fields is valid and it was successfully persisted in the database, the call to the method will return the <kbd>200 OK</kbd> status code and the recently updated <kbd>Game</kbd> serialized to JSON in the response body.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following lines show a sample response:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
    <strong>Content-Length: 204</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Fri, 26 Oct 2018 16:40:51 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "esrb_rating": "AO (Adults Only)",</strong>
    <strong>    "name": "Mutant Football League: Dynasty Edition",</strong>
    <strong>    "played_once": true,</strong>
    <strong>    "played_times": 10,</strong>
    <strong>    "release_date": "2018-10-20T03:02:00.776594Z",</strong>
    <strong>    "url": "http://localhost:8000/games/2/"</strong>
    <strong>}</strong>
  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Taking advantage of pagination</h1>
                
            
            
                
<p>Our database has a few rows for each of the tables that persist the models we have defined. However, after we start working with our API in a real-life production environment, we will have thousands of player scores, players, and games—although the ESRB ratings will still be few in number. We definitely have to prepare our API to deal with large result sets. Luckily, we can take advantage of the pagination features available in Django REST framework to make it easy to specify how we want large result sets to be split into individual pages of data.</p>
<p>First, we will write commands to compose and send HTTP <kbd>POST</kbd> requests to create 10 games that belong to one of the ESRB ratings we have created: <kbd>T (Teen)</kbd>. This way, ...</p></div>



  
<div><h1 class="header-title">Customizing pagination classes</h1>
                
            
            
                
<p>The <kbd>rest_framework.pagination.LimitOffsetPagination</kbd> class that we are using to provide paginated responses declares a <kbd>max_limit</kbd> class attribute that defaults to <kbd>None</kbd>. This attribute allows us to indicate the maximum allowable limit that can be specified by using the <kbd>limit</kbd> query parameter. With the default setting, there is no limit, and we will be able to process requests that specify a value for <kbd>1000000</kbd> for the <kbd>limit</kbd> query parameter.</p>
<p>We definitely don't want our API to be able to generate a response with a million player scores or players with a single request. Unluckily, there is no configuration setting that allows us to change the value that the class assigns to the <kbd>max_limit</kbd> class attribute. Thus, we are forced to create our customized version of the <kbd>limit</kbd>/<kbd>offset</kbd> pagination style provided by Django REST Framework.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Create a new Python file named <kbd>max_limit_pagination.py</kbd> within the <kbd>games_service/games</kbd> folder and enter the following code that declares the new <kbd>MaxLimitPagination</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_07_03</kbd> folder, in the <kbd>Django01/games-service/games/max_limit_pagination.py</kbd> file:</p>
<pre>from rest_framework.pagination import LimitOffsetPagination 
 
class MaxLimitPagination(LimitOffsetPagination): 
    max_limit = 8 </pre>
<p>The previous lines declare the <kbd>MaxLimitPagination</kbd> class as a subclass of the <kbd>rest_framework.pagination.LimitOffsetPagination</kbd> superclass and overrides the value specified for the <kbd>max_limit</kbd> class attribute with <kbd>8</kbd>.</p>
<p>Open the <kbd>settings.py</kbd> file in the <kbd>games_service/games_service</kbd> folder and replace the line that specified the value for the <kbd>DEFAULT_PAGINATION_CLASS</kbd> key in the dictionary named <kbd>REST_FRAMEWORK</kbd> with the highlighted line. The following lines show the new declaration of the dictionary named <kbd>REST_FRAMEWORK</kbd>. The code file for the sample is included in the <kbd>restful_python_2_07_03</kbd> folder, in the <kbd>Django01/games-service/games/settings.py</kbd> file:</p>
<pre>REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
<strong>    'games.max_limit_pagination.MaxLimitPagination', 
</strong>    'PAGE_SIZE': 4 
} </pre>
<p>Now the generic views will use the recently declared <kbd>games.pagination.MaxLimitPagination</kbd> class, which provides a <kbd>limit</kbd>/<kbd>offset</kbd> based style with a maximum <kbd>limit</kbd> value equal to <kbd>8</kbd>. If a request specifies a value for a limit higher than <kbd>8</kbd>, the class will use the maximum limit value, that is, <kbd>8</kbd>, and we will never return more than <kbd>8</kbd> items in a paginated response.</p>
<p>Now we will write a command to compose and send an HTTP request to retrieve the first page for the games, specifically, an HTTP <kbd>GET</kbd> method to <kbd>/games/</kbd> with the <kbd>limit</kbd> value set to <kbd>20</kbd>. The code file for the sample is included in the <kbd>restful_python_2_07_03</kbd> folder, in the <kbd>Django01/cmd/cmd719.txt</kbd> file:</p>
<pre>    <strong>http GET ":8000/games/?limit=20"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_07_03</kbd> folder, in the <kbd>Django01/cmd/cmd720.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:8000/games/?limit=20"</strong></pre>
<p>The result will use a limit value equal to <kbd>8</kbd>, instead of the indicated <kbd>20</kbd>, because we are using our customized pagination class. The result will provide us the first set with 10 game resources in the <kbd>results</kbd> key, the total number of games for the query in the <kbd>count</kbd> key, and a link to the next and previous pages in the <kbd>next</kbd> and <kbd>previous</kbd> keys. In this case, the result set is the first page, and therefore, the link to the next page in the <kbd>next</kbd> key is <kbd>http://localhost:8000/games/?limit=8&amp;offset=8</kbd>. We will receive a <kbd>200 OK</kbd> status code in the response header and the first eight games in the <kbd>results</kbd> array. The following lines show the header and the first lines of the output:</p>
<pre>    <strong>HTTP/1.1 200 OK</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 1542</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Fri, 26 Oct 2018 21:25:06 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "count": 12,</strong>
    <strong>    "next": "http://localhost:8000/games/?limit=8&amp;offset=8",</strong>
    <strong>    "previous": null,</strong>
    <strong>    "results": [</strong>
    <strong>        {</strong>
  </pre>
<p>It is a good practice to configure a maximum limit to avoid generating huge responses.</p>
<p>Open a web browser and enter <kbd>http://localhost:8000/games/</kbd>. Replace <kbd>localhost</kbd> with the IP of the computer that is running the Django development server if you use another computer or device to run the browser. The Browsable API will compose and send an HTTP <kbd>GET</kbd> request to <kbd>/games/</kbd> and will display the results of its execution, that is, the headers and the JSON games list. Because we have configured pagination, the rendered web page will include the default pagination template associated with the base pagination class we are using, and will display the available page numbers at the upper-right corner of the web page.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description game-list, and the three pages:</p>
<div><img src="img/3767e01a-f090-45aa-9fdb-0fdc3afab667.png" style="width:37.83em;height:29.25em;" width="1429" height="1104"/></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Understanding authentication, permissions, and throttling</h1>
                
            
            
                
<p>Our current version of the API processes all incoming requests without requiring any kind of authentication. Django REST Framework allows us to easily use different authentication schemes to identify the user that originated the request or the token that signed the request. Then, we can use these credentials to apply the permission and throttling policies that will determine whether the request must be permitted or not. In a production environment, we can combine an authentication scheme with an API running under HTTPS. In our development configuration, we will continue working with the API under HTTP, but this is only valid for developing.</p>


<p>As happened with other configurations, ...</p></div>



  
<div><h1 class="header-title">Adding security-related data to the models</h1>
                
            
            
                
<p>We will associate a game with a creator or owner. Only the authenticated users will be able to create new games. Only the creator of a game will be able to update it or delete it. All the requests that aren't authenticated will only have read-only access to games.</p>
<p>Open the <kbd>models.py</kbd> file in the <kbd>games_service/games</kbd> folder. Replace the code that declares the <kbd>Game</kbd> class with the following code. The new and edited lines are highlighted in the code listing. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/models.py</kbd> file:</p>
<pre>class Game(models.Model): 
    created = models.DateTimeField(auto_now_add=True) 
    name = models.CharField(max_length=200, unique=True) 
    esrb_rating = models.ForeignKey( 
        EsrbRating,  
        related_name='games',  
        on_delete=models.CASCADE) 
    release_date = models.DateTimeField() 
    played_once = models.BooleanField(default=False) 
    played_times = models.IntegerField(default=0) 
   <strong> owner = models.ForeignKey( 
        'auth.User',  
        related_name='games', 
        on_delete=models.CASCADE)</strong> 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name</pre>
<p>The new version of the <kbd>Game</kbd> model declares a new <kbd>owner</kbd> field that uses the <kbd>django.db.models.ForeignKey</kbd> class to provide a many-to-one relationship to the <kbd>auth.User</kbd> model, specifically, to the <kbd>django.contrib.auth.User</kbd> model. This <kbd>User</kbd> model represents the users within the Django authentication system. The <kbd>'games'</kbd> value specified for the <kbd>related_name</kbd> argument creates a backward relation from the <kbd>User</kbd> model to the <kbd>Game</kbd> model. This value indicates the name to use to relate a <kbd>User</kbd> object back to a <kbd>Game</kbd> object. This way, we will be able to access all the games owned by a specific user. Whenever we delete a user, we want all the games owned by this user to be deleted too, and therefore, we specify the <kbd>models.CASCADE</kbd> value for the <kbd>on_delete</kbd> argument.</p>
<p>Now we will run the <kbd>createsuperuser</kbd> subcommand for <kbd>manage.py</kbd> to create the superuser for Django that we will use to easily authenticate our requests. We will create more users later:</p>
<pre>    <strong>python manage.py createsuperuser</strong></pre>
<p>The command will ask you for the username you want to use for the superuser. Enter the desired username and press <em>Enter</em>. We will use <kbd>your_games_super_user</kbd> as the username for this example. You will see a line similar to the following one:</p>
<pre>    <strong>Username (leave blank to use 'xxxxxxxx'):</strong></pre>
<p>Then, the command will ask you for the email address:</p>
<pre>    <strong>Email address:<br/></strong></pre>
<p>Enter an email address, such as <kbd>your_games_super_user@example.com</kbd>, and press <em>Enter</em>.</p>
<p>Finally, the command will ask you for the password for the new superuser:</p>
<pre>    <strong>Password:</strong></pre>
<p>Enter your desired password and press <em>Enter</em>. In the examples, we will use <kbd>WCS3qn!a4ybX#</kbd> as the password.</p>
<p>The command will ask you to enter the password again:</p>
<pre>    <strong>Password (again):</strong></pre>
<p>Enter it and press <em>Enter</em>. If both entered passwords match, the superuser will be created:</p>
<pre>    <strong>Superuser created successfully.</strong></pre>
<p>Open the <kbd>serializers.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following code after the last line that declares the imports, before the declaration of the <kbd>GameCategorySerializer</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>from django.contrib.auth.models import User 
 
 
class UserGameSerializer(serializers.HyperlinkedModelSerializer): 
    class Meta: 
        model = Game 
        fields = ( 
            'url', 
            'name') 
 
 
class UserSerializer(serializers.HyperlinkedModelSerializer): 
    games = UserGameSerializer(many=True, read_only=True) 
 
    class Meta: 
        model = User 
        fields = ( 
            'url',  
            'id', 
            'username', 
            'games') </pre>
<p>The <kbd>UserGameSerializer</kbd> class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> superclass. We use this new serializer class to serialize the games related to a user. We just want to include the URL and the game's name, and therefore, the code specified <kbd>'url'</kbd> and <kbd>'name'</kbd> as members of the field tuple defined in the <kbd>Meta</kbd> inner class. We don't want to use the <kbd>GameSerializer</kbd> serializer class for the games related to a user because we want to serialize fewer fields, and therefore, we created the <kbd>UserGameSerializer</kbd> class.</p>
<p>The <kbd>UserSerializer</kbd> class is a subclass of the <kbd>HyperlinkedModelSerializer</kbd> superclass. This serializer class is related to the <kbd>django.contrib.auth.models.User</kbd> model. The <kbd>UserSerializer</kbd> class declares a <kbd>games</kbd> attribute as an instance of the previously explained <kbd>UserGameSerializer</kbd> with <kbd>many</kbd> and <kbd>read_only</kbd> equal to <kbd>True</kbd> because it is a one-to-many relationship and is read-only. We use the <kbd>games</kbd> name that we specified as the <kbd>related_name</kbd> string value when we added the <kbd>owner</kbd> field as a <kbd>models.ForeignKey</kbd> instance in the <kbd>Game</kbd> model. This way, the <kbd>games</kbd> field will provide us with an array of URLs and names for each game that belongs to the user.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>We will make more changes to the <kbd>serializers.py</kbd> file in the <kbd>game</kbd><kbd>s_service/games</kbd> folder. We will add an <kbd>owner</kbd> field to the existing <kbd>GameSerializer</kbd> class. The following lines show the new code for the <kbd>GameSerializer</kbd> class. The new and edited lines are highlighted. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>class GameSerializer(serializers.HyperlinkedModelSerializer): 
    # We want to display the game ESRB rating description instead of <br/>    #<br/><br/><br/><br/>its id 
    esrb_rating = serializers.SlugRelatedField( 
        queryset=EsrbRating.objects.all(),  
        slug_field='description') 
 <strong>   # We want to display the user name that is the owner 
    owner = serializers.ReadOnlyField(source='owner.username')</strong> 
 
    class Meta: 
        model = Game 
        fields = ( 
            'url', 
            'esrb_rating', 
            'name', 
            'release_date', 
            'played_once', 
         <strong>   'played_times', 
            'owner')</strong> </pre>
<p>Now the <kbd>GameSerializer</kbd> class declares an <kbd>owner</kbd> attribute as an instance of the <kbd>serializers.ReadOnlyField</kbd> class with <kbd>source</kbd> equal to <kbd>'owner.username'</kbd>. This way, we will serialize the value for the <kbd>username</kbd> field of the related <kbd>django.contrib.auth.User</kbd> hold in the <kbd>owner</kbd> field. We use the <kbd>ReadOnlyField</kbd> class because the owner is automatically populated when an authenticated user creates a game, and therefore, it won't be possible to change the owner after a game has been created. This way, the <kbd>owner</kbd> field will provide us with the username that created the game. In addition, we added <kbd>'owner'</kbd> to the <kbd>fields</kbd> string tuple declared in the <kbd>Meta</kbd> inner class.</p>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Creating a customized permission class for object-level permissions</h1>
                
            
            
                
<p>Create a new Python file named <kbd>customized_permissions.py</kbd> within the <kbd>games_service/games</kbd> folder and enter the following code that declares the new <kbd>IsOwnerOrReadOnly</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/customized_permissions.py</kbd> file:</p>
<pre>from rest_framework import permissions 
 
 
class IsOwnerOrReadOnly(permissions.BasePermission): 
    def has_object_permission(self, request, view, obj): 
        if request.method in permissions.SAFE_METHODS: 
            return True 
        else: 
            return obj.owner == request.user </pre>
<p>The <kbd>rest_framework.permissions.BasePermission</kbd> class is the base class from which all permission classes should inherit. ...</p></div>



  
<div><h1 class="header-title">Persisting the user that makes a request and configuring permission policies</h1>
                
            
            
                
<p>We want to be able to list all the users and retrieve the details for a single user. We will create subclasses of the two following generic class views declared in the <kbd>rest_framework.generics</kbd> module:</p>
<ul>
<li><kbd>ListAPIView</kbd>: Implements the <kbd>get</kbd> method that retrieves a listing of  <kbd>queryset</kbd></li>
<li><kbd>RetrieveAPIView</kbd>: Implements the <kbd>get</kbd> method to retrieve a model instance</li>
</ul>
<p>Open the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following code after the last line that declares the imports, before the declaration of the <kbd>GameCategoryList</kbd> class. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/views.py</kbd> file:</p>
<pre>from django.contrib.auth.models import User 
from rest_framework import permissions 
from games.serializers import UserSerializer 
from games.customized_permissions import IsOwnerOrReadOnly 
 
 
class UserList(generics.ListAPIView): 
    queryset = User.objects.all() 
    serializer_class = UserSerializer 
    name = 'user-list' 
 
 
class UserDetail(generics.RetrieveAPIView): 
    queryset = User.objects.all() 
    serializer_class = UserSerializer 
    name = 'user-detail'</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Stay editing the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following highlighted lines to the <kbd>ApiRoot</kbd> class declared in the <kbd>views.py</kbd> file. This way, we will be able to navigate to the users related views through the Browsable API. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/views.py</kbd> file:</p>
<pre>class ApiRoot(generics.GenericAPIView): 
    name = 'api-root' 
    def get(self, request, *args, **kwargs): 
        return Response({ 
<strong>            'users': reverse(UserList.name, request=request), 
</strong>            'players': reverse(PlayerList.name, request=request), 
            'esrb-ratings': reverse(EsrbRatingList.name, request=request), 
            'games': reverse(GameList.name, request=request), 
            'scores': reverse(PlayerScoreList.name, request=request) 
            }) </pre>
<p>Stay editing the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following highlighted lines to the <kbd>GameList</kbd> class-based view to override the <kbd>perform_create</kbd> method inherited from the <kbd>rest_framework.mixins.CreateModelMixin</kbd> superclass. Remember that the <kbd>generics.ListCreateAPIView</kbd> class inherits from <kbd>CreateModelMixin</kbd> class and other classes. The code in the new method will populate <kbd>owner</kbd> before a new <kbd>Game</kbd> instance is persisted in the database. In addition, the new code overrides the value for the <kbd>permission_classes</kbd> class attribute to configure permission policies for the class-based view. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/views.py</kbd> file:</p>
<pre>class GameList(generics.ListCreateAPIView): 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-list' 
  <strong>  permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        IsOwnerOrReadOnly)</strong> 
 
    <strong>def perform_create(self, serializer): 
        serializer.save(owner=self.request.user)</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The code for the overridden <kbd>perform_create</kbd> method passes an additional <kbd>owner</kbd> field to the <kbd>create</kbd> method by setting a value for the <kbd>owner</kbd> argument for the call to the <kbd>serializer.save</kbd> method. The code sets the <kbd>owner</kbd> attribute to the value of <kbd>self.request.user</kbd>, that is, to the user associated to the request. This way, whenever a new game is persisted, it will save the user associated to the request as its owner.</p>
<p>Stay editing the <kbd>views.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following highlighted lines to the <kbd>GameDetail</kbd> class-based view to override the value for the <kbd>permission_classes</kbd> class attribute to configure permission policies for the class-based view. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/views.py</kbd> file:</p>
<pre>class GameDetail(generics.RetrieveUpdateDestroyAPIView): 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-detail' 
  <strong>  permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        IsOwnerOrReadOnly)</strong> </pre>
<p>We have included the <kbd>IsAuthenticatedOrReadOnly</kbd> class and our previously created <kbd>IsOwnerOrReadOnly</kbd> permission class in the <kbd>permission_classes</kbd> tuple for both the <kbd>GameList</kbd> and <kbd>GameDetail</kbd> classes.</p>
<p>Open the <kbd>urls.py</kbd> file in the <kbd>games_service/games</kbd> folder. Add the following elements to the <kbd>urlpatterns</kbd> string list. The new strings define the URL patterns that specify the regular expressions that have to be matched in the request to run a specific method for the previously created class-based views in the <kbd>views.py</kbd> file: <kbd>UserList</kbd> and <kbd>UserDetail</kbd>. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>    url(r'^users/$', 
        views.UserList.as_view(), 
        name=views.UserList.name), 
    url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', 
        views.UserDetail.as_view(), 
        name=views.UserDetail.name),</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>Now open the <kbd>urls.py</kbd> file in the <kbd>games_service</kbd> folder, specifically, the <kbd>games_service/urls.py</kbd> file. The file defines the root URL configurations and we want to include the URL patterns to allow the Browsable API to display the login and logout views. The following lines show the new code with the added line highlighted. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/games-service/games/serializers.py</kbd> file:</p>
<pre>from django.conf.urls import url, include 
 
urlpatterns = [ 
    url(r'^', include('games.urls')), 
<strong>    url(r'^api-auth/', include('rest_framework.urls')), 
</strong>] </pre>
<p>The new line adds the URL patterns defined in the <kbd>rest_framework.urls</kbd> module and associates them to the <kbd>^api-auth/ pattern</kbd>. The browsable API uses <kbd>api-auth/</kbd> as a prefix for all the view related to the user login and logout</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Setting a default value for a new required field in migrations</h1>
                
            
            
                
<p>We have persisted many games in our database and we have added a new <kbd>owner</kbd> field for the games that are a required field. We don't want to delete all the existing games, and therefore, we will take advantage of some features in Django that make it easy for us to make the changes in the underlying database without losing the existing data.</p>
<p>Now we need to retrieve the <kbd>id</kbd> for the superuser we have created to use it as the default owner for the existing games. Django will allow us to easily update the existing games to set the owner user for them.</p>
<p>Run the following commands to retrieve the <kbd>id</kbd> from the <kbd>auth_user</kbd> table for the row whose <kbd>username</kbd> matches <kbd>'superuser'</kbd>. Replace <kbd>your_games_super_user ...</kbd></p></div>



  
<div><h1 class="header-title">Composing requests with the necessary authentication</h1>
                
            
            
                
<p>Now we will write a command to compose and send an HTTP <kbd>POST</kbd> request to create a new game without authentication credentials. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd721.txt</kbd> file:</p>
<pre><strong>http POST ":8000/games/" name='Super Mario Odyssey' esrb_rating='T (Teen)' release_date='2017-10-27T01:00:00.776594Z'</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd722.txt</kbd> file:</p>
<pre><strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Super Mario Odyssey", "esrb_rating":"T (Teen)", "release_date": "2017-10-27T01:00:00.776594Z"}' <br/>"localhost:8000/games/"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We will receive a <kbd>403 Forbidden</kbd> status code in the response header and a detailed message indicating that we didn't provide authentication credentials in the JSON body. The following lines show a sample response:</p>
<pre>    <strong>HTTP/1.1 403 Forbidden</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 58</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sat, 27 Oct 2018 15:03:53 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "detail": "Authentication credentials were not provided."</strong>
    <strong>}</strong>
  </pre>
<p>If we want to create a new game, that is, to make a <kbd>POST</kbd> request to <kbd>/games/</kbd>, we need to provide authentication credentials by using HTTP authentication. Now we will compose and send an HTTP request to create a new game with authentication credentials, that is, with the superuser name and their password. Remember to replace <kbd>your_games_super_user</kbd> with the name you used for the superuser and <kbd>WCS3qn!a4ybX#</kbd> with the password you configured for this user. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd723.txt</kbd> file:</p>
<pre><strong>http -a your_games_super_user:'WCS3qn!a4ybX#' POST ":8000/games/" name='Super Mario Odyssey' esrb_rating='T (Teen)' release_date='2017-10-27T01:00:00.776594Z'</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd724.txt</kbd> file:</p>
<pre><strong>curl --user your_games_super_user:'password' -iX POST -H "Content-Type: application/json" -d '{"name":"Super Mario Odyssey", "esrb_rating":"T (Teen)", "release_date": "2017-10-27T01:00:00.776594Z"}' "localhost:8000/games/"</strong>  </pre>
<p>If the new <kbd>Game</kbd> with the user named <kbd>your_games_super_user</kbd> as its owner was successfully persisted in the database, the function returns an HTTP <kbd>201 Created</kbd> status code and the recently-persisted <kbd>Game</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <kbd>Game</kbd> object in the JSON response:</p>
<pre>    <strong>HTTP/1.1 201 Created</strong>
    <strong>Allow: GET, POST, HEAD, OPTIONS</strong>
    <strong>Content-Length: 209</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sat, 27 Oct 2018 15:17:40 GMT</strong>
    <strong>Location: http://localhost:8000/games/13/</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "esrb_rating": "T (Teen)",</strong>
    <strong>    "name": "Super Mario Odyssey",</strong>
    <strong>    "owner": "your_games_super_user",</strong>
    <strong>    "played_once": false,</strong>
    <strong>    "played_times": 0,</strong>
    <strong>    "release_date": "2017-10-27T01:00:00.776594Z",</strong>
    <strong>    "url": "http://localhost:8000/games/13/"</strong>
    <strong>}</strong>
  </pre>
<p>Now we will compose and send an HTTP <kbd>PATCH</kbd> request to update the <kbd>played_once</kbd> and <kbd>played_times</kbd> field values for the previously created game with authentication credentials. However, in this case, we will use the other user we created in Django to authenticate the request. Remember to replace <kbd>gaston-hillar</kbd> with the name you used for the user and <kbd>FG$gI^76q#yA3v</kbd> with their password. In addition, replace <kbd>13</kbd> with the <kbd>id</kbd> generated for the previously-created game in your configuration. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd725.txt</kbd> file:</p>
<pre><strong>http -a 'gaston-hillar':'FG$gI^76q#yA3v' PATCH ":8000/games/13/" played_once=true played_times=15</strong>
  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd726.txt</kbd> file:</p>
<pre><strong>curl --user 'gaston-hillar':'FG$gI^76q#yA3v' -iX PATCH -H "Content-Type: application/json" -d '{"played_once": "true", "played_times": 15}' <br/>"localhost:8000/games/13/"</strong>
  </pre>
<p>We will receive a <kbd>403 Forbidden</kbd> status code in the response header and a detailed message indicating that we do not have permission to perform the action in the JSON body. The owner for the game we want to update is <kbd>your_games_super_user</kbd> and the authentication credentials for this request use a different user. Hence, the operation is rejected by the <kbd>has_object_permission</kbd> method in the <kbd>IsOwnerOrReadOnly</kbd> class. The following lines show a sample response:</p>
<pre>    <strong>HTTP/1.1 403 Forbidden</strong>
    <strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
    <strong>Content-Length: 63</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Sat, 27 Oct 2018 15:23:45 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.7.1</strong>
    <strong>Vary: Accept, Cookie</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "detail": "You do not have permission to perform this action."</strong>
    <strong>}</strong>
  </pre>
<p>If we compose and send an HTTP request with the same authentication credentials for that resource with the <kbd>GET</kbd> method, we will be able to retrieve the game that the specified user doesn't own. The request will work because <kbd>GET</kbd> is one of the safe methods and a user that is not the owner is allowed to read the game. Remember to replace <kbd>gaston-hillar</kbd> with the name you used for the user and <kbd>FG$gI^76q#yA3v</kbd> with their password. In addition, replace <kbd>13</kbd> with the ID generated for the previously created game in your configuration. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd727.txt</kbd> file:</p>
<pre>    <strong>http -a 'gaston-hillar':'FG$gI^76q#yA3v' GET ":8000/games/13/"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_07_04</kbd> folder, in the <kbd>Django01/cmd/cmd728.txt</kbd> file:</p>
<pre> <strong>curl --user 'gaston-hillar':'FG$gI^76q#yA3v' -iX GET "localhost:8000/games/13/"</strong>
  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Browsing the API with authentication credentials</h1>
                
            
            
                
<p>Open a web browser and enter <kbd>http://localhost:8000/</kbd>. Replace <kbd>localhost</kbd> with the IP of the computer that is running the Django development server if you use another computer or device to run the browser. The Browsable API will compose and send a <kbd>GET</kbd> request to <kbd>/</kbd> and will display the results of its execution, that is, the API root. You will notice there is a Log in hyperlink at the upper-right corner.</p>
<p>Click Log in and the browser will display the Django REST Framework login page. Enter <kbd>gaston-hillar</kbd> in the username field, enter <kbd>FG$gI^76q#yA3v</kbd> in the password field, and click Log In. Now, you will be logged in as <kbd>gaston-hillar</kbd> and all the requests you compose and send through the Browsable API ...</p></div>



  
<div><h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>Which of the following lines define a field named <kbd>title</kbd> in a model that will generate a unique constraint on this field?
<ol>
<li><kbd>title = django.db.models.CharField(max_length=250, unique=True)</kbd></li>
<li><kbd>title = django.db.models.UniqueCharField(max_length=250)</kbd></li>
<li><kbd>title = django.db.models.CharField(max_length=250, options=django.db.models.unique_constraint)</kbd></li>
</ol>
</li>
</ol>
<ol start="2">
<li>Which of the following lines define a field named <kbd>title</kbd> in a model that won't generate a unique constraint on this field?
<ol>
<li><kbd>title = django.db.models.CharField(max_length=250, unique=False)</kbd></li>
<li><kbd>title = django.db.models.NonUniqueCharField(max_length=250)</kbd></li>
<li><kbd>title = django.db.models.CharField(max_length=250, options=django.db.models.allow_duplicates)</kbd></li>
</ol>
</li>
</ol>
<ol start="3">
<li>Which of the following setting's keys in the <kbd>REST_FRAMEWORK</kbd> dictionary specifies a global setting with the default pagination class that the generic views will use to provide paginated responses?
<ol>
<li><kbd>DEFAULT_PAGINATED_RESPONSE_PARSER</kbd></li>
<li><kbd>DEFAULT_PAGINATION_CLASS</kbd></li>
<li><kbd>DEFAULT_PAGINATED_RESPONSE_CLASS</kbd></li>
</ol>
</li>
</ol>
<ol start="4">
<li>Which of the following pagination classes provides a limit/offset-based style in Django REST framework?
<ol>
<li><kbd>rest_framework.pagination.LimitOffsetPaging</kbd></li>
<li><kbd>rest_framework.styles.LimitOffsetPagination</kbd></li>
<li><kbd>rest_framework.pagination.LimitOffsetPagination</kbd></li>
</ol>
</li>
</ol>
<ol start="5">
<li>The <kbd>rest_framework.authentication.BasicAuthentication</kbd> class:
<ol>
<li>Works with Django's session framework for authentication</li>
<li>Provides an HTTP basic authentication against username and password</li>
<li>Provides a simple token-based authentication</li>
</ol>
</li>
</ol>
<ol start="6">
<li>The <kbd>rest_framework.authentication.SessionAuthentication</kbd> class:
<ol>
<li>Works with Django's session framework for authentication</li>
<li>Provides an HTTP basic authentication against username and password</li>
<li>Provides a simple token-based authentication</li>
</ol>
</li>
</ol>
<ol start="7">
<li>Which of the following setting's keys in the <kbd>REST_FRAMEWORK</kbd> dictionary specifies a global setting with a tuple of string that indicates the classes we want to use for authentication?:
<ol>
<li><kbd>DEFAULT_AUTH_CLASSES</kbd></li>
<li><kbd>AUTHENTICATION_CLASSES</kbd></li>
<li><kbd>DEFAULT_AUTHENTICATION_CLASSES</kbd></li>
</ol>
</li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we improved the RESTful API in many ways. We added unique constraints to the model and updated the database, we made it easy to update single fields with the <kbd>PATCH</kbd> method, and we took advantage of pagination.</p>
<p>Then, we started working with authentication, permissions, and throttling. We added security-related data to the models and we updated the database. We made many changes in the different pieces of code to achieve a specific security goal and we took advantage of Django REST Framework's authentication and permissions features.</p>
<p>Now that we have built an improved and complex API that takes into account authentication and uses permission policies, we will use additional abstractions included in the framework, adding ...</p></div>



  </body></html>