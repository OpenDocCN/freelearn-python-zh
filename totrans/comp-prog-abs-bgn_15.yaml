- en: '*Chapter 12:* Code Quality'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many aspects of code quality. We can talk about efficient code, which
    is code that runs fast or doesn't waste resources such as memory. It can also
    be source code that is easy to read and understand for us humans and therefore
    is easy to read and maintain. In this chapter, we'll talk about this and look
    at some best practices for writing high-quality code.
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at some examples of things we should try to avoid if we want
    to write high-quality code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what code quality is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing readable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing efficient code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding that smart code is not always smart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding some of the best practices for writing quality code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we learn how to write quality code, we should define what code quality
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Defining code quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is tough to define the meaning of quality when it comes to program code.
    The reason is that all developers will have their own opinion of what it means.
    One developer can argue that we should focus on writing readable code as it will
    be easier to understand and maintain and, by that, reduce the chance of us inserting
    any bugs into the code. Another developer could argue that we shall focus on writing
    compact code; that is, as few code lines as possible. Even if the code is harder
    to read, less code will give us fewer chances to introduce bugs in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the two developers would argue for the same thing – fewer bugs in the
    code – with two contradictory positions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a small example using Python as our language. We want to create
    a list that holds all possible combinations we can get by rolling two dice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one will use more code, but it will be easier to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the first line, we create an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a `for` loop for the first dice. The `d1` variable will get the
    value `1` the first iteration, `2` the second, and so on. Remember that the end
    value, `7`, is when it will stop, so this is `7`, not `6`, as it will stop when
    it reaches this, giving us the values 1 to 6\.
  prefs: []
  type: TYPE_NORMAL
- en: We will then do the same kind of loop for the second dice.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line, we will insert the values of `d1` and `d2` into the list.
    Having an extra pair of parentheses on appending the values will put them in what
    is called a `d1` and `d2` belong together as one combination.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can accomplish the same things with a single line of code. It will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the second example has less code but at the cost of readability.
  prefs: []
  type: TYPE_NORMAL
- en: But who is right – the developer arguing for readability or the one arguing
    for less code? We can't say, as they both are right.
  prefs: []
  type: TYPE_NORMAL
- en: What we need is a better definition of what code quality is, and more importantly,
    it should be measurable.
  prefs: []
  type: TYPE_NORMAL
- en: Many efforts to define a model for measuring code quality have been made, and
    one of the better known is CISQ's quality model. We'll see what that is next.
  prefs: []
  type: TYPE_NORMAL
- en: CISQ's quality model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Consortium for Information Software Quality** (**CISQ**) has defined
    five rules that can be used to measure the quality of code. It was first defined
    with business software in mind but was later extended to also include embedded
    systems, used mainly in **Internet of Things** (**IoT**) applications. These rules
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: Reliability measures the level of risk and the likelihood
    of failures. It will also measure the defects that are injected into existing
    code when it is updated or modified. The goal of measuring reliability is to prevent
    the time an application can''t run because of severe bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance efficiency**: When an application is running, the speed with
    which it performs its operations depends on how the code is written and structured.
    Measuring the efficiency at a code level will help to improve both the overall
    response time of an application and how we identify the potential risk of applications
    that need to process data at a high speed that fail as they fail to process data
    fast enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: The security rule will measure the likelihood of potential security
    breaches due to poor coding practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: When we are talking about the maintainability of code,
    we usually refer to three things. We say that the code should be, namely, *adaptable*,
    which is code that we can adapt to changes as per the requirements; *portable*,
    which is code that can be used on different platforms, such as different operating
    systems; and *transferable*, which is code that can be transferred from one development
    team to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be applied to, more or less, all code, but we want to be able to do
    all three of these with as little effort as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Size**: Size is not a quality attribute per se, but the size of the code
    can have an impact on its maintainability. The more code we have, the harder it
    will be to navigate, understand, and follow its logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now talked about the quality aspects regarding code. But what about
    quality from the user's perspective?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding user quality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What the CISQ model focuses very little on is quality from the user's perspective.
    An application can match all the CISQ rules, but a user of this application may
    still consider it being of poor quality.
  prefs: []
  type: TYPE_NORMAL
- en: Dr. Tom DeMarco, an American software engineer, has proposed that *a product's
    quality is a function of how much it changes the world for the better.*
  prefs: []
  type: TYPE_NORMAL
- en: This statement can be interpreted as meaning that an application's functional
    quality and user satisfaction are more important than the structural quality of
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: The American computer scientist Gerald Weinberg has said that *Quality is value
    to some person*. This implies that quality is subjective – what one person would
    define as quality in an application might be the opposite for another person.
    This view will focus on asking the questions *Who are the people that want to
    value our software?* and *What will be valuable to them?*
  prefs: []
  type: TYPE_NORMAL
- en: With these definitions in mind, we will start to realize that crafting software
    is much more than just writing code. Even if the code has excellent quality, if
    the users don't like what we have created, they will not use it. It is like if
    we build a chair using the best craftsmanship, but if it is incredibly uncomfortable,
    no one will buy it.
  prefs: []
  type: TYPE_NORMAL
- en: We must, therefore, understand our users and their needs. Doing so is not always
    easy as our potential users might not know about these needs. Before you had your
    first smartphone, you did not miss it as you did not know what it could offer
    you. Now, on the other hand, you would miss it just after a few hours if it was
    taken away from you.
  prefs: []
  type: TYPE_NORMAL
- en: To get to the point where we understand our user's needs before they understand
    it, we need to use our imagination. We can start by asking some simple questions.
    They could be, what problem will this application solve? Who will benefit from
    it? Is there a pattern that the people who will benefit from using this application
    have in common? What kind of applications does this group already use? Are there
    features, patterns, or ideas used in those applications that we can reuse in our
    application to make this group more familiar with how our application works from
    the start?
  prefs: []
  type: TYPE_NORMAL
- en: When we have an idea about who our future users might be, we will need to focus
    on the flow within the application. We all know how frustrating it is when we
    use a program, or any other product for that matter, and we can't figure out what
    to do. We try one thing after the other, and rather soon, we lose all interest
    in using it.
  prefs: []
  type: TYPE_NORMAL
- en: If you invest time and money in developing something, you should at least give
    that great idea of yours every chance to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Great! We now have an idea of what code quality is and we also understand the
    quality aspects from a user perspective. I am sure you want both in your software,
    so let's put them together.
  prefs: []
  type: TYPE_NORMAL
- en: Putting them together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we think about it, the art of creating quality software is, of course, neither
    writing code with high quality nor writing an application that the users find
    valuable; it is both.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in earlier chapters, applications that are used will be updated,
    modified, and extended. This means that the code needs to be read by other programmers
    (or by us) if we want to find where changes need to be made.
  prefs: []
  type: TYPE_NORMAL
- en: It will all boil down to a question about money. We want to create software
    that gives our users added value and we can sell our application. But maybe even
    more important is that the programmers that maintain the code of the application
    can work efficiently. If they can find a bug quickly, they will spend less time
    fixing it.
  prefs: []
  type: TYPE_NORMAL
- en: If the code is easy to read and understand, the programmers will also have a
    higher chance of avoiding inserting new bugs into the code, thus reducing the
    cost of fixing them.
  prefs: []
  type: TYPE_NORMAL
- en: One problem many programmers will face is that they are not given the time needed
    to create the quality code they want and that can be understood. Tight time schedules,
    managers who don't fully understand the importance of well-crafted code, and impatient
    customers can all be aspects that will force programmers to produce code quickly,
    resulting in a loss of quality. This is, of course, a very short-term approach.
  prefs: []
  type: TYPE_NORMAL
- en: You might ship the software faster, but with lower quality, both for the users
    and for the programmers who will need to maintain the code in the future. This
    will most likely be less cost-efficient than crafting high-quality code to begin
    with.
  prefs: []
  type: TYPE_NORMAL
- en: It should also be noted that if we start a project with poorly written code,
    this project will most likely always contain low-quality code as the cost of going
    back and improving all the code will be too high.
  prefs: []
  type: TYPE_NORMAL
- en: We have everything to win if we do a good job and write quality code and deliver
    software that is considered high quality by our users.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter will not focus on user quality. That does not mean
    that it's not essential, but this is a book about writing code, so let's see how
    we can do that with quality and style.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code with readability in mind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code that you write will not only be executed by the computer. It will also
    be read both by yourself and by others. Therefore, is it essential that you write
    code that is as easy to read and understand as possible.
  prefs: []
  type: TYPE_NORMAL
- en: There are some simple rules we can follow that will assist in achieving readable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Using comments and documentation wisely
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating code, you need an understanding what you do and why you do it.
    But when coming back to your code a couple of months later, it is not always as
    clear what these thoughts were and why you wrote things the way you did. Commenting
    on tricky lines of code is a great way to document your thoughts for both your
    future self and others that will read your code.
  prefs: []
  type: TYPE_NORMAL
- en: But comments can also make the code less readable. Never comment on things that
    are obvious – things that any programmer, including yourself, will understand.
  prefs: []
  type: TYPE_NORMAL
- en: You should use comments when you look at a line of code and understand that
    a reader who sees this line will need to stop and think before understanding what
    it does.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting on functions and methods is often a good idea. These comments will
    usually come right before the function or method or as the first thing inside
    it. What you should use depends on what language you are using, as well as the
    conventions used by programmers of that language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see an example of this for a JavaScript
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Documenting a JavaScript function](img/Figure_12.1_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Documenting a JavaScript function
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what we can infer from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first text line in this comment describes the overall responsibility of
    this function. Then, using the predefined `@param` name, the meaning of the two
    parameters are documented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the curly braces, the data type that is expected is defined. This is
    especially important if the language we are using is dynamically typed. A dynamically
    typed language will accept any type we assign to a variable, rather than using
    only the type we specify. JavaScript is dynamically typed, so this will assist
    any programmers using this function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that comes the name of the parameter (table and headers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, after a dash, we will document what this parameter is used for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many editors used by programmers can use this documentation if formatted correctly.
    The format we can see here is called JSDoc.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that when we write the code that will
    call this function, the editor can show us the information that was found in this
    comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Programming editor showing data from the function documentation](img/Figure_12.2_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Programming editor showing data from the function documentation
  prefs: []
  type: TYPE_NORMAL
- en: Comments are not the only way we can document our code. We can also let the
    code be partly self-documenting by naming things nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Using names as documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By naming variables and functions wisely, the names by themselves will act
    as documentation. Look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a function that will download a web page and extract all the links
    found on that page. When we call this function, we pass the address to the page
    we want to extract the links from. That address is stored in the `url` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Inside, a function called `download_page` is called. As the name describes clearly
    what that function does, when reading the code, there is no need for us to go
    to that function to understand what it does. The variable that receives the returned
    data is called `page`, so we understand what data it holds.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the same thing on the next line. If a function is called `extract_links`,
    we can assume that is what that function does. We store the data we get back in
    a variable called `links`, so our assumption seems to be right.
  prefs: []
  type: TYPE_NORMAL
- en: The function names will almost act like a table of content when reading this
    function. We understand what happens there, and we can go there if we want, but
    there is no need to do so just to learn what it does. The idea of a table of content
    in a book is that you will both learn what a chapter is about and learn where
    to find it. The same thing applies here. If we name our functions well, they will
    let us know what they do. Most integrated development environments will let us
    click the name, which means we will be taken to that function if we want to read
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, in the *Limiting function/method length* section, we
    will learn more about how to use this technique.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to understand what good code looks like, we must see both good and
    bad code. Therefore, to become a good programmer, we must read code.
  prefs: []
  type: TYPE_NORMAL
- en: Reading other people's code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a beginner programmer, the best thing we can do is read code written by experienced
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: A good source is open source projects. Experienced programmers develop these
    projects, and their code is available online for anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Pick any project, preferably in the same language you are using. At first, approaching
    such a project might be overwhelming as there will be maybe hundreds of files
    structured in several folders. But take your time and poke around in this file
    structure. Maybe the most important thing is not to understand the file structure
    of the project, but just looking at the code and trying to understand parts of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: This will give you an insight into how experienced programmers structure their
    code. It should be noted that all senior developers will not always do a perfect
    job, but most of the time, the code you can see here would be considered to be
    of relatively high quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at code written by a beginner programmer and compare it with the
    code written by an experienced one, you will see the difference. Now, refer to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – A program that was written by a beginner programmer](img/Figure_12.3_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – A program that was written by a beginner programmer
  prefs: []
  type: TYPE_NORMAL
- en: Look at the preceding program. It is written in C# and will ask the user for
    a sentence. It will then calculate the number of characters, not counting spaces,
    that the user entered and finally calculate and print the average number of characters
    of the words in the sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code has many characteristics of a beginner programmer. I have been teaching
    programming for 30 years and this is not, by far, the worst example I have seen.
    Now, refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – The same program shown previously, written by an experienced
    programmer](img/Figure_12.4_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – The same program shown previously, written by an experienced programmer
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, compare the code we provided at the start of this section with the code
    shown in the preceding screenshot, which is the very same program written by an
    experienced programmer. A user of these two programs will not be able to tell
    any difference. Executing both will produce an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the user's perspective, we can say that the quality of the two programs
    is identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the quality of the code is not identical at all. Let''s list some of the
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The first version – written by a beginner programmer – does not use any indentation,
    making the code very compact and hard to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first version does not use any blank lines, while in the other version,
    the blank lines divide the code into sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first version, the `newScen` variable is assigned values, but it is never
    used, so it can be removed from the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first version, the variable `names` do not reflect what they are storing.
    In the second version, the `myScen` variable is renamed to `sentence`, `n` is
    renamed to `word`, and `countedWords` is renamed to `averageCharCount`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first version is using a `for` loop to count all the characters except spaces.
    In the second version, a language-specific construct is used to do the same thing
    on a single line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first version declares all the variables at the beginning of the `main`
    method. In the second version, they are declared when they are first used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first version uses some other unnecessary code, such as `Convert.ToString`
    on line 16, and some of the comments do not add any new knowledge to the reader
    of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you don't understand the code, just looking at it reveals that the second
    version is much more pleasant to look at.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that even though the second program introduced blank lines in the
    code, the number of lines dropped from 31 to 22.
  prefs: []
  type: TYPE_NORMAL
- en: As a beginner programmer, you are very focused on getting things to work, and
    you should. But when you get there and your program is working, you should go
    back and look at your code and think about how you can raise the quality. Maybe
    you won't come up with the same one-line solutions the experienced programmer
    is using, but at least you can use blank lines, indentation, and sensible variable
    names.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to learn to write high-quality code, you will need to be exposed
    to it, which is why reading code written by senior developers will help you write
    better code. Don't forget that when you do read it, try to understand as much
    as you can about the code you are reading. It might be a slow process, but it
    is not like reading a book – you don't have to read all the code there is. Take
    a function or a method and focus on only the code you find there. A good source
    to go to is the Stack Overflow website, where programmers can ask questions and
    other programmers will answer them. Go to [https://stackoverflow.com/](https://stackoverflow.com/)
    and look around. You can filter the questions so that you will only see questions
    related to the language you are interested in. Focus on the answers, as the people
    who answer these questions are often very experienced and their code is often
    of high quality. You can, of course, also use this site to ask your own programming
    questions, and who knows – soon, you might be answering some too.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous example, just making the program work is not enough.
    When it does, we shall go back and look at the code we just wrote to see if we
    can restructure it to make it more pleasant to look at and read, and maybe come
    up with a better solution to the problem we are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: An excellent way to tackle a programming task is first to come up with a working
    solution, and then when you have it, work on it and tweak it to make it better.
    This will not only result in better code quality, but you will also learn from
    it, and the next time you face a similar problem, you will start with a better
    first solution.
  prefs: []
  type: TYPE_NORMAL
- en: This is why an experienced programmer will not start with something like what
    was shown in *Figure 12.3*, but with something closer to what was shown in *Figure
    12.4*.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the code you have written will make you look at it with fresh
    eyes, and you will see things that you did not see when you first wrote the code.
  prefs: []
  type: TYPE_NORMAL
- en: Letting your code go through several iterations will be beneficial in more than
    one way. Hopefully, it will give you higher quality code. You also understand
    the problem your code is trying to solve better because if you process the problem
    in your head and work on a solution, you will gain a broader and more in-depth
    understanding of the problem itself and how it could be solved.
  prefs: []
  type: TYPE_NORMAL
- en: You will also improve your language and programming skills as you will need
    to learn more about the language you are using, in order to use the right features
    the language has to offer for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Even programmers who have used a language for years will discover things they
    had no idea existed.
  prefs: []
  type: TYPE_NORMAL
- en: With more experience, you will also recognize patterns in the problems you are
    solving and the code you are writing. As you do, the process of rewriting your
    code will be faster. Not only will you come up with improved ideas quicker, but
    your code will also start at a higher level to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Always have readability as your primary focus when rewriting your code. Sometimes,
    you need to sacrifice readability to make the code more efficient or faster, but
    if it is your primary goal, this will be reflected in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look at your code, you should always ask yourself the most fundamental
    question: Is this code I would like to read if someone else wrote it?'
  prefs: []
  type: TYPE_NORMAL
- en: If the answer is no, change it so you can answer yes.
  prefs: []
  type: TYPE_NORMAL
- en: Readable code is excellent, but the code should be efficient too.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code with efficiency in mind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about efficient code, we can mean several different things. Let's
    look at some of the things people might mean when they talk about efficient code.
  prefs: []
  type: TYPE_NORMAL
- en: Removing redundant or unnecessary code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should always make sure that you remove redundant code. Redundant code is
    code that does not affect the output of the application, but will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a variable, `number`, and set it to `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a `for` loop. This loop will iterate 999 times. The first time
    this happens, the `i` variable will have a value of `1`; the second time, it will
    be `2`, and so on until it reaches `1000`. Then, we will exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we're inside the loop, we will take whatever value the variable number
    currently has, add the current value of `i` to it, and store the result in the
    `number` variable.
  prefs: []
  type: TYPE_NORMAL
- en: After we exit the loop, we assign the value `20` to the `variable` number, and
    by doing that, we will overwrite the value we just calculated.
  prefs: []
  type: TYPE_NORMAL
- en: This means that everything we did before the line where we assigned `20` to
    `number` is unnecessary. Deleting those lines will not have any effect on the
    output of the program, but when we run the application, this unnecessary loop
    will run, and by that, consume some resources and waste time.
  prefs: []
  type: TYPE_NORMAL
- en: Having code like this will also make the code harder to read as we will spend
    some time trying to figure out what the loop does and why it is there.
  prefs: []
  type: TYPE_NORMAL
- en: With the unnecessary code removed, we can now see how we can use the computer's
    hardware more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the use of memory and processors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is easy to waste memory without even knowing it. Depending on what language
    you use, memory will be handled differently.
  prefs: []
  type: TYPE_NORMAL
- en: There might also be features in your programming language that will use the
    computer hardware in a more efficient way than the first solution you come up
    with. Let's look at one example from Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will concatenate strings together using two different techniques.
    In the first version, we will use the `+` operator to concatenate them. We will
    repeat this 2 million times and measure how long it takes. Refer to the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how this code works:'
  prefs: []
  type: TYPE_NORMAL
- en: On the two first lines, we create two variables, `s1` and `s2`, that hold the
    two strings we want to concatenate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the third line, we create a variable called `result`, which, initially, is
    an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then enter our loop, which will iterate 2 million times. The underscore after
    `for` is there because we won't need a variable to hold the current iteration
    value (which is 0 the first iteration, 1 for the second, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time we're inside the loop, we take what is currently in the `result` variable
    and add it together with the content of the `s1` and `s2` variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the first iteration, `result` will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After the second iteration, it will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The result, after 2 million iterations, will be a string that is 32 million
    characters long!
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create the same application but use another technique for concatenating
    the strings. This is not as easy to understand, and don't worry if you don't get
    how the code works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has something called the **string join** method. It is designed to join
    strings together in a very efficient way. The code for the program looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This program will also iterate 2 million times, concatenate the two strings
    together, and produce a string that is 32 million characters long.
  prefs: []
  type: TYPE_NORMAL
- en: The first program we wrote took about 42 seconds to complete on my computer.
  prefs: []
  type: TYPE_NORMAL
- en: The second program will, on the same machine, complete in 0.34 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Adding two strings together as many times as we did here is, of course, not
    something we do very often, but these two programs illustrate the impact of choosing
    one solution instead of another.
  prefs: []
  type: TYPE_NORMAL
- en: It is not only language constructs such as the one we saw here that can also
    improve the performance of our applications. Choosing the right algorithm can
    also have a significant impact on speed and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Using efficient algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An algorithm is a solution to a problem. The algorithm will describe the logical
    steps needed to get something done. Let's look at an example. If we have a sequence
    of numbers and we want this sequence sorted, we can use a sorting algorithm. We
    have several algorithms to choose from, and all will get the job done; that is,
    sorting a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we have more than one algorithm is that they are more or less effective
    when it comes to speed and usage of memory. How hard it is to write the code that
    implements the algorithm will also differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at one of the easiest sorting algorithms to implement: bubble sort.
    It is also one of the least effective algorithms, as we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Look at the code and see if you understand what it does. I will not go through
    the details of it. Instead, we will go through the bubble sort algorithm step
    by step. After we have done that, you can come back to the code and try to figure
    out what is happening here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sequence we will work with looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the logic of bubble sort:'
  prefs: []
  type: TYPE_NORMAL
- en: In the following image, you can see a graphical representation of the sequence
    we are working on:![Figure 12.5 – The sequence to be sorted](img/Figure_12.5_B15554.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.5 – The sequence to be sorted
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bubble sort will start by comparing the first two values – in our case, **5**
    and **3** – as shown in the following image:![Figure 12.6 – Comparing the first
    two values](img/Figure_12.6_B15554.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.6 – Comparing the first two values
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If they are not in the right order, they will be swapped. As they are out of
    order, **3** will be moved to the first position, while **5** will be moved to
    the second, resulting in the following sequence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The values 5 and 3 swap places](img/Figure_12.7_B15554.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.7 – The values 5 and 3 swap places
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, **5** and **1** will be compared, and again get swapped if they're not
    in order, as shown in the following image:![Figure 12.8 – Comparing 5 and 1](img/Figure_12.8_B15554.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.8 – Comparing 5 and 1
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'They are not in the correct order, so they get swapped, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.9 – The values 5 and 1 swap places](img/Figure_12.9_B15554.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 12.9 – The values 5 and 1 swap places
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, **5** and **8** are compared, but as they are in the right order, nothing
    is done, as shown in the following image:![Figure 12.10 – The values 5 and 8 are
    in the right order](img/Figure_12.10_B15554.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 12.10 – The values 5 and 8 are in the right order
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, **8** and **2** will be compared, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – The values 8 and 2 are compared](img/Figure_12.11_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – The values 8 and 2 are compared
  prefs: []
  type: TYPE_NORMAL
- en: 'They will be swapped as they are out of order, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – The values 8 and 2 swap places](img/Figure_12.12_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – The values 8 and 2 swap places
  prefs: []
  type: TYPE_NORMAL
- en: We have now reached the end of the sequence and, as you can see, it is not sorted.
    But one item is sorted, and that is the value 8\. As this is the largest value
    in the sequence, it has been pushed to the end, and by that, it has reached its
    correct location.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the name of the algorithm comes from, since one value has bubbled
    to the end.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the algorithm will start over, comparing the first two values
    and swapping them if necessary. This time, though, the last value – 8, in our
    case – will not be part of the comparison as it has already found its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the second round, the sequence will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – The sequence after two rounds](img/Figure_12.13_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – The sequence after two rounds
  prefs: []
  type: TYPE_NORMAL
- en: 5 and 8 are now in the correct location (marked with a thicker border), and
    the algorithm will start over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third run, the values **1**, **3**, and **2** will be considered, and
    after that run, the sequence will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – The sequence after three rounds](img/Figure_12.14_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – The sequence after three rounds
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the sequence is now sorted, but the algorithm will pass over
    the remaining values once more. It will discover that it could go over them without
    swapping any values, and this means that the sequence is sorted, and we are done.
  prefs: []
  type: TYPE_NORMAL
- en: The reason bubble sort is inefficient is because it will go over the sequence
    multiple times. In fact, in the worst case, it will need to do as many passes
    as there are items. For a short sequence such as this one, this isn't a problem,
    but for a larger sequence, it will be noticeable.
  prefs: []
  type: TYPE_NORMAL
- en: Other sorting algorithms are much more efficient, but they're harder to write
    code for. Examples of these include Quicksort and Merge sort. We will not cover
    how they work here as they are somewhat complicated. If you want to know more
    about these algorithms, you can do a web search – you will find lots of useful
    resources that will explain how they work and give you readymade code for them
    in any programming language you want.
  prefs: []
  type: TYPE_NORMAL
- en: If we compare bubble sort and Quicksort, we will see the difference. On my computer,
    bubble sort sorted a sequence of 10,000 values in 9.8 seconds. Quicksort managed
    to sort the same sequence in 0.03 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The reason Quicksort and Merge sort will do better in most cases is that they
    will need to perform fewer operations. It should also be noted that bubble sort
    can beat the others if the sequence is sorted or almost sorted to begin with.
    If we have a sorted sequence, bubble sort will go through it once and discover
    that it is sorted and stop.
  prefs: []
  type: TYPE_NORMAL
- en: This was just a small example, but it illustrates the impact of choosing an
    efficient algorithm can have on the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: We will sometimes hear people talk about smart code. What is it, and is it always
    smart to use it? Let's check it out!
  prefs: []
  type: TYPE_NORMAL
- en: Is smart code smart?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are a beginner programmer, you are happy that your programs work at
    all, and you will not pay much attention to what your code looks like or how it
    performs. The important thing is that you get the result you want on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: But as you get more experienced and learn more, you will start to embrace what
    you might consider smart solutions. A smart solution, for you, might be that you
    can rewrite 10 lines of code so that it now is done in three.
  prefs: []
  type: TYPE_NORMAL
- en: The question you always should ask yourself is whether changes that are made
    to working code improve it in any way. Only if they do will the new code be considered
    smarter than it was before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you wrote a little game in Python. It has a loop that runs 10
    times, and in each iteration, it will ask the user for a number, either `0` or
    `1`. It will also randomly pick either a `0` or a `1`. If the user guessed the
    same number as the computer picked, the user wins; otherwise, the user loses.
    The code might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – A small guessing game in Python](img/Figure_12.15_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – A small guessing game in Python
  prefs: []
  type: TYPE_NORMAL
- en: This program does not have an error checker for if the user enters a number
    other than 0 or 1, but apart from that, it works fine, and you feel happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'But then you feel it is time to code this game smarter, and you end up with
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Same program as before, written in one line](img/Figure_12.16_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – Same program as before, written in one line
  prefs: []
  type: TYPE_NORMAL
- en: When running the two programs, you won't notice any difference. But is the second
    version smarter in any way? It sure takes up fewer lines, and if we count, also
    fewer characters. But what have we gained? Will the second program run faster?
    That is a somewhat irrelevant question for this kind of application as the program
    will spend most of its time waiting for the user to enter a number.
  prefs: []
  type: TYPE_NORMAL
- en: What about readability? Just because the second program has fewer lines and
    fewer characters does not make it easier to read and understand – it is the opposite.
    Even an experienced programmer will need to spend more time understanding the
    second program compared to the first.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one reason for you to create something like the second example,
    and that is as an exercise to use language features, but that's it. Go ahead and
    make your small programs as compact as you can; you will learn a lot from it,
    but when writing code that will be used for something else, you should have readability
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are situations when small, smart tricks are in their correct places.
    Look at the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can pass an `age` to this function, and it will return `true` if this age
    is equal to or greater than `21`; if not, it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function works, but we can make it smarter, and this time the change will
    be an improvement. If we think about what is happening inside the function, we
    see that the `if` statement will compare the `age` passed to this function with
    `21`. If the `if` statement is true, we return `true`. If it is false, we return
    `false`. This means that we return the same thing as the condition evaluates to,
    so why not return that? Let''s change the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That is a smart change as we made the code more compact and easier to read and
    got rid of any unnecessary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Being smart when coding can mean different things to different people. I was
    once working on a telecom project that was written in C. There was a bug, and
    I was assigned to fix it. But when reading the code, I was horrified. I have tried
    to recreate what parts of it looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Code that is extremely hard to read](img/Figure_12.17_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Code that is extremely hard to read
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are three `if` statements nested inside each other. In
    the real example, there were at least 20 levels of nested `if` statements like
    this!
  prefs: []
  type: TYPE_NORMAL
- en: Also, the variable names are saying nothing about what data they hold. We need
    to try to figure out what values these variables will have for us in order to
    enter the innermost `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: I did spend almost 2 weeks understanding and rewriting the code before I could
    even begin searching for the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might be wondering why I am showing this example here. This can hardly
    be considered smart code. The consultant who wrote it probably thought this was
    smart. Maybe the idea was to be irreplaceable, and that can be smart from a consultant's
    point of view. But that's not smart from the point of view of the company that
    owns the code. I can also mention that if that was down to the tactics from the
    consultant's side, it did not work as he or she was no longer with this company.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever you do, never write code like this. Instead, you should keep some best
    practices for writing quality code in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Code quality – best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated earlier in this chapter, what we focus on here is the quality of the
    code, not the quality of the user experience when using our applications.
  prefs: []
  type: TYPE_NORMAL
- en: When writing code, there are some things we can keep in mind to make our code
    *better*, quality-wise.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at some best practices and talk about why it is a good idea to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting line length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Long lines are never a good idea. Look at any newspaper and think about why
    the text hardly ever runs on one line across the full width of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – A newspaper uses columns to limit the line length. Photo by
    Wan Chen on Unsplash](img/Figure_12.18_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 – A newspaper uses columns to limit the line length. Photo by Wan
    Chen on Unsplash
  prefs: []
  type: TYPE_NORMAL
- en: A rule of thumb is that if the line is wider than what can fit on the screen,
    then it is too wide. Use your common sense and divide the code into several lines
    if needed, but do so in a way that makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot. The code shown here is just one single
    statement and could have been written on a single line, but that line would have
    been very long and hard to read. Instead, it has been broken up in separate lines,
    and the line breaks occur in a natural location so that the code is easier to
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – A lengthy statement that has been broken up into several lines](img/Figure_12.19_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – A lengthy statement that has been broken up into several lines
  prefs: []
  type: TYPE_NORMAL
- en: Some programming editors will assist you in determining the maximum length of
    your code lines by showing a line to indicate when it is time to add a line break.
  prefs: []
  type: TYPE_NORMAL
- en: It is not only the length of the code lines that should be limited. Next, we
    will see that this also applies to the length of functions and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting function/method length
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A function or method should do one thing only, and they should be small. If
    your functions are hundreds of lines long, you need to make them smaller. When
    they are 50 lines long, you should probably make them even smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Long functions are hard to read, and it is hard to follow the logic as it goes
    in and out of `if` statements and loops.
  prefs: []
  type: TYPE_NORMAL
- en: There is no fixed rule for how long a function should be, but I try to keep
    my functions below 20 lines if I can.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing is not the actual line count. Instead, you should focus
    on writing code that is easy to read. To help you write your functions and methods,
    you should let logic guide you.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a long function, just by looking at it, there might be clues that
    it is made up of multiple logical blocks. The things that can be an indication
    of this is blanks lines in the code as they are often used to indicate a logical
    transition of sorts. These decided segments of code can be good candidates to
    be lifted out of the original function and instead go into a function of their
    own. We can then just call that function from the place where the code was previously.
  prefs: []
  type: TYPE_NORMAL
- en: Another hint can be code that is indented by more than one level. Each level
    of indentation marks a block of code. Look at the logic that goes on there and
    ask yourself if you can't make the code cleaner by turning these blocks into functions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing high-quality small functions is an art that takes practice to master,
    but if you don't practice, you will never master it. Get into the habit of always
    reviewing code you've written and ask yourself if the function or method you just
    wrote only does one thing.
  prefs: []
  type: TYPE_NORMAL
- en: But what is one thing? Is the game Mario Kart one thing? Is asking the user
    for their credit card number one thing? Is incrementing a number one thing?
  prefs: []
  type: TYPE_NORMAL
- en: If a function has a single task, then we might be able to break this task into
    several subtasks. We could then let the main task be a function and let this function
    call a function for each subtask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following screenshot. Here, we can see a function written in C++.
    Its task is to search a file for a specified string pattern and replace it with
    a new pattern. Instead of doing all the steps needed, it is broken up into sub-tasks,
    each located in a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – An example of a C++ function that uses other functions to
    fulfill its task](img/Figure_12.20_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – An example of a C++ function that uses other functions to fulfill
    its task
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding code, we can observe that the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will call a function that reads all the contents of the file specified
    and returns it to us as a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will call a function that will call a function called `update_content`.
    To this, we are passing the original content of the file, the string we want to
    be replaced, and the string we want to replace the old string with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function will return an updated version of the file content. This updated
    content is then saved to a file with the same name as the original file, and by
    that, the old file will be overwritten.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As the function names describe what the function is doing and the variable names
    describe what gets returned from those functions, reading this code is now very
    easy.
  prefs: []
  type: TYPE_NORMAL
- en: Reading this function will almost be like reading an index of a book. We can
    see that, first, we read the content of a file. Good – and if we trust that the
    only thing that function does is performing exactly the same thing, there is no
    need for us to go and look at that code. The same thing goes for `update_content`
    and `save_file_content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is much more readable than what it would have looked like if we had everything
    in one function. Look at the preceding screenshot once more and compare it to
    the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21 – The original update_file function](img/Figure_12.21_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – The original update_file function
  prefs: []
  type: TYPE_NORMAL
- en: When we see these two versions of the function, it is easy to understand why
    we want to reduce the function's length and let the function and variable names
    do the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the structure of the code in the preceding screenshot, we can
    see two blank lines. They divide the code into three sections, and these sections
    are what we have moved into the three functions. The first section is what became
    the `read_file_content` function. The second section became `update_content`,
    while the last section became `save_file_content`.
  prefs: []
  type: TYPE_NORMAL
- en: When we move the code sections into separate functions, we will need to modify
    the code slightly, but that is usually not hard and is done rather quickly. The
    main logic is already there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final version of all four functions will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22 – The primary function and its three helper functions](img/Figure_12.22_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.22 – The primary function and its three helper functions
  prefs: []
  type: TYPE_NORMAL
- en: If we want to, we can ignore the first three functions and just read the last
    one to get an idea of what is going on here.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we should consider is avoiding deep nesting when it comes to control
    structures, such as conditional and loop statements.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding deep nesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is sometimes tempting to put several `if` statements or `for` loops inside
    each other. But many levels of nested `if` statements or `for` loops can make
    them hard to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have an `if` statement and in its `else` part, we have a new `if`
    statement with an `else` part. This is unnecessarily complex and hard to follow.
    We can rewrite it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The two functions will give us the same result, but the second one will return
    as soon as it knows the correct amount. By doing that, it reduces the number of
    lines, avoids the nested `if` statement, and overall makes the code cleaner and
    easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: When you have nested structures that go beyond one level, you should ask yourself
    if there is a better way to do this. The first thing you can do is what we did
    here and place the control structures after each other, rather than within each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to move the logic into separate functions and call them instead.
    In some situations, this will simplify the code and make it easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing we want to avoid is repeating ourselves. To help us avoid that,
    we can use the DRY principle.
  prefs: []
  type: TYPE_NORMAL
- en: Using the DRY principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DRY** stands for **Don''t Repeat Yourself** and was formulated by Andy Hunt
    and Dave Thomas. It states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Every piece of knowledge must have a single, unambiguous, authoritative representation
    within a system."*'
  prefs: []
  type: TYPE_NORMAL
- en: This states that we should not repeat the same or similar code more than once.
    A clear indication that you are about to contradict this principle is when you
    copy and paste code to a new location in your program, maybe with only some slight
    changes. This should always be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of DRY boils down to dividing the code into small reusable parts. Let's
    look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume you have some data and that this data is stored in a dictionary
    type (you can read more about the dictionary type in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*, in the *Dictionary type* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you want to print this data to the screen, while other times, you
    want to save it to a file. You might end up with two functions that look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first function, `show`, will print the items in the dictionary on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The second function, `save`, will build a string containing all the items in
    the dictionary. It adds a line break between each item. `\n` means newline and
    is used to indicate that a linefeed should occur at this location.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both functions deal with the same data, but it might not be obvious that we
    are repeating ourselves here – at least not until we need to update the dictionary.
    Let''s say that we need to add an item to the dictionary, maybe the manufacturer.
    We would need to make changes to both functions. The new code would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the line for the manufacturer was added to both functions. What
    would happen if we forgot to add it to one of them? At some point, we will discover
    the difference, but when we do, we can't be sure if the `manufacturer` line was
    added to one function or removed from the other.
  prefs: []
  type: TYPE_NORMAL
- en: Let's apply the DRY principle to the code. If we think about what is happening,
    we will discover that the `show` function has multiple lines within `print`. We
    also know that `print` will print something on one line and then insert a line
    feed so that the next `print` will start on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: But what would happen if we had one `print` that printed a string like the one
    in the `save` function? It contains the new line indicator, `\n`, in all the locations
    where we want a new line, so printing that string will give the same result as
    our current `show` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of this and add a function that creates and returns that string,
    and then both functions can call that function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `create_data` function, which creates the string and returns
    it to the caller. It is called from both the `show` and the `save` functions.
    In `show`, the `create_string` function is called first of all, and the string
    that gets returned will be printed.
  prefs: []
  type: TYPE_NORMAL
- en: In the `save` function, we call the `create_string` function from within the
    call to a function called `save_file`. The returned string will be passed as the
    second argument to the `save_file` function, just as it was in our first version.
  prefs: []
  type: TYPE_NORMAL
- en: This also makes the code more readable and shorter.
  prefs: []
  type: TYPE_NORMAL
- en: Many languages or software companies have *scandalized* the way we format the
    code we write. This is called *code conventions*, and this is what we will look
    at next.
  prefs: []
  type: TYPE_NORMAL
- en: Using code conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most programming languages have code conventions. These are recommendations
    for how we shall organize our files, indent our code, format comments, and use
    naming conventions, just to mention a few.
  prefs: []
  type: TYPE_NORMAL
- en: These are not rules but a recommended code style and the idea is that if all
    programmers using a language use the same code convention, their code will look
    more or less the same. This means that if you know the convention, it is easier
    for you to navigate the code and read it. It is, therefore, essential to learn
    the convention for every programming language you are using.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at some typical conventions and see how they differ among a couple
    of languages.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A naming convention is a set of rules for formatting the names of variables,
    types, functions, and other entities in the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, programming languages come with official naming conventions. Other
    times, they are not official but commonly used by the community using a language.
    Some companies have developed their own naming conventions for the code written
    within that company.
  prefs: []
  type: TYPE_NORMAL
- en: A naming convention is not about how you name things, but how you format the
    names. A naming convention dictates how uppercase and lowercase characters should
    be used and how names consisting of multiple words should be formatted. Some different
    styles are frequently used. Let's look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Camel case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In camel case, each word in a multi-word name has an initial capital letter,
    except for the initial letter. For example, if we want to store a value for the
    outside temperature, the name used for that variable would be `outsideTemperature`
    in camel case.
  prefs: []
  type: TYPE_NORMAL
- en: Camel case is also known as camel caps. The name refers to the apparent humps
    that the capital letters form. One early use of this style was by the Swedish
    chemist Jöns Jacob Berzelius, who suggested, in an 1813 essay in Annals of Philosophy
    2, that chemical elements should be written as one-letter or two-letter symbols
    with the first letter capitalized. That would allow formulae such as *NaCl* to
    be written without any spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Pascal case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pascal case is like camel case, with the only difference being that the first
    letter is also written using a capital case. So, the pascal case, the outside
    temperature variable would be named `OutsideTemperature`.
  prefs: []
  type: TYPE_NORMAL
- en: Pascal case gets its name from the programming language Pascal. Even though
    Pascal is case-insensitive, the practice was popularized by the Pascal convention
    to use this style.
  prefs: []
  type: TYPE_NORMAL
- en: Snake case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In snake case, all letters are written in lowercase, and an underscore separates
    words. The outside temperature variable, when written in snake case, would be
    `outside_temperature`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snake case has been in use for a long time but did not have any established
    name. An early reference to the name *snake_case* comes from Gavin Kistner, who,
    in 2004, wrote a post named *Appropriate use of CamelCase* in the group *comp.lang.ruby
    on Usenet*. In it, he said the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"BTW...what *do* you call that naming style? snake_case? That''s what I''ll
    call it until someone corrects me."*'
  prefs: []
  type: TYPE_NORMAL
- en: Indentation conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several different styles that are used when it comes to indentation
    and how compound statements are indicated.
  prefs: []
  type: TYPE_NORMAL
- en: For languages that use braces, how the braces are placed is a never-ending debate.
    Let's look at some variants.
  prefs: []
  type: TYPE_NORMAL
- en: '**K&R style**'
  prefs: []
  type: TYPE_NORMAL
- en: The K&R style originates from the Kernighan and Ritchie book *The C Programming
    Language* from 1978.
  prefs: []
  type: TYPE_NORMAL
- en: When following this style, each function has its opening brace on a new line
    and the same indentation level as the function header.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks inside the function will have their opening brace at the same line as
    the statement they are opening.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of the K&R style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.23 – The K&R bracing style](img/Figure_12.23_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.23 – The K&R bracing style
  prefs: []
  type: TYPE_NORMAL
- en: '**1TBS**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1TBS** is an abbreviation for **one true brace style** and is a variant on
    the K&R style. The only difference is that the opening brace for functions is
    located on the same line as the function header. Also, in 1TBS, control structures
    only containing one line will always have braces, a habit not always used in the
    K&R style. See the following screenshot for an example of this style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24 – The 1TBS bracing style](img/Figure_12.24_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.24 – The 1TBS bracing style
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, a commonly accepted practice is to use the K&R style, extended so that
    all opening braces are on the same line as the statement it opens. This applies
    to control structures, classes, and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following screenshot for an example of this style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25 – The Java bracing style](img/Figure_12.25_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.25 – The Java bracing style
  prefs: []
  type: TYPE_NORMAL
- en: '**Allman style**'
  prefs: []
  type: TYPE_NORMAL
- en: The Allman style, named after the American programmer Eric Allman, puts all
    opening braces on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: People arguing for this style means that it becomes easier to see where a block
    begins and ends, when the opening and closing braces are on the same indentation
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following screenshot for an example of this style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.26 – The Allman bracing style](img/Figure_12.26_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.26 – The Allman bracing style
  prefs: []
  type: TYPE_NORMAL
- en: '**Lisp or Python style**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This style can be used in any language that uses braces, but is mostly used
    by languages that don''t use braces and use an indentation level to identify blocks
    of code instead, such as Lisp and Python. In the following screenshot, we can
    see a Lisp program that uses this style:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.27 – The Lisp block indentation style](img/Figure_12.27_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.27 – The Lisp block indentation style
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the same program written in Python,
    using the same type of indentation to mark blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.28 – The Python block indentation style](img/Figure_12.28_B15554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.28 – The Python block indentation style
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the indentation levels are part of the language. This is sometimes
    called the **offside rule**, a name coined by the British computer scientist Peter
    J. Landin, most likely as a pun on the offside rule in football, compared to languages
    that use braces, meaning indentation levels are not decided on by the language.
  prefs: []
  type: TYPE_NORMAL
- en: These are not the only conventions you will find described in a convention document.
    Next, we will look at some other things you most likely will find when reading
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Other conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other conventions might be described for a language. One thing that is often
    described in a convention document is how comments should be formatted.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages have tools that can generate documentation from the comments
    found in the code. For this to work, the comments must follow a strict format.
    Some examples of these are Java's Javadoc and Doxygen for C and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages also support special kind of comments known as **docstrings**.
    They are comments, but when regular comments are stripped away from the executable
    code by the compiler, they are retained so that the programmer can inspect them
    when the program is running.
  prefs: []
  type: TYPE_NORMAL
- en: There can also be conventions for how the source code files should be organized
    in folders and packages (to learn more about packages, see [*Chapter 4*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067),
    *Software Projects and How We Organize Our Code*, in the *Working with packages
    to share code* section). There can also be conventions in place for how to name
    files.
  prefs: []
  type: TYPE_NORMAL
- en: A code convention can also dictate the use of tabs versus spaces when we indent
    our code. Here, most conventions prefer the use of spaces over tabs, but there
    are exceptions to this.
  prefs: []
  type: TYPE_NORMAL
- en: You might also find things that are not directly related to coding and coding
    style in a coding convention document. For example, one thing that you might find
    is recommendations for source file encoding. The file encoding dictates how the
    characters in the file will be interpreted. The two most frequent encodings are
    ASCII and UTF-8\. Sometimes, there are recommendations about part of a file. The
    convention document might state that comments or string literals must use a particular
    encoding, not the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing often found in code convention documents is how blanks lines and
    spaces should be used. For example, in the official Python style guide, called
    Pep 8, it is stated that two blank lines should separate functions and methods
    within a class by one blank line, and that there should never be more than one
    blank line between code lines within a function or method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can also be recommendations regarding how to write expressions. Again,
    the Python style guide says that these lines use a recommended style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare those to the following lines, which do not follow the recommended style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The last convention we will cover here, which can also be found in code conventions,
    is how long lines should be break up long lines into several lines.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when working with a long line that contains binary operators (such
    as +, -. *, and /), we can break up these operators, but what would happen if
    the operator appears as the last character on a line or as the first on the next
    one?
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, compare it to this variant, where the operators are moved to the next
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The American computer scientist Donald Knuth states, in his book *The TeXbook*
    from 1984, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Although formulas within a paragraph always break after binary operations
    and relations, displayed formulas always break before binary operations and relations."*'
  prefs: []
  type: TYPE_NORMAL
- en: This would suggest that when a formula is printed, it is always printed in the
    form shown in the second example. This is not a universal truth, though. If you
    read mathematical texts, you will find both forms represented, and sometimes even
    a third form where the operator is both at the end of the line and the beginning
    of the next.
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes, this argument by Knuth is used to recommend the form where the
    operator begins a line over the one where it comes at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Different conventions are a topic most programmers have an opinion about. Still,
    if there is one in place, either for the language you are using or the project
    you are working on, you should stick to it, even if it contradicts what you think
    is a good way of writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have reached the end of this journey into programming,
    and you now know what it takes to write quality code that is efficient and easy
    to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about the fact that we have two aspects of quality when it comes to
    software – one being the quality of the code and the other being quality from
    the user's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: We then turned our attention to how to achieve code quality. First, we talked
    about how we can create readable code and how this will improve the code's overall
    quality.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we looked at how efficient code, which is code that efficiently
    uses the computer's resources, will improve the quality of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Smart coding tricks are not always the smart way to write code if code quality
    is something we value. We saw some examples of things we should avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at some best practices that we can use to increase the quality
    of the code we write.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we have come to the end of the main chapters of the book. I hope
    you have enjoyed this journey as much as I have. I have tried to put together
    everything that is relevant and important from a beginner's point of view, and
    I am sure many of you will benefit from it.
  prefs: []
  type: TYPE_NORMAL
