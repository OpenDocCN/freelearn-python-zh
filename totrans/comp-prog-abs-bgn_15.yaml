- en: '*Chapter 12:* Code Quality'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章：代码质量*'
- en: There are many aspects of code quality. We can talk about efficient code, which
    is code that runs fast or doesn't waste resources such as memory. It can also
    be source code that is easy to read and understand for us humans and therefore
    is easy to read and maintain. In this chapter, we'll talk about this and look
    at some best practices for writing high-quality code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量有许多方面。我们可以谈论高效的代码，这是运行速度快或不会浪费资源（如内存）的代码。它也可以是易于我们人类阅读和理解的源代码，因此也易于阅读和维护。在本章中，我们将讨论这一点，并查看编写高质量代码的一些最佳实践。
- en: We will also look at some examples of things we should try to avoid if we want
    to write high-quality code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看一些示例，如果我们想编写高质量的代码，我们应该尽量避免的事情。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Understanding what code quality is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码质量是什么
- en: Writing readable code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可读的代码
- en: Writing efficient code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写高效的代码
- en: Understanding that smart code is not always smart
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解智能代码并不总是智能
- en: Understanding some of the best practices for writing quality code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编写高质量代码的一些最佳实践
- en: Before we learn how to write quality code, we should define what code quality
    is.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习如何编写高质量的代码之前，我们应该定义代码质量是什么。
- en: Defining code quality
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义代码质量
- en: It is tough to define the meaning of quality when it comes to program code.
    The reason is that all developers will have their own opinion of what it means.
    One developer can argue that we should focus on writing readable code as it will
    be easier to understand and maintain and, by that, reduce the chance of us inserting
    any bugs into the code. Another developer could argue that we shall focus on writing
    compact code; that is, as few code lines as possible. Even if the code is harder
    to read, less code will give us fewer chances to introduce bugs in the code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到程序代码时，定义质量的含义是困难的。原因是所有开发者都会对它有自己的看法。一位开发者可能会争辩说，我们应该专注于编写可读的代码，因为它更容易理解和维护，从而减少我们向代码中插入任何错误的机会。另一位开发者可能会争辩说，我们应该专注于编写紧凑的代码；也就是说，尽可能少的代码行。即使代码难以阅读，更少的代码也会给我们更少的在代码中引入错误的机会。
- en: Here, the two developers would argue for the same thing – fewer bugs in the
    code – with two contradictory positions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两位开发者会为同样的事情——代码中的错误更少——而争论，但他们的立场是矛盾的。
- en: Let's look at a small example using Python as our language. We want to create
    a list that holds all possible combinations we can get by rolling two dice.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个小的例子来看看，我们使用Python作为我们的语言。我们想要创建一个列表，它包含通过掷两个骰子可以得到的所有可能的组合。
- en: 'The first one will use more code, but it will be easier to understand:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个将使用更多的代码，但更容易理解：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On the first line, we create an empty list.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建一个空列表。
- en: Then, we have a `for` loop for the first dice. The `d1` variable will get the
    value `1` the first iteration, `2` the second, and so on. Remember that the end
    value, `7`, is when it will stop, so this is `7`, not `6`, as it will stop when
    it reaches this, giving us the values 1 to 6\.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个用于第一个骰子的`for`循环。`d1`变量在第一次迭代时将获得值`1`，第二次迭代时获得值`2`，依此类推。记住，结束值`7`是它停止的时候，所以这是`7`，而不是`6`，因为它会在达到这个值时停止，给我们的是1到6的值。
- en: We will then do the same kind of loop for the second dice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将对第二个骰子执行同样的循环。
- en: On the last line, we will insert the values of `d1` and `d2` into the list.
    Having an extra pair of parentheses on appending the values will put them in what
    is called a `d1` and `d2` belong together as one combination.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们将`d1`和`d2`的值插入到列表中。在追加值时多加一个额外的括号，将它们放入所谓的`d1`和`d2`属于一个组合。
- en: 'We can accomplish the same things with a single line of code. It will look
    like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一行代码完成同样的事情。它看起来像这样：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, the second example has less code but at the cost of readability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，第二个例子代码更少，但牺牲了可读性。
- en: But who is right – the developer arguing for readability or the one arguing
    for less code? We can't say, as they both are right.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但谁是对的——是主张可读性的开发者还是主张代码更少的开发者？我们无法说，因为他们都是对的。
- en: What we need is a better definition of what code quality is, and more importantly,
    it should be measurable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个更好的定义，即代码质量是什么，更重要的是，它应该是可衡量的。
- en: Many efforts to define a model for measuring code quality have been made, and
    one of the better known is CISQ's quality model. We'll see what that is next.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 已经做出了许多努力来定义一个衡量代码质量的模型，其中之一是CISQ的质量模型。我们将在下一节中看到它是什么。
- en: CISQ's quality model
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CISQ的质量模型
- en: 'The **Consortium for Information Software Quality** (**CISQ**) has defined
    five rules that can be used to measure the quality of code. It was first defined
    with business software in mind but was later extended to also include embedded
    systems, used mainly in **Internet of Things** (**IoT**) applications. These rules
    are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息软件质量联盟**（**CISQ**）已经定义了五条规则，可以用来衡量代码的质量。它最初是针对商业软件而定义的，但后来扩展到也包括嵌入式系统，主要用于**物联网**（**IoT**）应用程序。以下规则如下：'
- en: '**Reliability**: Reliability measures the level of risk and the likelihood
    of failures. It will also measure the defects that are injected into existing
    code when it is updated or modified. The goal of measuring reliability is to prevent
    the time an application can''t run because of severe bugs.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：可靠性衡量风险水平和失败的可能性。它还将衡量在代码更新或修改时注入现有代码中的缺陷。衡量可靠性的目标是防止应用程序因严重错误而无法运行的时间。'
- en: '**Performance efficiency**: When an application is running, the speed with
    which it performs its operations depends on how the code is written and structured.
    Measuring the efficiency at a code level will help to improve both the overall
    response time of an application and how we identify the potential risk of applications
    that need to process data at a high speed that fail as they fail to process data
    fast enough.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能效率**：当应用程序运行时，它执行操作的速度取决于代码的编写和结构。在代码级别上测量效率将有助于提高应用程序的整体响应时间以及我们识别需要高速处理数据的应用程序潜在风险的能力。'
- en: '**Security**: The security rule will measure the likelihood of potential security
    breaches due to poor coding practices.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：安全规则将衡量由于不良编码实践而可能发生的潜在安全漏洞的可能性。'
- en: '**Maintainability**: When we are talking about the maintainability of code,
    we usually refer to three things. We say that the code should be, namely, *adaptable*,
    which is code that we can adapt to changes as per the requirements; *portable*,
    which is code that can be used on different platforms, such as different operating
    systems; and *transferable*, which is code that can be transferred from one development
    team to another.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：当我们谈论代码的可维护性时，我们通常指的是三个方面。我们说代码应该是，即，*可适应的*，这意味着代码可以按照需求进行适应性的改变；*可移植的*，这意味着代码可以在不同的平台上使用，例如不同的操作系统；以及*可转移的*，这意味着代码可以从一个开发团队转移到另一个团队。'
- en: This can be applied to, more or less, all code, but we want to be able to do
    all three of these with as little effort as possible.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以应用于，或多或少，所有代码，但我们希望尽可能少地付出努力来完成这三件事。
- en: '**Size**: Size is not a quality attribute per se, but the size of the code
    can have an impact on its maintainability. The more code we have, the harder it
    will be to navigate, understand, and follow its logic.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规模**：规模本身并不是一个质量属性，但代码的规模可能会影响其可维护性。我们拥有的代码越多，就越难导航、理解和遵循其逻辑。'
- en: We have now talked about the quality aspects regarding code. But what about
    quality from the user's perspective?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论了关于代码的质量方面。但用户视角的质量又如何呢？
- en: Understanding user quality
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解用户质量
- en: What the CISQ model focuses very little on is quality from the user's perspective.
    An application can match all the CISQ rules, but a user of this application may
    still consider it being of poor quality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: CISQ模型非常关注的是从用户的角度来看的质量。一个应用程序可以符合所有CISQ规则，但使用这个应用程序的用户仍然可能认为它的质量很差。
- en: Dr. Tom DeMarco, an American software engineer, has proposed that *a product's
    quality is a function of how much it changes the world for the better.*
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 美国软件工程师汤姆·德马克博士提出，*一个产品的质量是它改善世界的程度的一个函数*。
- en: This statement can be interpreted as meaning that an application's functional
    quality and user satisfaction are more important than the structural quality of
    the code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话可以解释为，一个应用程序的功能质量和用户满意度比代码的结构质量更重要。
- en: The American computer scientist Gerald Weinberg has said that *Quality is value
    to some person*. This implies that quality is subjective – what one person would
    define as quality in an application might be the opposite for another person.
    This view will focus on asking the questions *Who are the people that want to
    value our software?* and *What will be valuable to them?*
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 美国计算机科学家杰拉尔德·温伯格曾经说过，*质量是对于某些人的价值*。这表明质量是主观的——一个人可能会将某个应用程序的质量定义为质量，而另一个人可能会认为它是相反的。这种观点将专注于提出以下问题：*谁是我们想要评价我们软件的人？*以及*对他们来说什么是有价值的？*
- en: With these definitions in mind, we will start to realize that crafting software
    is much more than just writing code. Even if the code has excellent quality, if
    the users don't like what we have created, they will not use it. It is like if
    we build a chair using the best craftsmanship, but if it is incredibly uncomfortable,
    no one will buy it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些定义的指导下，我们开始意识到，制作软件远不止是编写代码。即使代码质量很高，如果用户不喜欢我们创造的东西，他们也不会使用它。这就像如果我们用最好的工艺制作了一把椅子，但如果它非常不舒服，没有人会买它。
- en: We must, therefore, understand our users and their needs. Doing so is not always
    easy as our potential users might not know about these needs. Before you had your
    first smartphone, you did not miss it as you did not know what it could offer
    you. Now, on the other hand, you would miss it just after a few hours if it was
    taken away from you.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须了解我们的用户和他们的需求。这样做并不总是容易的，因为我们的潜在用户可能不知道这些需求。在你拥有第一台智能手机之前，你并没有觉得缺少它，因为你不知道它能提供什么。另一方面，如果你在几个小时后失去它，你可能会立刻觉得缺少它。
- en: To get to the point where we understand our user's needs before they understand
    it, we need to use our imagination. We can start by asking some simple questions.
    They could be, what problem will this application solve? Who will benefit from
    it? Is there a pattern that the people who will benefit from using this application
    have in common? What kind of applications does this group already use? Are there
    features, patterns, or ideas used in those applications that we can reuse in our
    application to make this group more familiar with how our application works from
    the start?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到在我们理解用户需求之前他们就已经理解的需求，我们需要发挥想象力。我们可以从问一些简单的问题开始。它们可能是，这个应用程序将解决什么问题？谁会从中受益？受益于使用这个应用程序的人是否有共同的模式？这个群体已经使用了什么类型的应用程序？在这些应用程序中使用的功能、模式或想法，我们能否在我们的应用程序中重用，以便使这个群体一开始就对我们的应用程序的工作方式更加熟悉？
- en: When we have an idea about who our future users might be, we will need to focus
    on the flow within the application. We all know how frustrating it is when we
    use a program, or any other product for that matter, and we can't figure out what
    to do. We try one thing after the other, and rather soon, we lose all interest
    in using it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了关于我们未来用户可能是谁的想法时，我们需要关注应用程序内的流程。我们都知道，当我们使用一个程序或任何其他产品时，如果我们不知道该做什么，是多么令人沮丧。我们尝试了一件事又一件，很快，我们就失去了使用它的兴趣。
- en: If you invest time and money in developing something, you should at least give
    that great idea of yours every chance to succeed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你投入时间和金钱去开发某样东西，你至少应该给你的这个伟大想法每一个成功的机会。
- en: Great! We now have an idea of what code quality is and we also understand the
    quality aspects from a user perspective. I am sure you want both in your software,
    so let's put them together.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在对代码质量有了概念，我们也从用户的角度理解了质量方面。我相信你肯定希望你的软件两者兼备，所以让我们把它们结合起来。
- en: Putting them together
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将它们结合起来
- en: If we think about it, the art of creating quality software is, of course, neither
    writing code with high quality nor writing an application that the users find
    valuable; it is both.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，创造高质量软件的艺术当然既不是用高质量编写代码，也不是编写用户认为有价值的应用程序；它两者都是。
- en: As we have seen in earlier chapters, applications that are used will be updated,
    modified, and extended. This means that the code needs to be read by other programmers
    (or by us) if we want to find where changes need to be made.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，被使用的应用程序将会被更新、修改和扩展。这意味着如果我们要找到需要更改的地方，代码需要被其他程序员（或我们自己）阅读。
- en: It will all boil down to a question about money. We want to create software
    that gives our users added value and we can sell our application. But maybe even
    more important is that the programmers that maintain the code of the application
    can work efficiently. If they can find a bug quickly, they will spend less time
    fixing it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的一切都将归结为一个关于金钱的问题。我们希望创建的软件能为我们的用户提供额外的价值，并且我们可以销售我们的应用程序。但也许更重要的是，维护应用程序代码的程序员可以高效地工作。如果他们能快速找到错误，他们将花费更少的时间来修复它。
- en: If the code is easy to read and understand, the programmers will also have a
    higher chance of avoiding inserting new bugs into the code, thus reducing the
    cost of fixing them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码易于阅读和理解，程序员也有更高的可能性避免在代码中插入新的错误，从而减少修复它们的成本。
- en: One problem many programmers will face is that they are not given the time needed
    to create the quality code they want and that can be understood. Tight time schedules,
    managers who don't fully understand the importance of well-crafted code, and impatient
    customers can all be aspects that will force programmers to produce code quickly,
    resulting in a loss of quality. This is, of course, a very short-term approach.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员将面临的一个问题是，他们没有足够的时间来创建他们想要的、易于理解的优质代码。时间紧迫、不完全理解精心编写的代码重要性的经理，以及不耐烦的客户，所有这些因素都可能迫使程序员快速编写代码，从而导致质量下降。这当然是一种非常短期的做法。
- en: You might ship the software faster, but with lower quality, both for the users
    and for the programmers who will need to maintain the code in the future. This
    will most likely be less cost-efficient than crafting high-quality code to begin
    with.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会更快地交付软件，但质量会降低，这对用户和未来需要维护代码的程序员来说都是如此。这很可能比一开始就编写高质量的代码成本效益更低。
- en: It should also be noted that if we start a project with poorly written code,
    this project will most likely always contain low-quality code as the cost of going
    back and improving all the code will be too high.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应当注意的是，如果我们用一个编写得不好的项目开始，这个项目很可能始终会包含低质量的代码，因为回过头来改进所有代码的成本将太高。
- en: We have everything to win if we do a good job and write quality code and deliver
    software that is considered high quality by our users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们做得好，编写高质量的代码，并交付用户认为高质量的软件，我们就有一切可以赢得胜利。
- en: The rest of this chapter will not focus on user quality. That does not mean
    that it's not essential, but this is a book about writing code, so let's see how
    we can do that with quality and style.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将不会关注用户质量。这并不意味着它不是必要的，但这是一本关于编写代码的书，所以让我们看看我们如何以质量和风格来做到这一点。
- en: Writing code with readability in mind
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑可读性编写代码
- en: Code that you write will not only be executed by the computer. It will also
    be read both by yourself and by others. Therefore, is it essential that you write
    code that is as easy to read and understand as possible.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你所编写的代码不仅会被计算机执行。它还将被你自己和他人阅读。因此，编写尽可能易于阅读和理解的代码是至关重要的。
- en: There are some simple rules we can follow that will assist in achieving readable
    code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遵循一些简单的规则，以帮助实现可读的代码。
- en: Using comments and documentation wisely
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聪明地使用注释和文档
- en: When creating code, you need an understanding what you do and why you do it.
    But when coming back to your code a couple of months later, it is not always as
    clear what these thoughts were and why you wrote things the way you did. Commenting
    on tricky lines of code is a great way to document your thoughts for both your
    future self and others that will read your code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，你需要理解你做什么以及你为什么这样做。但是，当你几个月后回到你的代码时，这些想法并不总是那么清晰，你为什么以这种方式编写代码。对复杂的代码行进行注释是记录你的想法的好方法，既是为了你自己的未来，也是为了将来阅读你代码的其他人。
- en: But comments can also make the code less readable. Never comment on things that
    are obvious – things that any programmer, including yourself, will understand.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，注释也可能使代码的可读性降低。永远不要对明显的事情进行注释——任何程序员，包括你自己，都会理解的事情。
- en: You should use comments when you look at a line of code and understand that
    a reader who sees this line will need to stop and think before understanding what
    it does.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到一行代码并理解到看到这一行的读者需要停下来思考才能理解它的作用时，你应该使用注释。
- en: Commenting on functions and methods is often a good idea. These comments will
    usually come right before the function or method or as the first thing inside
    it. What you should use depends on what language you are using, as well as the
    conventions used by programmers of that language.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对函数和方法进行注释通常是个好主意。这些注释通常就在函数或方法之前，或者作为它里面的第一件事。你应该使用什么取决于你使用的语言，以及该语言程序员使用的约定。
- en: 'In the following screenshot, we can see an example of this for a JavaScript
    function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到一个JavaScript函数的例子：
- en: '![Figure 12.1 – Documenting a JavaScript function](img/Figure_12.1_B15554.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 记录一个JavaScript函数](img/Figure_12.1_B15554.jpg)'
- en: Figure 12.1 – Documenting a JavaScript function
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 记录一个JavaScript函数
- en: 'The following is what we can infer from the preceding code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以从前面的代码中推断出的内容：
- en: The first text line in this comment describes the overall responsibility of
    this function. Then, using the predefined `@param` name, the meaning of the two
    parameters are documented.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此注释的第一行文本中，描述了此函数的整体职责。然后，使用预定义的 `@param` 名称，记录了两个参数的含义。
- en: Within the curly braces, the data type that is expected is defined. This is
    especially important if the language we are using is dynamically typed. A dynamically
    typed language will accept any type we assign to a variable, rather than using
    only the type we specify. JavaScript is dynamically typed, so this will assist
    any programmers using this function.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大括号内，定义了期望的数据类型。如果我们使用的语言是动态类型的，这一点尤为重要。动态类型的语言将接受我们分配给变量的任何类型，而不是只使用我们指定的类型。JavaScript
    是动态类型的，因此这将帮助任何使用此函数的程序员。
- en: After that comes the name of the parameter (table and headers).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是参数的名称（表格和标题）。
- en: Then, after a dash, we will document what this parameter is used for.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在破折号之后，我们将记录此参数的用途。
- en: Many editors used by programmers can use this documentation if formatted correctly.
    The format we can see here is called JSDoc.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员使用的编辑器如果格式正确，都可以使用这种文档。我们在这里可以看到的格式被称为 JSDoc。
- en: 'In the following screenshot, we can see that when we write the code that will
    call this function, the editor can show us the information that was found in this
    comment:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图里，我们可以看到当我们编写将要调用此函数的代码时，编辑器可以显示在此注释中找到的信息：
- en: '![Figure 12.2 – Programming editor showing data from the function documentation](img/Figure_12.2_B15554.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 显示函数文档数据的编程编辑器](img/Figure_12.2_B15554.jpg)'
- en: Figure 12.2 – Programming editor showing data from the function documentation
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 显示函数文档数据的编程编辑器
- en: Comments are not the only way we can document our code. We can also let the
    code be partly self-documenting by naming things nicely.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注释并不是我们记录代码的唯一方式。我们也可以通过给事物起好名字，让代码部分自文档化。
- en: Using names as documentation
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用名称作为文档
- en: 'By naming variables and functions wisely, the names by themselves will act
    as documentation. Look at the following function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过明智地命名变量和函数，名称本身就可以作为文档。看看以下函数：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have a function that will download a web page and extract all the links
    found on that page. When we call this function, we pass the address to the page
    we want to extract the links from. That address is stored in the `url` parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个将下载网页并提取该页面上找到的所有链接的函数。当我们调用此函数时，我们传递要从中提取链接的页面的地址。该地址存储在 `url` 参数中。
- en: Inside, a function called `download_page` is called. As the name describes clearly
    what that function does, when reading the code, there is no need for us to go
    to that function to understand what it does. The variable that receives the returned
    data is called `page`, so we understand what data it holds.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，调用了名为 `download_page` 的函数。正如其名称清楚地描述了该函数的功能，在阅读代码时，我们不需要去那个函数了解它做什么。接收返回数据的变量被称为
    `page`，因此我们了解它包含什么数据。
- en: We can see the same thing on the next line. If a function is called `extract_links`,
    we can assume that is what that function does. We store the data we get back in
    a variable called `links`, so our assumption seems to be right.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在下一行看到相同的内容。如果一个函数被命名为 `extract_links`，我们可以假设这就是该函数的功能。我们将获取的数据存储在一个名为 `links`
    的变量中，所以我们的假设似乎是正确的。
- en: The function names will almost act like a table of content when reading this
    function. We understand what happens there, and we can go there if we want, but
    there is no need to do so just to learn what it does. The idea of a table of content
    in a book is that you will both learn what a chapter is about and learn where
    to find it. The same thing applies here. If we name our functions well, they will
    let us know what they do. Most integrated development environments will let us
    click the name, which means we will be taken to that function if we want to read
    it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当阅读此函数时，函数名称几乎就像一个目录。我们了解那里发生了什么，如果我们想了解，我们可以去那里，但不需要这样做只是为了了解它做什么。一本书的目录的想法是，你将了解章节的内容，并了解如何找到它。这里也是同样的道理。如果我们给函数起一个好名字，它们将让我们知道它们做什么。大多数集成开发环境都允许我们点击名称，这意味着如果我们想阅读它，我们会被带到那个函数。
- en: Later in this chapter, in the *Limiting function/method length* section, we
    will learn more about how to use this technique.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，在*限制函数/方法长度*这一节中，我们将学习更多关于如何使用这项技术的知识。
- en: To be able to understand what good code looks like, we must see both good and
    bad code. Therefore, to become a good programmer, we must read code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够理解什么样的代码是好的，我们必须看到好的和坏的代码。因此，要成为一名优秀的程序员，我们必须阅读代码。
- en: Reading other people's code
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读他人的代码
- en: As a beginner programmer, the best thing we can do is read code written by experienced
    developers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名初学者程序员，我们能做的最好的事情就是阅读经验丰富的开发者编写的代码。
- en: A good source is open source projects. Experienced programmers develop these
    projects, and their code is available online for anyone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的来源是开源项目。经验丰富的程序员开发这些项目，他们的代码在网上对任何人都是可用的。
- en: Pick any project, preferably in the same language you are using. At first, approaching
    such a project might be overwhelming as there will be maybe hundreds of files
    structured in several folders. But take your time and poke around in this file
    structure. Maybe the most important thing is not to understand the file structure
    of the project, but just looking at the code and trying to understand parts of
    it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 选择任何项目，最好是使用你正在使用的相同语言。一开始，接近这样的项目可能会感到不知所措，因为可能会有成百上千个文件分布在几个文件夹中。但请慢慢来，在这个文件结构中探索。也许最重要的事情不是理解项目的文件结构，而是看看代码并尝试理解其中的部分。
- en: This will give you an insight into how experienced programmers structure their
    code. It should be noted that all senior developers will not always do a perfect
    job, but most of the time, the code you can see here would be considered to be
    of relatively high quality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让你了解经验丰富的程序员是如何组织他们的代码的。需要注意的是，并不是所有的高级开发者都会总是做得完美，但大多数时候，你在这里看到的代码会被认为是相对高质量的。
- en: 'If you look at code written by a beginner programmer and compare it with the
    code written by an experienced one, you will see the difference. Now, refer to
    the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看初学者编写的代码并与经验丰富的程序员编写的代码进行比较，你会看到差异。现在，参考以下代码：
- en: '![Figure 12.3 – A program that was written by a beginner programmer](img/Figure_12.3_B15554.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 由初学者程序员编写的程序](img/Figure_12.3_B15554.jpg)'
- en: Figure 12.3 – A program that was written by a beginner programmer
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 由初学者程序员编写的程序
- en: Look at the preceding program. It is written in C# and will ask the user for
    a sentence. It will then calculate the number of characters, not counting spaces,
    that the user entered and finally calculate and print the average number of characters
    of the words in the sentence.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的程序。它是用C#编写的，会要求用户输入一个句子。然后它会计算用户输入的字符数（不计空格），并最终计算并打印句子中单词的平均字符数。
- en: 'This code has many characteristics of a beginner programmer. I have been teaching
    programming for 30 years and this is not, by far, the worst example I have seen.
    Now, refer to the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码具有初学者程序员的许多特征。我教授编程已经有30年了，这绝对不是我所见过的最糟糕的例子。现在，参考以下代码：
- en: '![Figure 12.4 – The same program shown previously, written by an experienced
    programmer](img/Figure_12.4_B15554.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 前面展示的由经验丰富的程序员编写的相同程序](img/Figure_12.4_B15554.jpg)'
- en: Figure 12.4 – The same program shown previously, written by an experienced programmer
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 前面展示的由经验丰富的程序员编写的相同程序
- en: 'Now, compare the code we provided at the start of this section with the code
    shown in the preceding screenshot, which is the very same program written by an
    experienced programmer. A user of these two programs will not be able to tell
    any difference. Executing both will produce an output like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将本节开头提供的代码与前面截图中的代码进行比较，这是由经验丰富的程序员编写的完全相同的程序。使用这两个程序的用户将无法察觉任何差异。执行这两个程序将产生如下输出：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the user's perspective, we can say that the quality of the two programs
    is identical.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，我们可以这样说，这两个程序的质量是相同的。
- en: 'But the quality of the code is not identical at all. Let''s list some of the
    differences:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但代码的质量并不完全相同。让我们列出一些差异：
- en: The first version – written by a beginner programmer – does not use any indentation,
    making the code very compact and hard to read.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个版本——由初学者程序员编写的——没有使用任何缩进，这使得代码非常紧凑且难以阅读。
- en: The first version does not use any blank lines, while in the other version,
    the blank lines divide the code into sections.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个版本没有使用任何空白行，而另一个版本中的空白行将代码分成几个部分。
- en: In the first version, the `newScen` variable is assigned values, but it is never
    used, so it can be removed from the program.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个版本中，`newScen`变量被赋值，但它从未被使用，因此可以从程序中删除。
- en: In the first version, the variable `names` do not reflect what they are storing.
    In the second version, the `myScen` variable is renamed to `sentence`, `n` is
    renamed to `word`, and `countedWords` is renamed to `averageCharCount`.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个版本中，变量`names`并没有反映它们所存储的内容。在第二个版本中，将`myScen`变量重命名为`sentence`，将`n`重命名为`word`，将`countedWords`重命名为`averageCharCount`。
- en: The first version is using a `for` loop to count all the characters except spaces.
    In the second version, a language-specific construct is used to do the same thing
    on a single line.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个版本使用了一个`for`循环来计算所有非空格字符。在第二个版本中，使用了一种特定语言的构造来在单行上完成相同的事情。
- en: The first version declares all the variables at the beginning of the `main`
    method. In the second version, they are declared when they are first used.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个版本在`main`方法的开头声明了所有变量。在第二个版本中，它们是在首次使用时声明的。
- en: The first version uses some other unnecessary code, such as `Convert.ToString`
    on line 16, and some of the comments do not add any new knowledge to the reader
    of the code.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个版本使用了一些其他不必要的代码，例如第16行的`Convert.ToString`，以及一些注释并没有给代码的读者带来任何新的知识。
- en: Even if you don't understand the code, just looking at it reveals that the second
    version is much more pleasant to look at.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不理解代码，仅仅看一眼就能发现第二个版本看起来要愉快得多。
- en: Also, note that even though the second program introduced blank lines in the
    code, the number of lines dropped from 31 to 22.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，尽管第二个程序在代码中引入了空白行，但行数从31行减少到了22行。
- en: As a beginner programmer, you are very focused on getting things to work, and
    you should. But when you get there and your program is working, you should go
    back and look at your code and think about how you can raise the quality. Maybe
    you won't come up with the same one-line solutions the experienced programmer
    is using, but at least you can use blank lines, indentation, and sensible variable
    names.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名初级程序员，你非常专注于让事情工作，你应该这样做。但是当你到达那里，你的程序正在运行时，你应该回头看看你的代码，并思考如何提高代码质量。也许你不会提出像资深程序员那样的单行解决方案，但至少你可以使用空白行、缩进和有意义的变量名。
- en: To be able to learn to write high-quality code, you will need to be exposed
    to it, which is why reading code written by senior developers will help you write
    better code. Don't forget that when you do read it, try to understand as much
    as you can about the code you are reading. It might be a slow process, but it
    is not like reading a book – you don't have to read all the code there is. Take
    a function or a method and focus on only the code you find there. A good source
    to go to is the Stack Overflow website, where programmers can ask questions and
    other programmers will answer them. Go to [https://stackoverflow.com/](https://stackoverflow.com/)
    and look around. You can filter the questions so that you will only see questions
    related to the language you are interested in. Focus on the answers, as the people
    who answer these questions are often very experienced and their code is often
    of high quality. You can, of course, also use this site to ask your own programming
    questions, and who knows – soon, you might be answering some too.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要学会编写高质量的代码，你需要接触它，这就是为什么阅读资深开发者编写的代码将帮助你写出更好的代码。不要忘记，当你阅读时，尽量理解你正在阅读的代码。这可能是一个缓慢的过程，但并不像读书——你不需要阅读那里所有的代码。一个好的资源是Stack
    Overflow网站，程序员可以在这里提问，其他程序员会回答他们。访问[https://stackoverflow.com/](https://stackoverflow.com/)并四处看看。你可以过滤问题，这样你只会看到与你感兴趣的编程语言相关的问题。专注于答案，因为回答这些问题的人通常经验丰富，他们的代码通常质量很高。当然，你也可以使用这个网站来提问你自己的编程问题，谁知道呢——很快，你可能也会回答一些问题。
- en: Rewriting your code
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新编写你的代码
- en: As we saw in the previous example, just making the program work is not enough.
    When it does, we shall go back and look at the code we just wrote to see if we
    can restructure it to make it more pleasant to look at and read, and maybe come
    up with a better solution to the problem we are trying to solve.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的例子中所看到的，仅仅让程序工作是不够的。当它运行时，我们应该回头看看我们刚刚编写的代码，看看我们是否可以重构它，使其更易于查看和阅读，也许还能为我们要解决的问题想出更好的解决方案。
- en: An excellent way to tackle a programming task is first to come up with a working
    solution, and then when you have it, work on it and tweak it to make it better.
    This will not only result in better code quality, but you will also learn from
    it, and the next time you face a similar problem, you will start with a better
    first solution.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 解决编程任务的绝佳方式是首先提出一个可行的解决方案，然后当你有了它，就着手改进它，使其变得更好。这不仅会导致代码质量更高，你也会从中学习，下次你面对类似问题时，你将从一个更好的初始解决方案开始。
- en: This is why an experienced programmer will not start with something like what
    was shown in *Figure 12.3*, but with something closer to what was shown in *Figure
    12.4*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么经验丰富的程序员不会从像*图12.3*中展示的那样开始，而是从更接近*图12.4*中展示的内容开始。
- en: Going back to the code you have written will make you look at it with fresh
    eyes, and you will see things that you did not see when you first wrote the code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你编写的代码会使你以全新的视角看待它，你将看到你在第一次编写代码时没有看到的东西。
- en: Letting your code go through several iterations will be beneficial in more than
    one way. Hopefully, it will give you higher quality code. You also understand
    the problem your code is trying to solve better because if you process the problem
    in your head and work on a solution, you will gain a broader and more in-depth
    understanding of the problem itself and how it could be solved.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的代码经过几次迭代将带来多方面的好处。希望这能给你带来更高质量的代码。你也会更好地理解你的代码试图解决的问题，因为如果你在脑海中处理这个问题并努力寻找解决方案，你将获得对问题本身及其解决方式的更广泛和更深入的理解。
- en: You will also improve your language and programming skills as you will need
    to learn more about the language you are using, in order to use the right features
    the language has to offer for this problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你需要了解更多关于你所使用的语言的知识，以便使用该语言提供的正确功能来解决这个问题，你的语言和编程技能也将得到提高。
- en: Even programmers who have used a language for years will discover things they
    had no idea existed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是使用了一种语言多年的程序员也会发现一些他们以前不知道存在的事情。
- en: With more experience, you will also recognize patterns in the problems you are
    solving and the code you are writing. As you do, the process of rewriting your
    code will be faster. Not only will you come up with improved ideas quicker, but
    your code will also start at a higher level to begin with.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着经验的积累，你也会在解决你遇到的问题和编写的代码中识别出模式。当你这样做的时候，重写代码的过程将会更快。你不仅会更快地提出改进的想法，而且你的代码将从更高的起点开始。
- en: Always have readability as your primary focus when rewriting your code. Sometimes,
    you need to sacrifice readability to make the code more efficient or faster, but
    if it is your primary goal, this will be reflected in your code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写代码时，始终将可读性作为你的首要关注点。有时，你可能需要牺牲可读性来使代码更高效或更快，但如果这是你的主要目标，这将在你的代码中得到体现。
- en: 'When you look at your code, you should always ask yourself the most fundamental
    question: Is this code I would like to read if someone else wrote it?'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看你的代码时，你应该始终问自己最基本的问题：如果别人写了这段代码，我会愿意阅读它吗？
- en: If the answer is no, change it so you can answer yes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是“不”，那么就修改它，以便你能回答“是”。
- en: Readable code is excellent, but the code should be efficient too.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可读的代码是极好的，但代码也应该是高效的。
- en: Writing code with efficiency in mind
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑效率编写代码
- en: When we talk about efficient code, we can mean several different things. Let's
    look at some of the things people might mean when they talk about efficient code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论高效的代码时，我们可以意味着几件不同的事情。让我们看看人们在谈论高效代码时可能意味着的一些事情。
- en: Removing redundant or unnecessary code
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除冗余或不必要的代码
- en: You should always make sure that you remove redundant code. Redundant code is
    code that does not affect the output of the application, but will be executed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终确保你移除冗余的代码。冗余的代码是指不影响应用程序输出的代码，但会被执行。
- en: 'Look at the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we created a variable, `number`, and set it to `10`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个变量`number`，并将其设置为`10`。
- en: Then, we have a `for` loop. This loop will iterate 999 times. The first time
    this happens, the `i` variable will have a value of `1`; the second time, it will
    be `2`, and so on until it reaches `1000`. Then, we will exit the loop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个`for`循环。这个循环将迭代999次。第一次发生这种情况时，`i`变量将具有`1`的值；第二次，它将是`2`，以此类推，直到达到`1000`。然后，我们将退出循环。
- en: Each time we're inside the loop, we will take whatever value the variable number
    currently has, add the current value of `i` to it, and store the result in the
    `number` variable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们进入循环时，我们将取变量`number`当前具有的任何值，将其与当前的`i`值相加，并将结果存储在`number`变量中。
- en: After we exit the loop, we assign the value `20` to the `variable` number, and
    by doing that, we will overwrite the value we just calculated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们退出循环之后，我们将值`20`赋给变量`number`，通过这样做，我们将覆盖我们刚刚计算出的值。
- en: This means that everything we did before the line where we assigned `20` to
    `number` is unnecessary. Deleting those lines will not have any effect on the
    output of the program, but when we run the application, this unnecessary loop
    will run, and by that, consume some resources and waste time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在我们将`20`赋给`number`之前的所有操作都是不必要的。删除这些行不会对程序的输出有任何影响，但当我们运行应用程序时，这个不必要的循环将会运行，从而消耗一些资源并浪费时间。
- en: Having code like this will also make the code harder to read as we will spend
    some time trying to figure out what the loop does and why it is there.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的代码会使代码更难以阅读，因为我们将会花一些时间去弄清楚循环做了什么以及为什么会有这个循环。
- en: With the unnecessary code removed, we can now see how we can use the computer's
    hardware more efficiently.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 移除不必要的代码后，我们现在可以看到如何更有效地使用计算机的硬件。
- en: Optimizing the use of memory and processors
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化内存和处理器使用
- en: It is easy to waste memory without even knowing it. Depending on what language
    you use, memory will be handled differently.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易在不经意间浪费内存。根据你使用的语言，内存的处理方式会有所不同。
- en: There might also be features in your programming language that will use the
    computer hardware in a more efficient way than the first solution you come up
    with. Let's look at one example from Python.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你的编程语言可能也有一些特性，它们会比你的第一个解决方案更有效地使用计算机硬件。让我们看看Python中的一个例子。
- en: 'In this example, we will concatenate strings together using two different techniques.
    In the first version, we will use the `+` operator to concatenate them. We will
    repeat this 2 million times and measure how long it takes. Refer to the following
    code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用两种不同的技术来连接字符串。在第一个版本中，我们将使用`+`运算符来连接它们。我们将重复这个操作两百万次，并测量它所需的时间。参考以下代码：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s see how this code works:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码是如何工作的：
- en: On the two first lines, we create two variables, `s1` and `s2`, that hold the
    two strings we want to concatenate.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前两行，我们创建了两个变量`s1`和`s2`，它们分别保存我们要连接的两个字符串。
- en: On the third line, we create a variable called `result`, which, initially, is
    an empty string.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第三行，我们创建了一个名为`result`的变量，它最初是一个空字符串。
- en: We then enter our loop, which will iterate 2 million times. The underscore after
    `for` is there because we won't need a variable to hold the current iteration
    value (which is 0 the first iteration, 1 for the second, and so on).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们进入循环，这个循环将会迭代两百万次。`for`后面的下划线是因为我们不需要一个变量来保存当前的迭代值（第一次迭代时是0，第二次迭代时是1，依此类推）。
- en: Each time we're inside the loop, we take what is currently in the `result` variable
    and add it together with the content of the `s1` and `s2` variables.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次我们进入循环时，我们会取当前`result`变量中的内容，并将其与`s1`和`s2`变量的内容相加。
- en: 'After the first iteration, `result` will contain the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代之后，`result`将包含以下内容：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the second iteration, it will contain the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次迭代之后，它将包含以下内容：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result, after 2 million iterations, will be a string that is 32 million
    characters long!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在两百万次迭代之后，结果将是一个包含3200万个字符的字符串！
- en: Now, let's create the same application but use another technique for concatenating
    the strings. This is not as easy to understand, and don't worry if you don't get
    how the code works.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个相同的应用程序，但使用另一种技术来连接字符串。这可能不容易理解，如果你不理解代码，请不要担心。
- en: 'Python has something called the **string join** method. It is designed to join
    strings together in a very efficient way. The code for the program looks like
    this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个叫做**字符串连接**的方法。它被设计成以非常高效的方式连接字符串。程序的代码看起来像这样：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This program will also iterate 2 million times, concatenate the two strings
    together, and produce a string that is 32 million characters long.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序也将迭代两百万次，将两个字符串连接起来，并生成一个包含3200万个字符的字符串。
- en: The first program we wrote took about 42 seconds to complete on my computer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的第一个程序在我的电脑上完成大约需要42秒。
- en: The second program will, on the same machine, complete in 0.34 seconds.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一台机器上，第二个程序将在0.34秒内完成。
- en: Adding two strings together as many times as we did here is, of course, not
    something we do very often, but these two programs illustrate the impact of choosing
    one solution instead of another.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如此多次将两个字符串相加，当然不是我们经常做的事情，但这两个程序说明了选择一种解决方案而不是另一种解决方案的影响。
- en: It is not only language constructs such as the one we saw here that can also
    improve the performance of our applications. Choosing the right algorithm can
    also have a significant impact on speed and memory usage.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅是我们刚才看到的语言结构可以改善我们应用程序的性能，选择正确的算法也可以对速度和内存使用产生重大影响。
- en: Using efficient algorithms
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高效的算法
- en: An algorithm is a solution to a problem. The algorithm will describe the logical
    steps needed to get something done. Let's look at an example. If we have a sequence
    of numbers and we want this sequence sorted, we can use a sorting algorithm. We
    have several algorithms to choose from, and all will get the job done; that is,
    sorting a sequence.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是解决问题的解决方案。算法将描述完成某事所需的逻辑步骤。让我们看看一个例子。如果我们有一系列数字，我们想要对这个序列进行排序，我们可以使用排序算法。我们有几种算法可供选择，并且所有算法都能完成任务；也就是说，对序列进行排序。
- en: The reason we have more than one algorithm is that they are more or less effective
    when it comes to speed and usage of memory. How hard it is to write the code that
    implements the algorithm will also differ.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以有多个算法，是因为它们在速度和内存使用方面或多或少是有效的。编写实现算法的代码有多难也会有所不同。
- en: 'Let''s look at one of the easiest sorting algorithms to implement: bubble sort.
    It is also one of the least effective algorithms, as we will see:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最容易实现的一种排序算法：冒泡排序。它也是最无效的算法之一，正如我们将看到的：
- en: '[PRE9]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Look at the code and see if you understand what it does. I will not go through
    the details of it. Instead, we will go through the bubble sort algorithm step
    by step. After we have done that, you can come back to the code and try to figure
    out what is happening here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码，看看你是否理解它做了什么。我不会详细讲解它。相反，我们将一步一步地讲解冒泡排序算法。在我们这样做之后，你可以回到代码中，尝试弄清楚这里发生了什么。
- en: 'The sequence we will work with looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的序列看起来是这样的：
- en: '[PRE10]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s look at the logic of bubble sort:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看冒泡排序的逻辑：
- en: In the following image, you can see a graphical representation of the sequence
    we are working on:![Figure 12.5 – The sequence to be sorted](img/Figure_12.5_B15554.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的图像中，你可以看到我们正在处理的序列的图形表示：![图12.5 – 要排序的序列](img/Figure_12.5_B15554.jpg)
- en: Figure 12.5 – The sequence to be sorted
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.5 – 要排序的序列
- en: Bubble sort will start by comparing the first two values – in our case, **5**
    and **3** – as shown in the following image:![Figure 12.6 – Comparing the first
    two values](img/Figure_12.6_B15554.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冒泡排序将从比较前两个值开始 – 在我们的例子中，是**5**和**3**，如下面的图像所示：![图12.6 – 比较前两个值](img/Figure_12.6_B15554.jpg)
- en: Figure 12.6 – Comparing the first two values
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.6 – 比较前两个值
- en: 'If they are not in the right order, they will be swapped. As they are out of
    order, **3** will be moved to the first position, while **5** will be moved to
    the second, resulting in the following sequence:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果它们不是按正确的顺序排列，它们将会被交换。由于它们顺序错误，**3** 将被移动到第一个位置，而**5** 将被移动到第二个位置，结果序列如下：
- en: '![Figure 12.7 – The values 5 and 3 swap places](img/Figure_12.7_B15554.jpg)'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图12.7 – 5和3交换位置](img/Figure_12.7_B15554.jpg)'
- en: Figure 12.7 – The values 5 and 3 swap places
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.7 – 5和3交换位置
- en: Next, **5** and **1** will be compared, and again get swapped if they're not
    in order, as shown in the following image:![Figure 12.8 – Comparing 5 and 1](img/Figure_12.8_B15554.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，**5** 和 **1** 将会被比较，如果它们不是按顺序排列的，那么它们会被再次交换，如下面的图像所示：![图12.8 – 比较5和1](img/Figure_12.8_B15554.jpg)
- en: Figure 12.8 – Comparing 5 and 1
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.8 – 比较5和1
- en: 'They are not in the correct order, so they get swapped, as shown here:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们不在正确的顺序中，所以它们会被交换，如下所示：
- en: '![Figure 12.9 – The values 5 and 1 swap places](img/Figure_12.9_B15554.jpg)'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图12.9 – 5和1交换位置](img/Figure_12.9_B15554.jpg)'
- en: Figure 12.9 – The values 5 and 1 swap places
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.9 – 5和1交换位置
- en: Now, **5** and **8** are compared, but as they are in the right order, nothing
    is done, as shown in the following image:![Figure 12.10 – The values 5 and 8 are
    in the right order](img/Figure_12.10_B15554.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**5** 和 **8** 将会被比较，但由于它们是按正确顺序排列的，所以什么也没有做，如下面的图像所示：![图12.10 – 5和8顺序正确](img/Figure_12.10_B15554.jpg)
- en: Figure 12.10 – The values 5 and 8 are in the right order
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.10 – 5和8顺序正确
- en: 'Then, **8** and **2** will be compared, as follows:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，**8** 和 **2** 将会被比较，如下所示：
- en: '![Figure 12.11 – The values 8 and 2 are compared](img/Figure_12.11_B15554.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 比较8和2的值](img/Figure_12.11_B15554.jpg)'
- en: Figure 12.11 – The values 8 and 2 are compared
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 比较8和2的值
- en: 'They will be swapped as they are out of order, as shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它们将按照顺序错误进行交换，如下所示：
- en: '![Figure 12.12 – The values 8 and 2 swap places](img/Figure_12.12_B15554.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – 8和2的值交换位置](img/Figure_12.12_B15554.jpg)'
- en: Figure 12.12 – The values 8 and 2 swap places
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 8和2的值交换位置
- en: We have now reached the end of the sequence and, as you can see, it is not sorted.
    But one item is sorted, and that is the value 8\. As this is the largest value
    in the sequence, it has been pushed to the end, and by that, it has reached its
    correct location.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达序列的末尾，如您所见，它并没有排序。但有一个项目是排序好的，那就是值8。由于这是序列中最大的值，它已经被推到末尾，并且通过这种方式，它已经到达了正确的位置。
- en: This is where the name of the algorithm comes from, since one value has bubbled
    to the end.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是算法名称的由来，因为有一个值冒泡到了末尾。
- en: At this point, the algorithm will start over, comparing the first two values
    and swapping them if necessary. This time, though, the last value – 8, in our
    case – will not be part of the comparison as it has already found its place.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，算法将重新开始，比较前两个值，并在必要时进行交换。不过，这次最后一个值 – 在我们的例子中是8 – 将不会参与比较，因为它已经找到了自己的位置。
- en: 'After the second round, the sequence will look as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二轮之后，序列将看起来如下：
- en: '![Figure 12.13 – The sequence after two rounds](img/Figure_12.13_B15554.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 – 两轮后的序列](img/Figure_12.13_B15554.jpg)'
- en: Figure 12.13 – The sequence after two rounds
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 两轮后的序列
- en: 5 and 8 are now in the correct location (marked with a thicker border), and
    the algorithm will start over again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 5和8现在位于正确的位置（用较粗的边框标记），算法将重新开始。
- en: 'In the third run, the values **1**, **3**, and **2** will be considered, and
    after that run, the sequence will look as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次运行中，将考虑值**1**、**3**和**2**，在那次运行之后，序列将看起来如下：
- en: '![Figure 12.14 – The sequence after three rounds](img/Figure_12.14_B15554.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图12.14 – 三轮后的序列](img/Figure_12.14_B15554.jpg)'
- en: Figure 12.14 – The sequence after three rounds
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 三轮后的序列
- en: As we can see, the sequence is now sorted, but the algorithm will pass over
    the remaining values once more. It will discover that it could go over them without
    swapping any values, and this means that the sequence is sorted, and we are done.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，序列现在已排序，但算法将再次遍历剩余的值。它将发现可以不交换任何值就遍历它们，这意味着序列已排序，我们完成了。
- en: The reason bubble sort is inefficient is because it will go over the sequence
    multiple times. In fact, in the worst case, it will need to do as many passes
    as there are items. For a short sequence such as this one, this isn't a problem,
    but for a larger sequence, it will be noticeable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 冒泡排序效率低下的原因是它需要多次遍历序列。实际上，在最坏的情况下，它可能需要执行与项目数量一样多的遍历。对于如此短的序列，这并不是问题，但对于较长的序列，这将是明显的。
- en: Other sorting algorithms are much more efficient, but they're harder to write
    code for. Examples of these include Quicksort and Merge sort. We will not cover
    how they work here as they are somewhat complicated. If you want to know more
    about these algorithms, you can do a web search – you will find lots of useful
    resources that will explain how they work and give you readymade code for them
    in any programming language you want.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其他排序算法效率更高，但编写代码更困难。这些算法的例子包括快速排序和归并排序。我们在这里不会介绍它们的工作原理，因为它们相对复杂。如果您想了解更多关于这些算法的信息，可以进行网络搜索
    – 您将找到许多有用的资源，它们将解释它们的工作原理，并为您提供任何编程语言中现成的代码。
- en: If we compare bubble sort and Quicksort, we will see the difference. On my computer,
    bubble sort sorted a sequence of 10,000 values in 9.8 seconds. Quicksort managed
    to sort the same sequence in 0.03 seconds.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较冒泡排序和快速排序，我们将看到差异。在我的电脑上，冒泡排序在9.8秒内对10,000个值的序列进行了排序。快速排序设法在0.03秒内对相同的序列进行了排序。
- en: The reason Quicksort and Merge sort will do better in most cases is that they
    will need to perform fewer operations. It should also be noted that bubble sort
    can beat the others if the sequence is sorted or almost sorted to begin with.
    If we have a sorted sequence, bubble sort will go through it once and discover
    that it is sorted and stop.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序和归并排序在大多数情况下表现更好，原因在于它们需要执行的操作更少。还应注意的是，如果序列一开始就是排序或几乎排序好的，冒泡排序可能会打败其他排序算法。如果我们有一个已排序的序列，冒泡排序只需遍历一次就能发现它是排序好的，然后停止。
- en: This was just a small example, but it illustrates the impact of choosing an
    efficient algorithm can have on the performance of your application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个小的例子，但它说明了选择一个高效的算法对你的应用程序性能可能产生的影响。
- en: We will sometimes hear people talk about smart code. What is it, and is it always
    smart to use it? Let's check it out!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时会听到人们谈论聪明的代码。那是什么，使用它总是聪明的吗？让我们来看看！
- en: Is smart code smart?
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聪明的代码就是聪明的吗？
- en: When you are a beginner programmer, you are happy that your programs work at
    all, and you will not pay much attention to what your code looks like or how it
    performs. The important thing is that you get the result you want on the screen.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你是一个初学者程序员时，你会很高兴你的程序能正常运行，你不会太在意你的代码看起来如何或它的性能如何。重要的是你能在屏幕上得到你想要的结果。
- en: But as you get more experienced and learn more, you will start to embrace what
    you might consider smart solutions. A smart solution, for you, might be that you
    can rewrite 10 lines of code so that it now is done in three.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但是随着你越来越有经验，学到越来越多，你将开始接受你可能认为的聪明解决方案。对你来说，一个聪明的解决方案可能就是你可以重写10行代码，使其现在只需要三行。
- en: The question you always should ask yourself is whether changes that are made
    to working code improve it in any way. Only if they do will the new code be considered
    smarter than it was before.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你始终应该问自己的问题是，对正在运行的代码所做的更改是否以任何方式改进了它。只有当它们这样做时，新的代码才会被认为比之前更聪明。
- en: 'Imagine that you wrote a little game in Python. It has a loop that runs 10
    times, and in each iteration, it will ask the user for a number, either `0` or
    `1`. It will also randomly pick either a `0` or a `1`. If the user guessed the
    same number as the computer picked, the user wins; otherwise, the user loses.
    The code might look as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你用Python写了一个小游戏。它有一个循环，运行10次，每次迭代都会要求用户输入一个数字，要么是`0`要么是`1`。它也会随机选择一个`0`或`1`。如果用户猜对了计算机选择的数字，用户就赢了；否则，用户就输了。代码可能看起来如下：
- en: '![Figure 12.15 – A small guessing game in Python](img/Figure_12.15_B15554.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15 – 一个简单的Python猜数字游戏](img/Figure_12.15_B15554.jpg)'
- en: Figure 12.15 – A small guessing game in Python
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 一个简单的Python猜数字游戏
- en: This program does not have an error checker for if the user enters a number
    other than 0 or 1, but apart from that, it works fine, and you feel happy.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序没有检查用户输入除0或1以外的数字的错误检查器，但除此之外，它运行良好，你感到很高兴。
- en: 'But then you feel it is time to code this game smarter, and you end up with
    something like the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后你觉得是时候用更聪明的代码来编写这个游戏了，结果你得到了以下类似的东西：
- en: '![Figure 12.16 – Same program as before, written in one line](img/Figure_12.16_B15554.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图12.16 – 与之前相同的程序，但只用一行编写](img/Figure_12.16_B15554.jpg)'
- en: Figure 12.16 – Same program as before, written in one line
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – 与之前相同的程序，但只用一行编写
- en: When running the two programs, you won't notice any difference. But is the second
    version smarter in any way? It sure takes up fewer lines, and if we count, also
    fewer characters. But what have we gained? Will the second program run faster?
    That is a somewhat irrelevant question for this kind of application as the program
    will spend most of its time waiting for the user to enter a number.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这两个程序时，你不会注意到任何区别。但第二个版本在某种程度上更聪明吗？它确实占用的行数更少，如果我们计算，字符也更少。但我们得到了什么？第二个程序会运行得更快吗？对于这类应用程序来说，这是一个有些不相关的问题，因为程序将花费大部分时间等待用户输入数字。
- en: What about readability? Just because the second program has fewer lines and
    fewer characters does not make it easier to read and understand – it is the opposite.
    Even an experienced programmer will need to spend more time understanding the
    second program compared to the first.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性如何？仅仅因为第二个程序有更少的行和字符，并不意味着它更容易阅读和理解——恰恰相反。即使是经验丰富的程序员，也需要比第一个程序更多的时间来理解第二个程序。
- en: There is only one reason for you to create something like the second example,
    and that is as an exercise to use language features, but that's it. Go ahead and
    make your small programs as compact as you can; you will learn a lot from it,
    but when writing code that will be used for something else, you should have readability
    in mind.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建类似第二个例子这样的东西只有一个原因，那就是作为一个练习来使用语言特性，但仅此而已。继续努力让你的小程序尽可能紧凑；你会从中学到很多东西，但当你编写将被用于其他目的的代码时，你应该考虑到可读性。
- en: 'There are situations when small, smart tricks are in their correct places.
    Look at the following function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，小而聪明的技巧确实处于正确的位置。看看以下函数：
- en: '[PRE11]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can pass an `age` to this function, and it will return `true` if this age
    is equal to or greater than `21`; if not, it will return `false`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向这个函数传递一个`age`，如果这个年龄等于或大于`21`，它将返回`true`；如果不等于，它将返回`false`。
- en: 'This function works, but we can make it smarter, and this time the change will
    be an improvement. If we think about what is happening inside the function, we
    see that the `if` statement will compare the `age` passed to this function with
    `21`. If the `if` statement is true, we return `true`. If it is false, we return
    `false`. This means that we return the same thing as the condition evaluates to,
    so why not return that? Let''s change the function:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是有效的，但我们可以让它更聪明，这次的变化将是一个改进。如果我们考虑函数内部发生的事情，我们会看到`if`语句将比较传递给这个函数的`age`与`21`。如果`if`语句为真，我们返回`true`。如果它是假的，我们返回`false`。这意味着我们返回与条件评估相同的东西，所以为什么不直接返回那个值呢？让我们改变这个函数：
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That is a smart change as we made the code more compact and easier to read and
    got rid of any unnecessary code.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个聪明的改变，因为我们使代码更加紧凑，更容易阅读，并去除了任何不必要的代码。
- en: 'Being smart when coding can mean different things to different people. I was
    once working on a telecom project that was written in C. There was a bug, and
    I was assigned to fix it. But when reading the code, I was horrified. I have tried
    to recreate what parts of it looked like:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时聪明意味着对不同的人有不同的含义。我曾经在一个用C语言编写的电信项目中工作。那里有一个错误，我被分配去修复它。但是当我阅读代码时，我感到非常震惊。我试图重新创建它的部分样子：
- en: '![Figure 12.17 – Code that is extremely hard to read](img/Figure_12.17_B15554.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图12.17 – 极难阅读的代码](img/Figure_12.17_B15554.jpg)'
- en: Figure 12.17 – Code that is extremely hard to read
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 – 极难阅读的代码
- en: As you can see, there are three `if` statements nested inside each other. In
    the real example, there were at least 20 levels of nested `if` statements like
    this!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有三个嵌套的`if`语句。在真实例子中，至少有20层这样的嵌套`if`语句！
- en: Also, the variable names are saying nothing about what data they hold. We need
    to try to figure out what values these variables will have for us in order to
    enter the innermost `if` statement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变量名并没有说明它们所持有的数据。我们需要试图弄清楚这些变量将为我们提供什么值，以便进入最内层的`if`语句。
- en: I did spend almost 2 weeks understanding and rewriting the code before I could
    even begin searching for the bug.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实花了将近两周的时间来理解和重写代码，然后我才能开始寻找错误。
- en: Now, you might be wondering why I am showing this example here. This can hardly
    be considered smart code. The consultant who wrote it probably thought this was
    smart. Maybe the idea was to be irreplaceable, and that can be smart from a consultant's
    point of view. But that's not smart from the point of view of the company that
    owns the code. I can also mention that if that was down to the tactics from the
    consultant's side, it did not work as he or she was no longer with this company.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道为什么我要在这里展示这个例子。这几乎不能被认为是聪明的代码。写这个代码的顾问可能认为这是聪明的。也许想法是变得不可替代，从顾问的角度来看这可能很聪明。但从拥有代码的公司角度来看，这并不聪明。我还可以提到，如果这是顾问方面的策略，它并没有奏效，因为顾问或顾问已经不再在这个公司了。
- en: Whatever you do, never write code like this. Instead, you should keep some best
    practices for writing quality code in mind.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你做什么，永远不要编写这样的代码。相反，你应该记住一些编写高质量代码的最佳实践。
- en: Code quality – best practices
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码质量 – 最佳实践
- en: As stated earlier in this chapter, what we focus on here is the quality of the
    code, not the quality of the user experience when using our applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，我们关注的是代码的质量，而不是我们应用的用户体验的质量。
- en: When writing code, there are some things we can keep in mind to make our code
    *better*, quality-wise.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，有一些事情我们可以记住，以使我们的代码在质量上更**好**。
- en: We will look at some best practices and talk about why it is a good idea to
    use them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些最佳实践，并讨论为什么使用它们是个好主意。
- en: Limiting line length
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制行长度
- en: 'Long lines are never a good idea. Look at any newspaper and think about why
    the text hardly ever runs on one line across the full width of the page:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 长行从来都不是一个好主意。看看任何报纸，想想为什么文本几乎不会在整页宽度上单行运行：
- en: '![Figure 12.18 – A newspaper uses columns to limit the line length. Photo by
    Wan Chen on Unsplash](img/Figure_12.18_B15554.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图12.18 – 一份报纸使用栏来限制行长度。照片由Wan Chen在Unsplash上拍摄](img/Figure_12.18_B15554.jpg)'
- en: Figure 12.18 – A newspaper uses columns to limit the line length. Photo by Wan
    Chen on Unsplash
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 – 一份报纸使用栏来限制行长度。照片由Wan Chen在Unsplash上拍摄
- en: A rule of thumb is that if the line is wider than what can fit on the screen,
    then it is too wide. Use your common sense and divide the code into several lines
    if needed, but do so in a way that makes sense.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是，如果一行比屏幕能显示的宽度还要宽，那么它就太宽了。使用你的常识，如果需要，将代码分成几行，但要以一种有意义的方式进行。
- en: 'Take a look at the following screenshot. The code shown here is just one single
    statement and could have been written on a single line, but that line would have
    been very long and hard to read. Instead, it has been broken up in separate lines,
    and the line breaks occur in a natural location so that the code is easier to
    read:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图。这里显示的代码只是一条单独的语句，本可以写在一行上，但那行会非常长且难以阅读。相反，它已经被拆分成单独的行，并且换行符出现在自然的位置，使得代码更容易阅读：
- en: '![Figure 12.19 – A lengthy statement that has been broken up into several lines](img/Figure_12.19_B15554.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图12.19 – 被拆分成多行的长语句](img/Figure_12.19_B15554.jpg)'
- en: Figure 12.19 – A lengthy statement that has been broken up into several lines
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 – 被拆分成多行的长语句
- en: Some programming editors will assist you in determining the maximum length of
    your code lines by showing a line to indicate when it is time to add a line break.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程编辑器会通过显示一条线来帮助你确定代码行的最大长度，这条线会在需要添加换行符时出现。
- en: It is not only the length of the code lines that should be limited. Next, we
    will see that this also applies to the length of functions and methods.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅应该限制代码行的长度。接下来，我们将看到这也适用于函数和方法的长度的限制。
- en: Limiting function/method length
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制函数/方法长度
- en: A function or method should do one thing only, and they should be small. If
    your functions are hundreds of lines long, you need to make them smaller. When
    they are 50 lines long, you should probably make them even smaller.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 函数或方法应该只做一件事，并且它们应该是小的。如果你的函数有几百行长，你需要将它们变小。当它们有50行长时，你可能需要将它们做得更小。
- en: Long functions are hard to read, and it is hard to follow the logic as it goes
    in and out of `if` statements and loops.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 长函数难以阅读，而且很难跟随逻辑在`if`语句和循环中进进出出。
- en: There is no fixed rule for how long a function should be, but I try to keep
    my functions below 20 lines if I can.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 函数应该有多长并没有固定的规则，但只要可能，我会尽量让我的函数保持在20行以下。
- en: The important thing is not the actual line count. Instead, you should focus
    on writing code that is easy to read. To help you write your functions and methods,
    you should let logic guide you.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是实际的行数并不是关键。相反，你应该专注于编写易于阅读的代码。为了帮助你编写函数和方法，你应该让逻辑引导你。
- en: If you have a long function, just by looking at it, there might be clues that
    it is made up of multiple logical blocks. The things that can be an indication
    of this is blanks lines in the code as they are often used to indicate a logical
    transition of sorts. These decided segments of code can be good candidates to
    be lifted out of the original function and instead go into a function of their
    own. We can then just call that function from the place where the code was previously.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个长函数，仅通过看它，可能就有线索表明它由多个逻辑块组成。可以作为这种指示的可能是代码中的空白行，因为它们通常被用来表示某种逻辑过渡。这些确定的代码段可以是很好的候选者，可以从原始函数中提取出来，并放入一个自己的函数中。然后我们只需从代码之前的位置调用该函数即可。
- en: Another hint can be code that is indented by more than one level. Each level
    of indentation marks a block of code. Look at the logic that goes on there and
    ask yourself if you can't make the code cleaner by turning these blocks into functions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提示是超过一个级别的缩进代码。每个缩进级别标记一个代码块。看看那里的逻辑，并问问自己你是否可以通过将这些块转换为函数来使代码更干净。
- en: Writing high-quality small functions is an art that takes practice to master,
    but if you don't practice, you will never master it. Get into the habit of always
    reviewing code you've written and ask yourself if the function or method you just
    wrote only does one thing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 编写高质量的小函数是一种需要练习才能掌握的艺术，但如果你不练习，你就永远无法掌握它。养成总是回顾你所写代码的习惯，并问问自己你刚刚编写的函数或方法是否只做了一件事。
- en: But what is one thing? Is the game Mario Kart one thing? Is asking the user
    for their credit card number one thing? Is incrementing a number one thing?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但什么是一件事？马里奥赛车游戏是一件事吗？请求用户输入他们的信用卡号码是一件事吗？增加一个数字是一件事吗？
- en: If a function has a single task, then we might be able to break this task into
    several subtasks. We could then let the main task be a function and let this function
    call a function for each subtask.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数只有一个任务，那么我们可能能够将这个任务分解成几个子任务。然后我们可以让主任务成为一个函数，并让这个函数为每个子任务调用一个函数。
- en: 'Look at the following screenshot. Here, we can see a function written in C++.
    Its task is to search a file for a specified string pattern and replace it with
    a new pattern. Instead of doing all the steps needed, it is broken up into sub-tasks,
    each located in a separate function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 查看下面的截图。在这里，我们可以看到一个用 C++ 编写的函数。它的任务是搜索文件中的指定字符串模式并将其替换为新模式。它不是执行所有必要的步骤，而是将其分解成子任务，每个子任务都位于一个单独的函数中：
- en: '![Figure 12.20 – An example of a C++ function that uses other functions to
    fulfill its task](img/Figure_12.20_B15554.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20 – 使用其他函数完成任务的 C++ 函数示例](img/Figure_12.20_B15554.jpg)'
- en: Figure 12.20 – An example of a C++ function that uses other functions to fulfill
    its task
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 – 使用其他函数完成任务的 C++ 函数示例
- en: 'From the preceding code, we can observe that the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以观察到以下内容：
- en: First, we will call a function that reads all the contents of the file specified
    and returns it to us as a string.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将调用一个函数，该函数读取指定文件的全部内容，并将其作为字符串返回给我们。
- en: Next, we will call a function that will call a function called `update_content`.
    To this, we are passing the original content of the file, the string we want to
    be replaced, and the string we want to replace the old string with.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将调用一个函数，该函数将调用一个名为 `update_content` 的函数。为此，我们传递了文件的原内容、我们想要替换的字符串以及我们想要用新字符串替换旧字符串的字符串。
- en: This function will return an updated version of the file content. This updated
    content is then saved to a file with the same name as the original file, and by
    that, the old file will be overwritten.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数将返回文件内容的更新版本。然后，这个更新内容将被保存到与原始文件同名的文件中，从而覆盖旧文件。
- en: As the function names describe what the function is doing and the variable names
    describe what gets returned from those functions, reading this code is now very
    easy.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如函数名称所描述的那样，函数执行了什么操作，变量名称描述了从这些函数返回了什么，现在阅读这段代码变得非常容易。
- en: Reading this function will almost be like reading an index of a book. We can
    see that, first, we read the content of a file. Good – and if we trust that the
    only thing that function does is performing exactly the same thing, there is no
    need for us to go and look at that code. The same thing goes for `update_content`
    and `save_file_content`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这个函数几乎就像阅读一本书的目录。我们可以看到，首先，我们读取了一个文件的内容。很好 – 如果我们相信那个函数只执行完全相同的事情，我们就没有必要去查看那段代码。对于
    `update_content` 和 `save_file_content` 也是如此。
- en: 'This is much more readable than what it would have looked like if we had everything
    in one function. Look at the preceding screenshot once more and compare it to
    the following one:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这比如果我们将所有内容都放在一个函数中要容易阅读得多。再次查看前面的截图，并与以下截图进行比较：
- en: '![Figure 12.21 – The original update_file function](img/Figure_12.21_B15554.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图12.21 – 原始的 update_file 函数](img/Figure_12.21_B15554.jpg)'
- en: Figure 12.21 – The original update_file function
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 – 原始的 update_file 函数
- en: When we see these two versions of the function, it is easy to understand why
    we want to reduce the function's length and let the function and variable names
    do the documentation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到这两个函数版本时，很容易理解为什么我们想要缩短函数的长度，并让函数和变量名称来做文档。
- en: If we look at the structure of the code in the preceding screenshot, we can
    see two blank lines. They divide the code into three sections, and these sections
    are what we have moved into the three functions. The first section is what became
    the `read_file_content` function. The second section became `update_content`,
    while the last section became `save_file_content`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前面截图中的代码结构，我们可以看到两个空白行。它们将代码分成三个部分，这些部分就是我们移动到三个函数中的部分。第一部分变成了 `read_file_content`
    函数。第二部分变成了 `update_content`，而最后一部分变成了 `save_file_content`。
- en: When we move the code sections into separate functions, we will need to modify
    the code slightly, but that is usually not hard and is done rather quickly. The
    main logic is already there.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将代码部分移动到单独的函数中时，我们需要稍微修改一下代码，但这通常并不困难，而且完成得相当快。主要逻辑已经在那里了。
- en: 'The final version of all four functions will look something like the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 所有四个函数的最终版本将看起来像以下这样：
- en: '![Figure 12.22 – The primary function and its three helper functions](img/Figure_12.22_B15554.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图12.22 – 主要函数及其三个辅助函数](img/Figure_12.22_B15554.jpg)'
- en: Figure 12.22 – The primary function and its three helper functions
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 – 主要函数及其三个辅助函数
- en: If we want to, we can ignore the first three functions and just read the last
    one to get an idea of what is going on here.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以忽略前三个函数，只阅读最后一个函数，以了解这里发生了什么。
- en: Another thing we should consider is avoiding deep nesting when it comes to control
    structures, such as conditional and loop statements.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑避免在控制结构（如条件语句和循环语句）中深层嵌套。
- en: Avoiding deep nesting
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免深层嵌套
- en: It is sometimes tempting to put several `if` statements or `for` loops inside
    each other. But many levels of nested `if` statements or `for` loops can make
    them hard to read and understand.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，人们会倾向于在函数内部嵌套多个`if`语句或`for`循环。但多层嵌套的`if`语句或`for`循环会使它们难以阅读和理解。
- en: 'Look at the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码：
- en: '[PRE13]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we have an `if` statement and in its `else` part, we have a new `if`
    statement with an `else` part. This is unnecessarily complex and hard to follow.
    We can rewrite it like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`if`语句，在其`else`部分，我们有一个带有`else`部分的新`if`语句。这是不必要的复杂，难以理解。我们可以这样重写它：
- en: '[PRE14]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The two functions will give us the same result, but the second one will return
    as soon as it knows the correct amount. By doing that, it reduces the number of
    lines, avoids the nested `if` statement, and overall makes the code cleaner and
    easier to read.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将给出相同的结果，但第二个函数将在知道正确数量后立即返回。通过这样做，它减少了行数，避免了嵌套的`if`语句，并使代码更简洁、更容易阅读。
- en: When you have nested structures that go beyond one level, you should ask yourself
    if there is a better way to do this. The first thing you can do is what we did
    here and place the control structures after each other, rather than within each
    other.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有多层嵌套的结构时，你应该问自己是否有更好的方法来做这件事。你可以做的第一件事就是在这里我们所做的，将控制结构依次放置，而不是嵌套在一起。
- en: Another option is to move the logic into separate functions and call them instead.
    In some situations, this will simplify the code and make it easier to read.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是将逻辑移动到单独的函数中，并调用它们。在某些情况下，这将简化代码并使其更容易阅读。
- en: Another thing we want to avoid is repeating ourselves. To help us avoid that,
    we can use the DRY principle.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望避免重复。为了帮助我们避免这种情况，我们可以使用DRY原则。
- en: Using the DRY principle
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DRY原则
- en: '**DRY** stands for **Don''t Repeat Yourself** and was formulated by Andy Hunt
    and Dave Thomas. It states the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRY**代表**不要重复自己**，由Andy Hunt和Dave Thomas提出。它陈述如下：'
- en: '*"Every piece of knowledge must have a single, unambiguous, authoritative representation
    within a system."*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*"系统内每条知识都必须有一个单一、明确、权威的表示。"*'
- en: This states that we should not repeat the same or similar code more than once.
    A clear indication that you are about to contradict this principle is when you
    copy and paste code to a new location in your program, maybe with only some slight
    changes. This should always be avoided.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们不应该重复相同的或类似的代码超过一次。当你将代码复制粘贴到程序中的新位置，可能只有一些细微的变化时，这是一个明显的迹象表明你即将违反这一原则。这应该始终避免。
- en: The idea of DRY boils down to dividing the code into small reusable parts. Let's
    look at an example.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: DRY的原则可以归结为将代码分成小块可重用的部分。让我们看看一个例子。
- en: Let's assume you have some data and that this data is stored in a dictionary
    type (you can read more about the dictionary type in [*Chapter 6*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091),
    *Working with Data – Variables*, in the *Dictionary type* section).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一些数据，并且这些数据存储在字典类型中（你可以在[*第6章*](B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091)，*处理数据
    – 变量*，*字典类型*部分中了解更多关于字典类型的信息）。
- en: 'Sometimes, you want to print this data to the screen, while other times, you
    want to save it to a file. You might end up with two functions that look as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能想将此数据打印到屏幕上，而有时，你可能想将其保存到文件中。你可能会得到如下所示的两个函数：
- en: '[PRE15]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first function, `show`, will print the items in the dictionary on the screen.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数，`show`，将在屏幕上打印字典中的项目。
- en: The second function, `save`, will build a string containing all the items in
    the dictionary. It adds a line break between each item. `\n` means newline and
    is used to indicate that a linefeed should occur at this location.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数，`save`，将构建一个包含字典中所有项目的字符串。它在每个项目之间添加一个换行符。`\n`表示换行符，用于表示在此位置应该发生换行。
- en: 'Both functions deal with the same data, but it might not be obvious that we
    are repeating ourselves here – at least not until we need to update the dictionary.
    Let''s say that we need to add an item to the dictionary, maybe the manufacturer.
    We would need to make changes to both functions. The new code would look like
    this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数处理相同的数据，但在这里我们可能不会立即意识到我们在重复自己——至少直到我们需要更新字典的时候。假设我们需要向字典中添加一个条目，比如制造商。我们需要对两个函数都进行修改。新的代码将看起来像这样：
- en: '[PRE16]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the line for the manufacturer was added to both functions. What
    would happen if we forgot to add it to one of them? At some point, we will discover
    the difference, but when we do, we can't be sure if the `manufacturer` line was
    added to one function or removed from the other.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，制造商的行被添加到了两个函数中。如果我们忘记将其添加到其中一个函数中会发生什么？在某个时候，我们会发现差异，但当我们发现时，我们无法确定是哪个函数添加了`manufacturer`行，还是从另一个函数中删除了它。
- en: Let's apply the DRY principle to the code. If we think about what is happening,
    we will discover that the `show` function has multiple lines within `print`. We
    also know that `print` will print something on one line and then insert a line
    feed so that the next `print` will start on a new line.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将DRY原则应用到代码中。如果我们思考一下正在发生的事情，我们会发现`show`函数在`print`中有多个行。我们也知道`print`会在一行上打印一些内容，然后插入换行符，以便下一个`print`从新的一行开始。
- en: But what would happen if we had one `print` that printed a string like the one
    in the `save` function? It contains the new line indicator, `\n`, in all the locations
    where we want a new line, so printing that string will give the same result as
    our current `show` function.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一个像`save`函数中那样的打印字符串的`print`会发生什么？它包含所有我们想要换行的地方的新行指示符`\n`，所以打印这个字符串将给出与当前`show`函数相同的结果。
- en: 'We can make use of this and add a function that creates and returns that string,
    and then both functions can call that function, as shown in the following code:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点添加一个创建并返回该字符串的函数，然后两个函数都可以调用该函数，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we have the `create_data` function, which creates the string and returns
    it to the caller. It is called from both the `show` and the `save` functions.
    In `show`, the `create_string` function is called first of all, and the string
    that gets returned will be printed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有`create_data`函数，它创建字符串并将其返回给调用者。它被`show`和`save`函数调用。在`show`中，首先调用`create_string`函数，然后返回的字符串将被打印出来。
- en: In the `save` function, we call the `create_string` function from within the
    call to a function called `save_file`. The returned string will be passed as the
    second argument to the `save_file` function, just as it was in our first version.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在`save`函数中，我们在调用名为`save_file`的函数时，从内部调用了`create_string`函数。返回的字符串将被作为`save_file`函数的第二个参数传递，就像在我们的第一个版本中一样。
- en: This also makes the code more readable and shorter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得代码更易于阅读和更简洁。
- en: Many languages or software companies have *scandalized* the way we format the
    code we write. This is called *code conventions*, and this is what we will look
    at next.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言或软件公司都“丑化”了我们编写代码的方式。这被称为“代码约定”，这是我们接下来要探讨的内容。
- en: Using code conventions
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码约定
- en: Most programming languages have code conventions. These are recommendations
    for how we shall organize our files, indent our code, format comments, and use
    naming conventions, just to mention a few.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言都有代码约定。这些是我们组织文件、缩进代码、格式化注释和使用命名约定的建议，仅举几例。
- en: These are not rules but a recommended code style and the idea is that if all
    programmers using a language use the same code convention, their code will look
    more or less the same. This means that if you know the convention, it is easier
    for you to navigate the code and read it. It is, therefore, essential to learn
    the convention for every programming language you are using.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是规则，而是一种推荐的代码风格，其理念是，如果所有使用该语言的程序员都使用相同的代码约定，他们的代码看起来将大致相同。这意味着，如果您知道这个约定，您将更容易导航代码并阅读它。因此，学习您所使用的每种编程语言的约定是至关重要的。
- en: We will look at some typical conventions and see how they differ among a couple
    of languages.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一些典型的约定，并看看它们在几种语言中的差异。
- en: Naming conventions
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名规范
- en: A naming convention is a set of rules for formatting the names of variables,
    types, functions, and other entities in the source code.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 命名规范是一组规则，用于格式化源代码中变量、类型、函数和其他实体的名称。
- en: Sometimes, programming languages come with official naming conventions. Other
    times, they are not official but commonly used by the community using a language.
    Some companies have developed their own naming conventions for the code written
    within that company.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，编程语言会附带官方的命名约定。有时，它们不是官方的，但被使用该语言的社区广泛采用。一些公司为该公司编写的代码开发了他们自己的命名约定。
- en: A naming convention is not about how you name things, but how you format the
    names. A naming convention dictates how uppercase and lowercase characters should
    be used and how names consisting of multiple words should be formatted. Some different
    styles are frequently used. Let's look at some of them.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '命名约定不关乎你如何命名事物，而是关乎你如何格式化名称。命名约定规定了如何使用大写和小写字符，以及多词名称应该如何格式化。一些不同的风格经常被使用。让我们看看其中的一些。 '
- en: Camel case
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 驼峰命名法
- en: In camel case, each word in a multi-word name has an initial capital letter,
    except for the initial letter. For example, if we want to store a value for the
    outside temperature, the name used for that variable would be `outsideTemperature`
    in camel case.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在驼峰命名法中，多词名称中的每个单词的首字母都大写，除了第一个字母。例如，如果我们想存储外部温度的值，该变量的名称在驼峰命名法中将是 `outsideTemperature`。
- en: Camel case is also known as camel caps. The name refers to the apparent humps
    that the capital letters form. One early use of this style was by the Swedish
    chemist Jöns Jacob Berzelius, who suggested, in an 1813 essay in Annals of Philosophy
    2, that chemical elements should be written as one-letter or two-letter symbols
    with the first letter capitalized. That would allow formulae such as *NaCl* to
    be written without any spaces.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 驼峰命名法也被称为驼峰式。这个名字指的是大写字母形成的明显驼峰。这种风格的早期使用之一是由瑞典化学家 Jöns Jacob Berzelius，他在 1813
    年的《哲学年鉴》第 2 卷中提出，化学元素应该用单字母或双字母符号表示，并且首字母大写。这样就可以写出没有空格的公式，如 *NaCl*。
- en: Pascal case
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pascal 大写命名法
- en: Pascal case is like camel case, with the only difference being that the first
    letter is also written using a capital case. So, the pascal case, the outside
    temperature variable would be named `OutsideTemperature`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 大写命名法类似于驼峰命名法，唯一的区别在于第一个字母也使用大写字母。因此，Pascal 大写命名法的外部温度变量会被命名为 `OutsideTemperature`。
- en: Pascal case gets its name from the programming language Pascal. Even though
    Pascal is case-insensitive, the practice was popularized by the Pascal convention
    to use this style.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 大写命名法得名于编程语言 Pascal。尽管 Pascal 不区分大小写，但这种风格是通过 Pascal 规范流行起来的。
- en: Snake case
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 蛇形命名法
- en: In snake case, all letters are written in lowercase, and an underscore separates
    words. The outside temperature variable, when written in snake case, would be
    `outside_temperature`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在蛇形命名法中，所有字母都小写，单词之间用下划线分隔。外部温度变量在蛇形命名法中写作 `outside_temperature`。
- en: 'Snake case has been in use for a long time but did not have any established
    name. An early reference to the name *snake_case* comes from Gavin Kistner, who,
    in 2004, wrote a post named *Appropriate use of CamelCase* in the group *comp.lang.ruby
    on Usenet*. In it, he said the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Snake 大写命名法已经使用很长时间了，但没有一个确立的名字。对 *snake_case* 这个名字的早期提及来自 Gavin Kistner，他在
    2004 年在 Usenet 的 *comp.lang.ruby* 群组中发表了一篇名为 *Appropriate use of CamelCase* 的帖子。在其中，他说了以下内容：
- en: '*"BTW...what *do* you call that naming style? snake_case? That''s what I''ll
    call it until someone corrects me."*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*"顺便问一下...你叫那种命名法是什么？snake_case？我会这样称呼它，直到有人纠正我。"*'
- en: Indentation conventions
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩进约定
- en: There are several different styles that are used when it comes to indentation
    and how compound statements are indicated.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在缩进和复合语句表示方面，有几种不同的风格被使用。
- en: For languages that use braces, how the braces are placed is a never-ending debate.
    Let's look at some variants.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用花括号的编程语言，花括子的放置方式是一个永无止境的争论。让我们看看一些变体。
- en: '**K&R style**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**K&R 风格**'
- en: The K&R style originates from the Kernighan and Ritchie book *The C Programming
    Language* from 1978.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: K&R 风格起源于 1978 年的 Kernighan 和 Ritchie 所著的《C 程序设计语言》一书。
- en: When following this style, each function has its opening brace on a new line
    and the same indentation level as the function header.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循此风格时，每个函数的起始花括号都在新的一行，并且与函数标题具有相同的缩进级别。
- en: Blocks inside the function will have their opening brace at the same line as
    the statement they are opening.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内的块将与其打开语句在同一行上放置起始花括号。
- en: 'The following screenshot shows an example of the K&R style:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 K&R 风格的一个示例：
- en: '![Figure 12.23 – The K&R bracing style](img/Figure_12.23_B15554.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.23 – K&R 花括子风格](img/Figure_12.23_B15554.jpg)'
- en: Figure 12.23 – The K&R bracing style
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 – K&R括号风格
- en: '**1TBS**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**1TBS**'
- en: '**1TBS** is an abbreviation for **one true brace style** and is a variant on
    the K&R style. The only difference is that the opening brace for functions is
    located on the same line as the function header. Also, in 1TBS, control structures
    only containing one line will always have braces, a habit not always used in the
    K&R style. See the following screenshot for an example of this style:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**1TBS**是**one true brace style**的缩写，是K&R风格的一个变种。唯一的区别是函数的开括号位于函数标题所在的同一行。此外，在1TBS中，只包含一行控制结构的括号总是存在的，而在K&R风格中并不总是这样使用。以下屏幕截图展示了这种风格的一个示例：'
- en: '![Figure 12.24 – The 1TBS bracing style](img/Figure_12.24_B15554.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![图12.24 – 1TBS括号风格](img/Figure_12.24_B15554.jpg)'
- en: Figure 12.24 – The 1TBS bracing style
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 – 1TBS括号风格
- en: '**Java**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: In Java, a commonly accepted practice is to use the K&R style, extended so that
    all opening braces are on the same line as the statement it opens. This applies
    to control structures, classes, and methods.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，一种常见的做法是使用K&R风格，扩展到所有开括号都位于它打开的语句所在的同一行。这适用于控制结构、类和方法。
- en: 'See the following screenshot for an example of this style:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图展示了这种风格的一个示例：
- en: '![Figure 12.25 – The Java bracing style](img/Figure_12.25_B15554.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图12.25 – Java括号风格](img/Figure_12.25_B15554.jpg)'
- en: Figure 12.25 – The Java bracing style
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 – Java括号风格
- en: '**Allman style**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**Allman风格**'
- en: The Allman style, named after the American programmer Eric Allman, puts all
    opening braces on a new line.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Allman风格，以美国程序员埃里克·奥尔曼的名字命名，将所有开括号放在新的一行上。
- en: People arguing for this style means that it becomes easier to see where a block
    begins and ends, when the opening and closing braces are on the same indentation
    level.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 支持这种风格的人意味着，当开括号和闭括号处于相同的缩进级别时，更容易看到代码块的开始和结束位置。
- en: 'See the following screenshot for an example of this style:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图展示了这种风格的一个示例：
- en: '![Figure 12.26 – The Allman bracing style](img/Figure_12.26_B15554.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图12.26 – Allman括号风格](img/Figure_12.26_B15554.jpg)'
- en: Figure 12.26 – The Allman bracing style
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26 – Allman括号风格
- en: '**Lisp or Python style**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lisp或Python风格**'
- en: 'This style can be used in any language that uses braces, but is mostly used
    by languages that don''t use braces and use an indentation level to identify blocks
    of code instead, such as Lisp and Python. In the following screenshot, we can
    see a Lisp program that uses this style:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格可以用于任何使用括号的编程语言，但主要被那些不使用括号而使用缩进级别来标识代码块的语言使用，例如Lisp和Python。在下面的屏幕截图中，我们可以看到一个使用这种风格的Lisp程序：
- en: '![Figure 12.27 – The Lisp block indentation style](img/Figure_12.27_B15554.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图12.27 – Lisp块缩进风格](img/Figure_12.27_B15554.jpg)'
- en: Figure 12.27 – The Lisp block indentation style
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27 – Lisp块缩进风格
- en: 'In the following screenshot, we can see the same program written in Python,
    using the same type of indentation to mark blocks:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到用Python编写的相同程序，使用相同类型的缩进来标记代码块：
- en: '![Figure 12.28 – The Python block indentation style](img/Figure_12.28_B15554.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图12.28 – Python块缩进风格](img/Figure_12.28_B15554.jpg)'
- en: Figure 12.28 – The Python block indentation style
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28 – Python块缩进风格
- en: In Python, the indentation levels are part of the language. This is sometimes
    called the **offside rule**, a name coined by the British computer scientist Peter
    J. Landin, most likely as a pun on the offside rule in football, compared to languages
    that use braces, meaning indentation levels are not decided on by the language.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，缩进级别是语言的一部分。这有时被称为**偏移规则**，这个名字是由英国计算机科学家彼得·J·兰丁提出的，很可能是对足球中的偏移规则的戏仿，与使用括号的编程语言相比，这意味着缩进级别不是由语言决定的。
- en: These are not the only conventions you will find described in a convention document.
    Next, we will look at some other things you most likely will find when reading
    them.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是在约定文档中描述的唯一约定。接下来，我们将看看在阅读它们时你很可能会发现的其他一些内容。
- en: Other conventions
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他约定
- en: Other conventions might be described for a language. One thing that is often
    described in a convention document is how comments should be formatted.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一种语言，可能会有其他约定被描述。在约定文档中经常描述的一件事是如何格式化注释。
- en: Some languages have tools that can generate documentation from the comments
    found in the code. For this to work, the comments must follow a strict format.
    Some examples of these are Java's Javadoc and Doxygen for C and C++.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言有工具可以从代码中的注释生成文档。为了使这成为可能，注释必须遵循严格的格式。这些示例包括Java的Javadoc和C和C++的Doxygen。
- en: Some languages also support special kind of comments known as **docstrings**.
    They are comments, but when regular comments are stripped away from the executable
    code by the compiler, they are retained so that the programmer can inspect them
    when the program is running.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言还支持一种称为**docstrings**的特殊注释类型。它们是注释，但当编译器从可执行代码中移除常规注释时，它们会被保留，以便程序员在程序运行时检查它们。
- en: There can also be conventions for how the source code files should be organized
    in folders and packages (to learn more about packages, see [*Chapter 4*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067),
    *Software Projects and How We Organize Our Code*, in the *Working with packages
    to share code* section). There can also be conventions in place for how to name
    files.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 还可能有关于如何在文件夹和包中组织源代码文件的约定（要了解更多关于包的信息，请参阅[*第4章*](B15554_04_Final_NM_ePub.xhtml#_idTextAnchor067)，*软件项目和我们的代码组织方式*，在*使用包共享代码*部分）。还可能有关于如何命名文件的约定。
- en: A code convention can also dictate the use of tabs versus spaces when we indent
    our code. Here, most conventions prefer the use of spaces over tabs, but there
    are exceptions to this.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 代码约定也可以规定我们在缩进代码时使用制表符还是空格。在这里，大多数约定更倾向于使用空格而不是制表符，但也有例外。
- en: You might also find things that are not directly related to coding and coding
    style in a coding convention document. For example, one thing that you might find
    is recommendations for source file encoding. The file encoding dictates how the
    characters in the file will be interpreted. The two most frequent encodings are
    ASCII and UTF-8\. Sometimes, there are recommendations about part of a file. The
    convention document might state that comments or string literals must use a particular
    encoding, not the whole file.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能在编码约定文档中找到与编码和编码风格不直接相关的内容。例如，你可能会发现有关源文件编码的建议。文件编码决定了文件中的字符将被如何解释。最常用的两种编码是ASCII和UTF-8。有时，会有关于文件一部分的建议。约定文档可能声明注释或字符串字面量必须使用特定的编码，而不是整个文件。
- en: Another thing often found in code convention documents is how blanks lines and
    spaces should be used. For example, in the official Python style guide, called
    Pep 8, it is stated that two blank lines should separate functions and methods
    within a class by one blank line, and that there should never be more than one
    blank line between code lines within a function or method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 编码约定文档中经常找到的另一件事是如何使用空白行和空格。例如，在官方Python风格指南Pep 8中，指出应该在类中的函数和方法之间用一个空白行分隔，并且函数或方法内的代码行之间不应超过一个空白行。
- en: 'There can also be recommendations regarding how to write expressions. Again,
    the Python style guide says that these lines use a recommended style:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何编写表达式的建议也可能存在。再次强调，Python风格指南指出，这些行使用推荐的风格：
- en: '[PRE18]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compare those to the following lines, which do not follow the recommended style:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下不遵循推荐风格的行进行比较：
- en: '[PRE19]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last convention we will cover here, which can also be found in code conventions,
    is how long lines should be break up long lines into several lines.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的最后一个约定，也可以在代码约定中找到，是关于如何将长行拆分成多行。
- en: For example, when working with a long line that contains binary operators (such
    as +, -. *, and /), we can break up these operators, but what would happen if
    the operator appears as the last character on a line or as the first on the next
    one?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当处理包含二元运算符（如 +, -, *, 和 /）的长行时，我们可以将这些运算符分开，但如果运算符出现在一行的最后一个字符或下一行的第一个字符上，会发生什么呢？
- en: 'Look at this example:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子：
- en: '[PRE20]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, compare it to this variant, where the operators are moved to the next
    line:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将其与这个变体进行比较，其中运算符被移动到下一行：
- en: '[PRE21]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The American computer scientist Donald Knuth states, in his book *The TeXbook*
    from 1984, the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 美国计算机科学家唐纳德·克努特在他的1984年出版的《TeXbook》一书中指出：
- en: '*"Although formulas within a paragraph always break after binary operations
    and relations, displayed formulas always break before binary operations and relations."*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*"尽管段落内的公式总是在二元运算和关系之后断行，但显示的公式总是在二元运算和关系之前断行。"*'
- en: This would suggest that when a formula is printed, it is always printed in the
    form shown in the second example. This is not a universal truth, though. If you
    read mathematical texts, you will find both forms represented, and sometimes even
    a third form where the operator is both at the end of the line and the beginning
    of the next.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当一个公式被打印出来时，它总是以第二个例子中所示的形式打印。但这并不是一个普遍的真理。如果你阅读数学文本，你会发现两种形式都有表示，有时甚至还有第三种形式，其中运算符既在行尾又在下一行的开头。
- en: But sometimes, this argument by Knuth is used to recommend the form where the
    operator begins a line over the one where it comes at the end.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，Knuth的这个论点被用来推荐运算符开始一行而不是在行尾的形式。
- en: Different conventions are a topic most programmers have an opinion about. Still,
    if there is one in place, either for the language you are using or the project
    you are working on, you should stick to it, even if it contradicts what you think
    is a good way of writing code.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的约定是大多数程序员都有看法的一个话题。尽管如此，如果有一个适用于你使用的语言或你正在工作的项目，你应该坚持它，即使它与你认为的编写代码的好方法相矛盾。
- en: Summary
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have reached the end of this journey into programming,
    and you now know what it takes to write quality code that is efficient and easy
    to read and maintain.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经完成了这段编程之旅，现在你知道了编写高效、易于阅读和维护的高质量代码需要哪些要素。
- en: We talked about the fact that we have two aspects of quality when it comes to
    software – one being the quality of the code and the other being quality from
    the user's perspective.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了这样一个事实，即当涉及到软件质量时，我们有两个方面——一个是代码的质量，另一个是从用户的角度来看的质量。
- en: We then turned our attention to how to achieve code quality. First, we talked
    about how we can create readable code and how this will improve the code's overall
    quality.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将注意力转向如何实现代码质量。首先，我们讨论了如何编写可读的代码以及这将如何提高代码的整体质量。
- en: After that, we looked at how efficient code, which is code that efficiently
    uses the computer's resources, will improve the quality of our code.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们探讨了高效代码，即高效使用计算机资源的代码，将如何提高我们代码的质量。
- en: Smart coding tricks are not always the smart way to write code if code quality
    is something we value. We saw some examples of things we should avoid.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重视代码质量，智能编码技巧并不总是编写代码的明智方式。我们看到了一些我们应该避免的事情的例子。
- en: Finally, we looked at some best practices that we can use to increase the quality
    of the code we write.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了我们可以使用的最佳实践，以提升我们编写的代码质量。
- en: With this, we have come to the end of the main chapters of the book. I hope
    you have enjoyed this journey as much as I have. I have tried to put together
    everything that is relevant and important from a beginner's point of view, and
    I am sure many of you will benefit from it.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经到达了本书主要章节的结尾。我希望你和我一样享受这段旅程。我试图从初学者的角度整理出所有相关和重要的事项，我相信你们中的许多人都会从中受益。
