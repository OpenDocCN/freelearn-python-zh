- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the Microservice Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we spent a lot of time building API services for various applications
    using the core features of FastAPI. We also started applying important design
    patterns such as **Inversion of Control** (**IoC**) and **Dependency Injection**
    (**DI**), which are essential for managing FastAPI container objects. External
    Python packages were installed and used to provide options on what containers
    to use in managing objects.
  prefs: []
  type: TYPE_NORMAL
- en: These design patterns can help not only with managed objects in container but
    also when building scalable, enterprise-grade, and unconventionally complex applications.
    Most of these design patterns help break down monolithic architecture into loosely
    coupled components that are known as *microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore some architectural design patterns and principles
    that can provide strategies and ways to initiate the building of our microservices
    from a monolithic application. Our focus will be on breaking the huge application
    into business units, creating a sole gateway to bundle these business units, applying
    domain modeling to each of the microservices, and managing other concerns such
    as logging and application configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from expounding the benefits and disadvantages of each design pattern,
    another objective is to apply these architectural patterns to our software specimen
    to show its effectiveness and feasibility. And to support these goals, the following
    topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying the decomposition pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a common gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centralizing the logging mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming the REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the domain modeling approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing a microservice’s configuration details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses a *university ERP system* prototype that focuses on the students,
    faculty, and library submodules, but more on student-library and faculty-library
    operations (for example, book borrowing and issuing). Each submodule has its administration,
    management, and transaction services, and they are independent of each other even
    though they are part of an ERP specification. Currently, this sample prototype
    does not use any database management system, so all the data is temporarily stored
    in Python containers. The code is all uploaded at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)
    under the `ch04`, `ch04-student`, `ch04-faculty`, and `ch04-library` projects.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the decomposition pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we apply the monolithic strategy used in building the prototypes presented
    in the previous chapters, building this ERP will not be cost-effective in terms
    of resources and effort. There will be features that might become too dependent
    on other functions, which will put the teams of developers in a difficult situation
    whenever transaction problems occur due to these tightly coupled features. The
    best way to implement our University ERP prototype is to decompose the whole specification
    into smaller modules before the implementation starts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two appropriate ways in which to decompose our application prototype,
    namely decomposition by business units and decomposition by subdomains:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Decomposition by business units* is used when the breakdown of the monolithic
    application is based on organizational structures, architectural components, and
    structural units. Usually, its resulting modules have fixed and structured processes
    and functionality that are seldom enhanced or upgraded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Decomposition by subdomain* uses domain models and their corresponding business
    processes as the basis of the breakdown. Unlike the former, this decomposition
    strategy deals with modules that continuously evolve and change to capture the
    exact structure of the modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of the two options, decomposition by business units is the more practical decomposition
    strategy to use for our monolithic University ERP prototype. Since the information
    and business flow used by universities has been part of its foundation for years,
    we need to organize and breakdown its voluminous and compounded operations by
    colleges or departments. *Figure 4.1* shows the derivation of these submodules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Decomposition by business units](img/Figure_4.1_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Decomposition by business units
  prefs: []
  type: TYPE_NORMAL
- en: 'After determining the submodules, we can implement them as independent microservices
    using the FastAPI framework. We can call an implementation of a business unit
    or module a microservice if its services *can collectively stand as one component*.
    Also, it must be able to *collaborate with other microservices* through *interconnection*
    based on the URL address and port number. *Figure 4.2* shows the project directories
    of the faculty, library, and student management modules implemented as FastAPI
    microservice applications. [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014)*, Setting
    Up FastAPI for Starters,* to [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052)*,*
    *Investigating Dependency Injection*, gave us the foundation to build a FastAPI
    microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The faculty, library, and student microservice applications](img/Figure_4.2_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The faculty, library, and student microservice applications
  prefs: []
  type: TYPE_NORMAL
- en: Each of these microservices is independent of the others in terms of its server
    instance and management. Starting and shutting down one of them will not affect
    the other two, as each can have a different context root and port. Each application
    can have a separate logging mechanism, dependency environment, container, configuration
    file, and any other aspect of a microservice, which will be discussed in the subsequent
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: But FastAPI has another way of designing microservices using a *mount* sub-application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the sub-applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FastAPI allows you to build independent sub-applications inside the *main application*.
    Here, `main.py` serves as a gateway that provides a pathname to these mounted
    applications. It also creates the mounts specifying the context path mapped to
    the FastAPI instance of each sub-application. *Figure 4.3* shows a new university
    ERP implementation that has been built using mounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The main project with the mounts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – The main project with the mounts
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `faculty_mgt`, `library_mgt`, and `student_mgt` are typical independent
    microservice applications mounted into the `main.py` component, the top-level
    application. Each sub-application has a `main.py` component, such as `library_mgt`,
    which has its FastAPI instance created in its `library_main.py` setup, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The student sub-application has a `student_main.py` setup that creates its
    FastAPI instance, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the faculty sub-application also has its `faculty_main.py` setup,
    as highlighted in the following code, for the same purpose, to build the microservice
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These sub-applications are typical FastAPI microservice applications containing
    all of the essential components such as routers, middleware exception handlers,
    and all the necessary packages to build REST API services. The only difference
    from the usual applications is that their context paths or URLs are defined and
    decided by the top-level application that handles them.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can run the `library_mgt` sub-application independently from
    `main.py` through the `uvicorn main:library_app --port 8001` command, `faculty_mgt`
    through `uvicorn main:faculty_app --port 8082`, and `student_mgt` through `uvicorn
    main:student_app --port 8003`. The option of running them independently despite
    the mount explains why these mounted sub-applications are all microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the submodules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the FastAPI decorators of each sub-application must be mounted in the `main.py`
    component of the top-level application for them to be accessed at runtime. The
    `mount()` function is invoked by the FastAPI decorator object of the top-level
    application, which adds all FastAPI instances of the sub-applications into the
    gateway application (`main.py`) and maps each with its corresponding URL context.
    The following script shows how the mounting of the *library*, *student*, and *faculty*
    subsystems is implemented in the `main.py` component of the University ERP top-level
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this setup, the mounted `/ch04/student` URL will be used to access all
    the API services of the *student module* app, `/ch04/faculty` will be used for
    all the services of the *faculty module*, and `/ch04/library` will be used for
    the *library*-related REST services. These mounted paths become valid once they
    are declared in `mount()` because FastAPI automatically handles all of these paths
    through the `root_path` specification.
  prefs: []
  type: TYPE_NORMAL
- en: Since all three sub-applications of our *university ERP system* are independent
    microservices, now let us apply another design strategy that can help manage the
    requests to these applications just by using the main URL of the ERP system. Let
    us utilize the *main application* as a gateway to our sub-applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a common gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It will be easier if we use the URL of the main application to manage the requests
    and redirect users to any of the three sub-applications. The *main application*
    can stand as a pseudo-reverse proxy or an entry point for user requests, which
    will always redirect user requests to any of the desired sub-applications. This
    kind of approach is based on a design pattern called *API Gateway*. Now, let us
    explore how we can apply this design to manage independent microservices mounted
    onto the main application using a workaround.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the main endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are so many solutions when it comes to implementing this gateway endpoint,
    and among them is having a simple REST API service in the top-level application
    with an integer path parameter that will identify the `ID` parameter of the microservice.
    If the `ID` parameter is invalid, the endpoint will only return the `{''message'':
    ''University ERP Systems''}` JSON string instead of an error. The following script
    is a straightforward implementation of this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `access_portal` API endpoint is created as a GET path operation with `portal_id`
    as its path parameter. The `portal_id` parameter is essential to this process
    because it will determine which among the *Student*, *Faculty*, and *Library*
    microservices the user wants to access. Therefore, accessing the `/ch04/university/1`
    URL should lead the user to the student application, `/ch04/university/2` to the
    faculty microservice, and `/ch04/university/3` to the library application.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the microservice ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `portal_id` parameter will automatically be fetched and evaluated using
    a dependable function that is injected into the `APIRouter` instance where the
    API endpoint is implemented. As discussed in [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052),
    *Investigating Dependency Injection*, a *dependable function* or *object* can
    serve as a filter or validator of all incoming requests of any services once injected
    into an `APIRouter` or `FastAPI` instance. The dependable function used in this
    ERP prototype, as shown in the following script, evaluates whether the `portal_id`
    parameter is `1`, `2`, or `3` only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The given solution is a feasible workaround to trigger a custom event since
    FastAPI has no built-in event handling except for the startup and shutdown event
    handlers, which are topics in [*Chapter 8*](B17975_08.xhtml#_idTextAnchor229),
    *Creating Coroutines, Events, and Message-Driven Transactions*. So, once `call_api_gateway()`
    finds `portal_id` to be a valid microservice ID, it will raise some custom exceptions.
    It will throw `RedirectStudentPortalException` if the user wants to access the
    *Student* microservice. On the other hand, the `RedirectFacultyPortalException`
    error will be raised if the user desires the *Faculty* microservice. Otherwise,
    the `RedirectLibraryPortalException` error will be triggered when the *Library*
    microservice is the one wanted by the user. But first, we need to inject `call_api_gateway()`
    into the `APIRouter` instance handling the gateway endpoint through the `main.py`
    component of the top-level ERP application. The following script shows you how
    it is injected into `university.router` using the concepts discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All of these raised exceptions require an exception handler that will listen
    to the throws and execute some of the tasks required to pursue the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the exception handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The exception handler does a redirection to the appropriate microservice. As
    you learned in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033), *Exploring the
    Core Features*, each thrown exception must have its corresponding exception handler
    to pursue the required response after the exception handling. Here are the exception
    handlers that will handle the custom exception thrown by `call_api_gateway()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `exception_handler_student()` will redirect the user to the mount path
    of the *Student* microservice, while `exception_handler_faculty()` will redirect
    the user to the *Faculty* sub-application. Additionally, `exception_handler_library()`
    will let the user access the *Library* microservice. Exception handlers are the
    last component needed to complete the API Gateway architecture. The exceptions
    trigger the redirection to the independent microservices mounted on the FastAPI
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Although there are other, better solutions to achieve the gateway architecture,
    our approach is still procedural and pragmatic without having to resort to external
    modules and tools, just the core components of FastAPI. [*Chapter 11*](B17975_11.xhtml#_idTextAnchor321),
    *Adding Other Microservices Features*, will discuss establishing an effective
    API Gateway architecture using Docker and NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us explore how to set up a centralized logging mechanism for this kind
    of microservices setup.
  prefs: []
  type: TYPE_NORMAL
- en: Centralizing the logging mechanism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created an audit trail mechanism with middleware and Python file transactions
    in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033), *Exploring the Core Features*.
    We have found out that middleware, which can only be set up through the FastAPI
    decorator of the top-level application, can manage incoming Request and outgoing
    Response of any API services. This time, we will be using custom middleware to
    set up a centralized logging feature that will log all service transactions of
    the top-level application alongside its independent mounted microservices. Of
    the many approaches for integrating these logging concerns into the application
    without changing the API services, we will concentrate on the following pragmatic
    custom approach with the custom middleware and *Loguru* module.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the Loguru module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *application log* is essential to any enterprise-grade application. For monolithic
    applications deployed in a single server, logging means letting service transactions
    write their log messages to a single file. On the other hand, logging can be too
    complex and complicated to implement in an independent microservices setup, especially
    when these services are for deployment to different servers or Docker containers.
    Its logging mechanism could even cause runtime problems if the module used is
    not adaptable to asynchronous services.
  prefs: []
  type: TYPE_NORMAL
- en: 'For FastAPI instances that support both asynchronous and synchronous API services
    that run on an ASGI server, using Python’s logging module always generates the
    following error log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Opting for another logging extension is the only solution to avoid the error
    generated by the `logging` module. The best option is one that can fully support
    the FastAPI framework, which is the `loguru` extension. But first, we need to
    install it using the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Loguru is a straightforward and easy-to-use logging extension. We can immediately
    log using its default handler, the `sys.stderr` handler, even without adding much
    configurations. Since our application needs to place all messages in a log file,
    we need to add the following lines to the `main.py` component of the top-level
    application right after the instantiation of `FastAPI`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that its `logger` instance has an `add()` method where we can register
    *sinks*. The first part of the *sinks* is the *handler* that decides whether to
    emit the logs in `sys.stdout` or the file. In our university ERP prototype, we
    need to have a global `info.log` file that contains all the log messages of the
    sub-applications.
  prefs: []
  type: TYPE_NORMAL
- en: A crucial part of the log sink is the `level` type, which indicates the granularity
    of log messages that need to be managed and logged. If we set the `level` parameter
    of `add()` to `INFO`, it tells the logger to consider only those messages under
    the `INFO`, `SUCCESS`, `WARNING`, `ERROR`, and `CRITICAL` weights. The logger
    will bypass log messages outside these levels.
  prefs: []
  type: TYPE_NORMAL
- en: Another part of the *sinks* is the `format` log, where we can create a custom
    log message layout to replace its default format. This format is just like a Python
    interpolated string without the *"f"* that contains placeholders such as `{time}`,
    `{level}`, `{message}`, and any custom placeholders that need to be replaced by
    `logger` at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In `log.file`, we want our logs to start with the `Log` keyword followed immediately
    by the custom-generated `log_id` parameter and then the time the logging happened,
    the level, and the message.
  prefs: []
  type: TYPE_NORMAL
- en: And to add support for asynchronous logging, the `add()` function has an `enqueue`
    parameter that we can enable anytime. In our case, this parameter is default to
    `True` just to prepare for any `async/await` execution.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot to explore with Loguru’s features and functionality. For instance,
    we can create additional handlers for loggers to emit where each of these handlers
    has different retention, rotation, and rendition types. Additionally, Loguru can
    allow us to add colors to our logs through some color markups such as `<red>`,
    `<blue>`, or `<cyan>`. It also has an `@catch()` decorator that can be applied
    to manage exceptions at runtime. All the logging features we need to set up our
    unified application log are in Loguru. Now that we have configured our Loguru
    in the top-level application, we need to let its logging mechanism work across
    the three sub-applications or microservices without modifying their code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the logging middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core component of this centralized application log is the custom middleware
    that we must implement in the `main.py` component where we set up Loguru. FastAPI’s
    *mount* allows us to centralize some cross-cutting concerns such as logging without
    adding anything to the sub-applications. One middleware implementation in the
    `main.py` component of the top-level application is good enough to pursue logging
    across the independent microservices. The following is the middleware implementation
    for our specimen application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, `log_middleware()` will generate a `log_id` parameter every time it
    intercepts any API services from the main app or the sub-applications. Then, the
    `log_id` parameter is injected into the `dict` of context information through
    Loguru’s `contextualize()` method since `log_id` is part of the log information,
    as indicated in our log format setup. Afterward, logging starts before the API
    service is executed and after its successful execution. When exceptions are encountered
    during the process, the logger will still generate a log message with the `Exception`
    message. So, whenever we access any API services anywhere from the ERP prototype,
    the following log messages will be written in `info.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The given snapshot of log messages proves that we have a centralized setup because
    the middleware filters all API service execution and performs the logging transaction.
    It shows that the logging started from accessing the gateway down to executing
    the API services from the *faculty*, *student*, and *l**ibrary* sub-applications.
    Centralizing and managing cross-cutting concerns is one advantage that can be
    provided by using FastAPI’s *mounting* when building independent microservices.
  prefs: []
  type: TYPE_NORMAL
- en: But when it comes to the interactions among these independent sub-applications,
    can mounting also be an advantage? Now, let us explore how independent microservices
    in our architecture can communicate by utilizing each other’s API resources.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the REST API services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in an unmounted microservices setup, mounted ones can also communicate
    by accessing each other’s API services. For instance, if a faculty member or student
    wants to borrow a book from the library, how can that setup be implemented seamlessly?
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.4*, we can see that interactions can be possible by establishing
    a client-server communication wherein one API service can serve as a resource
    provider, and the others are the clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Interaction with the faculty, student, and library microservices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Interaction with the faculty, student, and library microservices
  prefs: []
  type: TYPE_NORMAL
- en: Consuming API resources in FastAPI can be straightforward using the `httpx`
    and `requests` external modules. The following discussions will focus on how these
    two modules can help our mounted services interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Using the httpx module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `httpx` external module is a Python extension that can consume both asynchronous
    and synchronous REST APIs and has *HTTP/1.1* and *HTTP/2* support. It is a fast
    and multi-purpose toolkit that is used to access API services running on WSGI-based
    platforms, as well as, on ASGI, like the FastAPI services. But first, we need
    to install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use it directly without further configuration to make two microservices
    interact, for instance, our *student* module submitting assignments to the *faculty*
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `httpx` module can process the `GET`, `POST`, `PATCH`, `PUT`, and `DELETE`
    path operations. It can allow the passing of different request parameters to the
    requested API without so much complexity. The `post()` client operation, for instance,
    can accept headers, cookies, params, json, files, and model data as parameter
    values. We use the `with` context manager to directly manage the streams created
    by its `Client()` or `AsyncClient()` instances, which are closeable components.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `list_assignments` service is a client that uses the `AsyncClient()`
    instance to pursue its GET request from an asynchronous `/ch04/faculty/assignments/list`
    API endpoint from the f*aculty* module. `AsyncClient` accesses the WSGI-based
    platform to execute any asynchronous services, not the synchronous ones, or else
    it will throw *Status Code 500*. It might require additional configuration details
    in its constructor for some complex cases, where it needs to further manage resource
    access through ASGI.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `submit_assignment` service is a synchronous client that
    accesses another synchronous endpoint, `ch04/faculty/assignments/student/submit`,
    which is a `POST` HTTP operation. In this case, the `Client()` instance is used
    to access the resource to submit an assignment to the *Faculty* module through
    a `POST` request. `AssignmentRequest` is a `BaseModel` object that needs to be
    filled up by the client for submission to the request endpoint. Unlike `params`
    and `json`, which are passed straightforwardly as `dict`, `data` is a model object
    that must be first converted into `dict` by `jsonable_encoder()` and `json.dumps()`
    to make the transport feasible across the HTTP. The new converted model becomes
    the argument value of the `data` parameter of the POST client operation.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the response of the client services, we can allow the response
    to be treated as a piece of text using the module’s `content` or as a JSON result
    using `json()`. It now depends on the requirement of the client service as to
    what response type to use for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the requests module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another option to establish client-server communication among microservices
    is the `requests` module. Although `httpx` and `requests` are almost compatible,
    the latter offers other features such as auto-redirection and explicit session
    handling. The only problem with `requests` is its non-direct support to asynchronous
    APIs and its slow performance when accessing resources. Despite its drawbacks,
    the `requests` module is still the standard way of consuming REST APIs in Python
    microservice development. First, we need to install it before we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our ERP prototype, the `requests` extension was used by the *faculty* microservice
    to borrow books from the *library* module. Let’s look at the *Faculty* client
    services that show us how the `requests` module is used to access the synchronous
    API of *library*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `requests` module has a `Session()` instance, which is equivalent to `Client()`
    in the `httpx` module. It provides all the necessary client operations that will
    consume the API endpoints from the FastAPI platform. Since `Session` is a closeable
    object, the context manager is, again, used here to handle the streams that will
    be utilized during the access of the resources and transport of some parameter
    values. Like in `httpx`, parameter details such as `params`, `json`, `header`,
    `cookies`, `files`, and `data` are also part of the `requests` module and are
    ready for transport through the client operation if needed by the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding code, we can see that sessions are created to implement the
    `list_all_request` and `list_all_issuance` `GET` client services. Here, `request_borrow_book`
    is a `POST` client service that requests a book in the form of `BookRequestReq`
    from the `/ch04/library/book/request` API endpoint. Similar to `httpx`, `jsonable_encoder()`
    and `json.dumps()` must be used to convert the `BaseModel` object into `dict`
    in order to be transported as a `data` parameter value. The same approach is also
    applied to the `return_book` `POST` client service, which returns the book borrowed
    by the faculty. The responses of these client services can also be `content` or
    `json()` just like what we have in the `httpx` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `requests` and `httpx` modules allows these mounted microservices
    to interact with each other based on some specification. Consuming exposed endpoints
    from other microservices minimizes tight coupling and strengthens the importance
    of the decomposition design pattern of building independent microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The next technique gives you the option of managing components within a microservice
    using *domain modeling*.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the domain modeling approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications that are database-focused or built from core functionalities without
    collaborating with models are either not easy to manage when they scale up or
    not friendly when enhanced or bug-fixed. The reason behind this is the absence
    of the structure and flow of business logic to follow, study, and analyze. Understanding
    the behavior of an application and deriving the domain models with the business
    logic behind them encompasses the best approach when it comes to establishing
    and organizing a structure in an application. This principle is called the *domain
    modeling approach*, which we will now apply to our ERP specimen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layering is one implementation that is inevitable when applying domain-driven
    development. There is a dependency between *layers* that, sometimes, might pose
    problems when fixing bugs during development. But what are important in layered
    architectures are the concepts, structures, categories, functionalities, and roles
    that *layering* can create, which helps in understanding the specification of
    the application. *Figure 4.5* shows the *models*, *repositories*, *services*,
    and *controllers* of the sub-applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B17975.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Layered architecture
  prefs: []
  type: TYPE_NORMAL
- en: The most crucial layer is the `models` layer, which consists of the domain model
    classes that describe the domain and business processes involved in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the domain models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *domain model layer* is the initial artifact of the application because
    it provides the contextual framework of the application. Business processes and
    transactions can be easily classified and managed if domains are first determined
    during the initial phase of the development. The code organization created by
    domain layering can provide code traceability, which can ease source code updates
    and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our ERP specimen, these models are categorized into two: the *data* and
    *request* models. The data models are those used to capture and store data in
    its temporary data stores, while the request models are the `BaseModel` objects
    used in the API services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the *faculty* module has the following data models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These data model classes always have their constructors implemented if constructor
    injection is needed during instantiation. Moreover, the `__repr__()` and `__str__()`
    dunder methods are optionally there to provide efficiency for developers when
    accessing, reading, and logging these objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the request models are familiar because they were already
    discussed in the previous chapter. Additionally, the *faculty* module has the
    following request models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The request models listed in the preceding snippet are just simple `BaseModel`
    types. For further details on how to create `BaseModel` classes, [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014),
    *Setting Up FastAPI for Starters*, provides guidelines for creating different
    kinds of `BaseModel` classes to capture different requests from clients.
  prefs: []
  type: TYPE_NORMAL
- en: Building the repository and service layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two most popular domain modeling patterns that are crucial in building
    the layers of this approach are the *repository* and *service layer patterns*.
    The repository aims to create strategies for managing data access. Some repository
    layers only provide data connectivity to the data store like in our specimen here,
    but oftentimes, repository''s goal is to interact with the **Object Relational
    Model** (**ORM**) framework to optimize and manage data transactions. But aside
    from the access, this layer provides a high-level abstraction for the application
    so that the specific database technology or *dialect* used will not matter to
    the applications. It serves as an adapter to any database platform to pursue data
    transactions for the application, nothing else. The following is a repository
    class of the *faculty* module, which manages the domain for creating assignments
    for their students:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, `AssignmentRepository` manages the `Assignment` domain object using its
    four repository transactions. Additionally, `insert_assignment()` creates a new
    `Assignment` entry in the `faculty_assignment_tbl` dictionary, and `update_assignment()`
    accepts new details or the corrected information of an existing assignment and
    updates it. On the other hand, `delete_assignment()` deletes an existing `Assignment`
    entry from the data store using its `assign_id` parameter. To retrieve all the
    created assignments, the repository class has `get_all_assignment()`, which returns
    all the entries of `faculty_assignments_tbl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service layer pattern defines the algorithms, operations, and process flows
    of the applications. Oftentimes, it interacts with the repository to build the
    necessary business logic, management, and controls for the other components of
    the application, such as the API services or controllers. Usually, one service
    caters to one repository class or more depending on the specification of the project.
    The following code snippet is a service that interfaces a repository to provide
    additional tasks such as UUID generation for a student workbin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `AssignmentSubmissionService` cited in the preceding code has methods that
    utilize the `AssignmentSubmissionRepository` transactions. It provides them with
    parameters and returns the `bool` results for evaluation by other components.
    Other services might look more complicated than this sample because algorithms
    and tasks are usually added to pursue the requirements of the layers.
  prefs: []
  type: TYPE_NORMAL
- en: The successful wiring of a repository class to the service happens in the latter’s
    constructor. Usually, the repository class is instantiated just like in the preceding
    sample. Another fantastic option is to use DI, as discussed in [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052).
  prefs: []
  type: TYPE_NORMAL
- en: Using the factory method pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *factory method design pattern* is always a good approach for managing injectable
    classes and functions using the `Depends()` component. [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052)
    showcased factory methods as mediums to inject the repository components into
    the service instead of instantiating them directly within the service. The design
    pattern provides loose coupling between components or layers. This approach is
    highly applicable to large applications wherein some modules and sub-components
    are reused and inherited.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at how the top-level application can manage the different configuration
    details of these mounted and independent microservice applications.
  prefs: []
  type: TYPE_NORMAL
- en: Managing a microservice’s configuration details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, this chapter has provided us with some popular design patterns and
    strategies that can give us a kickstart on how to provide our FastAPI microservices
    with the best structures and architecture. This time, let us explore how the FastAPI
    framework supports storing, assigning, and reading configuration details to mounted
    microservice applications such as database credentials, networking configuration
    data, application server information, and deployment details. First, we need to
    install `python-dotenv` using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All of these settings are values that are external to the implementation of
    the microservice applications. Instead of hardcoding them into the code as variable
    data, usually, we store them in the *env*, *property*, or *INI* files. However,
    challenges arise when assigning these settings to different microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks that support the *externalized configuration design pattern* have
    an internal processing feature that fetches environment variables or settings
    without requiring additional parsing or decoding techniques. For instance, the
    FastAPI framework has built-in support for externalized settings through pydantic’s
    `BaseSettings` class.
  prefs: []
  type: TYPE_NORMAL
- en: Storing settings as class attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our architecture setup, it should be the top-level application that will
    manage the externalized values. One way is to store them in a `BaseSettings` class
    as attributes. The following are classes of the `BaseSettings` type with their
    respective application details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `FacultySettings` will be assigned to the *f**aculty* module since it
    carries some information regarding the module. `LibrarySettings` is for the *library*
    module to utilize, while `StudentSettings` is for the *student* module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch the values, first, a component in a module must import the `BaseSettings`
    class from the main project’s `/configuration/config.py` module. Then, it needs
    an injectable function to instantiate it before injecting it into a component
    that needs to utilize the values. The following script is part of `/student_mgt/student_main.py`,
    where the settings need to be retrieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `build_config()` is an injectable function that injects the `StudentSettings`
    instance into the `/index` endpoint of the *s**tudent* microservice. After the
    DI, the application, webmaster, and created values will become accessible from
    the `config` wired object. These settings will appear on the browser right after
    calling the `/ch04/university/1` gateway URL.
  prefs: []
  type: TYPE_NORMAL
- en: Storing settings in the properties file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another option is to store all these settings inside a physical file with an
    extension of `.env`, `.properties`, or `.ini`. For instance, this project has
    the `erp_settings.properties` file found in the `/configuration` folder, and it
    contains the following application server details in *key-value* pair format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To fetch these details, the application needs another `BaseSettings` class
    implementation that declares the *key* of the *key-value* pair as attributes.
    The following class shows how `production_server`, `prod_port`, `development_server`,
    and `dev_port` are declared without any assigned values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Aside from the class variable declaration, `BaseSetting` requires an implementation
    of an *inner class*, called `Config`, with a predefined `env_file` assigned to
    the current location of the properties file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same processes are involved when it comes to accessing the property details
    from the file. After importing `ServerSettings`, it needs an injectable function
    to inject its instance to the components that need the details. The following
    script is an updated version of `/student_mgt/student_main.py`, which includes
    access to the `development_server` and `development_port` settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Based on this enhanced script, running the `/ch04/university/1` URL will redirect
    the browser to a screen showing additional server details from the properties
    file. Managing configuration details in FastAPI is easy, as we either save them
    inside a class or inside a file. No external module is necessary, and no special
    coding effort is required to fetch all these settings, just the creation of the
    `BaseSettings` classes. This easy setup contributes to building flexible and adaptable
    microservice applications that can run on varying configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter started with the decomposition pattern, which is useful for breaking
    down a monolithic application into granularized, independent, and scalable modules.
    The FastAPI application that implemented these modules exhibited some principles
    included in the *12-Factor Application principles* of a microservice, such as
    having independence, configuration files, logging systems, code bases, port binding,
    concurrency, and easy deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside decomposition, this chapter also showcased the *mounting of different
    independent sub-applications* onto the FastAPI platform. Only FastAPI can group
    independent microservices using mounts and bind them into one port with their
    corresponding context roots. From this feature, we created a pseudo-API Gateway
    pattern that serves as a façade to the independent sub-applications.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the possible drawbacks, the chapter also highlighted domain modeling
    as an option for organizing components in a FastAPI microservice. The *domain*,
    *repository*, and *service* layers help manage the information flow and task distribution
    based on the project specification. Tracing, testing, and debugging are easy when
    domain layers are in place.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on integrating our microservice applications
    with a relational database platform. The focus is to establish database connectivity
    and utilize our data models to implement CRUD transactions within the repository
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Data-Centric and Communication-Focused Microservices Concerns and Issues'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, we will be exploring other FastAPI components and
    features to solve other design patterns that the API framework can build, looking
    at data, communication, messaging, reliability, and security. External modules
    will also be highlighted in order to pursue other behavior and frameworks, such
    as ORM and reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B17975_05.xhtml#_idTextAnchor107), Connecting to a Relational
    Database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B17975_06.xhtml#_idTextAnchor155), Using a Non-Relational Database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B17975_07.xhtml#_idTextAnchor190), Securing the REST APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17975_08.xhtml#_idTextAnchor229), Creating Coroutines, Events,
    and Message-Driven Transactions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
