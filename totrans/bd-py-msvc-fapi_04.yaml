- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Building the Microservice Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建微服务应用程序
- en: Previously, we spent a lot of time building API services for various applications
    using the core features of FastAPI. We also started applying important design
    patterns such as **Inversion of Control** (**IoC**) and **Dependency Injection**
    (**DI**), which are essential for managing FastAPI container objects. External
    Python packages were installed and used to provide options on what containers
    to use in managing objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们花费了大量时间使用FastAPI的核心功能为各种应用程序构建API服务。我们还开始应用重要的设计模式，如**控制反转**（**IoC**）和**依赖注入**（**DI**），这对于管理FastAPI容器对象至关重要。安装并使用了外部Python包来提供在管理对象时选择使用哪些容器的选项。
- en: These design patterns can help not only with managed objects in container but
    also when building scalable, enterprise-grade, and unconventionally complex applications.
    Most of these design patterns help break down monolithic architecture into loosely
    coupled components that are known as *microservices*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计模式不仅可以帮助容器中的管理对象，还可以在构建可扩展的、企业级和非常复杂的应用程序时使用。大多数这些设计模式有助于将单体架构分解为松散耦合的组件，这些组件被称为*微服务*。
- en: In this chapter, we will explore some architectural design patterns and principles
    that can provide strategies and ways to initiate the building of our microservices
    from a monolithic application. Our focus will be on breaking the huge application
    into business units, creating a sole gateway to bundle these business units, applying
    domain modeling to each of the microservices, and managing other concerns such
    as logging and application configuration.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些架构设计模式和原则，这些模式和原则可以提供策略和方法，从单体应用程序开始构建我们的微服务。我们的重点将放在将大型应用程序分解为业务单元，创建一个单独的网关来捆绑这些业务单元，将领域建模应用于每个微服务，以及管理其他关注点，如日志记录和应用程序配置。
- en: 'Aside from expounding the benefits and disadvantages of each design pattern,
    another objective is to apply these architectural patterns to our software specimen
    to show its effectiveness and feasibility. And to support these goals, the following
    topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阐述每种设计模式的利弊之外，另一个目标是将这些架构模式应用于我们的软件样本，以展示其有效性和可行性。为了支持这些目标，本章将涵盖以下主题：
- en: Applying the decomposition pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用分解模式
- en: Creating a common gateway
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建通用网关
- en: Centralizing the logging mechanism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中日志机制
- en: Consuming the REST APIs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费REST API
- en: Applying the domain modeling approach
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用领域建模方法
- en: Managing a microservice’s configuration details
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理微服务的配置细节
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter uses a *university ERP system* prototype that focuses on the students,
    faculty, and library submodules, but more on student-library and faculty-library
    operations (for example, book borrowing and issuing). Each submodule has its administration,
    management, and transaction services, and they are independent of each other even
    though they are part of an ERP specification. Currently, this sample prototype
    does not use any database management system, so all the data is temporarily stored
    in Python containers. The code is all uploaded at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)
    under the `ch04`, `ch04-student`, `ch04-faculty`, and `ch04-library` projects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用了一个*大学ERP系统*原型，该原型专注于学生、教职员工和图书馆子模块，但更侧重于学生-图书馆和教职员工-图书馆操作（例如，借书和发放）。每个子模块都有自己的管理、管理和交易服务，尽管它们是ERP规范的一部分，但它们之间是独立的。目前，这个示例原型没有使用任何数据库管理系统，因此所有数据都临时存储在Python容器中。代码全部上传到[https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)，在`ch04`、`ch04-student`、`ch04-faculty`和`ch04-library`项目中。
- en: Applying the decomposition pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用分解模式
- en: If we apply the monolithic strategy used in building the prototypes presented
    in the previous chapters, building this ERP will not be cost-effective in terms
    of resources and effort. There will be features that might become too dependent
    on other functions, which will put the teams of developers in a difficult situation
    whenever transaction problems occur due to these tightly coupled features. The
    best way to implement our University ERP prototype is to decompose the whole specification
    into smaller modules before the implementation starts.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用在前面章节中展示的原型中使用的单体策略，那么在资源和工作量方面，构建这个ERP将不会具有成本效益。可能会有一些功能可能会过于依赖其他功能，这将在这些紧密耦合的功能因交易问题而出现时，使开发团队陷入困境。实现我们的大学ERP原型的最佳方式是在实施开始之前将整个规范分解成更小的模块。
- en: 'There are two appropriate ways in which to decompose our application prototype,
    namely decomposition by business units and decomposition by subdomains:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种合适的方法可以对我们的应用程序原型进行分解，即按业务单元分解和按子域分解：
- en: '*Decomposition by business units* is used when the breakdown of the monolithic
    application is based on organizational structures, architectural components, and
    structural units. Usually, its resulting modules have fixed and structured processes
    and functionality that are seldom enhanced or upgraded.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按业务单元分解*用于当单体应用的分解基于组织结构、架构组件和结构单元时。通常，其结果模块具有固定和结构化的流程和功能，很少进行增强或升级。'
- en: '*Decomposition by subdomain* uses domain models and their corresponding business
    processes as the basis of the breakdown. Unlike the former, this decomposition
    strategy deals with modules that continuously evolve and change to capture the
    exact structure of the modules.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*按子域分解*使用领域模型及其相应的业务流程作为分解的基础。与前者不同，这种分解策略处理的是持续演变和变化的模块，以捕捉模块的确切结构。'
- en: 'Of the two options, decomposition by business units is the more practical decomposition
    strategy to use for our monolithic University ERP prototype. Since the information
    and business flow used by universities has been part of its foundation for years,
    we need to organize and breakdown its voluminous and compounded operations by
    colleges or departments. *Figure 4.1* shows the derivation of these submodules:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种选择中，按业务单元分解是我们用于单体大学ERP原型的更实用的分解策略。由于大学使用的信息和业务流程已经是其多年的基础，我们需要通过学院或部门对其庞大而复杂的操作进行组织和分解。*图4.1*显示了这些子模块的推导：
- en: '![Figure 4.1 – Decomposition by business units](img/Figure_4.1_B17975.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 按业务单元分解](img/Figure_4.1_B17975.jpg)'
- en: Figure 4.1 – Decomposition by business units
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 按业务单元分解
- en: 'After determining the submodules, we can implement them as independent microservices
    using the FastAPI framework. We can call an implementation of a business unit
    or module a microservice if its services *can collectively stand as one component*.
    Also, it must be able to *collaborate with other microservices* through *interconnection*
    based on the URL address and port number. *Figure 4.2* shows the project directories
    of the faculty, library, and student management modules implemented as FastAPI
    microservice applications. [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014)*, Setting
    Up FastAPI for Starters,* to [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052)*,*
    *Investigating Dependency Injection*, gave us the foundation to build a FastAPI
    microservice:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 确定子模块后，我们可以使用FastAPI框架将它们实现为独立的微服务。如果一个业务单元或模块的服务*可以作为一个组件整体存在*，那么我们可以将其实现称为微服务。此外，它还必须能够通过基于URL地址和端口号的*互连*与其他微服务*协作*。*图4.2*显示了作为FastAPI微服务应用程序实现的学院、图书馆和学生管理模块的项目目录。[*第1章*](B17975_01.xhtml#_idTextAnchor014)*，为初学者设置FastAPI*，到[*第3章*](B17975_03.xhtml#_idTextAnchor052)*，*调查依赖注入*，为我们构建FastAPI微服务奠定了基础：
- en: '![Figure 4.2 – The faculty, library, and student microservice applications](img/Figure_4.2_B17975.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 学院、图书馆和学生微服务应用程序](img/Figure_4.2_B17975.jpg)'
- en: Figure 4.2 – The faculty, library, and student microservice applications
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 学院、图书馆和学生微服务应用程序
- en: Each of these microservices is independent of the others in terms of its server
    instance and management. Starting and shutting down one of them will not affect
    the other two, as each can have a different context root and port. Each application
    can have a separate logging mechanism, dependency environment, container, configuration
    file, and any other aspect of a microservice, which will be discussed in the subsequent
    chapters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: But FastAPI has another way of designing microservices using a *mount* sub-application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Creating the sub-applications
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FastAPI allows you to build independent sub-applications inside the *main application*.
    Here, `main.py` serves as a gateway that provides a pathname to these mounted
    applications. It also creates the mounts specifying the context path mapped to
    the FastAPI instance of each sub-application. *Figure 4.3* shows a new university
    ERP implementation that has been built using mounts:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The main project with the mounts'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B17975.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – The main project with the mounts
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `faculty_mgt`, `library_mgt`, and `student_mgt` are typical independent
    microservice applications mounted into the `main.py` component, the top-level
    application. Each sub-application has a `main.py` component, such as `library_mgt`,
    which has its FastAPI instance created in its `library_main.py` setup, as shown
    in the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The student sub-application has a `student_main.py` setup that creates its
    FastAPI instance, as shown in the following code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Likewise, the faculty sub-application also has its `faculty_main.py` setup,
    as highlighted in the following code, for the same purpose, to build the microservice
    architecture:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These sub-applications are typical FastAPI microservice applications containing
    all of the essential components such as routers, middleware exception handlers,
    and all the necessary packages to build REST API services. The only difference
    from the usual applications is that their context paths or URLs are defined and
    decided by the top-level application that handles them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can run the `library_mgt` sub-application independently from
    `main.py` through the `uvicorn main:library_app --port 8001` command, `faculty_mgt`
    through `uvicorn main:faculty_app --port 8082`, and `student_mgt` through `uvicorn
    main:student_app --port 8003`. The option of running them independently despite
    the mount explains why these mounted sub-applications are all microservices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Mounting the submodules
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the FastAPI decorators of each sub-application must be mounted in the `main.py`
    component of the top-level application for them to be accessed at runtime. The
    `mount()` function is invoked by the FastAPI decorator object of the top-level
    application, which adds all FastAPI instances of the sub-applications into the
    gateway application (`main.py`) and maps each with its corresponding URL context.
    The following script shows how the mounting of the *library*, *student*, and *faculty*
    subsystems is implemented in the `main.py` component of the University ERP top-level
    system:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子应用的所有 FastAPI 装饰器都必须挂载在顶层应用的 `main.py` 组件中，以便在运行时访问。顶层应用的 FastAPI 装饰器对象调用
    `mount()` 函数，将子应用的所有 FastAPI 实例添加到网关应用（`main.py`）中，并将每个实例与其对应的 URL 上下文进行映射。以下脚本展示了在大学
    ERP 顶层系统的 `main.py` 组件中如何实现 *图书馆*、*学生* 和 *教师* 子系统的挂载：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this setup, the mounted `/ch04/student` URL will be used to access all
    the API services of the *student module* app, `/ch04/faculty` will be used for
    all the services of the *faculty module*, and `/ch04/library` will be used for
    the *library*-related REST services. These mounted paths become valid once they
    are declared in `mount()` because FastAPI automatically handles all of these paths
    through the `root_path` specification.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，挂载的 `/ch04/student` URL 将用于访问 *学生模块* 应用程序的所有 API 服务，`/ch04/faculty` 将用于
    *教师模块* 的所有服务，而 `/ch04/library` 将用于与 *图书馆* 相关的 REST 服务。一旦在 `mount()` 中声明，这些挂载路径就变得有效，因为
    FastAPI 会自动通过 `root_path` 规范处理所有这些路径。
- en: Since all three sub-applications of our *university ERP system* are independent
    microservices, now let us apply another design strategy that can help manage the
    requests to these applications just by using the main URL of the ERP system. Let
    us utilize the *main application* as a gateway to our sub-applications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们 *大学 ERP 系统* 的所有三个子应用都是独立的微服务，现在让我们应用另一种设计策略，该策略可以通过使用 ERP 系统的主 URL 来管理对这些应用的请求。让我们利用
    *主应用程序* 作为子应用的网关。
- en: Creating a common gateway
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个公共网关
- en: It will be easier if we use the URL of the main application to manage the requests
    and redirect users to any of the three sub-applications. The *main application*
    can stand as a pseudo-reverse proxy or an entry point for user requests, which
    will always redirect user requests to any of the desired sub-applications. This
    kind of approach is based on a design pattern called *API Gateway*. Now, let us
    explore how we can apply this design to manage independent microservices mounted
    onto the main application using a workaround.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用主应用程序的 URL 来管理请求并将用户重定向到任何三个子应用程序之一，将会更容易。*主应用程序* 可以作为一个伪反向代理或用户请求的入口点，始终将用户请求重定向到任何所需的子应用程序。这种方法基于称为
    *API 网关* 的设计模式。现在，让我们探索如何应用这种设计来管理挂载到主应用程序上的独立微服务，并使用一种变通方法。
- en: Implementing the main endpoint
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现主端点
- en: 'There are so many solutions when it comes to implementing this gateway endpoint,
    and among them is having a simple REST API service in the top-level application
    with an integer path parameter that will identify the `ID` parameter of the microservice.
    If the `ID` parameter is invalid, the endpoint will only return the `{''message'':
    ''University ERP Systems''}` JSON string instead of an error. The following script
    is a straightforward implementation of this endpoint:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在实现此网关端点时，有如此多的解决方案，其中之一是在顶层应用程序中有一个简单的 REST API 服务，该服务具有一个整数路径参数，用于识别微服务的
    `ID` 参数。如果 `ID` 参数无效，端点将只返回 `{''message'': ''University ERP Systems''}` JSON 字符串，而不是错误。以下脚本是这个端点的直接实现：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `access_portal` API endpoint is created as a GET path operation with `portal_id`
    as its path parameter. The `portal_id` parameter is essential to this process
    because it will determine which among the *Student*, *Faculty*, and *Library*
    microservices the user wants to access. Therefore, accessing the `/ch04/university/1`
    URL should lead the user to the student application, `/ch04/university/2` to the
    faculty microservice, and `/ch04/university/3` to the library application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`access_portal` API 端点是作为一个带有 `portal_id` 作为路径参数的 GET 路径操作创建的。`portal_id` 参数对于此过程至关重要，因为它将确定用户想要访问的
    *学生*、*教师* 和 *图书馆* 微服务中的哪一个。因此，访问 `/ch04/university/1` URL 应该将用户引导到学生应用程序，`/ch04/university/2`
    到教师微服务，而 `/ch04/university/3` 到图书馆应用程序。'
- en: Evaluating the microservice ID
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估微服务 ID
- en: 'The `portal_id` parameter will automatically be fetched and evaluated using
    a dependable function that is injected into the `APIRouter` instance where the
    API endpoint is implemented. As discussed in [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052),
    *Investigating Dependency Injection*, a *dependable function* or *object* can
    serve as a filter or validator of all incoming requests of any services once injected
    into an `APIRouter` or `FastAPI` instance. The dependable function used in this
    ERP prototype, as shown in the following script, evaluates whether the `portal_id`
    parameter is `1`, `2`, or `3` only:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`portal_id` 参数将自动使用一个可信赖的函数获取并评估，该函数被注入到实现 API 端点的 `APIRouter` 实例中。正如在 [*第
    3 章*](B17975_03.xhtml#_idTextAnchor052)，*调查依赖注入* 中所讨论的，一个 *可信赖的函数* 或 *对象* 可以在注入到
    `APIRouter` 或 `FastAPI` 实例后作为所有服务的所有传入请求的过滤器或验证器。在以下脚本中，这个 ERP 原型中使用的可信赖函数评估 `portal_id`
    参数是否为 `1`、`2` 或 `3`：'
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The given solution is a feasible workaround to trigger a custom event since
    FastAPI has no built-in event handling except for the startup and shutdown event
    handlers, which are topics in [*Chapter 8*](B17975_08.xhtml#_idTextAnchor229),
    *Creating Coroutines, Events, and Message-Driven Transactions*. So, once `call_api_gateway()`
    finds `portal_id` to be a valid microservice ID, it will raise some custom exceptions.
    It will throw `RedirectStudentPortalException` if the user wants to access the
    *Student* microservice. On the other hand, the `RedirectFacultyPortalException`
    error will be raised if the user desires the *Faculty* microservice. Otherwise,
    the `RedirectLibraryPortalException` error will be triggered when the *Library*
    microservice is the one wanted by the user. But first, we need to inject `call_api_gateway()`
    into the `APIRouter` instance handling the gateway endpoint through the `main.py`
    component of the top-level ERP application. The following script shows you how
    it is injected into `university.router` using the concepts discussed earlier:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的解决方案是一个可行的解决方案，用于触发自定义事件，因为 FastAPI 除了启动和关闭事件处理器外没有内置的事件处理功能，这些是 [*第 8 章*](B17975_08.xhtml#_idTextAnchor229)，*创建协程、事件和消息驱动事务*
    的主题。因此，一旦 `call_api_gateway()` 发现 `portal_id` 是一个有效的微服务 ID，它将引发一些自定义异常。如果用户想要访问
    *Student* 微服务，它将抛出 `RedirectStudentPortalException`。另一方面，如果用户想要 *Faculty* 微服务，将引发
    `RedirectFacultyPortalException` 错误。否则，当用户想要 *Library* 微服务时，将触发 `RedirectLibraryPortalException`
    错误。但首先，我们需要通过顶级 ERP 应用程序的 `main.py` 组件将 `call_api_gateway()` 注入到处理网关端点的 `APIRouter`
    实例中。以下脚本展示了如何使用前面讨论的概念将其注入到 `university.router` 中：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All of these raised exceptions require an exception handler that will listen
    to the throws and execute some of the tasks required to pursue the microservices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些引发的异常都需要一个异常处理器来监听抛出并执行追求微服务所需的某些任务。
- en: Applying the exception handlers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用异常处理器
- en: 'The exception handler does a redirection to the appropriate microservice. As
    you learned in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033), *Exploring the
    Core Features*, each thrown exception must have its corresponding exception handler
    to pursue the required response after the exception handling. Here are the exception
    handlers that will handle the custom exception thrown by `call_api_gateway()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理器将重定向到适当的微服务。正如你在 [*第 2 章*](B17975_02.xhtml#_idTextAnchor033)，*探索核心功能* 中所学到的，每个抛出的异常都必须有一个相应的异常处理器，在异常处理之后追求所需响应。以下是处理
    `call_api_gateway()` 抛出的自定义异常的异常处理器：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `exception_handler_student()` will redirect the user to the mount path
    of the *Student* microservice, while `exception_handler_faculty()` will redirect
    the user to the *Faculty* sub-application. Additionally, `exception_handler_library()`
    will let the user access the *Library* microservice. Exception handlers are the
    last component needed to complete the API Gateway architecture. The exceptions
    trigger the redirection to the independent microservices mounted on the FastAPI
    framework.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`exception_handler_student()` 将将用户重定向到 *Student* 微服务的挂载路径，而 `exception_handler_faculty()`
    将将用户重定向到 *Faculty* 子应用。此外，`exception_handler_library()` 将允许用户访问 *Library* 微服务。异常处理器是完成
    API 网关架构所需的最后一个组件。异常触发将用户重定向到安装在 FastAPI 框架上的独立微服务。
- en: Although there are other, better solutions to achieve the gateway architecture,
    our approach is still procedural and pragmatic without having to resort to external
    modules and tools, just the core components of FastAPI. [*Chapter 11*](B17975_11.xhtml#_idTextAnchor321),
    *Adding Other Microservices Features*, will discuss establishing an effective
    API Gateway architecture using Docker and NGINX.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有其他更好的解决方案来实现网关架构，但我们的方法仍然是通过不依赖外部模块和工具，仅使用FastAPI的核心组件来进行程序化和实用。[*第11章*](B17975_11.xhtml#_idTextAnchor321)，*添加其他微服务功能*，将讨论使用Docker和NGINX建立有效的API网关架构。
- en: Now, let us explore how to set up a centralized logging mechanism for this kind
    of microservices setup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们探索如何为这种微服务设置设置集中式日志机制。
- en: Centralizing the logging mechanism
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集中式日志机制
- en: We have created an audit trail mechanism with middleware and Python file transactions
    in [*Chapter 2*](B17975_02.xhtml#_idTextAnchor033), *Exploring the Core Features*.
    We have found out that middleware, which can only be set up through the FastAPI
    decorator of the top-level application, can manage incoming Request and outgoing
    Response of any API services. This time, we will be using custom middleware to
    set up a centralized logging feature that will log all service transactions of
    the top-level application alongside its independent mounted microservices. Of
    the many approaches for integrating these logging concerns into the application
    without changing the API services, we will concentrate on the following pragmatic
    custom approach with the custom middleware and *Loguru* module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第2章*](B17975_02.xhtml#_idTextAnchor033)，*探索核心功能*中创建了一个审计跟踪机制，使用了中间件和Python文件事务。我们发现，中间件只能通过顶级应用程序的FastAPI装饰器来设置，它可以管理任何API服务的传入请求和传出响应。这次，我们将使用自定义中间件来设置一个集中式日志功能，该功能将记录顶级应用程序及其独立挂载的微服务的所有服务事务。在许多将日志关注点集成到应用程序中而不更改API服务的方法中，我们将专注于以下具有自定义中间件和*Loguru*模块的实用自定义方法。
- en: Utilizing the Loguru module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用Loguru模块
- en: An *application log* is essential to any enterprise-grade application. For monolithic
    applications deployed in a single server, logging means letting service transactions
    write their log messages to a single file. On the other hand, logging can be too
    complex and complicated to implement in an independent microservices setup, especially
    when these services are for deployment to different servers or Docker containers.
    Its logging mechanism could even cause runtime problems if the module used is
    not adaptable to asynchronous services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*应用程序日志*对于任何企业级应用都是必不可少的。对于部署在单个服务器上的单体应用，日志意味着让服务事务将它们的日志消息写入单个文件。另一方面，在独立的微服务设置中，日志可能过于复杂和难以实现，尤其是在这些服务需要部署到不同的服务器或Docker容器时。如果使用的模块不适应异步服务，其日志机制甚至可能导致运行时问题。'
- en: 'For FastAPI instances that support both asynchronous and synchronous API services
    that run on an ASGI server, using Python’s logging module always generates the
    following error log:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同时支持异步和同步API服务且运行在ASGI服务器上的FastAPI实例，使用Python的日志模块总是会生成以下错误日志：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Opting for another logging extension is the only solution to avoid the error
    generated by the `logging` module. The best option is one that can fully support
    the FastAPI framework, which is the `loguru` extension. But first, we need to
    install it using the `pip` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择另一个日志扩展是避免由`logging`模块生成的错误的唯一解决方案。最佳选择是能够完全支持FastAPI框架的扩展，即`loguru`扩展。但首先，我们需要使用`pip`命令安装它：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Loguru is a straightforward and easy-to-use logging extension. We can immediately
    log using its default handler, the `sys.stderr` handler, even without adding much
    configurations. Since our application needs to place all messages in a log file,
    we need to add the following lines to the `main.py` component of the top-level
    application right after the instantiation of `FastAPI`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Loguru是一个简单易用的日志扩展。我们可以立即使用其默认处理器，即`sys.stderr`处理器进行日志记录，甚至无需添加太多配置。由于我们的应用程序需要将所有消息放置在日志文件中，我们需要在顶级应用程序的`main.py`组件中`FastAPI`实例化之后添加以下行：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that its `logger` instance has an `add()` method where we can register
    *sinks*. The first part of the *sinks* is the *handler* that decides whether to
    emit the logs in `sys.stdout` or the file. In our university ERP prototype, we
    need to have a global `info.log` file that contains all the log messages of the
    sub-applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: A crucial part of the log sink is the `level` type, which indicates the granularity
    of log messages that need to be managed and logged. If we set the `level` parameter
    of `add()` to `INFO`, it tells the logger to consider only those messages under
    the `INFO`, `SUCCESS`, `WARNING`, `ERROR`, and `CRITICAL` weights. The logger
    will bypass log messages outside these levels.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Another part of the *sinks* is the `format` log, where we can create a custom
    log message layout to replace its default format. This format is just like a Python
    interpolated string without the *"f"* that contains placeholders such as `{time}`,
    `{level}`, `{message}`, and any custom placeholders that need to be replaced by
    `logger` at runtime.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In `log.file`, we want our logs to start with the `Log` keyword followed immediately
    by the custom-generated `log_id` parameter and then the time the logging happened,
    the level, and the message.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: And to add support for asynchronous logging, the `add()` function has an `enqueue`
    parameter that we can enable anytime. In our case, this parameter is default to
    `True` just to prepare for any `async/await` execution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot to explore with Loguru’s features and functionality. For instance,
    we can create additional handlers for loggers to emit where each of these handlers
    has different retention, rotation, and rendition types. Additionally, Loguru can
    allow us to add colors to our logs through some color markups such as `<red>`,
    `<blue>`, or `<cyan>`. It also has an `@catch()` decorator that can be applied
    to manage exceptions at runtime. All the logging features we need to set up our
    unified application log are in Loguru. Now that we have configured our Loguru
    in the top-level application, we need to let its logging mechanism work across
    the three sub-applications or microservices without modifying their code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Building the logging middleware
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The core component of this centralized application log is the custom middleware
    that we must implement in the `main.py` component where we set up Loguru. FastAPI’s
    *mount* allows us to centralize some cross-cutting concerns such as logging without
    adding anything to the sub-applications. One middleware implementation in the
    `main.py` component of the top-level application is good enough to pursue logging
    across the independent microservices. The following is the middleware implementation
    for our specimen application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, `log_middleware()` will generate a `log_id` parameter every time it
    intercepts any API services from the main app or the sub-applications. Then, the
    `log_id` parameter is injected into the `dict` of context information through
    Loguru’s `contextualize()` method since `log_id` is part of the log information,
    as indicated in our log format setup. Afterward, logging starts before the API
    service is executed and after its successful execution. When exceptions are encountered
    during the process, the logger will still generate a log message with the `Exception`
    message. So, whenever we access any API services anywhere from the ERP prototype,
    the following log messages will be written in `info.log`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The given snapshot of log messages proves that we have a centralized setup because
    the middleware filters all API service execution and performs the logging transaction.
    It shows that the logging started from accessing the gateway down to executing
    the API services from the *faculty*, *student*, and *l**ibrary* sub-applications.
    Centralizing and managing cross-cutting concerns is one advantage that can be
    provided by using FastAPI’s *mounting* when building independent microservices.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: But when it comes to the interactions among these independent sub-applications,
    can mounting also be an advantage? Now, let us explore how independent microservices
    in our architecture can communicate by utilizing each other’s API resources.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the REST API services
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in an unmounted microservices setup, mounted ones can also communicate
    by accessing each other’s API services. For instance, if a faculty member or student
    wants to borrow a book from the library, how can that setup be implemented seamlessly?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4.4*, we can see that interactions can be possible by establishing
    a client-server communication wherein one API service can serve as a resource
    provider, and the others are the clients:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Interaction with the faculty, student, and library microservices'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B17975.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Interaction with the faculty, student, and library microservices
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Consuming API resources in FastAPI can be straightforward using the `httpx`
    and `requests` external modules. The following discussions will focus on how these
    two modules can help our mounted services interact with each other.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Using the httpx module
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `httpx` external module is a Python extension that can consume both asynchronous
    and synchronous REST APIs and has *HTTP/1.1* and *HTTP/2* support. It is a fast
    and multi-purpose toolkit that is used to access API services running on WSGI-based
    platforms, as well as, on ASGI, like the FastAPI services. But first, we need
    to install it using `pip`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we can use it directly without further configuration to make two microservices
    interact, for instance, our *student* module submitting assignments to the *faculty*
    module:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `httpx` module can process the `GET`, `POST`, `PATCH`, `PUT`, and `DELETE`
    path operations. It can allow the passing of different request parameters to the
    requested API without so much complexity. The `post()` client operation, for instance,
    can accept headers, cookies, params, json, files, and model data as parameter
    values. We use the `with` context manager to directly manage the streams created
    by its `Client()` or `AsyncClient()` instances, which are closeable components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `list_assignments` service is a client that uses the `AsyncClient()`
    instance to pursue its GET request from an asynchronous `/ch04/faculty/assignments/list`
    API endpoint from the f*aculty* module. `AsyncClient` accesses the WSGI-based
    platform to execute any asynchronous services, not the synchronous ones, or else
    it will throw *Status Code 500*. It might require additional configuration details
    in its constructor for some complex cases, where it needs to further manage resource
    access through ASGI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `submit_assignment` service is a synchronous client that
    accesses another synchronous endpoint, `ch04/faculty/assignments/student/submit`,
    which is a `POST` HTTP operation. In this case, the `Client()` instance is used
    to access the resource to submit an assignment to the *Faculty* module through
    a `POST` request. `AssignmentRequest` is a `BaseModel` object that needs to be
    filled up by the client for submission to the request endpoint. Unlike `params`
    and `json`, which are passed straightforwardly as `dict`, `data` is a model object
    that must be first converted into `dict` by `jsonable_encoder()` and `json.dumps()`
    to make the transport feasible across the HTTP. The new converted model becomes
    the argument value of the `data` parameter of the POST client operation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the response of the client services, we can allow the response
    to be treated as a piece of text using the module’s `content` or as a JSON result
    using `json()`. It now depends on the requirement of the client service as to
    what response type to use for the application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Using the requests module
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another option to establish client-server communication among microservices
    is the `requests` module. Although `httpx` and `requests` are almost compatible,
    the latter offers other features such as auto-redirection and explicit session
    handling. The only problem with `requests` is its non-direct support to asynchronous
    APIs and its slow performance when accessing resources. Despite its drawbacks,
    the `requests` module is still the standard way of consuming REST APIs in Python
    microservice development. First, we need to install it before we can use it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our ERP prototype, the `requests` extension was used by the *faculty* microservice
    to borrow books from the *library* module. Let’s look at the *Faculty* client
    services that show us how the `requests` module is used to access the synchronous
    API of *library*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `requests` module has a `Session()` instance, which is equivalent to `Client()`
    in the `httpx` module. It provides all the necessary client operations that will
    consume the API endpoints from the FastAPI platform. Since `Session` is a closeable
    object, the context manager is, again, used here to handle the streams that will
    be utilized during the access of the resources and transport of some parameter
    values. Like in `httpx`, parameter details such as `params`, `json`, `header`,
    `cookies`, `files`, and `data` are also part of the `requests` module and are
    ready for transport through the client operation if needed by the API endpoints.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding code, we can see that sessions are created to implement the
    `list_all_request` and `list_all_issuance` `GET` client services. Here, `request_borrow_book`
    is a `POST` client service that requests a book in the form of `BookRequestReq`
    from the `/ch04/library/book/request` API endpoint. Similar to `httpx`, `jsonable_encoder()`
    and `json.dumps()` must be used to convert the `BaseModel` object into `dict`
    in order to be transported as a `data` parameter value. The same approach is also
    applied to the `return_book` `POST` client service, which returns the book borrowed
    by the faculty. The responses of these client services can also be `content` or
    `json()` just like what we have in the `httpx` extension.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Using the `requests` and `httpx` modules allows these mounted microservices
    to interact with each other based on some specification. Consuming exposed endpoints
    from other microservices minimizes tight coupling and strengthens the importance
    of the decomposition design pattern of building independent microservices.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The next technique gives you the option of managing components within a microservice
    using *domain modeling*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Applying the domain modeling approach
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications that are database-focused or built from core functionalities without
    collaborating with models are either not easy to manage when they scale up or
    not friendly when enhanced or bug-fixed. The reason behind this is the absence
    of the structure and flow of business logic to follow, study, and analyze. Understanding
    the behavior of an application and deriving the domain models with the business
    logic behind them encompasses the best approach when it comes to establishing
    and organizing a structure in an application. This principle is called the *domain
    modeling approach*, which we will now apply to our ERP specimen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Creating the layers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Layering is one implementation that is inevitable when applying domain-driven
    development. There is a dependency between *layers* that, sometimes, might pose
    problems when fixing bugs during development. But what are important in layered
    architectures are the concepts, structures, categories, functionalities, and roles
    that *layering* can create, which helps in understanding the specification of
    the application. *Figure 4.5* shows the *models*, *repositories*, *services*,
    and *controllers* of the sub-applications:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Layered architecture'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B17975.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Layered architecture
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The most crucial layer is the `models` layer, which consists of the domain model
    classes that describe the domain and business processes involved in the application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the domain models
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *domain model layer* is the initial artifact of the application because
    it provides the contextual framework of the application. Business processes and
    transactions can be easily classified and managed if domains are first determined
    during the initial phase of the development. The code organization created by
    domain layering can provide code traceability, which can ease source code updates
    and debugging.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In our ERP specimen, these models are categorized into two: the *data* and
    *request* models. The data models are those used to capture and store data in
    its temporary data stores, while the request models are the `BaseModel` objects
    used in the API services.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the *faculty* module has the following data models:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These data model classes always have their constructors implemented if constructor
    injection is needed during instantiation. Moreover, the `__repr__()` and `__str__()`
    dunder methods are optionally there to provide efficiency for developers when
    accessing, reading, and logging these objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the request models are familiar because they were already
    discussed in the previous chapter. Additionally, the *faculty* module has the
    following request models:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The request models listed in the preceding snippet are just simple `BaseModel`
    types. For further details on how to create `BaseModel` classes, [*Chapter 1*](B17975_01.xhtml#_idTextAnchor014),
    *Setting Up FastAPI for Starters*, provides guidelines for creating different
    kinds of `BaseModel` classes to capture different requests from clients.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Building the repository and service layers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The two most popular domain modeling patterns that are crucial in building
    the layers of this approach are the *repository* and *service layer patterns*.
    The repository aims to create strategies for managing data access. Some repository
    layers only provide data connectivity to the data store like in our specimen here,
    but oftentimes, repository''s goal is to interact with the **Object Relational
    Model** (**ORM**) framework to optimize and manage data transactions. But aside
    from the access, this layer provides a high-level abstraction for the application
    so that the specific database technology or *dialect* used will not matter to
    the applications. It serves as an adapter to any database platform to pursue data
    transactions for the application, nothing else. The following is a repository
    class of the *faculty* module, which manages the domain for creating assignments
    for their students:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `AssignmentRepository` manages the `Assignment` domain object using its
    four repository transactions. Additionally, `insert_assignment()` creates a new
    `Assignment` entry in the `faculty_assignment_tbl` dictionary, and `update_assignment()`
    accepts new details or the corrected information of an existing assignment and
    updates it. On the other hand, `delete_assignment()` deletes an existing `Assignment`
    entry from the data store using its `assign_id` parameter. To retrieve all the
    created assignments, the repository class has `get_all_assignment()`, which returns
    all the entries of `faculty_assignments_tbl`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The service layer pattern defines the algorithms, operations, and process flows
    of the applications. Oftentimes, it interacts with the repository to build the
    necessary business logic, management, and controls for the other components of
    the application, such as the API services or controllers. Usually, one service
    caters to one repository class or more depending on the specification of the project.
    The following code snippet is a service that interfaces a repository to provide
    additional tasks such as UUID generation for a student workbin:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `AssignmentSubmissionService` cited in the preceding code has methods that
    utilize the `AssignmentSubmissionRepository` transactions. It provides them with
    parameters and returns the `bool` results for evaluation by other components.
    Other services might look more complicated than this sample because algorithms
    and tasks are usually added to pursue the requirements of the layers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The successful wiring of a repository class to the service happens in the latter’s
    constructor. Usually, the repository class is instantiated just like in the preceding
    sample. Another fantastic option is to use DI, as discussed in [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Using the factory method pattern
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *factory method design pattern* is always a good approach for managing injectable
    classes and functions using the `Depends()` component. [*Chapter 3*](B17975_03.xhtml#_idTextAnchor052)
    showcased factory methods as mediums to inject the repository components into
    the service instead of instantiating them directly within the service. The design
    pattern provides loose coupling between components or layers. This approach is
    highly applicable to large applications wherein some modules and sub-components
    are reused and inherited.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us look at how the top-level application can manage the different configuration
    details of these mounted and independent microservice applications.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Managing a microservice’s configuration details
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, this chapter has provided us with some popular design patterns and
    strategies that can give us a kickstart on how to provide our FastAPI microservices
    with the best structures and architecture. This time, let us explore how the FastAPI
    framework supports storing, assigning, and reading configuration details to mounted
    microservice applications such as database credentials, networking configuration
    data, application server information, and deployment details. First, we need to
    install `python-dotenv` using `pip`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All of these settings are values that are external to the implementation of
    the microservice applications. Instead of hardcoding them into the code as variable
    data, usually, we store them in the *env*, *property*, or *INI* files. However,
    challenges arise when assigning these settings to different microservices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks that support the *externalized configuration design pattern* have
    an internal processing feature that fetches environment variables or settings
    without requiring additional parsing or decoding techniques. For instance, the
    FastAPI framework has built-in support for externalized settings through pydantic’s
    `BaseSettings` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Storing settings as class attributes
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our architecture setup, it should be the top-level application that will
    manage the externalized values. One way is to store them in a `BaseSettings` class
    as attributes. The following are classes of the `BaseSettings` type with their
    respective application details:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, `FacultySettings` will be assigned to the *f**aculty* module since it
    carries some information regarding the module. `LibrarySettings` is for the *library*
    module to utilize, while `StudentSettings` is for the *student* module.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch the values, first, a component in a module must import the `BaseSettings`
    class from the main project’s `/configuration/config.py` module. Then, it needs
    an injectable function to instantiate it before injecting it into a component
    that needs to utilize the values. The following script is part of `/student_mgt/student_main.py`,
    where the settings need to be retrieved:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `build_config()` is an injectable function that injects the `StudentSettings`
    instance into the `/index` endpoint of the *s**tudent* microservice. After the
    DI, the application, webmaster, and created values will become accessible from
    the `config` wired object. These settings will appear on the browser right after
    calling the `/ch04/university/1` gateway URL.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Storing settings in the properties file
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another option is to store all these settings inside a physical file with an
    extension of `.env`, `.properties`, or `.ini`. For instance, this project has
    the `erp_settings.properties` file found in the `/configuration` folder, and it
    contains the following application server details in *key-value* pair format:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To fetch these details, the application needs another `BaseSettings` class
    implementation that declares the *key* of the *key-value* pair as attributes.
    The following class shows how `production_server`, `prod_port`, `development_server`,
    and `dev_port` are declared without any assigned values:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Aside from the class variable declaration, `BaseSetting` requires an implementation
    of an *inner class*, called `Config`, with a predefined `env_file` assigned to
    the current location of the properties file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The same processes are involved when it comes to accessing the property details
    from the file. After importing `ServerSettings`, it needs an injectable function
    to inject its instance to the components that need the details. The following
    script is an updated version of `/student_mgt/student_main.py`, which includes
    access to the `development_server` and `development_port` settings:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Based on this enhanced script, running the `/ch04/university/1` URL will redirect
    the browser to a screen showing additional server details from the properties
    file. Managing configuration details in FastAPI is easy, as we either save them
    inside a class or inside a file. No external module is necessary, and no special
    coding effort is required to fetch all these settings, just the creation of the
    `BaseSettings` classes. This easy setup contributes to building flexible and adaptable
    microservice applications that can run on varying configuration details.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapter started with the decomposition pattern, which is useful for breaking
    down a monolithic application into granularized, independent, and scalable modules.
    The FastAPI application that implemented these modules exhibited some principles
    included in the *12-Factor Application principles* of a microservice, such as
    having independence, configuration files, logging systems, code bases, port binding,
    concurrency, and easy deployment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Alongside decomposition, this chapter also showcased the *mounting of different
    independent sub-applications* onto the FastAPI platform. Only FastAPI can group
    independent microservices using mounts and bind them into one port with their
    corresponding context roots. From this feature, we created a pseudo-API Gateway
    pattern that serves as a façade to the independent sub-applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Despite the possible drawbacks, the chapter also highlighted domain modeling
    as an option for organizing components in a FastAPI microservice. The *domain*,
    *repository*, and *service* layers help manage the information flow and task distribution
    based on the project specification. Tracing, testing, and debugging are easy when
    domain layers are in place.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on integrating our microservice applications
    with a relational database platform. The focus is to establish database connectivity
    and utilize our data models to implement CRUD transactions within the repository
    layer.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Data-Centric and Communication-Focused Microservices Concerns and Issues'
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part of the book, we will be exploring other FastAPI components and
    features to solve other design patterns that the API framework can build, looking
    at data, communication, messaging, reliability, and security. External modules
    will also be highlighted in order to pursue other behavior and frameworks, such
    as ORM and reactive programming.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'This part comprises the following chapters:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B17975_05.xhtml#_idTextAnchor107), Connecting to a Relational
    Database'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B17975_06.xhtml#_idTextAnchor155), Using a Non-Relational Database'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B17975_07.xhtml#_idTextAnchor190), Securing the REST APIs'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B17975_08.xhtml#_idTextAnchor229), Creating Coroutines, Events,
    and Message-Driven Transactions'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
