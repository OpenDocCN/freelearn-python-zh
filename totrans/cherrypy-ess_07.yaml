- en: Chapter 7. The Presentation Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have developed our application from a server-side point of view.
    In this chapter, we will start focusing on the client side of the photoblog. Initially,
    we will introduce HTML templating via the `Kid` Python engine and JavaScript via
    the Mochikit library. We will present briefly a few important components of the
    success of the Web such as HTML, XHTML, and CSS. However, these sections do not
    aim at explaining each of them deeply, as this is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although in our previous chapter, we introduced the separation of concerns between
    layers within our application, we need to keep in mind that our primary target
    is Internet browsers, so we will focus on HTML rendering.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML** (**HyperText Markup Language**), used right from the beginning of
    the Web as defined by Tim Berners-Lee in the early 1990s, is a light version of
    **SGML** (**Standard Generalized Markup Language**) keeping only simple elements
    that are useful for the Web. Due to the quick growth of the Web, further development
    was achieved on HTML to improve it. Eventually HTML 4.0 was officially specified
    in 1997 by the W3C with an update in 1999 leading to HTML 4.01, which is still
    as of today the official version to use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of an HTML 4.01 document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the document states the DOCTYPE declaration, specifying which
    variant of a format a document follows. DOCTYPEs are specified in DTDs (Document
    Type Definitions).
  prefs: []
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 1996, W3C started to work on **XML** (**Extensible Markup Language**), a
    generic simpler markup language derived from SGML keeping its power while avoiding
    its complexity. In the context of the Web, the goal of XML is aimed at solving
    a few limitations of HTML, such as the lack of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensibility:** HTML did not allow new elements to be added to the language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validation:** HTML did not offer a language to validate against the structure
    nor the semantics of a document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structure:** HTML did not allow complex structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to XML, expressive and flexible work was undertaken by W3C to reformulate
    HTML 4 through XML, leading to specification of XHTML 1.0 in the year 2000.
  prefs: []
  type: TYPE_NORMAL
- en: 'XHTML 1.0 has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: User agents that solely understand HTML 4 can render a document, making it backward
    compatible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishers can enter the XML world and its richness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example of an XHTML 1.0 document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we also specify a DOCTYPE declaration informing consumers
    that our document respects the XHTML 1.0 Strict DTD. Since XHTML is an application
    of XML:'
  prefs: []
  type: TYPE_NORMAL
- en: We provide the XML declaration on the very first line to give the XML-consuming
    processor some hints about the document content, such as the fact that it is encoded
    in UTF-8\. Note that it is not compulsory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also explicitly mark the anonymous namespace of that document as the XHTML
    namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the syntax for both the documents is very close, they carry different
    semantics and would be treated differently by user agents. Therefore, both the
    documents have distinct MIME formats. An HTML document should be served using
    the `text/html` MIME content-type, while XHTML documents should be served via
    `application/xhtml+xml`. However, because XHTML 1.0 aims at being backward compatible
    with user agents that do not understand its MIME content-type, it is allowed to
    serve an XHTML 1.0 document respecting specific guidelines as `text/html`. This
    is, however, not recommended and can lead to unexpected rendering that depends
    on how user agents treat the structure of the document; it is often referred as
    *tag-soup*.
  prefs: []
  type: TYPE_NORMAL
- en: For these reasons, serving XHTML can be cumbersome on the Internet and is the
    root of extremely heated discussions. Our photoblog application will therefore
    keep it simple by using HTML.
  prefs: []
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether you use HTML or XHTML, both formats only specify the structure and
    the semantics of your pages; they do not inform user agents how they ought to
    render those pages. This is achieved through CSS (Cascading Style Sheets), a language
    to describe rules to apply on elements within a marked up document such as HTML
    or XHTML. A rule is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A *selector* indicates the element on which the rule is to be applied. The selector
    can be precise to target only one specific element within the context of the document
    or applicable to all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more *attributes* indicate which property of the element is involved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *value* or a set of values is associated to each attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example applied to the previous HTML example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`body` is the selector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`background-color` is the attribute, whose value is `#666633`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the previous example, we have embedded the CSS within the HTML document
    itself. It is advisable to externalize it into its own document and link it from
    the HTML page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The CSS file, `style.css`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: DHTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Tim Berners-Lee imagined the Web, he did so to enable the exchange of documents
    between researchers. Those documents were static and were not generated by the
    web application. In fact, web applications did not exist at that time, only web
    servers that were accepting requests and returning content. Since then, the Web
    has grown much more value and web applications are a reality. Nonetheless, for
    a long time the component achieving the work has been the server itself, the client
    only being required to display the rendered content. Quickly enough however, it
    appeared that providing much fancier interfaces would move the Web one step further
    for it to attract a larger public. The Web should, could, and would be more than
    presenting books or papers on a screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term DHTML (Dynamic HTML) was coined to group a set of technologies to
    improve client-side content handling. DHTML encompasses:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML defining the structure of the document to manipulate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS to style the web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript to dynamically modify the Document Object Model (DOM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A DOM is a memory representation of the (X)HTML document structure built by
    the browser. By using JavaScript functions, it is possible to dynamically modify
    the DOM tree and thus change its rendering from the end-user perspective.
  prefs: []
  type: TYPE_NORMAL
- en: However interesting the idea behind DHTML was, it never really took off due
    to interoperability issues between browser vendors. JavaScript and CSS were not
    implemented equally across navigators making it really hard for web developers
    to ensure their page would act as expected in most cases. Nowadays, DHTML is not
    a common term in the field but its ideas have been kept and improved in newer
    techniques. This has been also possible thanks to a better interoperability between
    browsers, better debugging tools, and the arrival of dedicated JavaScript toolkits
    or frameworks encapsulating browser differences in a common API, as we will see
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we have introduced the basic components that constitute
    web pages—HTML or XHTML for the structure and CSS for the style. Generating web
    pages can be as easy as using your favorite text editor and laying it down. However
    in the context of a dynamic application, where the content is based on a given
    context and generated on the fly, you need tools to ease such creation. This is
    achieved through the use of templating engines. A templating engine takes a model
    of the page as well as the input data and then processes both to render the final
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'When searching for a templating engine, you should look for one that offers
    at least some features such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable substitution: In your template, a variable can act as place holder
    for your input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Conditional statements: It is common that a template needs to be rendered with
    slight differences based on the context of the input data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looping mechanism: This is obviously mandatory when your template has to render
    a set of data into a table for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extensibility: Templates can often share aspects and diverge in some specific
    contexts, for example common header and footer templates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python world is anything but short in templating engines, and selecting
    one for your needs will certainly be a matter of taste based on its features as
    well as its syntax. For the purpose of this book, we will use a templating engine
    named `Kid` developed by Ryan Tomayko.
  prefs: []
  type: TYPE_NORMAL
- en: Kid—The Templating Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will have some description of our `Kid` engine.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start our introduction to the `Kid` engine by creating a template of
    our previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, a template looks very similar to the final expected rendered
    page. When you save this template in a file named `helloworld.kid`, the next step
    is to process the template via the `Kid` engine as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Kid` provides a `Template` function that requires the name of the template
    to be processed and the input data to be passed on during the rendering of the
    template. When a template is being processed for the first time, `Kid` creates
    a Python module that serves as a cached version of the template for latter use.
    The `kid.Template` function returns an instance of the `Template` class you then
    use to render the output content. To do so, the `Template` class provides the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serialize:` This returns the output content as a Python string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generate:` This returns the output content as a Python iterator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write:` This dumps the output content into a file object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three methods take the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`encoding:` This informs `Kid` how to encode the output content; it defaults
    to UTF-8.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fragment:` This is a Boolean value asking `Kid` to include or not the XML
    prolog or Doctype in the final result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output:` This specifies which type of serialization should be used by `Kid`
    to render the content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kid's Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The attributes of `Kid` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: XML-Based Templating Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Kid` is an XML-based language, which means:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Kid` template must be a well-formed XML document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Kid` uses attributes within XML elements to inform the underlying engine what
    action to follow when reaching an element. To avoid collision with other existing
    attributes within the XML document, `Kid` comes with its own namespace ([http://purl.org/kid/ns#](http://purl.org/kid/ns#)),
    most of the time associated with the `py` prefix, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Variable Substitution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Kid` comes with a very simple variable substitution scheme: `${variable-name}`.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be used either in attributes of elements or as the text content of
    an element. `Kid` will evaluate the variable each time it comes across it in the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to output a literal string such as `${something}`, you can escape
    the variable substitution by doubling the dollar sign such as `$${something}`,
    which will be rendered as `${something}`.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you need to toggle between different cases in a template, you need to
    use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tag` is the name of the element, for instance `DIV` or `SPAN`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expression` is a Python expression. If as a Boolean it evaluates to `True`
    the element will be included in the output content. Otherwise, the element will
    not be part of it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping Mechanism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To tell `Kid` to loop on an element, you must use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tag` is the name of the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expression` is a Python expression, for example `for value in [...]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The looping mechanism is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Extensibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Extending a template is done using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tag` is the name of the element. In this specific case however, the element
    can only be the root element of the current template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates` is a comma-separated list of `Kid` template filenames or instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, define a `Kid` template named `common.kid:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the template of the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When `Kid` processes that template, it will first compile the `common.kid` template.
    When `Kid` meets the`<this-is-ed />` element, it will understand that it matches
    the head element of the `common.kid` template, and will replace its content.
  prefs: []
  type: TYPE_NORMAL
- en: Other Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Kid` comes with more attributes to the basic ones we have reviewed before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`py:content="expression":` The descendant of the element using this attribute
    will be replaced by the output content of the expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`py:strip="expression":` If the expression evaluates to `True`, the containing
    element will not be present in the result but its descendants will be there. If
    the expression evaluates to `False`, the processing goes as normal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`py:replace="expression":` This is a shortcut for `py:content="expression"
    py:strip="True"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`py:attrs="expression":` This allows dynamic insertion of new attributes into
    the element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`py:def="template_name(args)":` This allows creation of a temporary template
    that can be referenced elsewhere in the main template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get more information by navigating to the official `Kid` documentation
    available at [http://kid-templating.org/](http://kid-templating.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Photoblog Design Preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we have introduced tools that we will use to create
    our application interface. In the following sections, we will create the base
    of that interface.
  prefs: []
  type: TYPE_NORMAL
- en: Targetting the User Agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering the fact that the photoblog application is centered on the images
    to be displayed, we will disregard user agents not supporting that feature. The
    application will also heavily use client-side code through JavaScript. Thus, we
    will solely focus on the modern browser engines supporting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief list of our principal targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Engine | Browsers Targeted |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Gecko | Mozilla Firefox 1.5 and above, Netscape 8 |'
  prefs: []
  type: TYPE_TB
- en: '| MSHTML | Internet Explorer 6 SP1 and above |'
  prefs: []
  type: TYPE_TB
- en: '| KHTML (and WebKit) | Konqueror, Safari |'
  prefs: []
  type: TYPE_TB
- en: '| Presto | Opera 9 and above |'
  prefs: []
  type: TYPE_TB
- en: Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this application you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: A text editor; your favorite text editor will do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A browser providing development tools; Mozilla Firefox with the following extensions
    would be a good choice:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web developer or Firebug
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: LiveHTTPHeader or Tamper Data. Alternatively, CherryPy provides the `log_headers`
    tool, which when enabled in the global settings of CherryPy will log the request
    headers on the server allowing an easy debugging per request.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: DOM inspector
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript debugger
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, although we will be doing most of our development using one specific
    browser, it is recommended to test it regularly using as many browsers as you
    can.
  prefs: []
  type: TYPE_NORMAL
- en: Global Design Goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said, the photoblog application is focused on images. With this in mind,
    we will draw a globally designed interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Global Design Goals](img/1848_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, our default design will not have the fanciest look but it provides
    us with the basic structure for a blog that we are looking for, to explore web
    design.
  prefs: []
  type: TYPE_NORMAL
- en: The topmost area will be our header. This is where you will put the catchy name
    of your blog. Right under it we will have the navigation menu with a few links
    to move through the base areas of the blog. Then we will have the content area
    where we will only display by default photography. It means that by default no
    text will be displayed and it will require user interaction to reveal it. This
    ensures that the focus stays on the photography. However, the content area will
    stretch as requested, when it has to display text content. Finally, there is a
    footer area containing information about the copyrights of the content of this
    blog.
  prefs: []
  type: TYPE_NORMAL
- en: Design Directory Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The design that we will use for the photoblog application will reside in the
    following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will name this design *default*, as it will be the one shipped with the application
    and used by default during the first access to the application.
  prefs: []
  type: TYPE_NORMAL
- en: You will note that the `js` directory is empty in spite of intensive use of
    JavaScript. The reason is that we will define a global static directory of files
    that might be shared by different templates, which could be the case with all
    the JavaScript files we will create.
  prefs: []
  type: TYPE_NORMAL
- en: CherryPy—Encapsulating the Template Rendering Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CherryPy handlers could well be fine calling `Kid` themselves and returning
    the serialized output of a template but we will not do it that way. Instead, we
    will encapsulate `Kid` into a CherryPy tool that our handlers will call. There
    are two reasons for such a decision:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow you to switch from `Kid` to a different templating engine. Imagine
    that you prefer the `Cheetah` templating engine to `Kid`. You could write a template
    with `Cheetah` and only modify the tool without having to go through the entire
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To ease the maintenance. If `Kid` evolves and changes its syntax, it will be
    easier to update just the tool rather than the entire application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tool named `Design` is attached to the default CherryPy toolbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will use the tool like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A page handler using that tool will be required to return a Python dictionary
    containing values to be passed to the templating engine and expected by the template.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the tool expects a `path` parameter that will not be passed to
    the decorator call itself. That `path` represents the absolute base path of the
    folder containing a design directory and in our example `path` would be the `default`
    directory that we have already defined. We will set this value once in a configuration
    file that will be attached to the CherryPy application. We will see more details
    about this in[Chapter 10](ch10.html "Chapter 10. Deployment").
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Christian Wyglendowski is the maintainer of a project called Buffet that aims
    at providing the core feature demonstrated in the mentioned tool. It supports
    many templating languages and offers an extended API. However, it currently supports
    solely CherryPy 2 and therefore it is not used in this chapter. CherryPy 3 support
    is planned and will certainly be available soon.
  prefs: []
  type: TYPE_NORMAL
- en: Photoblog Design in Detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will have a look at the basic structure of our photoblog design.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first step is to define the HTML structure of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This template, which we will name `index.kid`, extends the template `common.kid`.
    It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `head` element of the `index.kid` template will be replaced by that of the
    `Kid` template named `common.kid`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will process that template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you navigate to [http://localhost:8080/](http://localhost:8080/), it
    should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Structure](img/1848_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to add the CSS stylesheet by modifying the `common.kid` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the CSS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you reload the page, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Structure](img/1848_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have the main page of our photoblog application. The following configurations
    will make us understand how we will handle the other pages of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One `Kid` template per page: In this configuration, each time a link is followed
    or a form is submitted to the application, a new page will be constructed on the
    server from its template and will be sent back to the browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantage: It is easy for the web designer who can now edit every page.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drawback: It feels less dynamic from the end-user point of view. It feels as
    if the navigation is done *per page*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One or two templates and a bunch of JavaScript files: In this case, only one
    page would be sent to the browser but it will contain enough information for the
    browser to generate and insert blocks of content depending on the context and
    end-user interaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantage: It feels much more dynamic for the end-user. Less processing is
    done by the server, which sends data to be processed by the user agent.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drawback: It is less intuitive for the web designer. It will not work on user
    agents that do not support JavaScript.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One `Kid` template per block of content to be displayed: This is a mix between
    the previous two solutions. One page will be sent to the user agent and upon user
    interaction, the browser will go and fetch extra blocks of content generated on
    the server from the `Kid` templates that will be inserted directly within the
    web page. This technique is referred as AHAH (Asynchronous HTML and HTTP), as
    we will see in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advantage: It is easy for the web developer who works on HTML code, as in the
    first solution.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Drawback: The rendering is done by the server, so more work on its part. It
    does not work for browsers that do not support JavaScript.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of this application, we will be using mainly the second solution.
    We will see the application in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Mochikit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mochikit, created and maintained by Bob Ippolito, is a JavaScript toolkit providing
    a set of functionalities to simplify the development of web applications from
    a client-side perspective. Mochikit provides the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Async:** This allows HTTP requests from the browser that are handled either
    synchronously or asynchronously. We will explain this in more detail in the next
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base:** This is a set of functions for common programming tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM:** This is an API to ease the manipulation of the DOM tree and perform
    operations such as insertion or removal of nodes in the tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DragAndDrop:** This is there to enable drag and drop handling in a web application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color:** This provides color abstraction with support for CSS3 colors that
    are not supported natively by current browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DateTime:** These are helpers for date and time management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Format:** These are helpers for string manipulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iter:** This brings good support to JavaScript for the iterator pattern over
    a collection of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging** and **LoggingPane:** These are extended logger tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Signal:** This is an API to handle events and their dispatching in a web
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Style:** This is a better support for CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sortable:** This simplifies the way to sort collections of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual:** These are effects to make a web application more attractive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mochikit is not the only major player in the JavaScript toolkit field; there
    are others such Dojo, script.aculo.us, Rico, Yahoo UI Library, JQuery, mooh.fx,
    etc. All of them allow you to write rich client-side web applications and choosing
    one of these is a matter of taste as much as of functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Mochikit library extensively to provide a more dynamic feeling
    experience to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could add a box displaying information about the film associated
    to the current photograph displayed. This box would be hidden by default and would
    show up when the user clicks on a link.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Photoblog Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now all the tools to develop a web application interface and we will
    now present step by step how our photoblog application will use those tools through
    specific examples, reflecting the application user-interface cases.
  prefs: []
  type: TYPE_NORMAL
- en: HTML Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start first by the insertion of an HTML box that will display film information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML code of the box to be inserted into the `index.kid` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we define an inner box and an outer box because we may need
    to add more content sharing the same process as the inner box. Note also that
    we do provide some random data from the template itself for testing purpose while
    developing the interface. Indeed, even though the application is built step by
    step in this book, in real-life projects tasks are usually achieved in parallel,
    so the areas that are normally interdependent have to work on their side on mock-up
    objects or data. Those are hard-coded but provide realistic content to work against.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Link
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As this box will be hidden by default, we need to provide the end user with
    a link to toggle its visibility. To do so, we add the following HTML code to the
    `index.kid` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that, although we call it a link, this is not an HTML`<a />` element but
    instead a text label that will act as a link from the end-user point of view.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the End-User Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming we have a JavaScript file named `utils.js`, we would define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create a simple JavaScript function that takes only one parameter,
    a DOM event object containing details of the current event, the caller, and the
    callee. This function performs solely two actions:'
  prefs: []
  type: TYPE_NORMAL
- en: It hides the DOM element with `film-pane` as `id`. Mochikit provides the `$(name)`
    as a shortcut to retrieve a DOM node within the DOM tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It attaches the `onclick` signal of the element with the `id` named `toggle-film-infos`
    to a function named `toggleFilmVisibility`. That function only toggles the state
    of visibility of the film box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we connect the `onload` signal of the `window` DOM object with the `initialize`
    function. This means that `initialize` will be called once the `window` object
    has been loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Amending the Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `common.kid` template, we simply need to add the following lines to
    the`<head />` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Amending the CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen in our example, our different HTML elements have either an
    `id` attribute and/or a `class` attribute. Both will allow us to apply a specific
    style to those elements, as we will see now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's be More Flexible...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the example we have been through, we started with the fact that the HTML
    box would be included directly within the main template. Mochikit comes with a
    handy DOM toolbox, with functions named after common HTML elements such as `DIV,
    SPAN, INPUT, FORM`, etc. It provides an extremely easy way to generate HTML elements
    on the fly to insert them into the DOM tree held by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical use case of our application will be the presentation of existing
    albums. Since their number is going to change with time, it is required to generate
    the associated HTML code dynamically, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We first create the main block containing the information and then we associate
    a unique identifier using the pattern `album-#id#`, where `#id#` is the `id` of
    the album to be displayed. Doing it that way, we provide a unique identifier for
    each block within the DOM tree. This is required as we will attach mouse events
    to the block itself for further processing. Then, we attach a series of inline
    elements, via the `SPAN` element, and we insert the content of the linked attribute
    of the album.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the block is created, we connect the mouse events as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When a user clicks on an album block `selectAlbum` will be called and operations
    will be performed to display the selected album, as we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we attach the newly created element to an outer album box area and we
    display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The creation of the blocks containing the album information will take place
    in a loop through the albums retrieved from the server, as we will see in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter, we have introduced some of the technologies and tools
    that are available today to create web application interfaces with dynamic and
    attractive design.
  prefs: []
  type: TYPE_NORMAL
- en: These range from the good old HTML variants that are still widely used to structure
    the content, to the CSS, a web designer's best friend to style the interface,
    and the resourceful Mochikit that lets us step into the world of rich web application.
  prefs: []
  type: TYPE_NORMAL
- en: There is still a missing link to put everything together between the server
    and the client. This link is commonly referred today as Ajax. This is what we
    will explain in the next chapter.
  prefs: []
  type: TYPE_NORMAL
