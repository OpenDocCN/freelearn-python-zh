<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;1.&#xA0;Starting with the Basics" id="E9OE1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Starting with the Basics</h1></div></div></div><p class="calibre8">The vast majority of Salt users see it as a configuration management platform. And in truth, it handles that very well. But it did not start off with that as a design goal. In its early days, Salt was a communication framework that was designed to be useful even to those who did not write code. But for those who were willing, it was also designed to be heavily extensible to those users who had some Python in their toolbelt.</p><p class="calibre8">Before we get into writing modules, it will help to have a basic understanding of how the Salt module system works. In this chapter, you'll learn the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How the loader system works</li><li class="listitem">How Salt uses Python</li></ul></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Starting with the Basics" id="E9OE1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Using plugins"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Using plugins</h1></div></div></div><p class="calibre8">As Salt <a id="id0" class="calibre1"/>was originally designed as a backbone that other software could use to communicate, its earliest purpose was to collect information from a large cluster of both physical and virtual machines, and return that data either to the user or to a database. Various programs, such as <code class="email">ps</code>, <code class="email">du</code>, and <code class="email">netstat</code>, were used to collect that information. Because of that, each program was wrapped with a plugin, which contained various functions to call those programs, and parse the return data.</p><p class="calibre8">Those plugins were originally called modules. Later, when other types of module were added to Salt, the original modules began to be referred to as <span class="strong"><em class="calibre9">execution modules</em></span>. This is because the execution modules would do the heavy lifting, and other types of module would generally wrap around them and extend their functionality.</p></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Starting with the Basics" id="E9OE1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Using plugins">
<div class="book" title="Loading modules"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec07" class="calibre1"/>Loading modules</h2></div></div></div><p class="calibre8">Like many <a id="id1" class="calibre1"/>data centers, the one that Salt was created in had various servers that used different software packages to perform their work. One server would be running Nginx, while another would be running DNSMasq. It wouldn't make sense to enable the <code class="email">nginx</code> module on the DHCP server, or a <code class="email">dnsmasq</code> module on the web server. A number of popular programs solve this by allowing the user to configure which plugins will be loaded before starting the service.</p><p class="calibre8">Salt had a <a id="id2" class="calibre1"/>different way of handling plugins. In a large infrastructure, individual configuration of servers can be costly in terms of time. And as configuration management was added to Salt, a core belief grew that configuration management platforms should require as little configuration themselves as possible. What is the point of using such a suite to save time if so much time is required to get it going in the first place?</p><p class="calibre8">This is <a id="id3" class="calibre1"/>how the loader system came to be. Salt would always ship with a full set of modules, and Salt would automatically detect modules that would be available, and dynamically load them.</p><p class="calibre8">Execution modules are a type of plugin that performs most of the heavy lifting inside of Salt. These were the first to use the loader system, and for a short time there was no other type of module. As the functionality of Salt increased, it quickly became evident that other types of module would be needed. For instance, return output was originally just printed to the console. Then the output was changed to be easier to handle from shell scripts. Then the outputter system was added, so that output could be displayed in JSON, YAML, Python's <code class="email">pprint</code>, and any other format that might be useful.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Starting with the Basics" id="E9OE1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Using plugins">
<div class="book" title="Standard modules"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec08" class="calibre1"/>Standard modules</h2></div></div></div><p class="calibre8">In the <a id="id4" class="calibre1"/>beginning, there were some types of module that would always be loaded. The first of these was the <code class="email">test</code> module, which required nothing more than Salt's own dependencies; in particular, it would only require Python.</p><p class="calibre8">Other modules were also designed for general use, requiring no more than Salt's own dependencies. The <code class="email">file</code> module would perform various file-based operations. The <code class="email">useradd</code> module would wrap the standard Unix <code class="email">useradd</code> program. This was fine, so long as Salt was only used on Unix-like platforms. When users started running Salt on Windows, where those utilities were not readily available, things changed. This is where virtual modules really started to shine.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Starting with the Basics" id="E9OE1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Using plugins">
<div class="book" title="Virtual modules"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec09" class="calibre1"/>Virtual modules</h2></div></div></div><p class="calibre8">Supporting <a id="id5" class="calibre1"/>Salt on various platforms, such as both Unix-like and Windows, presents the same problem as whether or not to make the <code class="email">nginx</code> module available: if that platform is installed and available, make the module available. Otherwise, don't. Salt handles the availability problem by implementing virtual modules.</p><p class="calibre8">The idea behind a virtual module is that it will contain a piece of code that will detect whether or not its dependencies are met, and if so, the module will be loaded and made available <a id="id6" class="calibre1"/>to Salt on that system. We'll get into the details of actually doing this in <a class="calibre1" title="Chapter 2. Writing Execution Modules" href="part0019_split_000.html#I3QM2-d9976ffc65994572ad672a3ef48f1135">Chapter 2</a>, <span class="strong"><em class="calibre9">Writing Execution Modules</em></span>.</p></div></div></div>

<div class="book" title="Chapter&#xA0;1.&#xA0;Starting with the Basics" id="E9OE1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Using plugins">
<div class="book" title="Lazy loading modules"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec10" class="calibre1"/>Lazy loading modules</h2></div></div></div><p class="calibre8">In the <a id="id7" class="calibre1"/>beginning, if a module was detected as being loadable, then it would be loaded as the Salt service was started. A number of modules may be loaded for a particular system, which the administrator never intends to use. It may be nice to have them, but in some cases it's better to only load them when they're needed.</p><p class="calibre8">When the Salt service starts, the lazy loader will detect which modules may be used on a particular system, but it won't immediately load them into memory. Once a particular module is called, Salt will load it on demand, and then keep it in memory. On a system that typically only uses a small handful of modules, this can result in a much smaller footprint than before.</p></div></div></div>
<div class="book" title="Extending the loader system" id="F8901-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Extending the loader system</h1></div></div></div><p class="calibre8">As we<a id="id8" class="calibre1"/> said before, the loader system was originally designed for one type of module: what we now call execution modules. Before long, other types of module were added, and that number continues to grow even today.</p><p class="calibre8">This book does not include every type of module, but it does cover quite a few. The following list is not comprehensive, but it will tell you much of what is available now, and <a id="id9" class="calibre1"/>possibly give you an idea of what other types of module to look at after you finish this book:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Execution modules</strong></span> do much of the heavy lifting inside of Salt. When a program<a id="id10" class="calibre1"/> needs to be called, an execution module will be written for it. When other modules need to use that program, they will call out to that module.</li><li class="listitem"><span class="strong"><strong class="calibre2">Grain modules</strong></span> are <a id="id11" class="calibre1"/>used to report information about Minions. <span class="strong"><strong class="calibre2">Virtual modules</strong></span> often rely heavily on these. Configuration can also be defined in grains.</li><li class="listitem"><span class="strong"><strong class="calibre2">Runner modules</strong></span> were designed to add an <a id="id12" class="calibre1"/>element of scripting to Salt. Whereas execution modules run on Minions, a runner module would run on the Master, and call out to the Minions.</li><li class="listitem"><span class="strong"><strong class="calibre2">Returner modules</strong></span> give Minions a way to return data to something besides the Master, such <a id="id13" class="calibre1"/>as a database configured to store log data.</li><li class="listitem"><span class="strong"><strong class="calibre2">State modules</strong></span> transform Salt from a remote execution framework into a configuration <a id="id14" class="calibre1"/>management engine.</li><li class="listitem"><span class="strong"><strong class="calibre2">Renderer modules</strong></span> allow Salt States to be <a id="id15" class="calibre1"/>defined using different file formats, as appropriate.</li><li class="listitem"><span class="strong"><strong class="calibre2">Pillar modules</strong></span> extend grains, by providing<a id="id16" class="calibre1"/> a more centralized system of defining configuration.</li><li class="listitem"><span class="strong"><strong class="calibre2">SDB modules</strong></span> provide a simple database lookup. They are usually referenced from <a id="id17" class="calibre1"/>configuration areas (including grains and pillars) to <a id="id18" class="calibre1"/>keep sensitive data from appearing in plaintext.</li><li class="listitem"><span class="strong"><strong class="calibre2">Outputter modules</strong></span> affect how command-line<a id="id19" class="calibre1"/> data output is shown to the user.</li><li class="listitem"><span class="strong"><strong class="calibre2">External file server modules</strong></span> allow the files that <a id="id20" class="calibre1"/>Salt serves to be stored somewhere besides locally on the Master.</li><li class="listitem"><span class="strong"><strong class="calibre2">Cloud modules</strong></span> are used to manage virtual <a id="id21" class="calibre1"/>machines across different compute cloud providers.</li><li class="listitem"><span class="strong"><strong class="calibre2">Beacons</strong></span> allow<a id="id22" class="calibre1"/> various pieces of software, from other Salt components to third-party applications, to report data to Salt.</li><li class="listitem"><span class="strong"><strong class="calibre2">External authentication modules</strong></span> allow users<a id="id23" class="calibre1"/> to access the Master without having to have a local account on it.</li><li class="listitem"><span class="strong"><strong class="calibre2">Wheel modules</strong></span> provide an API for managing <a id="id24" class="calibre1"/>Master-side configuration files.</li><li class="listitem"><span class="strong"><strong class="calibre2">Proxy minion modules</strong></span> allow devices <a id="id25" class="calibre1"/>that cannot run the Salt platform itself to be able to be treated as if they were still full-fledged Minions.</li><li class="listitem"><span class="strong"><strong class="calibre2">Engines</strong></span> allow <a id="id26" class="calibre1"/>Salt to provide internal information and services to long-running external processes. In fact, it may be best to think of engines as programs in their own right, with a special connection to Salt. </li><li class="listitem"><span class="strong"><strong class="calibre2">The Master Tops system</strong></span> allows States to be<a id="id27" class="calibre1"/> targeted without having to use the <code class="email">top.sls</code> file.</li><li class="listitem"><span class="strong"><strong class="calibre2">Roster modules</strong></span> allow <a id="id28" class="calibre1"/>Salt SSH to target Minions without having to use the <code class="email">/etc/salt/roster</code> file.</li><li class="listitem"><span class="strong"><strong class="calibre2">Queue modules</strong></span> provide <a id="id29" class="calibre1"/>a means of organizing function calls.</li><li class="listitem">The <span class="strong"><strong class="calibre2">pkgdb</strong></span> and <span class="strong"><strong class="calibre2">pkgfile modules</strong></span> allow the Salt Package Manager to store its local <a id="id30" class="calibre1"/>database and install Salt formulas <a id="id31" class="calibre1"/>into a location outside of the local hard drive.</li></ul></div><p class="calibre8">These modules were generally created as necessity dictated. All of them are written in Python. And while some can be pretty extensive, most are pretty simple to create. In fact, a number of modules that now ship with Salt were actually provided by users who had no previous<a id="id32" class="calibre1"/> Python experience.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Loading modules with Python" id="G6PI1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Loading modules with Python</h1></div></div></div><p class="calibre8">Python is <a id="id33" class="calibre1"/>well suited to building a loader system. Despite being <a id="id34" class="calibre1"/>classified as a very high-level language (and not a mid-level language like C), Python has a lot of control over how it manages its own internals. The existence of robust module introspection built into Python was very useful for Salt, as it made the arbitrary loading of virtual modules at runtime a very smooth operation.</p><p class="calibre8">Each Salt module can support a function called <code class="email">__virtual__()</code>. This is the function that detects whether or not a module will be made available to Salt on that system.</p><p class="calibre8">When the <code class="email">salt-minion</code> service loads, it will go through each module, looking for a <code class="email">__virtual__()</code> function. If none is found, then the module is assumed to have all of its requirements already met, and it can be made available. If that function is found, then it will be used to detect whether the requirements for that module are met.</p><p class="calibre8">If a module type uses the lazy loader, then modules that can be loaded will be set aside to be loaded when needed. Modules that do not meet the requirements will be discarded.</p></div>

<div class="book" title="Loading modules with Python" id="G6PI1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Detecting grains"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec11" class="calibre1"/>Detecting grains</h2></div></div></div><p class="calibre8">On a<a id="id35" class="calibre1"/> Minion, the most important things to load are probably the grains. Although grain modules are important (and are discussed in <a class="calibre1" title="Chapter 3. Extending Salt Configuration" href="part0023_split_000.html#LTSU2-d9976ffc65994572ad672a3ef48f1135">Chapter 3</a>, <span class="strong"><em class="calibre9">Extending Salt Configuration</em></span>), there are in fact a number of core grains that are loaded by Salt itself.</p><p class="calibre8">A number of these grains describe the hardware on the system. Others describe the operating system that Salt is running on. Grains such as <code class="email">os</code> and <code class="email">os _family</code> are set, and used later to determine which of the core modules will be loaded.</p><p class="calibre8">For<a id="id36" class="calibre1"/> example, if the <code class="email">os_family</code> grain is set to <code class="email">redhat</code>, then the execution module located at <code class="email">salt/modules/yumpkg.py</code> will be loaded as the <code class="email">pkg</code> module. If the <code class="email">os_family</code> grain is set to <code class="email">debian</code>, then <code class="email">salt/modules/aptpkg.py</code> will be loaded as the <code class="email">pkg</code> module.</p></div></div>

<div class="book" title="Loading modules with Python" id="G6PI1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Using other detection methods"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec12" class="calibre1"/>Using other detection methods</h2></div></div></div><p class="calibre8">Grains <a id="id37" class="calibre1"/>aren't the only mechanism used for determining whether a module should be loaded. Salt also ships with a number of utilities that can be used. The <code class="email">salt.utils</code> library contains a number of functions that are often faster than grains, or have more functionality than a simple <code class="email">name=value</code> (also known as a key-value pair) configuration can provide.</p><p class="calibre8">One example is the <code class="email">salt.utils.is_windows()</code> function that, as the name implies, reports whether Salt is being run inside of Windows. If Windows is detected, then <code class="email">salt/modules/win_file.py</code> will be loaded as the <code class="email">file</code> module. Otherwise, <code class="email">salt/modules/file.py</code> will be loaded as the <code class="email">file</code> module.</p><p class="calibre8">Another very common example is the <code class="email">salt.utils.which()</code> function, which reports whether a necessary shell command is available. For instance, this is used by <code class="email">salt/modules/nginx.py</code> to detect whether the <code class="email">nginx</code> command is available to Salt. If so, then the <code class="email">nginx</code> module will be made available.</p><p class="calibre8">There are a number of other examples that we could get into, but there is not nearly enough room in this book for all of them. As it is, the most common ones are best demonstrated by example. Starting with <a class="calibre1" title="Chapter 2. Writing Execution Modules" href="part0019_split_000.html#I3QM2-d9976ffc65994572ad672a3ef48f1135">Chapter 2</a>, <span class="strong"><em class="calibre9">Writing Execution Modules</em></span>, we will begin writing Salt modules that make use of the examples that we've already gone over, plus a wealth of others.</p></div></div>
<div class="book" title="Summary" id="H5A41-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Salt is made possible by the existence of the loader system, which detects which modules are able to load, and then only what is available. Types of module that make use of the lazy loader will only be loaded on demand.</p><p class="calibre8">Python is an integral part of Salt, allowing modules to be easily written and maintained. Salt ships with a library of functions that help support the loader system, and the modules that are loaded with it. These files live in various directories under the <code class="email">salt/</code> directory in Salt's code base. For example, execution modules live in <code class="email">salt/modules/</code>.</p><p class="calibre8">This chapter barely brushed the surface of what is possible with Salt, but it got some necessary concepts out of the way. From here on in, the focus will be all about writing and maintaining modules in Python.</p></div></body></html>