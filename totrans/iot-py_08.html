<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Displaying Information and Performing Actions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Displaying Information and Performing Actions</h1></div></div></div><p>In this chapter, we will work with a variety of breakout boards and an actuator to display data and perform actions by writing a Python code. We shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understand LCD displays and their connection types</li><li class="listitem" style="list-style-type: disc">Learn the most important things we must consider when choosing LCD displays</li><li class="listitem" style="list-style-type: disc">Take advantage of the <code class="literal">upm</code> library with LCD displays and actuators</li><li class="listitem" style="list-style-type: disc">Use an LCD display with an RGB backlight that works with the I<sup>2</sup>C bus</li><li class="listitem" style="list-style-type: disc">Display and update text in a 16x2 LCD screen</li><li class="listitem" style="list-style-type: disc">Use an OLED display that works with the I<sup>2</sup>C bus</li><li class="listitem" style="list-style-type: disc">Display and update text on a 96-by-96 dot matrix OLED display</li><li class="listitem" style="list-style-type: disc">Wire a standard servo motor to be controlled with PWM</li><li class="listitem" style="list-style-type: disc">Display a value with a servo motor and a shaft</li></ul></div><div class="section" title="Understanding LCD displays and their connection types"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Understanding LCD displays and their connection types</h1></div></div></div><p>Sometimes, our <a id="id388" class="indexterm"/>IoT device has to provide information to the user with any device connected to an Intel Galileo Gen 2 board. We can use different kinds of electronic components, shields, or breakout boards to achieve this goal.</p><p>For example, we can use simple LEDs to provide information that we can represent with colors. For example, a red LED that turns on can indicate that our temperature sensor connected to the board has detected that the ambient temperature is higher than 80 degrees Fahrenheit (ºF) or 26.66 degrees Celsius (ºC). A blue LED that turns on can indicate that our temperature sensor had detected that the ambient temperature is lower than 40 degrees Fahrenheit (ºF) or 4.44 degrees Celsius (ºC). A red LED turned on can indicate that the temperature is between these two values. These three LEDs allow us to provide valuable information to the user.</p><p>We can also <a id="id389" class="indexterm"/>achieve the same goal using a single RGB LED and work with <a id="id390" class="indexterm"/>
<span class="strong"><strong>pulse width modulation</strong></span> (<span class="strong"><strong>PWM</strong></span>) to change its color based on the measured ambient temperature value, as we learned in <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, <span class="emphasis"><em>Working with a RESTful API and Pulse Width Modulation</em></span>.</p><p>However, sometimes <a id="id391" class="indexterm"/>colors aren't enough to provide a detailed and accurate information to the user. For example, sometimes we want to display the humidity level with a percentage value and a few LEDs aren't enough to represent numbers from 0 to 100%. If we want to be able to display a 1% step, we would require 100 LEDs. We don't have 100 GPIO pins, and therefore, we would require a shield or breakout board with 100 LEDs and a digital interface such as an I<sup>2</sup>C bus to allow us to send commands indicating the number of LEDs that we want to be turned on.</p><p>In these cases, an LCD screen that allows us to print a specific number of characters might be an appropriate solution. For example, on an LCD screen that allows us to display 16 characters per line, with 2 lines of 16 characters, known as a 16x2 LCD module, we can display the temperature in the first line and the humidity level in the second line. The following table shows an example of each line with the text and the values considering that we have 16 columns and 2 rows for the characters.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>T</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>m</p>
</td><td style="text-align: left" valign="top">
<p>p</p>
</td><td style="text-align: left" valign="top">
<p>.</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>.</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>F</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>H</p>
</td><td style="text-align: left" valign="top">
<p>u</p>
</td><td style="text-align: left" valign="top">
<p>m</p>
</td><td style="text-align: left" valign="top">
<p>i</p>
</td><td style="text-align: left" valign="top">
<p>d</p>
</td><td style="text-align: left" valign="top">
<p>i</p>
</td><td style="text-align: left" valign="top">
<p>t</p>
</td><td style="text-align: left" valign="top">
<p>y</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>8</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>%</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>The 16x2 LCD module provides a clear description for each value, a floating point value and a unit of measure. Thus, we will use a 16x2 LCD module for our example. The following picture shows an example of the location of each character in a 16x2 LCD screen:</p><div class="mediaobject"><img src="images/B05042_08_01.jpg" alt="Understanding LCD displays and their connection types"/></div><p>There <a id="id392" class="indexterm"/>are <a id="id393" class="indexterm"/>LCD modules with different features and we must consider a lot of the things we learned when we analyzed sensors in <a class="link" href="ch07.html" title="Chapter 7. Retrieving Data from the Real World with Sensors">Chapter 7</a>, <span class="emphasis"><em>Retrieving Data from the Real World with Sensors</em></span>. The <a id="id394" class="indexterm"/>following list enumerates the most important things that we must consider when we select an LCD module and their description. As we analyzed many of these things when we learned about sensors, we won't repeat the descriptions for the common items.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Compatibility with Intel Galileo Gen 2 board and the voltage supply that we are using (5V or 3.3V)</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Power consumption</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Connection type</strong></span>: Some LCD displays consume too many pins, and therefore, it is very important to check all the pins that they require. The most common connection types for LCD displays are the I<sup>2</sup>C bus, the SPI bus, and the UART port. However, some LCD displays require a bus or port combined with additional GPIO pins.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Operating range and special environment requirements</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Dimensions</strong></span>: LCD displays come with different dimensions. Sometimes only specific dimensions are suitable for our project.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Number of columns and rows</strong></span>: Based on the text we have to display, we will select the LCD display with the appropriate number of columns and rows that can display the characters.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Response time</strong></span>: It is<a id="id395" class="indexterm"/> very important to determine how much we can wait for the LCD display to show the new content that replaces the text that is being displayed or to clear the display.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Protocol, support in the upm library and Python bindings</strong></span>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Supported character set and built-in fonts</strong></span>: Some LCD displays support user-defined characters, and therefore, they allow us to configure and display custom characters. It is also important to check whether the LCD display supports characters for the languages in which we have to display the text.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Backlight color, text color and contrast level</strong></span>: Some LCD displays allow us to change the backlight color while others have a fixed backlight color. An RGB backlight makes it possible to combine red, green, and blue components to determine the desired backlight color. In addition, it is always important to take into account whether the contrast level is appropriate for the light conditions in which you will need to display information.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Cost</strong></span>.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring an LCD RGB backlight to the I2C bus"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Wiring an LCD RGB backlight to the I<sup>2</sup>C bus</h1></div></div></div><p>In our<a id="id396" class="indexterm"/> last example in <a class="link" href="ch07.html" title="Chapter 7. Retrieving Data from the Real World with Sensors">Chapter 7</a>, <span class="emphasis"><em>Retrieving Data from the Real World with Sensors</em></span>, we worked with a multifunctional digital sensor that provided us with the temperature and relative humidity information. We worked with a breakout board that uses the I<sup>2</sup>C bus to allow the Intel Galileo Gen 2 board to communicate with the sensor. Now, we will add a breakout board with a 16x2 LCD RGB backlight to allow us to display the measured temperature and humidity values with text and numbers.</p><p>The LCD RGB backlight breakout board will also be connected to the same I<sup>2</sup>C bus to which the temperature and humidity digital sensor is connected. We can connect many slaves to the I<sup>2</sup>C bus in the Intel Galileo Gen 2 board as long as their have different I<sup>2</sup>C addresses. In fact, the LCD RGB backlight breakout board has two I<sup>2</sup>C addresses: one for the LCD display and the other for the backlight.</p><p>We need the following parts to work with this example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A SeeedStudio Grove temperature and humidity sensor (high-accuracy and mini) breakout. The following URL provides detailed information about this breakout board: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html">http://www.seeedstudio.com/depot/Grove-TemperatureHumidity-Sensor-HighAccuracy-Mini-p-1921.html</a>.</li><li class="listitem" style="list-style-type: disc">A SeeedStudio Grove LCD RGB backlight breakout. The following URL provides detailed information about this breakout board: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html">http://www.seeedstudio.com/depot/Grove-LCD-RGB-Backlight-p-1643.html</a>.</li></ul></div><p>The following <a id="id397" class="indexterm"/>diagram shows the digital temperature and humidity breakout, the LCD RGB backlight breakout, the necessary wirings, and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_08_01.fzz</code> and the following image is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_08_02.jpg" alt="Wiring an LCD RGB backlight to the I2C bus"/></div><p>The following <a id="id398" class="indexterm"/>image shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_08_03.jpg" alt="Wiring an LCD RGB backlight to the I2C bus"/></div><p>As seen in the<a id="id399" class="indexterm"/> previous schematic, we have the following connections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SDA</strong></span> pin is connected to both the breakout board pins labeled <span class="strong"><strong>SDA</strong></span>. This way, we connect both the digital temperature and humidity sensor and the LCD backlight to the serial data line for the I<sup>2</sup>C bus.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SCL</strong></span> pin is connected to both the breakout board pins labeled <span class="strong"><strong>SCL</strong></span>. This way, we can connect both the digital temperature and humidity sensor and the LCD backlight to the serial clock line for the I<sup>2</sup>C bus.</li><li class="listitem" style="list-style-type: disc">The<a id="id400" class="indexterm"/> power pin labeled <span class="strong"><strong>3V3</strong></span> is connected to the digital temperature and humidity sensor breakout board power pin labeled <span class="strong"><strong>VCC</strong></span>.</li><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>5V</strong></span> is connected to the LCD backlight breakout board power pin labeled <span class="strong"><strong>VCC</strong></span>.</li><li class="listitem" style="list-style-type: disc">The ground pin labeled <span class="strong"><strong>GND</strong></span> is connected to both the breakout board pins labeled <span class="strong"><strong>GND</strong></span>.</li></ul></div><p>Now, it is time make all the necessary wirings. Don't forget to shut down the Yocto Linux, wait for all the onboard LEDs to turn off and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Displaying text on an LCD display"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Displaying text on an LCD display</h1></div></div></div><p>The <code class="literal">upm</code> library<a id="id401" class="indexterm"/> includes support for the 16x2 LCD RGB backlight breakout board in the <code class="literal">pyupm_i2clcd</code> module. The <code class="literal">Jhd1313m1</code> class declared in this module represents a 16x2 LCD display and its RGB backlight, connected to our board. The class makes it easy to set the color components for the RGB backlight, clear the LCD display, specify the cursor location, and write text through the I<sup>2</sup>C bus. The class works with the <code class="literal">mraa.I2c</code> class under the hoods to talk with the RGB backlight and the LCD display. These two devices act as slave devices connected to the I<sup>2</sup>C bus, and therefore, each of them have a specific address in this bus.</p><p>We will take the code we wrote in the previous chapter when we read temperature and humidity values from the sensor and we will use this code as a baseline to add the new features. The code file for the sample was <code class="literal">iot_python_chapter_07_05.py</code>.</p><p>We will create an <code class="literal">Lcd</code> class to represent the 16x2 LCD RGB backlight and make it easier for us to set the background color and write the text in two lines without worrying about the specific methods when working with an instance of the <code class="literal">Jhd1313m1</code> class. We will use the <code class="literal">Jhd1313m1</code> class to interact with the LCD and its RGB backlight. The following lines show the code for the new <code class="literal">Lcd</code> class that works with the <code class="literal">upm</code> library, specifically with the <code class="literal">pyupm_i2clcd</code> module. The code file for the sample is <code class="literal">iot_python_chapter_08_01.py</code>.</p><div class="informalexample"><pre class="programlisting">import pyupm_th02 as upmTh02
import pyupm_i2clcd as upmLcd
import time

class Lcd:
    # The I2C address for the LCD display
    lcd_i2c_address = 0x3E
    # The I2C address for the RBG backlight
    rgb_i2c_address = 0x62

    def __init__(self, bus, red, green, blue):
        self.lcd = upmLcd.Jhd1313m1(
            bus,
            self.__class__.lcd_i2c_address,
            self.__class__.rgb_i2c_address)
        self.lcd.clear()
        self.set_background_color(red, green, blue)

    def set_background_color(self, red, green, blue):
        self.lcd.setColor(red, green, blue)

    def print_line_1(self, message):
        self.lcd.setCursor(0, 0)
        self.lcd.write(message)

    def print_line_2(self, message):
        self.lcd.setCursor(1, 0)
        self.lcd.write(message)</pre></div><p>The <code class="literal">Lcd</code> class <a id="id402" class="indexterm"/>declares two class attributes: <code class="literal">lcd_i2c_address</code> and <code class="literal">rgb_i2c_address</code>. The first class attribute defines the I<sup>2</sup>C address for the LCD display, that is, the address that will process the commands that locate the cursor and write text once the cursor is located in a specific row and column. The address is <code class="literal">3E</code> in hexadecimal (<code class="literal">0x3E</code>). If we just see a <code class="literal">0x3E</code> within the code, we don't understand that it is an I<sup>2</sup>C bus address for the LCD display. The second class attribute defines the I<sup>2</sup>C address for the RGB backlight, that is, the address that will process the commands that set the red, green, and blue components for the backlight color. The address is <code class="literal">62</code> in hexadecimal (<code class="literal">0x62</code>). If we just see a <code class="literal">0x62</code> within the code, we don't understand that it is an I<sup>2</sup>C bus address for the RGB backlight. These class attributes make it easier to read the code.</p><p>We have to specify the I<sup>2</sup>C bus number to which the both the 16x2 LCD and the RGB backlight are wired when we create an instance of the <code class="literal">Lcd</code> class in the <code class="literal">bus</code> required argument. In addition, it is necessary to specify the values for the red, green and blue color components to configure the background color for the RGB backlight. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">upmLcd.Jhd1313m1</code> instance with the received <code class="literal">bus</code> argument followed by the <code class="literal">lcd_i2c_address</code> and <code class="literal">rgb_i2c_address</code> class attributes and saves the reference for the new instance in the <code class="literal">lcd</code> attribute. Then, the code calls the <code class="literal">clear</code> method for the new instance to clear the LCD screen. Finally, the code calls the <code class="literal">set_background_color</code> method with the red, green, and blue values received as arguments to configure the background color for the RGB backlight.</p><p>The <a id="id403" class="indexterm"/>class declares the <code class="literal">set_background_color</code> method that calls the <code class="literal">lcd.setColor</code> method with the <code class="literal">red</code>, <code class="literal">green</code> and <code class="literal">blue</code> values received as arguments. Under the hoods, the <code class="literal">upmLcd.Jhd1313m1</code> instance will write data to the slave device whose address is equal to the <code class="literal">rgb_i2c_address</code> class attribute through the I<sup>2</sup>C bus to specify the desired value for each color component. We just create a specific method to follow Python naming conventions and make our final code that uses our class easier to read.</p><p>The class defines the following two additional methods to make it easy to print text on the first and the second row of the LCD display:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">print_line_1</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">print_line_2</code></li></ul></div><p>The <code class="literal">print_line_1</code> method calls the <code class="literal">setCursor</code> method for the <code class="literal">upmLcd.Jhd1313m1</code> instance (<code class="literal">self.lcd</code>), with <code class="literal">0</code> as the value for both the <code class="literal">row</code> and the <code class="literal">column</code> argument, to locate the cursor in the first row and the first column. Then, a call to the write method for the the <code class="literal">upmLcd.Jhd1313m1</code> instance (<code class="literal">self.lcd</code>) with the <code class="literal">message</code> reviewed as a parameter as an argument prints the received string in the LCD display. Under the hoods, the <code class="literal">upmLcd.Jhd1313m1</code> instance will write the data to the slave device whose address is equal to the <code class="literal">lcd_i2c_address</code> class attribute through the I<sup>2</sup>C bus to specify the desired location for the cursor and then to write the specified text starting in the position in which we have located the cursor. The first row is identified with 0, but we named the method <code class="literal">print_line_1</code> because it makes it easier for us to understand that we are writing a message in the first line of the LCD screen.</p><p>The <code class="literal">print_line_2</code> method has the same two lines of code than the <code class="literal">print_line_1</code> method with just one difference: the call to the <code class="literal">setCursor</code> method specifies 1 as the value for the row argument. This way, the method prints a message in the second line of the LCD screen.</p><p>Now, we will create a subclass of the previously coded <code class="literal">Lcd</code> class named <code class="literal">TemperatureAndHumidityLcd</code>. The subclass will specialize the <code class="literal">Lcd</code> class to allow us to easily print a temperature value expressed in degrees Fahrenheit in the first line of the LCD screen and print a humidity value expressed in percentage in the second line of the LCD screen. The following lines show the code for the new <code class="literal">TemperatureAndHumidityLcd</code> class. The code file for the sample is <code class="literal">iot_python_chapter_08_01.py</code>.</p><div class="informalexample"><pre class="programlisting">class TemperatureAndHumidityLcd(Lcd):
    def print_temperature(self, temperature_fahrenheit):
        self.print_line_1("Temp.    {:5.2f}F".format(temperature_fahrenheit))

    def print_humidity(self, humidity):
        self.print_line_2("Humidity   {0}%".format(humidity))</pre></div><p>The new class (<code class="literal">TemperatureAndHumidityLcd</code>) adds the following two methods to its superclass (<code class="literal">Lcd</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">print_temperature</code>: Calls the <code class="literal">print_line_1</code> method with the formatted text that displays the temperature value expressed in degrees Fahrenheit (ºF) received in the <code class="literal">temperature_fahrenheit</code> argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">print_humidity</code>: Calls the <code class="literal">print_line_2</code> method with the formatted text that displays the humidity level expressed in percentage received in the <code class="literal">humidity</code> argument.</li></ul></div><p>Now, we <a id="id404" class="indexterm"/>will write a loop that will display the ambient temperature expressed in degrees Fahrenheit (ºF) and the humidity value in the LCD screen, every 10 seconds. The code file for the sample is <code class="literal">iot_python_chapter_08_01.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    temperature_and_humidity_sensor = \
        TemperatureAndHumiditySensor(0)
<span class="strong"><strong>    lcd = TemperatureAndHumidityLcd(0, 0, 0, 128)</strong></span>

    while True:
        temperature_and_humidity_sensor.\
            measure_temperature_and_humidity()
<span class="strong"><strong>        lcd.print_temperature(</strong></span>
<span class="strong"><strong>            temperature_and_humidity_sensor.temperature_fahrenheit)</strong></span>
<span class="strong"><strong>        lcd.print_humidity(</strong></span>
<span class="strong"><strong>            temperature_and_humidity_sensor.humidity)</strong></span>
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_and_humidity_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_and_humidity_sensor.temperature_fahrenheit))
        print("Ambient humidity: {0}".
              format(temperature_and_humidity_sensor.humidity))
        # Sleep 10 seconds (10000 milliseconds)
        time.sleep(10)</pre></div><p>The highlighted <a id="id405" class="indexterm"/>lines show the changes made to the <code class="literal">__main__</code> method compared with the previous version. The first highlighted line creates an instance of the previously coded <code class="literal">TemperatureAndHumidityLcd</code> class with <code class="literal">0</code> as the value of the <code class="literal">bus</code> argument, <code class="literal">0</code> for <code class="literal">red</code> and <code class="literal">green</code>, and <code class="literal">128</code> for <code class="literal">blue</code> to set the background color to light blue. The code saves the reference to this instance in the <code class="literal">lcd</code> local variable. This way, the instance will establish a communication with the LCD screen and the RGB backlight through the I<sup>2</sup>C bus. The RGB backlight will display a light blue background.</p><p>Then, the code runs a loop forever and the highlighted line calls the <code class="literal">lcd.print_temperature</code> method with <code class="literal">temperature_and_humidity_sensor.temperature_fahrenheit</code>, that is, the measured temperature expressed in degrees Fahrenheit (ºF), as an argument. This way, the code displays this temperature value in the first line of the LCD screen.</p><p>The next hightlighted line calls the <code class="literal">lcd.print_humidity</code> method with <code class="literal">temperature_and_humidity_sensor.humidity</code>, that is, the measured humidity expressed in percentage, as an argument. This way, the code displays this humidity value in the second line of the LCD screen.</p><p>The following line will start the example:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_08_01.py</pre></div><p>After you run the example, turn on an air conditioner or heating system, to generate a change in the ambient temperature and humidity. The LCD screen will display the temperature and humidity and refresh it every 10 seconds.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring an OLED dot matrix to the I2C bus"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Wiring an OLED dot matrix to the I<sup>2</sup>C bus</h1></div></div></div><p>LCD displays <a id="id406" class="indexterm"/>are not the only option when we have to display content on an external screen through the I<sup>2</sup>C or SPI buses. There are also OLED dot matrixes that allow us to control a specific number of dots. In OLED dot matrices we have control over each dot, instead of controlling each character space. Some of them are grayscale and others RGB.</p><p>The key advantage of OLED dot matrixes is that we can display any kind of graphics and not just text. In fact, we can mix any kind of graphics and images with text. The Grove OLED Display 0.96" is an example of a 16 grayscale 96-by-96 dot matrix OLED display module that works with the I<sup>2</sup>C bus. The following URL provides detailed information about this breakout board: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html">http://www.seeedstudio.com/depot/Grove-OLED-Display-096-p-824.html</a>. The Xadow RGB OLED 96x24 is an example of an RGB color 96-by-64 dot matrix OLED display module that works with the SPI bus. The following URL provides detailed information about this breakout board: <a class="ulink" href="http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html">http://www.seeedstudio.com/depot/Xadow-RGB-OLED-96x64-p-2125.html</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip58"/>Tip</h3><p>Another option is to work with TFT LCD dot matrices or displays. Some of them include support for touch detection.</p></div></div><p>Now, we will replace the breakout board with a 16x2 LCD RGB backlight with a 16 grayscale 96-by-96 dot matrix OLED display module that also works with the I<sup>2</sup>C bus, and we will use this new screen to display similar values with a different configuration. The wirings are compatible with the previous breakout board.</p><p>As it happened in our previous example, the dot matrix OLED will also be connected to the same I<sup>2</sup>C bus to which the temperature and humidity digital sensor is connected. As the dot matrix OLED has an I<sup>2</sup>C address that is different than the one used by the temperature and humidity digital sensor, we don't have problems to wire the two devices to the same I<sup>2</sup>C bus.</p><p>We need the<a id="id407" class="indexterm"/> following additional part to work with this example: A SeeedStudio Grove OLED Display 0.96", 16 grayscale 96-by-96 dot matrix OLED display module. The 96-by-96 dot matrix OLED display provides us the chance to control 9,216 dots, known as pixels. However, in this case, we just want to use the OLED display to display a similar text than the one we displayed in our previous example, but with a different layout.</p><p>If we use the default 8-by-8 character box, we have 12 columns (96/8) and 12 rows (96/8) for characters. The following table shows an example of each line with the text and the values.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>T</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>m</p>
</td><td style="text-align: left" valign="top">
<p>p</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>r</p>
</td><td style="text-align: left" valign="top">
<p>a</p>
</td><td style="text-align: left" valign="top">
<p>t</p>
</td><td style="text-align: left" valign="top">
<p>u</p>
</td><td style="text-align: left" valign="top">
<p>r</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>F</p>
</td><td style="text-align: left" valign="top">
<p>a</p>
</td><td style="text-align: left" valign="top">
<p>h</p>
</td><td style="text-align: left" valign="top">
<p>r</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>n</p>
</td><td style="text-align: left" valign="top">
<p>h</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>i</p>
</td><td style="text-align: left" valign="top">
<p>t</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>.</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>C</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>l</p>
</td><td style="text-align: left" valign="top">
<p>s</p>
</td><td style="text-align: left" valign="top">
<p>i</p>
</td><td style="text-align: left" valign="top">
<p>u</p>
</td><td style="text-align: left" valign="top">
<p>s</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>.</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>H</p>
</td><td style="text-align: left" valign="top">
<p>u</p>
</td><td style="text-align: left" valign="top">
<p>m</p>
</td><td style="text-align: left" valign="top">
<p>i</p>
</td><td style="text-align: left" valign="top">
<p>d</p>
</td><td style="text-align: left" valign="top">
<p>i</p>
</td><td style="text-align: left" valign="top">
<p>t</p>
</td><td style="text-align: left" valign="top">
<p>y</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>L</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>v</p>
</td><td style="text-align: left" valign="top">
<p>e</p>
</td><td style="text-align: left" valign="top">
<p>l</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>8</p>
</td><td style="text-align: left" valign="top">
<p>0</p>
</td><td style="text-align: left" valign="top">
<p>%</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>The possibility<a id="id408" class="indexterm"/> to work with 12 columns and 12 rows of characters allows us to provide a very clear description for each value. In addition, we are able to display the temperature values expressed in both degrees Fahrenheit and degrees Celsius. The following picture shows an example of the location of each character in the 96-by-96 dot matrix OLED display module with an 8-by-8 character box. </p><div class="mediaobject"><img src="images/B05042_08_04.jpg" alt="Wiring an OLED dot matrix to the I2C bus"/></div><p>After we replace the LCD screen breakout board with the OLED module, we will have the following connections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SDA</strong></span> pin is connected to both breakout board pins labeled <span class="strong"><strong>SDA</strong></span>. This way, we connect both the digital temperature and humidity sensor and the OLED module to the serial data line for the I<sup>2</sup>C bus.</li><li class="listitem" style="list-style-type: disc">The <span class="strong"><strong>SCL</strong></span> pin is connected to both the breakout board pins labeled <span class="strong"><strong>SCL</strong></span>. This way, we connect both the digital temperature and humidity sensor and the OLED module to the serial clock line for the I<sup>2</sup>C bus.</li><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>3V3</strong></span> is connected to the digital temperature and humidity sensor breakout board power pin labeled <span class="strong"><strong>VCC</strong></span>.</li><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>5V</strong></span> is connected to the OLED module power pin labeled <span class="strong"><strong>VCC</strong></span>.</li><li class="listitem" style="list-style-type: disc">The ground pin labeled <span class="strong"><strong>GND</strong></span> is connected to both the breakout board pins labeled <span class="strong"><strong>GND</strong></span>.</li></ul></div><p>Now, it is <a id="id409" class="indexterm"/>time make all the necessary wirings. Don't forget to shutdown the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Displaying text on an OLED display"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Displaying text on an OLED display</h1></div></div></div><p>The <code class="literal">upm</code> library<a id="id410" class="indexterm"/> includes support for the SeeedStudio Grove OLED display 0.96", 16 grayscale 96-by-96 dot matrix OLED display breakout board the in the <code class="literal">pyupm_i2clcd</code> module. As this OLED display uses SSD1327 driver integrated circuit, the <code class="literal">SSD1327</code> class declared in this module represents a 96-by-96 dot matrix OLED display, connected to our board. The class makes it easy to clear the OLED screen, draw bitmap images, specify the cursor location, and write text through the I<sup>2</sup>C bus. The class works with the <code class="literal">mraa.I2c</code> class under the hoods to talk with the OLED display.</p><p>We will create a new <code class="literal">Oled</code> class that will represent the 96-by-96 dot matrix OLED and will use its default 8-by-8 character box to display text. We will use the <code class="literal">SSD1327</code> class to interact with the OLED display. The following lines show the code for the new <code class="literal">Oled</code> class that works with the <code class="literal">upm</code> library, specifically with the <code class="literal">pyupm_i2clcd</code> module and its <code class="literal">SSD1327</code> class. The code file for the sample is <code class="literal">iot_python_chapter_08_02.py</code>:</p><div class="informalexample"><pre class="programlisting">class Oled:
    # The I2C address for the OLED display
    oled_i2c_address = 0x3C

    def __init__(self, bus, red, green, blue):
        self.oled = upmLcd.SSD1327(
            bus,
            self.__class__.oled_i2c_address)
        self.oled.clear()

    def print_line(self, row, message):
        self.oled.setCursor(row, 0)
        self.oled.setGrayLevel(12)
        self.oled.write(message)</pre></div><p>The <code class="literal">Oled</code> class<a id="id411" class="indexterm"/> declares the <code class="literal">oled_i2c_address</code> class attribute that defines the I<sup>2</sup>C address for the OLED display, that is, the address that will process the commands that locate the cursor and write text once the cursor is located in a specific row and column. The address is <code class="literal">3C</code> in hexadecimal (<code class="literal">0x3C</code>).</p><p>We have to specify the I<sup>2</sup>C bus number to which the OLED display is wired when we create an instance of the <code class="literal">Oled</code> class in the <code class="literal">bus</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">upmLcd. SSD1327</code> instance with the received <code class="literal">bus</code> argument followed by the <code class="literal">oled_i2c_address</code> class attribute, and saves the reference for the new instance in the <code class="literal">oled</code> attribute. Finally, the code calls the <code class="literal">clear</code> method for the new instance to clear the OLED screen.</p><p>The class declared the <code class="literal">print_line</code> method to make it easy to print text on a specific row. The code calls the <code class="literal">setCursor</code> method for the <code class="literal">upmLcd.SSD1327</code> instance (<code class="literal">self.oled</code>), with the received <code class="literal">row</code> value as the value for the <code class="literal">row</code> argument and <code class="literal">0</code> for the <code class="literal">column</code> argument, to locate the cursor in the specified row and the first column. Then, a call to the <code class="literal">setGrayLevel</code> and the <code class="literal">write</code> method for the the <code class="literal">upmLcd.SSD1327</code> instance (<code class="literal">self.oled</code>) with the <code class="literal">message</code> reveiced as a parameter as an argument prints the received string in the OLED display with the default 8-by-8 character box with the gray level set to 12. Under the hoods, the <code class="literal">upmLcd.SSD1327</code> instance will write data to the slave device whose address is equal to the <code class="literal">oled_i2c_address</code> class attribute through the I<sup>2</sup>C bus to specify the desired location for the cursor and then to write the specified text starting in the position in which we have located the cursor.</p><p>Now, we will create a subclass of the previously coded <code class="literal">Oled</code> class named <code class="literal">TemperatureAndHumidityOled</code>. The subclass will specialize the <code class="literal">Oled</code> class to allow us to easily print a temperature value expressed in degrees Fahrenheit, the temperature value expressed in degrees Celsius and a humidity value expressed in percentage. We will use the previously explained layout for the text. The following lines show the code for the new <code class="literal">TemperatureAndHumidityOled</code> class. The code file for the sample is <code class="literal">iot_python_chapter_08_02.py</code>.</p><div class="informalexample"><pre class="programlisting">class TemperatureAndHumidityOled(Oled):
    def print_temperature(self, temperature_fahrenheit, temperature_celsius):self.oled.clear()
        self.print_line(0, "Temperature")
        self.print_line(2, "Fahrenheit")
        self.print_line(3, "{:5.2f}".format(temperature_fahrenheit))
        self.print_line(5, "Celsius")
        self.print_line(6, "{:5.2f}".format(temperature_celsius))

    def print_humidity(self, humidity):
        self.print_line(8, "Humidity")
        self.print_line(9, "Level")
        self.print_line(10, "{0}%".format(humidity))</pre></div><p>The new<a id="id412" class="indexterm"/> class (<code class="literal">TemperatureAndHumidityOled</code>) adds the following two methods to its superclass (<code class="literal">Oled</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">print_temperature</code>: Calls the <code class="literal">print_line</code> method many times to display the temperature in both degrees Fahrenheit (ºF) and Celsius (ºC) received as arguments</li><li class="listitem" style="list-style-type: disc"><code class="literal">print_humidity</code>: Calls the <code class="literal">print_line</code> method many times to display the humidity value received as an argument</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip59"/>Tip</h3><p>In this case, we refresh many lines to change just a few values. As we will run a loop every 10 seconds, it won't be a problem. However, in other cases in which we want to update values in a shorter amount of time, we can write optimized code that just clears a single line and updates the specific value in this line.</p></div></div><p>Now, we will write a loop that will display the ambient temperature expressed in Fahrenheit (ºF) and Celsius (ºC) and the humidity value in the OLED screen, every 10 seconds. The code file for the sample is <code class="literal">iot_python_chapter_08_02.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    temperature_and_humidity_sensor = \
        TemperatureAndHumiditySensor(0)
<span class="strong"><strong>    oled = TemperatureAndHumidityOled(0)</strong></span>

    while True:
        temperature_and_humidity_sensor.\
            measure_temperature_and_humidity()
<span class="strong"><strong>        oled.print_temperature(</strong></span>
<span class="strong"><strong>            temperature_and_humidity_sensor.temperature_fahrenheit,</strong></span>
<span class="strong"><strong>            temperature_and_humidity_sensor.temperature_celsius)</strong></span>
<span class="strong"><strong>        oled.print_humidity(</strong></span>
<span class="strong"><strong>            temperature_and_humidity_sensor.humidity)</strong></span>
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_and_humidity_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_and_humidity_sensor.temperature_fahrenheit))
        print("Ambient humidity: {0}".
              format(temperature_and_humidity_sensor.humidity))
        # Sleep 10 seconds (10000 milliseconds)
        time.sleep(10)</pre></div><p>The<a id="id413" class="indexterm"/> highlighted lines show the changes made in the <code class="literal">__main__</code> method compared with the previous version. The first highlighted line creates an instance of the previously coded <code class="literal">TemperatureAndHumidityOled</code> class with <code class="literal">0</code> as the value of the <code class="literal">bus</code> argument. The code saves the reference to this instance in the <code class="literal">oled</code> local variable. This way, the instance will establish a communication with the OLED screen through the I<sup>2</sup>C bus.</p><p>Then, the code runs a loop forever and the highlighted line calls the <code class="literal">oled.print_temperature</code> method with <code class="literal">temperature_and_humidity_sensor.temperature_fahrenheit</code> and <code class="literal">temperature_and_humidity_sensor.temperature_celsius</code> as arguments. This way, the code displays both temperature values in the first lines of the OLED screen.</p><p>The next hightlighted line calls the <code class="literal">oled.print_humidity</code> method with <code class="literal">temperature_and_humidity_sensor.humidity</code>. This way, the code uses many lines to display this humidity value at the bottom of the OLED screen.</p><p>The following line will start the example:</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_08_02.py</pre></div><p>After you run the example, turn on an air conditioner or a heating system to generate a change in the ambient temperature and humidity. The OLED screen will display the temperature and humidity and refresh it every 10 seconds.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Wiring a servo motor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Wiring a servo motor</h1></div></div></div><p>So far, we <a id="id414" class="indexterm"/>have been using sensors to retrieve data from the real world and we displayed information in LCD and OLED displays. However, IoT devices are not limited to sensing and displaying data, they can also move things. We can connect different components, shields, or breakout boards to our Intel Galileo Gen 2 board and write Python code to move things connected to the board.</p><p>Standard servo motors are extremely useful to precisely control a shaft and position it at various angles, usually between 0 and 180 degrees. In <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, <span class="emphasis"><em>Working with a RESTful API and Pulse Width Modulation</em></span>, we worked with pulse width modulation, known as PWM, to control the brightness of an LED and a RGB LED. We can also use PWM to control a standard analog servo motor and position its shaft at a specific angle.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip60"/>Tip</h3><p>Standard servo motors are DC motors that includes gears and feedback control loop circuitry that provides precision positioning. They are ideal for pinion steering, robot arms and legs, among other usages that require a precise positioning. Standard servo motors don't require motor drivers.</p></div></div><p>Obviously, not <a id="id415" class="indexterm"/>all servor motors have the same features and we must take into account many of them when we select a specific servo motor for our project. It depends on what we need to position, the accuracy, the required torque, the optimal servo rotational velocity, among other factors. In this case, we will focus on the usage of PWM to position a standard servo motor. However, you cannot use the same servo to rotate a lighter plastic piece than the one you will need to rotate a heavy robotic arm. It is necessary to research about the appropriate servo for each task.</p><p>Now, we will wire a standard high sensitive mini servo motor to our existing project and we will rotate the shaft to display the measured temperature expressed in degrees Fahrenheit with the shaft. The shaft will allow us to display the measured temperature in a half circle protractor that measures angles in degrees and will display the number for the angle from 0 to 180 degrees. The combination of the servo with the shaft and the protactor will allow us to display the temperature with moving parts. Then, we can create our own protactor with a scale that can add colors, specific thresholds and many other visual artifacts to make temperature measurement funnier. Specifically, we can create a gauge chart, speedometer or semicircle donut, that is, a combination of a doughnut chart and a pie chart in a single chart with the different temperature values. The following picture shows and example of a half circle protractor that we can use in combination with the servo with the shaft.</p><div class="mediaobject"><img src="images/B05042_08_05.jpg" alt="Wiring a servo motor"/></div><p>We need the<a id="id416" class="indexterm"/> following additional part to work with this example: A SeeedStudio Grove Servo or a EMAX 9g ES08A High Sensitive Mini Servo. The following URLs provide detailed information about these servos: <a class="ulink" href="http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html">http://www.seeedstudio.com/depot/Grove-Servo-p-1241.html</a> and <a class="ulink" href="http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html">http://www.seeedstudio.com/depot/EMAX-9g-ES08A-High-Sensitive-Mini-Servo-p-760.html</a>.</p><p>The following diagram shows the digital temperature and humidity breakout, the LCD RGB backlight breakout, the mini servo, the necessary wirings and the wirings from the Intel Galileo Gen 2 board to the breadboard. The Fritzing file for the sample is <code class="literal">iot_fritzing_chapter_08_03.fzz</code> and the following picture is the breadboard view:</p><div class="mediaobject"><img src="images/B05042_08_06.jpg" alt="Wiring a servo motor"/></div><p>The following picture shows the schematic with the electronic components represented as symbols:</p><div class="mediaobject"><img src="images/B05042_08_07.jpg" alt="Wiring a servo motor"/></div><p>As seen in<a id="id417" class="indexterm"/> the previous schematic, we added the following additional connections to our existing project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The power pin labeled <span class="strong"><strong>5V</strong></span> in the board's symbol is connected to the servo's pin labeled <span class="strong"><strong>+</strong></span>. Servos usually use a red wire for this connection.</li><li class="listitem" style="list-style-type: disc">The PWM capable GPIO pin labeled <span class="strong"><strong>D3 PWM</strong></span> in the board's symbol is connected to the servo's pin labeled <span class="strong"><strong>PULSE</strong></span>. Servos usually use a yellow wire for this connection.</li><li class="listitem" style="list-style-type: disc">The ground pin labeled <span class="strong"><strong>GND</strong></span> in the board's symbol is connected to the servo's pin labeled <span class="strong"><strong>-</strong></span>. Servos usually use a black wire for this connection.</li></ul></div><p>Now, it is <a id="id418" class="indexterm"/>time make all the necessary wirings. Don't forget to shut down the Yocto Linux, wait for all the onboard LEDs to turn off, and unplug the power supply from the Intel Galileo Gen 2 board before adding or removing any wire from the board's pins.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Positioning a shaft to indicate a value with a servo motor"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Positioning a shaft to indicate a value with a servo motor</h1></div></div></div><p>We can use<a id="id419" class="indexterm"/> the <code class="literal">mraa.Pwm</code> class to control PWM on the PWM capable GPIO pin labeled <span class="strong"><strong>~3</strong></span>, as we learned in <a class="link" href="ch04.html" title="Chapter 4. Working with a RESTful API and Pulse Width Modulation">Chapter 4</a>, <span class="emphasis"><em>Working with a RESTful API and Pulse Width Modulation</em></span>. However, this would require us to read the detailed specs for the servo. The <code class="literal">upm</code> library includes support for both the SeeedStudio Grove Servo or the EMAX 9g ES08A High Sensitive Mini Servo in the <code class="literal">pyupm_servo</code> module. The <code class="literal">ES08A</code> class declared in this module represents any of the two mentioned servors connected to our board.</p><p>The class makes it easy to set the desired angle for the servo shaft and work with angles instead of duty cycles and other PWM details. The class works with the <code class="literal">mraa.Pwm</code> class under the hoods to configure PWM and control the duty cycle based on the desired angle for the shaft.</p><p>We will take the code we wrote in the previous example and we will use this code as a baseline to add the new features. The code file for the sample was <code class="literal">iot_python_chapter_08_02.py</code>.</p><p>We will create a <code class="literal">TemperatureServo</code> class to represent the servo and make it easier for us to position the shaft in a valid angle (from 0 to 180 degrees) based on the temperature expressed in degrees Fahrenheit. We will use the <code class="literal">ES08A</code> class to interact with the servo. The following lines show the code for the new <code class="literal">TemperatureServo</code> class that works with the <code class="literal">upm</code> library, specifically with the <code class="literal">pyupm_servo</code> module. The code file for the sample is <code class="literal">iot_python_chapter_08_03.py</code>.</p><div class="informalexample"><pre class="programlisting">import pyupm_th02 as upmTh02
import pyupm_i2clcd as upmLcd
import pyupm_servo as upmServo
import time


class TemperatureServo:
    def __init__(self, pin):
        self.servo = upmServo.ES08A(pin)
        self.servo.setAngle(0)

    def print_temperature(self, temperature_fahrenheit):
        angle = temperature_fahrenheit
        if angle &lt; 0:
            angle = 0
        elif angle &gt; 180:
            angle = 180
        self.servo.setAngle(angle)</pre></div><p>We have <a id="id420" class="indexterm"/>to specify the pin number to which the servo is connected when we create an instance of the <code class="literal">TemperatureServo</code> class in the <code class="literal">pin</code> required argument. The constructor, that is, the <code class="literal">__init__</code> method, creates a new <code class="literal">upmServo.ES08A</code> instance with the received <code class="literal">pin</code> as its <code class="literal">pin</code> argument, saves its reference in the <code class="literal">servo</code> attribute and calls its <code class="literal">setAngle</code> with <code class="literal">0</code> as the value for the <code class="literal">angle</code> required argument. This way, the underlying code will configure the output duty cycle for the PWM enabled GPIO pin based on the received value in the <code class="literal">angle</code> argument to position the shaft at the desired angle. In this case, we want the shaft to be positioned at 0 degrees.</p><p>The class defines a <code class="literal">print_temperature</code> method that receives a temperature value expressed in degrees Fahrenheit (ºF) in the <code class="literal">temperature_fahrenheit</code> argument. The code defines an <code class="literal">angle</code> local variable that makes sure that the desired angle for the shaft is in a valid range: from 0 to 180 (inclusive). If the value received in the <code class="literal">temperature_fahrenheit</code> argument is lower than <code class="literal">0</code>, the <code class="literal">angle</code> value will be <code class="literal">0</code>. If the value received in the <code class="literal">temperature_fahrenheit</code> argument is greater than <code class="literal">180</code>, the <code class="literal">angle</code> value will be <code class="literal">180</code>. Then, the code calls the <code class="literal">setAngle</code> method for the <code class="literal">upmServo.ES08A</code> instance (<code class="literal">self.servo</code>) with <code class="literal">angle</code> as an argument. Under the hoods, the <code class="literal">upmServo.ES08A</code> instance will configure the output duty cycle for the PWM enabled GPIO pin based on the received value in the <code class="literal">angle</code> argument to position the shaft at the desired angle. This way, the shaft will position at an angle that will be the same than the received temperature in degrees Fahrenheit (ºF), as long as the temperature value is between 0 and 180 degrees Fahrenheit (ºF).</p><p>In case it is too cold, (less than 0 degrees Fahrenheit) the shaft will stay at a 0 degrees angle. In case the temperature is higher than 180 degrees Fahrenheit, the shaft will stay at a 180 degrees angle.</p><p>Now, we will make changes to our main loop to display the ambient temperature expressed in Fahrenheit (ºF) with the shaft, every 10 seconds. The code file for the sample is <code class="literal">iot_python_chapter_08_03.py</code>.</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    temperature_and_humidity_sensor = \
        TemperatureAndHumiditySensor(0)
    oled = TemperatureAndHumidityOled(0)
<span class="strong"><strong>    temperature_servo = TemperatureServo(3)</strong></span>
    while True:

        temperature_and_humidity_sensor.\
            measure_temperature_and_humidity()
        oled.print_temperature(
            temperature_and_humidity_sensor.temperature_fahrenheit,
            temperature_and_humidity_sensor.temperature_celsius)
        oled.print_humidity(
            temperature_and_humidity_sensor.humidity)
<span class="strong"><strong>        temperature_servo.print_temperature(</strong></span>
<span class="strong"><strong>            temperature_and_humidity_sensor.temperature_fahrenheit)</strong></span>
        print("Ambient temperature in degrees Celsius: {0}".
              format(temperature_and_humidity_sensor.temperature_celsius))
        print("Ambient temperature in degrees Fahrenheit: {0}".
              format(temperature_and_humidity_sensor.temperature_fahrenheit))
        print("Ambient humidity: {0}".
              format(temperature_and_humidity_sensor.humidity))
        # Sleep 10 seconds (10000 milliseconds)
        time.sleep(10)</pre></div><p>The <a id="id421" class="indexterm"/>highlighted lines show the changes made to the <code class="literal">__main__</code> method compared with the previous version. The first highlighted line creates an instance of the previously coded <code class="literal">TemperatureServo</code> class with <code class="literal">3</code> as the value of the <code class="literal">pin</code> argument. The code saves the reference to this instance in the <code class="literal">temperature_servo</code> local variable. This way, the instance will configure PWM for pin number 3 and position the shaft at <code class="literal">0</code> degrees.</p><p>Then, the code runs a loop forever and the highlighted line calls the <code class="literal">temperature_servo.print_temperature</code> method with <code class="literal">temperature_and_humidity_sensor.temperature_fahrenheit</code> as an argument. This way, the code makes the shaft point to the temperature value in the protractor.</p><p>The following line will start the example.</p><div class="informalexample"><pre class="programlisting">python iot_python_chapter_08_03.py</pre></div><p>After you run the example, turn on an air conditioner or a heating system and generate a change in<a id="id422" class="indexterm"/> the ambient temperature. You will notice how the shaft starts moving to reflect the changes in the temperature every 10 seconds. </p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Test your knowledge"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Test your knowledge</h1></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The Intel Galileo Gen 2 board works as an I<sup>2</sup>C bus master and allows us to:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Connect many slaves to the I<sup>2</sup>C bus as long as their have different I<sup>2</sup>C addresses.</li><li class="listitem">Connect many slaves to the I<sup>2</sup>C bus as long as their have the same I<sup>2</sup>C addresses.</li><li class="listitem">Connect a maximum of two slaves to the I<sup>2</sup>C bus as long as their have different I<sup>2</sup>C addresses.</li></ol></div></li><li class="listitem">A 16x2 LCD module allows us to display:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Two lines of text with 16 characters each.</li><li class="listitem">Sixteen lines of text with 2 characters each.</li><li class="listitem">Sixteen lines of text with 3 characters each.</li></ol></div></li><li class="listitem">A 16 grayscale 96-by-96 dot matrix OLED display module allows us to control:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">96 lines of text with 96 characters each.</li><li class="listitem">A single line with 96 dots or 96 characters, based on how we configure the OLED display.</li><li class="listitem">9,216 dots (96*96).</li></ol></div></li><li class="listitem">A 16 grayscale 96-by-96 dot matrix OLED display with an 8-by-8 character box allows us to display:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">96 lines of text with 96 characters each: 96 columns and 96 rows.</li><li class="listitem">16 lines of text with 16 characters each: 16 columns and 16 rows.</li><li class="listitem">12 lines of text with 12 characters each: 12 columns and 12 rows.</li></ol></div></li><li class="listitem">Standard servos allow us to:<div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Display text on an OLED display.</li><li class="listitem">Position the shaft at various specific angles.</li><li class="listitem">Move the shaft to a specific location by specifying the desired latitude and longitude.</li></ol></div></li></ol></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Summary</h1></div></div></div><p>In this chapter, we learned about different displays the we could connect to our board through the I<sup>2</sup>C bus. We worked with an LCD display, an RGB backlight, and then replaced it with an OLED dot matrix.</p><p>We wrote the code that took advantage of the modules and classes included in the <code class="literal">upm</code> library that made it easier for us to work with LCD and OLED display and show text on them. In addition, we wrote the code that interacted with an analog servo. Instead of writing our own code to set the output duty cycle based on the desired position for the shaft, we took advantage of a specific module and a class in the <code class="literal">upm</code> library. We could control the shaft to allow us to create a gauge chart to display the temperature value retrieved with a sensor. Our Python code could make things move.</p><p>Now that we are able to show data next to the board and work with servos, we will connect our IoT device to the entire world and work with cloud services, which is the topic of the next chapter.</p></div></div>
</body></html>