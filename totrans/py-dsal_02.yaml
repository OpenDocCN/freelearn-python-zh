- en: Python Data Types and Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to examine the Python data types in detail. We
    have already been introduced to two data types, the string, `str()`, and `list()`.
    It is often the case where we want more specialized objects to represent our data.
    In addition to the built-in types, there are several internal modules that allow
    us to address common issues when working with data structures. First, we are going
    to review some operations and expressions that are common to all data types.
  prefs: []
  type: TYPE_NORMAL
- en: Operations and expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of operations that are common to all data types. For example,
    all data types, and generally all objects, can be tested for a truth value in
    some way. The following are values that Python considers `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `None` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer, float, or complex zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty sequence or mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of a user-defined class that defines a `__len__()` or `__bool__()`
    method that returns zero or `False`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other values are considered `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Boolean operation returns a value of eighter `True` or `False`. Boolean operations
    are ordered in priority, so if more than one Boolean operation occurs in an expression,
    the operation with the highest priority will occur first. The following table
    outlines the three Boolean operators in descending order of priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| not `x` | Returns `True` if `x` is `False`; returns `False` otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `x` and `y` | Returns `True` if both `x` and `y` are `True`; returns `False`
    otherwise. |'
  prefs: []
  type: TYPE_TB
- en: '| `x` or `y` | Returns `True` if either `x` or `y` is `True`; returns `False`
    otherwise. |'
  prefs: []
  type: TYPE_TB
- en: Both the `and` operator and the `or` operator use "short-circuiting" when evaluating
    an expression. This means Python will only evaluate an operator if it needs to.
    For example, if `x` is `True` then in an expression `x` or `y`, the `y` does not
    get evaluated since the expression is obviously `True`. In a similar way, in an
    expression `x` and `y` where `x` is `False`, the interpreter will simply evaluate
    `x` and return `False`, without evaluating `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison and Arithmetic operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard arithmetic operators (`+`, `-`, `*`, `/`) work with all Python
    numeric types. The `//` operator gives an integer quotient, (for example, `3 //
    2` returns `1`), the exponent operator is `x ** y`, and the modulus operator,
    given by `a % b`, returns the remainder of the division `a/b`. The comparison
    operators (`<`, `<=`, `>`, `>=`, `==`, and `!=`) work with numbers, strings, lists,
    and other collection objects and return `True` if the condition holds. For collection
    objects, these operators compare the number of elements and the equivalence operator
    `== b` returns `True` if each collection object is structurally equivalent, and
    the value of each element is identical.
  prefs: []
  type: TYPE_NORMAL
- en: Membership, identity, and logical operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Membership operators (`in`, `not in`) test for variables in sequences, such
    as lists or strings do what you would expect, `x in y` returns `True` if a variable
    `x` is found in `y`. The `is` operator compares object identity. For example,
    the following snippet shows contrast equivalence with object identity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_001.png)'
  prefs: []
  type: TYPE_IMG
- en: Built-in data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python data types can be divided into three categories: numeric, sequence,
    and mapping. There is also the `None` object that represents a `Null`, or absence
    of a value. It should not be forgotten either that other objects such as classes,
    files, and exceptions can also properly be considered *types*; however, they will
    not be considered here.'
  prefs: []
  type: TYPE_NORMAL
- en: Every value in Python has a data type. Unlike many programming languages, in
    Python you do not need to explicitly declare the type of a variable. Python keeps
    track of object types internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python built-in data types are outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| None | `None` | The null object. |'
  prefs: []
  type: TYPE_TB
- en: '| Numeric | `int` | Integer. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `float` | Floating point number. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `complex` | Complex number. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `bool` | Boolean (True, False). |'
  prefs: []
  type: TYPE_TB
- en: '| Sequences | `str` | String of characters. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `list` | List of arbitrary objects. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `Tuple` | Group of arbitrary items. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `range` | Creates a range of integers. |'
  prefs: []
  type: TYPE_TB
- en: '| Mapping | `dict` | Dictionary of key-value pairs. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `set` | Mutable, unordered collection of unique items. |'
  prefs: []
  type: TYPE_TB
- en: '|  | `frozenset` | Immutable set. |'
  prefs: []
  type: TYPE_TB
- en: None type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The None type is immutable and has one value, `None`. It is used to represent
    the absence of a value. It is returned by objects that do not explicitly return
    a value and evaluates to `False` in Boolean expressions. It is often used as the
    default value in optional arguments to allow the function to detect whether the
    caller has passed a value.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All numeric types, apart from `bool`, are signed and they are all immutable.
    Booleans have two possible values, `True` and `False`. These values are mapped
    to 1 and 0, respectively. The integer type, `int`, represents whole numbers of
    unlimited range. Floating point numbers are represented by the native double precision
    floating point representation of the machine. Complex numbers are represented
    by two floating point numbers. They are assigned using the `j` operator to signify
    the imaginary part of the complex number, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can access the real and imaginary parts with `a.real` and `a.imag`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Representation error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It should be noted that the native double precision representation of floating
    point numbers leads to some unexpected results. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a result of the fact that most decimal fractions are not exactly representable
    as a binary fraction, which is how most underlying hardware represents floating
    point numbers. For algorithms or applications where this may be an issue, Python
    provides a `decimal` module. This module allows for the exact representation of
    decimal numbers and facilitates greater control properties such as rounding behavior,
    number of significant digits, and precision. It defines two objects, a `Decimal`
    type, representing decimal numbers, and a `Context` type, representing various
    computational parameters such as precision, rounding, and error handling. An example
    of its usage can be seen in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we have created a global context and set the precision to `4`. The `Decimal`
    object can be treated pretty much as you would treat an `int` or a `float`. They
    are subject to all the same mathematical operations and can be used as dictionary
    keys, placed in sets, and so on. In addition, `Decimal` objects also have several
    methods for mathematical operations, such as natural exponents, `x.exp()`, natural
    logarithms, `x.ln()`, and base 10 logarithms, `x.log10()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python also has a `fractions` module that implements a rational number type.
    The following example shows several ways to create fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_004.png)'
  prefs: []
  type: TYPE_IMG
- en: It is also worth mentioning here the `NumPy` extension. This has types for mathematical
    objects such as arrays, vectors, and matrixes, and capabilities for linear algebra,
    calculation of Fourier transforms, eigenvectors, logical operations, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequences are ordered sets of objects indexed by non-negative integers. Lists
    and tuples are sequences of arbitrary objects, strings are sequences of characters.
    String, tuple, and range objects are immutable. All sequence types have a number
    of operations in common. For all sequences, the indexing and slicing operators
    apply as described in the previous chapter. Note that for the immutable types,
    any operation will only return a value rather than actually change the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'All sequences have the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `len(s)` | Number of elements in `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `min(s, [,default=obj, key=func])` | The minimum value in `s` (alphabetically
    for strings) |'
  prefs: []
  type: TYPE_TB
- en: '| `max(s, [,default=obj, key=func])` | Maximum value in `s` (alphabetically
    for strings) |'
  prefs: []
  type: TYPE_TB
- en: '| `sum(s,[,start=0])` | The sum of the elements (returns `TypeError` if `s`
    is not numeric) |'
  prefs: []
  type: TYPE_TB
- en: '| `all(s)` | Returns `True` if all elements in `s` are True (that is, not `0`,
    `False`, or  `Null`) |'
  prefs: []
  type: TYPE_TB
- en: '| `any(s)` | Checks whether any item in `s` is `True` |'
  prefs: []
  type: TYPE_TB
- en: 'In addition, all sequences support the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `s + r` | Concatenates two sequences of the same type |'
  prefs: []
  type: TYPE_TB
- en: '| `s * n` | Make `n` copies of `s`, where `n` is an integer |'
  prefs: []
  type: TYPE_TB
- en: '| `v1, v2 ..., vn = s` | Unpacks n variables from `s` to `v1`, `v2`, and so
    on |'
  prefs: []
  type: TYPE_TB
- en: '| `s[i]` | Indexing-returns element `i` of `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `s[i:j:stride]` | Slicing returns elements between `i` and `j` with optional
    stride |'
  prefs: []
  type: TYPE_TB
- en: '| `x in s` | Returns `True` if element `x` is in `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `x not in s` | Returns true if element `x` is not in `s` |'
  prefs: []
  type: TYPE_TB
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples are immutable sequences of arbitrary objects. They are indexed by integers
    greater than zero. Tuples are **hashable**, which means we can sort lists of them
    and they can be used as keys to dictionaries. Syntactically, tuples are just a
    comma-separated sequence of values; however, it is common practice to enclose
    them in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to remember to use a trailing comma when creating a tuple with
    one element, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Without the trailing comma, this would be interpreted as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create a tuple using the built-in function `tuple()`. With no argument,
    this creates an empty tuple. If the argument to `tuple()` is a sequence then this
    creates a tuple of elements of that sequence, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_005.png)'
  prefs: []
  type: TYPE_IMG
- en: Most operators, such as those for slicing and indexing, work as they do on lists.
    However, because tuples are immutable, trying to modify an element of a tuple
    will give you a `TypeError.` We can compare tuples in the same way that we compare
    other sequences, using the `==`, `>` and `<` operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important use of tuples is to allow us to assign more than one variable
    at a time by placing a tuple on the left-hand side of an assignment, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can actually use this multiple assignment to swap values in a tuple, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_007.png)'
  prefs: []
  type: TYPE_IMG
- en: A `ValueError` will be thrown if the number of values on each side of the assignment
    are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dictionaries are arbitrary collections of objects indexed by numbers, strings,
    or other immutable objects. Dictionaries themselves are mutable; however, their
    index keys must be immutable. The following table contains all the dictionary
    methods and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `len(d)` | Number of items in `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.clear()` | Removes all items from `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.copy()` | Makes a shallow copy of `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.fromkeys(s [,value])` | Returns a new dictionary with keys from sequence
    `s` and values set to `value`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.get(k [,v])` | Returns `d[k]` if found, or else returns `v`, or None if
    `v` is not given. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.items()` | Returns a sequence of `key:value` pairs in `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.keys()` | Returns a sequence of keys in `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.pop(k [,default])` | Returns `d[k]` and removes it from `d`. If `d[k]`
    is not found, it returns default or raises `KeyError`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.popitem()` | Removes a random `key:value` pair from `d` and returns it
    as a tuple. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.setdefault(k [,v])` | Returns `d[k]`. If `d[k]` is not found, it returns
    `v` and sets `d[k]` to `v`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.update(b)` | Adds all objects from `b` to `d`. |'
  prefs: []
  type: TYPE_TB
- en: '| `d.values()` | Returns a sequence of values in `d`. |'
  prefs: []
  type: TYPE_TB
- en: 'Python dictionaries are the only built-in mapping type and they are similar
    to hash tables or associative arrays found in other languages. They can be thought
    of as a mapping from a set of keys to a set of values. They are created using
    the syntax `{key:value}`. For example, the following creates a dictionary mapping
    words to numerals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add keys and values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or update multiple values using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we inspect `d`, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can test for the occurrence of a value using the `in` operator, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_009.png)'
  prefs: []
  type: TYPE_IMG
- en: It should be noted that the `in` operator, when applied to dictionaries, works
    in a slightly different way to when it is applied to a list. When we use the `in`
    operator on a list, the relationship between the time it takes to find an element
    and the size of the list is considered linear. That is, as the size of the list
    gets bigger, the corresponding time it takes to find an element grows, at most,
    linearly. The relationship between the time an algorithm takes to run compared
    to the size of its input is often referred to as its time complexity. We will
    talk more about this important topic in the next (and subsequent) chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the `list` object, when the `in` operator is applied to dictionaries,
    it uses a hashing algorithm and this has the effect of the increase in time for
    each lookup almost independent of the size of the dictionary. This makes dictionaries
    extremely useful as a way to work with large amounts of indexed data. We will
    talk more about this important topic of rates of growth hashing in [Chapter 4](fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml),
    *Lists and pointer structures*, and [Chapter 13](48e9b010-a4c9-4cc3-9ae0-de772639da37.xhtml), *Implementations,
    applications and tools*.
  prefs: []
  type: TYPE_NORMAL
- en: Notice when we print out the `key:value` pairs of the dictionary it does so
    in no particular order. This is not a problem since we use specified keys to look
    up each dictionary value rather than an ordered sequence of integers as is the
    case for strings and lists.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to do a simple sort on either the keys or values of a dictionary,
    we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_010.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the first line in the preceding code sorts the keys according to alphabetical
    order, and the second line sorts the values in order of integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sorted()` method has two optional arguments that are of interest: `key`
    and `reverse`. The key argument has nothing to do with the dictionary keys, but
    rather is a way of passing a function to the sort algorithm to determine the sort
    order. For example, in the following code, we use the `__getitem__` special method
    to sort the dictionary keys according to the dictionary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Essentially, what the preceding code is doing is for every `key` in `d` to
    use the corresponding value to sort. We can also sort the values according to
    the sorted order of the dictionary keys. However, since dictionaries do not have
    a method to return a `key` by using its value, the equivalent of the `list.index`
    method for lists, using the optional `key` argument to do this is a little tricky.
    An alternative approach is to use a list comprehension, as the following example
    demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `sorted()` method also has an optional reverse argument, and unsurprisingly,
    this does exactly what it says, reverses the order of the sorted list, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s say we are given the following dictionary, English words as keys
    and French words as values. Our task is to place these string values in correct
    numerical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, when we print this dictionary out, it will be unlikely to print
    in the correct order. Because all keys and values are strings, we have no context
    for numerical ordering. To place these items in correct order, we need to use
    the first dictionary we created, mapping words to numerals as a way to order our
    English to French dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice we are using the values of the first dictionary, `d`, to sort the keys
    of the second dictionary, `d2`. Since our keys in both dictionaries are the same,
    we can use a list comprehension to sort the values of the French to English dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can, of course, define our own custom method that we can use as the `key`
    argument to the `sorted` method. For example, here we define a function that simply
    returns the last letter of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this as the `key` to our `sorted` function to sort each element
    by its last letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_016.png)'
  prefs: []
  type: TYPE_IMG
- en: Dictionaries for text analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common use of dictionaries is to count the occurrences of like items in a
    sequence; a typical example is counting the occurrences of words in a body of
    text. The following code creates a dictionary where each word in the text is used
    as a key and the number of occurrences as its value. This uses a very common idiom
    of nested loops. Here we are using it to traverse the lines in a file in an outer
    loop and the keys of a dictionary on the inner loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a dictionary with an element for each unique word in the text
    file. A common task is to filter items such as these into subsets we are interested
    in. You will need a text file saved in the same directory as you run the code.
    Here we have used `alice.txt`, a short excerpt from *Alice in Wonderland*. To
    obtain the same results, you can download `alice.txt` from [davejulian.net/bo5630](http://davejulian.net/bo5630),
    or use a text file of your own. In the following code, we create another dictionary,
    `filtered`, containing a subset of items from `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print the filtered dictionary, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_017.png)'
  prefs: []
  type: TYPE_IMG
- en: Note the use of the **dictionary comprehension** used to construct the filtered
    dictionary. Dictionary comprehensions work in an identical way to the list comprehensions
    we looked at in [Chapter 1](bed519dd-40d8-4bfd-a721-184d8ea37555.xhtml), *Python
    Objects, Types, and Expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sets are unordered collections of unique items. Sets are themselves mutable,
    we can add and remove items from them; however, the items themselves must be immutable.
    An important distinction with sets is that they cannot contain duplicate items.
    Sets are typically used to perform mathematical operations such as intersection,
    union, difference, and complement.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike sequence types, set types do not provide any indexing or slicing operations.
    There are also no keys associated with values, as is the case with dictionaries.
    There are two types of set objects in Python, the mutable `set` object and the
    immutable `frozenset` object. Sets are created using comma-separated values within
    curly braces. By the way, we cannot create an empty set using `a={}`, because
    this will create a dictionary. To create an empty set, we write either `a=set()`
    or `a=frozenset()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods and operations of sets are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Operators** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `len(s)` |  | Returns the number of elements in `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.copy()` |  | Returns a shallow copy of `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.difference(t)` | `s - t- t2 - ...` | Returns a set of all items in `s`
    but not in `t` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.intersection(t)` |  | Returns a set of all items in both `t` and `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.isdisjoint(t)` |  | Returns True if `s` and `t` have no items in common
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.issubset(t)` | `s <= t``s < t (s != t)` | Returns True if all items in
    `s` are also in `t` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.issuperset(t)` | `s >= t``s > t (s != t)` | Returns True if all items
    in `t` are also in `s` |'
  prefs: []
  type: TYPE_TB
- en: '| `s.symmetric_difference(t)` | `s ^ t` | Returns a set of all items that are
    in `s` or `t`, but not both |'
  prefs: []
  type: TYPE_TB
- en: '| `s.union(t)` | `s &#124; t1 &#124; t2 &#124;...` | Returns a set of all items
    in `s` or `t` |'
  prefs: []
  type: TYPE_TB
- en: In the preceding table, the parameter `t` can be any Python object that supports
    iteration and all methods are available to both `set` and `frozenset` objects.
    It is important to be aware that the operator versions of these methods require
    their arguments to be sets, whereas the methods themselves can accept any iterable
    type. For example, `s - [1,2,3]`, for any set `s`, will generate an unsupported
    operand type. Using the equivalent `s.difference([1,2,3])` will return a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutable set objects have additional methods, described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `s.add(item)` | Adds item to `s`. Has no effect if `item` is already present.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.clear()` | Removes all items from `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.difference_update(t)` | Removes all items in `s` that are also in `t`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `s.discard(item)` | Removes `item` from `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.intersection_update(t)` | Removes all items from `s` that are not in the
    intersection of `s` and `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.pop()` | Returns and removes an arbitrary item from `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.remove(item)` | Removes item from `s`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.symetric_difference_update(t)` | Removes all items from `s` that are not
    in the symmetric difference of `s` and `t`. |'
  prefs: []
  type: TYPE_TB
- en: '| `s.update(t)` | Adds all the items in an iterable object `t` to `s`. |'
  prefs: []
  type: TYPE_TB
- en: 'The following example demonstrates some simple set operations and their results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_018.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the set object does not care that its members are not all of the
    same type, as long as they are all immutable. If you try to use a mutable object
    such as a list or dictionaries in a set, you will receive an unhashable type error.
    Hashable types all have a hash value that does not change throughout the lifetime
    of the instance. All built-in immutable types are hashable. All built-in mutable
    types are not hashable, so they cannot be used as elements of sets or keys to
    dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Notice also in the preceding code that when we print out the union of `s1` and
    `s2,` there is only one element with the value `'ab'`. This is a natural property
    of sets in that they do not include duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these built-in methods there are a number of other operations
    that we can perform on sets. For example, to test for membership of a set, use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can loop through elements in a set using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_020.png)'
  prefs: []
  type: TYPE_IMG
- en: Immutable sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has an immutable set type called `frozenset`. It works pretty much exactly
    like `set` apart from not allowing methods or operations that change values such
    as the `add()` or `clear()` methods. There are several ways that this immutability
    can be useful. For example, since normal sets are mutable and therefore not hashable,
    they cannot be used as members of other sets. The `frozenset`, on the other hand,
    is immutable and therefore able to be used as a member of a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also the immutable property of `frozenset` means we can use it for a `key`
    to a dictionary, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_022.png)'
  prefs: []
  type: TYPE_IMG
- en: Modules for data structures and algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the built-in types, there are several Python modules that we
    can use to extend these built-in types and functions. In many cases, these Python
    modules may offer efficiency and programming advantages that allow us to simplify
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at the built-in datatypes of strings, lists, sets, and
    dictionaries as well as the `decimal` and `fractions` modules. They are often
    described by the term **abstract data types** (**ADTs**). ADTs can be considered
    as mathematical specifications for the set of operations that can be performed
    on data. They are defined by their behavior rather than their implementation.
    In addition to the ADTs that we have looked at, there are several Python libraries
    that provide extensions to the built-in datatypes. These will be discussed in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `collections` module provides more specialized, high, performance alternatives
    for the built-in data types as well as a utility function to create named tuples.
    The following table lists the datatypes and operations of the collections module
    and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Datatype or operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `namedtuple()` | Creates tuple subclasses with named fields. |'
  prefs: []
  type: TYPE_TB
- en: '| `deque` | Lists with fast appends and pops either end. |'
  prefs: []
  type: TYPE_TB
- en: '| `ChainMap` | Dictionary like class to create a single view of multiple mappings.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Counter` | Dictionary subclass for counting hashable objects. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderedDict` | Dictionary subclass that remembers the entry order. |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultdict` | Dictionary subclass that calls a function to supply missing
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `UserDict``UserList``UserString` | These three data types are simply wrappers
    for their underlying base classes. Their use has largely been supplanted by the
    ability to subclasas their respective base classes directly. Can be used to access
    the underlying object as an attribute. |'
  prefs: []
  type: TYPE_TB
- en: Deques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Double-ended queues, or deques (usually pronounced *decks*), are list-like objects
    that support thread-safe, memory-efficient appends. Deques are mutable and support
    some of the operations of lists, such as indexing. Deques can be assigned by index,
    for example, `dq[1] = z`; however, we cannot directly slice deques. For example,
    `dq[1:2]` results in a `TypeError` (we will look at a way to return a slice from
    a `deque` as a list shortly).
  prefs: []
  type: TYPE_NORMAL
- en: The major advantage of deques over lists is that inserting items at the beginning
    of a deque is much faster than inserting items at the beginning of a list, although
    inserting items at the end of a `deque` is very slightly slower than the equivalent
    operation on a list. Deques are thread, safe and can be serialized using the `pickle`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful way of thinking about deques is in terms of populating and consuming
    items. Items in deques are usually populated and consumed sequentially from either
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the `pop()` and `popleft()` methods for consuming items in the `deque`,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the `rotate(n)` method to move and rotate all items of *n*
    steps to the right for positive values of the integer *n*, or left for negative
    values of n the left, using positive integers as the argument, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that we can use the `rotate` and `pop` methods to delete selected elements.
    Also worth knowing is a simple way to return a slice of a deque, as a list, which
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_026.png)'
  prefs: []
  type: TYPE_IMG
- en: The `itertools.islice` method works in the same way that slice works on a list,
    except rather than taking a list for an argument, it takes an iterable and returns
    selected values, by start and stop indices, as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful feature of deques is that they support a `maxlen` optional parameter
    that restricts the size of the `deque`. This makes it ideally suited to a data
    structure known as a **circular buffer**. This is a fixed-size structure that
    is effectively connected end to end and they are typically used for buffering
    data streams. The following is a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_027.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we are populating from the right and consuming from the left.
    Notice that once the buffer is full, the oldest values are consumed first, and
    values are replaced from the right. We will look at circular buffers again in
    [Chapter 4](fb02c65a-fcf9-44cb-b3a7-9ed2d4705a86.xhtml), *Lists and Pointer Structures*,
    by implementing circular lists.
  prefs: []
  type: TYPE_NORMAL
- en: ChainMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `collections.chainmap` class was added in Python 3.2 and it provides a
    way to link a number of dictionaries, or other mappings, so that they can be treated
    as one object. In addition, there is a `maps` attribute, a `new_child()` method,
    and a `parents` property. The underlying mappings for `ChainMap` objects are stored
    in a list and are accessible using the `maps[*i*]` attribute to retrieve the `ith`
    dictionary. Note that even though dictionaries themselves are unordered, ChainMaps
    are an ordered list of dictionaries. `ChainMap` is useful in applications where
    we are using a number of dictionaries containing related data. The consuming application
    expects data in terms of a priority, where the same key in two dictionaries is
    given priority if it occurs at the beginning of the underlying list. `ChainMap` is
    typically used to simulate nested contexts such as when we have multiple overriding
    configuration settings. The following example demonstrates a possible use case
    for `ChainMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_028.png)'
  prefs: []
  type: TYPE_IMG
- en: The advantage of using ChainMaps, rather than just a dictionary, is that we
    retain previously set values. Adding a child context overrides values for the
    same key, but it does not remove it from the data structure. This can be useful
    for when we may need to keep a record of changes so that we can easily roll back
    to a previous setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve and change any value in any of the dictionaries by providing
    the `map()` method with an appropriate index. This index represents a dictionary
    in the ChainMap. Also, we can retrieve the parent setting, that is, the default
    settings, by using the `parents()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_029.png)'
  prefs: []
  type: TYPE_IMG
- en: Counter objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Counter is a subclass of a dictionary where each dictionary `key` is a hashable
    object and the associated value is an integer count of that object. There are
    three ways to initialize a counter. We can pass it any sequence object, a dictionary
    of `key:value` pairs, or a tuple of the format `(object = value, ...)`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_030.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also create an empty counter object and populate it by passing its `update`
    method an iterable or a dictionary, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_031.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how the `update` method adds the counts rather than replacing them with
    new values. Once the counter is populated, we can access stored values in the
    same way we would for dictionaries, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_032.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The most notable difference between counter objects and dictionaries is that
    counter objects return a zero count for missing items rather than raising a `key`
    error, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_033.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can create an iterator out of a `Counter` object by using its `elements()`
    method. This returns an iterator where counts below one are not included and the
    order is not guaranteed. In the following code, we perform some updates, create
    an iterator from `Counter` elements, and use `sorted()` to sort the keys alphabetically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_034.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Two other Counter methods worth mentioning are `most_common()` and `subtract()`.
    The most common method takes a positive integer argument that determines the number
    of most common elements to return. Elements are returned as a list of `(key ,value)`
    tuples. The `subtract` method works exactly like update except instead of adding
    values, it subtracts them, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_035.png)'
  prefs: []
  type: TYPE_IMG
- en: Ordered dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The important thing about ordered dictionaries is that they remember the insertion
    order, so when we iterate over them, they return values in the order they were
    inserted. This is in contrast to a normal dictionary, where the order is arbitrary.
    When we test to see whether two dictionaries are equal, this equality is only
    based on their keys and values; however, with an `OrderedDict`, the insertion
    order is also considered An equality test between two OrderedDicts with the same
    keys and values but a different insertion order will return `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_036.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, when we add values from a list using `update`, the `OrderedDict`
    will retain the same order as the list. This is the order that is returned when
    we iterate the values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_037.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `OrderedDict` is often used in conjunction with the sorted method to create
    a sorted dictionary. For example, in the following example we use a `lambda` function
    to sort on the values, here we use a numerical expression to sort the integer
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_038.png)'
  prefs: []
  type: TYPE_IMG
- en: defaultdict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `defaultdict` object is a subclass of `dict` and therefore they share methods
    and operations. It acts as a convenient way to initialize dictionaries. With a
    `dict`, Python will throw a `KeyError` when attempting to access a key that is
    not already in the dictionary. The `defaultdict` overrides one method, `__missing__(key)`,
    and creates a new instance variable, `default_factory`. With `defaultdict`, rather
    than throw an error, it will run the function, supplied as the `default_factory`
    argument, which will generate a value. A simple use of `defaultdict` is to set
    `default_factory` to `int` and use it to quickly tally the counts of items in
    the dictionary, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_039.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will notice that if we tried to do this with an ordinary dictionary, we
    would get a key error when we tried to add the first key. The `int` we supplied
    as an argument to default `dict` is really the function `int()` that simply returns
    a zero. We can, of course, create a function that will determine the dictionary''s
    values. For example, the following function returns `True` if the supplied argument
    is a primary color, that is red, green, or blue, or returns `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a new `defaultdict` object and use the `isprimary` function
    to populate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_040.png)'
  prefs: []
  type: TYPE_IMG
- en: Named Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `namedtuple` method returns a tuple-like object that has fields accessible
    with named indexes as well as the integer indexes of normal tuples. This allows
    for code that is, to a certain extent, self-documenting and more readable. It
    can be especially useful in an application where there is a large number of tuples
    and we need to easily keep track of what each tuple represents. The `namedtuple`
    inherits methods from `tuple` and it is backward-compatible with `tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The field names are passed to the `namedtuple` method as comma and/or whitespace
    separated values. They can also be passed as a sequence of strings. Field names
    are single strings and they can be any legal Python identifier that does not begin
    with a digit or an underscore. A typical example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_041.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `namedtuple` method take two optional Boolean arguments, `verbose` and
    `rename`. When `verbose` is set to `True` then the class definition is printed
    when it is built. This argument is depreciated in favor of using the `__source`
    attribute. When the `rename` argument is set to `True` then any invalid field
    names will be automatically replaced with positional arguments. As an example,
    we attempt to use `def` as a field name. This would normally generate an error,
    but since we have assigned `rename` to `True`, the Python interpreter allows this.
    However, when we attempt to look up the `def` value, we get a syntax error, since
    `def` is a reserved keyword. The illegal field name has been replaced by a field
    name created by adding an underscore to the positional value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_042.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition to the inherited tuple methods, the named tuple also defines three
    methods of its own, `_make()` , `asdict()`, and `_replace`. These methods begin
    with an underscore to prevent potential conflicts with field names. The `_make()`
    method takes an iterable as an argument and turns it into a named tuple object,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_043.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `_asdict` method returns an `OrderedDict` with the field names mapped to
    index keys and the values mapped to the dictionary values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_044.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `_replace` method returns a new instance of the tuple, replacing the specified
    values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_045.png)'
  prefs: []
  type: TYPE_IMG
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The array module defines a datatype `array` that is similar to the `list` datatype
    except for the constraint that their contents must be of a single type of the
    underlying representation, as is determined by the machine architecture or underlying
    C implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of an array is determined at creation time and it is indicated by
    one of the following type codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | C type | Python type | Minimum bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `''b''` | `signed char` | `int` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `''B''` | `unsigned char` | `int` | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `''u''` | `Py_UNICODE` | `Unicode character` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `''h''` | `signed short` | `int` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `''H''` | `unsigned short` | `int` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `''i''` | `signed int` | `int` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `''I''` | `unsigned int` | `int` | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `''l''` | `signed long` | `int` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `''L''` | `unsigned long` | `int` | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `''q''` | `signed long long` | `int` | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `''Q''` | `unsigned lon long` | `int` | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `''f''` | `float` | `float` | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `''d''` | `double` | `float` | 8 |'
  prefs: []
  type: TYPE_TB
- en: 'The array objects support the following attributes and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute or method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `a.typecode` | The typecode character used to create the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.itemsize` | Size, in bytes, of items stored in the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.append(x)` | Appends item `x` to the end of the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.buffer_info()` | Returns the memory location and length of the buffer
    used to store the array. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.byteswap()` | Swaps the byte order of each item. Used for writing to a
    machine or file with a different byte order. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.count(x)` | Returns the number of occurrences of `x` in `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.extend(b)` | Appends any iterable, `b`, to the end of array `a`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.frombytes(s)` | Appends items from a string, `s`, as an array of machine
    values. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.fromfile(f, n)` | Reads `n` items, as machine values, from a file object,
    `f`, and appends them to `a`. Raises an `EOFError` if there are fewer than `n`
    items in `n`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.fromlist(l)` | Appends items from list `l`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.fromunicode(s)` | Extends `a` with unicode string `s`. Array `a` must
    be of type `u` or else `ValueError` is raised. |'
  prefs: []
  type: TYPE_TB
- en: '| `index(x)` | Returns the first (smallest) index of item `x.` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.insert(i, x)` | Inserts item `x` before index `i.` |'
  prefs: []
  type: TYPE_TB
- en: '| `a.pop([i])` | Removes and returns items with index `i`. Defaults to the
    last item `(i = -1)` if not specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.remove(x)` | Removes the first occurrence of item `x`. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.reverse()` | Reverses the order of items. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.tobytes()` | Convert the array to machine values and returns the bytes
    representation. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.tofile(f)` | Writes all items, as machine values, to file object `f`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a.tolist()` | Converts the array to a list. |'
  prefs: []
  type: TYPE_TB
- en: '| `a.tounicode()` | Convert an array to `unicode` string. The array type must
    be `''u''` or else a `ValueError` is raised. |'
  prefs: []
  type: TYPE_TB
- en: Array objects support all the normal sequence operations such as indexing, slicing,
    concatenation, and multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using arrays, as opposed to lists, is a much more efficient way of storing
    data that is all of the same type. In the following example, we have created an
    integer array of the digits from 0 to 1 million minus 1, and an identical list.
    Storing 1 million integers in an integer array requires around 45% of the memory
    of an equivalent list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_046.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Because we are interested in saving space, that is, we are dealing with large
    datasets and limited memory size, we usually perform in-place operations on arrays,
    and only create copies when we need to. Typically, enumerate is used to perform
    an operation on each element. In the following snippet, we perform the simple
    operation of adding one to each item in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It should be noted that when performing operations on arrays that create lists,
    such as list comprehensions, the memory efficiency gains of using an array in
    the first place will be negated. When we need to create a new data object, a solution
    is to use a generator expression to perform the operation, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_02_048.png)'
  prefs: []
  type: TYPE_IMG
- en: Arrays created with this module are unsuitable for work that requires a matrix
    of vector operations. In the next chapter, we will build our own abstract data
    type to deal with these operations. Also important for numerical work is the `NumPy`
    extension, available at [www.numpy.org](http://www.numpy.org) .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last two chapters, we have examined the language features and data types
    of Python. We have looked at the built-in data types and some internal Python
    modules, most notably the collections module. There are also several other Python
    modules that are relevant to the topic of this book, but rather than examining
    them separately, their use and functionality should become self-evident as we
    begin using them. There are also a number of external libraries such as the SciPy
    stack, and, likewise, I will attempt to explain their basic functionality as we
    begin to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the basic theory and techniques of algorithm
    design.
  prefs: []
  type: TYPE_NORMAL
