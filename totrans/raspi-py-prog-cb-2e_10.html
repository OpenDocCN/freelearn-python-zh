<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Interfacing with Technology"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Interfacing with Technology</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Automating your home with remote sockets</li><li class="listitem" style="list-style-type: disc">Using SPI to control an LED matrix</li><li class="listitem" style="list-style-type: disc">Communicating using a serial interface</li><li class="listitem" style="list-style-type: disc">Controlling the Raspberry Pi over Bluetooth</li><li class="listitem" style="list-style-type: disc">Controlling USB devices</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Introduction</h1></div></div></div><p>One of the key aspects of the Raspberry Pi that differentiates it from an average computer is its ability to interface with and control hardware. In this chapter, we use the Raspberry Pi to control remotely activated mains sockets, send commands over serial connections from another computer, and control the GPIO remotely. We make use of SPI (another useful protocol) to drive an 8 x 8 LED matrix display.</p><p>We also use a Bluetooth module to connect with a smartphone, allowing information to be transferred wirelessly between devices. Finally, we take control of USB devices by tapping into the commands sent over USB.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip28"/>Tip</h3><p>Be sure to check out the <span class="emphasis"><em>Hardware list</em></span> section in the <a class="link" href="apa.html" title="Appendix A. Hardware and Software List">Appendix</a>, <span class="emphasis"><em>Hardware and Software List</em></span>; it lists all the items used in this chapter and the places you can obtain them from.</p></div></div></div></div>
<div class="section" title="Automating your home with remote sockets"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Automating your home with remote sockets</h1></div></div></div><p>The Raspberry Pi <a class="indexterm" id="id847"/>can make an excellent tool for home <a class="indexterm" id="id848"/>automation by providing accurate timing, control, and the ability to respond to commands, button inputs, environmental sensors, or messages from the Internet.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec212"/>Getting ready</h2></div></div></div><p>Great care must be taken when controlling devices that use electricity from the mains since high <a class="indexterm" id="id849"/>voltages and currents are often involved.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note96"/>Note</h3><p>Never attempt to modify or alter devices that are connected to mains electricity without proper training. You must never directly connect any homemade devices to the mains supply. All electronics must undergo rigorous safety testing to ensure that there will be no risk or harm to people or property in the event of a failure.</p></div></div><p>In this example, we will use remote controlled <span class="strong"><strong>radio frequency</strong></span> (<span class="strong"><strong>RF</strong></span>) plug-in sockets; these use a separate <a class="indexterm" id="id850"/>remote unit to send a specific RF signal to switch any electrical device that is plugged into it on or off. This allows us to modify the remote control and use the Raspberry Pi to activate the switches safely, without interfering <a class="indexterm" id="id851"/>with dangerous voltages:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_01.jpg"/><div class="caption"><p>Remote control and remote mains socket</p></div></div><p>The particular remote control used in this example has six buttons on it to directly switch three different sockets on or off and is powered by a 12V battery. It can be switched into four different channels, which would allow you to control a total of 12 sockets (each socket has a similar selector that will be used to set the signal it will respond to).</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_02.jpg"/><div class="caption"><p>Inside the remote control</p></div></div><p>The remote<a class="indexterm" id="id852"/> buttons, when pressed, will broadcast a <a class="indexterm" id="id853"/>specific RF signal (this one uses a transmission frequency of 433.92 MHz). This will trigger any socket(s) that is set to the corresponding channel (A, B, C, or D) and number (1, 2, or 3).</p><p>Internally, each of the buttons connects two separate signals to ground, the number (1, 2, or 3), and state (on or off). This triggers the correct broadcast that is to be made by the remote control.</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_03.jpg"/><div class="caption"><p>Connect the wires to ON, OFF, 1, 2, 3, and GND at suitable points on the remote's PCB (only ON, OFF, 1, and GND are connected in the image)</p></div></div><p>It is recommended that you do not connect anything to your sockets that could cause a hazard if switched on or off. The signals sent by the remote are not unique (there are only four different channels available). This therefore makes it possible for someone else nearby who has a similar set of sockets to unknowingly activate/deactivate one of your sockets. It is recommended that you select a channel other than the default, A, which will slightly reduce the chance of someone else accidentally using the same channel.</p><p>To allow the <a class="indexterm" id="id854"/>Raspberry Pi to simulate the button presses <a class="indexterm" id="id855"/>of the remote, we will need five relays to allow us to select the number (1, 2, or 3) and state (on or off). </p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_04.jpg"/><div class="caption"><p>A prebuilt Relay Module can be used to switch the signals</p></div></div><p>Alternatively, the transistor and relay circuit from <a class="link" href="ch09.html" title="Chapter 9. Building Robots">Chapter 9</a>, <span class="emphasis"><em>Building Robots</em></span>, can be used to simulate the button presses.</p><p>Wire the<a class="indexterm" id="id856"/> relay control pins to the Raspberry Pi GPIO <a class="indexterm" id="id857"/>and connect the socket remote control to each relay output as follows:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_05.jpg"/><div class="caption"><p>The socket remote control circuit</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note97"/>Note</h3><p>Although the remote socket requires both the number (1, 2, or 3) and the state (on or off) to activate a socket, it is the state signal that activates the RF transmission. To avoid draining the remote's battery, we must ensure that we have turned off the state signal.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec213"/>How to do it...</h2></div></div></div><p>Create<a class="indexterm" id="id858"/> the<a class="indexterm" id="id859"/> following <code class="literal">socketControl.py</code> script:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
# socketControl.py
import time
import RPi.GPIO as GPIO
#HARDWARE SETUP
# P1
# 2[V=G====XI====]26[=======]40
# 1[=====321=====]25[=======]39
#V=5V  G=Gnd
sw_num=[15,13,11]#Pins for Switch 1,2,3
sw_state=[16,18]#Pins for State X=Off,I=On
MSGOFF=0; MSGON=1
SW_ACTIVE=0; SW_INACTIVE=1

class Switch():
  def __init__(self):
    self.setup()
  def __enter__(self):
    return self
  def setup(self):
    print("Do init")
    #Setup the wiring
    GPIO.setmode(GPIO.BOARD)
    for pin in sw_num:
      GPIO.setup(pin,GPIO.OUT)
    for pin in sw_state:
      GPIO.setup(pin,GPIO.OUT)
    self.clear()
  def message(self,number,state):
    print ("SEND SW_CMD: %s %d" % (number,state))
    if state==MSGON:
      self.on(number)
    else:
      self.off(number)
  def on(self,number):
    print ("ON: %d"% number)
    GPIO.output(sw_num[number-1],SW_ACTIVE)
    GPIO.output(sw_state[MSGON],SW_ACTIVE)
    GPIO.output(sw_state[MSGOFF],SW_INACTIVE)
    time.sleep(0.5)
    self.clear()
  def off(self,number):
    print ("OFF: %d"% number)
    GPIO.output(sw_num[number-1],SW_ACTIVE)
    GPIO.output(sw_state[MSGON],SW_INACTIVE)
    GPIO.output(sw_state[MSGOFF],SW_ACTIVE)
    time.sleep(0.5)
    self.clear()
  def clear(self):
    for pin in sw_num:
      GPIO.output(pin,SW_INACTIVE)
    for pin in sw_state:
      GPIO.output(pin,SW_INACTIVE)
  def __exit__(self, type, value, traceback):
    self.clear()
    GPIO.cleanup()
def main():
  with Switch() as mySwitches:
    mySwitches.on(1)
    time.sleep(5)
    mySwitches.off(1)  
    
if __name__ == "__main__":
    main()
#End</pre></div><p>The socket<a class="indexterm" id="id860"/> control script performs a quick test by <a class="indexterm" id="id861"/>switching the first socket on for 5 seconds and then turning it off again.</p><p>To control the rest of the sockets, create a GUI menu as follows:</p><div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_06.jpg"/><div class="caption"><p>Remote Switches GUI</p></div></div><p>Create<a class="indexterm" id="id862"/> the<a class="indexterm" id="id863"/> following <code class="literal">socketMenu.py</code> script:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
#socketMenu.py
import tkinter as TK
import socketControl as SC

#Define Switches ["Switch name","Switch number"]
switch1 = ["Living Room Lamp",1]
switch2 = ["Coffee Machine",2]
switch3 = ["Bedroom Fan",3]
sw_list = [switch1,switch2,switch3]
SW_NAME = 0; SW_CMD  = 1
SW_COLOR=["gray","green"]

class swButtons:
  def __init__(self,gui,sw_index,switchCtrl):
    #Add the buttons to window
    self.msgType=TK.IntVar()
    self.msgType.set(SC.MSGOFF)
    self.btn = TK.Button(gui,
                  text=sw_list[sw_index][SW_NAME],
                  width=30, command=self.sendMsg,
                  bg=SW_COLOR[self.msgType.get()])
    self.btn.pack()
    msgOn = TK.Radiobutton(gui,text="On",
              variable=self.msgType, value=SC.MSGON)
    msgOn.pack()
    msgOff = TK.Radiobutton(gui,text="Off",
              variable=self.msgType,value=SC.MSGOFF)
    msgOff.pack()
    self.sw_num=sw_list[sw_index][SW_CMD]
    self.sw_ctrl=switchCtrl
  def sendMsg(self):
    print ("SW_CMD: %s %d" % (self.sw_num,
                              self.msgType.get()))
    self.btn.configure(bg=SW_COLOR[self.msgType.get()])
    self.sw_ctrl.message(self.sw_num,
                         self.msgType.get())

root = TK.Tk()
root.title("Remote Switches")
prompt = "Control a switch"
label1 = TK.Label(root, text=prompt, width=len(prompt),
                  justify=TK.CENTER, bg='lightblue')
label1.pack()
#Create the switch
with SC.Switch() as mySwitches:
  #Create menu buttons from sw_list
  for index, app in enumerate(sw_list):
    swButtons(root,index,mySwitches)
  root.mainloop()
#End</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec214"/>How it works...</h2></div></div></div><p>The first <a class="indexterm" id="id864"/>script defines a class called <code class="literal">Switch</code>; it sets <a class="indexterm" id="id865"/>up the GPIO pins required to control the five relays (within the setup function). It also defines the <code class="literal">__enter__</code> and <code class="literal">__exit__</code> functions, which are special functions used by the <code class="literal">with..as</code> statement. When a class is created using <code class="literal">with..as</code>, it uses <code class="literal">__enter__</code> to perform any extra initialization or setup (if required), and then it performs any cleanup by calling <code class="literal">__exit__</code>. When the <code class="literal">Switch</code> class has been executed, all the relays are switched off to preserve the remote's battery and <code class="literal">GPIO.cleanup()</code> is called to release the GPIO pins. The parameters of the <code class="literal">__exit__</code> function (<code class="literal">type</code>, <code class="literal">value</code>, and <code class="literal">traceback</code>) allow the handling of any specific exceptions that may have occurred when the class was being executed within the <code class="literal">with..as</code> statement (if required).</p><p>To control the sockets, create two functions that will switch the relevant relays on or off to activate the remote control to send the required signal to the sockets. Then, shortly after, turn the relays off again using <code class="literal">clear()</code>. To make controlling the switches even easier, create a <code class="literal">message</code> function that will allow a switch number and state to be specified.</p><p>We make use of the <code class="literal">socketControl.py</code> script by creating a Tkinter GUI menu. The menu is made up of three sets of controls (one for each of the switches) that are defined by the <code class="literal">swButtons</code> class.</p><p>The <code class="literal">swButtons</code> class<a class="indexterm" id="id866"/> creates a <code class="literal">Tkinter</code> button and<a class="indexterm" id="id867"/> two <code class="literal">Radiobutton</code> controls. Each <code class="literal">swButtons</code> object is given an index and a reference to the <code class="literal">mySwitches</code> object. This allows us to set a name for the button and control a particular switch when it is pressed. The socket is activated/deactivated by calling <code class="literal">message()</code>, with the required switch number and state set by the <code class="literal">Radiobutton</code> controls.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec215"/>There's more...</h2></div></div></div><p>The previous example allows you to rewire the remotes of most remote controlled sockets, but another option is to emulate the signals to control it directly.</p><div class="section" title="Sending RF control signals directly"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec86"/>Sending RF control signals directly</h3></div></div></div><p>Instead of rewiring the remote control, you can replicate the remote's RF signals using a transmitter<a class="indexterm" id="id868"/> that uses the same frequency as <a class="indexterm" id="id869"/>your sockets (these particular units use 433.94 MHz). This will depend on the particular sockets and sometimes your location—some countries prohibit the use of certain frequencies—as you may require certification before making your own transmissions:</p><div class="mediaobject"><img alt="Sending RF control signals directly" src="graphics/6623OT_10_07.jpg"/><div class="caption"><p>The 433.94 MHz RF transmitter (left) and receiver (right)</p></div></div><p>The signals sent by the RF remote control can be recreated using 433Utils created by <a class="ulink" href="http://ninjablocks.com">http://ninjablocks.com</a>. The 433Utils uses WiringPi and are written in C++, allowing high speed capture and replication of the RF signals.</p><p>Obtain the code using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd ~</strong></span>
<span class="strong"><strong>wget https://github.com/ninjablocks/433Utils/archive/master.zip</strong></span>
<span class="strong"><strong>unzip master.zip</strong></span>
</pre></div><p>Next, we<a class="indexterm" id="id870"/> need to wire up our RF transmitter (so we can control the switches) and RF receiver (so we can determine the control codes) to <a class="indexterm" id="id871"/>the Raspberry Pi.</p><p>The transmitter (the smaller square module) has three pins, which are power (VCC), ground (GND), and data out (ATAD). The voltage supplied on the power pin will govern the transmission range (we will use 5V supply from the Raspberry Pi, but you could replace this with 12V, as long as you ensure you connect the ground pin to both your 12V supply and the Raspberry Pi).</p><p>Although the receiver has four pins, there is a power pin (VCC), ground pin (GND), and two data out pins (DATA), which are wired together, so we only need to connect three wires to the Raspberry Pi.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>RF Tx</p>
</th><th style="text-align: left" valign="bottom">
<p>RPi GPIO pin</p>
</th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>RF Rx</p>
</th><th style="text-align: left" valign="bottom">
<p>RPi GPIO pin</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>VCC (5V)</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>VCC (3V3)</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Data out</p>
</td><td style="text-align: left" valign="top">
<p>11</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>Data in</p>
</td><td style="text-align: left" valign="top">
<p>13</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>GND</p>
</td><td style="text-align: left" valign="top">
<p>6</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>GND</p>
</td><td style="text-align: left" valign="top">
<p>9</p>
</td></tr></tbody></table></div><p>Before we use the programs within the <code class="literal">RPi_Utils</code>, we will make a few adjustments to ensure our RX and TX pins are set correctly.</p><p>Locate <code class="literal">codesend.cpp</code> in <code class="literal">433Utils-master/RPi_utils/</code> to make the required changes:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd ~/433Utils-master/RPi_utils</strong></span>
<span class="strong"><strong>nano codesend.cpp -c</strong></span>
</pre></div><p>Change <code class="literal">int PIN = 0;</code> (located at around line 24) to <code class="literal">int PIN = 11;</code> (RPi physical pin number).</p><p>Change <code class="literal">wiringPi</code> to use physical pin numbering (located around line 27) by replacing <code class="literal">wiringPiSetup()</code> with <code class="literal">wiringPiSetupPhy()</code>. Otherwise, the default is WiringPi GPIO numbers; for more <a class="indexterm" id="id872"/>details, see <a class="ulink" href="http://wiringpi.com/reference/setup/">http://wiringpi.com/reference/setup/</a>. Find the following line:</p><div class="informalexample"><pre class="programlisting">if (wiringPiSetup () == -1) return 1;</pre></div><p>Change it to this:</p><div class="informalexample"><pre class="programlisting">if (wiringPiSetupPhys () == -1) return 1;</pre></div><p>Save and exit <code class="literal">nano</code> using <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>.</p><p>Make similar adjustments to <code class="literal">RFSniffer.cpp</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>nano RFSniffer.cpp -c</strong></span>
</pre></div><p>Find the<a class="indexterm" id="id873"/> following line (located at around line 25):</p><div class="informalexample"><pre class="programlisting">     int PIN = 2;</pre></div><p>Change it to<a class="indexterm" id="id874"/> this:</p><div class="informalexample"><pre class="programlisting">     int PIN = 13; //RPi physical pin number</pre></div><p>Find the following line (located at around line 27:</p><div class="informalexample"><pre class="programlisting">     if(wiringPiSetup() == -1) {</pre></div><p>Change it to this:</p><div class="informalexample"><pre class="programlisting">     if(wiringPiSetupPhys() == -1) {</pre></div><p>Save and exit <code class="literal">nano</code> using <span class="emphasis"><em>Ctrl </em></span>+ <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>.</p><p>Build the code using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>make all</strong></span>
</pre></div><p>This should build without errors, as shown here:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>g++    -c -o codesend.o codesend.cpp</strong></span>
<span class="strong"><strong>g++   RCSwitch.o codesend.o -o codesend -lwiringPi</strong></span>
<span class="strong"><strong>g++    -c -o RFSniffer.o RFSniffer.cpp</strong></span>
<span class="strong"><strong>g++   RCSwitch.o RFSniffer.o -o RFSniffer -lwiringPi</strong></span>
</pre></div><p>Now that we have our RF modules connected to the Raspberry Pi and our code ready, we can capture the control signals from our remote. Run the following command and take note of the reported output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo ./RFSniffer</strong></span>
</pre></div><p>Get the output by pressing Button 1 OFF with the remote set to channel A (note we may get a few that pick up random noise):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Received 1381716</strong></span>
<span class="strong"><strong>Received 1381716</strong></span>
<span class="strong"><strong>Received 1381716</strong></span>
<span class="strong"><strong>Received 1381717</strong></span>
<span class="strong"><strong>Received 1398103</strong></span>
</pre></div><p>We can now send out the signals using the <code class="literal">sendcode</code> command to switch the sockets OFF (<code class="literal">1381716</code>) and ON (<code class="literal">1381719</code>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sendcode 1381716</strong></span>
<span class="strong"><strong>sendcode 1381719</strong></span>
</pre></div><p>You could <a class="indexterm" id="id875"/>even set up the Raspberry Pi to <a class="indexterm" id="id876"/>use the receiver module to detect signals from the remote (on an unused channel) and act upon them to start processes, control other hardware, or perhaps trigger a software shutdown/reboot.</p></div><div class="section" title="Extending the range of the RF Transmitter"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec87"/>Extending the range of the RF Transmitter</h3></div></div></div><p>The range <a class="indexterm" id="id877"/>of the transmitter is very limited <a class="indexterm" id="id878"/>when it is powered by 5V and without an additional antenna. However, it is worth testing everything before you make any modifications.</p><p>Simple wire antenna can be made from 25 cm of single core wire, 17 mm side connected to the antenna solder point, then 16 turns (made using a thin screwdriver shaft or similar) and the <a class="indexterm" id="id879"/>remaining wire on top (approximately 53 mm). This is described in more detail at .</p><div class="mediaobject"><img alt="Extending the range of the RF Transmitter" src="graphics/6623OT_10_08.jpg"/><div class="caption"><p>The transmitter range is vastly improved with a simple antenna</p></div></div></div><div class="section" title="Determining the structure of the remote control codes"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec88"/>Determining the structure of the remote control codes</h3></div></div></div><p>Recording<a class="indexterm" id="id880"/> the codes this for <a class="indexterm" id="id881"/>each of the buttons, we can determine the codes for each (and break down the structure):</p><div class="mediaobject"><img alt="Determining the structure of the remote control codes" src="graphics/Table_new.jpg"/></div><p>To select channel A, B, C, or D, set the two bits to 00. Similarly, for button 1, 2, or 3, set the two bits to 00 to select that button. Finally, set the last two bits to 11 for ON or 00 for OFF.</p><p>See <a class="ulink" href="https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-foryour-arduino/">https://arduinodiy.wordpress.com/2014/08/12/433-mhz-system-foryour-arduino/</a>, which analyses these and other similar RF remote controls.</p></div></div><div class="section" title="Using SPI to control an LED matrix"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl1sec77"/>Using SPI to control an LED matrix</h2></div></div></div><p>In <a class="link" href="ch07.html" title="Chapter 7. Sense and Display Real-World Data">Chapter 7</a>, <span class="emphasis"><em>Sense and Display Real-World Data</em></span>, we connected to devices using a bus protocol called I<sup>2</sup>C. The Raspberry Pi also supports another chip-to-chip protocol called <span class="strong"><strong>SPI</strong></span> (<span class="strong"><strong>Serial Peripheral Interface</strong></span>). The SPI bus differs from I<sup>2</sup>C because it uses two single <a class="indexterm" id="id885"/>direction <a class="indexterm" id="id886"/>data lines (where I<sup>2</sup>C uses one bidirectional data line). Although SPI requires more wires (I<sup>2</sup>C uses two<a class="indexterm" id="id887"/> bus signals, SDA and SCL), it supports the simultaneous sending and receiving of data and much higher clock speeds than I<sup>2</sup>C.</p><div class="mediaobject"><img alt="Using SPI to control an LED matrix" src="graphics/6623OT_10_09.jpg"/><div class="caption"><p>General connections of SPI devices with the Raspberry Pi</p></div></div><p>The SPI bus <a class="indexterm" id="id888"/>consists <a class="indexterm" id="id889"/>of the following four signals:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>SCLK</strong></span>: This<a class="indexterm" id="id890"/> provides the clock edges to read/write data on the input/output lines; it is driven by the master device. As the clock signal changes from one state to another, the SPI device will check the state of the MOSI signal to read a single bit. Similarly, if the SPI device is sending data, it will use the clock signal edges to synchronize when it sets the state of the MISO signal.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>CE</strong></span>: This<a class="indexterm" id="id891"/> refers to Chip Enable (typically, a separate Chip Enable is used for each slave device on the bus). The master device will set the Chip Enable signal to low for the device that it wants to communicate with. When the Chip Enable signal<a class="indexterm" id="id892"/> is set to high, it ignores any other<a class="indexterm" id="id893"/> signals on the bus. This signal is sometimes called <span class="strong"><strong>Chip Select</strong></span> (<span class="strong"><strong>CS</strong></span>) or <span class="strong"><strong>Slave Select</strong></span> (<span class="strong"><strong>SS</strong></span>).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MOSI</strong></span>: This <a class="indexterm" id="id894"/>stands for Master Output, Slave Input (it connects to Data Out of the master device and Data In of the slave device).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>MISO</strong></span>: This<a class="indexterm" id="id895"/> stands for Master Input, Slave Output (it provides a response from the slave).</li></ul></div><p>The following diagram shows each of the signals:</p><div class="mediaobject"><img alt="Using SPI to control an LED matrix" src="graphics/6623OT_10_10.jpg"/><div class="caption"><p>The SPI signals: SCLK (1), CE(2), MOSI(3), and MISO(4)</p></div></div><p>The previous<a class="indexterm" id="id896"/> scope trace <a class="indexterm" id="id897"/>shows two bytes being sent over SPI. Each byte is clocked into the SPI device using the <span class="strong"><strong>SCLK (1)</strong></span> signal. A byte is signified by a burst of eight clock cycles (a low and then high period on the <span class="strong"><strong>SCLK (1)</strong></span> signal), where the value of a specific bit is read when the clock state changes. The exact sample point is determined by the clock mode; in the following diagram, it is when the clock goes from low to high:</p><div class="mediaobject"><img alt="Using SPI to control an LED matrix" src="graphics/6623OT_10_11.jpg"/><div class="caption"><p>The first data byte sent by the Raspberry Pi to the SPI device on the MOSI(3) signal</p></div></div><p>The first byte sent is 0x01 (all the bits are low, except <span class="strong"><strong>Bit 0</strong></span>) and the second sent is 0x03 (only <span class="strong"><strong>Bit 1</strong></span> and <span class="strong"><strong>Bit 0</strong></span> are high). At the same time, the <span class="strong"><strong>MOSI (4)</strong></span> signal returns data from the SPI device—in this case, 0x08 (<span class="strong"><strong>Bit 3</strong></span> is high) and 0x00 (all the bits are low). The <span class="strong"><strong>SCLK (1)</strong></span> signal is used to sync everything, even the data being sent from the SPI device.</p><p>The <span class="strong"><strong>CE (2)</strong></span> signal is held low while the data is being sent to instruct that particular SPI device<a class="indexterm" id="id898"/> to listen to <a class="indexterm" id="id899"/>the <span class="strong"><strong>MOSI (4)</strong></span> signal. When the <span class="strong"><strong>CE (2)</strong></span> signal is set to high again, it indicates to the SPI device that the transfer has been completed.</p><p>The following is an image of an 8 x 8 LED matrix that is controlled via the <span class="strong"><strong>SPI Bus</strong></span>:</p><div class="mediaobject"><img alt="Using SPI to control an LED matrix" src="graphics/6623OT_10_12.jpg"/><div class="caption"><p>An 8 x 8 LED module displaying the letter K</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec216"/>Getting ready</h3></div></div></div><p>The <code class="literal">wiringPi</code> library that we used previously for I<sup>2</sup>C also supports SPI. Ensure that wiringPi is installed (see <a class="link" href="ch07.html" title="Chapter 7. Sense and Display Real-World Data">Chapter 7</a>, <span class="emphasis"><em>Sense and Display Real-World Data</em></span>, for details) so that we can use it here.</p><p>Next, we need to enable SPI if we didn't do so when we enabled I<sup>2</sup>C previously:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo nano /boot/config.txt</strong></span>
</pre></div><p>Remove the <code class="literal">#</code> before #dtparam=spi=on to enable it, so it reads, and save (<span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>,<span class="emphasis"><em> Enter</em></span>):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dtparam=spi=on</strong></span>
</pre></div><p>You can confirm that the SPI is active by listing all the running modules using the following command and locating <code class="literal">spi_bcm2835</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>lsmod</strong></span>
</pre></div><p>You<a class="indexterm" id="id900"/> can test the SPI <a class="indexterm" id="id901"/>with the following <code class="literal">spiTest.py</code> script:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
# spiTest.py
import wiringpi

print("Add SPI Loopback - connect GPIO Pin19 and Pin21")
print("[Press Enter to continue]")
input()
wiringpi.wiringPiSPISetup(1,500000)
buffer=str.encode("HELLO")
print("Buffer sent %s" % buffer)
wiringpi.wiringPiSPIDataRW(1,buffer)
print("Buffer received %s" % buffer)
print("Remove the SPI Loopback")
print("[Press Enter to continue]")
input()
buffer=str.encode("HELLO")
print("Buffer sent %s" % buffer)
wiringpi.wiringPiSPIDataRW(1,buffer)
print("Buffer received %s" % buffer)
#End</pre></div><p>Connect inputs 19 and 21 to create an SPI loopback for testing.</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_13.jpg"/><div class="caption"><p>The SPI loopback test</p></div></div><p>You should get the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Buffer sent b'HELLO'</strong></span>
<span class="strong"><strong>Buffer received b'HELLO'</strong></span>
<span class="strong"><strong>Remove the SPI Loopback</strong></span>
<span class="strong"><strong>[Press Enter to continue]</strong></span>
<span class="strong"><strong>Buffer sent b'HELLO'</strong></span>
<span class="strong"><strong>Buffer received b'\x00\x00\x00\x00\x00'</strong></span>
</pre></div><p>The<a class="indexterm" id="id902"/> example that <a class="indexterm" id="id903"/>follows uses an LED 8 x 8 matrix <a class="indexterm" id="id904"/>display that is being driven by an SPI-controlled <span class="strong"><strong>MAX7219 LED driver</strong></span>:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_14.jpg"/><div class="caption"><p>An LED Controller MAX7219 pin-out, LED matrix pin-out, and LED matrix internal wiring (left to right)</p></div></div><p>Although the device has been designed to control eight separate 7-segment LED digits, we can use it for our LED matrix display. When used for digits, each of the seven segments (plus a decimal place) is wired to one of the SEG pins, and the COM connection of each of the digits is wired to the DIG pins. The controller then switches each of the segments on as required, while setting the relevant digit COM low to enable it. The controller can quickly cycle through each of the digits using the DIG pin fast enough that all eight appear to be lit at the same time:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_15.jpg"/><div class="caption"><p>A 7-segment LED digit uses segments A to G, plus DP (decimal place)</p></div></div><p>We use the<a class="indexterm" id="id905"/> controller in <a class="indexterm" id="id906"/>a similar way, except each SEG pin will connect to a column in the matrix and the DIG pins will enable/disable a row.</p><p>We use an 8 x 8 module connected to the MAX7219 chip as follows:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_16.jpg"/><div class="caption"><p>The MAX7219 LED controller driving an 8 x 8 LED matrix display</p></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec217"/>How to do it…</h3></div></div></div><p>To control<a class="indexterm" id="id907"/> an LED matrix<a class="indexterm" id="id908"/> connected to an SPI MAX7219 chip, create the following <code class="literal">matrixControl.py</code> script:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
# matrixControl.py
import wiringpi
import time

MAX7219_NOOP        = 0x00
DIG0=0x01; DIG1=0x02; DIG2=0x03; DIG3=0x04
DIG4=0x05; DIG5=0x06; DIG6=0x07; DIG7=0x08
MAX7219_DIGIT=[DIG0,DIG1,DIG2,DIG3,DIG4,DIG5,DIG6,DIG7]
MAX7219_DECODEMODE  = 0x09
MAX7219_INTENSITY   = 0x0A
MAX7219_SCANLIMIT   = 0x0B
MAX7219_SHUTDOWN    = 0x0C
MAX7219_DISPLAYTEST = 0x0F
SPI_CS=1
SPI_SPEED=100000

class matrix():
  def __init__(self,DEBUG=False):
    self.DEBUG=DEBUG
    wiringpi.wiringPiSPISetup(SPI_CS,SPI_SPEED)
    self.sendCmd(MAX7219_SCANLIMIT, 8)   # enable outputs
    self.sendCmd(MAX7219_DECODEMODE, 0)  # no digit decode
    self.sendCmd(MAX7219_DISPLAYTEST, 0) # display test off
    self.clear()
    self.brightness(7)                   # brightness 0-15
    self.sendCmd(MAX7219_SHUTDOWN, 1)    # start display
  def sendCmd(self, register, data):
    buffer=(register&lt;&lt;8)+data
    buffer=buffer.to_bytes(2, byteorder='big')
    if self.DEBUG:print("Send byte: 0x%04x"%
                        int.from_bytes(buffer,'big'))
    wiringpi.wiringPiSPIDataRW(SPI_CS,buffer)
    if self.DEBUG:print("Response:  0x%04x"%
                        int.from_bytes(buffer,'big'))
    return buffer
  def clear(self):
    if self.DEBUG:print("Clear")
    for row in MAX7219_DIGIT:
      self.sendCmd(row + 1, 0)
  def brightness(self,intensity):
    self.sendCmd(MAX7219_INTENSITY, intensity % 16)

def letterK(matrix):
    print("K")
    K=(0x0066763e1e366646).to_bytes(8, byteorder='big')
    for idx,value in enumerate(K):
        matrix.sendCmd(idx+1,value)

def main():
    myMatrix=matrix(DEBUG=True)
    letterK(myMatrix)
    while(1):
      time.sleep(5)
      myMatrix.clear()
      time.sleep(5)
      letterK(myMatrix)

if __name__ == '__main__':
    main()
#End</pre></div><p>Running the <a class="indexterm" id="id909"/>script (<code class="literal">python3 matrixControl.py</code>) displays the letter K.</p><p>We can <a class="indexterm" id="id910"/>use a GUI to control the output of the LED matrix using <code class="literal">matrixMenu.py</code>:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
#matrixMenu.py
import tkinter as TK
import time
import matrixControl as MC

#Enable/Disable DEBUG
DEBUG = True
#Set display sizes
BUTTON_SIZE = 10
NUM_BUTTON = 8
NUM_LIGHTS=NUM_BUTTON*NUM_BUTTON
MAX_VALUE=0xFFFFFFFFFFFFFFFF
MARGIN = 2
WINDOW_H = MARGIN+((BUTTON_SIZE+MARGIN)*NUM_BUTTON)
WINDOW_W = WINDOW_H
TEXT_WIDTH=int(2+((NUM_BUTTON*NUM_BUTTON)/4))
LIGHTOFFON=["red4","red"]
OFF = 0; ON = 1
colBg = "black"

def isBitSet(value,bit):
  return (value&gt;&gt;bit &amp; 1)

def setBit(value,bit,state=1):
  mask=1&lt;&lt;bit
  if state==1:
    value|=mask
  else:
    value&amp;=~mask
  return value

def toggleBit(value,bit):
  state=isBitSet(value,bit)
  value=setBit(value,bit,not state)
  return value

class matrixGUI(TK.Frame):
  def __init__(self,parent,matrix):
    self.parent = parent
    self.matrix=matrix
    #Light Status
    self.lightStatus=0
    #Add a canvas area ready for drawing on
    self.canvas = TK.Canvas(parent, width=WINDOW_W,
                        height=WINDOW_H, background=colBg)
    self.canvas.pack()
    #Add some "lights" to the canvas
    self.light = []
    for iy in range(NUM_BUTTON):
      for ix in range(NUM_BUTTON):
        x = MARGIN+MARGIN+((MARGIN+BUTTON_SIZE)*ix)
        y = MARGIN+MARGIN+((MARGIN+BUTTON_SIZE)*iy)
        self.light.append(self.canvas.create_rectangle(x,y,
                              x+BUTTON_SIZE,y+BUTTON_SIZE,
                              fill=LIGHTOFFON[OFF]))
    #Add other items
    self.codeText=TK.StringVar()
    self.codeText.trace("w", self.changedCode)
    self.generateCode()
    code=TK.Entry(parent,textvariable=self.codeText,
                  justify=TK.CENTER,width=TEXT_WIDTH)
    code.pack()
    #Bind to canvas not tk (only respond to lights)
    self.canvas.bind('&lt;Button-1&gt;', self.mouseClick)
  
  def mouseClick(self,event):
    itemsClicked=self.canvas.find_overlapping(event.x,
                             event.y,event.x+1,event.y+1)
    for item in itemsClicked:
      self.toggleLight(item)

  def setLight(self,num):
    state=isBitSet(self.lightStatus,num)
    self.canvas.itemconfig(self.light[num],
                           fill=LIGHTOFFON[state])
    
  def toggleLight(self,num):
    if num != 0:
      self.lightStatus=toggleBit(self.lightStatus,num-1)
      self.setLight(num-1)
      self.generateCode()

  def generateCode(self):
    self.codeText.set("0x%016x"%self.lightStatus)

  def changedCode(self,*args):
    updated=False
    try:
      codeValue=int(self.codeText.get(),16)
      if(codeValue&gt;MAX_VALUE):
        codeValue=codeValue&gt;&gt;4
      self.updateLight(codeValue)
      updated=True
    except:
      self.generateCode()
      updated=False
    return updated

  def updateLight(self,lightsetting):
    self.lightStatus=lightsetting
    for num in range(NUM_LIGHTS):
      self.setLight(num)
    self.generateCode()
    self.updateHardware()

  def updateHardware(self):
    sendBytes=self.lightStatus.to_bytes(NUM_BUTTON,
                                        byteorder='big')
    print(sendBytes)
    for idx,row in enumerate(MC.MAX7219_DIGIT):
      response = self.matrix.sendCmd(row,sendBytes[idx])
      print(response)

def main():
  global root
  root=TK.Tk()
  root.title("Matrix GUI")
  myMatrixHW=MC.matrix(DEBUG)
  myMatrixGUI=matrixGUI(root,myMatrixHW)
  TK.mainloop()
    
if __name__ == '__main__':
    main()
#End</pre></div><p>The <a class="indexterm" id="id911"/>Matrix GUI allows<a class="indexterm" id="id912"/> us to switch each of the LEDs on/off by clicking on each of the squares (or by directly entering the hexadecimal value) to create the required pattern.</p><div class="mediaobject"><img alt="How to do it…" src="graphics/6623OT_10_17.jpg"/><div class="caption"><p>The Matrix GUI to control the 8 x 8 LED matrix</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec218"/>How it works...</h3></div></div></div><p>Initially, we defined addresses for each of the control registers used by the MAX7219 device. View the <a class="indexterm" id="id913"/>datasheet at  for more information.</p><p>We created a class called <code class="literal">matrix</code> that will allow us to control the module. The <code class="literal">__init__()</code> function sets up the SPI of the Raspberry Pi (using <code class="literal">SPI_CS</code> as pin 26 CS1 and <code class="literal">SPI_SPEED</code> as 100 kHz).</p><p>The key function in our <code class="literal">matrix</code> class is the <code class="literal">sendCmd()</code> function; it uses <code class="literal">wiringpi.wiringPiSPIDataRW(SPI_CS,buff)</code> to send <code class="literal">buffer</code> (which is the raw byte data that we want to send) over the SPI bus (while also setting the <code class="literal">SPI_CS</code> pin low when the transfer occurs). Each command consists of two bytes: the first specifies the address of the<a class="indexterm" id="id914"/> register, and the <a class="indexterm" id="id915"/>second sets the data that needs to be put into it. To display a row of lights, we send the address of one of the <code class="literal">ROW</code> registers (<code class="literal">MC.MAX7219_DIGIT</code>) and the bit-pattern we want to display (as a byte).</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note98"/>Note</h3><p>After the <code class="literal">wiringpi.wiringPiSPIDataRW()</code> function is called, <code class="literal">buffer</code> contains the result of whatever is received on the MISO pin (which is read simultaneously as the data is sent via the MOSI pin). If connected, this will be the output of the LED module (a delayed copy of the data that was sent). Refer to the following <span class="emphasis"><em>There's more…</em></span> section regarding daisy-chained SPI configurations to learn how the chip output can be used.</p></div></div><p>To initialize the MAX7219, we need to ensure that it is configured in the correct mode. First, we set the <span class="strong"><strong>Scan Limit</strong></span> field to <code class="literal">7</code> (which enables all the DIG0 - DIG7 outputs). Next, we disable the built-in digit decoding since we are using the raw output for the display (and don't want it to try to display digits). We also want to ensure that the <code class="literal">MAX7219_DISPLAYTEST</code> register is disabled (if enabled, it would turn on all the LEDs).</p><p>We ensure the display is cleared by calling our own <code class="literal">clear()</code> function, which sends <code class="literal">0</code> to each of the <code class="literal">MAX7219_DIGIT</code> registers to clear each of the rows. Finally, we use the <code class="literal">MAX7219_INTENSITY</code> register to set the brightness of the LEDs. The brightness is controlled using a PWM output to make the LEDs appear brighter or darker according to the brightness that is required.</p><p>Within the <code class="literal">main()</code> function, we perform a quick test to display the letter K on the grid by sending a set of 8 bytes (<code class="literal">0x0066763e1e366646</code>).</p><div class="mediaobject"><img alt="How it works..." src="graphics/6623OT_10_18.jpg"/><div class="caption"><p>Each 8 x 8 pattern consists of 8 bits in 8 bytes (one bit for each column, making each byte a row in the display)</p></div></div><p>The <code class="literal">matrixGUI</code> class creates a canvas object that is populated with a grid of rectangle objects to <a class="indexterm" id="id916"/>represent<a class="indexterm" id="id917"/> the 8 x 8 grid of LEDs we want to control (these are kept in <code class="literal">self.light</code>). We also add a text entry box to display the resulting bytes that we will send to the LED matrix module. We then bind the <code class="literal">&lt;Button-1&gt;</code> mouse event to the canvas so that <code class="literal">mouseClick</code> is called whenever a mouse click occurs within the area of the canvas.</p><p>We attach a function called <code class="literal">changedCode()</code> to the <code class="literal">codeText</code> variable using <code class="literal">trace</code>, a special Python function, which allows us to monitor specific variables or functions. If we use the <code class="literal">'w'</code> value with the <code class="literal">trace</code> function, the Python system will call the callback function whenever the value is written to.</p><p>When the <code class="literal">mouseClick()</code> function is called, we use the <code class="literal">event.x</code> and <code class="literal">event.y</code> coordinates to identify the object that is located there. If an item is detected, then the ID of the item is used (via <code class="literal">toggleLight()</code>) to toggle the corresponding bit in the <code class="literal">self.lightStatus</code> value, and the color of the light in the display changes accordingly (via <code class="literal">setLight()</code>). The <code class="literal">codeText</code> variable is also updated with the new hexadecimal representation of the <code class="literal">lightStatus</code> value.</p><p>The <code class="literal">changeCode()</code> function allows us to use the <code class="literal">codeText</code> variable and translate it into an integer. This allows us to check whether it is a valid value. Since it is possible to enter text here freely, we must validate it. If we are unable to convert it to an integer, the <code class="literal">codeValue</code> text is refreshed using the <code class="literal">lightStatus</code> value. Otherwise, we check if it is too large, in which case we perform a bit-shift by four to divide it by 16 until it is within a valid range. We update the <code class="literal">lightStatus</code> value, the GUI lights, the <code class="literal">codeText</code> variable, and also <a class="indexterm" id="id918"/>the hardware (by calling <code class="literal">updateHardware()</code>).</p><p>The <code class="literal">updateHardware()</code> function makes use of the <code class="literal">myMatrixHW</code> object that was created using<a class="indexterm" id="id919"/> the <code class="literal">MC.matrix</code> class. We send the bytes that we want to display to the matrix hardware one byte at a time (along with the corresponding <code class="literal">MAX7219_DIGIT</code> value to specify the row).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec219"/>There's more...</h3></div></div></div><p>The SPI bus allows us to control multiple devices on the same bus by using the Chip Enable signal. Some devices, such as the MAX7219, also allow what is known as a daisy-chain SPI configuration.</p><div class="section" title="Daisy-chain SPI configuration"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec91"/>Daisy-chain SPI configuration</h4></div></div></div><p>You may have <a class="indexterm" id="id920"/>noticed that<a class="indexterm" id="id921"/> the <code class="literal">matrix</code> class also returns a byte when we send the data on the MOSI line. This is the data output from the MAX7219 controller on the DOUT connection. The MAX7219 controller actually passes all the DIN data through to DOUT, which is one set of instructions behind the DIN data. In this way, the MAX7219 can be daisy-chained (with each DOUT feeding into the next DIN). By keeping the CE signal low, multiple controllers can be loaded with data by being passed though one another. The data is ignored while CE is set to low, the outputs will only be changed when we set it high again. In this way, you can clock in all the data for each of the modules in the chain and then set CE to high to update them:</p><div class="mediaobject"><img alt="Daisy-chain SPI configuration" src="graphics/6623OT_10_19.jpg"/><div class="caption"><p>The daisy-chain SPI configuration</p></div></div><p>We need to do this for each row that we wish to update (or use <code class="literal">MAX7219_NOOP</code> if we want to keep<a class="indexterm" id="id922"/> the current row the same). This is known as a daisy-chain SPI configuration, supported by some <a class="indexterm" id="id923"/>SPI devices, where data is passed through each device on the SPI bus to the next one, which allows the use of three bus control signals for multiple devices.</p></div></div></div><div class="section" title="Communicating using a serial interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl1sec78"/>Communicating using a serial interface</h2></div></div></div><p>Traditionally, serial protocols such as RS232 are a common way to connect devices such as printers and scanners as well as joysticks and mouse devices to computers. Now, despite being <a class="indexterm" id="id924"/>superseded by USB, many peripherals still make use of this protocol for internal communication between components, to transfer data, and to update firmware. For electronics hobbyists, RS232 is a very useful protocol for debugging and controlling other devices while avoiding the complexities of USB.</p><p>The two scripts in this example allow for the control of the GPIO pins to illustrate how we can remotely control the Raspberry Pi through the serial port. The serial port could be connected to a PC, another Raspberry Pi, or even an embedded microcontroller (such as Arduino, PIC, or similar).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec220"/>Getting ready</h3></div></div></div><p>The easiest way to connect to the Raspberry Pi via a serial protocol will depend on whether your computer has a built-in serial port or not. The serial connection, software, and test setup are described in the following three steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create an RS232 serial connection between your computer and the Raspberry Pi. For this, you need one of the following setups:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If your computer has a built-in serial port available, you can use a Null-Modem cable with an RS232 to USB adaptor to connect to the Raspberry Pi:<div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_20.jpg"/><div class="caption"><p>USB for an RS232 adaptor</p></div></div><p>A Null-Modem is a serial cable/adaptor that has the TX and RX wires crossed over so that one side is connected to the TX pin of the serial port, whereas the other side is connected to the RX pin:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_21.jpg"/><div class="caption"><p>A PC serial port connected to the Raspberry Pi via a Null-Modem cable and an RS232 to USB adaptor</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note99"/>Note</h3><p>A list <a class="indexterm" id="id925"/>of supported USB to RS232 devices<a class="indexterm" id="id926"/> is available at the following link: <a class="ulink" href="http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters">http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters</a>
</p><p>Refer to the <span class="emphasis"><em>There's more…</em></span> section for details on how to set them up.</p><p>If you do not have a serial port built into your computer, you can use another USB to RS232 adaptor to connect to the PC/laptop, converting the RS232 to the more common USB connection.</p><p>If you do not have any available USB ports on the Raspberry Pi, you can use the GPIO serial pins directly with either a Serial Console Cable or a Bluetooth serial module (refer to the <span class="emphasis"><em>There's more…</em></span> section for details). Both of these will require some additional setup.</p><p>For all cases, you can use an RS232 loopback to confirm that everything is working and set up correctly (again, refer to the <span class="emphasis"><em>There's more…</em></span> section).</p></div></div></li></ul></div></li><li class="listitem">Next, prepare<a class="indexterm" id="id927"/> the software you need for this example.<p>You will need to install pySerial so we can use the serial port with Python</p></li><li class="listitem">Install pySerial <a class="indexterm" id="id928"/>with the following command (you will also need PIP installed; refer to <a class="link" href="ch03.html" title="Chapter 3. Using Python for Automation and Productivity">Chapter 3</a>, <span class="emphasis"><em>Using Python for Automation and Productivity</em></span>, for details):<div class="informalexample"><pre class="programlisting">sudo pip-3.2 install pyserial</pre></div><p>Refer to<a class="indexterm" id="id929"/> the <code class="literal">pySerial</code> site for further documentation: <a class="ulink" href="https://pyserial.readthedocs.io/en/latest/">https://pyserial.readthedocs.io/en/latest/</a>.</p><p>In order to demonstrate the RS232 serial control, you will require some example hardware attached to the Raspberry Pi's GPIO pins.</p><p>The <code class="literal">serialMenu.py</code> script allows the GPIO pins to be controlled through commands sent through the serial port. To fully test this, you can connect suitable output devices (such as LEDs) to each of the GPIO pins. You can ensure that the total current is kept low using 470 ohm resistors for each of the LEDs so that the maximum GPIO current that the Raspberry Pi can supply is not exceeded:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_22.jpg"/><div class="caption"><p>A test circuit to test the GPIO output via serial control</p></div></div></li></ol></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec221"/>How to do it...</h3></div></div></div><p>Create <a class="indexterm" id="id930"/>the following <code class="literal">serialControl.py</code> script:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
#serialControl.py
import serial
import time

#Serial Port settings
SERNAME="/dev/ttyUSB0"
#default setting is 9600,8,N,1
IDLE=0; SEND=1; RECEIVE=1

def b2s(message):
  '''Byte to String'''
  return bytes.decode(message)
def s2b(message):
  '''String to Byte'''
  return bytearray(message,"ascii")

class serPort():
  def __init__(self,serName="/dev/ttyAMA0"):
    self.ser = serial.Serial(serName)
    print (self.ser.name)
    print (self.ser)
    self.state=IDLE
  def __enter__(self):
    return self
  def send(self,message):
    if self.state==IDLE and self.ser.isOpen():
      self.state=SEND
      self.ser.write(s2b(message))
      self.state=IDLE

  def receive(self, chars=1, timeout=5, echo=True,
              terminate="\r"):
    message=""
    if self.state==IDLE and self.ser.isOpen():
      self.state=RECEIVE
      self.ser.timeout=timeout
      while self.state==RECEIVE:
        echovalue=""
        while self.ser.inWaiting() &gt; 0:
          echovalue += b2s(self.ser.read(chars))
        if echo==True:
          self.ser.write(s2b(echovalue))
        message+=echovalue
        if terminate in message:
          self.state=IDLE
    return message
  def __exit__(self,type,value,traceback):
    self.ser.close()      

def main():
  try:
    with serPort(serName=SERNAME) as mySerialPort:
      mySerialPort.send("Send some data to me!\r\n")
      while True:
        print ("Waiting for input:")
        print (mySerialPort.receive())
  except OSError:
    print ("Check selected port is valid: %s" %serName)
  except KeyboardInterrupt:
    print ("Finished")

if __name__=="__main__":
  main()
#End    </pre></div><p>Ensure that <a class="indexterm" id="id931"/>the <code class="literal">serName</code> element is correct for the serial port we want to use (such as <code class="literal">/dev/ttyAMA0</code> for the GPIO pins or <code class="literal">/dev/ttyUSB0</code> for a USB RS232 adaptor).</p><p>Connect the other end to a serial port on your laptop or computer (the serial port can be another USB to RS232 adaptor).</p><p>Monitor the<a class="indexterm" id="id932"/> serial port on your computer using a serial program such as HyperTerminal or RealTerm () for Windows or Serial Tools for OS X. You will need to ensure that you have the correct COM port set and a baud rate of 9600 bps (<code class="literal">Parity=None</code>, <code class="literal">Data Bits=8</code>, <code class="literal">Stop Bits=1</code>, and <code class="literal">Hardware Flow Control=None</code>).</p><p>The script will send a request for data from the user and wait for a response.</p><p>To send data to the Raspberry Pi, write some text on the other computer and press <span class="emphasis"><em>Enter</em></span> to send it over to the Raspberry Pi.</p><p>You will see output similar to the following on the Raspberry Pi terminal:</p><div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_23.jpg"/><div class="caption"><p>The text "Switch on LED 1" has been sent via a USB to RS232 cable from a connected computer</p></div></div><p>You will also see output similar to the following on the serial monitoring program:</p><div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_24.jpg"/><div class="caption"><p>RealTerm displaying typical output from the connected serial port</p></div></div><p>Press <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> on the Raspberry Pi to stop the script.</p><p>Now, create <a class="indexterm" id="id933"/>a GPIO control menu. Create <code class="literal">serialMenu.py</code>:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
#serialMenu.py
import time
import RPi.GPIO as GPIO
import serialControl as SC
SERNAME = "/dev/ttyUSB0"
running=True

CMD=0;PIN=1;STATE=2;OFF=0;ON=1
GPIO_PINS=[7,11,12,13,15,16,18,22]
GPIO_STATE=["OFF","ON"]
EXIT="EXIT"

def gpioSetup():
  GPIO.setmode(GPIO.BOARD)
  for pin in GPIO_PINS:
    GPIO.setup(pin,GPIO.OUT)

def handleCmd(cmd):
  global running
  commands=cmd.upper()
  commands=commands.split()
  valid=False
  print ("Received: "+ str(commands))
  if len(commands)==3:
    if commands[CMD]=="GPIO":
      for pin in GPIO_PINS:
        if str(pin)==commands[PIN]:
          print ("GPIO pin is valid")
          if GPIO_STATE[OFF]==commands[STATE]:
            print ("Switch GPIO %s %s"% (commands[PIN],
                                         commands[STATE]))
            GPIO.output(pin,OFF)
            valid=True
          elif GPIO_STATE[ON]==commands[STATE]:
            print ("Switch GPIO %s %s"% (commands[PIN],
                                         commands[STATE]))
            GPIO.output(pin,ON)
            valid=True
  elif commands[CMD]==EXIT:
    print("Exit")
    valid=True
    running=False
  if valid==False:
    print ("Received command is invalid")
    response="  Invalid:GPIO Pin#(%s) %s\r\n"% (
                      str(GPIO_PINS), str(GPIO_STATE))
  else:
    response="  OK\r\n"
  return (response)

def main():
  try:
    gpioSetup()
    with SC.serPort(serName=SERNAME) as mySerialPort:
      mySerialPort.send("\r\n")
      mySerialPort.send("  GPIO Serial Control\r\n")
      mySerialPort.send("  -------------------\r\n")
      mySerialPort.send("  CMD PIN STATE "+
                        "[GPIO Pin# ON]\r\n")
      while running==True:
        print ("Waiting for command...")
        mySerialPort.send("&gt;&gt;")
        cmd = mySerialPort.receive(terminate="\r\n")
        response=handleCmd(cmd)
        mySerialPort.send(response)
      mySerialPort.send("  Finished!\r\n")
  except OSError:
    print ("Check selected port is valid: %s" %serName)
  except KeyboardInterrupt:
    print ("Finished")
  finally:
    GPIO.cleanup()

main()
#End</pre></div><p>When you <a class="indexterm" id="id934"/>run the script (<code class="literal">sudo python3 serialMenu.py</code>), type the control messages within the serial monitoring program:</p><div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_25.jpg"/><div class="caption"><p>The GPIO Serial Control menu</p></div></div><p>The terminal output on the Raspberry Pi will be similar to the following screenshot, and the LEDs should respond accordingly:</p><div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_26.jpg"/><div class="caption"><p>The GPIO Serial Control menu</p></div></div><p>The<a class="indexterm" id="id935"/> Raspberry Pi validates the commands received from the serial connection and switches the LEDs connected to the GPIO pins 7 and 11 on and then off.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec222"/>How it works...</h3></div></div></div><p>The first script, <code class="literal">serialControl.py</code>, provides us with a <code class="literal">serPort</code> class. We define the class with the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">__init__(self,serName="/dev/ttyAMA0")</code>: This function will create a new serial device using <code class="literal">serName</code>—the default of <code class="literal">"/dev/ttyAMA0</code>" is the ID for the GPIO serial pins (see the <span class="emphasis"><em>There's more...</em></span> section). After it is initialized, information about the device is displayed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">__enter__(self)</code>: This is a dummy function that allows us to use the <code class="literal">with…as</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">send(self,message)</code>: This is used to check that the serial port is open and not in use; if so, it will then send a message (after converting it to raw bytes using the <code class="literal">s2b()</code> function).</li><li class="listitem" style="list-style-type: disc"><code class="literal">receive(self, chars=1, echo=True, terminate="\r")</code>: After checking whether the serial port is open and not in use, this function then waits for data through the serial port. The function will collect data until the terminate characters are detected, and then the full message is returned.</li><li class="listitem" style="list-style-type: disc"><code class="literal">__exit__(self,type,value,traceback)</code>: This function is called when the <code class="literal">serPort</code> object is no longer required by the <code class="literal">with…as</code> method, so we can close the port at this point.</li></ul></div><p>The <code class="literal">main()</code> function in the script performs a quick test of the class by sending a prompt for data<a class="indexterm" id="id936"/> through the serial port to a connected computer and then waiting for input that will be followed by the terminate character(s).</p><p>The next script, <code class="literal">serialMenu.py</code>, allows us to make use of the <code class="literal">serPort</code> class.</p><p>The <code class="literal">main()</code> function sets up the GPIO pins as outputs (via <code class="literal">gpioSetup()</code>), creates a new <code class="literal">serPort</code> object, and finally, waits for commands through the serial port. Whenever a new command is received, the <code class="literal">handleCmd()</code> function is used to parse the message to ensure that it is correct before acting on it.</p><p>The script will switch a particular GPIO pin on or off as commanded through the serial port using the <code class="literal">GPIO</code> command keyword. We could add any number of command keywords and control (or read) whatever device (or devices) we attached to the Raspberry Pi. We now have a very effective way to control the Raspberry Pi using any devices connected via a serial link.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec223"/>There's more...</h3></div></div></div><p>In addition to the serial transmit and receive, the RS232 serial standard includes several other control signals. To test it, you can use a serial loopback to confirm if the serial ports are set up correctly.</p><div class="section" title="Configuring a USB to RS232 device for the Raspberry Pi"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec92"/>Configuring a USB to RS232 device for the Raspberry Pi</h4></div></div></div><p>Once you <a class="indexterm" id="id937"/>have connected the USB to RS232<a class="indexterm" id="id938"/> device to the Raspberry Pi, check to <a class="indexterm" id="id939"/>see if a new serial <a class="indexterm" id="id940"/>device is listed by typing the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dmesg | grep tty</strong></span>
</pre></div><p>The <code class="literal">dmesg</code> command lists events that occur on the system; using <code class="literal">grep</code>, we can filter any messages that mention <code class="literal">tty</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[ 2409.195407] usb 1-1.2: pl2303 converter now attached to ttyUSB0</strong></span>
</pre></div><p>This shows that a PL2303-based USB-RS232 device was attached (2,409 seconds after startup) and allocated the <code class="literal">ttyUSB0</code> identity. You will see that a new serial device has been added <a class="indexterm" id="id941"/>within the <code class="literal">/dev/</code> directory (usually <code class="literal">/dev/ttyUSB0</code> or something similar).</p><p>If the device<a class="indexterm" id="id942"/> has not been detected, you can try steps similar to<a class="indexterm" id="id943"/> the ones used in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with a Raspberry Pi Computer">Chapter 1</a>, <span class="emphasis"><em>Getting Started with a Raspberry Pi Computer</em></span>, to locate and install suitable drivers (if they <a class="indexterm" id="id944"/>are available).</p></div><div class="section" title="RS232 signals and connections"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec93"/>RS232 signals and connections</h4></div></div></div><p>The RS232 serial standard has lots of variants and includes six additional control signals.</p><p>The <a class="indexterm" id="id945"/>Raspberry Pi GPIO serial drivers (and the Bluetooth TTL module used in the following example) only support RX and TX signals. If you require <a class="indexterm" id="id946"/>support for other signals, such as DTR that is often used for a reset prior to the programming of AVR/Arduino devices, then alternative GPIO serial drivers may be needed to set these signals via other GPIO pins. Most RS232 to USB adaptors should support the standard signals; however, ensure that anything you connect is able to handle standard RS232 voltages:</p><div class="mediaobject"><img alt="RS232 signals and connections" src="graphics/6623OT_10_27.jpg"/><div class="caption"><p>The RS232 9-Way D Connector pin-out and signals</p></div></div><p>For more details on the RS232 serial protocol and to know how these signals are used, visit the<a class="indexterm" id="id947"/> following link <a class="ulink" href="http://en.wikipedia.org/wiki/Serial_port">http://en.wikipedia.org/wiki/Serial_port</a>:</p></div><div class="section" title="Using the GPIO built-in serial pins"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec94"/>Using the GPIO built-in serial pins</h4></div></div></div><p>Standard<a class="indexterm" id="id948"/> RS232 signals can range from -15V to +15V, so you must never directly connect any RS232 device to the GPIO serial<a class="indexterm" id="id949"/> pins. You must use an RS232 to TTL voltage-level converter (such as a MAX232 chip) or a device that uses TTL-level signals (such as another microcontroller or a TTL serial console cable):</p><div class="mediaobject"><img alt="Using the GPIO built-in serial pins" src="graphics/6623OT_10_28.jpg"/><div class="caption"><p>A USB to TTL serial console cable</p></div></div><p>The<a class="indexterm" id="id950"/> Raspberry Pi has TTL-level serial pins on<a class="indexterm" id="id951"/> the GPIO header that allow the connection of a TTL serial USB cable. The wires will connect to the Raspberry Pi GPIO pins, and the USB will plug in to your computer and be detected like a standard RS232 to USB cable.</p><div class="mediaobject"><img alt="Using the GPIO built-in serial pins" src="graphics/6623OT_10_29.jpg"/><div class="caption"><p>Connection of a USB to TTL serial console cable to the Raspberry Pi GPIO</p></div></div><p>It is possible to provide power from the USB port to the 5V pin; however, this will bypass the built-in polyfuse, so it is not recommended for general use (just leave the 5V wire disconnected and power as normal through the micro-USB).</p><p>By default, these pins are set up to allow remote terminal access, allowing you to connect to the COM port via PuTTY and create a serial SSH session.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note100"/>Note</h3><p>A serial SSH session can be helpful if you want to use the Raspberry Pi without a display attached to it.</p><p>However, a serial SSH session is limited to text-only terminal access since it does not support X10 Forwarding, as used in the <span class="emphasis"><em>Connecting remotely to Raspberry Pi over the network using SSH (and X11 Forwarding)</em></span> section of <a class="link" href="ch01.html" title="Chapter 1. Getting Started with a Raspberry Pi Computer">Chapter 1</a>, <span class="emphasis"><em>Getting Started with a Raspberry Pi Computer</em></span>.</p></div></div><p>In order<a class="indexterm" id="id952"/> to use it as a standard serial <a class="indexterm" id="id953"/>connection, we have to disable the serial console so it is available for us to use.</p><p>First, we need to edit <code class="literal">/boot/cmdline.txt</code> to remove the first <code class="literal">console</code> and <code class="literal">kgboc</code> options (do not remove the other <code class="literal">console=tty1</code> option, which is the default terminal when you switch on):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo nano /boot/cmdline.txt</strong></span>
<span class="strong"><strong>dwc_otg.lpm_enable=0 console=ttyAMA0,115200 kgdboc=ttyAMA0,115200 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait</strong></span>
</pre></div><p>The previous command line becomes the following (ensure that this is still a single command line):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dwc_otg.lpm_enable=0 console=tty1 root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait</strong></span>
</pre></div><p>We also have to remove the task that runs the <code class="literal">getty</code> command (the program that handles the text terminal for the serial connection) by commenting it out with <code class="literal">#</code>. This is set in <code class="literal">/etc/inittab</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo nano /etc/inittab</strong></span>
<span class="strong"><strong>T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100</strong></span>
</pre></div><p>The previous command line becomes the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>#T0:23:respawn:/sbin/getty -L ttyAMA0 115200 vt100</strong></span>
</pre></div><p>To reference the GPIO serial port in our script, we use its name, <code class="literal">/dev/ttyAMA0</code>.</p></div><div class="section" title="The RS232 loopback"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec95"/>The RS232 loopback</h4></div></div></div><p>You can <a class="indexterm" id="id954"/>check whether the serial port connections <a class="indexterm" id="id955"/>are working correctly using a serial loopback.</p><p>A simple loopback consists of connecting RXD and TXD together. These are pins 8 and 10 on the Raspberry Pi GPIO header, or pins 2 and 3 on the standard RS232 D9 connector on the USB-RS232 adaptor:</p><div class="mediaobject"><img alt="The RS232 loopback" src="graphics/6623OT_10_30.jpg"/><div class="caption"><p>Serial loopback connections to test the Raspberry Pi GPIO (left) and RS232 9-Way D Connector (right)</p></div></div><p>An RS232 full <a class="indexterm" id="id956"/>loopback cable also connects <a class="indexterm" id="id957"/>pin 4 (DTR) and pin 6 (DSR) as well as pin 7 (RTS) and pin 8 (CTS) on the RS232 adaptor. However, this is not required for most situations, unless these signals are used. By default, no pins are allocated on the Raspberry Pi specifically for these additional signals.</p><div class="mediaobject"><img alt="The RS232 loopback" src="graphics/6623OT_10_31.jpg"/><div class="caption"><p>RS232 full loopback</p></div></div><p>Create the following <code class="literal">serialTest.py</code> script:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
#serialTest.py
import serial
import time

WAITTIME=1
serName="/dev/ttyAMA0"
ser = serial.Serial(serName)
print (ser.name)
print (ser)
if ser.isOpen():
  try:
    print("For Serial Loopback - connect GPIO Pin8 and Pin10")
    print("[Type Message and Press Enter to continue]")
    print("#:")
    command=input()
    ser.write(bytearray(command+"\r\n","ascii"))
    time.sleep(WAITTIME)
    out=""
    while ser.inWaiting() &gt; 0:
      out += bytes.decode(ser.read(1))
    if out != "":
      print ("&gt;&gt;" + out)
    else:
      print ("No data Received")
  except KeyboardInterrupt:
    ser.close()
#End</pre></div><p>When a <a class="indexterm" id="id958"/>loopback is connected, you will observe that the<a class="indexterm" id="id959"/> message is echoed back to the screen (when removed, <code class="literal">No data Received</code> will be displayed):</p><div class="mediaobject"><img alt="The RS232 loopback" src="graphics/6623OT_10_32.jpg"/><div class="caption"><p>An RS232 loopback test on GPIO serial pins</p></div></div><p>If we require non-default settings, they can be defined when the serial port is initialized (the pySerial documentation at <a class="ulink" href="https://pyserial.readthedocs.io/en/latest/">https://pyserial.readthedocs.io/en/latest/</a> provides full details of all the options), as<a class="indexterm" id="id960"/> shown in the following <a class="indexterm" id="id961"/>code:</p><div class="informalexample"><pre class="programlisting">ser = serial.Serial(port=serName, baudrate= 115200, 
    timeout=1, parity=serial.PARITY_ODD,
    stopbits=serial.STOPBITS_TWO,
    bytesize=serial.SEVENBITS)</pre></div></div></div></div><div class="section" title="Controlling the Raspberry Pi over Bluetooth"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl1sec79"/>Controlling the Raspberry Pi over Bluetooth</h2></div></div></div><p>Serial data <a class="indexterm" id="id962"/>can also be sent through Bluetooth by <a class="indexterm" id="id963"/>connecting a HC-05 Bluetooth module that supports the <span class="strong"><strong>Serial Port Profile</strong></span> (<span class="strong"><strong>SPP</strong></span>) to the GPIO serial RX/TX pins. This allows the <a class="indexterm" id="id964"/>serial connection to become wireless, which allows Android tablets or smartphones to be used to control things and read data from the Raspberry Pi:</p><div class="mediaobject"><img alt="Controlling the Raspberry Pi over Bluetooth" src="graphics/6623OT_10_33.jpg"/><div class="caption"><p>The HC-05 Bluetooth module for the TLL serial</p></div></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note101"/>Note</h3><p>While it is possible to achieve a similar result using a USB Bluetooth dongle, additional configuration would be required depending on the particular dongle used. The TTL Bluetooth module provides a drop-in replacement for a physical cable, requiring very little additional configuration.</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec224"/>Getting ready</h3></div></div></div><p>Ensure that the serial console has been disabled (see the previous <span class="emphasis"><em>There's more…</em></span> section).</p><p>The module should be connected using the following pins:</p><div class="mediaobject"><img alt="Getting ready" src="graphics/6623OT_10_34.jpg"/><div class="caption"><p>Connection to a Bluetooth module for the TLL serial</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec225"/>How to do it...</h3></div></div></div><p>With the <a class="indexterm" id="id965"/>Bluetooth module configured and connected, we can pair the module with a laptop or smartphone to send and receive commands<a class="indexterm" id="id966"/> wirelessly. Bluetooth SPP Pro provides an easy way to use a serial connection over Bluetooth to control or monitor the Raspberry Pi for Android devices.</p><p>Alternatively, you may be able to set up a Bluetooth COM port on your PC/laptop and use it in the same way as the previous wired example:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When the device is connected initially, the LED flashes quickly to indicate that it is waiting to be paired. Enable Bluetooth on your device and select the <span class="strong"><strong>HC-05</strong></span> device:<div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_35.jpg"/><div class="caption"><p>The HC-05 Bluetooth module viewable in Bluetooth SPP Pro</p></div></div></li><li class="listitem">Click on the <span class="strong"><strong>Pair</strong></span> button to begin the pairing process and enter the device's <span class="strong"><strong>PIN</strong></span> (the default is <code class="literal">1234</code>):<div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_36.jpg"/><div class="caption"><p>Pair the Bluetooth device with the PIN code (1234)</p></div></div></li><li class="listitem">If the<a class="indexterm" id="id967"/> pairing was successful, you<a class="indexterm" id="id968"/> will be able to connect with the device and send and receive messages to and from the Raspberry Pi:<div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_37.jpg"/><div class="caption"><p>Connect to the device and select the control method</p></div></div></li><li class="listitem">In <span class="strong"><strong>Keyboard mode</strong></span>, you can define actions for each of the buttons to send suitable commands when pressed.<p>For example, <span class="strong"><strong>Pin12 ON</strong></span> can be set to send <code class="literal">gpio 12 on</code>, and <span class="strong"><strong>Pin12 OFF</strong></span> can be set to send <code class="literal">gpio 12 off</code>.</p></li><li class="listitem">Ensure that you set the end flag to <code class="literal">\r\n</code> via the menu options.</li><li class="listitem">Ensure<a class="indexterm" id="id969"/> that <code class="literal">menuSerial.py</code> is <a class="indexterm" id="id970"/>set to use the GPIO serial connection:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>serName="/dev/ttyAMA0"</strong></span>
</pre></div></li><li class="listitem">Run the <code class="literal">menuSerial.py</code> script (with the LEDs attached):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo python3 menuSerial.py</strong></span>
</pre></div></li><li class="listitem">Check that the Bluetooth serial app displays the <code class="literal">GPIO Serial Control</code> menu as shown in the following screenshot:<div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_38.jpg"/><div class="caption"><p>GPIO control over Bluetooth</p></div></div></li></ol></div><p>We can see from the output in the following screenshot that the commands have been received and the LED connected to pin 12 has been switched on and off as required.</p><div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_39.jpg"/><div class="caption"><p>The Raspberry Pi receiving GPIO control over Bluetooth</p></div></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec226"/>How it works...</h3></div></div></div><p>By default, the <a class="indexterm" id="id971"/>Bluetooth module is set up to act like a <a class="indexterm" id="id972"/>TTL serial slave device, so we can simply plug it in to the GPIO RX and TX pins. Once the module is paired with a device, it will transfer the serial communication over the Bluetooth connection. This allows us to send commands and receive data via Bluetooth and control the Raspberry Pi using a smart phone or PC.</p><p>This means you can attach a second module to another device (such as an Arduino) that has TTL serial pins and control it using the Raspberry Pi (either by pairing it with another TTL Bluetooth module or suitably configuring a USB Bluetooth dongle). If the module is set up as a master device, then you will need to reconfigure it to act as a slave (see the <span class="emphasis"><em>There's more…</em></span> section).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec227"/>There's more...</h3></div></div></div><p>Now, let's understand how to configure the Bluetooth settings.</p><div class="section" title="Configuring Bluetooth module settings"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec96"/>Configuring Bluetooth module settings</h4></div></div></div><p>The Bluetooth <a class="indexterm" id="id973"/>module can be set in two different modes using the KEY pin.</p><p>In a normal operation, serial messages are sent over Bluetooth; however, if we need to change the settings of the Bluetooth module itself, we can do so by connecting the KEY pin to 3V3 and putting it into AT mode.</p><p>AT mode allows us to directly configure the module, allowing us to change the baud rate, the pairing code, the device name, or even set it up as a master/slave device.</p><p>You can use <code class="literal">miniterm</code>, which is part of pySerial, to send the required messages, as shown in the<a class="indexterm" id="id974"/> following code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python3 -m serial.tools.miniterm</strong></span>
</pre></div><p>The <code class="literal">miniterm</code> program, when started, will prompt for the port to use:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Enter port name: /dev/ttyAMA0</strong></span>
</pre></div><p>You can send the following commands (you will need to do this quickly, or paste them, as the module will time out if there is a gap and respond with an error):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AT</code>: This command should respond with <span class="strong"><strong>OK</strong></span>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AT+UART?</code>: This command will report the current settings as <code class="literal">UART=&lt;Param1&gt;,&lt;Param2&gt;,&lt;Param3&gt;</code>. The output of this command will be <span class="strong"><strong>OK</strong></span>.</li><li class="listitem" style="list-style-type: disc">To change the current settings, use <code class="literal">AT+UART=&lt;Param1&gt;,&lt;Param2&gt;,&lt;Param3&gt;</code>, that is, <code class="literal">AT+UART=19200,0,0</code>.<div class="mediaobject"><img alt="Configuring Bluetooth module settings" src="graphics/6623OT_10_40.jpg"/><div class="caption"><p>HC-05 AT mode AT+UART command parameters</p></div></div></li></ul></div><p>For details on how to configure modules as paired master and slave devices (for example, between two Raspberry Pi devices), Zak Kemble has written an excellent guide. It is available at<a class="indexterm" id="id975"/> the following link: <a class="ulink" href="http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/">http://blog.zakkemble.co.uk/getting-bluetooth-modules-talking-to-each-other/</a>.</p><p>For additional <a class="indexterm" id="id976"/>documentation on the HC-05 module, visit the following link: <a class="ulink" href="http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf">http://www.robotshop.com/media/files/pdf/rb-ite-12-bluetooth_hc05.pdf</a>.</p></div></div></div><div class="section" title="Controlling USB devices"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl1sec80"/>Controlling USB devices</h2></div></div></div><p>The <span class="strong"><strong>Universal Serial Bus</strong></span> (<span class="strong"><strong>USB</strong></span>) is used extensively by computers to provide additional peripherals <a class="indexterm" id="id977"/>and expansion through a common standard connection. We <a class="indexterm" id="id978"/>will use the <span class="strong"><strong>PyUSB</strong></span> Python library to <a class="indexterm" id="id979"/>send custom commands to connected devices over USB.</p><p>The following example controls a USB toy missile launcher, which in turn allows it to be controlled by our Python control panel. We see that the same principle can be applied to other USB devices, such as a robotic arm, using similar techniques, and the controls can be activated using a sensor connected to the Raspberry Pi GPIO:</p><div class="mediaobject"><img alt="Controlling USB devices" src="graphics/6623OT_10_41.jpg"/><div class="caption"><p>The USB Tenx Technology SAM missile launcher</p></div></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec228"/>Getting ready</h3></div></div></div><p>We will need to install PyUSB for Python 3 using <code class="literal">pip-3.2</code> as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo pip-3.2 install pyusb</strong></span>
</pre></div><p>You can test whether PyUSB has installed correctly by running the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>python3</strong></span>
<span class="strong"><strong>&gt; import usb</strong></span>
<span class="strong"><strong>&gt; help (usb)</strong></span>
<span class="strong"><strong>&gt; exit()</strong></span>
</pre></div><p>This should allow you to view the package information if it was installed correctly.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec229"/>How to do it...</h3></div></div></div><p>We will create<a class="indexterm" id="id980"/> the following <code class="literal">missileControl.py</code> script, which will include two classes and a default <code class="literal">main()</code> function to test it:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Import the required modules as follows:<div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
# missileControl.py
import time
import usb.core</pre></div></li><li class="listitem">Define the <code class="literal">SamMissile()</code> class, which provides the specific commands for the USB device, as follows:<div class="informalexample"><pre class="programlisting">class SamMissile():
  idVendor=0x1130
  idProduct=0x0202
  idName="Tenx Technology SAM Missile"
  # Protocol control bytes
  bmRequestType=0x21
  bmRequest=0x09
  wValue=0x02
  wIndex=0x01
  # Protocol command bytes
  INITA     = [ord('U'), ord('S'), ord('B'), ord('C'),
               0,  0,  4,  0]
  INITB     = [ord('U'), ord('S'), ord('B'), ord('C'),
               0, 64,  2,  0]
  CMDFILL   = [ 8,  8,
                0,  0,  0,  0,  0,  0,  0,  0,
                0,  0,  0,  0,  0,  0,  0,  0,
                0,  0,  0,  0,  0,  0,  0,  0,
                0,  0,  0,  0,  0,  0,  0,  0,
                0,  0,  0,  0,  0,  0,  0,  0,
                0,  0,  0,  0,  0,  0,  0,  0,
                0,  0,  0,  0,  0,  0,  0,  0]#48 zeros
  STOP      = [ 0,  0,  0,  0,  0,  0]
  LEFT      = [ 0,  1,  0,  0,  0,  0]
  RIGHT     = [ 0,  0,  1,  0,  0,  0]
  UP        = [ 0,  0,  0,  1,  0,  0]
  DOWN      = [ 0,  0,  0,  0,  1,  0]
  LEFTUP    = [ 0,  1,  0,  1,  0,  0]
  RIGHTUP   = [ 0,  0,  1,  1,  0,  0]
  LEFTDOWN  = [ 0,  1,  0,  0,  1,  0]
  RIGHTDOWN = [ 0,  0,  1,  0,  1,  0]
  FIRE      = [ 0,  0,  0,  0,  0,  1]
  def __init__(self):
    self.dev = usb.core.find(idVendor=self.idVendor,
                                idProduct=self.idProduct)
  def move(self,cmd,duration):
    print("Move:%s %d sec"% (cmd,duration))
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest,self.wValue,
                           self.wIndex, self.INITA)
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest,self.wValue,
                           self.wIndex, self.INITB)
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest, self.wValue,
                           self.wIndex, cmd+self.CMDFILL)
    time.sleep(duration)
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest, self.wValue,
                           self.wIndex, self.INITA)
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest, self.wValue,
                           self.wIndex, self.INITB)
    self.dev.ctrl_transfer(self.bmRequestType,
                      self.bmRequest, self.wValue,
                      self.wIndex, self.STOP+self.CMDFILL)</pre></div></li><li class="listitem">Define the <code class="literal">Missile()</code> class, which allows us to detect the USB device and provide <a class="indexterm" id="id981"/>command functions, as follows:<div class="informalexample"><pre class="programlisting">class Missile():
  def __init__(self):
    print("Initialize Missiles")
    self.usbDevice=SamMissile()
    
    if self.usbDevice.dev is not None:
      print("Device Initialized:" +
            " %s" % self.usbDevice.idName)
      #Detach the kernel driver if active
      if self.usbDevice.dev.is_kernel_driver_active(0):
        print("Detaching kernel driver 0")
        self.usbDevice.dev.detach_kernel_driver(0)
      if self.usbDevice.dev.is_kernel_driver_active(1):
        print("Detaching kernel driver 1")
        self.usbDevice.dev.detach_kernel_driver(1)
      self.usbDevice.dev.set_configuration()
    else:
      raise Exception("Missile device not found")
  def __enter__(self):
    return self
  def left(self,duration=1):
    self.usbDevice.move(self.usbDevice.LEFT,duration)
  def right(self,duration=1):
    self.usbDevice.move(self.usbDevice.RIGHT,duration)
  def up(self,duration=1):
    self.usbDevice.move(self.usbDevice.UP,duration)
  def down(self,duration=1):
    self.usbDevice.move(self.usbDevice.DOWN,duration)
  def fire(self,duration=1):
    self.usbDevice.move(self.usbDevice.FIRE,duration)
  def stop(self,duration=1):
    self.usbDevice.move(self.usbDevice.STOP,duration)
  def __exit__(self, type, value, traceback):
    print("Exit")</pre></div></li><li class="listitem">Finally, create <a class="indexterm" id="id982"/>a <code class="literal">main()</code> function, which provides a quick test of our <code class="literal">missileControl.py</code> module if the file is run directly, as follows:<div class="informalexample"><pre class="programlisting">def main():
  try:
    with Missile() as myMissile:
      myMissile.down()
      myMissile.up()
  except Exception as detail:

      time.sleep(2)
    print("Error: %s" % detail)
    
if __name__ == '__main__':
    main()
#End</pre></div></li></ol></div><p>When the script is run using the following command, you should see the missile launcher move downwards and then up again:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sudo python3 missileControl.py</strong></span>
</pre></div><p>To provide easy control of the device, create the following GUI:</p><div class="mediaobject"><img alt="How to do it..." src="graphics/6623OT_10_42.jpg"/><div class="caption"><p>The Missile Command GUI</p></div></div><p>Although<a class="indexterm" id="id983"/> simple commands have been used here, you could use a series of preset commands if desired.</p><p>Create the GUI for the <code class="literal">missileMenu.py</code> missile command:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/python3
#missileMenu.py
import tkinter as TK
import missileControl as MC

BTN_SIZE=10

def menuInit():
  btnLeft = TK.Button(root, text="Left",
                      command=sendLeft, width=BTN_SIZE)   
  btnRight = TK.Button(root, text="Right",
                       command=sendRight, width=BTN_SIZE)   
  btnUp = TK.Button(root, text="Up",
                    command=sendUp, width=BTN_SIZE)   
  btnDown = TK.Button(root, text="Down",
                      command=sendDown, width=BTN_SIZE)
  btnFire = TK.Button(root, text="Fire",command=sendFire,
                      width=BTN_SIZE, bg="red")
  btnLeft.grid(row=2,column=0)
  btnRight.grid(row=2,column=2)
  btnUp.grid(row=1,column=1)
  btnDown.grid(row=3,column=1)
  btnFire.grid(row=2,column=1)

def sendLeft():
  print("Left")
  myMissile.left()
       
def sendRight():
  print("Right")    
  myMissile.right()
       
def sendUp():
  print("Up")
  myMissile.up()
       
def sendDown():
  print("Down")
  myMissile.down()
       
def sendFire():
  print("Fire")
  myMissile.fire()
       

root = TK.Tk()
root.title("Missile Command")
prompt = "Select action"
label1 = TK.Label(root, text=prompt, width=len(prompt),
                  justify=TK.CENTER, bg='lightblue')
label1.grid(row=0,column=0,columnspan=3)
menuInit()
with MC.Missile() as myMissile:
  root.mainloop()
#End</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec230"/>How it works...</h3></div></div></div><p>The control script <a class="indexterm" id="id984"/>consists of two classes: one called <code class="literal">Missile</code> that provides a common interface for the control, and another called <code class="literal">SamMissile</code> that provides all the specific details of the particular USB device being used.</p><p>In order to drive a USB device, we need a lot of information about the device, such as its USB identification, its protocol, and the control messages it requires to be controlled.</p><p>The USB ID for the Tenx Technology SAM missile device is determined by the vendor ID (<code class="literal">0x1130</code>) and the product ID (<code class="literal">0x0202</code>). This is the same identification information you would see within <span class="strong"><strong>Device Manager</strong></span> in Windows. These IDs are usually registered with <a class="ulink" href="http://www.usb.org">www.usb.org</a>; therefore, each device should be unique. Again, you can use the <code class="literal">dmesg | grep usb</code> command to discover these.</p><p>We use the device IDs to find the USB device using <code class="literal">usb.core.find</code>; then, we can send messages using <code class="literal">ctrl_transfer()</code>.</p><p>The USB message has five parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Request type</strong></span> (<code class="literal">0x21</code>): This defines the type of the message request, such as the message direction (Host to Device), its type (Vendor), and the recipient (Interface)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Request</strong></span> (<code class="literal">0x09</code>): This is the set configuration</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Value</strong></span> (<code class="literal">0x02</code>): This is the configuration value</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Index</strong></span> (<code class="literal">0x01</code>): This is the command we want to send</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Data</strong></span>: This is the command we want to send (as described next)</li></ul></div><p>The <code class="literal">SamMissile</code> device requires the following commands to move:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It requires two initialization messages (<code class="literal">INITA</code> and <code class="literal">INITB</code>).</li><li class="listitem" style="list-style-type: disc">It also requires the control message. This consists of the <code class="literal">CMD</code>, which includes one of the control bytes that has been set to <code class="literal">1</code> for the required component. The <code class="literal">CMD</code> is then added to <code class="literal">CMDFILL</code> to complete the message.</li></ul></div><p>You will see<a class="indexterm" id="id985"/> that the other missile devices and the robot arm (see the following <span class="emphasis"><em>There's more…</em></span> section) have similar message structures.</p><p>For each device, we created the <code class="literal">__init__()</code> and <code class="literal">move()</code> functions and defined values for each of the valid commands, which the <code class="literal">missile</code> class will use whenever the <code class="literal">left()</code>, <code class="literal">right()</code>, <code class="literal">up()</code>, <code class="literal">down()</code>, <code class="literal">fire()</code>, and <code class="literal">stop()</code> functions are called.</p><p>For the control GUI for our missile launcher, we create a small Tkinter window with five buttons, each of which will send a command to the missile device.</p><p>We import <code class="literal">missileControl</code> and create a <code class="literal">missile</code> object called <code class="literal">myMissile</code> that will be controlled by each of the buttons.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl2sec231"/>There's more...</h3></div></div></div><p>The example only shows how to control one particular USB device; however, it is possible to extend this to support several types of missile devices and even other USB devices in general.</p><div class="section" title="Controlling similar missile-type devices"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec97"/>Controlling similar missile-type devices</h4></div></div></div><p>There are <a class="indexterm" id="id986"/>several variants of USB missile-type<a class="indexterm" id="id987"/> devices, each with their own USB IDs and USB commands. We can add support for these other devices by defining their own classes to handle them.</p><p>Use <code class="literal">lsusb -vv</code> to determine the vendor and product ID that matches your device.</p><p>For <code class="literal">Chesen Electronics/Dream Link</code>, we have to add the following code:</p><div class="informalexample"><pre class="programlisting">class ChesenMissile():
  idVendor=0x0a81
  idProduct=0x0701
  idName="Chesen Electronics/Dream Link"
  # Protocol control bytes
  bmRequestType=0x21
  bmRequest=0x09
  wValue=0x0200
  wIndex=0x00
  # Protocol command bytes
  DOWN    = [0x01]
  UP      = [0x02]
  LEFT    = [0x04]
  RIGHT   = [0x08]
  FIRE    = [0x10]
  STOP    = [0x20]
  def __init__(self):
    self.dev = usb.core.find(idVendor=self.idVendor,
                             idProduct=self.idProduct)
  def move(self,cmd,duration):
    print("Move:%s"%cmd)
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest,
                           self.wValue, self.wIndex, cmd)
    time.sleep(duration)
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest, self.wValue,
                           self.wIndex, self.STOP)</pre></div><p>For <code class="literal">Dream Cheeky Thunder</code>, we need the following code:</p><div class="informalexample"><pre class="programlisting">class ThunderMissile():
  idVendor=0x2123
  idProduct=0x1010
  idName="Dream Cheeky Thunder"
  # Protocol control bytes
  bmRequestType=0x21
  bmRequest=0x09
  wValue=0x00
  wIndex=0x00
  # Protocol command bytes
  CMDFILL = [0,0,0,0,0,0]
  DOWN    = [0x02,0x01]
  UP      = [0x02,0x02]
  LEFT    = [0x02,0x04]
  RIGHT   = [0x02,0x08]
  FIRE    = [0x02,0x10]
  STOP    = [0x02,0x20]
  def __init__(self):
    self.dev = usb.core.find(idVendor=self.idVendor,
                             idProduct=self.idProduct)
  def move(self,cmd,duration):
    print("Move:%s"%cmd)
    self.dev.ctrl_transfer(self.bmRequestType,
                           self.bmRequest, self.wValue,
                           self.wIndex, cmd+self.CMDFILL)
    time.sleep(duration)
    self.dev.ctrl_transfer(self.bmRequestType,
                      self.bmRequest, self.wValue,
                      self.wIndex, self.STOP+self.CMDFILL)</pre></div><p>Finally, adjust<a class="indexterm" id="id988"/> the script to use the required<a class="indexterm" id="id989"/> class as follows:</p><div class="informalexample"><pre class="programlisting">class Missile():
  def __init__(self):
    print("Initialize Missiles")
    self.usbDevice = ThunderMissile()</pre></div></div><div class="section" title="Robot arm"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec98"/>Robot arm</h4></div></div></div><p>Another device <a class="indexterm" id="id990"/>that can be controlled in a similar manner is<a class="indexterm" id="id991"/> the OWI Robotic Arm with a USB interface.</p><div class="mediaobject"><img alt="Robot arm" src="graphics/6623OT_10_43.jpg"/><div class="caption"><p>The OWI Robotic Arm with a USB interface (image courtesy of Chris Stagg)</p></div></div><p>This has featured in <span class="emphasis"><em>The MagPi</em></span> magazine several times, thanks to Stephen Richards' articles on <a class="indexterm" id="id992"/>Skutter; the USB control has been explained in detail in issue 3 (page 14) at <a class="ulink" href="https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14">https://issuu.com/themagpi/docs/the_magpi_issue_3_final/14</a>. It can also be found at <a class="ulink" href="https://www.raspberrypi.org/magpi/issues/3/">https://www.raspberrypi.org/magpi/issues/3/</a>.</p><p>The robotic arm <a class="indexterm" id="id993"/>can be controlled using the following <a class="indexterm" id="id994"/>class. Remember that you will also need to adjust the commands from <code class="literal">UP</code>, <code class="literal">DOWN</code>, and so on when calling the <code class="literal">move()</code> function, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">class OwiArm():
  idVendor=0x1267
  idProduct=0x0000
  idName="Owi Robot Arm"
  # Protocol control bytes
  bmRequestType=0x40
  bmRequest=0x06
  wValue=0x0100
  wIndex=0x00
  # Protocol command bytes
  BASE_CCW    = [0x00,0x01,0x00]
  BASE_CW     = [0x00,0x02,0x00]
  SHOLDER_UP  = [0x40,0x00,0x00]
  SHOLDER_DWN = [0x80,0x00,0x00]
  ELBOW_UP    = [0x10,0x00,0x00]
  ELBOW_DWN   = [0x20,0x00,0x00]
  WRIST_UP    = [0x04,0x00,0x00]
  WRIST_DOWN  = [0x08,0x00,0x00]
  GRIP_OPEN   = [0x02,0x00,0x00]
  GRIP_CLOSE  = [0x01,0x00,0x00]
  LIGHT_ON    = [0x00,0x00,0x01]
  LIGHT_OFF   = [0x00,0x00,0x00]
  STOP        = [0x00,0x00,0x00]</pre></div></div><div class="section" title="Taking USB control further"><div class="titlepage"><div><div><h4 class="title"><a id="ch10lvl3sec99"/>Taking USB control further </h4></div></div></div><p>The theory <a class="indexterm" id="id995"/>and method of control used for the USB missile device can be applied to very complex devices such as the Xbox 360's Kinect (a special 3D camera add-on for the Xbox game console) as well.</p><p>Adafruit's website has a very interesting tutorial written by Limor Fried (also known as Ladyada) on how<a class="indexterm" id="id996"/> to analyze and investigate USB commands; access it at <a class="ulink" href="http://learn.adafruit.com/hacking-the-kinect">http://learn.adafruit.com/hacking-the-kinect</a>.</p><p>This is well worth a look if you intend to reverse engineer other USB items.</p></div></div></div></div></body></html>