<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Communicating with the Web"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Communicating with the Web</h1></div></div></div><p>In this chapter, we'll be looking at the following ways to get your scripts talking to the outside world by sending and receiving web requests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Opening a web page from script</li><li class="listitem" style="list-style-type: disc">Grabbing data from a server</li><li class="listitem" style="list-style-type: disc">Working with XML data</li><li class="listitem" style="list-style-type: disc">Working with JSON data</li><li class="listitem" style="list-style-type: disc">Sending POST data to a web server from Maya</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec63"/>Introduction</h1></div></div></div><p>In the previous chapter, we looked at how to read and write data to disk, which can be a great way to build up toolchains and pipelines for your teams. However, you will almost always be working as part of a team (or working to support a team as a TD), which means that you'll generally want to read and write data to some central repository.</p><p>And in order to do it, you'll probably need to communicate with a web server of some kind. In this chapter, we'll be looking at how to do just that—how to pull data from and push data onto the Web.</p></div></div>
<div class="section" title="Opening a web page from script"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Opening a web page from script</h1></div></div></div><p>If you find <a id="id324" class="indexterm"/>yourself writing a complex script, it can often be helpful to provide documentation for your script in the form of a web page. A great way to do that is to include an easy way to show that page to the user. In this example, we'll create a simple script that will open a given URL in the user's default web browser.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec181"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def showHelp():
    cmds.showHelp("http://www.adrianherbez.net", absolute=True)

showHelp()</pre></div><p>Run the script, and you'll see the specified URL appear in your default browser.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec182"/>How it works...</h2></div></div></div><p>All we're <a id="id325" class="indexterm"/>really doing here is using the <code class="literal">showHelp</code> command. It's a bit misleading, as the <code class="literal">showHelp</code> command is also used to show Maya's documentation for a specific command. However, as long as you specify the absolute flag to true, you can pass in a full path to the URL you would like to open:</p><div class="informalexample"><pre class="programlisting">cmds.showHelp("http://www.adrianherbez.net", absolute=True)</pre></div><p>Note that there are a few deprecated commands that you might come across that no longer work. In older versions of Maya, there was a <code class="literal">webBrowser</code> command that would allow for the inclusion of web content in script-based UIs. Unfortunately, that command has been removed, necessitating the use of <code class="literal">showHelp</code> to open content in the browser.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec183"/>There's more...</h2></div></div></div><p>It's highly likely that if you have a script that is complex enough to warrant a page of documentation, it also includes (possibly complex) UI. Rather than just having a button to show help, it's easy enough to implement a proper "Help" menu, as is commonly seen in other programs.</p><div class="mediaobject"><img src="graphics/B04657_09_01.jpg" alt="There's more..."/></div><p>This is easily <a id="id326" class="indexterm"/>done with the menu and <code class="literal">menuItem</code> commands. Here's a full listing to produce the preceding result:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

class helpWin():

    def __init__(self):
        self.win = cmds.window(menuBar=True, width=300, height=200)
        cmds.menu(label="Help", helpMenu=True)
        cmds.menuItem(label="View Help", command=self.showHelp)
        cmds.columnLayout()
        cmds.showWindow(self.win)

    def showHelp(self, args):
        cmds.showHelp("http://www.adrianherbez.net", absolute=True)

helpWin()</pre></div><p>We start by creating a window, just as we've done in previous examples. Then, we add a new menu with the <code class="literal">menu</code> command. The label is the text that will appear as the top of the menu, and specifying <code class="literal">helpMenu=True</code> ensures that this particular menu will be treated as a help menu (displayed to the far right of all menu options).</p><p>Once we have a menu, we can add menu items to it. This is a lot like adding a button, in that we specify a label and a command that will be executed when the item is selected.</p><p>Note that the new <code class="literal">menuItem</code> will be added to the most recent menu. To add menu items in different menus (to have both a "File" and a "Help" category, for example), be sure to call <code class="literal">cmds.menu</code> to start <a id="id327" class="indexterm"/>a new menu before adding additional items.</p></div></div>
<div class="section" title="Grabbing data from a server"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec65"/>Grabbing data from a server</h1></div></div></div><p>In this <a id="id328" class="indexterm"/>example, we'll look at the simplest possible way to grab data from a given URL, using Python's built-in <code class="literal">urllib2</code> library.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec184"/>Getting ready</h2></div></div></div><p>You'll <a id="id329" class="indexterm"/>want to make sure that you have a URL to grab. You can use any website you like, but for the sake of testing, it can be helpful to have a minimal page served on your local machine. If you want to do that, start by creating a simple html file, something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;
            Maya scripting chapter 9
        &lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        HELLO FROM THE WEB
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Once you've done that, you'll want to have that served as a page on your own machine. Python offers a really simple way to do just that. Open a command line (terminal on a mac) and navigate to wherever you saved your html file. From there, enter the following command:</p><div class="informalexample"><pre class="programlisting">python -m SimpleHTTPServer</pre></div><p>This will cause Python to serve the contents of the current directory as a website on localhost. The -m flag tells python to include a given module (in this case, <code class="literal">SimpleHTTPServer</code>) when running the interpreter. It's the equivalent of using the following at the beginning of a Python script:</p><div class="informalexample"><pre class="programlisting">import SimpleHTTPServer</pre></div><p>By default, the contents of the current directory will be served on port 8000, meaning that you can access the contents by opening a browser and going to: </p><div class="informalexample"><pre class="programlisting">http://localhost:8000/</pre></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec185"/>How to do it...</h2></div></div></div><p>Create a <a id="id330" class="indexterm"/>new file and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import urllib2

def getWebData():
    url = 'http://localhost:8000'

    print('grabbing web data from ', url)
    
    try:
        web = urllib2.urlopen(url)
        
    except Exception as e:
        print("ERROR: ", e)
        return
    
    print(web.getcode())
    print(web.info())
    print(web.read())
    


getWebData()</pre></div><p>Make <a id="id331" class="indexterm"/>sure that you've created an <code class="literal">index.htm</code> (or html) file somewhere and that you've run <code class="literal">python -m SimpleHTTPServer</code> from that same directory. If you've done that, running the preceding script should output something like the following followed by the entire contents of your <code class="literal">index.htm</code> file:</p><div class="informalexample"><pre class="programlisting">200
Server: SimpleHTTP/0.6 Python/2.7.10
Date: Tue, 26 Apr 2016 19:08:08 GMT
Content-type: text/html
Content-Length: 113
Last-Modified: Wed, 13 Apr 2016 06:31:18 GMT</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec186"/>How it works...</h2></div></div></div><p>First off, we have to make sure to import the <code class="literal">urllib2</code> library in addition to our standard <code class="literal">maya.cmds</code>:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import urllib2</pre></div><p>This will give us access to the commands we'll need to load data from a given URL. We start by setting up a variable to hold the URL we're loading, and printing a message indicating that we're about to attempt to load it:</p><div class="informalexample"><pre class="programlisting">def getWebData():
    url = 'http://localhost:8000'

    print('grabbing web data from ', url)</pre></div><p>Now we're <a id="id332" class="indexterm"/>ready to actually attempt to load the data. When<a id="id333" class="indexterm"/> loading data from a URL, it's important that you never assume that the URL is accessible. There are any number of things that can go wrong either on the server side (the server could be down or not responding to requests) or on the client side (the indicated URL could be blocked by a firewall, the Ethernet cable could be unplugged, and so on) any one of which would prevent the URL from loading.</p><p>As such, we'll wrap our attempt to fetch the URL in a try/catch block. If anything goes wrong in the loading of the URL, we'll print out the error and return:</p><div class="informalexample"><pre class="programlisting">    try:
        web = urllib2.urlopen(url)
        
    except Exception as e:
        print("ERROR: ", e)
        return</pre></div><p>If we manage to actually retrieve the URL in question, we're left with a "file-like object". This means that we can use all the functions that we would use when opening a file, such as <code class="literal">read()</code> to get the contents. The specific file-like objects returned by <code class="literal">urllib2.urlopen</code> also implement a couple of additional functions, which we make use of here. First, we get the HTTP code:</p><div class="informalexample"><pre class="programlisting">print(web.getcode())</pre></div><p>If everything went as expected, that <span class="emphasis"><em>should</em></span> print out "200", indicating a successful request. Next, we retrieve some information about the URL:</p><div class="informalexample"><pre class="programlisting">print(web.info())</pre></div><p>This will display the information in the headers (server type, time of last modification, and so on):</p><div class="informalexample"><pre class="programlisting">print(web.info())</pre></div><p>Finally, we'll get the actual data at the web address with the <code class="literal">read()</code> function. Calling <code class="literal">read()</code> without specifying a number of bytes to read will grab the entire contents of the file (or in this case, the website).</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec187"/>There's more...</h2></div></div></div><p>In this example, we <a id="id334" class="indexterm"/>loaded the entirety of a website. While you generally wouldn't want to do that for most websites, it makes a lot of sense when requesting data from a web API, where the result will typically be a small(ish) amount of formatted data (either XML or JSON).</p><p>If what you <a id="id335" class="indexterm"/>want is to just display a full website (rather than retrieving data via an API), see the previous example where we use the <code class="literal">showHelp</code> command to display a given website.</p></div></div>
<div class="section" title="Working with XML data"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Working with XML data</h1></div></div></div><p>When<a id="id336" class="indexterm"/> grabbing data from a web server, it's highly likely that you'll receive it in a structured format of one kind or another, with XML and JSON being the most common options. In this example, we'll look at how to make use of data served up as XML.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec188"/>Getting ready</h2></div></div></div><p>To use this example, you'll need to have an XML file available on a server somewhere. The easiest way to do this is to create a file locally on your machine, then run the following:</p><div class="informalexample"><pre class="programlisting">python -m SimpleHTTPServer</pre></div><p>From the same directory as the file, provide access to it via localhost. Here's the file that I'll be using as the example:</p><div class="informalexample"><pre class="programlisting">&lt;xml version="1.0"&gt;
    &lt;object type="cube"&gt;
        &lt;x&gt;0&lt;/x&gt;
        &lt;y&gt;2&lt;/y&gt;
        &lt;z&gt;3&lt;/z&gt;
        &lt;size&gt;3&lt;/size&gt;
    &lt;/object&gt;

    &lt;object type="sphere"&gt;
        &lt;size&gt;2&lt;/size&gt;
        &lt;x&gt;0&lt;/x&gt;
        &lt;y&gt;0&lt;/y&gt;
        &lt;z&gt;0&lt;/z&gt;
    &lt;/object&gt;
&lt;/xml&gt;</pre></div><p>The file is pretty simple, but will allow us to look at iterating over XML nodes and parsing both attributes and elements.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec189"/>How to do it...</h2></div></div></div><p>Create a new<a id="id337" class="indexterm"/> file and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import urllib2
import xml.etree.ElementTree as ET

def makeObjectAt(type, position, size):

    if (type == 1):
        cmds.polyCube(height=size, width=size, depth=size)
    elif (type == 2):
        cmds.sphere(radius=size/2)
        
    cmds.move(position[0], position[1], position[2])

def loadXML():
    url = 'http://localhost:8000/data.xml'
    
    try:
        webData = urllib2.urlopen(url)
        
    except Exception as e:
        print("ERROR: ", e)
        return

    data = ET.parse(webData)
    root = data.getroot()

    for item in root:
        
        objectType = 1
        objectSize = 1
        pos = [0,0,0]

        if (item.attrib['type'] == "sphere"):
            objectType = 2

        for details in item:
            tagName = details.tag
            tagValue = float(details.text)

            if (tagName == "size"):
                objectSize = tagValue
            elif (tagName == "x"):
                pos[0] = tagValue
            elif (tagName == "y"):
                pos[1] = tagValue
            elif (tagName == "z"):
                pos[2] = tagValue

        makeObjectAt(objectType, pos, objectSize)


loadXML()</pre></div><p>Be sure to<a id="id338" class="indexterm"/> point the URL at the proper location for your XML file, and run the script; you should see a cube and a sphere appear.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec190"/>How it works...</h2></div></div></div><p>First off, we add another library <code class="literal">xml.etree.ElementTree</code> to our imports and give it a shorter name to make it easier to work with:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import urllib2
import xml.etree.ElementTree as ET</pre></div><p>Next, we create a simple function to create either a sphere or a cube of a given size and move it to a given position. This is pretty straightforward and probably seems quite familiar at this point:</p><div class="informalexample"><pre class="programlisting">def makeObjectAt(type, position, size):
    if (type == 1):
        cmds.polyCube(height=size, width=size, depth=size)
    elif (type == 2):
        cmds.sphere(radius=size/2)
    cmds.move(position[0], position[1], position[2])</pre></div><p>Next, we grab the data from the specified URL, as we have in the previous examples this chapter:</p><div class="informalexample"><pre class="programlisting">def loadXML():
    url = 'http://localhost:8000/data.xml'
    
    try:
        webData = urllib2.urlopen(url)
        
    except Exception as e:
        print("ERROR: ", e)
        return</pre></div><p>Now we're ready to move onto the meat of the example—the actual XML parsing. First off, we parse the data we received from the Web into an XML tree with the <code class="literal">xml.etree.ElementTree</code> parse command.</p><div class="informalexample"><pre class="programlisting">data = ET.parse(webData)</pre></div><p>The parse<a id="id339" class="indexterm"/> command can accept either a string or a file-like object. Because we receive a file-like object from the <code class="literal">urllib2.urlopen</code> command, we can pass the result straight in.</p><p>Once we've done that, we have a proper tree of XML nodes, and we're ready to start traversing the tree and parsing our data. To get started parsing, we first need to grab the root node, which we do with the <code class="literal">getroot()</code> command:</p><div class="informalexample"><pre class="programlisting">root = data.getroot()</pre></div><p>The actual parsing will be a bit different, depending on the nature of your XML schema. In this case, we have some number of &lt;object&gt; nodes, each of which containing a "type" attribute and several child nodes for the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> positions as well as the size.</p><p>We'll want to start by iterating through all of the child nodes of the root to give us all of the object nodes. The <code class="literal">ElementTree</code> library makes that really easy—we can simply use a for loop to get all the child nodes. For each object we find, we'll start by setting variables for object type, position, and size to default values:</p><div class="informalexample"><pre class="programlisting">    for item in root:
        
        objectType = 1
        objectSize = 1
        pos = [0,0,0]</pre></div><p>In this case, our local <code class="literal">item</code> variable represents a node that is a direct child of the root. Given the structure of our example XML document, that means we have an &lt;object&gt; node. First off, we'll want to examine the <code class="literal">type</code> attribute to see if we should be making a cube or a sphere.</p><p>The attributes of a given node are stored as a dictionary in the node's <code class="literal">attrib</code> attribute. We can index into that to grab the value, and if we find that it's equal to <code class="literal">sphere</code>, we set our <code class="literal">objectType</code> to <code class="literal">2</code>:</p><div class="informalexample"><pre class="programlisting">        if (item.attrib['type'] == "sphere"):
            objectType = 2</pre></div><p>Now we need to look at the children of our current node to get the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, <span class="emphasis"><em>z</em></span> positions and the size. We'll use the same trick as before, iterating over the children of a given node with a for loop. For each child we find, we want to know two things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name of the tag.</li><li class="listitem" style="list-style-type: disc">The value contained within the tag, as a float.</li></ul></div><p>The name of a<a id="id340" class="indexterm"/> given node can be accessed via its tag property, and any text contained within it can be grabbed via the text property. For our purposes, we want to ensure floating point values, so we'll be sure to cast the text to a float. Putting all that together gives us the following:</p><div class="informalexample"><pre class="programlisting">    for details in item:
        tagName = details.tag
        tagValue = float(details.text)</pre></div><p>All that's left is to make use of the tag that we found and set the appropriate variable to our <code class="literal">tagValue</code>:</p><div class="informalexample"><pre class="programlisting">    if (tagName == "size"):
        objectSize = tagValue
    elif (tagName == "x"):
        pos[0] = tagValue
    elif (tagName == "y"):
        pos[1] = tagValue
    elif (tagName == "z"):
        pos[2] = tagValue</pre></div><p>Having done all of that, we pass our data into our <code class="literal">makeObjectAt</code> function to produce the object.</p><div class="informalexample"><pre class="programlisting">makeObjectAt(objectType, pos, objectSize)</pre></div></div></div>
<div class="section" title="Working with JSON data"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Working with JSON data</h1></div></div></div><p>In this <a id="id341" class="indexterm"/>example, we'll look at the other format you're likely to want to use—JSON. JSON can model data just as well as XML, but is considerably more compact. As such, it has been growing in popularity in recent years and has all but replaced XML for many tasks.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec191"/>Getting ready</h2></div></div></div><p>Once again, you'll want to make sure that you have a file being served by a server that you have access to, but this time you'll want to make sure that it's JSON data. Once again, we'll create some number of cubes and spheres, but this time, we'll specify the data as an array of JSON objects.</p><p>The full listing for the example document is as follows:</p><div class="informalexample"><pre class="programlisting">[
    {"type": "cube", "size": 3, "x": 0, "y": 2, "z": 3},
    {"type": "sphere", "size": 1, "x": 0, "y": 0, "z": 0}
]</pre></div><p>The square brackets indicate an array, and the curly brackets indicate an object. Within an object, there can be any number of named values. Arrays and objects can also be nested, allowing us to have <a id="id342" class="indexterm"/>an array <span class="emphasis"><em>of</em></span> objects, as we do here. For more information on how to structure JSON data, be sure to have a look at <a class="ulink" href="http://www.json.org/">http://www.json.org/</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec192"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import urllib2
import json

def makeObjectAt(type, position, size):

    if (type == 1):
        cmds.polyCube(height=size, width=size, depth=size)
    elif (type == 2):
        cmds.sphere(radius=size/2)
        
    cmds.move(position[0], position[1], position[2])

def loadJSON():
    url = 'http://localhost:8000/data.json'
    
    try:
        webData = urllib2.urlopen(url)
        
    except Exception as e:
        print("ERROR: ", e)
        return

    data = json.loads(webData.read())

    for item in data:

        objectType = 1
        objectSize = 1
        position = [0,0,0]

        if ('type' in item and item['type'] == "sphere"):
            objectType = 2
        if ('x' in item):
            position[0] = item['x']
        if ('y' in item):
            position[1] = item['y']
        if ('z' in item):
            position[2] = item['z']
        if ('size' in item):
            objectSize = float(item['size'])

        print(objectType, position, objectSize)
        makeObjectAt(objectType, position, objectSize)
        
loadJSON()</pre></div><p>Make sure that you<a id="id343" class="indexterm"/> have a JSON file formatted in the same way as the example and that it's accessible via a URL, localhost, or otherwise. Run the script, and you should have some number of cubes and spheres appear on your scene.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec193"/>How it works...</h2></div></div></div><p>Most of the script is the same as our previous example of parsing XML data. The first difference is that we change the import statements slightly, removing the <code class="literal">xml.etree.ElementTree</code> library and adding the JSON library instead:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import urllib2
import json</pre></div><p>Next up, we have the same function as was used in the XML example to create either a sphere or a cube of a given size and move it to a specified position. I'll omit the details because it's identical to the function from the previous example.</p><p>In the function responsible for actually loading the data, we start off grabbing the URL as we have in the previous examples in this chapter:</p><div class="informalexample"><pre class="programlisting">def loadJSON():
    url = 'http://localhost:8000/data.json'
    
    try:
        webData = urllib2.urlopen(url)
        
    except Exception as e:
        print("ERROR: ", e)
        return</pre></div><p>The new functionality comes in the form of a call to the <code class="literal">loads()</code> or "load string" function, which will load data from a string into a proper JSON object. By passing the result of <code class="literal">webData.read()</code> into that function, we will be left with the full contents of our file into an object:</p><div class="informalexample"><pre class="programlisting">data = json.loads(webData.read())</pre></div><p>Once we've done<a id="id344" class="indexterm"/> that, we'll want to step through the entries in the data. The result of parsing JSON in Python will translate arrays into lists and objects into dictionaries. Because our JSON data was in the form of an array of objects, we are left with a list of dictionaries after loading.</p><p>We start our parsing by stepping through the array and grabbing the data for each object. As in the XML example, we set up placeholder variables with default values for <code class="literal">objectType</code>, <code class="literal">objectSize</code>, and <code class="literal">position</code>, as follows:</p><div class="informalexample"><pre class="programlisting">    for item in data:

        objectType = 1
        objectSize = 1
        position = [0,0,0]</pre></div><p>Within the loop, we'll grab the values for each of our attributes by first checking to see if they're present in the current dictionary and, if so, set the value of the corresponding variable. We have the following code:</p><div class="informalexample"><pre class="programlisting">        if ('type' in item and item['type'] == "sphere"):
            objectType = 2
        if ('x' in item):
            position[0] = item['x']
        if ('y' in item):
            position[1] = item['y']
        if ('z' in item):
            position[2] = item['z']
        if ('size' in item):
            objectSize = float(item['size'])</pre></div><p>Note that we cast <code class="literal">objectSize</code> to a float. That's necessary, since we divide it by 2 in our <code class="literal">makeObjectAt()</code> function. If we happen to have an integer input, dividing it by 2 would result in an integer result, possibly giving us a bad value (if we pass in 1, we would get 0 instead of 0.5, for example).</p><p>Finally, we pass in the retrieved values to our <code class="literal">makeObjectAt()</code> function:</p><div class="informalexample"><pre class="programlisting">makeObjectAt(objectType, position, objectSize)</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec194"/>There's more...</h2></div></div></div><p>You'll probably note that JSON data is a bit easier to work with than XML—with JSON, we end up with standard Python lists and dictionaries, whereas XML requires that we walk up and down a series of nodes.</p><p>That's true not only in Python, but in many other languages as well. If you happen to be working in JavaScript, there's often no actual parsing required, as JSON is a subset of JavaScript itself (JSON is short for JavaScript Object Notation).</p><p>There are still <a id="id345" class="indexterm"/>good reasons to use XML, but if all that's needed is a way to move structured data from one place to another, JSON tends to be easier to parse, and just as easy to read.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec195"/>See also</h2></div></div></div><p>If you're new to<a id="id346" class="indexterm"/> JSON, it's a good idea to have a look at the official docs, available at <a class="ulink" href="http://www.json.org/">http://www.json.org/</a>. You'll find that for all its flexibility, it's actually a pretty simple format.</p></div></div>
<div class="section" title="Sending POST data to a web server from Maya"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Sending POST data to a web server from Maya</h1></div></div></div><p>So far, everything we've looked at involves pulling data from the Web into Maya. In this example, we'll look at how to send data to a server from within Maya.</p><p>There are two<a id="id347" class="indexterm"/> main ways to send data to a server—GET and POST. Using GET involves adding arguments onto a URL directly. It has the benefit of being able to be bookmarked (since the arguments are in the URL), but has limitations on the amount of data that can be sent. POST requests are more flexible and will usually be what you want to use to build tool pipelines in a production environment.</p><p>In this example, we'll implement two different examples of sending POST data. First, we'll look at sending summary data about a scene (the name of the file and the number of objects). Then, we'll look at using POST requests to send a selected model to a server as an OBJ file. This could form the backbone of an asset management pipeline.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec196"/>Getting ready</h2></div></div></div><p>We'll be using the requests library for this example, so make sure to install it. For details on how to do that, visit <a class="ulink" href="http://docs.python-requests.org/en/master/user/install/#install">http://docs.python-requests.org/en/master/user/install/#install</a>.</p><p>In order to make the most of this example, you'll need to have a server that can respond to GET and POST requests. Setting that up is beyond the scope of this book, and there are any number of ways to go about it (and any number of languages you can use to do so). Luckily, there's an easy way to test your requests in the form of <a class="ulink" href="http://httpbin.org/">http://httpbin.org/</a>. The httpbin site can be used to test a wide range of HTTP requests, and will return whatever data is passed to it.</p><p>Also, since we're going to be sending actual model data, you'll need to have at least one polygonal mesh in your scene.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec197"/>How to do it...</h2></div></div></div><p>Create a new <a id="id348" class="indexterm"/>file and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import os
import requests
import json

DATA_URL = "http://httpbin.org/post"

def sendFileData():
    fullname = cmds.file(query=True, sceneName=True)
    filename = os.path.basename(fullname)

    data = {}
    data['fileName'] = filename
    data['numObjects'] = len(cmds.ls(geometry=True))

    result = requests.post(DATA_URL, json=data)

    if (result.status_code == 200):
        responseData = json.loads(result.text)
        print("SENT DATA: ")
        print(responseData['data'])
    else:
        error("HTTP Error")


def polygonSelected():
    objs = cmds.ls(selection=True)
    if (len(objs) &lt; 1):
        return False
    
    objectToExport = objs[0]
    
    shapeNode = cmds.listRelatives(objectToExport, shapes=True)
    if (cmds.nodeType(shapeNode[0]) != "mesh"):
        return False

    return True

def saveSelectionAsOBJ(path):
    cmds.loadPlugin("objExport", quiet=True)

    if (not cmds.file(path, query=True, exists=True)):
        f = open(path,"w")
        f.close()

    cmds.file(path, type="OBJ", force=True, exportSelected=True, options="groups=0;ptgroups=0;materials=0;smoothing=1;normals=1")


def sendModelAsPost(fileName):

    if not polygonSelected():
        cmds.error("Please select a polgonal object to export")

    baseDir = cmds.workspace(query=True, directory=True)
    path = os.path.join(baseDir, fileName)

    saveSelectionAsOBJ(path)
        
    data = {}
    data['filename'] = path
    modelFile = {'file': open(path, "rb")}

    result = requests.post(DATA_URL, json=data, files=modelFile)

    responseData = json.loads(result.text)
    print("FILE SENT: ")
    print(responseData['files'])


sendFileData()
sendModelAsPost("widget4.obj")</pre></div><p>Select a<a id="id349" class="indexterm"/> polygonal mesh and run the script. Both of the examples will send data to httpbin and output the result that gets parroted back from the site. You should see something like the following:</p><div class="informalexample"><pre class="programlisting"># requests.packages.urllib3.connectionpool : Starting new HTTP connection (1): httpbin.org # 
SENT DATA: 
{"numObjects": 2, "fileName": "widgt.ma"}
# requests.packages.urllib3.connectionpool : Starting new HTTP connection (1): httpbin.org # 
FILE SENT:  
{u'file': u'# OBJ file data'}</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec198"/>How it works...</h2></div></div></div><p>We start <a id="id350" class="indexterm"/>off the script with importing everything we need—<code class="literal">maya.cmds</code> as always, plus the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">- requests</code>: This provides nicer tools for working with requests and sending data</li><li class="listitem" style="list-style-type: disc"><code class="literal">- os</code>: This is needed to work with paths</li><li class="listitem" style="list-style-type: disc"><code class="literal">- json</code>: This is needed to parse the response that we'll get from httpbin.org</li></ul></div><p>We also set a global variable to hold the URL that we'll be sending data to, in this case, <code class="literal">httpbin.org/post</code>:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds
import os
import requests
import json

DATA_URL = "http://httpbin.org/post"</pre></div><p>Now we're ready to implement our first example—sending some summary data about our scene. In this case, we'll send the name of the scene and the number of objects it contains. To get the name of the current scene, we use the file command in query mode, and setting the <code class="literal">sceneName</code> flag.</p><p>This will give us the full path to the current scene, which we'll pass into <code class="literal">os.path.basename</code> to retrieve just the filename itself:</p><div class="informalexample"><pre class="programlisting">def sendFileData():
    fullname = cmds.file(query=True, sceneName=True)
    filename = os.path.basename(fullname)</pre></div><p>Next, we'll get the total number of objects in the scene by using the <code class="literal">ls</code> command and setting the geometry flag to true. The length of that list will give us the total number of (geometric) objects:</p><div class="informalexample"><pre class="programlisting">    numObjects = len(cmds.ls(geometry=True))</pre></div><p>At this point, we have all of the data that we want to send. In order to prep it for sending, we'll need to create a new dictionary and create an entry for each value we want to send:</p><div class="informalexample"><pre class="programlisting">    data = {}
    data['fileName'] = filename
    data['numObjects'] = numObjects</pre></div><p>Actually, sending the data is very straightforward, thanks to the requests library. All that we need to do is to call <code class="literal">requests.post</code> with our desired URL, and with our data variable passed in as the value for the JSON option. We'll be sure to save the result to a variable so that we can examine the response from the server:</p><div class="informalexample"><pre class="programlisting">    result = requests.post(DATA_URL, json=data)</pre></div><p>Once<a id="id351" class="indexterm"/> we've sent the request, we'll want to examine whether or not it was successful. To do that, we examine the <code class="literal">status_code</code> attribute of the result, checking it against 200. If the request went through, we parse the actual response into a JSON object and print the data attribute. Otherwise, we display an error, as in the following code:</p><div class="informalexample"><pre class="programlisting">    if (result.status_code == 200):
        responseData = json.loads(result.text)
        print("SENT DATA: ")
        print(responseData['data'])
    else:
        error("HTTP Error")</pre></div><p>Since <code class="literal">httpbin.org/post</code> will echo back any data sent to it, we should see something like the following:</p><div class="informalexample"><pre class="programlisting">SENT DATA: 
{"numObjects": 2, "fileName": "widget.ma"}</pre></div><p>This indicates that the data was successfully sent to the server and returned to us as a response.</p><p>Now, let's look at a slightly more involved example. We'll create a function that will save a selected polygonal object as an OBJ, then send that file to a server as POST data. We'll build that up from a few smaller functions, starting with one to test whether or not the current selection is a polygon mesh.</p><div class="informalexample"><pre class="programlisting">def polygonSelected():
    objs = cmds.ls(selection=True)
    if (len(objs) &lt; 1):
        return False
    
    objectToExport = objs[0]
    
    shapeNode = cmds.listRelatives(objectToExport, shapes=True)
    if (cmds.nodeType(shapeNode[0]) != "mesh"):
        return False

    return True</pre></div><p>This is similar to what we've done in previous examples; we get the current selection and start by checking to see if at least one object is selected. If that succeeds, we use the <code class="literal">listRelatives</code> command to retrieve the shape node associated with the selected object and test its node type. If it's anything other than "mesh" (indicating a polygonal object), we return false. If we pass through both checks, we return true.</p><p>Next, we implement a function to save the currently selected object as an OBJ. Since exporting OBJs requires that the OBJ export plugin be loaded, we start our function with a call to <code class="literal">loadPlugin</code> to make sure that it is. See the following:</p><div class="informalexample"><pre class="programlisting">def saveSelectionAsOBJ(path):
    cmds.loadPlugin("objExport", quiet=True)</pre></div><p>We <a id="id352" class="indexterm"/>pass in <code class="literal">objExport</code> as the plugin to load, and we set the quiet flag to true, which will prevent Maya from displaying a message if the plugin was already loaded.</p><p>To export the model, we'll need to use the <code class="literal">file</code> command, but before doing that, we'll want to make sure that the file exists. That's needed in order to avoid a quirk of the file command, which can cause it to error out if saving to a file that doesn't exist.</p><p>We start by using the <code class="literal">file</code> command in the query mode to see if a file of the given name exists. If not, we create one by opening it in write mode, then immediately closing it, as follows:</p><div class="informalexample"><pre class="programlisting">    if (not cmds.file(path, query=True, exists=True)):
        f = open(path,"w")
        f.close()</pre></div><p>Now we're ready to actually write out the OBJ file, using the file command once again:</p><div class="informalexample"><pre class="programlisting">    cmds.file(path, exportSelected=True, type="OBJ", force=True, 
    options="groups=0;ptgroups=0;materials=0;smoothing=1;normals=1")</pre></div><p>The first argument is the full path to where we want to save the file. After that, we set <code class="literal">exportSelected</code> to true to indicate the main operation that should be performed, in this case, exporting only the currently selected object. Next, we specify that we want to save it as an OBJ, and we set force to true to avoid prompting the user for a file overwrite confirmation. Finally, we set the options for the OBJ export as a single string, with semicolons to separate out each of the parts. In this case, we'll turn everything off except <code class="literal">normals</code>.</p><p>Now that we've created both of our helper functions, we're ready to move to the function to put them together and send the model to a server. We start by running the check for polygonal geometry and throwing an error if it fails:</p><div class="informalexample"><pre class="programlisting">def sendModelAsPost(fileName):

    if not polygonSelected():
        cmds.error("Please select a polygonal object to export")</pre></div><p>Once we've done that, we build up the path to save the file by first using the workspace command to retrieve the current workspace location and using <code class="literal">os.path.join</code> to append the desired filename:</p><div class="informalexample"><pre class="programlisting">    baseDir = cmds.workspace(query=True, directory=True)
    path = os.path.join(baseDir, fileName)</pre></div><p>With the full path, we can save out the model using our <code class="literal">saveSelectionAsOBJ()</code> function:</p><div class="informalexample"><pre class="programlisting">    saveSelectionAsOBJ(path)</pre></div><p>Now we're <a id="id353" class="indexterm"/>ready to send the file. In order to send files via POST data, we'll need to send a "multipart" request in order to send the file data as its own part. Luckily for us, the requests library handles all of that for us. It ends up looking quite similar to our previous example of sending simple POST data, in that we start by setting up our data in a dictionary.</p><div class="informalexample"><pre class="programlisting">    modelFile = {'file': open(path, "rb")}</pre></div><p>In this case, we have only a single entry, named <code class="literal">file</code>, which we set equal to the output of the <code class="literal">file open</code> command:</p><div class="informalexample"><pre class="programlisting">    modelFile = {'file': open(path, "rb")}</pre></div><p>Once we've done that, all we need to do to actually send the file is to call <code class="literal">requests.post</code> with the desired URL, and pass in our <code class="literal">modelFile</code> dictionary as the value for the <code class="literal">files</code> attribute:</p><div class="informalexample"><pre class="programlisting">result = requests.post(DATA_URL, files=modelFile)</pre></div><p>Just as with the simple example, we'll check the <code class="literal">result.status_code</code> and, if we find 200, parse the response as JSON and output some of it, though in this case, we output the <code class="literal">files</code> attribute instead of data. We have the following code:</p><div class="informalexample"><pre class="programlisting">    if (result.status_code == 200):
        responseData = json.loads(result.text)
        print("FILE SENT: ")
        print(responseData['files'])
    else:
        error("File send error")</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec199"/>There's more...</h2></div></div></div><p>While we sent data and files in two separate requests for the sake of the examples, you can certainly send both at the same time. For example, if you wanted to build an asset management pipeline for an MMO, you might want to send the models to a central server, along with some metadata, such as which textures they use or what their in-game attributes are.</p></div></div></body></html>