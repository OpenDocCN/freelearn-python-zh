- en: Chapter 3. Vertex Groups and Materials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：顶点组和材料
- en: Complex meshes might be difficult to handle when the number of vertices is large.
    In this chapter we will look at how we can make life easier for the end user by
    defining vertex groups to label collections of vertices. We will also explore
    some of the many uses of vertex groups including their use in armatures and modifiers,
    and we will look into methods to apply different materials to different parts
    of mesh.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶点数量很大时，复杂的网格可能难以处理。在本章中，我们将探讨如何通过定义顶点组来标记顶点集合，从而让最终用户的生活更加轻松。我们还将探索顶点组的许多用途，包括它们在骨架和修改器中的应用，以及我们将探讨将不同材质应用于网格不同部分的方法。
- en: 'In this chapter, we will learn how to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何：
- en: Define vertex groups
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义顶点组
- en: Assign vertices to a vertex group
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶点分配给顶点组
- en: Assign materials to faces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将材质分配给面
- en: Assign vertex colors to vertices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将顶点颜色分配给顶点
- en: Set edge properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置边属性
- en: Add modifiers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加修改器
- en: Skin bones
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 皮肤骨骼
- en: '![Vertex Groups and Materials](img/0400-03-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![顶点组和材料](img/0400-03-01.jpg)'
- en: Vertex groups
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点组
- en: '**Vertex** **groups** are a way to organize collections of vertices within
    a mesh. A mesh may have any number of vertex groups and any vertex within a mesh
    may be a member of more than one vertex group or may belong to no vertex group
    at all. A newly created `Mesh` object does not have any vertex groups defined.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点** **组**是组织网格内顶点集合的一种方式。一个网格可以有任意数量的顶点组，网格中的任何顶点都可以是多个顶点组的成员，或者根本不属于任何顶点组。一个新创建的`Mesh`对象没有定义任何顶点组。'
- en: In their basic form, vertex groups are a valuable tool in identifying distinct
    parts of a complex mesh. By assigning vertices to vertex groups, the modeler eventually
    provides people, such as the rigger or the people who texture a model, with the
    means to easily identify and select the parts of the model they want to work on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在其基本形式中，顶点组是识别复杂网格中不同部分的有价值工具。通过将顶点分配给顶点组，建模者最终为人们，如绑定者或为模型贴图的人，提供了轻松识别和选择他们想要工作的模型部分的方法。
- en: The use of vertex groups goes far beyond simple identification though. Many
    mesh modifiers restrict their influence to a designated vertex group and an armature
    can be configured to deform a mesh by linking the influence of each bone to a
    single vertex group. We will see examples of that later.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管顶点组的使用远不止简单的识别。许多网格修改器将它们的影响限制在指定的顶点组中，并且可以通过将每个骨骼的影响链接到单个顶点组来配置骨架以变形网格。我们将在稍后看到这方面的例子。
- en: A vertex group is not merely a collection of vertices. Each vertex of a vertex
    group may have an associated *weight* (between zero and one) that many modifiers
    use to fine-tune their influence. A vertex may have a different weight associated
    with it in each vertex group it belongs to.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个顶点组不仅仅是顶点的集合。顶点组中的每个顶点都可能有一个关联的*权重*（介于零和一之间），许多修改器使用它来微调它们的影响。一个顶点在其所属的每个顶点组中可能具有不同的权重。
- en: The bugs we create with `creepycrawlies.py` are an excellent example of a rather
    complex mesh with many distinct parts that would benefit greatly from defining
    vertex groups. Not only to make it simpler to select a part by name, for instance
    the head, but also to make life easier for ourselves if we want to rig the model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`creepycrawlies.py`创建的虫子是一个相当复杂的网格的极好例子，它具有许多不同的部分，定义顶点组将极大地从中受益。不仅可以通过名称选择部分，例如头部，而且如果我们要为模型绑定，也会使我们的工作更加容易。
- en: 'Our primary tools in creating vertex groups are the methods of `Mesh` objects
    listed in the following table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建顶点组的主要工具是以下表中列出的`Mesh`对象的方法：
- en: '| Method | Action | Remarks |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 操作 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `addVertGroup(group)` | Adds a new empty vertex group. |   |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `addVertGroup(group)` | 添加一个新的空顶点组。 |   |'
- en: '| `assignVertsToGroup(group,vertices,weight,mode)` | Adds a list of vertex
    indices to an existing vertex group with the given weight. | Mode determines what
    to do when a vertex is already a member of the vertex group. See main text for
    details. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `assignVertsToGroup(group,vertices,weight,mode)` | 将顶点索引列表添加到具有给定权重的现有顶点组中。
    | 模式确定当顶点已经是顶点组的成员时应该做什么。请参阅正文以获取详细信息。 |'
- en: '| `getVertsFromGroup(group,weightsFlag=0,vertices)` | Returns a list of vertex
    indices (the default) or a list of (index, weight) tuples (`if` `weightsFlag`
    `=` `1`). If the vertices list is specified only those vertices that are in the
    group and in the given list are returned. |   |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `getVertsFromGroup(group,weightsFlag=0,vertices)` | 返回一个顶点索引列表（默认）或一个包含（索引，权重）元组的列表（如果`weightsFlag`等于`1`）。如果指定了顶点列表，则只返回该组中且在给定列表中的顶点。|  |'
- en: '| `removeVertsFromGroup(group,vertices)` | Removes a list of vertices from
    an existing vertex group. If the list is not specified all vertices are removed.
    |   |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `removeVertsFromGroup(group,vertices)` | 从现有的顶点组中删除顶点列表。如果未指定列表，则删除所有顶点。|  |'
- en: '| `renameVertGroup(groupName, newName)` | Renames a vertex group. |   |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `renameVertGroup(groupName, newName)` | 重命名一个顶点组。|  |'
- en: '| `getVertGroupNames()` | Returns a list of all vertex group names. |   |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `getVertGroupNames()` | 返回所有顶点组名称的列表。|  |'
- en: '| `removeVertGroup(group)` | Deletes a vertex group. | Will NOT delete the
    actual vertices. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `removeVertGroup(group)` | 删除一个顶点组。| 不会删除实际的顶点。|'
- en: 'The important concept to grasp here is that creating a vertex group and assigning
    vertices to it are two separate actions. Creating a new empty vertex group is
    done by calling the `addVertGroup()` method of your `Mesh` object. It takes a
    single string as an argument and that will be the name of the vertex group. If
    there is already a vertex group with the same name, the name will have a numerical
    suffix added to prevent a name clash, so for example: `TailSegment` may become
    `TailSegment.001`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要掌握的重要概念是，创建顶点组和将顶点分配给它是两个不同的操作。通过调用您的`Mesh`对象的`addVertGroup()`方法创建一个新的空顶点组。它接受一个字符串参数，该参数将是顶点组的名称。如果已经存在具有相同名称的顶点组，则名称将添加一个数字后缀以防止名称冲突，例如：`TailSegment`可能变为`TailSegment.001`。
- en: Adding vertices to an existing vertex group is done by calling the `assignVertsToGroup()`
    method of your mesh. This method will take four mandatory arguments—the name of
    the vertex group to assign the vertices to, a list of vertex indices, a weight,
    and an *assign* mode. If the vertex group does not exist, or one of the vertex
    indices points to a nonexistent vertex, an exception is raised.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 向现有的顶点组添加顶点是通过调用您的网格的`assignVertsToGroup()`方法来完成的。此方法将接受四个强制参数——要分配顶点的顶点组名称、顶点索引列表、权重和一个*分配*模式。如果顶点组不存在，或者其中一个顶点索引指向一个不存在的顶点，则会引发异常。
- en: The weight must be a value between 0.0 and 1.0; any weight larger than 1.0 is
    clamped to 1.0\. A weight smaller or equal to 0.0 will remove a vertex from the
    vertex group. If you want to assign different weights to vertices in the same
    vertex group, you have to assign them to the group with separate calls to `assignVertsToGroup()`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 权重必须是一个介于0.0和1.0之间的值；任何大于1.0的权重都会被限制为1.0。小于或等于0.0的权重将从一个顶点组中删除顶点。如果您想为同一顶点组中的顶点分配不同的权重，您必须通过单独调用`assignVertsToGroup()`方法来分配它们。
- en: 'The *assign* mode comes in three flavors: `ADD`, `REPLACE`, and `SUBTRACT`.
    `ADD` will add new vertices to the vertex group and will associate the given weight
    with them. If any of the vertices in the list already exist they get the weight
    added to them. `REPLACE` will replace the weight associated with the indices in
    the list if they are members of the vertex group or do nothing otherwise. `SUBTRACT`
    will try to subtract the weight from the vertices in the list and again do nothing
    if they are not members of the vertex group. Most often when adding completely
    new vertex groups to a mesh you will use the `ADD` mode.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*分配*模式有三种：`ADD`、`REPLACE`和`SUBTRACT`。`ADD`会将新顶点添加到顶点组中，并将给定的权重与它们关联。如果列表中的任何顶点已经存在，它们将获得附加的权重。`REPLACE`将替换列表中索引关联的权重，如果它们是顶点组的成员，否则不执行任何操作。`SUBTRACT`将尝试从列表中的顶点减去权重，如果它们不是顶点组的成员，则不执行任何操作。在将完全新的顶点组添加到网格时，通常使用`ADD`模式。'
- en: A weighty issue
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个重要的问题
- en: For our first example we will add two new vertex groups to an existing mesh
    object—one that will contain all vertices that have a positive x-coordinate and
    one that will contain the vertices with a negative x-coordinate. We will name
    these groups **Right** and **Left** respectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将向一个现有的网格对象添加两个新的顶点组——一个将包含所有具有正x坐标的顶点，另一个将包含具有负x坐标的顶点。我们将分别将这些组命名为**右**和**左**。
- en: Additionally, we will give each vertex in these groups a weight depending on
    its distance from its object center with larger weights for vertices that are
    farther away from the center.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将根据每个顶点与其对象中心的距离为其分配一个权重，距离中心越远的顶点权重越大。
- en: 'Code outline: leftright.py'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码概要：leftright.py
- en: 'Schematically we will take the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 概括地说，我们将采取以下步骤：
- en: Get the active object.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取活动对象。
- en: Verify that it is a mesh and get the mesh data.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证它是一个网格并获取网格数据。
- en: Add two new vertex groups to the object—Left and Right.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向对象添加两个新的顶点组——Left 和 Right。
- en: 'For all vertices in the mesh:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于网格中的所有顶点：
- en: Calculate the weight
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算权重
- en: 'If the x-coordinate > 0:'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 x 坐标 > 0：
- en: Add vertex index and weight to vertex group *right*
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点索引和权重添加到顶点组 *right*
- en: 'If the x-coordinate < 0:'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 x 坐标 < 0：
- en: Add vertex index and weight to vertex group *left*
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点索引和权重添加到顶点组 *left*
- en: 'In order to make certain that a new vertex group is empty we check if the group
    already exists and remove it if that is the case. This checking is highlighted
    in the code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保新的顶点组为空，我们检查该组是否已存在，并在必要时将其删除。此检查在代码中突出显示：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The full script is available as `leftright.py`. The formula to calculate the
    weight may need some explanation: in order to assign a maximum weight of 1.0 to
    the points lying at the greatest distance from the center of the object we have
    to scale by the maximum distance possible. We could loop over all vertices to
    determine that maximum first, but here we choose to approximate this maximum by
    the root mean square of the size. This will exaggerate the maximum distance so
    the maximum weight assigned to any vertex will probably be less than 1.0\. However,
    getting the size is much faster than calculating the exact maximum for large meshes.
    Also, note that we calculate the distance to the object center (the object center
    from the point of view of the vertices in a mesh is always at (0, 0, 0)).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完整脚本作为 `leftright.py` 提供。计算权重的公式可能需要一些解释：为了将最大权重 1.0 分配给位于对象中心最远处的点，我们必须按可能的最大距离进行缩放。我们可以遍历所有顶点以确定最大值，但在这里我们选择通过尺寸的均方根来近似这个最大值。这将夸大最大距离，因此分配给任何顶点的最大权重可能小于
    1.0。然而，获取尺寸比计算大型网格的确切最大值要快得多。此外，请注意，我们计算对象中心到距离（从网格中顶点的角度来看，对象中心始终在 (0, 0, 0)）。
- en: This may be completely different from what may be perceived by the user as the
    center of the mesh. (The object center is normally displayed as a pink dot in
    Blender and may be changed to lie at the average position of all vertices by selecting
    **Object | Transform | Center new**.)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能与用户感知的网格中心完全不同。（在 Blender 中，对象中心通常以一个粉红色点显示，并且可以通过选择 **对象 | 变换 | 中心新** 来改变，使其位于所有顶点的平均位置。）
- en: 'The resulting weights for a mesh might looks like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的结果权重可能如下所示：
- en: '![Code outline: leftright.py](img/0400-03-02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要：leftright.py](img/0400-03-02.jpg)'
- en: Modifiers
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改器
- en: '**Modifiers** are tools that change a mesh in a non-destructive way and that
    can be adjusted interactively. Other objects may have modifiers as well: `Text3d`,
    `Metaballs`, and `Curves` for example. These objects may be represented as meshes
    so they can be modified as well. Not all modifiers can be associated with these
    objects though. If desired, the effects of modifiers can be made permanent by
    *applying* them. Blender provides a whole host of modifiers ranging from subsurface
    modifiers to all sorts of deformation modifiers. The table shows the list of available
    modifiers:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**修改器** 是以非破坏性方式更改网格的工具，并且可以交互式调整。其他对象也可能有修改器：例如 `Text3d`、`Metaballs` 和 `Curves`。这些对象可以表示为网格，因此也可以进行修改。但并非所有修改器都可以与这些对象关联。如果需要，可以通过
    *应用* 修改器的效果使其永久化。Blender 提供了从次表面修改器到各种变形修改器的一系列修改器。表中显示了可用的修改器列表：'
- en: '| Modifier | Vertex group influence | Remarks |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 修改器 | 顶点组影响 | 备注 |'
- en: '| --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| displacement | yes |   |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 位移 | 是 |   |'
- en: '| curve | yes |   |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 曲线 | 是 |   |'
- en: '| explode | yes |   |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 分解 | 是 |   |'
- en: '| lattice | yes |   |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 网格 | 是 |   |'
- en: '| mask | yes |   |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 遮罩 | 是 |   |'
- en: '| meshdeform | yes |   |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 网格变形 | 是 |   |'
- en: '| shrinkwrap | yes |   |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 收缩包裹 | 是 |   |'
- en: '| simpledeform | yes |   |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 简单变形 | 是 |   |'
- en: '| smooth | yes |   |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 平滑 | 是 |   |'
- en: '| wave | yes |   |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 波浪 | 是 |   |'
- en: '| array | no |   |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 否 |   |'
- en: '| bevel | no |   |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 倒角 | 否 |   |'
- en: '| boolean | no |   |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 并集 | 否 |   |'
- en: '| build | no |   |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 构建 | 否 |   |'
- en: '| cast | no |   |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 投影 | 否 |   |'
- en: '| decimate | no |   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 简化 | 否 |   |'
- en: '| edgesplit | no |   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 边分割 | 否 |   |'
- en: '| mirror | no |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 镜像 | 否 |   |'
- en: '| subsurface | no |   |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| subsurface | no |   |'
- en: '| uvproject | no |   |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| uvproject | no |   |'
- en: '| Particle system | yes | Many parameters influenced by different vertex groups
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Particle system | yes | 许多参数受不同顶点组的影响 |'
- en: '| armature | yes | Each bone may be restricted to influence a single vertex
    group |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| armature | yes | 每个骨骼可能被限制仅影响单个顶点组 |'
- en: Many modifiers can be made to restrict their influence to a specific vertex
    group and a few modifiers are special. A particle system is considered a modifier
    although generally particle systems are managed via their own set of tools. Also,
    its relation to vertex groups is in a way reversed; instead of restricting its
    influence to the vertices within a vertex group, the weights of the vertices of
    vertex groups may influence all sorts of parameters of the particle system, such
    as emission density and velocity of the particles. We will see an example of that
    in the *Flying sparks* section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 许多修改器可以被设置为仅将它们的影响限制在特定的顶点组上，而一些修改器是特殊的。粒子系统被认为是一个修改器，尽管通常粒子系统是通过它们自己的工具集进行管理的。此外，它与顶点组的关系在某种程度上是相反的；它不是将影响限制在顶点组内的顶点上，而是顶点组的顶点权重可能影响粒子系统的各种参数，例如粒子的发射密度和速度。我们将在
    *飞溅火花* 部分看到一个例子。
- en: Armature modifiers are also somewhat special as they do not restrict their influence
    to a single vertex group. However, they may be configured to restrict the influence
    of each separate bone to a specific vertex group as we will examine in the *Bones*
    section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼修改器也是有些特殊的，因为它们不会将它们的影响限制在单个顶点组上。然而，它们可以被配置为将每个单独的骨骼的影响限制在特定的顶点组上，正如我们将在 *骨骼*
    部分中考察的那样。
- en: From a Python programmer's point of view the list of modifiers is a property
    of an object (that is, *not* of the underlying mesh). Objects referring to the
    same mesh may have different modifiers. This list contains `Modifier` objects
    and these can be added to and removed from this list, and individual modifiers
    can be moved up or down in the list. The order of modifiers is important in some
    cases. For example, adding a subsurface modifier after a mirror modifier may look
    different from adding the mirror modifier before the subsurface modifier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 程序员的角度来看，修改器列表是对象的一个属性（即，不是底层网格的属性）。引用相同网格的对象可能有不同的修改器。此列表包含 `Modifier`
    对象，并且可以添加到或从列表中删除这些对象，并且可以移动列表中的单个修改器上下。在某些情况下，修改器的顺序很重要。例如，在镜像修改器之后添加子表面修改器可能与在子表面修改器之前添加镜像修改器看起来不同。
- en: A `Modifier` object has a type and a name (initially representing its type but
    it may be set to something more appropriate). The type is one of the types from
    the list of constants in `Modifier.Types`. Each modifier object may have many
    settings indexed by keys that are defined in `Modifier.Settings`. Not all settings
    are appropriate for all types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modifier` 对象有一个类型和一个名称（最初代表其类型，但它可能被设置为更合适的内容）。类型是 `Modifier.Types` 常量列表中的一个类型。每个修改器对象可能有许多设置，这些设置通过在
    `Modifier.Settings` 中定义的键进行索引。并非所有设置都适用于所有类型。'
- en: 'If we had two objects, a mesh object named `Target` and a lattice object named
    `Deformer,` and we would like to associate the `Deformer` object as a lattice
    modifier to the `Target` object, the following code snippet would do the trick:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个对象，一个名为 `Target` 的网格对象和一个名为 `Deformer` 的晶格对象，并且我们希望将 `Deformer` 对象作为晶格修改器关联到
    `Target` 对象，以下代码片段将完成这项任务：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the `Target` object had a vertex group named `Right` consisting of the vertices
    in the right half of the `Target` object we could restrict the influence of the
    modifier by changing the `VERTGROUP` attribute. Our snippet would change to the
    following (added line highlighted):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Target` 对象有一个名为 `Right` 的顶点组，该顶点组包含 `Target` 对象右半部分的顶点，我们可以通过更改 `VERTGROUP`
    属性来限制修改器的影响。我们的片段将变为以下内容（添加的行已突出显示）：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Modifiers](img/0400-03-03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![Modifiers](img/0400-03-03.jpg)'
- en: Engraving
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 雕刻
- en: 'Consider the following problem: given some text, we want to render this text
    as sunken grooves in a surface, just like it was engraved. This is not as simple
    as it seems. It is simple enough to create a text object, of course, but in order
    to manipulate this text we would like to convert this text object to a mesh. The
    Blender GUI offers this possibility in the object menu but strangely enough, the
    Blender API does not provide an equivalent function. So, our first hurdle would
    be to convert a text object to a mesh.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下问题：给定一些文本，我们希望将此文本渲染为表面上的凹槽，就像它被雕刻出来一样。这并不像看起来那么简单。当然，创建一个文本对象很简单，但为了操纵这个文本，我们希望将这个文本对象转换为网格。Blender
    GUI 在对象菜单中提供了这种可能性，但奇怪的是，Blender API 并没有提供等效的功能。因此，我们的第一个障碍就是将文本对象转换为网格。
- en: The second problem that we have to solve is how to extrude a collection of vertices
    or edges in order to gauge out a depression in a surface. Again, there is no function
    in the Blender API for this so we will have to add this to our toolkit ourselves.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须解决的第二个问题是，如何将一组顶点或边挤出，以在表面上测量凹槽。同样，Blender API 中没有这个功能，所以我们必须自己将其添加到我们的工具包中。
- en: 'The final problem is more subtle. If we have somehow managed to create some
    sunken grooves we might want to make the edges somewhat less sharp as nothing
    in real life has perfectly sharp edges. There are various ways to go about this
    but many involve adding a modifier to our mesh. A **bevel** **modifier** might
    be enough to take away just the sharp edges but it is likely we would want to
    add a subsurface modifier to our mesh as a whole. Here we have a problem, when
    filling the gaps between the characters of our text it is very likely that we
    encounter many narrow triangles. These triangles mess up the appearance of our
    subsurface modifier as can be observed in the following figure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题更为微妙。如果我们设法创建了一些凹槽，我们可能希望使边缘不那么尖锐，因为现实生活中的东西没有完美的尖锐边缘。有各种方法可以做到这一点，但许多方法都需要在我们的网格中添加修改器。一个
    **斜面** **修改器** 可能足以去除尖锐的边缘，但我们可能还想将次表面修改器添加到整个网格中。在这里，我们遇到了一个问题，当填充文本字符之间的间隙时，我们很可能遇到许多狭窄的三角形。这些三角形破坏了我们的次表面修改器的外观，如下面的图所示：
- en: '![Engraving](img/0400-03-04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![雕刻](img/0400-03-04.jpg)'
- en: 'Two things might help to mitigate this problem. One is to add a crease weight
    to the edges of our engraved text thereby weighing these edges more than the default
    when calculating the subsurface. These may help but might also defeat the purpose
    of the modifier as it makes those edges sharper. The following figure shows the
    result: better, but still not looking great.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两点可能有助于减轻这个问题。一是给雕刻文本的边缘添加折痕权重，这样在计算次表面时，这些边缘的权重会比默认值更大。这可能有所帮助，但也可能违背修改器的目的，因为它使这些边缘更尖锐。以下图显示了结果：更好，但仍然看起来不太好。
- en: '![Engraving](img/0400-03-05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![雕刻](img/0400-03-05.jpg)'
- en: Another approach is to add an extra edge loop just outside the engraved text.
    This will add a ring of quad faces around the text making the subsurface around
    the text behave a lot better as can be seen below. In our final implementation
    we apply both solutions but first we tackle each issue one at a time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是，在雕刻文本的外侧添加一个额外的边环。这将围绕文本添加一个四边形面的环，使得文本周围的次表面行为表现得更好，如下所示。在我们的最终实现中，我们应用了这两种解决方案，但首先我们一次解决一个问题。
- en: '![Engraving](img/0400-03-06.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![雕刻](img/0400-03-06.jpg)'
- en: Converting a Text3d object to a mesh
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Text3d 对象转换为网格
- en: A `Text3d` object is basically a curve with some additional parameters. The
    data block it refers to is a Blender `Curve` object and once we know how to access
    the individual parts in the curve that make up each character in our text, we
    can convert these curves to vertices and edges. All relevant functionality can
    be found in the `Blender.Curve` and `Blender.Geometry` modules.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text3d` 对象基本上是一个带有一些额外参数的曲线。它所引用的数据块是一个 Blender `Curve` 对象，一旦我们知道了如何访问构成我们文本中每个字符的曲线的各个部分，我们就可以将这些曲线转换为顶点和边。所有相关功能都可以在
    `Blender.Curve` 和 `Blender.Geometry` 模块中找到。'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In Blender, the relation between a `Text3d` object and a `Curve` object is
    rather more subtle and confusing than described in the main text. A `Text3d` object
    is a specialized version of a `Curve` object, rather like a subclass in object-oriented
    parlance. However, in the Blender API, the `Text3d` object is not a subclass of
    `Curve`, nor are the extra attributes available on the same object instance. Sound
    confusing? It is. How would you retrieve all attributes then? The trick is that
    you can use the name of the `Text3d` object to get access to its associated `Curve`
    object as this small example shows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blender 中，`Text3d` 对象和 `Curve` 对象之间的关系比正文中所描述的要微妙和复杂得多。`Text3d` 对象是 `Curve`
    对象的一个特殊版本，类似于面向对象术语中的子类。然而，在 Blender API 中，`Text3d` 对象不是 `Curve` 的子类，而且同一对象实例上也没有额外的属性。听起来很复杂？确实如此。那么如何检索所有属性呢？技巧在于你可以使用
    `Text3d` 对象的名称来获取其关联的 `Curve` 对象，如下面的小示例所示：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we can use `txt` to access `Text3d`-specific information (for example, `txt.setText('foo')`)
    and curve to access `Curve`-specific information (for example, `curve.getNumCurves()`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `txt` 来访问 `Text3d` 特定的信息（例如，`txt.setText('foo')`）和 `curve` 来访问 `Curve`
    特定的信息（例如，`curve.getNumCurves()`）。
- en: 'A Blender `Curve` object consists of a number of `CurNurb` objects that represent
    sections of a curve. A single text character typically consists of one or two
    curve segments. The small letter *e* for example, consists of an outer curve segment
    and a small inner curve segment. `CurNurb` objects in turn consist of a number
    of **nodes** or **control points** that define the curve segment. These nodes
    are always `BezTriple` objects in the case of `Text3d` objects and Blender''s
    `Geometry` module provides us with the `BezierInterp()` function that returns
    a list of coordinates interpolated between two points. These points and the direction
    the curve takes at those points (often called a **handle**) can be taken from
    the `BezTriple` objects. The resulting code looks this (the full code is part
    of our toolkit in `Tools.py`):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 的 `Curve` 对象由多个 `CurNurb` 对象组成，这些对象代表曲线的各个部分。通常，一个文本字符由一个或两个曲线段组成。例如，小写字母
    *e* 由一个外部的曲线段和一个小的内部曲线段组成。`CurNurb` 对象反过来又由定义曲线段的多个 **节点** 或 **控制点** 组成。在这些情况下，节点始终是
    `BezTriple` 对象，而 Blender 的 `Geometry` 模块为我们提供了 `BezierInterp()` 函数，该函数返回两个点之间插值的坐标列表。这些点和曲线在这些点处的方向（通常称为
    **手柄**）可以从 `BezTriple` 对象中获取。生成的代码看起来是这样的（完整的代码是我们工具包中 `Tools.py` 部分的一部分）：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The highlighted lines show two important aspects. The first one shows the actual
    interpolation. We have renamed the rather awkwardly name `BezierInterp()` function
    to `interpolate()` and it takes five arguments. The first four are taken from
    the two `BezTriple` objects that we are interpolating between. Each `BezTriple`
    object can be accessed as a list of three vectors—the incoming handle, the position
    of the point, and the outgoing handle (see the next figure). We pass the position
    of the first point and its outgoing handle and the position of the second point
    and its ingoing handle. The fifth argument is the number of points we want the
    `interpolate()` function to return.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的线条显示了两个重要的方面。第一个显示了实际的插值。我们将名称相当不自然的 `BezierInterp()` 函数重命名为 `interpolate()`，它接受五个参数。前四个参数来自我们正在插值之间的两个
    `BezTriple` 对象。每个 `BezTriple` 对象都可以作为一个包含三个向量的列表访问——进入的手柄、点的位置和出去的手柄（参见下一图）。我们传递第一个点的位置和它的出去手柄以及第二个点的位置和它的进入手柄。第五个参数是我们希望
    `interpolate()` 函数返回的点数。
- en: '![Converting a Text3d object to a mesh](img/0400-03-07.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![将 Text3d 对象转换为网格](img/0400-03-07.jpg)'
- en: The second highlighted line takes care of **closed** **curves**, that is curves
    that have their first and last points connected. This is the case for all curves
    that form characters in a text. The function returns a list of lists. Each list
    contains all of the interpolated points (tuples of x, y, z coordinates) for each
    curve. Note that some characters consist of more than one curve. For example,
    the small letter *e* in many fonts or the letter *o* consist of two curves, one
    defining the outline of the letter and one the interior. A `Text3d` object containing
    the text `Foo` for example will return a list of five lists—the first one will
    contain the vertices defining the capital letter *F* and the second and third
    will contain the vertices for the two curves that make up the small letter *o*
    as will the fourth and fifth.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条高亮行处理**闭合曲线**，即第一条和最后一点相连的曲线。这是所有在文本中形成字符的曲线的情况。该函数返回一个列表的列表。每个列表包含每个曲线的所有插值点（x、y、z坐标的元组）。请注意，一些字符由多个曲线组成。例如，许多字体中的小写字母
    *e* 或字母 *o* 由两个曲线组成，一个定义字母的轮廓，另一个定义内部。例如，包含文本 `Foo` 的 `Text3d` 对象将返回五个列表的列表——第一个将包含定义大写字母
    *F* 的顶点，第二个和第三个将包含组成小写字母 *o* 的两个曲线的顶点，同样第四个和第五个也是如此。
- en: Extruding an edge loop
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拉伸边环
- en: '**Extrusion** is the process where we duplicate vertices (and possibly their
    connecting edges) and move them out in some direction, after which we connect
    these duplicated vertices to their origins by new edges and finish up the operation
    by creating a new face between the old and new vertices. We need it in order to
    sink the outline of our text to create a groove with vertical walls. The function
    `extrude_selected_edges()` in `Tools.py` takes a mesh and a vector as arguments
    and will extrude the vertices on selected edges in the mesh in the direction of
    the vector, adding any necessary new edges and faces. Because the techniques are
    extensions of things we''ve seen earlier the code is not shown here.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**拉伸**是我们复制顶点（以及可能连接它们的边）并将它们移动到某个方向的过程，之后我们通过新边将这些复制的顶点连接到它们的原点，并通过在旧顶点和新顶点之间创建新面来完成操作。我们需要它来将文本的轮廓下沉，以创建具有垂直壁的凹槽。`Tools.py`
    中的 `extrude_selected_edges()` 函数接受一个网格和一个向量作为参数，并将网格中选定边的顶点沿向量方向拉伸，添加任何必要的新的边和面。因为技术是早期看到的东西的扩展，所以这里没有显示代码。'
- en: Expanding an edge loop
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展边环
- en: If we have a list of edges forming a closed curve (or more than one) defining
    a character, we would like to surround those edges with an extra edge loop to
    create a better "flow" in any subsurface modifier that the end user may associate
    with our mesh. This would be a rather involved process if we would have to calculate
    this in 3D, but fortunately our converted characters have all their vertices in
    the xy plane (this is because all of the characters in a newly instantiated `Text3d`
    object lie in the xy plane)..
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个形成闭合曲线（或多个）的边列表来定义一个字符，我们希望用额外的边环包围这些边，以在最终用户可能关联到我们的网格的任何次表面修改器中创建更好的“流动”。如果我们不得不在3D中计算这个，这将是一个相当复杂的过程，但幸运的是，我们转换后的角色所有顶点都在xy平面上（这是因为新实例化的`Text3d`对象中的所有字符都位于xy平面上）。
- en: '![Expanding an edge loop](img/0400-03-08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![扩展边环](img/0400-03-08.jpg)'
- en: In just two dimensions this is quite a tractable problem. For each point on
    our edge loop we determine the direction of the vertex normal. The **vertex**
    **normal** is the line bisecting the angle between the two edges that share the
    point we are considering. If the two edges are co-linear (or nearly so), we take
    the vertex normal to be a line perpendicular to one of the edges. The position
    of the point to create on the new edge loop will be somewhere on this normal.
    In order to determine if we have to move outward or inward along this normal,
    we simply try one direction and check whether the new position is within the outline
    of our character. If so, we reverse the direction.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅仅两个维度中，这是一个相当容易解决的问题。对于我们的边环上的每一个点，我们确定顶点法线的方向。**顶点法线**是分割我们正在考虑的点共享的两条边之间的角度的线。如果两条边是共线的（或几乎是），我们将顶点法线视为垂直于其中一条边的线。要在新边环上创建的点将位于这条法线的某个位置。为了确定我们是否需要沿着这条法线向外或向内移动，我们只需尝试一个方向，并检查新位置是否在我们的字符轮廓内。如果是这样，我们就反转方向。
- en: One issue needs addressing still, a character may consist of more than one curve.
    If we want to draw additional edge loops around such a character, such an edge
    loop should be beyond the outline of a character but inside any interior curve.
    In other words, if we construct a new edge loop we have to know whether a curve
    lies within another curve. If so, it is not an outline and the new edge loop should
    be constructed to lie within the curve. Therefore, our `expand()` function (shown
    in the next snippet, full code is part of `Tools.py`) takes an extra optional
    argument `plist`, which is a list of lists containing `MVert` objects defining
    additional polygons to check against. If the first point of the curve that we
    want to expand lies within any of these additional curves, we assume that the
    curve we are expanding is an **interior** **curve**. (This would be wrong if the
    interior curve would cross the exterior curve at some point, but for curves defining
    a character in a font this is never so.)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有一个问题需要解决，一个字符可能由多个曲线组成。如果我们想在这样一个字符周围绘制额外的边环，这样的边环应该位于字符轮廓之外但任何内部曲线之内。换句话说，如果我们构造一个新的边环，我们必须知道曲线是否位于另一个曲线内。如果是这样，它不是轮廓，新的边环应该构造在曲线内。因此，我们的`expand()`函数（在下一个片段中显示，完整代码是`Tools.py`的一部分）接受一个额外的可选参数`plist`，它是一个包含定义要检查的额外多边形的`MVert`对象的列表的列表。如果我们想要扩展的曲线的第一个点位于这些额外曲线中的任何一个，我们假设我们正在扩展的曲线是一个**内部****曲线**。（如果内部曲线会在某个点与外部曲线交叉，这将是不正确的，但对于定义字体中字符的曲线来说，这种情况永远不会发生。）
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The highlighted code calls a function (provided in `Tools.py`) that takes a
    list of edges that form an edge loop and returns a sorted list of vertices. This
    is necessary because our `in_polygon()` function takes a list of vertices rather
    than edges and assumes that this list is sorted, that is adjacent vertices form
    edges that do not cross.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 高亮代码调用一个函数（在`Tools.py`中提供），该函数接受形成一个边环的边列表，并返回一个排序后的顶点列表。这是必要的，因为我们的`in_polygon()`函数接受一个顶点列表而不是边，并假设这个列表是排序的，即相邻顶点形成不交叉的边。
- en: 'To determine whether a point is inside a closed polygon defined by a list of
    vertices, we count the number of edges that are crossed by a line (often called
    a **ray**) that starts at the point and extends to infinity. If the number of
    edges crossed is odd, the point will lie inside the polygon; if it''s even, it
    lies outside of the polygon. The following figure illustrates the concept:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定一个点是否在由顶点列表定义的闭合多边形内部，我们计算一条线（通常称为**射线**）穿过的边的数量，这条线从点开始并延伸到无穷大。如果穿过的边的数量是奇数，则点位于多边形内部；如果是偶数，则位于多边形外部。以下图示说明了这个概念：
- en: '![Expanding an edge loop](img/0400-03-09.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![扩展边环](img/0400-03-09.jpg)'
- en: The function `in_polygon()` shown here is part of `Tools.py`. It takes a point
    (a `Vector`) and a list of vertices (`MVert` objects) and returns either `True`
    or `False`. Note that any z-coordinate in either the point or the vertices in
    the polygon is ignored.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的`in_polygon()`函数是`Tools.py`的一部分。它接受一个点（一个`Vector`）和一个顶点列表（`MVert`对象），并返回`True`或`False`。请注意，多边形中点或顶点的任何z坐标都被忽略。
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The heavy lifting is done in the highlighted line by the `LineIntersect2D()`
    function available in the `Blender.Geometry` module. The *modulo* (`%`) operation
    in the `return` statement is a way to determine whether the encountered number
    of intersections is odd.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 重的劳动是在高亮行中由`Blender.Geometry`模块中可用的`LineIntersect2D()`函数完成的。`return`语句中的`modulo`（`%`）操作是一种确定遇到的交点数是否为奇数的方法。
- en: 'Putting it all together: Engrave.py'
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有这些放在一起：Engrave.py
- en: 'Armed with all the supporting functions developed in the previous sections,
    we can make a list of the steps that we''ll have to undertake in order to engrave
    a text:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 带着在前几节中开发的全部辅助函数，我们可以列出为了雕刻文本我们需要执行的步骤：
- en: Show a pop up to enter a string to engrave.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个弹出窗口以输入要雕刻的字符串。
- en: Check whether the active object is a mesh and has faces selected.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查活动对象是否是网格并且有面被选中。
- en: Create a `Text3d` object.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Text3d`对象。
- en: Convert it to a mesh, with appropriate vertex groups.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换为网格，并添加适当的顶点组。
- en: Add extra edge loops to the characters.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为字符添加额外的边环。
- en: Extrude the original characters downward.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向下挤出原始字符。
- en: Fill the bottom of the extruded characters.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充挤出字符的底部。
- en: Add a "cartouche" (a rectangle) around the text.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本周围添加一个“卷轴”（一个矩形）。
- en: Fill the space between the cartouche and the characters.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充卷轴和字符之间的空间。
- en: Add a subsurface modifier.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个子表面修改器。
- en: Set a crease value in the edges contained in `TextTop` and `TextBottom` vertex
    groups.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TextTop`和`TextBottom`顶点组中包含的边缘上设置折痕值。
- en: 'Our final script follows this outline almost exactly and makes use of the tools
    that we developed earlier in this chapter. We show the most relevant sections
    here (the full script is available as `engrave.py`). We start off by converting
    a `Text3d` object (`c` in the following code) to a list containing a list of vertex
    positions for each curve segment in the text and we add a new empty `Mesh` object
    to the scene with some empty vertex groups:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终的脚本几乎遵循这个大纲，并使用了我们在本章早期开发的工具。我们在这里展示最相关的部分（完整的脚本作为`engrave.py`提供）。我们首先将`Text3d`对象（以下代码中的`c`）转换为包含每个文本曲线段顶点位置的列表，并在场景中添加一个新的空`Mesh`对象和一些空顶点组：
- en: '[PRE7]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next step is to add these vertices to the mesh and create connecting edges.
    As all curve segments in a character are closed, we have to take care to add an
    extra edge to bridge the gap between the last and first vertex as shown in the
    highlighted line. For good measure, we remove any doubles that may be present
    in the interpolated curve segment. We add the vertices to the `TextTop` vertex
    group and store the list of new edges for future reference.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将这些顶点添加到网格中并创建连接边缘。由于字符中的所有曲线段都是闭合的，我们必须注意添加一个额外的边缘来连接最后一个和第一个顶点，如高亮行所示。为了保险起见，我们删除可能存在于插值曲线段中的任何重复项。我们将顶点添加到`TextTop`顶点组中，并存储新边缘的列表以供将来参考。
- en: '[PRE8]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For each edge loop that we stored in the previous part we construct a new,
    and slightly larger, edge loop around it and add these new vertices and edges
    to our mesh. We want to construct faces between these edge loops as well and that
    is started at the highlighted line: here we use the Python built-in function `zip()`
    to pair the edges of the two edge loops. Each edge loop is ordered by a `utility`
    function (available in `Tools.py`) that sorts edges to lie in the order in which
    they are connected to each other. For each pair of edges we construct two possible
    arrangements of vertex indices and calculate which of them forms an untwisted
    face. This calculation is done by the `least_warped()` function (code not shown)
    that basically compares the circumference of the faces defined by the two different
    orderings of vertices. The untwisted face will have the shortest circumference,
    which is then added to the mesh.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在上一部分存储的每个边缘环路，我们围绕它构建一个新的、略微更大的边缘环路，并将这些新顶点和边缘添加到我们的网格中。我们还想在这些边缘环路之间构建面，这从高亮行开始：在这里，我们使用Python内置函数`zip()`来配对两个边缘环路的边缘。每个边缘环路都通过一个`utility`函数（在`Tools.py`中可用）进行排序，该函数将边缘排序为它们相互连接的顺序。对于每一对边缘，我们构建两种可能的顶点索引排列，并计算哪一种形成一个未扭曲的面。这种计算是通过`least_warped()`函数（代码未显示）完成的，该函数基本上比较由两种不同的顶点排序定义的面的周长。未扭曲的面将具有最短的周长，然后将其添加到网格中。
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We omitted the code to extrude the character edge loop, but the following lines
    are informative as they show how to fill an edge loop. First, we select all relevant
    edges by using two utility functions (these are the extruded edges of the characters).
    Next, we call the `fill()` method. This method will fill any collection of closed
    edge loops as long as they lie in the same plane. It even takes cares of holes
    (like the little island in the letter *e*):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了挤出字符边缘环路的代码，但以下行提供了信息，展示了如何填充边缘环路。首先，我们通过使用两个实用函数（这些是字符的挤出边缘）选择所有相关边缘。接下来，我们调用`fill()`方法。只要这些封闭的边缘环路位于同一平面内，此方法就会填充任何集合。它甚至还会处理孔洞（如字母*e*中的小岛）：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Adding the cartouche is simply a matter of adding a rectangular edge loop around
    our characters. If this edge loop is selected together with the vertices in the
    `Outline` vertex group, the `fill()` method can be used again to fill up this
    cartouche. This is not shown here. We end with some finishing touches: we convert
    the triangles in our mesh as much as possible to quads by using the `triangleToQuad()`
    method and then subdivide the mesh. We also add a subsurface modifier, set the
    `smooth` attribute on all the faces, and recalculate all face normals to point
    consistently outward.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 添加边框只是在我们的人物周围添加一个矩形边缘环路的问题。如果此边缘环路与`Outline`顶点组中的顶点一起选择，则可以再次使用`fill()`方法填充此边框。这里没有展示。我们以一些收尾工作结束：我们尽可能使用`triangleToQuad()`方法将网格中的三角形转换为四边形，然后细分网格。我们还添加了一个子表面修改器，将所有面的`smooth`属性设置为平滑，并重新计算所有面的法线，使其一致地指向外部。
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The hidden Hook modifier:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏的钩子修改器**：'
- en: We have seen that the modifiers available in Blender can be added to an object
    in Python. There is, however, one modifier that can be added but seems to have
    no equivalent within the Blender GUI. This is the so-called **Hook** **modifier**.
    A Hook in Blender is a way to parent vertices to an object (so it's the reverse
    of vertex parenting where we parent an object to a vertex) and in the application
    itself can be accessed through the **Mesh | Vertex | Add Hook** menu in *edit*
    mode. Once added, it will show up in the list of modifiers. From a programmer's
    view the Hook modifier is no different from other modifiers but alas neither its
    type nor the settings needed are documented in the API.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Blender中可用的修改器可以通过Python添加到对象中。然而，有一个修改器可以添加，但在Blender的GUI中似乎没有等效的修改器。这就是所谓的**钩子**修改器。在Blender中，钩子是一种将顶点连接到对象的方式（因此它是顶点父化的逆过程，其中我们将对象连接到顶点）。在应用程序本身中，可以通过*编辑*模式下的**网格
    | 顶点 | 添加钩子**菜单访问它。一旦添加，它将出现在修改器列表中。从程序员的视角来看，钩子修改器与其他修改器没有区别，但遗憾的是，其类型和API中需要的设置都没有被记录。
- en: Flying sparks
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 飞溅的火花
- en: Sparks and all sorts of glowing effects can readily be created by adding a suitable
    particle system to an object. Many of the particle systems' parameters can be
    controlled by the weight of vertices in a vertex group, including the local density
    of the emitted particles.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向对象添加合适的粒子系统，可以轻松地创建火花和各种发光效果。许多粒子系统的参数可以通过顶点组的顶点权重来控制，包括发射粒子的局部密度。
- en: In this example we would like to mimic the behavior of the electrical phenomenon
    called "St Elmo's fire". This is the effect that under certain circumstances,
    especially in the advance of a thunderstorm, some objects start to glow. This
    glow is called **corona discharge** ([http://en.wikipedia.org/wiki/St._Elmo%27s_fire](http://en.wikipedia.org/wiki/St._Elmo%27s_fire))
    and is most prominent at sharp and protruding parts of larger structures, for
    example, radio antennae or lightning rods where the electric field that causes
    the effect is strongest.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要模拟被称为“圣埃尔摩之火”的电气现象。这是在某些情况下，尤其是在雷暴来临之际，一些物体开始发光的现象。这种发光被称为**电晕放电**([http://en.wikipedia.org/wiki/St._Elmo%27s_fire](http://en.wikipedia.org/wiki/St._Elmo%27s_fire))，并且在大型结构的尖锐和突出部分最为明显，例如无线电天线或避雷针，那里的电场是造成这种现象的最强。
- en: In order to influence the number of particles emitted from the mesh in a believable
    manner we need to calculate a quantity named local curvature and store this curvature
    suitably scaled as weights in a vertex group. Then, we can apply this vertex group
    to the density parameter in the **extra** panel of the particle's context to control
    the emission.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以令人信服的方式影响从网格发射出的粒子数量，我们需要计算一个名为局部曲率的量，并将这个曲率以适当缩放的权重形式存储在顶点组中。然后，我们可以将这个顶点组应用到粒子上下文中的**额外**面板的密度参数上，以控制发射。
- en: A mesh may have any form, and most of the time there is no neat formula that
    approximates the form. Therefore, we approximate the local curvature in a necessarily
    crude way (for more details and some heavy math, see [http://en.wikipedia.org/wiki/Mean_curvature](http://en.wikipedia.org/wiki/Mean_curvature))
    by calculating the average of all edge curvatures of the connected edges for every
    vertex in the mesh. Here we define the **edge** **curvature** as the dot product
    of the normalized vertex normal and the edge vector (that is, the vector form
    the vertex to its neighbor). This product will be negative if the edge curves
    down relative to the normal and positive if it curves up. We will reverse this
    sign as we are more accustomed with the notion of a positive curvature for spikes
    rather than for troughs. Another way to look at this is that in areas of positive
    curvature, the angle between the vertex normal and an edge starting at the same
    vertex is larger than 90°.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网格可以具有任何形状，大多数情况下没有整洁的公式可以近似其形状。因此，我们以必要而粗略的方式近似局部曲率（更多细节和一些复杂的数学，请参阅[http://en.wikipedia.org/wiki/Mean_curvature](http://en.wikipedia.org/wiki/Mean_curvature))，通过计算网格中每个顶点连接边的所有边曲率的平均值。在这里，我们定义**边曲率**为归一化顶点法向量和边向量的点积（即从顶点到其邻居的向量形式）。如果边相对于法线向下弯曲，则该乘积将为负，如果边向上弯曲，则乘积为正。我们将反转这个符号，因为我们更习惯于将正曲率与尖峰而不是与凹槽联系起来。另一种看待这个问题的方式是，在正曲率区域，顶点法向量和从同一顶点开始的边之间的角度大于90°。
- en: The following figure illustrates the concept—it depicts a series of vertices
    linked by edges. Each vertex has an associated vertex normal shown (the arrows).
    The vertices marked **a** have a positive curvature, the ones marked **b** a negative
    curvature. Two of the shown vertices labeled with **c** are in an area of zero
    curvature—that is, at those locations the surface is flat and the vertex normal
    perpendicular to the edges.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了这个概念——它描绘了一系列通过边连接的顶点。每个顶点都有一个关联的顶点法线显示（箭头）。标记为 **a** 的顶点具有正曲率，标记为 **b**
    的顶点具有负曲率。有两个标记为 **c** 的顶点位于零曲率区域——也就是说，在这些位置，表面是平的，顶点法线垂直于边。
- en: '![Flying sparks](img/0400-03-10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![飞溅的火花](img/0400-03-10.jpg)'
- en: Calculating the local curvature
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算局部曲率
- en: 'The function that calculates the local curvature for each vertex in a mesh
    and returns a list of normalized weights may be implemented as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 计算网格中每个顶点的局部曲率并返回一个包含归一化权重的列表的函数可以如下实现：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The function `localcurvature()` takes a mesh and one optional argument and returns
    a list of tuples with the vertex index and its weight. If the optional argument
    is `true` any negative weight calculated is discarded.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `localcurvature()` 接收一个网格和一个可选参数，并返回一个包含顶点索引及其权重的元组列表。如果可选参数为 `true`，则丢弃计算出的任何负权重。
- en: The hard work is done in the highlighted lines. Here we loop over all vertices
    and then, in an inner loop, check each connected edge to retrieve the vertex at
    the other end from a precomputed dictionary. We then calculate `dv` as the edge
    vector and append the dot-product of this edge vector and the normalized vertex
    normal to the list `dvdn`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 繁重的工作在突出显示的行中完成。在这里，我们遍历所有顶点，然后在内部循环中检查每个连接的边，从预先计算的字典中检索另一端的顶点。然后我们计算 `dv`
    作为边向量，并将此边向量与归一化顶点法线的点积追加到列表 `dvdn` 中。
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous line may look strange but it appends a tuple consisting of the
    vertex index and its average curvature, where the average is computed by summing
    the list of curvatures and dividing it by the number of values in the list. Because
    the list may be empty (this happens when the mesh contains unconnected vertices),
    we safeguard against a divide by zero error by dividing it by the length of the
    list or by one, whichever is the largest. In this way, we keep our code a little
    more readable by avoiding `if` statements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行可能看起来很奇怪，但它会附加一个由顶点索引及其平均曲率组成的元组，其中平均曲率是通过将曲率列表求和然后除以列表中的值数来计算的。因为列表可能为空（这发生在网格包含未连接的顶点时），我们通过将其除以列表长度或1（取较大者）来防止除以零错误。这样，我们通过避免
    `if` 语句使代码更易于阅读。
- en: 'Code outline: curvature.py'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码概要：curvature.py
- en: 'With the `localcurvature()` function at our disposal, the actual curvature
    script becomes quite terse (full script available as `curvature.py`):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了 `localcurvature()` 函数之后，实际的曲率脚本变得相当简洁（完整脚本作为 `curvature.py` 提供）：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The highlighted lines show how we remove a possible existing `Curvature` vertex
    group from the `Mesh` object by just trying and catching an `AtrributeError` that
    is raised when the group is not present. Next, we add again the group with the
    same name so it will be completely empty. The last highlighted line shows how
    we add each vertex separately because any vertex may have a different weight.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的行显示了如何通过尝试捕获当组不存在时引发的 `AtrributeError` 来从 `Mesh` 对象中移除可能存在的 `Curvature`
    顶点组。接下来，我们再次以相同的名称添加该组，使其完全为空。最后突出显示的行显示了如何单独添加每个顶点，因为任何顶点可能具有不同的权重。
- en: All actions are surrounded by a `try … except` construct that will catch any
    errors and that will pop up a nice informational message if anything out of the
    ordinary occurs. Most likely this will be in situations where the user forgets
    to select a `Mesh` object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作都围绕着一个 `try … except` 结构，该结构会捕获任何错误，并在发生任何异常情况时弹出一个友好的信息消息。最可能的情况是，这发生在用户忘记选择一个
    `Mesh` 对象的情况下。
- en: '![Code outline: curvature.py](img/0400-03-11.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要：curvature.py](img/0400-03-11.jpg)'
- en: 'Putting it all together: St. Elmo''s fire'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合一切：圣埃尔摩之火
- en: The illustration of the discharge from the sharp-tipped rod was made by modeling
    a simple rod object by hand and then calculating the curvature with `curvature.py`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过手动建模一个简单的杆对象并使用 `curvature.py` 计算曲率，制作了尖锐尖端杆的放电示意图。
- en: '![Putting it all together: St. Elmo''s fire](img/0400-03-12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![整合一切：圣埃尔摩之火](img/0400-03-12.jpg)'
- en: 'Then, a particle system was added and the density parameter in the extra tab
    was set to the `Curvature` vertex group. The rod and the particle system were
    given separate materials: a simple gray and white halo respectively. The particles
    were simulated for 250 frames and frame 250 was rendered for the illustration.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，添加了一个粒子系统，并在额外标签页中将密度参数设置为`Curvature`顶点组。杆和粒子系统分别赋予了不同的材质：简单的灰色和白色光环。粒子模拟了250帧，并渲染了第250帧以供插图。
- en: '![Putting it all together: St. Elmo''s fire](img/0400-03-13.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容组合在一起：圣埃尔摩之火](img/0400-03-13.jpg)'
- en: Bones
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 骨骼
- en: An armature might be considered the backbone of animation because deforming
    a mesh in a controllable way, which can be keyed at given frames, is necessary
    to enable animators to pose their characters in a well-controlled way.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼可能被认为是动画的骨干，因为以可控的方式变形网格，这可以在给定的帧上键入，对于动画师来说，这是在良好的控制下摆姿势的必要条件。
- en: Blender's armature implementation provides the rigger and animator with an overwhelmingly
    large amount of possibilities, but at the end of the day an armature is foremost
    a collection of connected bones where each bone will deform part of a mesh. The
    movements of these bones in respect to each other can be governed by several different
    constraints.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Blender的骨骼实现为绑定器和动画师提供了大量的可能性，但最终，骨骼首先是一系列连接的骨骼，其中每个骨骼将变形网格的一部分。这些骨骼相对于彼此的运动可以通过几种不同的约束来控制。
- en: While bones may be configured to work their influence via an **envelope**, thereby
    basically deforming any vertex of the target mesh within a certain radius, they
    may also be configured to deform only those vertices that belong to a vertex group
    with the same name as the name of the bone. This deformation is further controlled
    by the weight of the vertices in the vertex group enabling us to fine-tune the
    bone influence.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然骨骼可以配置为通过**包络**来施加影响，从而基本上在一定的半径内变形目标网格中的任何顶点，但它们也可以配置为仅变形与骨骼名称相同的顶点组中的顶点。这种变形进一步由顶点组中顶点的权重控制，使我们能够精细调整骨骼影响。
- en: Tick-Tock
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滴答声
- en: To illustrate the basic possibilities of an armature we will be rigging a simple
    clock model. The clock is of a single mesh consisting of three separate, non-connected
    submeshes—the body, the little hand, and the big hand. The vertices of each clock
    hand belong to two separate vertex groups—one for the bit of the clock hand connected
    to the center of the clock, and for the end of the hand itself. This setup allows
    for a cartoon-like animation where we can make the tip of the hand trail the actual
    motion for instance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明骨骼的基本可能性，我们将绑定一个简单的时钟模型。这个时钟由一个由三个独立的、非连接的子网格组成的单一网格组成——主体、小指针和大指针。每个时钟指针的顶点属于两个独立的顶点组——一个用于连接到时钟中心的指针部分，另一个用于指针本身的末端。这种设置允许进行卡通风格的动画，例如我们可以使指针的尖端跟随实际的运动。
- en: 'Code outline: clock.py'
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码概要：clock.py
- en: 'We will have to take the following steps to rig our clock in the way we intend:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取以下步骤来以我们期望的方式绑定我们的时钟：
- en: Import mesh data.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入网格数据。
- en: Create clock mesh.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建时钟网格。
- en: Create vertex groups.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建顶点组。
- en: Create armature object.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建骨骼对象。
- en: Create bones within armature.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在骨骼内创建骨骼。
- en: Associate armature modifier.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关联骨骼修改器。
- en: 'The translation from the outline to code is almost one on one and a little
    repetitive as many instructions are repeated for each bone (full code available
    as `clock.py`):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从概要到代码的转换几乎是逐字逐句的，并且有些重复，因为许多指令都要为每个骨骼重复（完整代码可在`clock.py`中找到）：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The important things are highlighted. First, we disable the envelopes and the
    `vertexGroups` properties on the armature *object*. This may seem strange but
    these properties are remnants of a time where an armature was not a modifier applied
    to a mesh, but worked its influence by being parented to the `Mesh` object (at
    least as far as I can tell, the available documentation is a bit vague about this)..
    We determine what kind of influence to use by setting properties on the armature
    *modifier*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的是重要事项。首先，我们在骨骼对象上禁用了包络和`vertexGroups`属性。这看起来可能有些奇怪，但这些属性是过去骨骼不是应用于网格的修改器，而是通过作为`Mesh`对象（至少就我所知，可用的文档对此有些含糊）的父对象来施加影响时的残留。我们通过在骨骼修改器上设置属性来确定要使用哪种影响。
- en: After associating an armature modifier with our `Mesh` object we construct our
    armature bone by bone. Before we add any bones to an armature we have to call
    its `makeEditable()` method. Note that this **edit** **mode** **for** **armatures**
    is distinct from the *edit* mode for other objects that can be set with the `Blender.Window.editMode()`
    function! Once we are done, we revert to *normal* mode again by calling the `update()`
    method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在将一个臂架修改器与我们的`Mesh`对象关联后，我们通过逐个构建臂架骨骼。在我们向臂架添加任何骨骼之前，我们必须调用其`makeEditable()`方法。请注意，这种针对臂架的**编辑**
    **模式** **用于** **臂架**是与其他对象不同的，这些对象可以通过`Blender.Window.editMode()`函数设置**编辑**模式！一旦我们完成，我们再次通过调用`update()`方法回到**正常**模式。
- en: You may have noticed that when constructing our armature we created instances
    of `Editbone` objects. Outside of the *edit* mode, these same bones are referred
    to as `Bone` objects. Both refer to the same bone but offer different functionality
    and attributes appropriate for either *edit* mode or in *object* mode. To accommodate
    the same sort of approach, Blender also provides `PoseBone` objects to manipulate
    bones in **Pose mode**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在构建我们的臂架时，我们创建了`Editbone`对象的实例。在**编辑**模式之外，这些相同的骨骼被称为`Bone`对象。两者都指向同一个骨骼，但提供了适用于**编辑**模式或**对象**模式的不同功能和属性。为了适应类似的方法，Blender还提供了`PoseBone`对象来在**姿势模式**中操纵骨骼。
- en: The bones are positioned in the armature by specifying their head and tail positions
    (the blunt and sharp end respectively when representing a bone as an octagon).
    To connect bones it is not sufficient to make the tail position of one bone equal
    to the head position of another. In order to let a bone follow the movements of
    another bone it must be parented to it. Parenting is effected by setting the `parent`
    attribute of the child to point to the parent bone object. In our example, we
    have parented each hand bone to its corresponding arm bone.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定骨骼的头和尾位置（当将骨骼表示为八边形时，分别是钝端和锐端）来在臂架中定位骨骼。为了连接骨骼，仅将一个骨骼的尾位置设置为另一个骨骼的头位置是不够的。为了使一个骨骼跟随另一个骨骼的运动，它必须被设置为它的父对象。通过将子对象的`parent`属性设置为指向父骨骼对象来实现父化。在我们的示例中，我们将每个手骨与其对应的臂骨进行了父化。
- en: Bones within an armature are indexed by their name. If the `VGROUPS` property
    of an armature modifier is set, the name of the bone should be identical to the
    name of the vertex group that it influences.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 臂架内的骨骼通过其名称进行索引。如果臂架修改器的`VGROUPS`属性被设置，骨骼的名称应该与其影响的顶点组的名称相同。
- en: 'The final line of our example code is important as well; it is necessary to
    parent the `Mesh` object to the armature. This might seem superfluous in situations
    where the armature and the mesh will stay in the same location and only the individual
    bones in the armature will move; but failing to do so will result in an erratic
    display of the mesh when interactively changing a pose (you will have to change
    the mesh to *edit* mode and back, for example to see the effect of the pose on
    the armature, which is completely unworkable). The result of our rigging will
    look like this (we set the display mode of the armature to x-ray to make it visible
    through the mesh):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例代码的最后一行同样很重要；必须将`Mesh`对象设置为臂架的父对象。在臂架和网格将保持在同一位置且只有臂架中的单个骨骼会移动的情况下，这可能会显得有些多余；但如果不这样做，在交互式更改姿势时将导致网格显示异常（例如，您必须将网格更改为**编辑**模式然后再返回，例如，以查看姿势对臂架的影响，这是完全不实用的）。我们的绑定结果将看起来像这样（我们将臂架的显示模式设置为X射线，以便通过网格可见）：
- en: '![Code outline: clock.py](img/0400-03-14.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要：clock.py](img/0400-03-14.jpg)'
- en: 'The rendered result may look like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染结果可能看起来像这样：
- en: '![Code outline: clock.py](img/0400-03-15.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要：clock.py](img/0400-03-15.jpg)'
- en: We might want to limit the motion of the individual bones to just rotations
    around the z-axis and this may be accomplished by adding constraints. We will
    encounter constraints in the next chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要限制单个骨骼的运动仅限于围绕z轴的旋转，这可以通过添加约束来实现。我们将在下一章中遇到约束。
- en: Get a bit of backbone boy!
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好吧，有点像 backbone boy！
- en: What we have learned so far about rigging can be applied to `creepycrawlies.py`
    as well. If we want to extend the functionality of the generated model, we may
    associate an armature modifier with the generated mesh. We have to create an armature
    object as well, with an appropriate set of bones.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止关于绑定的知识也可以应用到`creepycrawlies.py`中。如果我们想扩展生成的模型的功能，我们可以将一个臂架修改器与生成的网格关联起来。我们必须创建一个带有适当骨骼集的臂架对象。
- en: Our task is made light as we already have the vertices grouped by body part
    in the `mymesh` module, so associating them with a vertex group and a matching
    bone is trivial. Not so trivial is to create the bones themselves as these might
    be many and should be positioned and connected in the correct way.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在`mymesh`模块中将顶点按身体部位分组，因此将它们与顶点组和一个匹配的骨骼关联是微不足道的。但创建骨骼本身可能很多，并且应该以正确的方式定位和连接，这并不简单。
- en: 'Let''s look at how some of the essential elements might be implemented (the
    full code is in `creepycrawlies.py`). First we have to create an armature and
    make it editable in order to add bones:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些基本元素可能如何实现（完整的代码在`creepycrawlies.py`中）。首先，我们必须创建一个骨架并使其可编辑，以便添加骨骼：
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We may also set any attributes that alter the behavior of the armature or the
    way it is displayed. Here we just enable the `autoIK` feature as this will make
    manipulating the possibly very long tail of our creature a lot simpler for the
    animator.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置任何改变骨架行为或显示方式的属性。在这里，我们只是启用`autoIK`功能，这将使动画师操纵我们生物体可能非常长的尾巴变得更加简单。
- en: 'The next step is to create a bone for each set of vertices. The `vgroup` list
    in the following code contains tuples (`vg,vlist,parent,connected`) where `vg`
    is the name of the vertex group and `vlist` is the list of vertex indices belonging
    to this group. Each bone that we create may have a parent and it may be physically
    connected to the parent. These conditions are signaled by the `parent` and `connected`
    members of the tuple:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为每组顶点创建一个骨骼。以下代码中的`vgroup`列表包含元组（`vg,vlist,parent,connected`），其中`vg`是顶点组的名称，`vlist`是属于此组的顶点索引列表。我们创建的每个骨骼可能有一个父级，并且它可能物理上连接到父级。这些条件由元组的`parent`和`connected`成员表示：
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For each bone we create we calculate the bounding box of all the vertices in
    the vertex group that this bone will influence. The next thing will be to position
    the bone. The way we have set up our creature, all segments of its body will extend
    along the y-axis except for the wings and legs. These extend along the x-axis.
    We check this first and set the `axis` variable accordingly:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们创建的每个骨骼，我们计算该骨骼将影响的顶点组中所有顶点的边界框。接下来要做的事情是定位骨骼。根据我们的设置，我们生物体的所有身体段都将沿着y轴延伸，除了翅膀和腿，它们沿着x轴延伸。我们首先检查这一点，并相应地设置`axis`变量：
- en: '[PRE18]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Bones within the armature are indexed by name and the positions of the bone
    ends are stored in its `head` and `tail` attributes respectively. So, if we have
    a parent bone and we want to determine its average y-coordinate we can calculate
    that in the following manner:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架内的骨骼按名称索引，骨骼末端的坐标分别存储在其`head`和`tail`属性中。因此，如果我们有一个父级骨骼，并且我们想确定其平均y坐标，我们可以按以下方式计算：
- en: '[PRE19]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We calculate this position because parts such as legs and wings have parent
    bones (that is, they move along with the parent bone) but are not connected from
    head to tail. We will position these bones starting at the center of the parent
    bone and for that we need the y-position of the parent. The bones of segments
    lying along the y-axis are positioned along the y-axis themselves and so have
    zero x and z-coordinates. The x and z-coordinates of leg and wing segments are
    taken from their bounding boxes. If the bone *is* connected, we simply set its
    head position to a copy of the position of the tail of the parent (highlighted
    below).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算这个位置是因为像腿和翅膀这样的部分有父级骨骼（即，它们随着父级骨骼移动）但不是从头到尾连接。我们将从父级骨骼的中心开始定位这些骨骼，为此我们需要父级的y坐标。沿着y轴排列的骨骼段沿着y轴定位，因此它们的x和z坐标为零。腿和翅膀段段的x和z坐标来自它们的边界框。如果骨骼*是*连接的，我们只需将其头部位置设置为父级尾巴位置的副本（如下所示）。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Blender `Vector` class provides the `copy()` function but oddly enough not
    the `__copy__()` function, so it won't play nice with the functions from Python's
    `copy` module.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Blender的`Vector`类提供了`copy()`函数，但奇怪的是没有提供`__copy__()`函数，所以它不会与Python的`copy`模块中的函数很好地配合。
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The final steps in creating a bone are adding it to the armature and setting
    bone-specific options and any parent relationship.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建骨骼的最终步骤是将它添加到骨架中，并设置骨骼特定的选项以及任何父级关系。
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that in the preceding code, the order of the operations is significant:
    the `parent` attribute may only be cleared on bones that are added to an armature
    and the `CONNECTED` option may only be set on a bone with a parent.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，操作顺序很重要：`parent`属性只能在添加到骨架的骨骼上清除，`CONNECTED`选项只能在具有父级的骨骼上设置。
- en: Again, we should beware of some Blender peculiarity here. A parent may be set
    on a bone by assigning to its `parent` attribute. If it has no parent, this attribute
    will return `None`. We cannot *assign* `None` to this attribute however, we must
    use the `clearParent()` function to remove a parent relationship.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们应该注意Blender的一些特性。可以通过将其`parent`属性分配给骨骼来设置骨骼的父对象。如果没有父对象，此属性将返回`None`。然而，我们不能将`None`分配给此属性，我们必须使用`clearParent()`函数来移除父关系。
- en: '![Get a bit of backbone boy!](img/0400-03-16.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![Get a bit of backbone boy!](img/0400-03-16.jpg)'
- en: Materials
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料
- en: Materials are what give an object its outward appearance. In Blender, materials
    are extremely versatile and because of that rather complex. Almost any aspect
    of the way light behaves when reflecting from an object may be controlled and
    that not only by simple parameters, but by image maps and node networks as well.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 材料是赋予对象外观的东西。在Blender中，材料非常灵活，因此相对复杂。几乎可以控制从对象反射的光的任何方面，不仅可以通过简单的参数，还可以通过图像映射和节点网络来实现。
- en: Up to 16 materials can be associated with an object and, within an object, individual
    parts can refer to one of these 16 materials. In `Text3d` objects, each individual
    character may refer to a different material and in curves this is true for each
    control point.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最多可以与一个对象关联16种材料，并且在一个对象内部，各个部分可以引用这16种材料中的任意一种。在`Text3d`对象中，每个单独的字符可能引用不同的材料，而在曲线中，这一点适用于每个控制点。
- en: From a developer's point of view, assigning materials to objects is a two-step
    process. First, we have to define a new material, and then we have to assign a
    material or materials to an object. The first step may be omitted if we can refer
    to already existing materials.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，将材料分配给对象是一个两步的过程。首先，我们必须定义一种新材料，然后我们必须将材料或材料分配给一个对象。如果我们能引用已经存在的材料，第一步可以省略。
- en: If an object like a mesh already has faces defined we then still have to assign
    a material to each face. Newly created faces will have the active material assigned
    if the active material is defined.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象如网格已经定义了面，那么我们仍然需要为每个面分配一种材料。如果定义了活动材料，新创建的面将分配活动材料。
- en: A small code snippet illustrates how we can assign materials to a `Mesh` object.
    Here we assign a material with a white diffuse color to all even numbered faces
    and one with a black diffuse color to all odd numbered faces in a `Mesh` object
    referred to as `ob`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的代码片段说明了我们如何将材料分配给`Mesh`对象。在这里，我们将具有白色漫反射颜色的材料分配给所有偶数编号的面，并将具有黑色漫反射颜色的材料分配给所有奇数编号的面，在一个称为`ob`的`Mesh`对象中。
- en: '[PRE23]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The highlighted line makes sure that the material indices used in each face
    refer to the materials assigned to the object. (It is also possible to associate
    materials with the mesh data as we will see in the next section.)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行确保每个面使用的材料索引指向分配给对象的材料。（我们将在下一节中看到，也可以将材料与网格数据关联。）
- en: Object materials versus ObData materials
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象材料与ObData材料
- en: In Blender, both a `Mesh` object and the top-level Blender object containing
    the `Mesh` object may have their own list of 16 materials. This is convenient
    if we would want to instance many copies of the same mesh but with different materials
    applied. However, in some situations we might want to apply some or all of the
    materials to the `Mesh` instead of to the object. This is controlled by the `colbits`
    attribute of the object. This attribute consists of 16 bits, each bit indicating
    whether to use the material from the Object or that from the `Mesh`. We saw an
    example of that already in the previous section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中，一个`Mesh`对象和包含`Mesh`对象的最顶层Blender对象都可以有自己的16种材料列表。如果我们想要实例化许多具有不同材料的应用的相同网格副本，这很方便。然而，在某些情况下，我们可能希望将一些或所有材料应用于`Mesh`而不是对象。这由对象的`colbits`属性控制。此属性由16位组成，每一位指示是否使用对象或`Mesh`中的材料。我们已经在上一节中看到了一个例子。
- en: 'A `Curve` object may also have its own set of materials, and selecting the
    actual material obeys the same rules as for a `Mesh` object. Metaballs do have
    their own set of materials as well and switching between the sets of materials
    is effected in the same way, but unlike many types of objects that consist of
    parts (see next section) there is no way to associate different materials with
    different elements within a Metaball (this is true in the GUI as well: the buttons
    in the Links and Materials of the Edit context exist to assign material indices
    to individual metaball elements but they have no effect). Just the first slot
    of the list of materials is used.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Curve`对象也可能有自己的材料集，选择实际材料遵循与`Mesh`对象相同的规则。元球也有自己的材料集，在材料集之间切换的方式也是相同的，但与由部分组成的许多类型对象不同（参见下一节），无法将不同的材料与元球内的不同元素关联起来（这在GUI中也是如此：编辑上下文中的链接和材料中的按钮用于将材料索引分配给单个元球元素，但它们没有效果）。只使用材料列表中的第一个槽位。'
- en: Note that objects that are not rendered themselves, such as armatures and lattices,
    have no associated materials (that is, any materials associated with the top-level
    Object containing the armature or lattice is ignored). Some objects that do not
    have associated materials may have textures associated to them. The `World` and
    `Lamp` objects for example may have associated textures to control their colors.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，不自行渲染的对象，如骨架和格子，没有关联的材料（也就是说，与包含骨架或格子的顶级对象关联的任何材料都被忽略）。一些没有关联材料的对象可能具有与之关联的纹理。例如，`World`和`Lamp`对象可能具有关联的纹理来控制它们的颜色。
- en: Assigning materials to parts of an Object
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将材料分配给对象的各个部分
- en: Within a mesh each face may have its own associated material. This material
    is identified by its index into the list of materials and stored in the `mat`
    attribute. Within a `Text3d` object, each character may have its own material,
    again identified by its index into the list of materials. This time, this index
    is not stored directly in an attribute but may be set or retrieved by `accessor`
    methods that take the index of the character in the text as argument.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个网格中，每个面可能有自己的相关材料。这种材料通过其在材料列表中的索引来识别，并存储在`mat`属性中。在一个`Text3d`对象中，每个字符可能有自己的材料，同样通过其在材料列表中的索引来识别。这次，这个索引不是直接存储在属性中，而是可以通过接受字符在文本中索引的`accessor`方法来设置或检索。
- en: Sections within a `Curve` (`CurNurb` objects) may be assigned a material index
    by their `setMatIndex()` method. The index might be retrieved from it by the corresponding
    `getMatIndex()` method. Note that associating materials with curves that consist
    of a single line without an extrusion width set or a bevel object associated will
    have no visible effects as these curves are not rendered.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Curve`（`CurNurb`对象）内的部分可以通过其`setMatIndex()`方法分配材料索引。可以通过相应的`getMatIndex()`方法从中检索索引。请注意，将材料与由单行组成且未设置挤出宽度或与斜面对象关联的曲线关联起来将没有可见效果，因为这些曲线不会被渲染。'
- en: The following snippet shows how to assign different materials to different characters
    within a `Text3d` object. The code itself is straightforward but as you may notice
    we define a list of three materials but use only one. This is wasteful but necessary
    to work around a peculiarity in `setMaterial()`. Its material index argument should
    be offset by one, for example, index 2 refers to the second material in the list,
    however, the largest index may pass is not offset by one. So if we would like
    to use two materials, we would have to use indices 1 and 2 to access materials
    0 and 1, but the actual list of materials should contain three materials, otherwise
    we can't pass 2 as an argument to `setMaterial()`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码片段显示了如何将不同的材料分配给`Text3d`对象内的不同字符。代码本身很简单，但如您所注意到的，我们定义了一个包含三个材料的列表，但只使用了一个。这是浪费的，但这是为了解决`setMaterial()`的一个特性。其材料索引参数应该偏移一个，例如，索引2指的是列表中的第二个材料，然而，可能通过的最大索引没有偏移一个。所以如果我们想使用两种材料，我们必须使用索引1和2来访问材料0和1，但实际的材料列表应该包含三个材料，否则我们无法将2作为`setMaterial()`的参数传递。
- en: '[PRE24]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The highlighted code shows the correction by `1`. The full code is provided
    as `TextColors.py`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码显示了通过`1`进行的修正。完整的代码以`TextColors.py`的形式提供。
- en: Vertex colors versus face materials
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点颜色与面材料
- en: One important aspect of dealing with materials that we have not dealt with so
    far is **vertex** **colors**. In meshes, each vertex may have its own vertex color.
    A vertex color is distinct from a material, but whether vertex colors have any
    visible effect is controlled by a material's mode flags. For a material to use
    any vertex colors its `VColPaint` bit should be set by calling its `setMode()`
    method. When used this way, vertex colors determine the diffuse color of a material
    while all the materials' regular attributes control the way this diffuse color
    is rendered. A common use for vertex colors is to *bake* computationally expensive
    effects such as ambient occlusion. Since vertex colors can be rendered very quickly,
    ambient occlusion might be approximated this way even in real-time setups such
    as in the game engine. (Approximated because it will not respond in the same way
    to changes in lighting.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未处理的一个处理材料的重要方面是**顶点** **颜色**。在网格中，每个顶点可能有自己的顶点颜色。顶点颜色与材料不同，但顶点颜色是否具有可见效果由材料的模式标志控制。为了使材料使用任何顶点颜色，其`VColPaint`位应该通过调用其`setMode()`方法来设置。当以这种方式使用时，顶点颜色确定材料的漫反射颜色，而所有材料的常规属性控制这种漫反射颜色的渲染方式。顶点颜色的一个常见用途是*烘焙*计算成本高昂的效果，如环境遮蔽。由于顶点颜色可以非常快速地渲染，因此即使在实时设置中，如游戏引擎中，也可以通过这种方式近似环境遮蔽。（近似是因为它不会以相同的方式对光照变化做出反应。）
- en: Vertex colors are stored as `Mesh`, `MCol` objects (basically RGBA tuples) in
    the `col` attribute of a face. The `col` attribute is a list containing a reference
    to an `MCol` object for each vertex in the face. This arrangement makes sense
    when you consider the fact that materials are associated with faces, not with
    vertices. When the vertex colors of vertices are different they are linearly interpolated
    across the face.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 面的`col`属性中存储了作为`Mesh`、`MCol`对象（基本上是RGBA元组）的顶点颜色。`col`属性是一个列表，包含对面的每个顶点上的`MCol`对象的引用。当你考虑到材料是与面相关而不是与顶点相关这一事实时，这种安排是有意义的。当顶点的顶点颜色不同时，它们将在面上进行线性插值。
- en: It is only possible to assign to the `col` attribute of a face if the mesh has
    its `vertexColors` attribute set to `True`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当网格的`vertexColors`属性设置为`True`时，才能将值分配给面的`col`属性。
- en: The following example snippet shows how we might set the vertex colors of a
    mesh. We choose shades of gray depending on the z-coordinate of the vertices (highlighted).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码片段显示了如何设置网格的顶点颜色。我们根据顶点的z坐标选择灰度阴影（突出显示）。
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The full code is available as `VertexColors.py`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码作为`VertexColors.py`提供。
- en: Adding materials to our engraving
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的雕刻添加材料
- en: As a finishing touch to our engraving activities we will add two materials.
    One material index is assigned to the vertices on the surface and another one
    to the vertices in the chiseled grooves. This way we can, for instance, create
    the appearance of newly created lettering in a slab of weathered stone.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的雕刻活动更加完美，我们将添加两种材料。一种材料索引分配给表面的顶点，另一种分配给雕刻的凹槽中的顶点。这样，例如，我们可以在一块风化的石头上创建新刻字母的外观。
- en: As we have earlier defined some convenient vertex groups, assigning material
    indices is a matter of iterating over all faces and assigning to each vertex of
    a face the appropriate material index depending on which vertex group a vertex
    is a member of. The function shown below takes a slightly more general approach
    as it takes a mesh and a list of regular expressions and assigns a material index
    to each face depending on whether it belongs to a vertex group that has a name
    that matches one of the regular expressions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前定义了一些方便的顶点组，因此分配材料索引只需遍历所有面，并根据顶点所属的顶点组将适当的材料索引分配给面的每个顶点。下面显示的函数采用了一种稍微更通用的方法，它接受一个网格和一个正则表达式列表，并根据它是否属于具有与正则表达式匹配的名称的顶点组，将材料索引分配给每个面。
- en: This functions makes it very easy to assign the same material index to all vertex
    groups that have similar names, for example all tail and thorax segments of the
    mesh created by `creepycrawlies.py` (these all have names such as `tail.0`, `tail.1`,
    …, and so on).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能使得将相同的材料索引分配给所有具有相似名称的顶点组变得非常容易，例如由`creepycrawlies.py`创建的网格的所有尾段和胸段（这些名称都像`tail.0`、`tail.1`……等等）。
- en: The function is available in `Tools.py`. It depends on Python's `re.search()`
    function that will match a regular expression against a string. The highlighted
    line shows that we embed the regular string in so-called anchors (`^` and `$`).
    This way a regular expression such as `aaaa` will match only a vertex group with
    the name `aaaa` and not one with the name `aaaa.0` so we can distinguish between
    them if we want. If we want to match all vertex group names that start with `tail`,
    we could pass the regular expression `tail.*` for example.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能在 `Tools.py` 中可用。它依赖于 Python 的 `re.search()` 函数，该函数将正则表达式与字符串进行匹配。高亮行显示我们嵌入所谓的锚（`^`
    和 `$`）。这样，正则表达式 `aaaa` 将仅匹配名称为 `aaaa` 的顶点组，而不是名称为 `aaaa.0` 的顶点组，这样我们就可以在需要时区分它们。如果我们想匹配所有以
    `tail` 开头的顶点组名称，我们可以传递正则表达式 `tail.*`，例如。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Regular expressions are an extremely powerful way to match strings. If you are
    unfamiliar with them you should consult the documentation of the Python module
    ([http://docs.python.org/library/re.html](http://docs.python.org/library/re.html)).
    Start with a gentler tutorial, for example, [http://docs.python.org/howto/regex.html](http://docs.python.org/howto/regex.html).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是匹配字符串的极其强大的方式。如果您不熟悉它们，您应该查阅 Python 模块的文档（[http://docs.python.org/library/re.html](http://docs.python.org/library/re.html)）。从更温和的教程开始，例如，[http://docs.python.org/howto/regex.html](http://docs.python.org/howto/regex.html)。
- en: Another thing to note in this function is the way we use set operations. These
    speed up things quite a bit as the Python set operations are extremely fast. We
    use them here to check efficiently whether the set of vertices (or rather their
    indices) that comprises a face are all in the set of vertex indices that are in
    some vertex group. We compute, in advance, both the sets of vertex indices that
    belong to a vertex group and the sets of vertex indices of each face and store
    them in dictionaries for easy access. In this way, we create those sets only once
    for each vertex group and each face respectively instead of recreating each set
    every time we match against a regular expression. For large meshes, this saves
    potentially a lot of time (at the expense of storage).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中需要注意的另一件事是我们使用集合操作的方式。这些操作大大加快了速度，因为 Python 的集合操作非常快。我们在这里使用它们来高效地检查构成面的顶点集（或更确切地说，它们的索引）是否都在某个顶点组的顶点索引集中。我们预先计算了属于顶点组的顶点索引集和每个面的顶点索引集，并将它们存储在字典中以方便访问。这样，我们只为每个顶点组和每个面分别创建这些集一次，而不是每次匹配正则表达式时都重新创建每个集。对于大型网格，这可以节省大量时间（以存储为代价）。
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Adding materials to our engraving](img/0400-03-17.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![将材质添加到我们的雕刻](img/0400-03-17.jpg)'
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw how to make life easier for our end users by defining
    vertex groups in meshes to aid in an easy selection of certain features. We also
    saw how to assign materials to vertices and how to create new materials if needed.
    First steps were taken to rig a mesh. Specifically, we learned:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何通过在网格中定义顶点组来简化最终用户的操作，从而便于轻松选择某些特性。我们还看到了如何将材质分配给顶点，以及如果需要如何创建新的材质。我们迈出了为网格设置骨架的第一步。具体来说，我们学习了：
- en: How to define vertex groups
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何定义顶点组
- en: How to assign vertices to a vertex group
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将顶点分配到顶点组
- en: How to assign materials to faces
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将材质分配给面
- en: How to assign vertex colors to vertices
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将顶点颜色分配给顶点
- en: How to set edge properties
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置边属性
- en: How to add modifiers
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何添加修改器
- en: How to skin bones
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何绑定骨骼
- en: Next up we go beyond static objects and see how to control the movement of objects.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将超越静态对象，看看如何控制对象的移动。
