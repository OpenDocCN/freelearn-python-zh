- en: Chapter 3. Vertex Groups and Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex meshes might be difficult to handle when the number of vertices is large.
    In this chapter we will look at how we can make life easier for the end user by
    defining vertex groups to label collections of vertices. We will also explore
    some of the many uses of vertex groups including their use in armatures and modifiers,
    and we will look into methods to apply different materials to different parts
    of mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define vertex groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign vertices to a vertex group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign materials to faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign vertex colors to vertices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set edge properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skin bones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Vertex Groups and Materials](img/0400-03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Vertex groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vertex** **groups** are a way to organize collections of vertices within
    a mesh. A mesh may have any number of vertex groups and any vertex within a mesh
    may be a member of more than one vertex group or may belong to no vertex group
    at all. A newly created `Mesh` object does not have any vertex groups defined.'
  prefs: []
  type: TYPE_NORMAL
- en: In their basic form, vertex groups are a valuable tool in identifying distinct
    parts of a complex mesh. By assigning vertices to vertex groups, the modeler eventually
    provides people, such as the rigger or the people who texture a model, with the
    means to easily identify and select the parts of the model they want to work on.
  prefs: []
  type: TYPE_NORMAL
- en: The use of vertex groups goes far beyond simple identification though. Many
    mesh modifiers restrict their influence to a designated vertex group and an armature
    can be configured to deform a mesh by linking the influence of each bone to a
    single vertex group. We will see examples of that later.
  prefs: []
  type: TYPE_NORMAL
- en: A vertex group is not merely a collection of vertices. Each vertex of a vertex
    group may have an associated *weight* (between zero and one) that many modifiers
    use to fine-tune their influence. A vertex may have a different weight associated
    with it in each vertex group it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: The bugs we create with `creepycrawlies.py` are an excellent example of a rather
    complex mesh with many distinct parts that would benefit greatly from defining
    vertex groups. Not only to make it simpler to select a part by name, for instance
    the head, but also to make life easier for ourselves if we want to rig the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our primary tools in creating vertex groups are the methods of `Mesh` objects
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action | Remarks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `addVertGroup(group)` | Adds a new empty vertex group. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `assignVertsToGroup(group,vertices,weight,mode)` | Adds a list of vertex
    indices to an existing vertex group with the given weight. | Mode determines what
    to do when a vertex is already a member of the vertex group. See main text for
    details. |'
  prefs: []
  type: TYPE_TB
- en: '| `getVertsFromGroup(group,weightsFlag=0,vertices)` | Returns a list of vertex
    indices (the default) or a list of (index, weight) tuples (`if` `weightsFlag`
    `=` `1`). If the vertices list is specified only those vertices that are in the
    group and in the given list are returned. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `removeVertsFromGroup(group,vertices)` | Removes a list of vertices from
    an existing vertex group. If the list is not specified all vertices are removed.
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| `renameVertGroup(groupName, newName)` | Renames a vertex group. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `getVertGroupNames()` | Returns a list of all vertex group names. |   |'
  prefs: []
  type: TYPE_TB
- en: '| `removeVertGroup(group)` | Deletes a vertex group. | Will NOT delete the
    actual vertices. |'
  prefs: []
  type: TYPE_TB
- en: 'The important concept to grasp here is that creating a vertex group and assigning
    vertices to it are two separate actions. Creating a new empty vertex group is
    done by calling the `addVertGroup()` method of your `Mesh` object. It takes a
    single string as an argument and that will be the name of the vertex group. If
    there is already a vertex group with the same name, the name will have a numerical
    suffix added to prevent a name clash, so for example: `TailSegment` may become
    `TailSegment.001`.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding vertices to an existing vertex group is done by calling the `assignVertsToGroup()`
    method of your mesh. This method will take four mandatory arguments—the name of
    the vertex group to assign the vertices to, a list of vertex indices, a weight,
    and an *assign* mode. If the vertex group does not exist, or one of the vertex
    indices points to a nonexistent vertex, an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The weight must be a value between 0.0 and 1.0; any weight larger than 1.0 is
    clamped to 1.0\. A weight smaller or equal to 0.0 will remove a vertex from the
    vertex group. If you want to assign different weights to vertices in the same
    vertex group, you have to assign them to the group with separate calls to `assignVertsToGroup()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *assign* mode comes in three flavors: `ADD`, `REPLACE`, and `SUBTRACT`.
    `ADD` will add new vertices to the vertex group and will associate the given weight
    with them. If any of the vertices in the list already exist they get the weight
    added to them. `REPLACE` will replace the weight associated with the indices in
    the list if they are members of the vertex group or do nothing otherwise. `SUBTRACT`
    will try to subtract the weight from the vertices in the list and again do nothing
    if they are not members of the vertex group. Most often when adding completely
    new vertex groups to a mesh you will use the `ADD` mode.'
  prefs: []
  type: TYPE_NORMAL
- en: A weighty issue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For our first example we will add two new vertex groups to an existing mesh
    object—one that will contain all vertices that have a positive x-coordinate and
    one that will contain the vertices with a negative x-coordinate. We will name
    these groups **Right** and **Left** respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will give each vertex in these groups a weight depending on
    its distance from its object center with larger weights for vertices that are
    farther away from the center.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code outline: leftright.py'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Schematically we will take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the active object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that it is a mesh and get the mesh data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two new vertex groups to the object—Left and Right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For all vertices in the mesh:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the weight
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the x-coordinate > 0:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add vertex index and weight to vertex group *right*
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the x-coordinate < 0:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add vertex index and weight to vertex group *left*
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to make certain that a new vertex group is empty we check if the group
    already exists and remove it if that is the case. This checking is highlighted
    in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The full script is available as `leftright.py`. The formula to calculate the
    weight may need some explanation: in order to assign a maximum weight of 1.0 to
    the points lying at the greatest distance from the center of the object we have
    to scale by the maximum distance possible. We could loop over all vertices to
    determine that maximum first, but here we choose to approximate this maximum by
    the root mean square of the size. This will exaggerate the maximum distance so
    the maximum weight assigned to any vertex will probably be less than 1.0\. However,
    getting the size is much faster than calculating the exact maximum for large meshes.
    Also, note that we calculate the distance to the object center (the object center
    from the point of view of the vertices in a mesh is always at (0, 0, 0)).'
  prefs: []
  type: TYPE_NORMAL
- en: This may be completely different from what may be perceived by the user as the
    center of the mesh. (The object center is normally displayed as a pink dot in
    Blender and may be changed to lie at the average position of all vertices by selecting
    **Object | Transform | Center new**.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting weights for a mesh might looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code outline: leftright.py](img/0400-03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Modifiers** are tools that change a mesh in a non-destructive way and that
    can be adjusted interactively. Other objects may have modifiers as well: `Text3d`,
    `Metaballs`, and `Curves` for example. These objects may be represented as meshes
    so they can be modified as well. Not all modifiers can be associated with these
    objects though. If desired, the effects of modifiers can be made permanent by
    *applying* them. Blender provides a whole host of modifiers ranging from subsurface
    modifiers to all sorts of deformation modifiers. The table shows the list of available
    modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Modifier | Vertex group influence | Remarks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| displacement | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| curve | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| explode | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| lattice | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| mask | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| meshdeform | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| shrinkwrap | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| simpledeform | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| smooth | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| wave | yes |   |'
  prefs: []
  type: TYPE_TB
- en: '| array | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| bevel | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| build | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| cast | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| decimate | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| edgesplit | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| mirror | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| subsurface | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| uvproject | no |   |'
  prefs: []
  type: TYPE_TB
- en: '| Particle system | yes | Many parameters influenced by different vertex groups
    |'
  prefs: []
  type: TYPE_TB
- en: '| armature | yes | Each bone may be restricted to influence a single vertex
    group |'
  prefs: []
  type: TYPE_TB
- en: Many modifiers can be made to restrict their influence to a specific vertex
    group and a few modifiers are special. A particle system is considered a modifier
    although generally particle systems are managed via their own set of tools. Also,
    its relation to vertex groups is in a way reversed; instead of restricting its
    influence to the vertices within a vertex group, the weights of the vertices of
    vertex groups may influence all sorts of parameters of the particle system, such
    as emission density and velocity of the particles. We will see an example of that
    in the *Flying sparks* section.
  prefs: []
  type: TYPE_NORMAL
- en: Armature modifiers are also somewhat special as they do not restrict their influence
    to a single vertex group. However, they may be configured to restrict the influence
    of each separate bone to a specific vertex group as we will examine in the *Bones*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: From a Python programmer's point of view the list of modifiers is a property
    of an object (that is, *not* of the underlying mesh). Objects referring to the
    same mesh may have different modifiers. This list contains `Modifier` objects
    and these can be added to and removed from this list, and individual modifiers
    can be moved up or down in the list. The order of modifiers is important in some
    cases. For example, adding a subsurface modifier after a mirror modifier may look
    different from adding the mirror modifier before the subsurface modifier.
  prefs: []
  type: TYPE_NORMAL
- en: A `Modifier` object has a type and a name (initially representing its type but
    it may be set to something more appropriate). The type is one of the types from
    the list of constants in `Modifier.Types`. Each modifier object may have many
    settings indexed by keys that are defined in `Modifier.Settings`. Not all settings
    are appropriate for all types.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had two objects, a mesh object named `Target` and a lattice object named
    `Deformer,` and we would like to associate the `Deformer` object as a lattice
    modifier to the `Target` object, the following code snippet would do the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `Target` object had a vertex group named `Right` consisting of the vertices
    in the right half of the `Target` object we could restrict the influence of the
    modifier by changing the `VERTGROUP` attribute. Our snippet would change to the
    following (added line highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Modifiers](img/0400-03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engraving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following problem: given some text, we want to render this text
    as sunken grooves in a surface, just like it was engraved. This is not as simple
    as it seems. It is simple enough to create a text object, of course, but in order
    to manipulate this text we would like to convert this text object to a mesh. The
    Blender GUI offers this possibility in the object menu but strangely enough, the
    Blender API does not provide an equivalent function. So, our first hurdle would
    be to convert a text object to a mesh.'
  prefs: []
  type: TYPE_NORMAL
- en: The second problem that we have to solve is how to extrude a collection of vertices
    or edges in order to gauge out a depression in a surface. Again, there is no function
    in the Blender API for this so we will have to add this to our toolkit ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final problem is more subtle. If we have somehow managed to create some
    sunken grooves we might want to make the edges somewhat less sharp as nothing
    in real life has perfectly sharp edges. There are various ways to go about this
    but many involve adding a modifier to our mesh. A **bevel** **modifier** might
    be enough to take away just the sharp edges but it is likely we would want to
    add a subsurface modifier to our mesh as a whole. Here we have a problem, when
    filling the gaps between the characters of our text it is very likely that we
    encounter many narrow triangles. These triangles mess up the appearance of our
    subsurface modifier as can be observed in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Engraving](img/0400-03-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Two things might help to mitigate this problem. One is to add a crease weight
    to the edges of our engraved text thereby weighing these edges more than the default
    when calculating the subsurface. These may help but might also defeat the purpose
    of the modifier as it makes those edges sharper. The following figure shows the
    result: better, but still not looking great.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Engraving](img/0400-03-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another approach is to add an extra edge loop just outside the engraved text.
    This will add a ring of quad faces around the text making the subsurface around
    the text behave a lot better as can be seen below. In our final implementation
    we apply both solutions but first we tackle each issue one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '![Engraving](img/0400-03-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Converting a Text3d object to a mesh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Text3d` object is basically a curve with some additional parameters. The
    data block it refers to is a Blender `Curve` object and once we know how to access
    the individual parts in the curve that make up each character in our text, we
    can convert these curves to vertices and edges. All relevant functionality can
    be found in the `Blender.Curve` and `Blender.Geometry` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Blender, the relation between a `Text3d` object and a `Curve` object is
    rather more subtle and confusing than described in the main text. A `Text3d` object
    is a specialized version of a `Curve` object, rather like a subclass in object-oriented
    parlance. However, in the Blender API, the `Text3d` object is not a subclass of
    `Curve`, nor are the extra attributes available on the same object instance. Sound
    confusing? It is. How would you retrieve all attributes then? The trick is that
    you can use the name of the `Text3d` object to get access to its associated `Curve`
    object as this small example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use `txt` to access `Text3d`-specific information (for example, `txt.setText('foo')`)
    and curve to access `Curve`-specific information (for example, `curve.getNumCurves()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A Blender `Curve` object consists of a number of `CurNurb` objects that represent
    sections of a curve. A single text character typically consists of one or two
    curve segments. The small letter *e* for example, consists of an outer curve segment
    and a small inner curve segment. `CurNurb` objects in turn consist of a number
    of **nodes** or **control points** that define the curve segment. These nodes
    are always `BezTriple` objects in the case of `Text3d` objects and Blender''s
    `Geometry` module provides us with the `BezierInterp()` function that returns
    a list of coordinates interpolated between two points. These points and the direction
    the curve takes at those points (often called a **handle**) can be taken from
    the `BezTriple` objects. The resulting code looks this (the full code is part
    of our toolkit in `Tools.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show two important aspects. The first one shows the actual
    interpolation. We have renamed the rather awkwardly name `BezierInterp()` function
    to `interpolate()` and it takes five arguments. The first four are taken from
    the two `BezTriple` objects that we are interpolating between. Each `BezTriple`
    object can be accessed as a list of three vectors—the incoming handle, the position
    of the point, and the outgoing handle (see the next figure). We pass the position
    of the first point and its outgoing handle and the position of the second point
    and its ingoing handle. The fifth argument is the number of points we want the
    `interpolate()` function to return.
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting a Text3d object to a mesh](img/0400-03-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The second highlighted line takes care of **closed** **curves**, that is curves
    that have their first and last points connected. This is the case for all curves
    that form characters in a text. The function returns a list of lists. Each list
    contains all of the interpolated points (tuples of x, y, z coordinates) for each
    curve. Note that some characters consist of more than one curve. For example,
    the small letter *e* in many fonts or the letter *o* consist of two curves, one
    defining the outline of the letter and one the interior. A `Text3d` object containing
    the text `Foo` for example will return a list of five lists—the first one will
    contain the vertices defining the capital letter *F* and the second and third
    will contain the vertices for the two curves that make up the small letter *o*
    as will the fourth and fifth.
  prefs: []
  type: TYPE_NORMAL
- en: Extruding an edge loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Extrusion** is the process where we duplicate vertices (and possibly their
    connecting edges) and move them out in some direction, after which we connect
    these duplicated vertices to their origins by new edges and finish up the operation
    by creating a new face between the old and new vertices. We need it in order to
    sink the outline of our text to create a groove with vertical walls. The function
    `extrude_selected_edges()` in `Tools.py` takes a mesh and a vector as arguments
    and will extrude the vertices on selected edges in the mesh in the direction of
    the vector, adding any necessary new edges and faces. Because the techniques are
    extensions of things we''ve seen earlier the code is not shown here.'
  prefs: []
  type: TYPE_NORMAL
- en: Expanding an edge loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we have a list of edges forming a closed curve (or more than one) defining
    a character, we would like to surround those edges with an extra edge loop to
    create a better "flow" in any subsurface modifier that the end user may associate
    with our mesh. This would be a rather involved process if we would have to calculate
    this in 3D, but fortunately our converted characters have all their vertices in
    the xy plane (this is because all of the characters in a newly instantiated `Text3d`
    object lie in the xy plane)..
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding an edge loop](img/0400-03-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In just two dimensions this is quite a tractable problem. For each point on
    our edge loop we determine the direction of the vertex normal. The **vertex**
    **normal** is the line bisecting the angle between the two edges that share the
    point we are considering. If the two edges are co-linear (or nearly so), we take
    the vertex normal to be a line perpendicular to one of the edges. The position
    of the point to create on the new edge loop will be somewhere on this normal.
    In order to determine if we have to move outward or inward along this normal,
    we simply try one direction and check whether the new position is within the outline
    of our character. If so, we reverse the direction.
  prefs: []
  type: TYPE_NORMAL
- en: One issue needs addressing still, a character may consist of more than one curve.
    If we want to draw additional edge loops around such a character, such an edge
    loop should be beyond the outline of a character but inside any interior curve.
    In other words, if we construct a new edge loop we have to know whether a curve
    lies within another curve. If so, it is not an outline and the new edge loop should
    be constructed to lie within the curve. Therefore, our `expand()` function (shown
    in the next snippet, full code is part of `Tools.py`) takes an extra optional
    argument `plist`, which is a list of lists containing `MVert` objects defining
    additional polygons to check against. If the first point of the curve that we
    want to expand lies within any of these additional curves, we assume that the
    curve we are expanding is an **interior** **curve**. (This would be wrong if the
    interior curve would cross the exterior curve at some point, but for curves defining
    a character in a font this is never so.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code calls a function (provided in `Tools.py`) that takes a
    list of edges that form an edge loop and returns a sorted list of vertices. This
    is necessary because our `in_polygon()` function takes a list of vertices rather
    than edges and assumes that this list is sorted, that is adjacent vertices form
    edges that do not cross.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether a point is inside a closed polygon defined by a list of
    vertices, we count the number of edges that are crossed by a line (often called
    a **ray**) that starts at the point and extends to infinity. If the number of
    edges crossed is odd, the point will lie inside the polygon; if it''s even, it
    lies outside of the polygon. The following figure illustrates the concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanding an edge loop](img/0400-03-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The function `in_polygon()` shown here is part of `Tools.py`. It takes a point
    (a `Vector`) and a list of vertices (`MVert` objects) and returns either `True`
    or `False`. Note that any z-coordinate in either the point or the vertices in
    the polygon is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The heavy lifting is done in the highlighted line by the `LineIntersect2D()`
    function available in the `Blender.Geometry` module. The *modulo* (`%`) operation
    in the `return` statement is a way to determine whether the encountered number
    of intersections is odd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together: Engrave.py'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Armed with all the supporting functions developed in the previous sections,
    we can make a list of the steps that we''ll have to undertake in order to engrave
    a text:'
  prefs: []
  type: TYPE_NORMAL
- en: Show a pop up to enter a string to engrave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the active object is a mesh and has faces selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Text3d` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert it to a mesh, with appropriate vertex groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add extra edge loops to the characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extrude the original characters downward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the bottom of the extruded characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a "cartouche" (a rectangle) around the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill the space between the cartouche and the characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a subsurface modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a crease value in the edges contained in `TextTop` and `TextBottom` vertex
    groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our final script follows this outline almost exactly and makes use of the tools
    that we developed earlier in this chapter. We show the most relevant sections
    here (the full script is available as `engrave.py`). We start off by converting
    a `Text3d` object (`c` in the following code) to a list containing a list of vertex
    positions for each curve segment in the text and we add a new empty `Mesh` object
    to the scene with some empty vertex groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to add these vertices to the mesh and create connecting edges.
    As all curve segments in a character are closed, we have to take care to add an
    extra edge to bridge the gap between the last and first vertex as shown in the
    highlighted line. For good measure, we remove any doubles that may be present
    in the interpolated curve segment. We add the vertices to the `TextTop` vertex
    group and store the list of new edges for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For each edge loop that we stored in the previous part we construct a new,
    and slightly larger, edge loop around it and add these new vertices and edges
    to our mesh. We want to construct faces between these edge loops as well and that
    is started at the highlighted line: here we use the Python built-in function `zip()`
    to pair the edges of the two edge loops. Each edge loop is ordered by a `utility`
    function (available in `Tools.py`) that sorts edges to lie in the order in which
    they are connected to each other. For each pair of edges we construct two possible
    arrangements of vertex indices and calculate which of them forms an untwisted
    face. This calculation is done by the `least_warped()` function (code not shown)
    that basically compares the circumference of the faces defined by the two different
    orderings of vertices. The untwisted face will have the shortest circumference,
    which is then added to the mesh.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We omitted the code to extrude the character edge loop, but the following lines
    are informative as they show how to fill an edge loop. First, we select all relevant
    edges by using two utility functions (these are the extruded edges of the characters).
    Next, we call the `fill()` method. This method will fill any collection of closed
    edge loops as long as they lie in the same plane. It even takes cares of holes
    (like the little island in the letter *e*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding the cartouche is simply a matter of adding a rectangular edge loop around
    our characters. If this edge loop is selected together with the vertices in the
    `Outline` vertex group, the `fill()` method can be used again to fill up this
    cartouche. This is not shown here. We end with some finishing touches: we convert
    the triangles in our mesh as much as possible to quads by using the `triangleToQuad()`
    method and then subdivide the mesh. We also add a subsurface modifier, set the
    `smooth` attribute on all the faces, and recalculate all face normals to point
    consistently outward.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The hidden Hook modifier:**'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that the modifiers available in Blender can be added to an object
    in Python. There is, however, one modifier that can be added but seems to have
    no equivalent within the Blender GUI. This is the so-called **Hook** **modifier**.
    A Hook in Blender is a way to parent vertices to an object (so it's the reverse
    of vertex parenting where we parent an object to a vertex) and in the application
    itself can be accessed through the **Mesh | Vertex | Add Hook** menu in *edit*
    mode. Once added, it will show up in the list of modifiers. From a programmer's
    view the Hook modifier is no different from other modifiers but alas neither its
    type nor the settings needed are documented in the API.
  prefs: []
  type: TYPE_NORMAL
- en: Flying sparks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sparks and all sorts of glowing effects can readily be created by adding a suitable
    particle system to an object. Many of the particle systems' parameters can be
    controlled by the weight of vertices in a vertex group, including the local density
    of the emitted particles.
  prefs: []
  type: TYPE_NORMAL
- en: In this example we would like to mimic the behavior of the electrical phenomenon
    called "St Elmo's fire". This is the effect that under certain circumstances,
    especially in the advance of a thunderstorm, some objects start to glow. This
    glow is called **corona discharge** ([http://en.wikipedia.org/wiki/St._Elmo%27s_fire](http://en.wikipedia.org/wiki/St._Elmo%27s_fire))
    and is most prominent at sharp and protruding parts of larger structures, for
    example, radio antennae or lightning rods where the electric field that causes
    the effect is strongest.
  prefs: []
  type: TYPE_NORMAL
- en: In order to influence the number of particles emitted from the mesh in a believable
    manner we need to calculate a quantity named local curvature and store this curvature
    suitably scaled as weights in a vertex group. Then, we can apply this vertex group
    to the density parameter in the **extra** panel of the particle's context to control
    the emission.
  prefs: []
  type: TYPE_NORMAL
- en: A mesh may have any form, and most of the time there is no neat formula that
    approximates the form. Therefore, we approximate the local curvature in a necessarily
    crude way (for more details and some heavy math, see [http://en.wikipedia.org/wiki/Mean_curvature](http://en.wikipedia.org/wiki/Mean_curvature))
    by calculating the average of all edge curvatures of the connected edges for every
    vertex in the mesh. Here we define the **edge** **curvature** as the dot product
    of the normalized vertex normal and the edge vector (that is, the vector form
    the vertex to its neighbor). This product will be negative if the edge curves
    down relative to the normal and positive if it curves up. We will reverse this
    sign as we are more accustomed with the notion of a positive curvature for spikes
    rather than for troughs. Another way to look at this is that in areas of positive
    curvature, the angle between the vertex normal and an edge starting at the same
    vertex is larger than 90°.
  prefs: []
  type: TYPE_NORMAL
- en: The following figure illustrates the concept—it depicts a series of vertices
    linked by edges. Each vertex has an associated vertex normal shown (the arrows).
    The vertices marked **a** have a positive curvature, the ones marked **b** a negative
    curvature. Two of the shown vertices labeled with **c** are in an area of zero
    curvature—that is, at those locations the surface is flat and the vertex normal
    perpendicular to the edges.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flying sparks](img/0400-03-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calculating the local curvature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function that calculates the local curvature for each vertex in a mesh
    and returns a list of normalized weights may be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The function `localcurvature()` takes a mesh and one optional argument and returns
    a list of tuples with the vertex index and its weight. If the optional argument
    is `true` any negative weight calculated is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: The hard work is done in the highlighted lines. Here we loop over all vertices
    and then, in an inner loop, check each connected edge to retrieve the vertex at
    the other end from a precomputed dictionary. We then calculate `dv` as the edge
    vector and append the dot-product of this edge vector and the normalized vertex
    normal to the list `dvdn`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The previous line may look strange but it appends a tuple consisting of the
    vertex index and its average curvature, where the average is computed by summing
    the list of curvatures and dividing it by the number of values in the list. Because
    the list may be empty (this happens when the mesh contains unconnected vertices),
    we safeguard against a divide by zero error by dividing it by the length of the
    list or by one, whichever is the largest. In this way, we keep our code a little
    more readable by avoiding `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code outline: curvature.py'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the `localcurvature()` function at our disposal, the actual curvature
    script becomes quite terse (full script available as `curvature.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines show how we remove a possible existing `Curvature` vertex
    group from the `Mesh` object by just trying and catching an `AtrributeError` that
    is raised when the group is not present. Next, we add again the group with the
    same name so it will be completely empty. The last highlighted line shows how
    we add each vertex separately because any vertex may have a different weight.
  prefs: []
  type: TYPE_NORMAL
- en: All actions are surrounded by a `try … except` construct that will catch any
    errors and that will pop up a nice informational message if anything out of the
    ordinary occurs. Most likely this will be in situations where the user forgets
    to select a `Mesh` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code outline: curvature.py](img/0400-03-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Putting it all together: St. Elmo''s fire'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The illustration of the discharge from the sharp-tipped rod was made by modeling
    a simple rod object by hand and then calculating the curvature with `curvature.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together: St. Elmo''s fire](img/0400-03-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, a particle system was added and the density parameter in the extra tab
    was set to the `Curvature` vertex group. The rod and the particle system were
    given separate materials: a simple gray and white halo respectively. The particles
    were simulated for 250 frames and frame 250 was rendered for the illustration.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together: St. Elmo''s fire](img/0400-03-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An armature might be considered the backbone of animation because deforming
    a mesh in a controllable way, which can be keyed at given frames, is necessary
    to enable animators to pose their characters in a well-controlled way.
  prefs: []
  type: TYPE_NORMAL
- en: Blender's armature implementation provides the rigger and animator with an overwhelmingly
    large amount of possibilities, but at the end of the day an armature is foremost
    a collection of connected bones where each bone will deform part of a mesh. The
    movements of these bones in respect to each other can be governed by several different
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: While bones may be configured to work their influence via an **envelope**, thereby
    basically deforming any vertex of the target mesh within a certain radius, they
    may also be configured to deform only those vertices that belong to a vertex group
    with the same name as the name of the bone. This deformation is further controlled
    by the weight of the vertices in the vertex group enabling us to fine-tune the
    bone influence.
  prefs: []
  type: TYPE_NORMAL
- en: Tick-Tock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the basic possibilities of an armature we will be rigging a simple
    clock model. The clock is of a single mesh consisting of three separate, non-connected
    submeshes—the body, the little hand, and the big hand. The vertices of each clock
    hand belong to two separate vertex groups—one for the bit of the clock hand connected
    to the center of the clock, and for the end of the hand itself. This setup allows
    for a cartoon-like animation where we can make the tip of the hand trail the actual
    motion for instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code outline: clock.py'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will have to take the following steps to rig our clock in the way we intend:'
  prefs: []
  type: TYPE_NORMAL
- en: Import mesh data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create clock mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create vertex groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create armature object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create bones within armature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Associate armature modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The translation from the outline to code is almost one on one and a little
    repetitive as many instructions are repeated for each bone (full code available
    as `clock.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The important things are highlighted. First, we disable the envelopes and the
    `vertexGroups` properties on the armature *object*. This may seem strange but
    these properties are remnants of a time where an armature was not a modifier applied
    to a mesh, but worked its influence by being parented to the `Mesh` object (at
    least as far as I can tell, the available documentation is a bit vague about this)..
    We determine what kind of influence to use by setting properties on the armature
    *modifier*.
  prefs: []
  type: TYPE_NORMAL
- en: After associating an armature modifier with our `Mesh` object we construct our
    armature bone by bone. Before we add any bones to an armature we have to call
    its `makeEditable()` method. Note that this **edit** **mode** **for** **armatures**
    is distinct from the *edit* mode for other objects that can be set with the `Blender.Window.editMode()`
    function! Once we are done, we revert to *normal* mode again by calling the `update()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that when constructing our armature we created instances
    of `Editbone` objects. Outside of the *edit* mode, these same bones are referred
    to as `Bone` objects. Both refer to the same bone but offer different functionality
    and attributes appropriate for either *edit* mode or in *object* mode. To accommodate
    the same sort of approach, Blender also provides `PoseBone` objects to manipulate
    bones in **Pose mode**.
  prefs: []
  type: TYPE_NORMAL
- en: The bones are positioned in the armature by specifying their head and tail positions
    (the blunt and sharp end respectively when representing a bone as an octagon).
    To connect bones it is not sufficient to make the tail position of one bone equal
    to the head position of another. In order to let a bone follow the movements of
    another bone it must be parented to it. Parenting is effected by setting the `parent`
    attribute of the child to point to the parent bone object. In our example, we
    have parented each hand bone to its corresponding arm bone.
  prefs: []
  type: TYPE_NORMAL
- en: Bones within an armature are indexed by their name. If the `VGROUPS` property
    of an armature modifier is set, the name of the bone should be identical to the
    name of the vertex group that it influences.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final line of our example code is important as well; it is necessary to
    parent the `Mesh` object to the armature. This might seem superfluous in situations
    where the armature and the mesh will stay in the same location and only the individual
    bones in the armature will move; but failing to do so will result in an erratic
    display of the mesh when interactively changing a pose (you will have to change
    the mesh to *edit* mode and back, for example to see the effect of the pose on
    the armature, which is completely unworkable). The result of our rigging will
    look like this (we set the display mode of the armature to x-ray to make it visible
    through the mesh):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code outline: clock.py](img/0400-03-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The rendered result may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code outline: clock.py](img/0400-03-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We might want to limit the motion of the individual bones to just rotations
    around the z-axis and this may be accomplished by adding constraints. We will
    encounter constraints in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Get a bit of backbone boy!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have learned so far about rigging can be applied to `creepycrawlies.py`
    as well. If we want to extend the functionality of the generated model, we may
    associate an armature modifier with the generated mesh. We have to create an armature
    object as well, with an appropriate set of bones.
  prefs: []
  type: TYPE_NORMAL
- en: Our task is made light as we already have the vertices grouped by body part
    in the `mymesh` module, so associating them with a vertex group and a matching
    bone is trivial. Not so trivial is to create the bones themselves as these might
    be many and should be positioned and connected in the correct way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how some of the essential elements might be implemented (the
    full code is in `creepycrawlies.py`). First we have to create an armature and
    make it editable in order to add bones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We may also set any attributes that alter the behavior of the armature or the
    way it is displayed. Here we just enable the `autoIK` feature as this will make
    manipulating the possibly very long tail of our creature a lot simpler for the
    animator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a bone for each set of vertices. The `vgroup` list
    in the following code contains tuples (`vg,vlist,parent,connected`) where `vg`
    is the name of the vertex group and `vlist` is the list of vertex indices belonging
    to this group. Each bone that we create may have a parent and it may be physically
    connected to the parent. These conditions are signaled by the `parent` and `connected`
    members of the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For each bone we create we calculate the bounding box of all the vertices in
    the vertex group that this bone will influence. The next thing will be to position
    the bone. The way we have set up our creature, all segments of its body will extend
    along the y-axis except for the wings and legs. These extend along the x-axis.
    We check this first and set the `axis` variable accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Bones within the armature are indexed by name and the positions of the bone
    ends are stored in its `head` and `tail` attributes respectively. So, if we have
    a parent bone and we want to determine its average y-coordinate we can calculate
    that in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We calculate this position because parts such as legs and wings have parent
    bones (that is, they move along with the parent bone) but are not connected from
    head to tail. We will position these bones starting at the center of the parent
    bone and for that we need the y-position of the parent. The bones of segments
    lying along the y-axis are positioned along the y-axis themselves and so have
    zero x and z-coordinates. The x and z-coordinates of leg and wing segments are
    taken from their bounding boxes. If the bone *is* connected, we simply set its
    head position to a copy of the position of the tail of the parent (highlighted
    below).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Blender `Vector` class provides the `copy()` function but oddly enough not
    the `__copy__()` function, so it won't play nice with the functions from Python's
    `copy` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The final steps in creating a bone are adding it to the armature and setting
    bone-specific options and any parent relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding code, the order of the operations is significant:
    the `parent` attribute may only be cleared on bones that are added to an armature
    and the `CONNECTED` option may only be set on a bone with a parent.'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we should beware of some Blender peculiarity here. A parent may be set
    on a bone by assigning to its `parent` attribute. If it has no parent, this attribute
    will return `None`. We cannot *assign* `None` to this attribute however, we must
    use the `clearParent()` function to remove a parent relationship.
  prefs: []
  type: TYPE_NORMAL
- en: '![Get a bit of backbone boy!](img/0400-03-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Materials are what give an object its outward appearance. In Blender, materials
    are extremely versatile and because of that rather complex. Almost any aspect
    of the way light behaves when reflecting from an object may be controlled and
    that not only by simple parameters, but by image maps and node networks as well.
  prefs: []
  type: TYPE_NORMAL
- en: Up to 16 materials can be associated with an object and, within an object, individual
    parts can refer to one of these 16 materials. In `Text3d` objects, each individual
    character may refer to a different material and in curves this is true for each
    control point.
  prefs: []
  type: TYPE_NORMAL
- en: From a developer's point of view, assigning materials to objects is a two-step
    process. First, we have to define a new material, and then we have to assign a
    material or materials to an object. The first step may be omitted if we can refer
    to already existing materials.
  prefs: []
  type: TYPE_NORMAL
- en: If an object like a mesh already has faces defined we then still have to assign
    a material to each face. Newly created faces will have the active material assigned
    if the active material is defined.
  prefs: []
  type: TYPE_NORMAL
- en: A small code snippet illustrates how we can assign materials to a `Mesh` object.
    Here we assign a material with a white diffuse color to all even numbered faces
    and one with a black diffuse color to all odd numbered faces in a `Mesh` object
    referred to as `ob`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line makes sure that the material indices used in each face
    refer to the materials assigned to the object. (It is also possible to associate
    materials with the mesh data as we will see in the next section.)
  prefs: []
  type: TYPE_NORMAL
- en: Object materials versus ObData materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Blender, both a `Mesh` object and the top-level Blender object containing
    the `Mesh` object may have their own list of 16 materials. This is convenient
    if we would want to instance many copies of the same mesh but with different materials
    applied. However, in some situations we might want to apply some or all of the
    materials to the `Mesh` instead of to the object. This is controlled by the `colbits`
    attribute of the object. This attribute consists of 16 bits, each bit indicating
    whether to use the material from the Object or that from the `Mesh`. We saw an
    example of that already in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Curve` object may also have its own set of materials, and selecting the
    actual material obeys the same rules as for a `Mesh` object. Metaballs do have
    their own set of materials as well and switching between the sets of materials
    is effected in the same way, but unlike many types of objects that consist of
    parts (see next section) there is no way to associate different materials with
    different elements within a Metaball (this is true in the GUI as well: the buttons
    in the Links and Materials of the Edit context exist to assign material indices
    to individual metaball elements but they have no effect). Just the first slot
    of the list of materials is used.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that objects that are not rendered themselves, such as armatures and lattices,
    have no associated materials (that is, any materials associated with the top-level
    Object containing the armature or lattice is ignored). Some objects that do not
    have associated materials may have textures associated to them. The `World` and
    `Lamp` objects for example may have associated textures to control their colors.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning materials to parts of an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within a mesh each face may have its own associated material. This material
    is identified by its index into the list of materials and stored in the `mat`
    attribute. Within a `Text3d` object, each character may have its own material,
    again identified by its index into the list of materials. This time, this index
    is not stored directly in an attribute but may be set or retrieved by `accessor`
    methods that take the index of the character in the text as argument.
  prefs: []
  type: TYPE_NORMAL
- en: Sections within a `Curve` (`CurNurb` objects) may be assigned a material index
    by their `setMatIndex()` method. The index might be retrieved from it by the corresponding
    `getMatIndex()` method. Note that associating materials with curves that consist
    of a single line without an extrusion width set or a bevel object associated will
    have no visible effects as these curves are not rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet shows how to assign different materials to different characters
    within a `Text3d` object. The code itself is straightforward but as you may notice
    we define a list of three materials but use only one. This is wasteful but necessary
    to work around a peculiarity in `setMaterial()`. Its material index argument should
    be offset by one, for example, index 2 refers to the second material in the list,
    however, the largest index may pass is not offset by one. So if we would like
    to use two materials, we would have to use indices 1 and 2 to access materials
    0 and 1, but the actual list of materials should contain three materials, otherwise
    we can't pass 2 as an argument to `setMaterial()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code shows the correction by `1`. The full code is provided
    as `TextColors.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex colors versus face materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important aspect of dealing with materials that we have not dealt with so
    far is **vertex** **colors**. In meshes, each vertex may have its own vertex color.
    A vertex color is distinct from a material, but whether vertex colors have any
    visible effect is controlled by a material's mode flags. For a material to use
    any vertex colors its `VColPaint` bit should be set by calling its `setMode()`
    method. When used this way, vertex colors determine the diffuse color of a material
    while all the materials' regular attributes control the way this diffuse color
    is rendered. A common use for vertex colors is to *bake* computationally expensive
    effects such as ambient occlusion. Since vertex colors can be rendered very quickly,
    ambient occlusion might be approximated this way even in real-time setups such
    as in the game engine. (Approximated because it will not respond in the same way
    to changes in lighting.)
  prefs: []
  type: TYPE_NORMAL
- en: Vertex colors are stored as `Mesh`, `MCol` objects (basically RGBA tuples) in
    the `col` attribute of a face. The `col` attribute is a list containing a reference
    to an `MCol` object for each vertex in the face. This arrangement makes sense
    when you consider the fact that materials are associated with faces, not with
    vertices. When the vertex colors of vertices are different they are linearly interpolated
    across the face.
  prefs: []
  type: TYPE_NORMAL
- en: It is only possible to assign to the `col` attribute of a face if the mesh has
    its `vertexColors` attribute set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The following example snippet shows how we might set the vertex colors of a
    mesh. We choose shades of gray depending on the z-coordinate of the vertices (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available as `VertexColors.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding materials to our engraving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a finishing touch to our engraving activities we will add two materials.
    One material index is assigned to the vertices on the surface and another one
    to the vertices in the chiseled grooves. This way we can, for instance, create
    the appearance of newly created lettering in a slab of weathered stone.
  prefs: []
  type: TYPE_NORMAL
- en: As we have earlier defined some convenient vertex groups, assigning material
    indices is a matter of iterating over all faces and assigning to each vertex of
    a face the appropriate material index depending on which vertex group a vertex
    is a member of. The function shown below takes a slightly more general approach
    as it takes a mesh and a list of regular expressions and assigns a material index
    to each face depending on whether it belongs to a vertex group that has a name
    that matches one of the regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: This functions makes it very easy to assign the same material index to all vertex
    groups that have similar names, for example all tail and thorax segments of the
    mesh created by `creepycrawlies.py` (these all have names such as `tail.0`, `tail.1`,
    …, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The function is available in `Tools.py`. It depends on Python's `re.search()`
    function that will match a regular expression against a string. The highlighted
    line shows that we embed the regular string in so-called anchors (`^` and `$`).
    This way a regular expression such as `aaaa` will match only a vertex group with
    the name `aaaa` and not one with the name `aaaa.0` so we can distinguish between
    them if we want. If we want to match all vertex group names that start with `tail`,
    we could pass the regular expression `tail.*` for example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regular expressions are an extremely powerful way to match strings. If you are
    unfamiliar with them you should consult the documentation of the Python module
    ([http://docs.python.org/library/re.html](http://docs.python.org/library/re.html)).
    Start with a gentler tutorial, for example, [http://docs.python.org/howto/regex.html](http://docs.python.org/howto/regex.html).
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note in this function is the way we use set operations. These
    speed up things quite a bit as the Python set operations are extremely fast. We
    use them here to check efficiently whether the set of vertices (or rather their
    indices) that comprises a face are all in the set of vertex indices that are in
    some vertex group. We compute, in advance, both the sets of vertex indices that
    belong to a vertex group and the sets of vertex indices of each face and store
    them in dictionaries for easy access. In this way, we create those sets only once
    for each vertex group and each face respectively instead of recreating each set
    every time we match against a regular expression. For large meshes, this saves
    potentially a lot of time (at the expense of storage).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding materials to our engraving](img/0400-03-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we saw how to make life easier for our end users by defining
    vertex groups in meshes to aid in an easy selection of certain features. We also
    saw how to assign materials to vertices and how to create new materials if needed.
    First steps were taken to rig a mesh. Specifically, we learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to define vertex groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to assign vertices to a vertex group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to assign materials to faces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to assign vertex colors to vertices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set edge properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to skin bones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next up we go beyond static objects and see how to control the movement of objects.
  prefs: []
  type: TYPE_NORMAL
