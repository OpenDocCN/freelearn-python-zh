- en: Chapter 14. Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working in a development environment, and running our application
    on the console in 'foreground' mode, so that we can see the output for debugging
    and confirmation purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a more or less complete application, we may want to deploy
    it. Even for limited audience testing, we want the deployed application to run
    in the background. Later on, we probably want to use a full-fledged web server,
    such as Apache, for serving our application, and maybe others. Finally, for an
    application that expects lots of traffic and numerous visitors, we might want
    to balance the load over multiple instances of our application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss how to deploy our application by using the standard
    paster server. Then we'll find out how to run the application behind Apache, first
    by using a simple proxy configuration, and then under `mod_wsgi`. Finally, we'll
    explore how ZEO provides horizontal scalability for our application, and will
    briefly discuss how to make a site support high traffic loads by adding caching
    and load balancing into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some specific topics that we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple deployment with paster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running behind Apache with proxy pass
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running behind Apache with `mod_wsgi`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a ZEO cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching and load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving an application to production mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before thinking about which web server we will use for our deployment, there
    is one step that we need to take for every production application. Grok offers
    a 'developer mode' for the application server, which enables some functionality
    intended to help developers debug and test their applications more easily.
  prefs: []
  type: TYPE_NORMAL
- en: The most noticeable effect of developer mode is that any changes made to templates
    are automatically taken into account by the server, without needing to restart.
    This imposes a penalty on application performance because the server has to poll
    files to find out if there were any changes made to a template.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you turn this functionality off when preparing an application
    for release. Further changes to templates will require a restart, but in web development,
    any performance gain must be welcomed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn developer mode off, edit the `etc/zope.conf.in` file that was included
    in the package that was generated by `grokproject`. Find the line that says `devmode
    on`, and modify it to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By commenting out the line shown in bold, the default will apply, which is for
    development mode to be off. However, note that this is not the actual configuration
    file, but a template used to generate it.
  prefs: []
  type: TYPE_NORMAL
- en: To make the change take effect, rerun the buildout, so that the actual configuration
    file at `parts/etc/zope.conf` is rewritten. When you next start the application,
    it will run in production mode.
  prefs: []
  type: TYPE_NORMAL
- en: Running the paster server in the background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By far the easiest way of deploying our application is to use the same paster
    server that we have been using for development throughout the book. The only thing
    that we need to do is to launch the server in ''daemon'' mode, so that our application
    runs in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The process will then start in the background. The PID for that process will
    be stored in the file `paster.pid`, which can be used to get status information
    for the running server. The `paster.if` filename is assumed by default, by other
    `paster serve` commands, so for example, to get the process status, you can type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we need to stop the server, we use the `stop-daemon` option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of other options that can be useful. We might want the server
    to be restarted automatically in case, the server dies for whatever reason; that''s
    what the `monitor-restart` option does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we may prefer to run the server continuously in the background and
    have it restart automatically when we change some files. This can be accomplished
    with the `reload` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This setup could be considered as the minimum Grok deployment architecture,
    and its parts are shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the paster server in the background](img/7481_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running Grok behind the Apache web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem with using the default paster configuration for production is that
    the URL for our site must include the application name. This might be acceptable
    in some cases, but almost always it's not good enough. The easiest way to overcome
    this problem is to put the application behind a web server, such as Apache, and
    use the powerful URL-rewriting tools available in most web servers to serve our
    application from any URL that we require.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if our site will be running any other applications besides the one that
    we have developed, it is usually a good idea to let Apache or some other web server
    take care of centralizing the requests for multiple applications on the site.
  prefs: []
  type: TYPE_NORMAL
- en: Using mod_rewrite to serve our application from Apache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To set up this configuration, you will need to install the Apache web server,
    which is available for all platforms. Most Linux distributions will allow you
    to install it by using their package management tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in Ubuntu or Debian, you can simply type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once you have Apache ready, the next step is to configure it to use the `mod_rewrite`
    module. Usually, the way to do this is to edit the `httpd.conf` file, which should
    be available somewhere inside the `/etc` directory of your server, under either
    the `apache2` or `httpd` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the required modules to make `mod_rewrite` work, the following general
    configuration is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first three lines load the required modules, and the `ProxyRequests` line
    makes sure that the server can't be used as an involuntary proxy by third parties.
    Do not leave this line out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the "rewrite" functionality is enabled, we need to create a virtual
    host that will serve our application''s requests. This virtual host will include
    the "rewrite" rule that will allow our application to be served by Apache. A sample
    virtual host definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this simple example, we just set the server name, turn on the rewrite engine,
    and set up a rewrite rule. Before doing anything else, make sure that the server
    name is correct.
  prefs: []
  type: TYPE_NORMAL
- en: The rewrite rule is the important part of the configuration. Apache's `mod_rewrite`
    uses regular expression syntax for matching the part of a URL that will trigger
    the rule. In the configuration above, the first part of the rule tells the engine
    to match any URL that begins with a slash, which of course, will match any URL
    that will be served by this virtual host.
  prefs: []
  type: TYPE_NORMAL
- en: In regular expressions, when you enclose a subexpression in parentheses, it
    means that anything that matches the text inside them has to be saved in a variable.
    The first expression in parentheses that matches this text is stored in the variable
    `$1`, the second in `$2`, and so on. In this case, anything after the slash, which
    is the full path of the request, will be stored in `$1`.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the rule is dependent on Grok's virtual hosting tools. This
    will be the URL that will be looked up by the rule in order to get the actual
    content to be served at the matching location. For virtual hosting, Grok expects
    the full URL to the application that we are publishing (http://localhost:8080/todo),
    followed by the special virtual hosting syntax that will include the protocol,
    server name, and port, which will be used by Grok to translate all of the URLs
    present in the response, so that every link in it points to the correct host.
    Notice how, after the Grok `++vh++` rule, the full path for the request is appended
    to the end, by using the `$1` variable explained before.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final part of the rule indicates to Apache that this is a proxy
    request (P) and that this rule should be the last rule applied, when it matches
    (L).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all that is needed to set up our application with `mod_rewrite`. To
    test this, first make sure that the paster process is running and that Apache
    is using the configuration that we added. Usually, the server is started automatically
    when it''s installed, so you might need to tell it to reload the configuration.
    In Ubuntu or Debian, the way to do this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now you can go to the URL that you defined in the configuration (http://grok.example.com,
    in our example) and see your application work from behind Apache.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and setting up Grok under mod_wsgi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another great option for serving Grok applications behind Apache is `mod_wsgi`,
    which is an Apache module that serves applications under the WSGI protocol. In
    this section, we'll learn what WSGI is, and how to set up Apache to serve our
    application by using the `mod_wsgi` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'WSGI: The Python Web Server Gateway Interface'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WSGI is a Python standard for specifying how web applications can communicate
    with web servers and application servers. Its objective is to provide a simple
    interface that can support most interactions between a web server and a web framework
    (such as Grok).
  prefs: []
  type: TYPE_NORMAL
- en: WSGI also supports "middleware" components that can be used to preprocess or
    post-process a request. This means that it is used to create Python WSGI tools
    that "plug" into our applications and perform services such as profiling, error
    handling, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Grok can run behind any WSGI server. We'll now look at how to install Grok behind
    the Apache web server and `mod_wsgi` on a brand new Linux virtual server.
  prefs: []
  type: TYPE_NORMAL
- en: Grok and WSGI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For Python web developers, WSGI holds the key to the Python web development
    future. As there are a number of important web development frameworks, and the
    power of Python makes it really easy to create new ones quickly, interacting with
    the best of breed applications developed in multiple frameworks could soon be
    the best way to create a new Python website.
  prefs: []
  type: TYPE_NORMAL
- en: Until relatively recently, Zope 3 and some of its derived applications, such
    as Grok, ran the risk of missing the WSGI party, but not anymore. Grok 1.0 is
    WSGI compatible and can therefore be integrated with the wide range of WSGI-based
    technologies available in the Python world today.
  prefs: []
  type: TYPE_NORMAL
- en: Why use Apache and mod_wsgi for Grok?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of WSGI servers available, but this chapter will focus on
    using `mod_wsgi`, which is a WSGI adapter module for Apache. There are a number
    of reasons for this.
  prefs: []
  type: TYPE_NORMAL
- en: First, Apache is the most popular web hosting platform, so there are many web
    developers and site administrators who are already familiar with it. Grok, for
    example, has been installed behind Apache for production servers by using `mod_rewrite`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, there are also lots of Python applications that already run under Apache
    by using `mod_python`. There are a few WSGI adapters for this module as well,
    but `mod_wsgi` is written in C code, and has lower memory overhead and better
    performance than those adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Also, one of the goals of `mod_wsgi` is to break into the low-cost commodity
    web hosting market, which would be good for Python, and ultimately for Grok and
    Zope.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a clean Linux server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the discussion that follows, we'll use Linux as the operating system because,
    it's the most popular way to deploy web applications, by far. Ubuntu is the distribution
    that we'll cover, but these steps apply equally well to any Debian-based distribution.
    Other distributions use different package managers, and probably other system
    paths, but you should be able to easily figure out what you need in any case.
  prefs: []
  type: TYPE_NORMAL
- en: We can start with a clean install of a recent version of Ubuntu GNU/Linux. The
    first step is to install the necessary packages for both the correct Python version
    (Grok currently requires Python 2.5) and the Apache server.
  prefs: []
  type: TYPE_NORMAL
- en: Before that, it is necessary to install the required packages for being able
    to compile and build software using Ubuntu (other distributions usually don't
    need this). Be aware that both package installation and Apache module additions
    usually require root access. In the commands block, the prompt with `$` is a user
    prompt, and the one with `#` is a root prompt that you can have with the command
    `sudo -s`. In this part, you'll use a root terminal so that you do not have to
    prefix each command with `sudo`. In the other parts, you'll use a user terminal
    where you add `sudo` before a command, if you need to execute something as root.
    You can have one terminal opened as root and another terminal as user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the packages for Python and Apache. As with most packaged Linux
    distributions, Ubuntu requires a separate install for the development libraries
    of each piece of software:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apache2` package usually installs `apache2-mpm-worker`, but you may have
    the other version, `apache2-mpm-prefork`, installed. To check which one is installed,
    you can execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the corresponding development package, `apache2-threaded-dev`
    if `apache2-mpm-worker` is installed, or `apache2-prefork-dev` if `apache2-mpm-prefork`
    is installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Grok uses Python''s `setuptools`, so that package is needed as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s possible that the version provided by the Ubuntu package is not the latest.
    If you want to have more control of the installed version of `setuptools` and
    want to update it yourself when a new version is available, you can use the following
    method instead. Download `setuptools-0.6c9-py2.5.egg` manually (or latest version,
    choose py2.5) and execute the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can later update it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring mod_wsgi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, the server is ready to install `mod_wsgi`. There is a package `libapache2-mod-wsgi`
    in Ubuntu, but it''s recommended that you build the latest version, in part because
    `mod_wsgi` has to be compiled with the same Python used by Grok. Please remove
    the `libapache2-mod-wsgi` package if you have installed it previously. We need
    to get the source directly from the download site, and then build it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, note that it is necessary to compile `mod_wsgi` using the same Python
    that you will use to run your website. As Grok requires 2.5, the `--with-python`
    option was used to point to the version of Python that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Once `mod_wsgi` is installed, the Apache server needs to be told about it. On
    Apache 2, this is done by adding the load declaration and any configuration directives
    to the `/etc/apache2/mods-available/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The load declaration for the module needs to go in a file named `wsgi.load`
    (in the `/etc/apache2/mods-available/` directory), which contains only the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The configuration directives reside in the file named `wsgi.conf` next to `wsgi.load`
    file. We don't create it now, but it can be useful later to add directives to
    it, if you have more than one WSGI application to serve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you have to activate the `wsgi` module with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `a2enmod` stands for "apache2 enable mod" an executable that creates
    the symlink for you. Actually, `a2enmod wsgi` is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For Apache 1.3, or Apache 2 with an old directory layout, you may need to place
    the `LoadModule` line and the configuration directives (which you will see later)
    inside the `httpd.conf` file in your Apache's `/etc` directory. The soft links
    above will not be necessary in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Grok site under mod_wsgi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Grok can be installed with `setuptools`, and a Grok site can be easily created
    by using the included `grokproject` tool. As mentioned before, Grok can run behind
    any WSGI server, not just the paster server that is used by default. Now that
    we have a working `mod_wsgi`, we will look at how to run Grok behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the to-do application ready for mod_wsgi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WSGI applications use entry points to let the WSGI server know how to run the
    program. The **entry point** is usually a simple Python script that provides a
    function for calling the application and passing the appropriate initialization
    file to the server. Some servers, such as the paster server, need only the path
    to the `.ini` file, which is what we normally use to start up a Grok application.
    This doesn''t mean that there''s no entry point script for paster. In fact, the
    entry point is defined in the `setup.py` file, which is created by `grokproject`
    when a new project is initialized. Take a look at the last few lines of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The heading `paste.app_factory` tells the server where to find the factory functions
    for each section of the `.ini` file. In Grok, a general application factory function
    is defined in the `grokcore.startup` package, which is what paster uses to start
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: However, `mod_wsgi` requires a path to the factory, which would be cumbersome
    to include in our configuration, because this would mean that it would need to
    point to a file inside the `grokcore.startup` egg. As eggs include the version
    number, a simple update could crash our site if the old egg is removed. It would
    be better to have our own factory defined inside the application package.
  prefs: []
  type: TYPE_NORMAL
- en: Given that the factory code can be almost identical for different projects,
    it would be better to have it included automatically when we create the project,
    to avoid having to re-create the same script every time. Fortunately for us, Grok's
    use of buildout turns out to be very helpful in this case, as there is a buildout
    recipe available that creates the WSGI application factory for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe is called `collective.recipe.modwsgi`. To use it, simply add a part
    to the buildout having a name such as `wsgi_app`. The recipe requires two parameters
    the first being the eggs that have to be made available to the Python process
    that will run the app under WSGI, and the second being the path to the configuration
    file that will be used for the site. This last parameter `value` is the usual
    `parts/etc/deploy.ini` path that we have been using for running the application
    under paster. That''s it. Edit the `buildout.cfg` file''s `parts` list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following section anywhere in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `eggs` parameter simply points back to the main egg section defined
    at the start of the buildout, to avoid repetition.
  prefs: []
  type: TYPE_NORMAL
- en: When the buildout is run again, we'll find a `parts/wsgi_app` directory (or
    whichever name we used for the buildout part). Inside that directory, there will
    be a `wsgi` file that can be used as is by `mod_wsgi` to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an Apache site to use mod_wsgi
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last step is to add a site to the Apache server that uses `mod_wsgi` to
    serve our application. This is standard `mod_wsgi` configuration; we'll just add
    the path to the application factory that we created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the virtual host, create a file in the `/etc/apache2/sites-available`
    directory and call it, for example, "grok". Add the following code to it, assuming
    your to-do application is at `/home/cguardia/grok/todo:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will run `mod_wsgi` in 'daemon' mode, which means that it will launch a
    number of processes in order to run the configured WSGI application instead of
    using the Apache process. If you are using virtualenv, the `site-packages` directory
    of the virtual Python, which is used to run it, needs to be passed in the `WSGIPythonHome`
    variable. To tell `mod_wsgi` which WSGI application to run, we use the `WSGIScriptAlias`
    directive, and pass to it the path to the application factory that we created
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we assign a user and group to run the process. It is required that
    this user has access to the application directory.
  prefs: []
  type: TYPE_NORMAL
- en: The PYTHON_EGG_CACHE directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Note that when the application is started, all of the eggs will be automatically
    extracted in the `PYTHON_EGG_CACHE` directory, normally `~/.python-eggs`. This
    directory depends on the `HOME` environment variable. The `HOME` apache user `www-data`
    is `/var/www`. You may get the error, **[Errno 13] Permission denied: ''/var/www/.python-eggs''**
    in your `error.log` apache file if you don''t configure the user or the `python-eggs`
    variable in the `WSGIDaemonProcess` directive. You can also add a `python-eggs`
    parameter to tell `mod_wsgi` to use an alternative directory for the egg cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the process belongs to `www-data`. The `www-data` and `python-eggs`
    cache directory will be `/tmp/python-eggs`.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the configuration is ready, we need to enable the site in Apache, because
    we just created it. This is necessary only for the first time we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create a link from the Apache `sites-enabled` directory to
    the "grok" site that we just configured, which is enough to make it active. Then,
    we can start serving our application from Apache by simply reloading the configuration
    for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When you visit the site in a browser ([http://wsgi.example.com/todo](http://wsgi.example.com/todo)),
    you should see the Grok admin UI. You should be able to log in by using the admin
    login name and password.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a ZEO server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, `mod_wsgi` will use a single process to run the application. As
    this configuration is intended for production use, it may be desirable to have
    a higher number of processes available to serve the application. The ZODB that
    Grok uses comes with a server named **Zope Enterprise Object** (ZEO), which allows
    us to add as many processes to our configuration as our system permits, providing
    unlimited horizontal scalability. Typically, the recommended number of processes
    is one for each core in the system's processors. Let's set up a ZEO server and
    configure the Grok process to connect to it.
  prefs: []
  type: TYPE_NORMAL
- en: Buildout recipe for the ZEO configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once again, the easiest way to get ZEO running is to use an existing buildout
    recipe. This time we''ll use the one named `zc:zodbrecipes`. Add a `zeo_server`
    part to your `buildout.cfg` file, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add a `zeo_server` section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will add the ZEO server, and configure it to listen on port 8100\. The
    rest of the configuration is pretty much boilerplate, so just copy it to new projects
    when you need ZEO there. The `blobstorage` section sets up a file storage with
    blob handling enabled; the `logfile` sections tells the server where to store
    the log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need the buildout to add scripts for starting and stopping ZEO. This
    is easily accomplished by adding the `ZODB3` egg to our app section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the ZEO client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, the Grok application that we are using is working with the regular
    Zope server. To use ZEO, we need to change the configuration to connect to the
    server at port 8100\. Fortunately, the required changes already come inside the
    regular `zope.conf` file that is created inside the Grok project, so we only need
    to uncomment those lines. Uncomment the following lines inside the `zope.conf.in`
    file in the `etc` directory of your Grok project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The important line here is the one with the ZEO server address. In this case,
    we are using the same host as the Grok application, and the port that we defined
    in our ZEO configuration in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the ZEO server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After running the buildout again, we''ll be ready to start the ZEO server in
    the background. To do this, we have to run only the server script that was automatically
    created for us. The name of the script is the same as the name of the part in
    the buildout where we configured the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Grok application is now running! To stop it, you can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Augmenting the number of processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recall that we mentioned earlier that `mod_wsgi` runs the application in a
    single process by default. To really take advantage of ZEO, we want to have more
    processes available. We need to make a small addition to our `mod_wsgi` Apache
    virtual host configuration for that. Change the `WSGIDaemonProcess` line, near
    the top, to look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Remember to reload the Apache configuration to be able to see the new setup
    in action. In this example, we'll have two processes running, with four threads
    each. By using ZEO and `mod_wsgi`, we now have a scalable site.
  prefs: []
  type: TYPE_NORMAL
- en: 'More scalability: Adding caching and load balancing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The configurations that we just discussed will be enough for most kinds of sites.
    However, there are times when a site is required to handle high traffic loads,
    and measures need to be taken to ensure that it will not go down under pressure.
  prefs: []
  type: TYPE_NORMAL
- en: Caching proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One very effective thing that can be done is to add a caching proxy in front
    of the Apache server. A **caching proxy** reduces bandwidth and improves response
    times by saving a copy of the most frequently used pages of a site and serving
    that copy directly on further requests, rather than connecting to the server again.
  prefs: []
  type: TYPE_NORMAL
- en: Two very popular caching proxies are Squid ([http://www.squid-cache.org](http://www.squid-cache.org))
    and Varnish ([http://www.varnish-cache.org](http://www.varnish-cache.org)). A
    detailed discussion of how to set these up is beyond the objectives of this chapter,
    but, interestingly, there are buildout recipes available for setting them up automatically.
    Take a look at the Python Package Index and see how these recipes help to build
    and configure a caching proxy. For Squid, there's `plone.recipe.squid` ([http://pypi.python.org/pypi/plone.recipe.squid/](http://pypi.python.org/pypi/plone.recipe.squid/)),
    and for Varnish, the corresponding `plone.recipe.varnish` ([http://pypi.python.org/pypi/plone.recipe.varnish](http://pypi.python.org/pypi/plone.recipe.varnish)).
  prefs: []
  type: TYPE_NORMAL
- en: Load balancers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **load balancer** sits in front of two or more instances of an application
    and distributes the incoming requests evenly between them. This is a very powerful
    solution when you can have several machines serving the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are several load balancers available as open source; for example, Apache
    itself has a load-balancing module. However, one of the most popular load balancers
    to use with Zope Toolkit-based applications is "Pound" ([http://www.apsis.ch/pound/](http://www.apsis.ch/pound/)).
  prefs: []
  type: TYPE_NORMAL
- en: Pound does a lot more than just distributing the load. It can keep session information
    and send a request from the same origin browser to the same destination server
    used on the first request. Pound can also distribute requests among servers according
    to its URL. Finally, it can act as a failover server, because it's smart enough
    to notice when a backend server fails and will stop sending requests to it until
    the server recovers.
  prefs: []
  type: TYPE_NORMAL
- en: There is, of course, a buildout recipe available for setting up Pound, appropriately
    named `plone.recipe.pound` ([http://pypi.python.org/pypi/plone.recipe.pound](http://pypi.python.org/pypi/plone.recipe.pound)).
  prefs: []
  type: TYPE_NORMAL
- en: A high-traffic architecture for Grok
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know about some mechanisms for improving our application's performance,
    it can be helpful to visualize how the different parts relate to each other. In
    our case, a good way of organizing a system to support high traffic loads would
    be to put a caching proxy such as Varnish at the front and configure it to pass
    requests to the Pound load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Pound would be configured to distribute the load among a number of separate
    servers, each one of them running Apache configured with `mod_wsgi`, and running
    several processes that would talk to a number of ZEO clients running our Grok
    application. Using this architecture, depicted in the following figure, we could
    scale our application to deal with very high traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '![A high-traffic architecture for Grok](img/7481_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed how to approach application deployment, and explored
    various possibilities for deploying our sample application, from a simple setup
    to a scalable configuration with ZEO.
  prefs: []
  type: TYPE_NORMAL
- en: We have reached the end of our journey with Grok. Hopefully, you'll find that
    Grok is a good addition to your web arsenal, and will think about how its strengths
    could help you reach your goals whenever you need to develop a web application.
    In this Internet age, it's very easy to reach out and communicate with people
    who can help us with many kinds of technologies. Grok developers and users are
    no exception, so please do not hesitate to ask for advice, by using Grok's mailing
    lists or IRC channel. We'll be glad to help you, and will be happy that you took
    Grok out for a spin.
  prefs: []
  type: TYPE_NORMAL
