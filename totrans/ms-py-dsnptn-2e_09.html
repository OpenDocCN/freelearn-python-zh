<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-219" class="chapter-number"><a id="_idTextAnchor233"/>9</h1>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor234"/>Distributed Systems Patterns</h1>
			<p>As technology evolves and the demand for scalable and resilient systems increases, understanding the fundamental patterns that govern distributed systems <span class="No-Break">becomes paramount.</span></p>
			<p>From managing<a id="_idIndexMarker855"/> communication between nodes to ensuring <strong class="bold">fault tolerance</strong> (<strong class="bold">FT</strong>) and consistency, this chapter explores essential design patterns that empower developers to architect robust distributed systems. Whether you’re building microservices or implementing cloud-native applications, mastering these patterns will equip you with the tools to tackle the complexities of distributed <span class="No-Break">computing effectively.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The <span class="No-Break">Throttling pattern</span></li>
				<li>The <span class="No-Break">Retry pattern</span></li>
				<li>The Circuit <span class="No-Break">Breaker pattern</span></li>
				<li>Other distributed <span class="No-Break">systems patterns</span></li>
			</ul>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor235"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>.The additional technical requirements for the code discussed in this chapter are <span class="No-Break">the following:</span></p>
			<ul>
				<li>Install Flask and Flask-Limiter, using <strong class="source-inline">python -m pip install </strong><span class="No-Break"><strong class="source-inline">flask flask-limiter</strong></span></li>
				<li>Install PyBreaker, using <strong class="source-inline">python -m pip </strong><span class="No-Break"><strong class="source-inline">install pybreaker</strong></span></li>
			</ul>
			<p><a href="https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition/tree/main/ch09&#13;"/></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor236"/>The Throttling pattern</h1>
			<p>Throttling is an<a id="_idIndexMarker856"/> important pattern we may need to use in today’s applications and APIs. In <a id="_idIndexMarker857"/>this context, throttling means controlling the rate of requests a user (or a client service) can send to a given service or A<a id="_idTextAnchor237"/>PI in a given amount of time, to protect the resources of the service from being overused. For example, we may limit the number of user requests for an API to 1,000 per day. Once that limit is reached, the next request is handled by sending an error message with the 429 HTTP status code to the user with a message saying that there are too <span class="No-Break">many requests.</span></p>
			<p>There are many things to understand about throttling, including which limiting strategy and algorithm one may use and measuring how the service is used. You can find technical details about the Throttling pattern in<a id="_idIndexMarker858"/> the catalog of cloud design patterns by <span class="No-Break">Microsoft (</span><a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling"><span class="No-Break">https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling</span></a><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor238"/>Real-world examples</h2>
			<p>There are a lot of examples of throttling in<a id="_idIndexMarker859"/> real life, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Highway traffic management</strong>: Traffic lights or speed limits regulate the flow of vehicles on <span class="No-Break">a highway</span></li>
				<li><strong class="bold">Water faucet</strong>: Adjusting the flow of water from <span class="No-Break">a faucet</span></li>
				<li><strong class="bold">Concert ticket sales</strong>: When tickets for a popular concert go on sale, the website may limit the number of tickets each user can purchase at once to prevent the server from crashing due to a sudden surge <span class="No-Break">in demand</span></li>
				<li><strong class="bold">Electricity usage</strong>: Some utility companies offer plans where customers pay different rates based on their electricity usage during peak and <span class="No-Break">off-peak hours</span></li>
				<li><strong class="bold">Buffet line</strong>: In a buffet, customers may be limited to taking only one plate of food at a time to ensure that everyone has a fair chance to eat and to prevent <span class="No-Break">food</span><span class="No-Break"><a id="_idIndexMarker860"/></span><span class="No-Break"> wastage</span></li>
			</ul>
			<p>We also have examples of pieces of software that help <span class="No-Break">implement throttling:</span></p>
			<ul>
				<li><strong class="source-inline">django-throttle-requests</strong> (<a href="https://github.com/sobotklp/django-throttle-requests">https://github.com/sobotklp/django-throttle-requests</a>) is a framework for<a id="_idIndexMarker861"/> implementing application-specific rate-limiting middleware for <span class="No-Break">Django projects</span></li>
				<li>Flask-Limiter (<a href="https://flask-limiter.readthedocs.io/en/stable/">https://flask-limiter.readthedocs.io/en/stable/</a>) provides rate-limiting features to <a id="_idIndexMarker862"/><span class="No-Break">Flask routes</span></li>
			</ul>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor239"/>Use cases for the Throttling pattern</h2>
			<p>This pattern is<a id="_idIndexMarker863"/> recommended when you need to ensure your system continuously delivers the service as expected, when you need to optimize the <a id="_idIndexMarker864"/>cost of usage of the service, or when you need to handle bursts <span class="No-Break">in activity.</span></p>
			<p>In practice, you may implement the <span class="No-Break">following rules:</span></p>
			<ul>
				<li>Limit the number of total requests to an API as N/day (for <span class="No-Break">example, N=1000)</span></li>
				<li>Limit the number of requests to an API as N/day from a given IP address, or from a given country <span class="No-Break">or region</span></li>
				<li>Limit the number of reads or writes for <span class="No-Break">authenticated users</span></li>
			</ul>
			<p>In addition to the rate-limiting cases, it can be used for <em class="italic">resource allocation</em>, ensuring fair distribution of resources among <span class="No-Break">multiple clients.</span></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor240"/>Implementing the Throttling pattern</h2>
			<p>Before diving into an <a id="_idIndexMarker865"/>implementation example, you need to know that there are several types of throttling, among which are Rate-Limit, IP-level Limit (based on a list of whitelisted IP addresses, for example), and Concurrent Connections Limit, to only cite those three. The first two are relatively easy to experiment with. We will focus on the first <span class="No-Break">one here.</span></p>
			<p>Let’s see an example of rate-limit-type throttling using a minimal web application developed using Flask and its <span class="No-Break">Flask-Limiter extension.</span></p>
			<p>We start with the imports we need for <span class="No-Break">the example:</span></p>
			<pre class="source-code">
from flask import Flask
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address</pre>			<p>As is usual with Flask, we set up the Flask application with the following <span class="No-Break">two lines:</span></p>
			<pre class="source-code">
app = Flask(__name__)</pre>			<p>We then define the Limiter instance; we create it by passing a key function, <strong class="source-inline">get_remote_address</strong> (which we imported), the application object, the default limits values, and other parameters, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
limiter = Limiter(
    get_remote_address,
    app=app,
    default_limits=["100 per day", "10 per hour"],
    storage_uri="memory://",
    strategy="fixed-window",
)</pre>			<p>Based on that, we <a id="_idIndexMarker866"/>can define a route for the <strong class="source-inline">/limited</strong> path, which <a id="_idIndexMarker867"/>will be rate-limited using the default limits, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@app.route("/limited")
def limited_api():
    return "Welcome to our API!"</pre>			<p>We also add the definition for a route for the <strong class="source-inline">/more_limited</strong> path. In this case, we decorate the function with <strong class="source-inline">@limiter.limit("2/minute")</strong> to ensure a rate limit of two requests per minute. The code is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@app.route("/more_limited")
@limiter.limit("2/minute")
def more_limited_api():
    return "Welcome to our expensive, thus very limited, API!"</pre>			<p>Finally, we add the snippet that is conventional for <span class="No-Break">Flask applications:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    app.run(debug=True)</pre>			<p>To test this example, run the file (<strong class="source-inline">ch09/throttling_flaskapp.py</strong>) using the <strong class="source-inline">python ch09/throttling_flaskapp.py</strong> command. You would get the<a id="_idIndexMarker868"/> usual output for a<a id="_idIndexMarker869"/> Flask application that <span class="No-Break">is starting:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B21896_09_1.jpg" alt="Figure 9.1 – throttling_flaskapp: Flask application example startup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – throttling_flaskapp: Flask application example startup</p>
			<p>Then, if you point your browser to <strong class="source-inline">http://127.0.0.1:5000/limited</strong>, you will see the welcome content displayed on the page, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B21896_09_2.jpg" alt="Figure 9.2 – Response to the /limited endpoint in the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Response to the /limited endpoint in the browser</p>
			<p>It gets interesting if you keep hitting the <strong class="bold">Refresh</strong> button. The 10th time, the page content will change and show you a <strong class="bold">Too Many Requests</strong> error message, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B21896_09_3.jpg" alt="Figure 9.3 – Too many requests on the /limited endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Too many requests on the /limited endpoint</p>
			<p>Let’s not<a id="_idIndexMarker870"/> stop here. Remember – there is a second route<a id="_idIndexMarker871"/> in the code, <strong class="source-inline">/more_limited</strong>, with a specific limit of two requests per minute. To test that second route, point your browser to <strong class="source-inline">http://127.0.0.1:5000/more_limited</strong>. You will see new welcome content displayed on the page, <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21896_09_4.jpg" alt="Figure 9.4 – Response to the /more_limited endpoint in the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Response to the /more_limited endpoint in the browser</p>
			<p>If we hit the <strong class="bold">Refresh</strong> button and do it more than twice in a window of 1 minute, we get another <strong class="bold">Two Many Requests</strong> message, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21896_09_5.jpg" alt="Figure 9.5 – Too many requests on the /more_limited endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Too many requests on the /more_limited endpoint</p>
			<p>Also, looking at <a id="_idIndexMarker872"/>the console where the Flask server is <a id="_idIndexMarker873"/>running, you will notice the mention of each HTTP request received and the status code of the response the application sent. It should look like the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B21896_09_6.jpg" alt="Figure 9.6 – Flask server console: Responses to the HTTP requests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Flask server console: Responses to the HTTP requests</p>
			<p>There are many possibilities for rate-limit-type throttling in a Flask application using the Flask-Limiter extension, as you can see on the documentation page of the module. The reader can find more information on the documentation page on how to use different strategies and storage backends such as Redis for a <span class="No-Break">specific implementation.</span></p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor241"/>The Retry pattern</h1>
			<p>Retrying is an<a id="_idIndexMarker874"/> approach<a id="_idIndexMarker875"/> that is increasingly needed in the context of distributed systems. Think about microservices or cloud-based infrastructures where components co<a id="_idTextAnchor242"/>llaborate with each other but are not developed or deployed/operated by the same teams <span class="No-Break">and parties.</span></p>
			<p>In its daily operation, parts of a cloud-native application may experience what are called transient faults or failures, meaning some mini-issues that can look like bugs but are not due to your application itself; rather, they are due to some constraints outside of your control such as the networking or the external server/service performance. As a result, your application may malfunction (at least, that could be the perception of your users) or even hang in some places. The answer to the risk of such failures is to put in place some retry logic so that we pass through the issue by calling the service again, maybe immediately or after some wait time (such as a <span class="No-Break">few seconds).</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor243"/>Real-world examples</h2>
			<p>There are examples of the Retry <a id="_idIndexMarker876"/>pattern (or analogies) in our daily life, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Making a phone call</strong>: Imagine you’re trying to reach a friend on the phone, but the call doesn’t go through because their line is busy or there’s a network issue. Instead of giving up immediately, you retry dialing their number after a <span class="No-Break">short delay.</span></li>
				<li><strong class="bold">Withdrawing money from an ATM</strong>: Imagine you go to an ATM to withdraw cash, but due to a temporary issue such as network congestion or connectivity problems, the transaction fails, and the machine displays an error message. Instead of giving up on getting cash, you wait a moment and try the transaction again. This time, the transaction may go through successfully, allowing you to withdraw the money <span class="No-Break">you need.</span></li>
			</ul>
			<p>There are also many tools or techniques that we can consider as examples in the software realm since they help implement the Retry pattern, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>In Python, the <a id="_idIndexMarker877"/>Retrying library (<a href="https://github.com/rholder/retrying">https://github.com/rholder/retrying</a>) is available to simplify the task of adding retry behavior to <span class="No-Break">our functions</span></li>
				<li>The <a id="_idIndexMarker878"/>Pester library (<a href="https://github.com/sethgrid/pester">https://github.com/sethgrid/pester</a>) for <span class="No-Break">Go developers</span></li>
			</ul>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor244"/>Use cases for the Retry pattern</h2>
			<p>This pattern<a id="_idIndexMarker879"/> is recommended to alleviate the impact of<a id="_idIndexMarker880"/> identified transient failures while communicating with an external component or service, due to network failure or <span class="No-Break">server overload.</span></p>
			<p>Note that the retrying approach is not recommended for handling failures such as internal exceptions caused by errors in the application logic itself. Also, we must analyze the response from the external service. If the application experiences frequent busy faults, it’s often a sign that the service being accessed has a scaling issue that should <span class="No-Break">be addressed.</span></p>
			<p>We can relate retrying to the microservices architecture, where services often communicate over the network. The Retry pattern ensures that transient failures don’t cause the entire system <span class="No-Break">to fail.</span></p>
			<p>Another type of use case is <em class="italic">data synchronization</em>. When syncing data between two systems, retries can handle the temporary unavailability of <span class="No-Break">one system.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor245"/>Implementing the Retry pattern</h2>
			<p>In this example, we’ll<a id="_idIndexMarker881"/> implement the Retry pattern for a database connection. We’ll use a decorator to handle the <span class="No-Break">retry mech<a id="_idTextAnchor246"/>anism.</span></p>
			<p>We start with the <strong class="source-inline">import</strong> statements for the example, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import logging
import random
import time</pre>			<p>We then add configuration for logging, which will help for observability when using <span class="No-Break">the code:</span></p>
			<pre class="source-code">
logging.basicConfig(level=logging.DEBUG)</pre>			<p>We add our function<a id="_idIndexMarker882"/> that will support the decorator to automatically retry the execution of the decorat<a id="_idTextAnchor247"/>ed function up to the number of attempts specified, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
def retry(attempts):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(attempts):
                try:
                    logging.info("Retry happening")
                    return func(*args, **kwargs)
                except Exception as e:
                    time.sleep(1)
                    logging.debug(e)
            return "Failure after all attempts"
        return wrapper
    return decorator</pre>			<p>Then, we <a id="_idIndexMarker883"/>add the <strong class="source-inline">connect_to_database()</strong> function, which simulates a database connection. It is decorated by the <strong class="source-inline">@retry</strong> decorator. We want the decorator to automatically retry the connection up to three times if <span class="No-Break">it fails:</span></p>
			<pre class="source-code">
@retry(attempts=3)
def connect_to_database():
    if random.randint(0, 1):
        raise Exception("Temporary Database Error")
    return "Connected to Database"</pre>			<p>Finally, to make it convenient to test our implementation, we add the following <span class="No-Break">testing code:</span></p>
			<pre class="source-code">
if __name__ == "__main__":
    for i in range(1, 6):
        logging.info(f"Connection attempt #{i}")
        print(f"--&gt; {connect_to_database()}")</pre>			<p>To test the example, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
<strong class="bold">python ch09/retry/retry_database_connection.py</strong></pre>			<p>You should <a id="_idIndexMarker884"/>get an<a id="_idIndexMarker885"/> output like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">INFO:root:Connection attempt #1</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">--&gt; Connected to Database</strong>
<strong class="bold">INFO:root:Connection attempt #2</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">--&gt; Failure after all attempts</strong>
<strong class="bold">INFO:root:Connection attempt #3</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">--&gt; Connected to Database</strong>
<strong class="bold">INFO:root:Connection attempt #4</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">--&gt; Connected to Database</strong>
<strong class="bold">INFO:root:Connection attempt #5</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">--&gt; Failure after all attempts</strong></pre>			<p>So, when a temporary database error occurs, a retry happens. Several retry attempts may occur, until three. Once three unsuccessful retry attempts have occurred, the outcome is the failure of <span class="No-Break">the operation.</span></p>
			<p>Overall, the <a id="_idIndexMarker886"/>Retry pattern is a viable way to handle this type of <a id="_idIndexMarker887"/>use case involved with distributed systems, and a few errors (four database errors in our example) may mean that there is a more permanent or problematic bug that should <span class="No-Break">be fixed.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor248"/>The Circuit Breaker pattern</h1>
			<p>One approach to <a id="_idIndexMarker888"/>FT involves retries, as we have just seen. But, when<a id="_idIndexMarker889"/> a failure due to communication with an external component is likely to be long-lasting, using a retry mechanism can affect the responsiveness of the application. We might be wasting time and resources trying to repeat a request that’s likely to fail. This is where another pattern can be useful: the Circuit <span class="No-Break">Breaker pattern.</span></p>
			<p>With the Circuit Breaker pattern, you wrap a fragile function call, or an integration point with an external service, in a special (circuit breaker) object, which monitors for failures. Once the failures reach a certain threshold, the circuit breaker trips and all subsequent calls to the circuit breaker return with an error, without the protected call being made <span class="No-Break">at all.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor249"/>Real-world examples</h2>
			<p>In life, we can think of a water or electricity distribution circuit where a circuit breaker plays an <span class="No-Break">important role.</span></p>
			<p>In software, a <a id="_idIndexMarker890"/>circuit breaker is used in the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker891"/></span><span class="No-Break">examples:</span></p>
			<ul>
				<li><strong class="bold">E-commerce checkout</strong>: If the payment gateway is down, the circuit breaker can halt further payment attempts, preventing <span class="No-Break">system overload</span></li>
				<li><strong class="bold">Rate-limited APIs</strong>: When an API has reached its rate limit, a circuit breaker can stop additional requests to <span class="No-Break">avoid penalties</span></li>
			</ul>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor250"/>Use cases for the Circuit Breaker pattern</h2>
			<p>As already said, the <a id="_idIndexMarker892"/>Circuit Breaker pattern is recommended when you need a component from your system to be fault-tolerant to long-lasting failures when communicating with an external component, service, or resource. Next, we will understand how it addresses such <span class="No-Break">use cases.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor251"/>Implementing the Circuit Breaker pattern</h2>
			<p>Let’s say you want to use a circuit <a id="_idIndexMarker893"/>breaker on a flaky function, a function that is fragile, for example, due to the networking environment it depends on. We are going to use<a id="_idIndexMarker894"/> the <strong class="source-inline">pybreaker</strong> library (<a href="https://pypi.org/project/pybreaker/">https://pypi.org/project/pybreaker/</a>) to show an example of implementing the Circuit <span class="No-Break">Breaker pattern.</span></p>
			<p>Our implementation is an adaptation of a nice script I found in this repository: <a href="https://github.com/veltra/pybreaker-playground">https://github.com/veltra/pybreaker-playground</a>. Let’s go through <span class="No-Break">the code.</span></p>
			<p>We start with our imports, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import pybreaker
from datetime import datetime
import random
from time import sleep</pre>			<p>Let’s define our circuit breaker to automatically open the circuit after five consecutive failures in that function. We need to create an instance of the <strong class="source-inline">pybreaker.CircuitBreaker</strong> class, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
breaker = pybreaker.CircuitBreaker(fail_max=2, reset_timeout=5)</pre>			<p>Then, we <a id="_idIndexMarker895"/>create our version of the function to simulate <a id="_idIndexMarker896"/>fragile calls. We use the decorator syntax to protect things, so the new function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
@breaker
def fragile_function():
    if not random.choice([True, False]):
        print(" / OK", end="")
    else:
        print(" / FAIL", end="")
        raise Exception("This is a sample Exception")</pre>			<p>Finally, here’s the main part of the code, with the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
def main():
    while True:
        print(datetime.now().strftime("%Y-%m-%d %H:%M:%S"), end="")
        try:
            fragile_function()
        except Exception as e:
            print(" / {} {}".format(type(e), e), end="")
        finally:
            print("")
            sleep(1)</pre>			<p>Calling this script by running the <strong class="source-inline">python ch09/circuit_breaker.py</strong> command produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B21896_09_7.jpg" alt="Figure 9.7 – Output of our program using a circuit breaker"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Output of our program using a circuit breaker</p>
			<p>By closely<a id="_idIndexMarker897"/> looking at the output, we can see that the <a id="_idIndexMarker898"/>circuit breaker does its job as expected: when it is open, all <strong class="source-inline">fragile_function()</strong> calls fail immediately (since they raise the <strong class="source-inline">CircuitBreakerError</strong> exception) without any attempt to execute the intended operation. And, after a timeout of 5 seconds, the circuit breaker will allow the next call to go through. If that call succeeds, the circuit is closed; if it fails, the circuit is opened again until another <span class="No-Break">timeout elapses.</span></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor252"/>Other distributed systems patterns</h1>
			<p>There are many more distributed systems patterns than the ones we covered here. Among the other patterns developers and architects can use are <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Command and Query Responsibility Segregation (CQRS)</strong>: This pattern separates the <a id="_idIndexMarker899"/>responsibilities for <a id="_idIndexMarker900"/>reading and writing data, allowing for optimized data access and scalability by tailoring data models and operations to specific <span class="No-Break">use cases</span></li>
				<li><strong class="bold">Two-Phase Commit</strong>: This<a id="_idIndexMarker901"/> distributed transaction<a id="_idIndexMarker902"/> protocol ensures atomicity and consistency across multiple participating resources by coordinating<a id="_idTextAnchor253"/> a two-phase commit process, involving a <em class="italic">prepare</em> phase followed by a <span class="No-Break"><em class="italic">commit</em></span><span class="No-Break"> phase</span></li>
				<li><strong class="bold">Saga</strong>: A saga<a id="_idIndexMarker903"/> is a sequence of local transactions that <a id="_idIndexMarker904"/>together form a distributed transaction, providing a compensating mechanism to maintain consistency in the face of partial failures or <span class="No-Break">aborted transactions</span></li>
				<li><strong class="bold">Sidecar</strong>: The<a id="_idIndexMarker905"/> Sidecar pattern<a id="_idIndexMarker906"/> involves deploying additional helper services alongside primary services to enhance functionality, such as adding monitoring, logging, or security features without directly modifying the <span class="No-Break">main application</span></li>
				<li><strong class="bold">Service Registry</strong>: This pattern centralizes the management and discovery of services within a distributed<a id="_idIndexMarker907"/> system, allowing services to <a id="_idIndexMarker908"/>dynamically register and discover each other, facilitating communication <span class="No-Break">and scalability</span></li>
				<li><strong class="bold">Bulkhead</strong>: Inspired by ship design, the<a id="_idIndexMarker909"/> Bulkhead pattern<a id="_idIndexMarker910"/> partitions resources or components within a system to isolate failures and prevent cascading failures from impacting other parts of the system, thereby enhancing FT <span class="No-Break">and resilience</span></li>
			</ul>
			<p>Each of these patterns addresses specific challenges inherent in distributed systems, offering strategies and best practices for architects and developers to design robust and scalable solutions capable of operating in dynamic and <span class="No-Break">unpredictable environments.</span></p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor254"/>Summary</h1>
			<p>In this chapter, we delved into the intricacies of distributed systems patterns, focusing on the Throttling, Retry, and Circuit Breaker patterns. These patterns are essential for building robust, fault-tolerant, and efficient <span class="No-Break">distributed systems.</span></p>
			<p>The skills you’ve acquired in this chapter will significantly contribute to your ability to design and implement distributed systems that can handle transient failures, service interruptions, and <span class="No-Break">high loads.</span></p>
			<p>The section about the Throttling pattern equipped you with the tools to manage service load and resource <span class="No-Break">allocation effectively.</span></p>
			<p>By understanding how to implement the Retry pattern, you’ve gained the skills to make your operations <span class="No-Break">more reliable.</span></p>
			<p>And, finally, the Circuit Breaker pattern taught you how to build fault-tolerant systems that can gracefully <span class="No-Break">handle failures.</span></p>
			<p>As we wrap up this chapter, it’s crucial to remember that these patterns are not isolated solutions but pieces of a larger puzzle. They often work best when combined and tailored to fit the specific needs and constraints of your system. The key takeaway is to understand the underlying principles so that you ca<a id="_idTextAnchor255"/>n adapt them to create a resilient and efficient <span class="No-Break">distributed system.</span></p>
			<p>Lastly, we briefly presented some other distributed systems patterns, which we cannot cover in <span class="No-Break">this book.</span></p>
			<p>In the next chapter, we will focus on patterns <span class="No-Break">for testing.</span></p>
		</div>
	</body></html>