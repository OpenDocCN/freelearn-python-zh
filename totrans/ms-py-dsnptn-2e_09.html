<html><head></head><body>
		<div><h1 id="_idParaDest-219" class="chapter-number"><a id="_idTextAnchor233"/>9</h1>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor234"/>Distributed Systems Patterns</h1>
			<p>As technology evolves and the demand for scalable and resilient systems increases, understanding the fundamental patterns that govern distributed systems becomes paramount.</p>
			<p>From managing<a id="_idIndexMarker855"/> communication between nodes to ensuring <strong class="bold">fault tolerance</strong> (<strong class="bold">FT</strong>) and consistency, this chapter explores essential design patterns that empower developers to architect robust distributed systems. Whether you’re building microservices or implementing cloud-native applications, mastering these patterns will equip you with the tools to tackle the complexities of distributed computing effectively.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>The Throttling pattern</li>
				<li>The Retry pattern</li>
				<li>The Circuit Breaker pattern</li>
				<li>Other distributed systems patterns</li>
			</ul>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor235"/>Technical requirements</h1>
			<p>See the requirements presented in <a href="B21896_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>.The additional technical requirements for the code discussed in this chapter are the following:</p>
			<ul>
				<li>Install Flask and Flask-Limiter, using <code>python -m pip install </code><code>flask flask-limiter</code></li>
				<li>Install PyBreaker, using <code>python -m pip </code><code>install pybreaker</code></li>
			</ul>
			<p><a href="https://github.com/PacktPublishing/Mastering-Python-Design-Patterns-Third-Edition/tree/main/ch09&#13;"/></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor236"/>The Throttling pattern</h1>
			<p>Throttling is an<a id="_idIndexMarker856"/> important pattern we may need to use in today’s applications and APIs. In <a id="_idIndexMarker857"/>this context, throttling means controlling the rate of requests a user (or a client service) can send to a given service or A<a id="_idTextAnchor237"/>PI in a given amount of time, to protect the resources of the service from being overused. For example, we may limit the number of user requests for an API to 1,000 per day. Once that limit is reached, the next request is handled by sending an error message with the 429 HTTP status code to the user with a message saying that there are too many requests.</p>
			<p>There are many things to understand about throttling, including which limiting strategy and algorithm one may use and measuring how the service is used. You can find technical details about the Throttling pattern in<a id="_idIndexMarker858"/> the catalog of cloud design patterns by Microsoft (<a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling">https://learn.microsoft.com/en-us/azure/architecture/patterns/throttling</a>).</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor238"/>Real-world examples</h2>
			<p>There are a lot of examples of throttling in<a id="_idIndexMarker859"/> real life, such as the following:</p>
			<ul>
				<li><strong class="bold">Highway traffic management</strong>: Traffic lights or speed limits regulate the flow of vehicles on a highway</li>
				<li><strong class="bold">Water faucet</strong>: Adjusting the flow of water from a faucet</li>
				<li><strong class="bold">Concert ticket sales</strong>: When tickets for a popular concert go on sale, the website may limit the number of tickets each user can purchase at once to prevent the server from crashing due to a sudden surge in demand</li>
				<li><strong class="bold">Electricity usage</strong>: Some utility companies offer plans where customers pay different rates based on their electricity usage during peak and off-peak hours</li>
				<li><strong class="bold">Buffet line</strong>: In a buffet, customers may be limited to taking only one plate of food at a time to ensure that everyone has a fair chance to eat and to prevent food<a id="_idIndexMarker860"/> wastage</li>
			</ul>
			<p>We also have examples of pieces of software that help implement throttling:</p>
			<ul>
				<li><code>django-throttle-requests</code> (<a href="https://github.com/sobotklp/django-throttle-requests">https://github.com/sobotklp/django-throttle-requests</a>) is a framework for<a id="_idIndexMarker861"/> implementing application-specific rate-limiting middleware for Django projects</li>
				<li>Flask-Limiter (<a href="https://flask-limiter.readthedocs.io/en/stable/">https://flask-limiter.readthedocs.io/en/stable/</a>) provides rate-limiting features to <a id="_idIndexMarker862"/>Flask routes</li>
			</ul>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor239"/>Use cases for the Throttling pattern</h2>
			<p>This pattern is<a id="_idIndexMarker863"/> recommended when you need to ensure your system continuously delivers the service as expected, when you need to optimize the <a id="_idIndexMarker864"/>cost of usage of the service, or when you need to handle bursts in activity.</p>
			<p>In practice, you may implement the following rules:</p>
			<ul>
				<li>Limit the number of total requests to an API as N/day (for example, N=1000)</li>
				<li>Limit the number of requests to an API as N/day from a given IP address, or from a given country or region</li>
				<li>Limit the number of reads or writes for authenticated users</li>
			</ul>
			<p>In addition to the rate-limiting cases, it can be used for <em class="italic">resource allocation</em>, ensuring fair distribution of resources among multiple clients.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor240"/>Implementing the Throttling pattern</h2>
			<p>Before diving into an <a id="_idIndexMarker865"/>implementation example, you need to know that there are several types of throttling, among which are Rate-Limit, IP-level Limit (based on a list of whitelisted IP addresses, for example), and Concurrent Connections Limit, to only cite those three. The first two are relatively easy to experiment with. We will focus on the first one here.</p>
			<p>Let’s see an example of rate-limit-type throttling using a minimal web application developed using Flask and its Flask-Limiter extension.</p>
			<p>We start with the imports we need for the example:</p>
			<pre class="source-code">
from flask import Flask
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address</pre>			<p>As is usual with Flask, we set up the Flask application with the following two lines:</p>
			<pre class="source-code">
app = Flask(__name__)</pre>			<p>We then define the Limiter instance; we create it by passing a key function, <code>get_remote_address</code> (which we imported), the application object, the default limits values, and other parameters, as follows:</p>
			<pre class="source-code">
limiter = Limiter(
    get_remote_address,
    app=app,
    default_limits=["100 per day", "10 per hour"],
    storage_uri="memory://",
    strategy="fixed-window",
)</pre>			<p>Based on that, we <a id="_idIndexMarker866"/>can define a route for the <code>/limited</code> path, which <a id="_idIndexMarker867"/>will be rate-limited using the default limits, as follows:</p>
			<pre class="source-code">
@app.route("/limited")
def limited_api():
    return "Welcome to our API!"</pre>			<p>We also add the definition for a route for the <code>/more_limited</code> path. In this case, we decorate the function with <code>@limiter.limit("2/minute")</code> to ensure a rate limit of two requests per minute. The code is as follows:</p>
			<pre class="source-code">
@app.route("/more_limited")
@limiter.limit("2/minute")
def more_limited_api():
    return "Welcome to our expensive, thus very limited, API!"</pre>			<p>Finally, we add the snippet that is conventional for Flask applications:</p>
			<pre class="source-code">
if __name__ == "__main__":
    app.run(debug=True)</pre>			<p>To test this example, run the file (<code>ch09/throttling_flaskapp.py</code>) using the <code>python ch09/throttling_flaskapp.py</code> command. You would get the<a id="_idIndexMarker868"/> usual output for a<a id="_idIndexMarker869"/> Flask application that is starting:</p>
			<div><div><img src="img/B21896_09_1.jpg" alt="Figure 9.1 – throttling_flaskapp: Flask application example startup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – throttling_flaskapp: Flask application example startup</p>
			<p>Then, if you point your browser to <code>http://127.0.0.1:5000/limited</code>, you will see the welcome content displayed on the page, as follows:</p>
			<div><div><img src="img/B21896_09_2.jpg" alt="Figure 9.2 – Response to the /limited endpoint in the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Response to the /limited endpoint in the browser</p>
			<p>It gets interesting if you keep hitting the <strong class="bold">Refresh</strong> button. The 10th time, the page content will change and show you a <strong class="bold">Too Many Requests</strong> error message, as shown in the following screenshot:</p>
			<div><div><img src="img/B21896_09_3.jpg" alt="Figure 9.3 – Too many requests on the /limited endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Too many requests on the /limited endpoint</p>
			<p>Let’s not<a id="_idIndexMarker870"/> stop here. Remember – there is a second route<a id="_idIndexMarker871"/> in the code, <code>/more_limited</code>, with a specific limit of two requests per minute. To test that second route, point your browser to <code>http://127.0.0.1:5000/more_limited</code>. You will see new welcome content displayed on the page, as follows:</p>
			<div><div><img src="img/B21896_09_4.jpg" alt="Figure 9.4 – Response to the /more_limited endpoint in the browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Response to the /more_limited endpoint in the browser</p>
			<p>If we hit the <strong class="bold">Refresh</strong> button and do it more than twice in a window of 1 minute, we get another <strong class="bold">Two Many Requests</strong> message, as shown in the following screenshot:</p>
			<div><div><img src="img/B21896_09_5.jpg" alt="Figure 9.5 – Too many requests on the /more_limited endpoint"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Too many requests on the /more_limited endpoint</p>
			<p>Also, looking at <a id="_idIndexMarker872"/>the console where the Flask server is <a id="_idIndexMarker873"/>running, you will notice the mention of each HTTP request received and the status code of the response the application sent. It should look like the following screenshot:</p>
			<div><div><img src="img/B21896_09_6.jpg" alt="Figure 9.6 – Flask server console: Responses to the HTTP requests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Flask server console: Responses to the HTTP requests</p>
			<p>There are many possibilities for rate-limit-type throttling in a Flask application using the Flask-Limiter extension, as you can see on the documentation page of the module. The reader can find more information on the documentation page on how to use different strategies and storage backends such as Redis for a specific implementation.</p>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor241"/>The Retry pattern</h1>
			<p>Retrying is an<a id="_idIndexMarker874"/> approach<a id="_idIndexMarker875"/> that is increasingly needed in the context of distributed systems. Think about microservices or cloud-based infrastructures where components co<a id="_idTextAnchor242"/>llaborate with each other but are not developed or deployed/operated by the same teams and parties.</p>
			<p>In its daily operation, parts of a cloud-native application may experience what are called transient faults or failures, meaning some mini-issues that can look like bugs but are not due to your application itself; rather, they are due to some constraints outside of your control such as the networking or the external server/service performance. As a result, your application may malfunction (at least, that could be the perception of your users) or even hang in some places. The answer to the risk of such failures is to put in place some retry logic so that we pass through the issue by calling the service again, maybe immediately or after some wait time (such as a few seconds).</p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor243"/>Real-world examples</h2>
			<p>There are examples of the Retry <a id="_idIndexMarker876"/>pattern (or analogies) in our daily life, such as the following:</p>
			<ul>
				<li><strong class="bold">Making a phone call</strong>: Imagine you’re trying to reach a friend on the phone, but the call doesn’t go through because their line is busy or there’s a network issue. Instead of giving up immediately, you retry dialing their number after a short delay.</li>
				<li><strong class="bold">Withdrawing money from an ATM</strong>: Imagine you go to an ATM to withdraw cash, but due to a temporary issue such as network congestion or connectivity problems, the transaction fails, and the machine displays an error message. Instead of giving up on getting cash, you wait a moment and try the transaction again. This time, the transaction may go through successfully, allowing you to withdraw the money you need.</li>
			</ul>
			<p>There are also many tools or techniques that we can consider as examples in the software realm since they help implement the Retry pattern, such as the following:</p>
			<ul>
				<li>In Python, the <a id="_idIndexMarker877"/>Retrying library (<a href="https://github.com/rholder/retrying">https://github.com/rholder/retrying</a>) is available to simplify the task of adding retry behavior to our functions</li>
				<li>The <a id="_idIndexMarker878"/>Pester library (<a href="https://github.com/sethgrid/pester">https://github.com/sethgrid/pester</a>) for Go developers</li>
			</ul>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor244"/>Use cases for the Retry pattern</h2>
			<p>This pattern<a id="_idIndexMarker879"/> is recommended to alleviate the impact of<a id="_idIndexMarker880"/> identified transient failures while communicating with an external component or service, due to network failure or server overload.</p>
			<p>Note that the retrying approach is not recommended for handling failures such as internal exceptions caused by errors in the application logic itself. Also, we must analyze the response from the external service. If the application experiences frequent busy faults, it’s often a sign that the service being accessed has a scaling issue that should be addressed.</p>
			<p>We can relate retrying to the microservices architecture, where services often communicate over the network. The Retry pattern ensures that transient failures don’t cause the entire system to fail.</p>
			<p>Another type of use case is <em class="italic">data synchronization</em>. When syncing data between two systems, retries can handle the temporary unavailability of one system.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor245"/>Implementing the Retry pattern</h2>
			<p>In this example, we’ll<a id="_idIndexMarker881"/> implement the Retry pattern for a database connection. We’ll use a decorator to handle the retry mech<a id="_idTextAnchor246"/>anism.</p>
			<p>We start with the <code>import</code> statements for the example, as follows:</p>
			<pre class="source-code">
import logging
import random
import time</pre>			<p>We then add configuration for logging, which will help for observability when using the code:</p>
			<pre class="source-code">
logging.basicConfig(level=logging.DEBUG)</pre>			<p>We add our function<a id="_idIndexMarker882"/> that will support the decorator to automatically retry the execution of the decorat<a id="_idTextAnchor247"/>ed function up to the number of attempts specified, as follows:</p>
			<pre class="source-code">
def retry(attempts):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(attempts):
                try:
                    logging.info("Retry happening")
                    return func(*args, **kwargs)
                except Exception as e:
                    time.sleep(1)
                    logging.debug(e)
            return "Failure after all attempts"
        return wrapper
    return decorator</pre>			<p>Then, we <a id="_idIndexMarker883"/>add the <code>connect_to_database()</code> function, which simulates a database connection. It is decorated by the <code>@retry</code> decorator. We want the decorator to automatically retry the connection up to three times if it fails:</p>
			<pre class="source-code">
@retry(attempts=3)
def connect_to_database():
    if random.randint(0, 1):
        raise Exception("Temporary Database Error")
    return "Connected to Database"</pre>			<p>Finally, to make it convenient to test our implementation, we add the following testing code:</p>
			<pre class="source-code">
if __name__ == "__main__":
    for i in range(1, 6):
        logging.info(f"Connection attempt #{i}")
        print(f"--&gt; {connect_to_database()}")</pre>			<p>To test the example, run the following command:</p>
			<pre class="source-code">
<strong class="bold">python ch09/retry/retry_database_connection.py</strong></pre>			<p>You should <a id="_idIndexMarker884"/>get an<a id="_idIndexMarker885"/> output like the following:</p>
			<pre class="source-code">
<strong class="bold">INFO:root:Connection attempt #1</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">--&gt; Connected to Database</strong>
<strong class="bold">INFO:root:Connection attempt #2</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">--&gt; Failure after all attempts</strong>
<strong class="bold">INFO:root:Connection attempt #3</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">--&gt; Connected to Database</strong>
<strong class="bold">INFO:root:Connection attempt #4</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">--&gt; Connected to Database</strong>
<strong class="bold">INFO:root:Connection attempt #5</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">INFO:root:Retry happening</strong>
<strong class="bold">DEBUG:root:Temporary Database Error</strong>
<strong class="bold">--&gt; Failure after all attempts</strong></pre>			<p>So, when a temporary database error occurs, a retry happens. Several retry attempts may occur, until three. Once three unsuccessful retry attempts have occurred, the outcome is the failure of the operation.</p>
			<p>Overall, the <a id="_idIndexMarker886"/>Retry pattern is a viable way to handle this type of <a id="_idIndexMarker887"/>use case involved with distributed systems, and a few errors (four database errors in our example) may mean that there is a more permanent or problematic bug that should be fixed.</p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor248"/>The Circuit Breaker pattern</h1>
			<p>One approach to <a id="_idIndexMarker888"/>FT involves retries, as we have just seen. But, when<a id="_idIndexMarker889"/> a failure due to communication with an external component is likely to be long-lasting, using a retry mechanism can affect the responsiveness of the application. We might be wasting time and resources trying to repeat a request that’s likely to fail. This is where another pattern can be useful: the Circuit Breaker pattern.</p>
			<p>With the Circuit Breaker pattern, you wrap a fragile function call, or an integration point with an external service, in a special (circuit breaker) object, which monitors for failures. Once the failures reach a certain threshold, the circuit breaker trips and all subsequent calls to the circuit breaker return with an error, without the protected call being made at all.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor249"/>Real-world examples</h2>
			<p>In life, we can think of a water or electricity distribution circuit where a circuit breaker plays an important role.</p>
			<p>In software, a <a id="_idIndexMarker890"/>circuit breaker is used in the following <a id="_idIndexMarker891"/>examples:</p>
			<ul>
				<li><strong class="bold">E-commerce checkout</strong>: If the payment gateway is down, the circuit breaker can halt further payment attempts, preventing system overload</li>
				<li><strong class="bold">Rate-limited APIs</strong>: When an API has reached its rate limit, a circuit breaker can stop additional requests to avoid penalties</li>
			</ul>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor250"/>Use cases for the Circuit Breaker pattern</h2>
			<p>As already said, the <a id="_idIndexMarker892"/>Circuit Breaker pattern is recommended when you need a component from your system to be fault-tolerant to long-lasting failures when communicating with an external component, service, or resource. Next, we will understand how it addresses such use cases.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor251"/>Implementing the Circuit Breaker pattern</h2>
			<p>Let’s say you want to use a circuit <a id="_idIndexMarker893"/>breaker on a flaky function, a function that is fragile, for example, due to the networking environment it depends on. We are going to use<a id="_idIndexMarker894"/> the <code>pybreaker</code> library (<a href="https://pypi.org/project/pybreaker/">https://pypi.org/project/pybreaker/</a>) to show an example of implementing the Circuit Breaker pattern.</p>
			<p>Our implementation is an adaptation of a nice script I found in this repository: <a href="https://github.com/veltra/pybreaker-playground">https://github.com/veltra/pybreaker-playground</a>. Let’s go through the code.</p>
			<p>We start with our imports, as follows:</p>
			<pre class="source-code">
import pybreaker
from datetime import datetime
import random
from time import sleep</pre>			<p>Let’s define our circuit breaker to automatically open the circuit after five consecutive failures in that function. We need to create an instance of the <code>pybreaker.CircuitBreaker</code> class, as follows:</p>
			<pre class="source-code">
breaker = pybreaker.CircuitBreaker(fail_max=2, reset_timeout=5)</pre>			<p>Then, we <a id="_idIndexMarker895"/>create our version of the function to simulate <a id="_idIndexMarker896"/>fragile calls. We use the decorator syntax to protect things, so the new function is as follows:</p>
			<pre class="source-code">
@breaker
def fragile_function():
    if not random.choice([True, False]):
        print(" / OK", end="")
    else:
        print(" / FAIL", end="")
        raise Exception("This is a sample Exception")</pre>			<p>Finally, here’s the main part of the code, with the <code>main()</code> function:</p>
			<pre class="source-code">
def main():
    while True:
        print(datetime.now().strftime("%Y-%m-%d %H:%M:%S"), end="")
        try:
            fragile_function()
        except Exception as e:
            print(" / {} {}".format(type(e), e), end="")
        finally:
            print("")
            sleep(1)</pre>			<p>Calling this script by running the <code>python ch09/circuit_breaker.py</code> command produces the following output:</p>
			<div><div><img src="img/B21896_09_7.jpg" alt="Figure 9.7 – Output of our program using a circuit breaker"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Output of our program using a circuit breaker</p>
			<p>By closely<a id="_idIndexMarker897"/> looking at the output, we can see that the <a id="_idIndexMarker898"/>circuit breaker does its job as expected: when it is open, all <code>fragile_function()</code> calls fail immediately (since they raise the <code>CircuitBreakerError</code> exception) without any attempt to execute the intended operation. And, after a timeout of 5 seconds, the circuit breaker will allow the next call to go through. If that call succeeds, the circuit is closed; if it fails, the circuit is opened again until another timeout elapses.</p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor252"/>Other distributed systems patterns</h1>
			<p>There are many more distributed systems patterns than the ones we covered here. Among the other patterns developers and architects can use are the following:</p>
			<ul>
				<li><strong class="bold">Command and Query Responsibility Segregation (CQRS)</strong>: This pattern separates the <a id="_idIndexMarker899"/>responsibilities for <a id="_idIndexMarker900"/>reading and writing data, allowing for optimized data access and scalability by tailoring data models and operations to specific use cases</li>
				<li><strong class="bold">Two-Phase Commit</strong>: This<a id="_idIndexMarker901"/> distributed transaction<a id="_idIndexMarker902"/> protocol ensures atomicity and consistency across multiple participating resources by coordinating<a id="_idTextAnchor253"/> a two-phase commit process, involving a <em class="italic">prepare</em> phase followed by a <em class="italic">commit</em> phase</li>
				<li><strong class="bold">Saga</strong>: A saga<a id="_idIndexMarker903"/> is a sequence of local transactions that <a id="_idIndexMarker904"/>together form a distributed transaction, providing a compensating mechanism to maintain consistency in the face of partial failures or aborted transactions</li>
				<li><strong class="bold">Sidecar</strong>: The<a id="_idIndexMarker905"/> Sidecar pattern<a id="_idIndexMarker906"/> involves deploying additional helper services alongside primary services to enhance functionality, such as adding monitoring, logging, or security features without directly modifying the main application</li>
				<li><strong class="bold">Service Registry</strong>: This pattern centralizes the management and discovery of services within a distributed<a id="_idIndexMarker907"/> system, allowing services to <a id="_idIndexMarker908"/>dynamically register and discover each other, facilitating communication and scalability</li>
				<li><strong class="bold">Bulkhead</strong>: Inspired by ship design, the<a id="_idIndexMarker909"/> Bulkhead pattern<a id="_idIndexMarker910"/> partitions resources or components within a system to isolate failures and prevent cascading failures from impacting other parts of the system, thereby enhancing FT and resilience</li>
			</ul>
			<p>Each of these patterns addresses specific challenges inherent in distributed systems, offering strategies and best practices for architects and developers to design robust and scalable solutions capable of operating in dynamic and unpredictable environments.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor254"/>Summary</h1>
			<p>In this chapter, we delved into the intricacies of distributed systems patterns, focusing on the Throttling, Retry, and Circuit Breaker patterns. These patterns are essential for building robust, fault-tolerant, and efficient distributed systems.</p>
			<p>The skills you’ve acquired in this chapter will significantly contribute to your ability to design and implement distributed systems that can handle transient failures, service interruptions, and high loads.</p>
			<p>The section about the Throttling pattern equipped you with the tools to manage service load and resource allocation effectively.</p>
			<p>By understanding how to implement the Retry pattern, you’ve gained the skills to make your operations more reliable.</p>
			<p>And, finally, the Circuit Breaker pattern taught you how to build fault-tolerant systems that can gracefully handle failures.</p>
			<p>As we wrap up this chapter, it’s crucial to remember that these patterns are not isolated solutions but pieces of a larger puzzle. They often work best when combined and tailored to fit the specific needs and constraints of your system. The key takeaway is to understand the underlying principles so that you ca<a id="_idTextAnchor255"/>n adapt them to create a resilient and efficient distributed system.</p>
			<p>Lastly, we briefly presented some other distributed systems patterns, which we cannot cover in this book.</p>
			<p>In the next chapter, we will focus on patterns for testing.</p>
		</div>
	</body></html>