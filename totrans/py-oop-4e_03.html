<html><head></head><body>
  <div id="_idContainer064">
    <h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-63" class="chapterTitle">When Objects Are Alike</h1>
    <p class="normal">In the programming world, duplicate code is considered evil. We should not have multiple copies of the same, or similar, code in different places. When we fix a bug in one copy and fail to fix the same bug in another copy, we've caused no end of problems for ourselves. </p>
    <p class="normal">There are many ways to merge pieces of code or objects that have a similar functionality. In this chapter, we'll be covering the most famous object-oriented principle: inheritance. As discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Object-Oriented Design</em>, inheritance allows us to create "is-a" relationships between two or more classes, abstracting common logic into superclasses and extending the superclass with specific details in each subclass. In particular, we'll be covering the Python syntax and principles for the following:</p>
    <ul>
      <li class="bullet">Basic inheritance</li>
      <li class="bullet">Inheriting from built-in types</li>
      <li class="bullet">Multiple inheritance</li>
      <li class="bullet">Polymorphism and duck typing</li>
    </ul>
    <p class="normal">This chapter's case study will expand on the previous chapter. We'll leverage the concepts of inheritance and abstraction to look for ways to manage common code in parts of the <em class="italic">k</em>-nearest neighbors computation.</p>
    <p class="normal">We'll start by taking a close look at how inheritance works to factor out common features so we can avoid copy-and-paste programming.</p>
    <h1 id="_idParaDest-64" class="title">Basic inheritance</h1>
    <p class="normal">Technically, every <a id="_idIndexMarker172"/>class we create uses inheritance. All Python classes are<a id="_idIndexMarker173"/> subclasses of the special built-in class named <code class="Code-In-Text--PACKT-">object</code>. This class provides a little bit of metadata and a few built-in behaviors so Python can treat all objects consistently.</p>
    <p class="normal">If we don't explicitly inherit from a different class, our classes will automatically inherit from <code class="Code-In-Text--PACKT-">object</code>. However, we can redundantly state that our class derives from <code class="Code-In-Text--PACKT-">object</code> using the following syntax:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MySubClass</span><span class="hljs-class">(</span><span class="hljs-built_in">object</span><span class="hljs-class">):</span> 
    <span class="hljs-keyword">pass</span> 
</code></pre>
    <p class="normal">This is<a id="_idIndexMarker174"/> inheritance! This example is, technically, no different from our very first example in <em class="chapterRef">Chapter 2</em>, <em class="italic">Objects in Python</em>. In Python 3, all classes automatically inherit from <code class="Code-In-Text--PACKT-">object</code> if we don't explicitly provide a <a id="_idIndexMarker175"/>different <strong class="keyword">superclass</strong>. The superclasses, or <em class="italic">parent</em> classes, in the relationship are the classes that are being inherited from, <code class="Code-In-Text--PACKT-">object</code> in this example. A subclass – <code class="Code-In-Text--PACKT-">MySubClass</code>, in this example – inherits from a superclass. A subclass<a id="_idIndexMarker176"/> is also said to be <em class="italic">derived from</em> its parent class, or the subclass <em class="italic">extends</em> the parent class. </p>
    <p class="normal">As you've probably figured out from the example, inheritance requires a minimal amount of extra syntax over a basic class definition. Simply include the name of the parent class inside parentheses between the class name and the colon that follows. This is all we have to do to tell Python that the new class should be derived from the given superclass.</p>
    <p class="normal">How do we apply inheritance<a id="_idIndexMarker177"/> in practice? The simplest and most obvious use of inheritance is to add functionality to an existing class. Let's start with a contact manager that tracks the names and email addresses of several people. The <code class="Code-In-Text--PACKT-">Contact</code> class is responsible for maintaining a global list of all contacts ever seen in a class variable, and for initializing the name and address for an individual contact:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Contact</span><span class="hljs-class">:</span>
   all_contacts: List[<span class="hljs-string">"Contact"</span>] = []
   <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, name: </span><span class="hljs-built_in">str</span><span class="hljs-params">, email: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
       self.name = name
       self.email = email
       Contact.all_contacts.append(self)
   <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
       <span class="hljs-keyword">return</span> (
           <span class="hljs-string">f"</span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-string">("</span>
           <span class="hljs-string">f"</span><span class="hljs-subst">{self.name!r}</span><span class="hljs-string">, </span><span class="hljs-subst">{self.email!r}</span><span class="hljs-string">"</span>
           <span class="hljs-string">f")"</span>
      )
</code></pre>
    <p class="normal">This example <a id="_idIndexMarker178"/>introduces us to <strong class="keyword">class variables</strong>. The <code class="Code-In-Text--PACKT-">all_contacts</code> list, because it is part of the class definition, is shared by all instances of this class. This means that there is only one <code class="Code-In-Text--PACKT-">Contact.all_contacts</code> list. We can also access it as <code class="Code-In-Text--PACKT-">self.all_contacts</code> from within any method on an instance of the <code class="Code-In-Text--PACKT-">Contact</code> class. If a field can't be found on the object (via <code class="Code-In-Text--PACKT-">self</code>), then it will be found on the class and will thus refer to the same single list.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Be careful with the <code class="Code-In-Text--PACKT-">self</code>-based reference. It can only provide access to an existing class-based variable. If you ever attempt to <strong class="" style="font-style: italic;">set</strong> the variable using <code class="Code-In-Text--PACKT-">self.all_contacts</code>, you will actually be creating a <strong class="" style="font-style: italic;">new</strong> instance variable associated just with that object. The class variable will still be unchanged and accessible as <code class="Code-In-Text--PACKT-">Contact.all_contacts</code>.</p>
    </div>
    <p class="normal">We can see how the class tracks data with the following example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c_1 = Contact(</span><span class="hljs-con-string">"Dusty"</span><span class="python">, </span><span class="hljs-con-string">"dusty@example.com"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c_2 = Contact(</span><span class="hljs-con-string">"Steve"</span><span class="python">, </span><span class="hljs-con-string">"steve@itmaybeahack.com"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Contact.all_contacts</span>
[Contact('Dusty', 'dusty@example.com'), Contact('Steve', 'steve@itmaybeahack.com')]
</code></pre>
    <p class="normal">We created two instances of the <code class="Code-In-Text--PACKT-">Contact</code> class and assigned them to variables <code class="Code-In-Text--PACKT-">c_1</code> and <code class="Code-In-Text--PACKT-">c_2</code>. When we looked at the <code class="Code-In-Text--PACKT-">Contact.all_contacts</code> class variable, we saw that the list has been updated to track the two objects. </p>
    <p class="normal">This is a <a id="_idIndexMarker179"/>simple class that allows us to track a couple of pieces of data about each contact. But what if some of our contacts are also suppliers that we need to order supplies from? We could add an <code class="Code-In-Text--PACKT-">order</code> method to the <code class="Code-In-Text--PACKT-">Contact</code> class, but that would allow people to accidentally order things from contacts who are customers or family friends. Instead, let's create a new <code class="Code-In-Text--PACKT-">Supplier</code> class that acts like our <code class="Code-In-Text--PACKT-">Contact</code> class, but has an additional <code class="Code-In-Text--PACKT-">order</code> method that accepts a yet-to-be-defined <code class="Code-In-Text--PACKT-">Order</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Supplier</span><span class="hljs-class">(</span><span class="hljs-params">Contact</span><span class="hljs-class">):</span>
   <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">order</span><span class="hljs-function">(</span><span class="hljs-params">self, order: </span><span class="hljs-string">"Order"</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
       print(
           <span class="hljs-string">"If this were a real system we would send "</span>
           <span class="hljs-string">f"'</span><span class="hljs-subst">{order}</span><span class="hljs-string">' order to '</span><span class="hljs-subst">{self.name}</span><span class="hljs-string">'"</span>
       )
</code></pre>
    <p class="normal">Now, if we test this class in our trusty interpreter, we see that all contacts, including suppliers, accept a name and email address in their <code class="Code-In-Text--PACKT-">__init__()</code> method, but that only <code class="Code-In-Text--PACKT-">Supplier</code> instances have an <code class="Code-In-Text--PACKT-">order()</code> method:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c = Contact(</span><span class="hljs-con-string">"Some Body"</span><span class="python">, </span><span class="hljs-con-string">"somebody@example.net"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s = Supplier(</span><span class="hljs-con-string">"Sup Plier"</span><span class="python">, </span><span class="hljs-con-string">"supplier@example.net"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(c.name, c.email, s.name, s.email)</span>
Some Body somebody@example.net Sup Plier supplier@example.net
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> pprint </span><span class="hljs-con-keyword">import</span><span class="python"> pprint</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pprint(c.all_contacts)</span>
[Contact('Dusty', 'dusty@example.com'),
 Contact('Steve', 'steve@itmaybeahack.com'),
 Contact('Some Body', 'somebody@example.net'),
 Supplier('Sup Plier', 'supplier@example.net')]
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c.order(</span><span class="hljs-con-string">"I need pliers"</span><span class="python">)</span>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Contact' object has no attribute 'order'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.order(</span><span class="hljs-con-string">"I need pliers"</span><span class="python">)</span>
If this were a real system we would send 'I need pliers' order to 'Sup Plier'
</code></pre>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">Supplier</code> class<a id="_idIndexMarker180"/> can do everything a contact can do (including adding itself to the list of <code class="Code-In-Text--PACKT-">Contact.all_contacts</code>) and all the special things it needs to handle as a supplier. This is the beauty of inheritance.</p>
    <p class="normal">Also, note that <code class="Code-In-Text--PACKT-">Contact.all_contacts</code> has collected every instance of the <code class="Code-In-Text--PACKT-">Contact</code> class as well as the subclass, <code class="Code-In-Text--PACKT-">Supplier</code>. If we used <code class="Code-In-Text--PACKT-">self.all_contacts</code>, then this would <strong class="" style="font-style: italic;">not</strong> collect all objects into the <code class="Code-In-Text--PACKT-">Contact</code> class, but would put <code class="Code-In-Text--PACKT-">Supplier</code> instances into <code class="Code-In-Text--PACKT-">Supplier.all_contacts</code>.</p>
    <h2 id="_idParaDest-65" class="title">Extending built-ins</h2>
    <p class="normal">One interesting <a id="_idIndexMarker181"/>use of this kind of inheritance is adding functionality to built-in classes. In the <code class="Code-In-Text--PACKT-">Contact</code> class seen earlier, we are adding contacts to a list of all contacts. What if we also wanted to search that list by name? Well, we could add a method on the <code class="Code-In-Text--PACKT-">Contact</code> class to search it, but it feels like this method actually belongs to the list itself. </p>
    <p class="normal">The following example shows how we can do this using inheritance from a built-in type. In this case, we're using the <code class="Code-In-Text--PACKT-">list</code> type. We're going to inform <strong class="" style="font-style: italic;">mypy</strong> that our list is only of instances of the <code class="Code-In-Text--PACKT-">Contact</code> class by using <code class="Code-In-Text--PACKT-">list["Contact"]</code>. For this syntax to work in Python 3.9, we need to also import the <code class="Code-In-Text--PACKT-">annotations</code> module from the <code class="Code-In-Text--PACKT-">__future__</code> package. The <a id="_idIndexMarker182"/>definitions look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ContactList</span><span class="hljs-class">(</span><span class="hljs-built_in">list</span><span class="hljs-params">[</span><span class="hljs-string">"Contact"</span><span class="hljs-params">]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">search</span><span class="hljs-function">(</span><span class="hljs-params">self, name: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; list["Contact"]:</span>
        matching_contacts: <span class="hljs-built_in">list</span>[<span class="hljs-string">"Contact"</span>] = []
        <span class="hljs-keyword">for</span> contact <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> contact.name:
                matching_contacts.append(contact)
        <span class="hljs-keyword">return</span> matching_contacts
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Contact</span><span class="hljs-class">:</span>
    all_contacts = ContactList()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, name: </span><span class="hljs-built_in">str</span><span class="hljs-params">, email: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.name = name
        self.email = email
        Contact.all_contacts.append(self)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return</span> (
            <span class="hljs-string">f"</span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-string">("</span> 
            <span class="hljs-string">f"</span><span class="hljs-subst">{self.name!r}</span><span class="hljs-string">, </span><span class="hljs-subst">{self.email!r}</span><span class="hljs-string">"</span> <span class="hljs-string">f")"</span>
        )
</code></pre>
    <p class="normal">Instead of instantiating a generic list as our class variable, we create a new <code class="Code-In-Text--PACKT-">ContactList</code> class that extends the built-in <code class="Code-In-Text--PACKT-">list</code> data type. Then, we instantiate this subclass as our <code class="Code-In-Text--PACKT-">all_contacts</code> list. We can test the new search functionality as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c1 = Contact(</span><span class="hljs-con-string">"John A"</span><span class="python">, </span><span class="hljs-con-string">"johna@example.net"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c2 = Contact(</span><span class="hljs-con-string">"John B"</span><span class="python">, </span><span class="hljs-con-string">"johnb@sloop.net"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c3 = Contact(</span><span class="hljs-con-string">"Jenna C"</span><span class="python">, </span><span class="hljs-con-string">"cutty@sark.io"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">[c.name </span><span class="hljs-con-keyword">for</span><span class="python"> c </span><span class="hljs-con-keyword">in</span><span class="python"> Contact.all_contacts.search(</span><span class="hljs-con-string">'John'</span><span class="python">)]</span>
['John A', 'John B']  
</code></pre>
    <p class="normal">We have two ways to create generic list objects. With type hints, we have another way of talking about lists, separate from creating actual list instances.</p>
    <p class="normal">First, creating a list with <code class="Code-In-Text--PACKT-">[]</code> is actually a shortcut for creating a list using <code class="Code-In-Text--PACKT-">list()</code>; the two syntaxes behave identically:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">[] == </span><span class="hljs-con-built_in">list</span><span class="python">()</span>
True  
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">[]</code> is short and sweet. We can call it <strong class="keyword">syntactic sugar</strong>; it is a call to the <code class="Code-In-Text--PACKT-">list()</code> constructor, written with two <a id="_idIndexMarker183"/>characters instead of six. The <code class="Code-In-Text--PACKT-">list</code> name refers to a data type: it is a class that we can extend.</p>
    <p class="normal">Tools like <strong class="" style="font-style: italic;">mypy</strong> can <a id="_idIndexMarker184"/>check the body of the <code class="Code-In-Text--PACKT-">ContactList.search()</code> method to be sure it really will create a <code class="Code-In-Text--PACKT-">list</code> instance populated with <code class="Code-In-Text--PACKT-">Contact</code> objects. Be sure you've installed a version that's 0.812 or newer; older versions of <strong class="" style="font-style: italic;">mypy</strong> don't handle these annotations based on generic types completely.</p>
    <p class="normal">Because we provided the <code class="Code-In-Text--PACKT-">Contact</code> class definition after the definition of the <code class="Code-In-Text--PACKT-">ContactList</code> class, we had to provide the reference to a not-yet-defined class as a string, <code class="Code-In-Text--PACKT-">list["Contact"]</code>. It's often more common to provide the individual item class definition first, and the collection can then refer to the defined class by name without using a string. </p>
    <p class="normal">As a second example, we can extend the <code class="Code-In-Text--PACKT-">dict</code> class, which is a collection of keys and their associated values. We can create instances of dictionaries using the <code class="Code-In-Text--PACKT-">{}</code> syntax sugar. Here's an extended dictionary that tracks the longest key it has seen:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LongNameDict</span><span class="hljs-class">(</span><span class="hljs-built_in">dict</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">, </span><span class="hljs-built_in">int</span><span class="hljs-params">]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">longest_key</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; Optional[str]:</span>
        <span class="hljs-string">"""In effect, max(self, key=len), but less obscure"""</span>
        longest = <span class="hljs-literal">None</span>
        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">if</span> longest <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(key) &gt; <span class="hljs-built_in">len</span>(longest):
                longest = key
        <span class="hljs-keyword">return</span> longest
</code></pre>
    <p class="normal">The hint for the class narrowed the generic <code class="Code-In-Text--PACKT-">dict</code> to a more specific <code class="Code-In-Text--PACKT-">dict[str, int]</code>; the keys are of type <code class="Code-In-Text--PACKT-">str</code> and the values are of type <code class="Code-In-Text--PACKT-">int</code>. This helps <strong class="" style="font-style: italic;">mypy</strong> reason about the <code class="Code-In-Text--PACKT-">longest_key()</code> method. Since the keys are supposed to be <code class="Code-In-Text--PACKT-">str</code>-type objects, the statement <code class="Code-In-Text--PACKT-">for key in self:</code> will iterate over <code class="Code-In-Text--PACKT-">str</code> objects. The result will be a <code class="Code-In-Text--PACKT-">str</code>, or possibly <code class="Code-In-Text--PACKT-">None</code>. That's why the result is described as <code class="Code-In-Text--PACKT-">Optional[str]</code>. (Is <code class="Code-In-Text--PACKT-">None</code> appropriate? Perhaps not. Perhaps a <code class="Code-In-Text--PACKT-">ValueError</code> exception is a better idea; that will have to wait until <em class="chapterRef">Chapter 4</em>, <em class="italic">Expecting the Unexpected</em>.)</p>
    <p class="normal">We're going to be <a id="_idIndexMarker185"/>working with strings and integer values. Perhaps the strings are usernames, and the integer values are the number of articles they've read on a website. In addition to the core username and reading history, we also need to know the longest name so we can format a table of scores with the right size display box. This is easy to test in the interactive interpreter:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">articles_read = LongNameDict()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">articles_read[</span><span class="hljs-con-string">'lucy'</span><span class="python">] = </span><span class="hljs-con-number">42</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">articles_read[</span><span class="hljs-con-string">'c_c_phillips'</span><span class="python">] = </span><span class="hljs-con-number">6</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">articles_read[</span><span class="hljs-con-string">'steve'</span><span class="python">] = </span><span class="hljs-con-number">7</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">articles_read.longest_key()</span>
'c_c_phillips'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">max</span><span class="python">(articles_read, key=</span><span class="hljs-con-built_in">len</span><span class="python">)</span>
'c_c_phillips'
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">What if we wanted a more generic dictionary? Say with either strings <strong class="" style="font-style: italic;">or</strong> integers as the values? We'd need a slightly more expansive type hint. We might use <code class="Code-In-Text--PACKT-">dict[str, Union[str, int]]</code> to describe a dictionary mapping strings to a union of either strings or integers. </p>
    </div>
    <p class="normal">Most built-in types can be similarly extended. These built-in types fall into several interesting families, with separate kinds<a id="_idIndexMarker186"/> of type hints:</p>
    <ul>
      <li class="bullet">Generic collections: <code class="Code-In-Text--PACKT-">set</code>, <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">dict</code>. These use type hints like <code class="Code-In-Text--PACKT-">set[something]</code>, <code class="Code-In-Text--PACKT-">list[something]</code>, and <code class="Code-In-Text--PACKT-">dict[key, value]</code> to narrow the hint from purely generic to something <a id="_idIndexMarker187"/>more specific that the application will actually use. To use the generic types as annotations, a <code class="Code-In-Text--PACKT-">from __future__ import annotations</code> is required as the first line of code.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">typing.NamedTuple</code> definition lets us define new kinds of immutable tuples and provide useful names for the members. This will be covered in <em class="chapterRef">Chapter 7</em>, <em class="italic">Python Data Structures</em>, and <em class="chapterRef">Chapter 8</em>, <em class="italic">The Intersection of Object-Oriented and Functional Programming</em>.</li>
      <li class="bullet">Python has type hints for file-related I/O objects. A new kind of file can use a type hint of <code class="Code-In-Text--PACKT-">typing.TextIO</code> or <code class="Code-In-Text--PACKT-">typing.BinaryIO</code> to describe built-in file operations.</li>
      <li class="bullet">It's possible to create new types of strings by extending <code class="Code-In-Text--PACKT-">typing.Text</code>. For the most part, the built-in <code class="Code-In-Text--PACKT-">str</code> class does everything we need.</li>
      <li class="bullet">New numeric types often start with the <code class="Code-In-Text--PACKT-">numbers</code> module as a source for built-in numeric functionality.</li>
    </ul>
    <p class="normal">We'll use the generic collections heavily throughout the book. As noted, we'll look at named tuples in later chapters. The other extensions to built-in types are too advanced for this book. In the next section, we'll look more deeply at the benefits of inheritance and how we can selectively leverage features of the superclass in our subclass.</p>
    <h2 id="_idParaDest-66" class="title">Overriding and super</h2>
    <p class="normal">So, inheritance is great for <em class="italic">adding</em> new behavior to existing classes, but what about <em class="italic">changing</em> behavior? Our <code class="Code-In-Text--PACKT-">Contact</code> class allows only a name and an email address. This may be sufficient for most contacts, but what if we want to add a phone number for our close friends?</p>
    <p class="normal">As we saw in <em class="chapterRef">Chapter 2</em>, <em class="italic">Objects in Python</em>, we can do this easily by setting a <code class="Code-In-Text--PACKT-">phone</code> attribute on the contact after it is constructed. But if we want to make this third variable available on initialization, we have to override the <code class="Code-In-Text--PACKT-">__init__()</code> method. Overriding<a id="_idIndexMarker188"/> means altering or<a id="_idIndexMarker189"/> replacing a method of the superclass with a new method (with the same name) in the subclass. No special syntax is needed to do this; the subclass's newly created method is automatically called instead of the superclass's method, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Friend</span><span class="hljs-class">(</span><span class="hljs-params">Contact</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, name: </span><span class="hljs-built_in">str</span><span class="hljs-params">, email: </span><span class="hljs-built_in">str</span><span class="hljs-params">, phone: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.name = name
        self.email = email
        self.phone = phone
</code></pre>
    <p class="normal">Any method can be overridden, not just <code class="Code-In-Text--PACKT-">__init__()</code>. Before we go on, however, we need to address some problems in this example. Our <code class="Code-In-Text--PACKT-">Contact</code> and <code class="Code-In-Text--PACKT-">Friend</code> classes have duplicate code to set up the <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">email</code> properties; this can make code maintenance complicated, as we have to update the code in two or more places. More alarmingly, our <code class="Code-In-Text--PACKT-">Friend</code> class is neglecting to add itself to the <code class="Code-In-Text--PACKT-">all_contacts</code> list we have created on the <code class="Code-In-Text--PACKT-">Contact</code> class. Finally, looking forward, if we add a feature to the <code class="Code-In-Text--PACKT-">Contact</code> class, we'd like it to also be part of the <code class="Code-In-Text--PACKT-">Friend</code> class. </p>
    <p class="normal">What we really need is a way to execute the original <code class="Code-In-Text--PACKT-">__init__()</code> method on the <code class="Code-In-Text--PACKT-">Contact</code> class from inside our new class. This is what the <code class="Code-In-Text--PACKT-">super()</code> function does; it returns the object as if it was actually an instance of the parent class, allowing us to call the parent method directly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Friend</span><span class="hljs-class">(</span><span class="hljs-params">Contact</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, name: </span><span class="hljs-built_in">str</span><span class="hljs-params">, email: </span><span class="hljs-built_in">str</span><span class="hljs-params">, phone: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(name, email)
        self.phone = phone
</code></pre>
    <p class="normal">This example first binds the instance to the parent class using <code class="Code-In-Text--PACKT-">super()</code> and calls <code class="Code-In-Text--PACKT-">__init__()</code> on that object, passing in the expected arguments. It then does its own initialization, namely, setting the <code class="Code-In-Text--PACKT-">phone</code> attribute, which is unique to the <code class="Code-In-Text--PACKT-">Friend</code> class.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Contact</code> class provided a definition for the <code class="Code-In-Text--PACKT-">__repr__()</code> method to produce a string representation. Our class did not override the <code class="Code-In-Text--PACKT-">__repr__()</code> method inherited from the superclass. Here's the consequence of that:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">f = Friend(</span><span class="hljs-con-string">"Dusty"</span><span class="python">, </span><span class="hljs-con-string">"Dusty@private.com"</span><span class="python">, </span><span class="hljs-con-string">"555-1212"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Contact.all_contacts</span>
[Friend('Dusty', 'Dusty@private.com')]
</code></pre>
    <p class="normal">The details shown for a <code class="Code-In-Text--PACKT-">Friend</code> instance don't include the new attribute. It's easy to overlook the special method definitions when thinking about class design. </p>
    <p class="normal">A <code class="Code-In-Text--PACKT-">super()</code> call can be <a id="_idIndexMarker190"/>made inside<a id="_idIndexMarker191"/> any method. Therefore, all methods can be modified via overriding and calls to <code class="Code-In-Text--PACKT-">super()</code>. The call to <code class="Code-In-Text--PACKT-">super()</code> can also be made at any point in the method; we don't have to make the call as the first line. For example, we may need to manipulate or validate incoming parameters before forwarding them to the superclass.</p>
    <h1 id="_idParaDest-67" class="title">Multiple inheritance</h1>
    <p class="normal">Multiple inheritance<a id="_idIndexMarker192"/> is a touchy subject. In principle, it's simple: a subclass that inherits<a id="_idIndexMarker193"/> from more than one parent class can access functionality from both of them. In practice, it requires some care to be sure any method overrides are fully understood.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">As a humorous rule of thumb, if you think you need multiple inheritance, you're probably wrong, but if you know you need it, you might be right.</p>
    </div>
    <p class="normal">The simplest and most useful form of multiple inheritance follows a design pattern called the <strong class="keyword">mixin</strong>. A mixin<a id="_idIndexMarker194"/> class definition is not intended to exist on its own, but is meant to be inherited by some other class to provide extra functionality. For example, let's say we wanted to add functionality to our <code class="Code-In-Text--PACKT-">Contact</code> class that allows sending an email to <code class="Code-In-Text--PACKT-">self.email</code>. </p>
    <p class="normal">Sending email is a common task that we might want to use on many other classes. So, we can write a simple mixin class to do the emailing for us:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Emailable</span><span class="hljs-class">(</span><span class="hljs-params">Protocol</span><span class="hljs-class">):</span>
    email: <span class="hljs-built_in">str</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MailSender</span><span class="hljs-class">(</span><span class="hljs-params">Emailable</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">send_mail</span><span class="hljs-function">(</span><span class="hljs-params">self, message: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        print(<span class="hljs-string">f"Sending mail to </span><span class="hljs-subst">{self.email=}</span><span class="hljs-string">"</span>)
        <span class="hljs-comment"># Add e-mail logic here</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MailSender</code> class doesn't do anything special (in fact, it can barely function as a standalone class, since <a id="_idIndexMarker195"/>it assumes an attribute it doesn't set). We have two classes because we're describing two things: aspects of the host class for a mixin, and new aspects the mixin provides to the host. We needed to create a hint, <code class="Code-In-Text--PACKT-">Emailable</code>, to describe the kinds <a id="_idIndexMarker196"/>of classes our <code class="Code-In-Text--PACKT-">MailSender</code> mixin expects to work with. </p>
    <p class="normal">This kind of type hint is<a id="_idIndexMarker197"/> called a <strong class="keyword">protocol</strong>; protocols generally have methods, and can also have class-level attribute names with type hints, but not full assignment statements. A protocol definition is a kind of incomplete class; think of it like a contract for features of a class. A protocol tells <strong class="" style="font-style: italic;">mypy</strong> that any class (or subclass) of <code class="Code-In-Text--PACKT-">Emailable</code> objects must support an <code class="Code-In-Text--PACKT-">email</code> attribute, and it must be a string.</p>
    <p class="normal">Note that we're relying on Python's name resolution rules. The name <code class="Code-In-Text--PACKT-">self.email</code> can be resolved as either an instance variable, or a class-level variable, <code class="Code-In-Text--PACKT-">Emailable.email</code>, or a property. The <strong class="" style="font-style: italic;">mypy</strong> tool<a id="_idIndexMarker198"/> will check all the classes mixed in with <code class="Code-In-Text--PACKT-">MailSender</code> for instance- or class-level definitions. We only need to provide the name of the attribute at the class level, with a type hint to make it clear to <strong class="" style="font-style: italic;">mypy</strong> that the mixin does not define the attribute – the class into which it's mixed will provide the <code class="Code-In-Text--PACKT-">email</code> attribute.</p>
    <p class="normal">Because of Python's duck typing rules, we can use the <code class="Code-In-Text--PACKT-">MailSender</code> mixin with any class that has an <code class="Code-In-Text--PACKT-">email</code> attribute defined. A class with which <code class="Code-In-Text--PACKT-">MailSender</code> is mixed doesn't have to be a formal subclass of <code class="Code-In-Text--PACKT-">Emailable</code>; it only has to provide the required attribute.</p>
    <p class="normal">For brevity, we didn't include the actual email logic here; if you're interested in studying how it's done, see the <code class="Code-In-Text--PACKT-">smtplib</code> module in the Python standard library.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MailSender</code> class does allow us to define a new class that describes both a <code class="Code-In-Text--PACKT-">Contact</code> and a <code class="Code-In-Text--PACKT-">MailSender</code>, using multiple inheritance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">EmailableContact</span><span class="hljs-class">(</span><span class="hljs-params">Contact, MailSender</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">The syntax for <a id="_idIndexMarker199"/>multiple inheritance looks like a parameter list in the class definition. Instead of including one base class inside the parentheses, we include two (or more), separated by a comma. When it's done well, it's common for the resulting class to have no unique features of its own. It's a combination of mixins, and the body of the class definition is often nothing more than the <code class="Code-In-Text--PACKT-">pass</code> placeholder. </p>
    <p class="normal">We can test this new hybrid to see the mixin at work:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">e = EmailableContact(</span><span class="hljs-con-string">"John B"</span><span class="python">, </span><span class="hljs-con-string">"johnb@sloop.net"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Contact.all_contacts</span>
[EmailableContact('John B', 'johnb@sloop.net')]
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">e.send_mail(</span><span class="hljs-con-string">"Hello, test e-mail here"</span><span class="python">)</span>
Sending mail to self.email='johnb@sloop.net'
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Contact</code> initializer is still <a id="_idIndexMarker200"/>adding the new contact to the <code class="Code-In-Text--PACKT-">all_contacts</code> list, and the mixin is able to send mail to <code class="Code-In-Text--PACKT-">self.email</code>, so we know that everything is working.</p>
    <p class="normal">This wasn't so hard, and you're probably wondering what our dire warnings about multiple inheritance were for. We'll get into the complexities in a minute, but let's consider some other options we had for this example, rather than using a mixin:</p>
    <ul>
      <li class="bullet">We could have used single inheritance and added the <code class="Code-In-Text--PACKT-">send_mail</code> function to a subclass of <code class="Code-In-Text--PACKT-">Contact</code>. The disadvantage here is that the email functionality then has to be duplicated for any unrelated classes that need an email. For example, if we had email information in the payments part of our application, unrelated to these contacts, and we wanted a <code class="Code-In-Text--PACKT-">send_mail()</code> method, we'd have to duplicate the code.</li>
      <li class="bullet">We can create a standalone Python function for sending an email, and just call that function with the correct email address supplied as a parameter when the email needs to be sent (this is a very common choice). Because the function is not part of a class, it's harder to be sure that proper encapsulation is being used.</li>
      <li class="bullet">We could explore a few ways of using composition instead of inheritance. For example, <code class="Code-In-Text--PACKT-">EmailableContact</code> could have a <code class="Code-In-Text--PACKT-">MailSender</code> object as a property instead of inheriting from it. This leads to a more complex <code class="Code-In-Text--PACKT-">MailSender</code> class because it now has to stand alone. It also leads to a more complex <code class="Code-In-Text--PACKT-">EmailableContact</code> class because it has to associate a <code class="Code-In-Text--PACKT-">MailSender</code> instance with each <code class="Code-In-Text--PACKT-">Contact</code>.</li>
      <li class="bullet">We could try to monkey patch (we'll briefly cover monkey patching in <em class="chapterRef">Chapter 13</em>, <em class="italic">Testing Object-Oriented Programs</em>) the <code class="Code-In-Text--PACKT-">Contact</code> class to have a <code class="Code-In-Text--PACKT-">send_mail</code> method after the class has been created. This is done by defining a function that accepts the <code class="Code-In-Text--PACKT-">self</code> argument, and setting it as an attribute on an existing class. This is fine for creating a unit test fixture, but terrible for the application itself.</li>
    </ul>
    <p class="normal">Multiple inheritance <a id="_idIndexMarker201"/>works alright when we're mixing methods from different <a id="_idIndexMarker202"/>classes, but it can be messy when we have to call methods on the superclass. When there are multiple superclasses, how do we know which one's methods to call? What is the rule for selecting the appropriate superclass method?</p>
    <p class="normal">Let's explore these questions by adding a home address to our <code class="Code-In-Text--PACKT-">Friend</code> class. There are a few approaches we might take: </p>
    <ul>
      <li class="bullet">An address is a collection of strings representing the street, city, country, and other related details of the contact. We could pass each of these strings as a parameter into the <code class="Code-In-Text--PACKT-">Friend</code> class's <code class="Code-In-Text--PACKT-">__init__()</code> method. We could also store these strings in a generic tuple or dictionary. These options work well when the address information doesn't need new methods. </li>
      <li class="bullet">Another option would be to create our own <code class="Code-In-Text--PACKT-">Address</code> class to hold those strings together, and then pass an instance of this class into the <code class="Code-In-Text--PACKT-">__init__()</code> method in our <code class="Code-In-Text--PACKT-">Friend</code> class. The advantage of this solution is that we can add behavior (say, a method to give directions or to print a map) to the data instead of just storing it statically. This is an example of composition, as we discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Object-Oriented Design</em>. The "has-a" relationship of composition is a perfectly viable solution to this problem and allows us to reuse <code class="Code-In-Text--PACKT-">Address</code> classes in other entities, such as buildings, businesses, or organizations. (This is an opportunity to use a dataclass. We'll discuss dataclasses in <em class="chapterRef">Chapter 7</em>, <em class="italic">Python Data Structures</em>.)</li>
      <li class="bullet">A third course of action is a cooperative multiple inheritance design. While this can be made to work, it doesn't pass muster with <strong class="" style="font-style: italic;">mypy</strong>. The reason, we'll see, is some potential ambiguity that's difficult to describe with the available type hints.</li>
    </ul>
    <p class="normal">The objective here is to add a new class to hold an address. We'll call this new class <code class="Code-In-Text--PACKT-">AddressHolder</code> instead of <code class="Code-In-Text--PACKT-">Address</code> because inheritance defines an "is-a" relationship. It is not correct to say a <code class="Code-In-Text--PACKT-">Friend</code> class is an <code class="Code-In-Text--PACKT-">Address</code> class, but since a friend can have an <code class="Code-In-Text--PACKT-">Address</code> class, we can argue that a <code class="Code-In-Text--PACKT-">Friend</code> class is an <code class="Code-In-Text--PACKT-">AddressHolder</code> class. Later, we could create other entities (companies, buildings) that also hold addresses. (Convoluted naming and nuanced questions about "is-a" serve as decent indications we should be sticking with composition, rather than inheritance.)</p>
    <p class="normal">Here's a naïve <code class="Code-In-Text--PACKT-">AddressHolder</code> class. We're calling it naïve because it doesn't account for multiple inheritance well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AddressHolder</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, street: </span><span class="hljs-built_in">str</span><span class="hljs-params">, city: </span><span class="hljs-built_in">str</span><span class="hljs-params">, state: </span><span class="hljs-built_in">str</span><span class="hljs-params">, code: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.street = street
        self.city = city
        self.state = state
        self.code = code
</code></pre>
    <p class="normal">We take all the data and toss the argument values into instance variables upon initialization. We'll look at the consequences of this, and then show a better design.</p>
    <h2 id="_idParaDest-68" class="title">The diamond problem</h2>
    <p class="normal">We can use multiple <a id="_idIndexMarker203"/>inheritance to add this new class as a parent of our existing <code class="Code-In-Text--PACKT-">Friend</code> class. The tricky part is that we now have two parent <code class="Code-In-Text--PACKT-">__init__()</code> methods, both <a id="_idIndexMarker204"/>of which need to be called. And they need to be called with different arguments. How do we do this? Well, we could start with a naïve approach for the <code class="Code-In-Text--PACKT-">Friend</code> class, also:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Friend</span><span class="hljs-class">(</span><span class="hljs-params">Contact, AddressHolder</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">        self,</span>
<span class="hljs-params">        name: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">        email: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">        phone: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">        street: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">        city: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">        state: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">        code: </span><span class="hljs-built_in">str</span><span class="hljs-params">,</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        Contact.__init__(self, name, email)
        AddressHolder.__init__(self, street, city, state, code)
        self.phone = phone
</code></pre>
    <p class="normal">In this example, we directly call the <code class="Code-In-Text--PACKT-">__init__()</code> function on each of the superclasses and explicitly pass the <code class="Code-In-Text--PACKT-">self</code> argument. This example technically works; we can access the different variables directly on the class. But there are a few problems.</p>
    <p class="normal">First, it is possible for a superclass to remain uninitialized if we neglect to explicitly call the initializer. That wouldn't break this example, but it could cause hard-to-debug program crashes in common scenarios. We would get a lot of strange-looking <code class="Code-In-Text--PACKT-">AttributeError</code> exceptions in classes where there's clearly an <code class="Code-In-Text--PACKT-">__init__()</code> method. It's rarely obvious the <code class="Code-In-Text--PACKT-">__init__()</code> method wasn't actually used.</p>
    <p class="normal">A more insidious <a id="_idIndexMarker205"/>possibility is a superclass being called multiple times because of the<a id="_idIndexMarker206"/> organization of the class hierarchy. Look at this inheritance diagram:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.1: Inheritance diagram for our multiple inheritance implementation</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__init__()</code> method from the <code class="Code-In-Text--PACKT-">Friend</code> class first calls <code class="Code-In-Text--PACKT-">__init__()</code> on the <code class="Code-In-Text--PACKT-">Contact</code> class, which implicitly<a id="_idIndexMarker207"/> initializes the <code class="Code-In-Text--PACKT-">object</code> superclass (remember, all classes derive from <code class="Code-In-Text--PACKT-">object</code>). The <code class="Code-In-Text--PACKT-">Friend</code> class then calls <code class="Code-In-Text--PACKT-">__init__()</code> on <code class="Code-In-Text--PACKT-">AddressHolder</code>, which implicitly initializes the <code class="Code-In-Text--PACKT-">object</code> superclass <em class="italic">again</em>. This means the parent class has been set up twice. With the <code class="Code-In-Text--PACKT-">object</code> class, that's relatively harmless, but in some situations, it could spell disaster. Imagine trying to connect to a database twice for every request!</p>
    <p class="normal">The base class should only be called once. Once, yes, but when? Do we call <code class="Code-In-Text--PACKT-">Friend</code>, then <code class="Code-In-Text--PACKT-">Contact</code>, then <code class="Code-In-Text--PACKT-">Object</code>, and then <code class="Code-In-Text--PACKT-">AddressHolder</code>? Or <code class="Code-In-Text--PACKT-">Friend</code>, then <code class="Code-In-Text--PACKT-">Contact</code>, then <code class="Code-In-Text--PACKT-">AddressHolder</code>, and then <code class="Code-In-Text--PACKT-">Object</code>?</p>
    <p class="normal">Let's contrive an example <a id="_idIndexMarker208"/>to illustrate this problem more clearly. Here, we have a base class, <code class="Code-In-Text--PACKT-">BaseClass</code>, that has a method named <code class="Code-In-Text--PACKT-">call_me()</code>. Two subclasses, <code class="Code-In-Text--PACKT-">LeftSubclass</code> and <code class="Code-In-Text--PACKT-">RightSubclass</code>, extend the <code class="Code-In-Text--PACKT-">BaseClass</code> class, and each overrides the <code class="Code-In-Text--PACKT-">call_me()</code> method with different implementations. </p>
    <p class="normal">Then, <em class="italic">another</em> subclass extends both of these using multiple inheritance with a fourth, distinct implementation of the <code class="Code-In-Text--PACKT-">call_me()</code> method. This is called <strong class="keyword">diamond inheritance</strong> because of the diamond shape of the class diagram:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.2: Diamond inheritance</p>
    <p class="normal">Let's convert this <a id="_idIndexMarker209"/>diagram into code. This <a id="_idIndexMarker210"/>example shows when the methods are called:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BaseClass</span><span class="hljs-class">:</span>
    num_base_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        print(<span class="hljs-string">"Calling method on BaseClass"</span>)
        self.num_base_calls += <span class="hljs-number">1</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LeftSubclass</span><span class="hljs-class">(</span><span class="hljs-params">BaseClass</span><span class="hljs-class">):</span>
    num_left_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        BaseClass.call_me(self)
        print(<span class="hljs-string">"Calling method on LeftSubclass"</span>)
        self.num_left_calls += <span class="hljs-number">1</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">RightSubclass</span><span class="hljs-class">(</span><span class="hljs-params">BaseClass</span><span class="hljs-class">):</span>
    num_right_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        BaseClass.call_me(self)
        print(<span class="hljs-string">"Calling method on RightSubclass"</span>)
        self.num_right_calls += <span class="hljs-number">1</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Subclass</span><span class="hljs-class">(</span><span class="hljs-params">LeftSubclass, RightSubclass</span><span class="hljs-class">):</span>
    num_sub_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        LeftSubclass.call_me(self)
        RightSubclass.call_me(self)
        print(<span class="hljs-string">"Calling method on Subclass"</span>)
        self.num_sub_calls += <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">This example <a id="_idIndexMarker211"/>ensures that each overridden <code class="Code-In-Text--PACKT-">call_me()</code> method directly calls the parent <a id="_idIndexMarker212"/>method with the same name. It lets us know each time a method is called by printing the information to the screen. It also creates a distinct instance variable to show how many times it has been called.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The <code class="Code-In-Text--PACKT-">self.num_base_calls += 1</code> line requires a little sidebar explanation. </p>
      <p class="Tip--PACKT-">This is effectively <code class="Code-In-Text--PACKT-">self.num_base_calls = self.num_base_calls + 1</code>. When Python resolves <code class="Code-In-Text--PACKT-">self.num_base_calls</code> on the right side of the <code class="Code-In-Text--PACKT-">=</code>, it will first look for an instance variable, then look for the class variable; we've provided a class variable with a default value of zero. After the <code class="Code-In-Text--PACKT-">+1</code> computation, the assignment statement will create a new instance variable; it will not update the class-level variable. </p>
      <p class="Tip--PACKT-">Each time after the first call, the instance variable will be found. It's pretty cool for the class to provide default values for instance variables.</p>
    </div>
    <p class="normal">If we instantiate one <code class="Code-In-Text--PACKT-">Subclass</code> object and call the <code class="Code-In-Text--PACKT-">call_me()</code> method on it once, we get the following output:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s = Subclass()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.call_me()</span>
Calling method on BaseClass
Calling method on LeftSubclass
Calling method on BaseClass
Calling method on RightSubclass
Calling method on Subclass
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(</span>
<span class="hljs-con-meta">...</span> <span class="python">s.num_sub_calls,</span>
<span class="hljs-con-meta">...</span> <span class="python">s.num_left_calls,</span>
<span class="hljs-con-meta">...</span> <span class="python">s.num_right_calls,</span>
<span class="hljs-con-meta">...</span> <span class="python">s.num_base_calls)</span>
1 1 1 2
</code></pre>
    <p class="normal">Thus, we<a id="_idIndexMarker213"/> can see the base class's <code class="Code-In-Text--PACKT-">call_me()</code> method being called twice. This could lead to some pernicious bugs if that method is doing actual work, such as depositing into a bank account, twice. </p>
    <p class="normal">Python's <strong class="keyword">Method Resolution Order</strong> (<strong class="keyword">MRO</strong>) algorithm<a id="_idIndexMarker214"/> transforms the diamond into a flat, linear tuple. We can see the results of this in the <code class="Code-In-Text--PACKT-">__mro__</code> attribute of a class. The linear version of this diamond is the sequence <code class="Code-In-Text--PACKT-">Subclass</code>, <code class="Code-In-Text--PACKT-">LeftSubclass</code>, <code class="Code-In-Text--PACKT-">RightSubClass</code>, <code class="Code-In-Text--PACKT-">BaseClass</code>, <code class="Code-In-Text--PACKT-">object</code>. What's important here is that <code class="Code-In-Text--PACKT-">Subclass</code> lists <code class="Code-In-Text--PACKT-">LeftSubclass</code> before <code class="Code-In-Text--PACKT-">RightSubClass</code>, imposing an ordering on the classes in <a id="_idIndexMarker215"/>the diamond. </p>
    <p class="normal">The thing to keep in mind with multiple inheritance is that we often want to call the next method in the MRO sequence, not necessarily a method of the parent class. The <code class="Code-In-Text--PACKT-">super()</code> function locates the name in the MRO sequence. Indeed, <code class="Code-In-Text--PACKT-">super()</code> was originally developed to make complicated forms of multiple inheritance possible. </p>
    <p class="normal">Here is the same code written using <code class="Code-In-Text--PACKT-">super()</code>. We've renamed some of the classes, adding an <code class="Code-In-Text--PACKT-">_S</code> to make it clear this is the version using <code class="Code-In-Text--PACKT-">super()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BaseClass</span><span class="hljs-class">:</span>
    num_base_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        print(<span class="hljs-string">"Calling method on Base Class"</span>)
        self.num_base_calls += <span class="hljs-number">1</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LeftSubclass_S</span><span class="hljs-class">(</span><span class="hljs-params">BaseClass</span><span class="hljs-class">):</span>
    num_left_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="code-highlight"><strong class="hljs-slc">super().call_me()</strong></span>
        print(<span class="hljs-string">"Calling method on LeftSubclass_S"</span>)
        self.num_left_calls += <span class="hljs-number">1</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">RightSubclass_S</span><span class="hljs-class">(</span><span class="hljs-params">BaseClass</span><span class="hljs-class">):</span>
    num_right_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="code-highlight"><strong class="hljs-slc">super().call_me()</strong></span>
        print(<span class="hljs-string">"Calling method on RightSubclass_S"</span>)
        self.num_right_calls += <span class="hljs-number">1</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Subclass_S</span><span class="hljs-class">(</span><span class="hljs-params">LeftSubclass_S, RightSubclass_S</span><span class="hljs-class">):</span>
    num_sub_calls = <span class="hljs-number">0</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">call_me</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="code-highlight"><strong class="hljs-slc">super().call_me()</strong></span>
        print(<span class="hljs-string">"Calling method on Subclass_S"</span>)
        self.num_sub_calls += <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">The change is <a id="_idIndexMarker216"/>pretty minor; we only replaced the naive direct calls with calls to <code class="Code-In-Text--PACKT-">super()</code>. The <code class="Code-In-Text--PACKT-">Subclass_S</code> class, at the bottom of the diamond, only calls <code class="Code-In-Text--PACKT-">super()</code> once rather <a id="_idIndexMarker217"/>than having to make the calls for both the left and right. The change is easy enough, but look at the difference when we execute it:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">ss = Subclass_S()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">ss.call_me()</span>
Calling method on BaseClass
Calling method on RightSubclass_S
Calling method on LeftSubclass_S
Calling method on Subclass_S
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(</span>
<span class="hljs-con-meta">...</span> <span class="python">ss.num_sub_calls,</span>
<span class="hljs-con-meta">...</span> <span class="python">ss.num_left_calls,</span>
<span class="hljs-con-meta">...</span> <span class="python">ss.num_right_calls,</span>
<span class="hljs-con-meta">...</span> <span class="python">ss.num_base_calls)</span>
1 1 1 1
</code></pre>
    <p class="normal">This output looks good: our base method is only being called once. We can see how this works by looking at the <code class="Code-In-Text--PACKT-">__mro__</code> attribute of the class: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> pprint </span><span class="hljs-con-keyword">import</span><span class="python"> pprint</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pprint(Subclass_S.__mro__)</span>
(&lt;class 'commerce_naive.Subclass_S'&gt;,
 &lt;class 'commerce_naive.LeftSubclass_S'&gt;,
 &lt;class 'commerce_naive.RightSubclass_S'&gt;,
 &lt;class 'commerce_naive.BaseClass'&gt;,
 &lt;class 'object'&gt;)
</code></pre>
    <p class="normal">The order of the classes shows what order <code class="Code-In-Text--PACKT-">super()</code> will use. The last class in the tuple is generally the built-in <code class="Code-In-Text--PACKT-">object</code> class. As noted earlier in this chapter, it's the implicit superclass of all classes.</p>
    <p class="normal">This shows <a id="_idIndexMarker218"/>what <code class="Code-In-Text--PACKT-">super()</code> is actually doing. Since the <code class="Code-In-Text--PACKT-">print</code> statements<a id="_idIndexMarker219"/> are executed after the <code class="Code-In-Text--PACKT-">super</code> calls, the printed output is in the order each method is actually executed. Let's look at the output from back to front to see who is calling what:</p>
    <ol>
      <li class="numbered">We start with the <code class="Code-In-Text--PACKT-">Subclass_S.call_me()</code> method. This evaluates <code class="Code-In-Text--PACKT-">super().call_me()</code>. The MRO shows <code class="Code-In-Text--PACKT-">LeftSubclass_S</code> as next.</li>
      <li class="numbered">We begin evaluation of the <code class="Code-In-Text--PACKT-">LeftSubclass_S.call_me()</code> method. This evaluates <code class="Code-In-Text--PACKT-">super().call_me()</code>. The MRO puts <code class="Code-In-Text--PACKT-">RightSubclass_S</code> as next. This is not a superclass; it's adjacent in the class diamond.</li>
      <li class="numbered">The evaluation of the <code class="Code-In-Text--PACKT-">RightSubclass_S.call_me()</code> method, <code class="Code-In-Text--PACKT-">super().call_me()</code>. This leads to <code class="Code-In-Text--PACKT-">BaseClass</code>.</li>
      <li class="numbered">The<code class="Code-In-Text--PACKT-"> BaseClass.call_me()</code> method finishes its processing: printing a message and setting an instance variable, <code class="Code-In-Text--PACKT-">self.num_base_calls</code>, to <code class="Code-In-Text--PACKT-">BaseClass.num_base_calls + 1</code>.</li>
      <li class="numbered">Then, the <code class="Code-In-Text--PACKT-">RightSubclass_S.call_me()</code> method can finish, printing a message and setting an instance variable, <code class="Code-In-Text--PACKT-">self.num_right_calls</code>.</li>
      <li class="numbered">Then, the <code class="Code-In-Text--PACKT-">LeftSubclass_S.call_me()</code> method will finish by printing a message and setting an instance variable, <code class="Code-In-Text--PACKT-">self.num_left_calls</code>.</li>
      <li class="numbered">This serves to set the stage for <code class="Code-In-Text--PACKT-">Subclass_S</code> to finish its <code class="Code-In-Text--PACKT-">call_me()</code> method processing. It writes a message, sets an instance variable, and rests, happy and successful.</li>
    </ol>
    <p class="normal"><strong class="keyword">Pay particular attention to this</strong>: The <code class="Code-In-Text--PACKT-">super</code> call is <em class="italic">not</em> calling the method on the superclass of <code class="Code-In-Text--PACKT-">LeftSubclass_S</code> (which is <code class="Code-In-Text--PACKT-">BaseClass</code>). Rather, it is calling <code class="Code-In-Text--PACKT-">RightSubclass_S</code>, even though it is not a direct parent of <code class="Code-In-Text--PACKT-">LeftSubclass_S</code>! This is the <em class="italic">next</em> class in the MRO, not the parent method. <code class="Code-In-Text--PACKT-">RightSubclass_S</code> then calls <code class="Code-In-Text--PACKT-">BaseClass</code> and the <code class="Code-In-Text--PACKT-">super()</code> calls have ensured each method in the class hierarchy is executed once.</p>
    <h2 id="_idParaDest-69" class="title">Different sets of arguments</h2>
    <p class="normal">This is going to<a id="_idIndexMarker220"/> make things complicated as we return to our <code class="Code-In-Text--PACKT-">Friend</code> cooperative multiple inheritance example. In the <code class="Code-In-Text--PACKT-">__init__()</code> method for the <code class="Code-In-Text--PACKT-">Friend</code> class, we were originally delegating initialization to the <code class="Code-In-Text--PACKT-">__init__()</code> methods of both parent classes, <em class="italic">with different sets of arguments</em>:</p>
    <pre class="programlisting code"><code class="hljs-code">Contact.__init__(self, name, email)
AddressHolder.__init__(self, street, city, state, code)
</code></pre>
    <p class="normal">How can we manage different sets of arguments when using <code class="Code-In-Text--PACKT-">super()</code>? We only really have access to the next class in the MRO sequence. Because of this, we need a way to pass the <strong class="" style="font-style: italic;">extra</strong> arguments through the constructors so that subsequent calls to super(), from other mixin classes, receive the right arguments.</p>
    <p class="normal">It works like this. The first call to <code class="Code-In-Text--PACKT-">super()</code> provides arguments to the first class of the MRO, passing the <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">email</code> arguments to <code class="Code-In-Text--PACKT-">Contact.__init__()</code>. Then, when <code class="Code-In-Text--PACKT-">Contact.__init__()</code> calls <code class="Code-In-Text--PACKT-">super()</code>, it needs to be able to pass the address-related arguments to the method of the next class in the MRO, which is <code class="Code-In-Text--PACKT-">AddressHolder.__init__()</code>.</p>
    <p class="normal">This problem often manifests itself anytime we want to call superclass methods with the same name, but with different sets of arguments. Collisions often arise around the special method names. Of these, the most common example is having a different set of arguments to various <code class="Code-In-Text--PACKT-">__init__()</code> methods, as we're doing here. </p>
    <p class="normal">There's no magical Python feature to handle cooperation among classes with divergent <code class="Code-In-Text--PACKT-">__init__()</code> parameters. Consequently, this requires some care to design our class parameter lists. The cooperative multiple inheritance approach is to accept keyword arguments for any parameters that are not required by every subclass implementation. A method must pass the unexpected arguments on to its <code class="Code-In-Text--PACKT-">super()</code> call, in case they are necessary to later methods in the MRO sequence of classes.</p>
    <p class="normal">While this works and works well, it's difficult to describe with type hints. Instead, we have to silence <strong class="" style="font-style: italic;">mypy</strong> in a few key places.</p>
    <p class="normal">Python's function parameter syntax provides a tool we can use to do this, but it makes the overall code<a id="_idIndexMarker221"/> look cumbersome. Have a look at a version of the <code class="Code-In-Text--PACKT-">Friend</code> multiple inheritance code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Contact</span><span class="hljs-class">:</span>
    all_contacts = ContactList()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, /, name: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">""</span><span class="hljs-params">, email: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">""</span><span class="hljs-params">, **kwargs: Any</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(**kwargs)  <span class="hljs-comment"># type: ignore [call-arg]</span>
        self.name = name
        self.email = email
        self.all_contacts.append(self)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">f"</span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-string">("</span> <span class="hljs-string">f"</span><span class="hljs-subst">{self.name!r}</span><span class="hljs-string">, </span><span class="hljs-subst">{self.email!r}</span><span class="hljs-string">"</span> <span class="hljs-string">f")"</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AddressHolder</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">        self,</span>
<span class="hljs-params">        /,</span>
<span class="hljs-params">        street: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">""</span><span class="hljs-params">,</span>
<span class="hljs-params">        city: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">""</span><span class="hljs-params">,</span>
<span class="hljs-params">        state: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">""</span><span class="hljs-params">,</span>
<span class="hljs-params">        code: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">""</span><span class="hljs-params">,</span>
<span class="hljs-params">        **kwargs: Any,</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(**kwargs)  <span class="hljs-comment"># type: ignore [call-arg]</span>
        self.street = street
        self.city = city
        self.state = state
        self.code = code
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Friend</span><span class="hljs-class">(</span><span class="hljs-params">Contact, AddressHolder</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, /, phone: </span><span class="hljs-built_in">str</span><span class="hljs-params"> = </span><span class="hljs-string">""</span><span class="hljs-params">, **kwargs: Any</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-built_in">super</span>().__init__(**kwargs)
        self.phone = phone
</code></pre>
    <p class="normal">We've added the <code class="Code-In-Text--PACKT-">**kwargs</code> parameter, which collects all additional keyword argument values into a dictionary. When called with <code class="Code-In-Text--PACKT-">Contact(name="this", email="that", street="something")</code>, the <code class="Code-In-Text--PACKT-">street</code> argument is put into the <code class="Code-In-Text--PACKT-">kwargs</code> dictionary; these extra parameters are passed up to the next class with the <code class="Code-In-Text--PACKT-">super()</code> call. The special parameter <code class="Code-In-Text--PACKT-">/</code> separates parameters that could be provided by position in the call from parameters that require a keyword to associate them with an argument value. We've given all string <a id="_idIndexMarker222"/>parameters an empty string as a default value, also. </p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If you aren't familiar with the <code class="Code-In-Text--PACKT-">**kwargs</code> syntax, it basically collects any keyword arguments passed into the method that were not explicitly listed in the parameter list. These arguments are stored in a dictionary named <code class="Code-In-Text--PACKT-">kwargs</code> (we can call the variable whatever we like, but convention suggests <code class="Code-In-Text--PACKT-">kw</code> or <code class="Code-In-Text--PACKT-">kwargs</code>). When we call a method, for example, <code class="Code-In-Text--PACKT-">super().__init__()</code>, with <code class="Code-In-Text--PACKT-">**kwargs</code> as an argument value, it unpacks the dictionary and passes the results to the method as keyword arguments. We'll look at this in more depth in <em class="chapterRef">Chapter 8</em>, <em class="italic">The Intersection of Object-Oriented and Functional Programming</em>.</p>
    </div>
    <p class="normal">We've introduced two comments that are addressed to <strong class="" style="font-style: italic;">mypy</strong> (and any person scrutinizing the code). The <code class="Code-In-Text--PACKT-"># type: ignore</code> comments provide a specific error code, <code class="Code-In-Text--PACKT-">call-arg</code>, on a specific line to be ignored. In this case, we need to ignore the <code class="Code-In-Text--PACKT-">super().__init__(**kwargs)</code> calls because it isn't obvious to <strong class="" style="font-style: italic;">mypy</strong> what the MRO really will be at runtime. As someone reading the code, we can look at the <code class="Code-In-Text--PACKT-">Friend</code> class and see the order: <code class="Code-In-Text--PACKT-">Contact</code> and <code class="Code-In-Text--PACKT-">AddressHolder</code>. This order means that inside the <code class="Code-In-Text--PACKT-">Contact</code> class, the <code class="Code-In-Text--PACKT-">super()</code> function will locate the next class, <code class="Code-In-Text--PACKT-">AddressHolder</code>. </p>
    <p class="normal">The <strong class="" style="font-style: italic;">mypy</strong> tool, however, doesn't look this deeply; it goes by the explicit list of parent classes in the <code class="Code-In-Text--PACKT-">class</code> statement. Since there's no parent class named, <strong class="" style="font-style: italic;">mypy</strong> is convinced the <code class="Code-In-Text--PACKT-">object</code> class will be located by <code class="Code-In-Text--PACKT-">super()</code>. Since <code class="Code-In-Text--PACKT-">object.__init__()</code> cannot take any arguments, the <code class="Code-In-Text--PACKT-">super().__init__(**kwargs)</code> in both <code class="Code-In-Text--PACKT-">Contact</code> and <code class="Code-In-Text--PACKT-">AddressHolder</code> appears incorrect to <strong class="" style="font-style: italic;">mypy</strong>. Practically, the chain of classes in the MRO will consume all of the various parameters and there will be nothing left over for the <code class="Code-In-Text--PACKT-">AddressHolder</code> class's <code class="Code-In-Text--PACKT-">__init__()</code> method.</p>
    <p class="normal">For more information on type<a id="_idIndexMarker223"/> hint annotations for cooperative multiple inheritance, see <a href="https://github.com/python/mypy/issues/8769"><span class="url">https://github.com/python/mypy/issues/8769</span></a>. The longevity of this issue suggests how hard the solution can be.</p>
    <p class="normal">The previous example does what it is supposed to do. But it's supremely difficult to answer the question: <em class="italic">What arguments do we need to pass into</em> <code class="Code-In-Text--PACKT-">Friend.__init__()</code>? This is the foremost question for anyone planning to use the class, so a docstring should be added to the method to explain the entire list of parameters from all the parent classes.</p>
    <p class="normal">The error message in the event of a misspelled or extraneous parameter can be confusing, also. The message <code class="Code-In-Text--PACKT-">TypeError: object.__init__() takes exactly one argument (the instance to initialize)</code> isn't too informative on how an extra parameter came to be provided to <code class="Code-In-Text--PACKT-">object.__init__()</code>.</p>
    <p class="normal">We have covered many of the caveats involved with cooperative multiple inheritance in Python. When we need to account for all possible situations, we have to plan for them, and our code can get messy.</p>
    <p class="normal">Multiple inheritance <a id="_idIndexMarker224"/>following the mixin pattern often works out very nicely. The idea is to have additional methods defined in mixin classes, but to keep all of the attributes centralized in a host class hierarchy. This can avoid the complexity of cooperative initialization.</p>
    <p class="normal">Design using composition also often works better than complex multiple inheritance. Many of the design patterns we'll be covering in <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns,</em> and <em class="chapterRef">Chapter 12</em>, <em class="italic">Advanced Design Patterns</em>, are examples of composition-based design.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The inheritance paradigm depends on a clear "is-a" relationship between classes. Multiple inheritance folds in other relationships that aren't as clear. We can say that an "Email is a kind of Contact," for example. But it doesn't seem as clear that we can say "A Customer is an Email." We might say "A Customer has an Email address" or "A Customer is contacted via Email," using "has an" or "is contacted by" instead of a direct "is-a" relationship.</p>
    </div>
    <h1 id="_idParaDest-70" class="title">Polymorphism</h1>
    <p class="normal">We were introduced to polymorphism<a id="_idIndexMarker225"/> in <em class="chapterRef">Chapter 1</em>, <em class="italic">Object-Oriented Design</em>. It is a showy name describing a simple concept: different behaviors happen depending on which subclass is being used, without having to explicitly know what the subclass actually is. It is also sometimes called the Liskov Substitution Principle, honoring Barbara Liskov's contributions to object-oriented programming. We should be able to substitute any subclass for its superclass.</p>
    <p class="normal">As an example, imagine a program that plays audio files. A media player might need to load an <code class="Code-In-Text--PACKT-">AudioFile</code> object and then play it. We can put a <code class="Code-In-Text--PACKT-">play()</code> method on the object, which is responsible for decompressing or extracting the audio and routing it to the sound card and speakers. The act of playing an <code class="Code-In-Text--PACKT-">AudioFile</code> could feasibly be as simple as:</p>
    <pre class="programlisting code"><code class="hljs-code">audio_file.play() 
</code></pre>
    <p class="normal">However, the process of decompressing and extracting an audio file is very different for different types of files. While <code class="Code-In-Text--PACKT-">.wav</code> files are stored uncompressed, <code class="Code-In-Text--PACKT-">.mp3</code>, <code class="Code-In-Text--PACKT-">.wma</code>, and <code class="Code-In-Text--PACKT-">.ogg</code> files all utilize totally different compression algorithms.</p>
    <p class="normal">We can use inheritance with polymorphism to simplify the design. Each type of file can be represented by a different subclass of <code class="Code-In-Text--PACKT-">AudioFile</code>, for example, <code class="Code-In-Text--PACKT-">WavFile</code> and <code class="Code-In-Text--PACKT-">MP3File</code>. Each of these would have a <code class="Code-In-Text--PACKT-">play()</code> method that would be implemented differently for each file to ensure that the correct extraction procedure is followed. The media player object would never need to know which subclass of <code class="Code-In-Text--PACKT-">AudioFile</code> it is referring to; it just calls <code class="Code-In-Text--PACKT-">play()</code> and polymorphically lets the object take care of the actual details of playing. Let's look at a quick<a id="_idIndexMarker226"/> skeleton showing how this might work:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">AudioFile</span><span class="hljs-class">:</span>
    ext: <span class="hljs-built_in">str</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, filepath: Path</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> filepath.suffix == self.ext:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"Invalid file format"</span>)
        self.filepath = filepath
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MP3File</span><span class="hljs-class">(</span><span class="hljs-params">AudioFile</span><span class="hljs-class">):</span>
    ext = <span class="hljs-string">".mp3"</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">play</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        print(<span class="hljs-string">f"playing </span><span class="hljs-subst">{self.filepath}</span><span class="hljs-string"> as mp3"</span>)
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">WavFile</span><span class="hljs-class">(</span><span class="hljs-params">AudioFile</span><span class="hljs-class">):</span>
    ext = <span class="hljs-string">".wav"</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">play</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        print(<span class="hljs-string">f"playing </span><span class="hljs-subst">{self.filepath}</span><span class="hljs-string"> as wav"</span>)
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">OggFile</span><span class="hljs-class">(</span><span class="hljs-params">AudioFile</span><span class="hljs-class">):</span>
    ext = <span class="hljs-string">".ogg"</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">play</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        print(<span class="hljs-string">f"playing </span><span class="hljs-subst">{self.filepath}</span><span class="hljs-string"> as ogg"</span>)
</code></pre>
    <p class="normal">All audio files check to ensure that a valid extension was given upon initialization. If the filename doesn't end with the correct name, it raises an exception (exceptions will be covered in detail in <em class="chapterRef">Chapter 4</em>, <em class="italic">Expecting the Unexpected</em>). </p>
    <p class="normal">But did you notice how the <code class="Code-In-Text--PACKT-">__init__()</code> method in the parent class is able to access the <code class="Code-In-Text--PACKT-">ext</code> class variable from different subclasses? That's polymorphism at work. The <code class="Code-In-Text--PACKT-">AudioFile</code> parent class merely has a type hint explaining to <strong class="" style="font-style: italic;">mypy</strong> that there will be an attribute named <code class="Code-In-Text--PACKT-">ext</code>. It doesn't actually store a reference to the <code class="Code-In-Text--PACKT-">ext</code> attribute. When the inherited method is used by a subclass, then the subclass' definition of the <code class="Code-In-Text--PACKT-">ext</code> attribute is used. The type hint can help <strong class="" style="font-style: italic;">mypy</strong> spot a class missing the attribute assignment.</p>
    <p class="normal">In addition, each subclass of <code class="Code-In-Text--PACKT-">AudioFile</code> implements <code class="Code-In-Text--PACKT-">play()</code> in a different way (this example doesn't actually play the music; audio compression algorithms really deserve a separate book!). This is also polymorphism in action. The media player can use the exact same code to play a file, no matter what type it is; it doesn't care what subclass of <code class="Code-In-Text--PACKT-">AudioFile</code> it is looking at. The details of decompressing the audio file are <em class="italic">encapsulated</em>. If we test this example, it works as we would hope:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">p_1 = MP3File(Path(</span><span class="hljs-con-string">"Heart of the Sunrise.mp3"</span><span class="python">))</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">p_1.play()</span>
playing Heart of the Sunrise.mp3 as mp3
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">p_2 = WavFile(Path(</span><span class="hljs-con-string">"Roundabout.wav"</span><span class="python">))</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">p_2.play()</span>
playing Roundabout.wav as wav
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">p_3 = OggFile(Path(</span><span class="hljs-con-string">"Heart of the Sunrise.ogg"</span><span class="python">))</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">p_3.play()</span>
playing Heart of the Sunrise.ogg as ogg
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">p_4 = MP3File(Path(</span><span class="hljs-con-string">"The Fish.mov"</span><span class="python">))</span>
Traceback (most recent call last):
<span class="hljs-con-meta">...</span>
ValueError: Invalid file format
</code></pre>
    <p class="normal">See how <code class="Code-In-Text--PACKT-">AudioFile.__init__()</code> can check the file type without actually knowing which subclass it is referring to?</p>
    <p class="normal">Polymorphism is actually one of the coolest things about object-oriented programming, and it makes some programming designs obvious that weren't possible in earlier paradigms. However, Python makes <a id="_idIndexMarker227"/>polymorphism seem less awesome because of duck typing. Duck typing in Python allows us to use <em class="italic">any</em> object that provides the required behavior without forcing it to be a subclass. The dynamic nature of Python makes this trivial. The following example does not extend <code class="Code-In-Text--PACKT-">AudioFile</code>, but it can be interacted with in Python using the exact same interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">FlacFile</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, filepath: Path</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> filepath.suffix == <span class="hljs-string">".flac"</span>:
            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"Not a .flac file"</span>)
        self.filepath = filepath
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">play</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        print(<span class="hljs-string">f"playing </span><span class="hljs-subst">{self.filepath}</span><span class="hljs-string"> as flac"</span>)
</code></pre>
    <p class="normal">Our media player can play objects of the <code class="Code-In-Text--PACKT-">FlacFile</code> class just as easily as objects of classes that extend <code class="Code-In-Text--PACKT-">AudioFile</code>.</p>
    <p class="normal">Polymorphism <a id="_idIndexMarker228"/>is one of the most important reasons to use inheritance in many object-oriented contexts. Because any objects that supply the correct interface can be used interchangeably in Python, it reduces the need for polymorphic common superclasses. Inheritance can still be useful for sharing code, but if all that is being shared is the public interface, duck typing is all that is required. </p>
    <p class="normal">This reduced need for inheritance also reduces the need for multiple inheritance; often, when multiple inheritance appears to be a valid solution, we can just use duck typing to mimic one of the multiple superclasses.</p>
    <p class="normal">In some cases, we can formalize this kind of duck typing using a <code class="Code-In-Text--PACKT-">typing.Protocol</code> hint. To make <strong class="" style="font-style: italic;">mypy</strong> aware of the expectations, we'll often define a number of functions or attributes (or a mixture) as a formal <code class="Code-In-Text--PACKT-">Protocol</code> type. This can help clarify how classes are related. We might, for example, have this kind of definition to define the common features between the <code class="Code-In-Text--PACKT-">FlacFile</code> class and the <code class="Code-In-Text--PACKT-">AudioFile</code> class hierarchy:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Playable</span><span class="hljs-class">(</span><span class="hljs-params">Protocol</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">play</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        ...
</code></pre>
    <p class="normal">Of course, just because an object satisfies a particular protocol (by providing required methods or attributes) does not mean it will simply work in all situations. It has to fulfill that interface in a way that makes sense in the overall system. Just because an object provides a <code class="Code-In-Text--PACKT-">play()</code> method does not mean it will automatically work with a media player. The methods must also have the same meaning, or semantics, in addition to having the same syntax.</p>
    <p class="normal">Another useful feature of duck typing<a id="_idIndexMarker229"/> is that the duck-typed object only needs to provide those methods and attributes that are actually being accessed. For example, if we needed to create a fake file object to read data from, we can create a new object that has a <code class="Code-In-Text--PACKT-">read()</code> method; we don't have to override the <code class="Code-In-Text--PACKT-">write()</code> method if the code that is going to interact with the fake object will not be calling it. More succinctly, duck typing doesn't need to provide the entire interface of an object that is available; it only needs to fulfill the protocol that is actually used. </p>
    <h1 id="_idParaDest-71" class="title">Case study</h1>
    <p class="normal">This section expands on the object-oriented design of our example, iris classification. We've been building on this in the previous chapters, and we'll continue building on it in later chapters. In this chapter, we'll review the diagrams created using the <strong class="keyword">Unified Modeling Language</strong> (<strong class="keyword">UML</strong>) to help depict and summarize the software we're going to build. We'll move on from the previous chapter to add features for the various ways of computing "nearest" for the <em class="italic">k</em>-nearest neighbors algorithm. There are a number of variations for this, and it demonstrates how class hierarchies work.</p>
    <p class="normal">There are several design principles that we'll be exploring as this design becomes more and more complete. One popular set of principles is the <strong class="keyword">SOLID</strong> principles, which are:</p>
    <ul>
      <li class="bullet"><strong class="keyword">S</strong>. Single Responsibility Principle. A <a id="_idIndexMarker230"/>class should have one responsibility. This can<a id="_idIndexMarker231"/> mean one reason to change when the application's requirements change.</li>
      <li class="bullet"><strong class="keyword">O</strong>. Open/Closed. A class <a id="_idIndexMarker232"/>should be open to extension but closed to modification.</li>
      <li class="bullet"><strong class="keyword">L</strong>. Liskov Substitution. (Named after Barbara Liskov, who created one of the first object-oriented <a id="_idIndexMarker233"/>programming languages, CLU.) Any subclass can be substituted for its superclass. This tends to focus a class hierarchy on classes that have very similar interfaces, leading to <em class="italic">polymorphism</em> among the objects. This the essence of inheritance.</li>
      <li class="bullet"><strong class="keyword">I</strong>. Interface Segregation. A class should have the smallest interface possible. This is, perhaps, the most <a id="_idIndexMarker234"/>important of these principles. Classes should be relatively small and isolated.</li>
      <li class="bullet"><strong class="keyword">D</strong>. Dependency Inversion. This has a peculiar name. We need to know what a bad dependency<a id="_idIndexMarker235"/> relationship is so we know how to invert it to have a good relationship. Pragmatically, we'd like classes to be independent, so a Liskov Substitution doesn't involve a lot of code changes. In Python, this often means referring to superclasses in type hints to be sure we have the flexibility to make changes. In some cases, it also means providing parameters so that we can make global class changes without revising any of the code.</li>
    </ul>
    <p class="normal">We won't look at all of these principles in this chapter. Because we're looking at inheritance, our design will tend to follow the Liskov Substitution design principle. Other chapters will touch on other design principles.</p>
    <h2 id="_idParaDest-72" class="title">Logical view</h2>
    <p class="normal">Here's the <a id="_idIndexMarker236"/>overview of some of the classes shown in the previous chapter's case study. An important omission from those definitions was the <code class="Code-In-Text--PACKT-">classify</code> algorithm of the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.3: Class overview</p>
    <p class="normal">In the previous chapter, we avoided delving into the classification algorithm. This reflects a common design strategy, sometimes called "<em class="italic">Hard Part, Do Later</em>," also called "<em class="italic">Do The Easy Part First</em>." This strategy encourages following common design patterns where possible to isolate the hard part. In effect, the easy parts define a number of fences that enclose and constrain the novel and unknown parts.</p>
    <p class="normal">The classification we're doing is based on the <em class="italic">k</em>-nearest neighbors algorithm, <em class="italic">k</em>-NN. Given a set of known samples, and an unknown sample, we want to find neighbors near the unknown sample; the majority of the neighbors tells us how to classify the newcomer. This means <em class="italic">k</em> is usually an odd number, so the majority is easy to compute. We've been avoiding the question, "What do we mean by nearest?"</p>
    <p class="normal">In a<a id="_idIndexMarker237"/> conventional, two-dimensional geometric sense, we can use the "Euclidean" distance between samples. Given an Unknown sample located at <img src="../Images/B17070_03_001.png" alt="" style="height: 1em;"/> and a Training sample at <img src="../Images/B17070_03_002.png" alt="" style="height: 1em;"/>, the Euclidean distance between these samples, <img src="../Images/B17070_03_003.png" alt="" style="height: 1em;"/>, is:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_004.png" alt="" style="height: 3em;"/></figure>
    <p class="normal">We can visualize it like this:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_04.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.4: Euclidean distance</p>
    <p class="normal">We've called<a id="_idIndexMarker238"/> this ED2 because it's only two-dimensional. In our case study data, we actually have four dimensions: sepal length, sepal width, petal length, and petal width. This is really difficult to visualize, but the math isn't too complex. Even when it's hard to imagine, we can still write it out fully, like so:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_005.png" alt="" style="height: 3em;"/></figure>
    <p class="normal">All of the<a id="_idIndexMarker239"/> two-dimensional examples expand to four dimensions, in spite of how hard it is to imagine. We'll stick with the easier to visualize <em class="italic">x-y</em> distance for the diagrams in this section. But we really mean the full four-dimensional computation that includes all of the available measurements.</p>
    <p class="normal">We can capture this computation as a class definition. An instance of this <code class="Code-In-Text--PACKT-">ED</code> class is usable by the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ED</span><span class="hljs-class">(</span><span class="hljs-params">Distance</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">distance</span><span class="hljs-function">(</span><span class="hljs-params">self, s1: Sample, s2: Sample</span><span class="hljs-function">) -&gt; float:</span>
        <span class="hljs-keyword">return</span> hypot(
            s1.sepal_length - s2.sepal_length,
            s1.sepal_width - s2.sepal_width,
            s1.petal_length - s2.petal_length,
            s1.petal_width - s2.petal_width,
        )
</code></pre>
    <p class="normal">We've leveraged the <code class="Code-In-Text--PACKT-">math.hypot()</code> function to do the square and square root parts of the distance computation. We've used a superclass, <code class="Code-In-Text--PACKT-">Distance</code>, that we haven't defined yet. We're pretty sure it's going to be needed, but we'll hold off a bit on defining it.</p>
    <p class="normal">The Euclidean distance is one of many alternative definitions of distance between a known and unknown sample. There are two relatively simple ways to compute a distance that are similar, and they often produce consistently good results without the complexity of a square root:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Manhattan distance</strong>: This is<a id="_idIndexMarker240"/> the distance you would walk in a city with square blocks (somewhat like parts of the city of Manhattan.)</li>
      <li class="bullet"><strong class="keyword">Chebyshev distance</strong>: This <a id="_idIndexMarker241"/>counts a diagonal step as 1. A Manhattan computation would rank this as 2. The Euclidean distance would be <img src="../Images/B17070_03_006.png" alt="" style="height: 1em;"/>, as depicted in <em class="italic">Figure 3.4</em>.</li>
    </ul>
    <p class="normal">With a number of alternatives, we're going to need to create distinct subclasses. That means we'll need a base class to define the general idea of distances. Looking over the definitions at hand, it seems like the base class can be the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Distance</span><span class="hljs-class">:</span>
    <span class="hljs-string">"""Definition of a distance computation"""</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">distance</span><span class="hljs-function">(</span><span class="hljs-params">self, s1: Sample, s2: Sample</span><span class="hljs-function">) -&gt; float:</span>
        <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">This seems to capture the essence of the distance computations we've seen. Let's implement a few more subclasses of this to be sure the abstraction really works.</p>
    <p class="normal">The Manhattan distance<a id="_idIndexMarker242"/> is the total number of steps along the <em class="italic">x</em>-axis, plus the total number of steps along the <em class="italic">y</em>-axis. The formula uses the absolute values of the distances, written as <img src="../Images/B17070_03_007.png" alt="" style="height: 1em;"/>, and looks like this:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_008.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">This can be as <a id="_idIndexMarker243"/>much as 41% larger than the direct Euclidean distance. However, it will still parallel the direct distance in a way that can yield a good <em class="italic">k</em>-NN result, but with a faster computation because it avoids squaring numbers and computing a square root.</p>
    <p class="normal">Here's a view of the Manhattan distance:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_05.png" alt="A picture containing chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.5: Manhattan distance</p>
    <p class="normal">Here's a <a id="_idIndexMarker244"/>subclass <a id="_idIndexMarker245"/>of <code class="Code-In-Text--PACKT-">Distance</code> that computes this variation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MD</span><span class="hljs-class">(</span><span class="hljs-params">Distance</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">distance</span><span class="hljs-function">(</span><span class="hljs-params">self, s1: Sample, s2: Sample</span><span class="hljs-function">) -&gt; float:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(
            [
                <span class="hljs-built_in">abs</span>(s1.sepal_length - s2.sepal_length),
                <span class="hljs-built_in">abs</span>(s1.sepal_width - s2.sepal_width),
                <span class="hljs-built_in">abs</span>(s1.petal_length - s2.petal_length),
                <span class="hljs-built_in">abs</span>(s1.petal_width - s2.petal_width),
            ]
        )
</code></pre>
    <p class="normal">The Chebyshev distance<a id="_idIndexMarker246"/> is the largest of the absolute <em class="italic">x</em> or <em class="italic">y</em> distances. This tends to minimize the effects of multiple dimensions:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_009.png" alt="" style="height: 2em;"/></figure>
    <p class="normal">Here's a view of the<a id="_idIndexMarker247"/> Chebyshev distance; it tends to emphasize neighbors that are closer to each other:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_06.png" alt="Chart  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.6: Chebyshev distance</p>
    <p class="normal">Here's a subclass of <code class="Code-In-Text--PACKT-">Distance</code> that performs this variant on the distance computation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CD</span><span class="hljs-class">(</span><span class="hljs-params">Distance()</span><span class="hljs-class">)</span>
<span class="hljs-class">    </span><span class="hljs-title">def</span><span class="hljs-class"> </span><span class="hljs-title">distance</span><span class="hljs-class">(</span><span class="hljs-params">self, s1: Sample, s2: Sample</span><span class="hljs-class">) -&gt; float:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(
            [
                <span class="hljs-built_in">abs</span>(s1.sepal_length - s2.sepal_length),
                <span class="hljs-built_in">abs</span>(s1.sepal_width - s2.sepal_width),
                <span class="hljs-built_in">abs</span>(s1.petal_length - s2.petal_length),
                <span class="hljs-built_in">abs</span>(s1.petal_width - s2.petal_width),
            ]
        )
</code></pre>
    <p class="normal">See <em class="italic">Effects of Distance Measure Choice on KNN Classifier Performance - A Review</em> (<a href="https://arxiv.org/pdf/1708.04321.pdf"><span class="url">https://arxiv.org/pdf/1708.04321.pdf</span></a>). This paper contains 54 distinct metrics computations. The<a id="_idIndexMarker248"/> examples we're looking at are collectively identified as "Minkowski" measures because they're similar and measure each axis equally. Each alternative distance strategy yields different results in the model's ability to classify unknown samples given a set of training data. </p>
    <p class="normal">This changes the idea behind the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class: we now have two distinct hyperparameters. The value of <em class="italic">k</em>, to decide how many neighbors to examine, and the distance computation, which tells us how to compute "nearest." These are both changeable parts of the algorithm, and we'll need to test various combinations to see which works best for our data.</p>
    <p class="normal">How can we have all of these different distance computations available? The short answer is we'll need a lot of subclass definitions of a common distance class. The review paper cited above lets us pare down the domain to a few of the more useful distance computations. To be sure we've got a good design, let's look at one more distance.</p>
    <h2 id="_idParaDest-73" class="title">Another distance </h2>
    <p class="normal">Just to make <a id="_idIndexMarker249"/>it clear how easy it is to add subclasses, we'll define a somewhat more complex distance metric. This is the Sorensen distance<a id="_idIndexMarker250"/>, also known as <a id="_idIndexMarker251"/>Bray-Curtis. If our distance class can handle these kinds of more complex formulas, we can be confident it's capable of handling others:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_010.png" alt="" style="height: 3.5em;"/></figure>
    <p class="normal">We've effectively standardized each component of the Manhattan distance by dividing by the possible range of values.</p>
    <p class="normal">Here's a diagram to <a id="_idIndexMarker252"/>illustrate how the Sorensen distance works:</p>
    <figure class="mediaobject"><img src="../Images/B17070_03_07.png" alt="Chart  Description automatically generated with medium confidence"/></figure>
    <p class="packt_figref">Figure 3.7: Manhattan versus Sorensen distance</p>
    <p class="normal">The simple <a id="_idIndexMarker253"/>Manhattan distance applies no matter how far from the origin we are. The Sorensen distance reduces the importance of measures that are further from the origin so they don't dominate the <em class="italic">k</em>-NN by virtue of being large-valued outliers.</p>
    <p class="normal">We can introduce this into our design by adding a new subclass of <code class="Code-In-Text--PACKT-">Distance</code>. While this is similar, in some ways, to the Manhattan distance, it's often classified separately:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SD</span><span class="hljs-class">(</span><span class="hljs-params">Distance</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">distance</span><span class="hljs-function">(</span><span class="hljs-params">self, s1: Sample, s2: Sample</span><span class="hljs-function">) -&gt; float:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(
            [
                <span class="hljs-built_in">abs</span>(s1.sepal_length - s2.sepal_length),
                <span class="hljs-built_in">abs</span>(s1.sepal_width - s2.sepal_width),
                <span class="hljs-built_in">abs</span>(s1.petal_length - s2.petal_length),
                <span class="hljs-built_in">abs</span>(s1.petal_width - s2.petal_width),
            ]
        ) / <span class="hljs-built_in">sum</span>(
            [
                s1.sepal_length + s2.sepal_length,
                s1.sepal_width + s2.sepal_width,
                s1.petal_length + s2.petal_length,
                s1.petal_width + s2.petal_width,
            ]
        )
</code></pre>
    <p class="normal">This design approach lets us leverage object-oriented inheritance to build a polymorphic family of distance computation functions. We can build on the first few functions to create a wide family of functions and use these as part of hyperparameter tuning to locate the best way to measure distances and perform the required classification.</p>
    <p class="normal">We'll need to integrate a <code class="Code-In-Text--PACKT-">Distance</code> object into the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class. This means providing an instance of one of these subclasses. Because they're all implementing the same <code class="Code-In-Text--PACKT-">distance()</code> method, we can replace different alternative distance computations to find which performs best with our unique collection of data and attributes.</p>
    <p class="normal">For now, we can reference a specific distance subclass in our <code class="Code-In-Text--PACKT-">Hyperparameter</code> class definition. In <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns</em>, we'll look at how we can flexibly plug in any possible distance computation from the hierarchy of <code class="Code-In-Text--PACKT-">Distance</code> class definitions.</p>
    <h1 id="_idParaDest-74" class="title">Recall</h1>
    <p class="normal">Some key points in this chapter:</p>
    <ul>
      <li class="bullet">A central object-oriented design principle is inheritance: a subclass can inherit aspects of a superclass, saving copy-and-paste programming. A subclass can extend the superclass to add features or specialize the superclass in other ways.</li>
      <li class="bullet">Multiple inheritance is a feature of Python. The most common form is a host class with mixin class definitions. We can combine multiple classes leveraging the method resolution order to handle common features like initialization.</li>
      <li class="bullet">Polymorphism lets us create multiple classes that provide alternative implementations for fulfilling a contract. Because of Python's duck typing rules, any classes that have the right methods can substitute for each other. </li>
    </ul>
    <h1 id="_idParaDest-75" class="title">Exercises</h1>
    <p class="normal">Look around you at some of the physical objects in your workspace and see if you can describe them in an inheritance hierarchy. Humans have been dividing the world into taxonomies like this for centuries, so it shouldn't be difficult. Are there any non-obvious inheritance relationships between classes of objects? If you were to model these objects in a computer application, what properties and methods would they share? Which ones would have to be polymorphically overridden? What properties would be completely different between them?</p>
    <p class="normal">Now write some code. No, not for the physical hierarchy; that's boring. Physical items have more properties than methods. Just think about a pet programming project you've wanted to tackle in the past year, but never gotten around to. For whatever problem you want to solve, try to think of some basic inheritance relationships and then implement them. Make sure that you also pay attention to the sorts of relationships that you actually don't need to use inheritance for. Are there any places where you might want to use multiple inheritance? Are you sure? Can you see any place where you would want to use a mixin? Try to knock together a quick prototype. It doesn't have to be useful or even partially working. You've seen how you can test code using <code class="Code-In-Text--PACKT-">python -i</code> already; just write some code and test it in the interactive interpreter. If it works, write some more. If it doesn't, fix it!</p>
    <p class="normal">Now, take a look at the various distance computations in the case study. We need to be able to work with testing data as well as unknown samples provided by a user. What do these two kinds of samples have in common? Can you create a common superclass and use inheritance for these two classes with similar behavior? (We haven't looked closely at the <em class="italic">k</em>-NN classification yet, but you can provide a "mock" classifier that will provide fake answers.)</p>
    <p class="normal">When we look at the distance computation, we can see how a <code class="Code-In-Text--PACKT-">Hyperparameter</code> is a composition that includes a distance algorithm plug-in as one of the parameters. Is this a good candidate for a mixin? Why or why not? What limitations does a mixin have that a plug-in does not have?</p>
    <h1 id="_idParaDest-76" class="title">Summary</h1>
    <p class="normal">We've gone from simple inheritance, one of the most useful tools in the object-oriented programmer's toolbox, all the way through to multiple inheritance – one of the most complicated. Inheritance can be used to add functionality to existing classes and built-in generics. Abstracting similar code into a parent class can help increase maintainability. Methods on parent classes can be called using <code class="Code-In-Text--PACKT-">super</code>, and argument lists must be formatted safely for these calls to work when using multiple inheritance.</p>
    <p class="normal">In the next chapter, we'll cover the subtle art of handling exceptional circumstances.</p>
  </div>
</body></html>