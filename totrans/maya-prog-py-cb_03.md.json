["```py\nimport maya.cmds as cmds\n\ndef currentSelectionPolygonal(obj):\n\n    shapeNode = cmds.listRelatives(obj, shapes=True)\n    nodeType = cmds.nodeType(shapeNode)\n\n    if nodeType == \"mesh\":\n        return True\n\n    return False\n\ndef checkSelection():\n    selectedObjs = cmds.ls(selection=True)\n\n    if (len(selectedObjs) < 1):\n        cmds.error('Please select an object')\n\n    lastSelected = selectedObjs[-1]\n\n    isPolygon = currentSelectionPolygonal(lastSelected)\n\n    if (isPolygon):\n        print('FOUND POLYGON')\n    else:\n        cmds.error('Please select a polygonal object')\n\ncheckSelection()\n```", "```py\nselectedObjs = cmds.ls(selection=True)\n```", "```py\n    if (len(selectedObjs) < 1):\n        cmds.error('Please select an object')\n```", "```py\nlastSelected = selectedObjs[-1]\n```", "```py\nisPolygon = currentSelectionPolygonal(lastSelected)\n```", "```py\ndef currentSelectionPolygonal(obj):\n    shapeNode = cmds.listRelatives(obj, shapes=True)\n```", "```py\n    if nodeType == \"mesh\":\n        return True\n\n    return False\n```", "```py\n    isMesh = False\n    if (nodeType == \"mesh\"):\n        isMesh = True\n\n    return isMesh\n```", "```py\n    return (nodeType == \"mesh\")\n```", "```py\n    if (isPolygon):\n        print('FOUND POLYGON')\n    else:\n        cmds.error('Please select a polygonal object')\n```", "```py\nimport maya.cmds as cmds\n\n# examine data for a currently-selected polygonal object\ndef getPolyData():\n    selectedObjects = cmds.ls(selection=True)\n    obj = selectedObjects[-1]\n\n    vertNum = cmds.polyEvaluate(obj, vertex=True)\n    print('Vertex Number: ',vertNum)\n\n    edgeNum = cmds.polyEvaluate(obj, edge=True)\n    print('Edge Number: ', edgeNum)\n\n    faceNum = cmds.polyEvaluate(obj, face=True)\n    print('Face Number: ',faceNum)\n\ngetPolyData()\n```", "```py\ncmds.select(obj+'.vtx[0]', replace=True)\n```", "```py\ncmds.select(obj+'.e[0]', replace=True)\n```", "```py\ncmds.select(obj+'.f[0]', replace=True)\n```", "```py\ncmds.select(obj+'.vtx[5:12]', replace=True)\n```", "```py\ncmds.select(obj+'.vtx[' + str(startIndex) + ':' + str(endIndex) + ']', replace=True)\n```", "```py\nmyObject.vtx[5:12]\n```", "```py\n{0}.vtx[{1}:{2}]\n```", "```py\n\"{0}.vtx[{1}:{2}]\".format(\"myObject\", 5, 12)\n```", "```py\nobjectName = \"myObject\"\nstartIndex = 5\nendIndex = 12\ncmds.select(\"{0}.vtx[{1}:{2}]\".format(objectName, startIndex, endIndex), replace=True)\n```", "```py\nimport maya.cmds as cmds\n\ndef getNURBSInfo():\n    selectedObjects = cmds.ls(selection=True)\n    obj = selectedObjects[-1]\n    degU = cmds.getAttr(obj + '.degreeU')\n    spansU = cmds.getAttr(obj + '.spansU')\n    cvsU = degU + spansU\n    print('CVs (U): ', cvsU)\n\n    degV = cmds.getAttr(obj + '.degreeV')\n    spansV = cmds.getAttr(obj + '.spansV')\n    cvsV = degV + spansV\n    print('CVs (V): ', cvsV)\n\ngetNURBSInfo()\n```", "```py\ndegU = cmds.getAttr(obj + '.degreeU')\nspansU = cmds.getAttr(obj + '.spansU')\n```", "```py\ndegU = cmds.getAttr(obj + '.degreeU')\nspansU = cmds.getAttr(obj + '.spansU')\ncvsU = degU + spansU\nprint('CVs (U): ', cvsU)\n```", "```py\ncmds.select(obj+'.cv[0][0]')\n```", "```py\ncmds.select(obj+'.cv[' + str(cvsU-1) + '][' + str(cvsV-1) + ']', add=True)\n```", "```py\ncmds.select(\"{0}.cv[{1}][{2}]\".format(obj, (cvsU-1), (cvsV-1), add=True)\n```", "```py\n    degree = cmds.getAttr(obj + '.degree')\n    spans = cmds.getAttr(obj + '.spans')\n    cvs = degree + spans\n    print('CVs: ', cvs)\n\n    cmds.select(obj+'.cv[0]')\n    cmds.select(obj+'.cv[' + str(cvs-1) + ']', add=True)\n```", "```py\nimport maya.cmds as cmds\nimport math\n\ndef makeCurve():\n    theCurve = cmds.curve(degree=1, p=[(-0.5,-0.5,0),(0.5,- 0.5,0),(0.5,0.5,0), (-0.5,0.5,0), (-0.5, -0.5, 0)])\n\ndef curveFunction(i):\n    x = math.sin(i)\n    y = math.cos(i)\n    x = math.pow(x, 3)\n    y = math.pow(y, 3)\n    return (x,y)\n\ndef complexCurve():\n    theCurve = cmds.curve(degree=3, p=[(0,0,0)])\n\n    for i in range(0, 32):\n        val = (math.pi * 2)/32 * i\n        newPoint = curveFunction(val)\n        cmds.curve(theCurve, append=True, p=[(newPoint[0], newPoint[1], 0)])\n\nmakeCurve()\ncomplexCurve()\n```", "```py\ntheCurve = cmds.curve(degree=1, p=[(-0.5,-0.5,0),(0.5,- 0.5,0),(0.5,0.5,0), (-0.5,0.5,0), (-0.5, -0.5, 0)])\n```", "```py\ndef curveFunction(i):\n    x = math.sin(i)\n    y = math.cos(i)\n    x = math.pow(x, 3)\n    y = math.pow(y, 3)\n    return (x,y)\n```", "```py\ntheCurve = cmds.curve(degree=3, p=[(0,0,0)])\n```", "```py\nfor i in range(0, 32):\n    val = (math.pi * 2)/32 * i\n    newPoint = curveFunction(val)\n    cmds.curve(theCurve, append=True, p=[(newPoint[0], newPoint[1], 0)])\n```", "```py\nimport maya.cmds as cmds\nimport math\n\ndef makeFace():\n\n    newFace = cmds.polyCreateFacet(p=[(-1,-1,0),(1,- 1,0),(1,1,0),(-1,1,0)])\n\ndef makeFaceWithHole():\n    points = []\n\n    # create the inital square\n    points.append((-5, -5, 0))\n    points.append(( 5, -5, 0))\n    points.append(( 5, 5, 0))\n    points.append((-5, 5, 0))\n\n    # add empty point to start a hole\n    points.append(())\n\n    for i in range(32):\n        theta = (math.pi * 2) / 32 * i\n        x = math.cos(theta) * 2\n        y = math.sin(theta) * 2\n        points.append((x, y, 0))\n\n    newFace = cmds.polyCreateFacet(p=points)\n\nmakeFace()\nmakeFaceWithHole()\n```", "```py\nnewFace = cmds.polyCreateFacet(p=[(-1,-1,0),(1,-1,0),(1,1,0),(- 1,1,0)])\n```", "```py\npoints = []\n\n# create the inital square\npoints.append((-5, -5, 0))\npoints.append(( 5, -5, 0))\npoints.append(( 5, 5, 0))\npoints.append((-5, 5, 0))\n```", "```py\n    points.append(())\n```", "```py\nfor i in range(32):\n        theta = (math.pi * 2) / 32 * i\n        x = math.cos(theta) * 2\n        y = math.sin(theta) * 2\n        points.append((x, y, 0))\n```", "```py\nnewFace = cmds.polyCreateFacet(p=points)\n```", "```py\n# with a polygonal object selected\ncmds.polyNormal(normalMode=4)\n```", "```py\ncmds.polyCreateFacet(p=myPoints)\ncmds.polyTriangulate()\n```", "```py\n# attempt to form quads from a recently-triangulated poly mesh\ncmds.polyQuad()\n```", "```py\nimport maya.cmds as cmds\nimport random\n\ndef addNoise(amt):\n\n    selectedObjs = cmds.ls(selection=True)\n    obj = selectedObjs[-1]\n\n    shapeNode = cmds.listRelatives(obj, shapes=True)\n\n    if (cmds.nodeType(shapeNode) != 'mesh'):\n        cmds.error('Select a mesh')\n        return\n\n    numVerts = cmds.polyEvaluate(obj, vertex=True)\n\n    randAmt = [0, 0, 0]\n    for i in range(0, numVerts):\n\n        for j in range(0, 3):\n            randAmt[j] = random.random() * (amt*2) - amt\n\n        vertexStr = \"{0}.vtx[{1}]\".format(obj, i)\n        cmds.select(vertexStr, replace=True)\n        cmds.move(randAmt[0], randAmt[1], randAmt[2], relative=True)\n\n    cmds.select(obj, replace=True)\n\naddNoise(0.2)\n```", "```py\n    selectedObjs = cmds.ls(selection=True)\n    obj = selectedObjs[-1]\n\n    shapeNode = cmds.listRelatives(obj, shapes=True)\n```", "```py\nnumVerts = cmds.polyEvaluate(obj, vertex=True)\n```", "```py\nrandAmt = [0, 0, 0]\n```", "```py\n        for j in range(0, 3):\n            randAmt[j] = random.random() * (amt*2) - amt\n```", "```py\n        vertexStr = \"{0}.vtx[{1}]\".format(obj, i)\n        cmds.select(vertexStr, replace=True)\n        cmds.move(randAmt[0], randAmt[1], randAmt[2], relative=True)\n```", "```py\ncmds.polyMoveVertex(vertexStr, t=randAmt)\n```", "```py\ncmds.select(obj, replace=True)\n```", "```py\nimport maya.cmds as cmds\nimport math\n\ndef makeTetra(size):\n\n    pointA = [0, 0, 0]\n    pointB = [size, 0, 0]\n\n    pointC = [size/2.0, 0, 0]\n    # set the Z position for C\n    pointC[2] = math.sqrt((size*size) - (size/2.0 * size/2.0))\n\n    pointE = [0,0,0]\n    # average the A, B, and C to get E\n    # first add all the values\n    for i in range(0,3):\n        pointE[i] += pointA[i]\n        pointE[i] += pointB[i]\n        pointE[i] += pointC[i]\n    # now divide by 3\n    for i in range(0,3):\n        pointE[i] = pointE[i] / 3.0\n\n    # start point D with the X and Z coordinates of point E\n    pointD = [0,0,0]\n    pointD[0] = pointE[0]\n    pointD[2] = pointE[2]\n\n    distanceAE = math.sqrt((pointE[0] * pointE[0]) + (pointE[2] * pointE[2]))\n\n    # set the Y coordinate of point D\n    pointD[1] = math.sqrt((size * size) - (distanceAE * distanceAE))\n\n    faces = []\n    faces.append(cmds.polyCreateFacet(p=[pointA, pointB, pointC], texture=1))\n    faces.append(cmds.polyCreateFacet(p=[pointA, pointD, pointB], texture=1))\n    faces.append(cmds.polyCreateFacet(p=[pointB, pointD, pointC], texture=1))\n    faces.append(cmds.polyCreateFacet(p=[pointC, pointD, pointA], texture=1))\n\n    cmds.select(faces[0], replace=True)\n    for i in range(1, len(faces)):\n        cmds.select(faces[i], add=True)\n\n    obj = cmds.polyUnite()\n\n    cmds.select(obj[0] + \".vtx[:]\")\n    cmds.polyMergeVertex(distance=0.0001)\n\n    cmds.select(obj[0])\n\n    cmds.move(-pointE[0], 0, -pointE[2])\n    cmds.xform(pivots=(pointE[0], 0, pointE[2]))\n    cmds.makeIdentity(apply=True)\n    cmds.delete(ch=True)\n\nmakeTetra(5)\n```", "```py\npointA = [0, 0, 0]\npointB = [size, 0, 0]\n```", "```py\npointC = [size/2.0, 0, 0]\n# set the Z position for C\npointC[2] = math.sqrt((size*size) - (size/2.0 * size/2.0))\n```", "```py\npointE = [0,0,0]\n# average the A, B, and C to get E\n# first add all the values\nfor i in range(0,3):\n    pointE[i] += pointA[i]\n    pointE[i] += pointB[i]\n    pointE[i] += pointC[i]\n# now divide by 3\nfor i in range(0,3):\n    pointE[i] = pointE[i] / 3.0\n```", "```py\n# start point D with the X and Z coordinates of point E\npointD = [0,0,0]\npointD[0] = pointE[0]\npointD[2] = pointE[2]\ndistanceAE = math.sqrt((pointE[0] * pointE[0]) + (pointE[2] * pointE[2]))\n```", "```py\nfaces = []\nfaces.append(cmds.polyCreateFacet(p=[pointA, pointB, pointC], texture=1))\nfaces.append(cmds.polyCreateFacet(p=[pointA, pointD, pointB], texture=1))\nfaces.append(cmds.polyCreateFacet(p=[pointB, pointD, pointC], texture=1))\nfaces.append(cmds.polyCreateFacet(p=[pointC, pointD, pointA], texture=1))\n```", "```py\ncmds.select(faces[0], replace=True)\nfor i in range(1, len(faces)):\n    cmds.select(faces[i], add=True)\n```", "```py\nobj = cmds.polyUnite()\n```", "```py\ncmds.select(obj[0] + \".vtx[:]\")\n```", "```py\ncmds.polyMergeVertex(distance=0.0001)\n```", "```py\ncmds.select(obj[0])\n```", "```py\ncmds.move(-pointE[0], 0, -pointE[2])\n```", "```py\ncmds.xform(pivots=(pointE[0], 0, pointE[2]))\n```", "```py\ncmds.makeIdentity(apply=True)\ncmds.delete(ch=True)\n```"]