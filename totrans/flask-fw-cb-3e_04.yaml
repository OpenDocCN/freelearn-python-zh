- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any web application, it is very important to control how you interact with
    web requests and the proper responses to cater to these requests. This chapter
    takes us through the various methods of handling requests properly and designing
    them in the best way.
  prefs: []
  type: TYPE_NORMAL
- en: Flask offers several ways of designing and laying out URL routing for our applications.
    Also, it gives us the flexibility to keep the architecture of our views as just
    functions or to create classes, which can be inherited and modified as required.
    In earlier versions, Flask just had function-based views. Later, however, in Version
    0.7, inspired by Django, Flask introduced the concept of pluggable views, which
    allows us to have classes and then write methods in these classes. This also makes
    the process of building a RESTful API pretty straightforward, with every HTTP
    method being handled by the corresponding class method. Also, we can always go
    a level deeper into the Werkzeug library and use the more flexible, but slightly
    complex, concept of URL maps. In fact, large applications and frameworks prefer
    using URL maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing function-based views and URL routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing class-based views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing URL routing and product-based pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering to templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with XHR requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using decorators to handle requests beautifully
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom 4xx and 5xx error handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flashing messages for better user feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing SQL-based searching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing function-based views and URL routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the simplest way of writing views and URL routes in Flask. We can just
    write a method and decorate it with the endpoint. In this recipe, we will write
    a few URL routes for `GET` and `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To go through this recipe, we can start with any Flask application. The app
    can be a new, empty, or complex app. We just need to understand the methods outlined
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following section explains the three most widely used different kinds of
    requests, demonstrated by means of small examples.
  prefs: []
  type: TYPE_NORMAL
- en: A simple GET request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a simple example of what a `GET` request looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just check whether the URL query has an argument called `foo`. If yes,
    we display this in the response; otherwise, the default is `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: A simple POST request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`POST` is similar to the `GET` request, but with a few differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The route now contains an extra argument called `methods`. Also, instead of
    `request.args`, we now use `request.form`, as `POST` assumes that the data is
    submitted in a form.
  prefs: []
  type: TYPE_NORMAL
- en: A simple GET/POST request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An amalgamation of both `GET` and `POST` into a single `view` function can
    be written as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s try to understand how the preceding play of methods works.
  prefs: []
  type: TYPE_NORMAL
- en: By default, any Flask `view` function supports only `GET` requests. In order
    to support or handle any other kind of request, we have to specifically tell our
    `route()` decorator about the methods we want to support. This is precisely what
    we did in our last two methods for `POST` and `GET/POST`.
  prefs: []
  type: TYPE_NORMAL
- en: For `GET` requests, the `request` object will look for `args` – that is, `request.args.get()`
    – and for `POST`, it will look for `form` – that is, `request.form.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if we try to make a `GET` request to a method that supports only `POST`,
    the request will fail with a `405` HTTP error. The same holds true for all the
    methods. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.1 – The Method Not Allowed \uFEFFerror page](img/B19111_04_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The Method Not Allowed error page
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we might want to have a URL map kind of a pattern, where we prefer
    to define all the URL rules with endpoints in a single place, rather than them
    being scattered all around an application. For this, we will need to define our
    methods without the `route()` decorator and define the route on our application
    object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you give the correct relative path to the method assigned to
    `view_func`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing class-based views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask introduced the concept of pluggable views in *Version 0.7*; this added
    a lot of flexibility to the existing implementation. We can write views in the
    form of classes; these views can be written in a generic fashion and allow for
    easy and understandable inheritance. In this recipe, we will look at how to create
    such class-based views.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Writing function-based views and URL routes*,
    to see the basic function-based views first.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flask provides a class named `View`, which can be inherited to add our custom
    behavior. The following is an example of a simple `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The name of the view provided in `as_view` (i.e., `get_request`) signifies the
    name that will be used when referring to this endpoint in `url_for()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate both the `GET` and `POST` requests, we can write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know that by default, any Flask `view` function supports only `GET` requests.
    The same applies to class-based views. In order to support or handle any other
    kind of request, we have to specifically tell our class, via a class attribute
    called `methods`, about the `HTTP` methods we want to support. This is exactly
    what we did in our last example of `GET/POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: For `GET` requests, the `request` object will look for `args` – that is, `request.args.get()`
    – and for `POST`, it will look for `form` – that is, `request.form.get()`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we try to make a `GET` request to a method that supports only `POST`,
    the request will fail with a `405` HTTP error. The same holds true for all the
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, many of you may be considering whether it would be possible to just declare
    the `GET` and `POST` methods inside a `View` class and let Flask handle the rest
    of the stuff. The answer to this question is `MethodView`. Let’s write our previous
    snippet using `MethodView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the previous recipe, *Writing function-based views and URL routes*,
    to understand the contrast between class- and function-based views.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing URL routing and product-based pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, we may encounter a problem where there is a need to parse the various
    parts of a URL differently. For example, a URL can have an integer part, a string
    part, a string part of a specific length, and slashes in the URL. We can parse
    all these combinations in our URLs using URL converters. In this recipe, we will
    see how to do this. Also, we will learn how to implement pagination using the
    `Flask-SQLAlchemy` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen several instances of basic URL converters in this book.
    In this recipe, we will look at some advanced URL converters and learn how to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we have a URL route defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the URL, `http://127.0.0.1:5000/test/Shalabh`, will result in `Shalabh`
    being parsed and passed in the `name` argument of the `get_name` method. This
    is a Unicode or string converter, which is the default one and need not be specified
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also have strings with specific lengths. Let’s say we want to parse
    a URL that may contain a country code or currency code. Country codes are usually
    two characters long, and currency codes are three characters long. This can be
    done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will match both `US` and `USD` in the URL – that is, `http://127.0.0.1:5000/test/USD`
    and `http://127.0.0.1:5000/test/US` will be treated similarly. We can also match
    the exact length using the `length` parameter instead of `minlength` and `maxlength`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also parse integer values in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can also specify the minimum and maximum values that can be accepted. For
    example, to limit the acceptable age between 18 and 99, the URL can be structured
    as `@app.route('/test/<int(min=18,max=99):age>')`. We can also parse float values
    using `float` in place of `int` in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s understand the concept of **pagination** next. In the *Creating a basic
    product model* recipe in [*Chapter 3*](B19111_03.xhtml#_idTextAnchor129), *Data
    Modeling in Flask*, we created a handler to list all the products in our database.
    If we have thousands of products, then generating a list of all of these products
    in one go can take a lot of time. Also, if we have to render these products in
    a template, then we would not want to show more than 10–20 products on a page
    in one go. Pagination proves to be a big help in building great applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify the `products()` method to list products to support pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding handler, we added a new URL route that adds a `page` parameter
    to the URL. Now, the `http://127.0.0.1:5000/products` URL will be the same as
    `http://127.0.0.1:5000/products/1`, and both will return a list of the first 10
    products from the database. The `http://127.0.0.1:5000/products/2` URL will return
    the next 10 products, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'The `paginate()` method takes four arguments and returns an object of the `Pagination`
    class. These four arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '• `page`: This is the current page to be listed.'
  prefs: []
  type: TYPE_NORMAL
- en: '• `per_page`: This is the number of items to be listed per page.'
  prefs: []
  type: TYPE_NORMAL
- en: '• `error_out`: If no items are found for the page, then this aborts with a
    `404` error. To prevent this behavior, set this parameter to `False`, and then
    it will just return an empty list.'
  prefs: []
  type: TYPE_NORMAL
- en: '• `max_per_page`: If this value is specified, then `per_page` will be limited
    to the same.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Creating a basic product model* recipe in [*Chapter 3*](B19111_03.xhtml#_idTextAnchor129),
    *Data Modeling in Flask*, to understand the context of this recipe for pagination,
    as this recipe builds on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering to templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After writing the views, we will surely want to render the content in a template
    and get information from the underlying database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To render templates, we will use `Jinja` as the templating language. Refer to
    [*Chapter 2*](B19111_02.xhtml#_idTextAnchor083), *Templating with Jinja2*, to
    understand templating in depth.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will again work in reference to our existing catalog application from the
    previous recipe. Let’s modify our views to render templates and then display data
    from the database in these templates.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the modified `views.py` code and the templates. The complete
    app can be downloaded from the code bundle provided with this book or from the
    GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by modifying our views – that is, `flask_catalog_template/my_app/catalog/views.py`
    – to render templates on specific handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note the `render_template()` method. This method will render `home.html` when
    the `home` handler is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following method handles the rendering of `product.html` with the `product`
    object in the template context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the paginated list of all products, see the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `products.html` template will be rendered with the list of paginated
    `product` objects in the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the product template on the creation of a new product, the `create_product()`
    method can be modified, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done using `redirect()`, but we will cover this at a later
    stage. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All three handlers in the preceding code work in a similar way, as discussed
    earlier when rendering the product-related templates.
  prefs: []
  type: TYPE_NORMAL
- en: The following are all the templates created and rendered as part of the application.
    For more information on how these templates are written and how they work, refer
    to [*Chapter 2*](B19111_02.xhtml#_idTextAnchor083), *Templating* *with Jinja2*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first template file is `flask_catalog_template/my_app/templates/base.html`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flask_catalog_template/my_app/templates/home.html` file appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flask_catalog_template/my_app/templates/product.html` file appears as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flask_catalog_template/my_app/templates/products.html` file appears as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note how the URL is being created for the `Previous page` and `Next page` links.
    We are using `request.endpoint` so that pagination works for the current URL,
    which will make the template reusable with `search` as well. We will see this
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flask_catalog_template/my_app/templates/category.html` file appears as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flask_catalog_template/my_app/templates/categories.html` file appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `view` methods have a `render_template` method call at the end. This means
    that following the successful completion of the method operations, we will render
    a template with some parameters added to the context.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Note how pagination has been implemented in the `products.html` file. It can
    be improved further to show the page numbers as well between the two links for
    navigation. You should undertake this on your own.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Implementing URL routing and product-based pagination* recipe
    to understand pagination and the remainder of the application used in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with XHR requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous JavaScript**, commonly known as **Ajax**, has become an important
    part of web applications over the last decade or so. The built-in **XMLHttpRequest**
    (**XHR**) object in a browser is used to execute Ajax on web pages. With the advent
    of single-page applications and JavaScript application frameworks such as **Angular**,
    **Vue**, and **React**, this technique of web development has risen exponentially.
    In this recipe, we will implement an Ajax request to facilitate asynchronous communication
    between the backend and the frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this book, I am opting to use Ajax to demonstrate `async` requests because
    it is simpler to understand and demonstrate and keeps the focus of the book on
    Flask. You can choose to use any JavaScript platform/framework. The Flask code
    would remain the same, while the JavaScript code would have to change according
    to the framework that you used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask provides an easy way to handle the XHR requests in the view handlers.
    We can even have common methods for normal web requests and XHRs. We can just
    check for the `XMLHttpRequest` header in our `request` object to determine the
    type of call and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We will update the catalog application from the previous recipe to have a feature
    to demonstrate XHR requests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Flask `request` object has a provision to check for the headers sent along
    with the request from the browser. We can check the `X-Requested-With` header
    for `XMLHttpRequest`, which tells us whether the request made is an XHR request
    or a simple web request. Usually, when we have an XHR request, the caller expects
    the result to be in the JSON format, which can then be used to render content
    in the correct place on the web page without reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s say we have an Ajax call to fetch the number of products in the database
    on the home page itself. One way to fetch the products is to send the count of
    products along with the `render_template()` context. Another way is to send this
    information over as a response to an Ajax call. We will implement the latter to
    see how Flask handles XHR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we first checked whether this is an XHR. If it is,
    we return the JSON data; otherwise, we just render `home.html`, as we have done
    hitherto.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This design of handling XHR and regular requests together in one method can
    become a bit bloated as the application grows in size, and different logic handling
    has to be executed in the case of XHR, compared to regular requests. In such cases,
    these two types of requests can be separated into different methods, where the
    handling of XHR is done separately from regular requests. This can even be extended
    so that we have different blueprints to make URL handling even cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify `flask_catalog_template/my_app/templates/base.html` to a block
    for `scripts`. This empty block, which is shown here, can be placed after the
    line where the `Bootstrap.js` script is included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have `flask_catalog_template/my_app/templates/home.html`, where we
    send an Ajax call to the `home()` handler, which checks whether the request is
    an XHR request. If it is, it fetches the count of products from the database and
    returns it as a JSON object. Check the code inside the `scripts` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, our home page contains a badge, which shows the number of products in the
    database. This badge will load only after the whole page has loaded. The difference
    in the loading of the badge and the other content on the page will be notable
    when the database has a substantially high number of products.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot that shows what the home page looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.2 – The home page\uFEFF with the count loaded using AJAX calls](img/B19111_04_2.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The home page with the count loaded using AJAX calls
  prefs: []
  type: TYPE_NORMAL
- en: Using decorators to handle requests beautifully
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of you may believe that checking every time whether a request is XHR, as
    shown in the last recipe, kills code readability. To solve this, we have an easy
    solution. In this recipe, we will write a simple decorator that can handle this
    redundant code for us.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will write a decorator. For some Python beginners, this might
    seem like alien territory. If so, read [http://legacy.python.org/dev/peps/pep-0318/](http://legacy.python.org/dev/peps/pep-0318/)
    for a better understanding of decorators.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the decorator method that we have written for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This decorator simply does what we did in the previous recipe to handle XHR
    – that is, check whether our request is XHR and, based on the outcome, either
    render the template or return JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s apply this decorator to our `home()` method, which handled the XHR
    call in the last recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Dealing with XHR requests* recipe to understand how this recipe
    changes the coding pattern. The reference for this recipe comes from [http://justindonato.com/notebook/template-or-json-decorator-for-flask.html](http://justindonato.com/notebook/template-or-json-decorator-for-flask.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom 4xx and 5xx error handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application throws errors to users at some point in time. These errors
    can be due to a user typing a non-existent URL (`404`), application overload (`500`),
    or something forbidden for a certain user to access (`403`). A good application
    handles these errors in a user-interactive way instead of showing an ugly white
    page, which makes no sense to most users. Flask provides an easy-to-use decorator
    to handle these errors. In this recipe, we will understand how we can leverage
    this decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Flask `app` object has a method called `errorhandler()`, which enables us
    to handle our application’s errors in a much more beautiful and efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a method that is decorated with `errorhandler()` and renders the `404.html`
    template whenever the `404 Not Found` error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines of code represent the `flask_catalog_template/my_app/templates/404.html`
    template, which is rendered if there are any `404` errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, now, if we open an incorrect URL – for example, `http://127.0.0.1:5000/i-am-
    lost` – then we will get the screen shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – A custom error handler page](img/B19111_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – A custom error handler page
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can add more error handlers for other error codes too.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to create custom errors as per application requirements
    and bind them to error codes and custom error screens. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Flashing messages for better user feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important aspect of all good web applications is to give users feedback regarding
    various activities. For example, when a user creates a product and is redirected
    to the newly created product, then it is good practice to tell them that the product
    has been created. In this recipe, we will see how flashing messages can be used
    as a good feedback mechanism for users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start by adding the flash message functionality to our existing catalog
    application. We also have to make sure that we add a secret key to the application
    because the session depends on it, and if it’s absent, the application will error
    out while flashing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate the flashing of messages, we will flash messages upon a product’s
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a secret key to our app configuration in `flask_catalog_template/my_app``__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will modify our `create_product()` handler in `flask_catalog_template/my_app/catalog/views.py`
    to flash a message to the user regarding the product’s creation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, another change has been made to this handler; now, it is possible to create
    the product from a web interface using a form. This change will make it easier
    to demonstrate how this recipe would work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we first check whether the request type is `POST`.
    If yes, then we proceed to product creation as always, or render the page with
    a form to create a new product. Also, note the `flash` statement, which will alert
    a user in the event of the successful creation of a product. The first argument
    to `flash()` is the message to be displayed, and the second is the category of
    the message. We can use any suitable identifier in the `message` category. This
    can be used later to determine the type of alert message to be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new template is added; this holds the code for the product form. The path
    of the template will be `flask_catalog_template/my_app/templates/product-create.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also modify our base template – that is, `flask_catalog_template/my_app/templates/base.html`
    – to accommodate flashed messages. Just add the following lines of code inside
    the `<div>` container before the `container` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the `<div>` container, we have added a mechanism to show a flashed
    message that fetches the flashed messages in the template, using `get_flashed_messages()`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A form like the one shown in the following screenshot will appear upon moving
    to `http://127.0.0.1:5000/product-create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Creating a product](img/B19111_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Creating a product
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the form and click on **Submit**. This will lead to the usual product
    page with an alert message at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.5 –\uFEFF The flash message on successful product creation](img/B19111_04_5.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The flash message on successful product creation
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SQL-based searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In any web application, it is important to be able to search a database for
    records based on certain criteria. In this recipe, we will go through how to implement
    basic SQL-based searching in SQLAlchemy. The same principle can be used to search
    any other database system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have implemented some level of search functionality in our catalog application
    from the beginning. Whenever we show the product page, we search for a specific
    product using its ID. We will now take it to a slightly more advanced level and
    search on the basis of name and category.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a method that searches in our catalog application for name,
    price, company, and category. We can search for any one criterion, or multiple
    criteria (except for a search by category, which can only be searched alone).
    Note that we have different expressions for different values. For a float value
    in `price`, we can search for equality, and in the case of a string, we can search
    using `like`. Also, carefully note how `join` is implemented in the case of `category`.
    Place this method in the `views` file – that is, `flask_catalog_template/my_app/catalog/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can search for products by entering a URL, something like `http://127.0.0.1:5000/product-search?name=iPhone`.
    This will search for products with the name `iPhone` and list the results on the
    `products.html` template. Similarly, we can search for price and/or company or
    category as required. Try various combinations by yourself to aid your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: We have used the same product list page to render our search results. It will
    be interesting to implement the search using Ajax. I will leave this to you to
    implement yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Flask Deep Dive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the basic Flask web application is built, the next question concerns creating
    beautiful and reusable web forms and authentication. The first two chapters in
    this part focus specifically on these topics.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you can always build web forms using plain HTML, but it is usually
    a cumbersome task and difficult to maintain consistent reusable components. This
    is where Jinja helps, with a better definition of forms and super-easy validations
    while being extensible and customizable.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication is one of the most important parts of any application, whether
    web, mobile, or desktop. [*Chapter 6*](B19111_06.xhtml#_idTextAnchor328) focuses
    on various techniques of authentication, which range from social to completely
    managed in-house.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter deals with APIs, which are an integral part of any web application,
    and one of the major strengths of Flask lies in building APIs in a very clear,
    concise, and readable format. This is followed by adding the capability to support
    multiple languages in your Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Flask by default does not come with an admin interface as you would find in
    Django, which is another popular web framework written in Python. However, it
    is possible to create a completely custom admin interface in Flask quickly by
    leveraging some extensions. The last chapter in this part deals with this subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19111_05.xhtml#_idTextAnchor273)*, Web Forms with WTForms*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19111_06.xhtml#_idTextAnchor328)*, Authenticating in Flask*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19111_07.xhtml#_idTextAnchor385)*, RESTful API Building*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19111_08.xhtml#_idTextAnchor414)*, Internationalization and
    Localization*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19111_09.xhtml#_idTextAnchor469)*, Admin Interface for Flask
    Apps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
