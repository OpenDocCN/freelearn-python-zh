- en: Chapter 3. Overview of CherryPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter we briefly reviewed some aspects of CherryPy; it is now
    time to dig deeper and see how the project is designed and structured. We will
    first go through a basic CherryPy example. Then we will go through the CherryPy
    core, the publishing-object engine, and see how it wraps the HTTP protocol in
    an object-oriented library. Our next step will be to explore the concept of hooking
    into the core, the CherryPy library, and the tool mechanism. We will then review
    how CherryPy handles errors and exceptions and how you can benefit from it.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter you will have a good overview of the CherryPy library;
    however, it is likely you will need to come back to this chapter during the rest
    of the book in order to fully appreciate it.
  prefs: []
  type: TYPE_NORMAL
- en: Vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to avoid misunderstandings, we need to define a few key words that
    will be used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Web server** | A web server is the interface dealing with the HTTP protocol.
    Its goal is to transform incoming HTTP requests into entities that are then passed
    to the application server and also transform information from the application
    server back into HTTP responses. |'
  prefs: []
  type: TYPE_TB
- en: '| **Application** | An application is a piece of software that takes a unit
    of information, applies business logic to it, and returns a processed unit of
    information. |'
  prefs: []
  type: TYPE_TB
- en: '| **Application server** | An application server is the component hosting one
    or more applications. |'
  prefs: []
  type: TYPE_TB
- en: '| **Web application server** | A web application server is simply the aggregation
    of a web server and an application server into a single component. |'
  prefs: []
  type: TYPE_TB
- en: CherryPy is a web application server.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate the CherryPy library we will go through a very basic web application
    allowing a user to leave a note on the main page through an HTML form. The notes
    will be stacked and be rendered in a reverse order of their creation date. We
    will use a session object to store the name of the author of the note.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Example](img/1848_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each note will have a URI attached to itself, of the form `/note/id`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic Example](img/1848_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a blank file named `note.py` and copy the following source code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Following is the CSS which should be saved in a file named `style.css` and stored
    in the same directory as `note.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the rest of this chapter we will refer to the application to explain CherryPy's
    design.
  prefs: []
  type: TYPE_NORMAL
- en: Built-In HTTP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CherryPy comes with its own web (HTTP) server. The goal of this decision was
    to make CherryPy self-contained and allow users to run a CherryPy application
    within minutes of getting the library. As the name implies, the web server is
    the gateway to a CherryPy application through which all HTTP requests and responses
    have to go. It is therefore up to that layer to handle the low-level TCP sockets
    used to convey the information between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: It is not compulsory to use the built-in server though and CherryPy is quite
    able to interface itself with other web servers if needed. Throughout this book,
    however, we will only use the default built-in web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the web server you have to make the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Internal Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The CherryPy engine is the layer in charge of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing Request and Response objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Request is in charge of retrieving and calling the page handler matching
    the Request-URI.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Response object constructs and validates the response before handing it
    back to the underlying server.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling, managing, and monitoring the CherryPy process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start the engine you must issue the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CherryPy comes with its own configuration system allowing you to parameterize
    the HTTP server as well as the behavior of the CherryPy engine when processing
    a Request-URI.
  prefs: []
  type: TYPE_NORMAL
- en: The settings can be stored either in a text file with syntax close to the `INI`
    format or in a pure Python dictionary. Choosing between the two is a matter of
    taste as both carry the same information.
  prefs: []
  type: TYPE_NORMAL
- en: 'CherryPy offers two entry points for passing configuration values—globally
    to the server instance through the `cherrypy.config.update()` method and per application
    via the `cherrypy.tree.mount()` method. In addition there is a third scope where
    configuration settings can be applied: per path.'
  prefs: []
  type: TYPE_NORMAL
- en: To configure the CherryPy server instance itself you will need to use the `global`
    section of the settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `note` application we have defined the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be represented in a file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using a file to store the settings you must use valid Python objects (string,
    integer, Boolean, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: We define the host and the port on which the server will listen for incoming
    connections.
  prefs: []
  type: TYPE_NORMAL
- en: Then we indicate to the CherryPy engine that the `/style.css` file is to be
    handled by the `staticfile` tool and also indicate the absolute path of the physical
    file to be served. We will explain in detail what tools are in the following chapters
    but for now imagine them as a way to extend CherryPy's internal features and enhance
    its possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To notify CherryPy of our global settings we need to make the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: With a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to pass the configuration values to the mounted applications as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With a dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although in most cases choosing between a dictionary and a file will be a matter
    of taste, it may happen in some cases that one is better than the other. For instance,
    you may be required to pass complex data or objects to one key of the configuration,
    which cannot be achieved via a text file. On the other hand if the settings are
    to be amendable by the administrator of the application, using an INI file may
    facilitate that task.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that if you configure parts of your application such as we do to serve
    the stylesheet in our Note application, you must make a call to `cherrypy.tree.mount()`.
  prefs: []
  type: TYPE_NORMAL
- en: The last way of configuring your application is by using the `_cp_config` attribute
    on your page handler or as a class attribute of the class containing the page
    handlers, in which case the configuration will prevail for all page handlers.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code sample, we indicate that all the page handlers of the
    `Root` class will use `gzip` compression except the `hello` page handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The call to `quickstart` above is a shortcut for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use this call anytime you only mount one single application on a CherryPy
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The last important point is that configuration settings are independent of the
    prefix on which the application is mounted. Therefore in the above example even
    though the application could be mounted at `/myapp` instead of `/`, the settings
    would not be different. They would not include the prefix. Therefore consider
    the configuration settings to be relative to the application but independent of
    the prefix used to mount the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The prefix where the application is mounted is referred to the `script_name`.
  prefs: []
  type: TYPE_NORMAL
- en: Object Publisher Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP servers such as Apache or lighttpd map Request-URIs to paths on the file
    system making them very efficient at handling websites mainly made of static content
    such as images.
  prefs: []
  type: TYPE_NORMAL
- en: CherryPy has chosen a completely different approach and uses its own internal
    lookup algorithm to retrieve the handler referred to by the Request-URI. The decision
    made with CherryPy 2.0 was that such a handler would be a Python-callable object
    attached to a tree of published objects. That is the reason why we speak of object
    publishing as the Request-URI maps to a Python object.
  prefs: []
  type: TYPE_NORMAL
- en: 'CherryPy defines two important concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Published:** A Python object is said to be published when it is attached
    to a tree of objects and the root of this tree is mounted on the CherryPy engine
    server via a call to `cherrypy.tree.mount`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the above example the root object is said to be published. By extension the
    admin object, which is an attribute of a published object, is also published.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exposed:** A published object is said to be exposed when it has an attribute
    named `exposed` set to `True`. An exposed object must be Python callable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Being published is not sufficient for an object to be treated as being a potential
    handler for a URI by CherryPy. A published object must be exposed so that it becomes
    visible to the CherryPy engine. For instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example a request to `/dosome` would return a **Not Found** error because
    the method is not exposed even though it belongs to a published object. The reason
    is that the dosome callable object is not exposed to the internal engine as a
    potential match for a URI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can set the `exposed` attribute either manually or by using the `expose`
    decorator provided by CherryPy as we will do throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An exposed object is usually referred to as a **page handler** by the CherryPy
    community. This is the term we will be using throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the `Note` application the published objects are `note_app`
    and `author`. The root of the tree is `note_app` and is mounted on the`'/'` prefix.
    Therefore CherryPy will use that tree of objects upon receiving a request for
    any path starting with`'/'`. Had we used a prefix such as `/postit`, the `Note`
    application would have only been served by CherryPy when getting a request starting
    with such a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: It is therefore possible to mount several applications via distinct prefixes.
    CherryPy will call the correct one based on the Request-URI. (As we will explain
    later in the book, two applications mounted via `cherrypy.tree.mount()` are unaware
    of each other. CherryPy makes sure that they don't leak.)
  prefs: []
  type: TYPE_NORMAL
- en: The following table displays the relationship between a Request-URI and the
    page handler matching the path of the URI as found by CherryPy.
  prefs: []
  type: TYPE_NORMAL
- en: '| Request-URI Path | Published Object | Page Handler |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | `note_app` | `index` |'
  prefs: []
  type: TYPE_TB
- en: '| `/author/` | `note_app.author` | `index` |'
  prefs: []
  type: TYPE_TB
- en: '| `/author/set` | `note_app.author` | `set` |'
  prefs: []
  type: TYPE_TB
- en: '| `/note/1` | `note_app` | `note` |'
  prefs: []
  type: TYPE_TB
- en: The `index()` and `default()` methods are special page handlers for CherryPy.
    The former one matches Request-URIs ending with a slash, similarly to the `index.html`
    file on the Apache server. The latter one is used by CherryPy when no explicit
    page handler is found for a Request-URI. Our `Note` application does not define
    one but the `default` page handler is often used to catch irregular URIs.
  prefs: []
  type: TYPE_NORMAL
- en: You can also notice that the `/note/1` URI, in fact, matches `note(id)`; this
    is because CherryPy supports positional parameters. The bottom line is that CherryPy
    will call the first page handler that has a signature matching the requested URI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CherryPy treats `/note/1` and `/note?id=1` the same way as long as it finds
    a page handler with the following signature: `note(id)`.'
  prefs: []
  type: TYPE_NORMAL
- en: The following figure is a global overview of the process followed by an HTTP
    request when reaching the CherryPy server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Object Publisher Engine](img/1848_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CherryPy comes with a set of modules covering common tasks when building a web
    application such as session management, static resource service, encoding handling,
    or basic caching.
  prefs: []
  type: TYPE_NORMAL
- en: The Autoreload Feature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CherryPy is a long-running Python process, meaning that if we modify a Python
    module of the application, it will not be propagated in the existing process.
    Since stopping and restarting the server manually can be a tedious task, the CherryPy
    team has included an autoreload module that restarts the process as soon as it
    detects a modification to a Python module imported by the application. This feature
    is handled via configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: If you need the autoreload module to be enabled while in production you will
    set it up as below. Note the `engine.autoreload_frequency` option that sets the
    number of seconds the autoreloader engine has to wait before checking for new
    changes. It defaults to one second if not present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Autoreload is not properly a module but we mention it here as it is a common
    feature offered by the library.
  prefs: []
  type: TYPE_NORMAL
- en: The Caching Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Caching is an important side of any web application as it reduces the load and
    stress of the different servers in action—HTTP, application, and database servers.
    In spite of being highly correlated to the application itself, generic caching
    tools such as the ones provided by this module can help in achieving decent improvements
    in your application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: The CherryPy caching module works at the HTTP server level in the sense that
    it will cache the generated output to be sent to the user agent and will retrieve
    a cached resource based on a predefined key, which defaults to the complete URL
    leading to that resource. The cache is held in the server memory and is therefore
    lost when stopping it. Note that you can also pass your own caching class to handle
    the underlying process differently while keeping the same high-level interface.
  prefs: []
  type: TYPE_NORMAL
- en: The Coverage Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When building an application it is often beneficial to understand the path taken
    by the application based on the input it processes. This helps to determine potential
    bottlenecks and also see if the application runs as expected. The coverage module
    provided by CherryPy does this and provides a friendly browseable output showing
    the lines of code executed during the run. The module is one of the few that rely
    on a third-party package to run.
  prefs: []
  type: TYPE_NORMAL
- en: The Encoding/Decoding Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Publishing over the Web means dealing with the multitude of existing character
    encoding. To one extreme you may only publish your own content using US-ASCII
    without asking for readers' feedback and to the other extreme you may release
    an application such as bulletin board that will handle any kind of charset. To
    help in this task CherryPy provides an encoding/decoding module that filters the
    input and output content based on server or user-agent settings.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module offers a set of classes and functions to handle HTTP headers and
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to parse the HTTP request line and query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Httpauth Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module provides an implementation of the basic and digest authentication
    algorithm as defined in RFC 2617.
  prefs: []
  type: TYPE_NORMAL
- en: The Profiler Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module features an interface to conduct a performance check of the application.
  prefs: []
  type: TYPE_NORMAL
- en: The Sessions Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Web is built on top of a stateless protocol, HTTP, which means that requests
    are independent of each other. In spite of that, a user can navigate an e-commerce
    website with the impression that the application more or less follows the way
    he or she would call the store to pass an order. The session mechanism was therefore
    brought to the Web to allow servers to keep track of users' information.
  prefs: []
  type: TYPE_NORMAL
- en: 'CherryPy''s session module offers a straightforward interface to the application
    developer to store, retrieve, amend, and delete chunks of data from a session
    object. CherryPy comes natively with three different back-end storages for session
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Back-end type | Advantages | Drawbacks |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RAM | EfficientAccepts any type of objectsNo configuration needed | Information
    lost when server is shutdownMemory consumption can grow fast |'
  prefs: []
  type: TYPE_TB
- en: '| File system | Persistence of the informationSimple setup | File system locking
    can be inefficientOnly serializable (via the pickle module) objects can be stored
    |'
  prefs: []
  type: TYPE_TB
- en: '| Relational database (PostgreSQL built-in support) | Persistence of the informationRobustScalableCan
    be load balanced | Only serializable objects can be storedSetup less straightforward
    |'
  prefs: []
  type: TYPE_TB
- en: The advantage is that your application will use a high-level interface independent
    of the underlying back end. Therefore, while in early development you may use
    RAM sessions, you can easily switch to the PostgreSQL back end if needed later
    on without modifying your application. Obviously CherryPy allows you to plug and
    use your own back end if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The Static Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even the most dynamic application serves static resources such as images or
    CSS. CherryPy provides a module to ease the process of serving those or to even
    serve a complete directory structure. It will handle the underlying HTTP exchanges
    such as the use of the `If-Modified-Since` header, which checks if a resource
    has changed since a given date thus avoiding processing it again unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: The Tidy Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even though as a web application developer you should make sure the content
    generated by your application is clean and valid against standards it may happen
    that you have to serve content over which you do not have full control. In such
    a case CherryPy provides an easy way to filter the outgoing content by using tools
    such as `nsgml` or `tidy`.
  prefs: []
  type: TYPE_NORMAL
- en: The Wsgiapp Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module allows you to wrap any WSGI application to use as a CherryPy application.
    For more information on WSGI, please refer to[Chapter 4](ch04.html "Chapter 4. CherryPy
    in Depth").
  prefs: []
  type: TYPE_NORMAL
- en: The XML-RPC Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XML-RPC is a remote procedure call protocol using XML to format messages, transferred
    via HTTP, between an XML-RPC client and XML-RPC server. Basically, a client creates
    an XML document containing the name of the remote method to call and the values
    to be passed and then requests the server using an HTTP POST message. The returned
    HTTP response contains the XML document, as a string, to be processed by the client.
  prefs: []
  type: TYPE_NORMAL
- en: The CherryPy xmlrpc module allows you to transform a published object into an
    XML-RPC service. CherryPy will extract, from the incoming XML document, the name
    of the method as well as the values and will apply the same logic as if it was
    a regular URI call, therefore looking for a matching page handler. Then when the
    page handler returns CherryPy wraps the content into a valid XML-RPC response
    and sends it back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The following code sample defines an XML-RPC service served by CherryPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Your XML-RPC client could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections we have introduced the built-in modules. CherryPy provides
    a **unified interface**, referred as the **tool** interface, to call those modules
    or build and call your own modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools can be set up from three different contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration file or dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Attached to a particular page handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not uncommon to decide to add extra processing to an object path matching
    a URI. In that case you might want to use a Python decorator around the page handler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Making a library call with a higher-level interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools can be applied as regular Python callable objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous line shows how to call the `accept` tool that looks up the provided
    media type within the requested `Accept HTTP` header.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to that unified interface it is possible to modify the underlying code
    of the tool without having to modify the application level itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A tool is an interface to extend CherryPy by plugging third-party components
    into the CherryPy engine.
  prefs: []
  type: TYPE_NORMAL
- en: Error and Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CherryPy tries hard to help the developer see a web application as close as
    a rich application. This means that from your page handler you may raise a Python
    error or exception as in any other Python application. CherryPy will catch those
    and transform them into HTTP messages depending on the type of errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that when an exception is raised and not caught by any other part of the
    application, CherryPy will return the corresponding HTTP 500 error code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following example will show the default behavior of CherryPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Error and Exception Handling](img/1848_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see CherryPy displays the complete traceback of the Python error.
    Although this is useful when developing the application, it might not be relevant
    in production mode. In that case, CherryPy returns simply a default message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Error and Exception Handling](img/1848_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In development mode you can hide the tracebacks on error by using the `request.show_tracebacks`
    key in the `global` section of the configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: CherryPy returns an HTTP error code 500 when it catches an error that is not
    handled otherwise by the application developer. The HTTP specification defines
    two sets of error codes, client errors in the 4xx range and server errors in the
    5xx range. The client errors indicate that the user agent has sent an invalid
    request (e.g. missing authentication credentials, requested resource not found
    or gone, etc.). The server errors inform the user agent that an event occurred
    that prevented the server fulfilling the request processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'CherryPy provides a simple interface allowing the application developer to
    send the correct error code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `HTTPError` error will be trapped by the CherryPy engine, which will in
    turn use the error code and error message of the error as the status and body
    of the HTTP response to be sent.
  prefs: []
  type: TYPE_NORMAL
- en: When raising that error, CherryPy sets the HTTP response body to the provided
    message and the HTTP header matching the error code defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned HTTP response will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Error and Exception Handling](img/1848_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Error and Exception Handling](img/1848_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You might wonder how to change the layout of the error page returned by CherryPy
    to integrate it with your own application. The way to achieve this is by using
    the configuration system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `notfound.html` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Error and Exception Handling](img/1848_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When catching an `HTTPError` error CherryPy looks for an `error_page.xxx` (where
    `xxx` is the HTTP error code used) entry in the configuration for that page handler
    and uses it instead of the default template.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see CherryPy offers a very flexible and yet effective way to use
    your own page template for displaying friendlier error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Until now we have discussed the high-level handling of errors in CherryPy. However,
    it is possible to modify the internal processing used through the hook API as
    we will see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter should have introduced you to some of the core principles of CherryPy,
    HTTP, and the server engine as well as its configuration system. We have also
    briefly discussed the object publisher engine, which allows transparent mapping
    of a URI to an exposed Python object. Finally we briefly reviewed the core modules
    of the CherryPy library that enhance its capacities and the way CherryPy lets
    you handle errors. The next chapter will dive into CherryPy's internal components
    and features as well go into more detail about some topics already covered.
  prefs: []
  type: TYPE_NORMAL
