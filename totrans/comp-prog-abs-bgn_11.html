<html><head></head><body>
		<div><h1 id="_idParaDest-126"><em class="italic"><a id="_idTextAnchor127"/>Chapter 9:</em> When Things Go Wrong – Bugs and Exceptions</h1>
			<p>Writing software can be hard, and when we write it, we will make errors. We will, unintentionally, introduce bugs to our application.</p>
			<p>Some of them will be rather trivial to find and fix, but some can set us off on a wild goose chase through the code where we try to understand the reasons as to why things are not working the way we expect them to.</p>
			<p>It is not unheard of that people spend days, and sometimes weeks, attempting to track down a bug. To be able to find bugs in our applications, we will need to understand what kinds exist and how they affect the way our applications run. This chapter will help us recognize them.</p>
			<p>In this chapter, you will learn about the following topics:</p>
			<ul>
				<li>Understanding software bugs</li>
				<li>Finding bugs using a debugger</li>
				<li>Working with exceptions</li>
				<li>Handling exceptions</li>
			</ul>
			<p>In this chapter, we will also talk a bit about variables and data types. Look back at <a href="B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a><em class="italic">, Working with Data – Variables</em>, if you need to refresh your memory about these.</p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor128"/>Understanding software bugs</h1>
			<p>When writing software, things will not always go according to plan. The programs we create will contain bugs. </p>
			<p>The term <em class="italic">bug</em> to describe an error, flaw, or fault in a program dates way long before we had any computers. It has been <a id="_idIndexMarker494"/>recorded as a part of engineering jargon since the 1870s. In a letter, dated 1878, to an associate, Thomas Edison wrote the following:</p>
			<p class="author-quote">"It has been just so in all of my inventions. The first step is an intuition, and comes with a burst, then difficulties arise—this thing gives out and [it is] then that "Bugs"—as such, little faults and difficulties are called—show themselves and months of intense watching, study, and labor are requisite before commercial success or failure is certainly reached."</p>
			<p>The first mechanical pinball game, Baffle Ball, was advertised as being <em class="italic">free from bugs</em> in 1931, and in 1944, Isaac Asimov used the term <em class="italic">bug</em> to describe issues with a robot in the short story <strong class="bold">Catch That Rabbit</strong>.</p>
			<p>One story that <a id="_idIndexMarker495"/>has often been given tribute for being the origin of the term bug in software comes from Grace Hopper. In 1946, she joined the Harvard Faculty at the Computation Laboratory, where she continued her work on the Mark I and Mark II computers. </p>
			<p>The Mark II computer produced errors and, after some searching, the operators found that the cause was a moth trapped in a relay. The moth was carefully removed and taped to the logbook. Under the moth, the following was written:</p>
			<p class="author-quote">"First actual case of a bug being found."</p>
			<p>The date in the logbook was September 9 1947, and that was the first time we had the term <em class="italic">bug</em> used in computer science:</p>
			<div><div><img src="img/Figure_9.1_B15554.jpg" alt="Figure 9.1 – The moth found in the Mark II computer in 1947 – US Naval Historical Center Online Library Photograph (Public Domain [PD])"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – The moth found in the Mark II computer in 1947 – US Naval Historical Center Online Library Photograph (Public Domain [PD])</p>
			<p>The likelihood <a id="_idIndexMarker496"/>that an actual bug will make our programs produce the wrong output is almost nonexistent. It is much more likely that the source of the error is ourselves.</p>
			<p>There are many different types of bugs. To understand some of them, and to see what damage a bug can cause, we'll look at two incredibly expensive software bugs.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor129"/>NASA's Mars Climate Orbiter</h2>
			<p>This is one of the most famous bugs in the history of computing. The Mars Climate Orbiter was a space probe <a id="_idIndexMarker497"/>that was launched by NASA on December 11, 1998. Its mission was to study the Martian climate, atmosphere, and surface changes. On September 23, 1999, all communication with the spacecraft was lost. It is not known if it was destroyed in <a id="_idIndexMarker498"/>the Martian atmosphere or if it continued existing in space.</p>
			<p>On November 10, 1999, the Mars Climate Orbiter Mishap Investigation Board released a Phase I report. In it, it was made clear that the reason for the disaster was a bug in a piece of <a id="_idIndexMarker499"/>ground-based software provided by one of NASA's contractors. This software produced a result in the United States <a id="_idIndexMarker500"/>customary units (units used in the US, such as inch, foot, and mile) while the NASA software expected the input to be in SI units (the metric system).</p>
			<p>The cost of this mistake was estimated at 125 million US dollars.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor130"/>The Morris worm</h2>
			<p>In 1988, a Cornell University student named Robert Morris released a computer worm that was designed as a harmless experiment. It exploited some flaws in the Unix operating system's sendmail program that <a id="_idIndexMarker501"/>were spread from computer to computer. When a new computer was found, the program checked to see if this computer was already infected. Morris understood <a id="_idIndexMarker502"/>that this would be an easy way for system administrators to stop the spread and help the system identify if it was infected already. To compensate for this, Morris designed his worm so that it infected any computer that responded with a yes 1 out of 7 times. </p>
			<p>This was the big mistake that made the worm not only spread rapidly across the internet but also infect the same computers multiple times, disrupting the target machines. The Morris worm was the first known internet worm, and the cost of cleaning up the mess it created was an estimated 100 million US dollars. Morris was fined 10,000 US dollars but made a good career later; he is now a professor at the Massachusetts Institute of Technology. A disk with the source code of the worm is on display at the Computer History Museum in California.</p>
			<p>Both of these examples show us that even a small error can have enormous consequences. In the first example, one single programmer made an error that went unnoticed in the final product. The biggest problem here is not the error that was introduced but that no one saw it and stopped it before it was too late.</p>
			<p>As for the second example, here, we had a person who created something on his own. The nature of this program was that no one should know about the program. The problem here is that he had no organization behind him with other developers who could help him make a plan for how the program should work. It is extremely hard to think about all the consequences one decision will have if you are alone and don't have anyone else to discuss your ideas with. In the latter case, having other people around him would <a id="_idIndexMarker503"/>hopefully result in them telling him that the idea as a whole was bad and should never have been done in the first place.</p>
			<p>Here, we have <a id="_idIndexMarker504"/>seen two examples of what a bug is, but there are so many other kinds around. Due to this, the first thing we should do is attempt to define what a bug is.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor131"/>Defining a software bug</h2>
			<p>To understand <a id="_idIndexMarker505"/>what a software bug is, we can first look at Techopedia's definition:</p>
			<p><em class="italic">"A software bug is a problem causing a program to crash or produce invalid output. The problem is caused by insufficient or erroneous logic. A bug can be an error, mistake, defect, or fault, which may cause failure or deviation from expected results."</em></p>
			<p>As we can see from this definition, a bug is caused by software that is not functioning correctly. This can result in incorrect or unexpected results. We can understand this if, say, we provide a program with some well-defined data. Here, we expect a certain result back. If the result is not what we expect, the reason can either be that there is something wrong with the data we provided or there is something wrong with the program. Let's say we, for example, provide a calculator app with the following data:</p>
			<pre>3 + 4</pre>
			<p>Here, we will expect the following result:</p>
			<pre>7</pre>
			<p>If we get anything else, we can say that there is a bug in our application.</p>
			<p>The definition also says that a program can behave in unintended ways. This is when we expect a program to do one thing, but it turns out that it does something completely different. If we have a program that should turn down the thermostat in our home when it's reached a certain temperature, but it turns it up, then that would be a bug.</p>
			<p>Why do we have bugs in our software? There isn't a single answer to this. To understand this, we will need to define some different types of bugs.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor132"/>Understanding types of software bugs</h1>
			<p>There are <a id="_idIndexMarker506"/>many different ways we can classify bugs. Here, we will look at some common types, see what they are, and see what they can look like.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor133"/>Arithmetic errors</h2>
			<p>Arithmetic bugs, as the <a id="_idIndexMarker507"/>name suggests, have to do with arithmetic <a id="_idIndexMarker508"/>operations. There are a few things we should look out for, as outlined in the following sections.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor134"/>Division by zero</h2>
			<p>One such thing is division by zero. This is not only related to computers as we can also never perform a division where <a id="_idIndexMarker509"/>the divisor is zero. In mathematics, dividing by zero has no meaning, because if we do <img src="img/Formula_09_001.png" alt=""/>, we will get 3. If we multiply 3 and 2, we will get 6 back. But if we take <img src="img/Formula_09_002.png" alt=""/>, there is no number we can multiply by zero to get back to 6.</p>
			<p>This might seem simple enough, but sometimes, it happens anyway, especially when we are working with variables.</p>
			<p>Let's assume that we have two variables that get their value somewhere in our application, like this:</p>
			<pre>x = 3
y = 14</pre>
			<p>Later on in the program, we perform some calculations, maybe with some other variables, it might look like this:</p>
			<pre>y = y – current_temperature</pre>
			<p>If the <code>current_temperature</code> variable now has the same value as <code>y</code>, which is <code>14</code> in our case, we will store the result, <code>0</code>, back in <code>y</code>.</p>
			<p>If we then <a id="_idIndexMarker510"/>did something like this, our application will crash:</p>
			<pre>result = x / y</pre>
			<p>The reason for this is that we are dividing by zero. It might not be obvious that <code>y</code> is zero, so the problem is not easy to spot.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor135"/>Arithmetic overflow/underflow</h2>
			<p>In <a href="B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Data – Variables</em>, in the <em class="italic">Primitive data types</em> section, we talked about integer types and that they could have a fixed size. What that means is that some integer types have a <a id="_idIndexMarker511"/>predefined size that describes how much memory they will use. This also gives a variable of this type a maximum and minimum value. As long as we are <a id="_idIndexMarker512"/>storing values between the maximum and minimum value, there will be no problem, but what happens if we try to store a value that is larger or smaller <a id="_idIndexMarker513"/>than these values? Let's look at an example.</p>
			<p>We will now assume that we are using a programming language that has a data type called byte. This data type <a id="_idIndexMarker514"/>can store values between -128 and 127.</p>
			<p>We can create a variable of this type and assign it a value as follows:</p>
			<pre>my_byte = 127</pre>
			<p>Now, what would happen if we increased this variable by one?</p>
			<pre>my_byte = my_byte + 1</pre>
			<p>Naturally, we expect 127 + 1 will result in 128. To our surprise, it is -128.</p>
			<p>The reason for this is that when we are at the maximum value a data type can handle and increase it by one, we will end up at the smallest number it can handle; in this case, -128. If we had increased it by 2 instead of 1, we would have ended up with -127.</p>
			<p>This is an overflow error. If we were at the lowest value the data type can handle and decrease the value by one, we would go to the largest value of this data type. This is called an underflow error.</p>
			<h3>Loss of precision</h3>
			<p>As we mentioned in <a href="B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Data – Variables,</em> floating-point numbers are something <a id="_idIndexMarker515"/>that is tricky for computers to work with, and we are always faced with the risk of losing precision when it comes to rounding off a value.</p>
			<p>In some languages, this can become obvious.</p>
			<p>Let's assume we have this code:</p>
			<pre>x = 1.3
y = 1.1
print x + y</pre>
			<p>The expected output of this program would, of course, be this:</p>
			<pre>2.4</pre>
			<p>To our surprise, some languages will instead give us this:</p>
			<pre>2.4000000000000004</pre>
			<p>This is the computer showing the problems it has with floating-point numbers. If you need a refresher on how this works, go back to <a href="B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>, <em class="italic">Working with Data – Variables</em>, and read the section about floating-point numbers under the <em class="italic">Numeric type</em> heading.</p>
			<p>We could argue that an error of 0.0000000000000004 is not much, but what if we were working with several of these results and added them together? This error would now accumulate and soon, we will have a value that is way off. </p>
			<p>These three are the most common arithmetic errors we will find in software. The next group of errors are not as fun for us programmers as they are introduced when our logic is incorrect.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor136"/>Logical errors</h2>
			<p>A logical error will <a id="_idIndexMarker516"/>usually not make a program crash but produce an unintended result. Unfortunately for us, there <a id="_idIndexMarker517"/>are a lot of opportunities to make logical errors. </p>
			<p>We could, for example, accidentally use the wrong operator. An example would be if we wanted to check if somebody's age was above 18, but we did this:</p>
			<pre>if age &lt; 18 then
   …
end_if</pre>
			<p>Another common thing is to forget to use less than or equal to or greater than or equal to. Here, we could write something like this:</p>
			<pre>if age &gt; 18 then
   …
end_if</pre>
			<p>This is incorrect <a id="_idIndexMarker518"/>as we actually wanted to check if the age was greater or equal to 18, like this:</p>
			<pre>if age &gt;= 18 then
   …
end_if</pre>
			<p>Another common <a id="_idIndexMarker519"/>error is to use one equals sign instead of two. Some languages will let us do something like this:</p>
			<pre>if age = 20 then
   …
end_if</pre>
			<p>Here, we intended to use the equal to operator, ==, but instead, we used the assignment operator, =. Some languages will interpret this as assigning value to age. This will give us two problems. First, we might enter the <code>if</code> statement, even if, in reality, we shouldn't. The other problem is that the value that was in the <code>age</code> variable now will be overwritten by the value <code>20</code>.</p>
			<p>One thing that has always amazed me is how hard it can be to get the logical operators right. Even though they are only two, it is very common that we use one instead of the other. Yes, even I do that at times.</p>
			<p>If we intend <a id="_idIndexMarker520"/>to check if the age is above <code>12</code> and below <code>20</code>, we might write this:</p>
			<pre>if age &gt; 12 or age &lt; 20 then
   …
end_if</pre>
			<p>However, what we <a id="_idIndexMarker521"/>wanted to do was this:</p>
			<pre>if age &gt; 12 and age &lt; 20 then
   …
end_if</pre>
			<p>The first example will always be true, as age will always be either greater than <code>12</code> or less than <code>20</code>.</p>
			<p>These are just some examples of logical errors. They can be hard to find as the code is valid, meaning that the program will run, but its behavior will be unexpected. </p>
			<p>An easier group of errors to amend is when the code is written so it can't run because we are breaking the language syntax rules. Let's take a look at these in more detail.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor137"/>Syntax errors</h2>
			<p>The rules that tell us how code should be written in a particular language are called its syntax. When we write code <a id="_idIndexMarker522"/>that does not follow the syntax rules, we get what is called a syntax error.</p>
			<p>These are rather easy to spot compared to many other errors as the compiler or interpreter will tell us where the <a id="_idIndexMarker523"/>problem is and also give us a hint about what the error is.</p>
			<p>Let's look at some syntax errors and investigate what message we get back that can assist us in fixing the error.</p>
			<p>Here is one syntax error. Can you spot it?</p>
			<pre>print "Hello</pre>
			<p>Here, we are trying to print a string, but we forgot the closing quote. Languages will report this error differently. As we will see, the message we get back does not always direct us to the real error.</p>
			<p>Here are four examples from four different programming languages – Python, Go, C#, and JavaScript, respectively:</p>
			<pre>SyntaxError: EOL while scanning string literal in line 1 column 12
1:12 syntax error: unexpected newline
Compilation error (line 1, col 12): Newline in constant
error: unknown: Unterminated string constant (1:12)</pre>
			<p>The second and third are talking about newline, while the first and last ones are talking about strings. We will need to learn the messages we get back from the language we are using. All of them will also direct us to where the error was discovered. In different formats, we are directed to line 1, column 12. </p>
			<p>The location that's given is not always where the actual error is, it is where the compiler/interpreter discovered the error. If you don't find anything at the location given, look at the line above or sometimes <a id="_idIndexMarker524"/>some lines above this location.</p>
			<p>We know from <a id="_idIndexMarker525"/>earlier chapters that we cannot name variables with a number as its first character. Let's do that anyway and do something like this:</p>
			<pre>1apple = 1</pre>
			<p>This will give us messages like the following:</p>
			<pre>SyntaxError: invalid syntax in line 1 column 2
1:2 syntax error: unexpected apple at end of statement
Compilation error (line 1, col 2): Identifier expected
error: unknown: Identifier directly after number (1:2)</pre>
			<p>As we can see, some languages call these errors syntax errors, while others will name them things such as compilation errors. Again, we will need to learn what the language we are using is calling these errors as it will help us identify them.</p>
			<p>Often, our editor will assist us in finding syntax errors by marking them even before we run the application. It uses the same technique as a spellchecker in a MS Word processor – a wiggly red line below the error. </p>
			<p>Look at the <a id="_idIndexMarker526"/>following screenshot. Here, we can see that the editor had marked a syntax error before we tried to run the program:</p>
			<div><div><img src="img/Figure_9.2_B15554_Swiggly_line.jpg" alt="Figure 9.2 –  An editor showing a syntax error in the programming language Python"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 –  An editor showing a syntax error in the programming language Python</p>
			<p>Syntax errors are, as mentioned previously, rather easy to find as the program will not run and we will be directed <a id="_idIndexMarker527"/>to a location close to where the error is. But how do we find bugs when we have logical errors? We have tools for this called debuggers.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor138"/>Finding bugs using a debugger</h1>
			<p>A debugger is a <a id="_idIndexMarker528"/>tool that can help us see what happens when a <a id="_idIndexMarker529"/>program is running. As we have already mentioned, some bugs can be hard to find and understand just by running the program. Often, we will discover a strange behavior in the program, but it might not be obvious what the reason behind this behavior is.</p>
			<p>A debugger is an application that is tailored for a particular programming language and can be used to pause the application at a specified code line. At this point, we can inspect what values all the variables have. </p>
			<p>We can also resume the execution of the program or execute it one line at a time to see what happens.</p>
			<p>Let's try using a debugger. To do this, we first need to pick a language and then write a small program that contains a logical error. We can take one of the errors that we previously looked at:</p>
			<pre>if age &gt; 12 or age &lt; 20 then
   …
end_if</pre>
			<p>Remember that in this example, we accidentally used <code>or</code> instead of <code>and</code>.</p>
			<p>Let's write this program in Python. In the following screenshot, we can see what it looks like:</p>
			<div><div><img src="img/Figure_9.3_B15554.jpg" alt="Figure 9.3 – A small program written in Python that contains a logical error"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – A small program written in Python that contains a logical error</p>
			<p>On the <a id="_idIndexMarker530"/>first line, we declare (remember that declaring a variable means that we are creating it) a variable called <code>age</code> and assign the value <code>17</code> to it.</p>
			<p>Then comes our <code>if</code> statement, where we're checking if the age is greater than <code>12</code> or less than <code>20</code>. The error here is that we used <code>or</code>.</p>
			<p>When <a id="_idIndexMarker531"/>running this program, we get the expected output:</p>
			<pre>You are a teenager.</pre>
			<p>If we now change the program, that is, we assign another value to age, say <code>24</code>, and run it, it will not give us the predicted result:</p>
			<pre>You are a teenager.</pre>
			<p>You can see the changed program in the following screenshot:</p>
			<div><div><img src="img/Figure_9.4_B15554.jpg" alt="Figure 9.4 – The same program with another value for age"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – The same program with another value for age</p>
			<p>Now, let's <a id="_idIndexMarker532"/>use a debugger and explore this error. The first thing we <a id="_idIndexMarker533"/>need to do is set a breakpoint.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor139"/>Breakpoints</h2>
			<p>A breakpoint is <a id="_idIndexMarker534"/>a way for us to say, run the program to this point, then pause <a id="_idIndexMarker535"/>it and show me the status of the program.</p>
			<p>In the following screenshot, we can see that we have a breakpoint on the line containing an <code>if</code> statement:</p>
			<div><div><img src="img/Figure_9.5_B15554.jpg" alt="Figure 9.5 –  A program with a breakpoint on line 3"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 –  A program with a breakpoint on line 3</p>
			<p>If we now run the program, it will stop when it reaches this line. At this point, the line that contains the breakpoint has still not executed. It will look like what's shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.6_B15554.jpg" alt="Figure 9.6 – The debugger has stopped at the breakpoint"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – The debugger has stopped at the breakpoint</p>
			<p>The line we <a id="_idIndexMarker536"/>are about to execute is marked with a blue line. Also, note that this debugger is showing the <code>age</code> value in gray on line 1. This helps us understand <a id="_idIndexMarker537"/>what value it currently has.</p>
			<p>If we zoom out a bit, we will see that we have some other tools that have popped up as the program paused at this line. We can see what it looks like in the following screenshot:</p>
			<div><div><img src="img/Figure_9.7_B15554.jpg" alt="Figure 9.7 – The debugger tools"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – The debugger tools</p>
			<p>What we <a id="_idIndexMarker538"/>see here there are several tools that are provided to us by <a id="_idIndexMarker539"/>the debugger application. Let's understand what they consist of:</p>
			<ul>
				<li>To the right, we see a section marked <strong class="bold">Variables</strong>. Here, we can see all the variables that are currently defined and what values they have.</li>
				<li>Above this window, we can see some arrows pointing in different directions. They are used to advance the program one step. We have some options here. The first one is the arrow that first goes up and then goes down (marked as <strong class="bold">1</strong> in the preceding screenshot). This is called step over. If we have a function call on this line, step over will not jump to that function. Instead, it will call that function, run all the code within it, and then stop again when it returns to where we currently are.</li>
				<li>The next arrow, the one pointing straight down, is step into (marked as <strong class="bold">2</strong>). This will, if we have a function on this line, jump to that function and let us step through it.</li>
				<li>We can ignore the two arrows that follow and instead look at the one pointing straight up (marked as <strong class="bold">3</strong>). This one is called step out. We can use this one if we have stepped into a function and changed our minds.  It will run all the code in the function and stop again when we go back to the location we came from.</li>
				<li>To the far left, we have some other tools that will restart the program (marked as <strong class="bold">4</strong>), resume the execution of the program (marked as <strong class="bold">5</strong>), pause a running program (marked as <strong class="bold">6</strong>), stop the program (marked as <strong class="bold">7</strong>), allow us to view all the breakpoints we currently have in the program (marked as <strong class="bold">8</strong>), and ignore all the breakpoints and continue to run (marked as <strong class="bold">9</strong>).</li>
			</ul>
			<p>For our problem, none of these tools will be able to help us. We know that the program will enter the <code>if</code> statement as the output was as follows:</p>
			<pre>You are a teenager.</pre>
			<p>Instead, there is another tool that might help us. In the following screenshot, we can see it marked with a rectangle:</p>
			<div><div><img src="img/Figure_9.8_B15554.jpg" alt="Figure 9.8 – The evaluate expression button"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – The evaluate expression button</p>
			<p>This tool, which <a id="_idIndexMarker540"/>looks like a small calculator, is the evaluate expression tool. If <a id="_idIndexMarker541"/>we click it, we will see a window like the one shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.9_B15554.jpg" alt="Figure 9.9 – The evaluate expression window"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – The evaluate expression window</p>
			<p>In the top field, we can <a id="_idIndexMarker542"/>enter an expression. This can help us <a id="_idIndexMarker543"/>understand what is happening. We are currently on this line:</p>
			<pre>if age &gt; 12 or age &lt; 20:</pre>
			<p>If we enter a part of this expression into the evaluation expression tool, it will show us the result. Let's take the first part of this <code>if</code> statement. Entering it into the tool will look as follows:</p>
			<div><div><img src="img/Figure_9.10_B15554.jpg" alt="Figure 9.10 – Evaluating an expression"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – Evaluating an expression</p>
			<p>Here, we can see <a id="_idIndexMarker544"/>that this part of the <code>if</code> statement is true.</p>
			<p>If we now <a id="_idIndexMarker545"/>do the same with the second part, we will see that the result is false, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.11_B15554.jpg" alt="Figure 9.11 – Evaluating another expression"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – Evaluating another expression</p>
			<p>We can now take both of these statements, since we have written them in the code, and check the result, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_9.12_B15554.jpg" alt="Figure 9.12 – Evaluating the full expression"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Evaluating the full expression</p>
			<p>Here, we can see that the result of the full expression is true, even though the value is greater than the last part of the condition, <code>20</code>.</p>
			<p>We can now suspect that the culprit is <code>or</code>. Let's change it to an <code>and</code> and see the result.</p>
			<p>In the following screenshot, we can see that the result is now evaluated to <code>false</code>, which is the value we expected:</p>
			<div><div><img src="img/Figure_9.13_B15554.jpg" alt="Figure 9.13 – Evaluating the expression with and instead of or"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – Evaluating the expression with and instead of or</p>
			<p>We can now <a id="_idIndexMarker546"/>stop the debugger and change our code.</p>
			<p>This was one <a id="_idIndexMarker547"/>example of when the debugger can help us understand a problem. We will frequently run into errors like this one, and what the problem is might not be obvious to us right away. As a programmer, we should learn to use the debugger, what features it has to offer, and how we can use it. </p>
			<p>Sometimes, we have other types of errors where the syntax is correct, but still, the program will crash. These are called exceptions. We will move on to those next.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor140"/>Working with exceptions</h2>
			<p>An <strong class="bold">exception</strong> (short for <strong class="bold">exceptional event</strong> or <strong class="bold">exceptional condition</strong>) is an error or <a id="_idIndexMarker548"/>an unexpected <a id="_idIndexMarker549"/>event <a id="_idIndexMarker550"/>that occurs while a program is running. It is caused by a condition in the software where the program has reached a state where it can no longer run.</p>
			<p>There are many <a id="_idIndexMarker551"/>reasons we can get an exception. One example could be if our program needs to read data from a file, but the file is not where it is supposed to be. Since the program has <a id="_idIndexMarker552"/>a reason to read the data from this file, a failure to do so will put the application in a state where it can no longer guarantee that its output will be correct. The best option, in this case, is just to halt the program and give back an error that hopefully instructs us about what the problem is so we can fix it.</p>
			<p>No software developer wants to write an application that crashes. It can make the users of the application lose unsaved work, though the consequences might be even worse, depending on the nature of the program.</p>
			<p>Soon, we will talk about how we can handle exceptions so that they don't crash our program. But before we do that, let's explore exceptions a bit so that we have an understanding of how they work.</p>
			<p>Let's look at some common reasons we get exceptions.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor141"/>Common reasons for exceptions</h2>
			<p>As we saw, a missing <a id="_idIndexMarker553"/>file can be one reason we get an exception. Another common <a id="_idIndexMarker554"/>reason is that when we are trying to index into a sequence, we use an index that is larger than the sequence. Let's take a look at an example:</p>
			<pre>names = ["Anna", "Bob", "Cara", "David"]</pre>
			<p>Here, we have an array (you can read more about array's in <a href="B15554_06_Final_NM_ePub.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a><em class="italic">, Working with Data – Variables</em>, in the <em class="italic">Composite type</em> section). It contains four values; in this case, four names. We can index into this array to retrieve a single value, as follows:</p>
			<pre>print names[2]</pre>
			<p>This will give us the following output:</p>
			<pre>Cara</pre>
			<p>Remember that the index value for the first item is 0, not 1, so the third item, <code>Cara</code>, has index 2.</p>
			<p>What will happen if we use an index value that is greater than the number of items we have, like this?</p>
			<pre>print names[6]</pre>
			<p>There is no value at this location, so the program cannot fetch it for us. The syntax is correct, and if we had enough values, it would work perfectly fine. But this time, it won't, as we have used an index for something that does not exist.</p>
			<p>The program cannot continue at this point as it cannot guess what it should do. We have given an instruction that says that we want a value from this location. The programming language cannot just come up with a value for us. The most sensible thing to do at this point is to just end the program and wait for it to give us an error. This error might look something like this:</p>
			<pre>IndexOutOfRangeException: Index was outside the bounds of the array at line 2.</pre>
			<p>This is an exception. We can see it in the output as it clearly says <code>IndexOutOfBoundException</code>.</p>
			<p>How much we use exceptions, and how many different exceptions we will need to deal with the different issues available, will differ greatly between languages. Some, such as Java, make heavy use of exceptions. C++, on the other hand, has just a handful of built-in exceptions. Then, we have languages such as Go that don't have exceptions at all, but instead will let a function return an error type alongside the real return value from the function.</p>
			<p>Some of the errors that we already have seen in this chapter will also generate exceptions. One such exception will happen if we divide something by zero.</p>
			<p>Most languages support exceptions. Even if the number of exceptions a programming language has differs, the way they work will be pretty much the same, no matter what language we are using. The names will differ, as well as what kinds of exceptions we have, but the way we work with them will be the same.</p>
			<p>At times, it can be <a id="_idIndexMarker555"/>hard to understand the output we get from an exception. The reason <a id="_idIndexMarker556"/>for this is that when we get an exception, something called the call stack is also printed. </p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor142"/>Exceptions and the call stack</h2>
			<p>Imagine that <a id="_idIndexMarker557"/>we have a program and that in it, we have a <code>main</code> function. This function is <a id="_idIndexMarker558"/>calling another function that calls another function, and so on. We will have something like the following:</p>
			<div><div><img src="img/Figure_9.14_B15554.jpg" alt="Figure 9.14 – A function that calls a function that calls a function, and so on"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – A function that calls a function that calls a function, and so on</p>
			<p>Keeping track of <a id="_idIndexMarker559"/>where we are in this chain of function calls is called the call stack, and that is handled by the programming language when we run the program.</p>
			<p>Now, imagine that <a id="_idIndexMarker560"/>we get an exception in the last function called <strong class="bold">function c</strong>. This function will now exit immediately and return to where it was called. That is <strong class="bold">function b</strong>. This function will also exit as soon as the control gets handed back to it, and we will be returned to where we came from. This time, it is <strong class="bold">function a</strong>. Again, this function will be terminated immediately, and we are returned to the <strong class="bold">main</strong> function. The last thing that will happen is that this function will also end. Since this was the first function that was called in this application, the application as a whole will end.</p>
			<p>The reason why all the functions will exit is that none of them handle the exception.</p>
			<p>Now, we will get not only the exception information printed to the screen but also the call stack. </p>
			<p>To illustrate this, let's use a very simple program like the following one:</p>
			<pre>function c()
    result = 10 / 0
end_function
function b()
    c()
end_function
function a()
    b()
end_function
function main()
    a()
end_function</pre>
			<p>This is a rather <a id="_idIndexMarker561"/>silly program, but it will illustrate what will happen. At <a id="_idIndexMarker562"/>the bottom, we have a function called <code>main</code>. The <code>main</code> function will be <a id="_idIndexMarker563"/>called automatically when we run this program.</p>
			<p>Inside the <code>main</code> function, we call <a id="_idIndexMarker564"/>the function named function <code>a</code>. This function will call <code>function b</code>, which calls <code>function c</code>.</p>
			<p>When we enter <code>function c</code>, <code>function b</code> is still running and is waiting for <code>function c</code> to finish. The same thing is true for <code>function a</code>, which waits for <code>function b</code>. The <code>main</code> function is waiting for <code>function a</code> to finish, so at this point, we have four active functions.</p>
			<p>Now, inside <code>function c</code>, we perform <a id="_idIndexMarker565"/>a division by zero, causing an exception to go off.</p>
			<p>At this point, <code>function c</code> will exit immediately. Control will be handed back to <code>function b</code>, which will exit, giving <a id="_idIndexMarker566"/>the control back to <code>function a</code>, which exits back to <code>main</code>, and finally, the program will exit.</p>
			<p>The output we'll get <a id="_idIndexMarker567"/>will look something like this:</p>
			<pre>Callstack
function c() at line 2
function b() at line 6
function a() at line 10
function main() at line 14
ZeroDivisionError: division by zero</pre>
			<p>As we can see, all the <a id="_idIndexMarker568"/>function calls are there. How this is displayed will <a id="_idIndexMarker569"/>differ from language to language. Some will print all the functions in the opposite order. Again, this is something we will need to learn when we pick up a new language.</p>
			<p>The reason we get all this information is that it can help us figure out where things went wrong. Even if the error occurred in <code>function c</code>, the reason it happened might originate somewhere else. Let's assume that the program looked as follows instead:</p>
			<pre>function c(x, y)
    result = x / y
end_function
function b()
    c(10, 0)
end_function
function a()
    b()
end_function
function main()
    a()
end_function</pre>
			<p>Now, <code>function c</code> takes <a id="_idIndexMarker570"/>two arguments, and it uses these to perform the calculation. This <a id="_idIndexMarker571"/>happens when <code>function c</code> is called from <code>function b</code>. The problem arises when we pass in <code>10</code> and <code>0</code> as arguments to the call.</p>
			<p>Since the data <a id="_idIndexMarker572"/>has its origins in <code>function b</code>, this is where the problem came from. <code>function c</code> does not know the origins of these two values. They might come from some user input, they might <a id="_idIndexMarker573"/>have been read from a file, or they may have come from any other source.</p>
			<p>To fully understand the origins of this problem, we will need the information that we get from the call stack as it tells us how we ended up in <code>function c</code> when the error occurred.</p>
			<p>But what if we don't want the program to crash? No problem. We can write code that will handle exceptions. Let's look at that next.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor143"/>Handling exceptions</h1>
			<p>To understand <a id="_idIndexMarker574"/>how we can handle exceptions, we must first understand what the origins of a problem might be. It is only when we have understood this that we can insert measures to handle them correctly.</p>
			<p>Let's return to our function that divides two values. Let's say this function takes two arguments, as it did in our previous example:</p>
			<pre>function c(x, y)
    result = x / y
end_function</pre>
			<p>We should assume that this function does something more than just print this single line. We can mark it out with some comments, as follows:</p>
			<pre>function c(x, y)
    // The function does some things ere
    result = x / y
    // And even more things here
    // It might even return a value
end_function</pre>
			<p>We know that as this function divides two values, we might get an exception if <code>y</code> is given a value of <code>0</code>.</p>
			<p>The first thing we <a id="_idIndexMarker575"/>should ask ourselves is if this is the best place to handle the problem. It could be, but most likely, it is not. This function is getting two values sent to it as arguments. Several parts of the application might use the function, so it has no way of knowing the source of the data that is being sent to it.</p>
			<p>What we can do, though, is check if <code>y</code> is equal to zero before we perform the division. Let's do that now. At the same time, we can change the function's name to <code>calculate</code> as it better reflects what the function does:</p>
			<pre>function calculate(x, y)
    if y == 0 then
	  // y is zero, so we cannot perform the division
    end_if
    // The function does some things ere
    result = x / y
    // And even more things here
    // It might even return a value
end_function</pre>
			<p>But what should we do if <code>y</code> is zero? We cannot continue running the function as we would then perform the division anyway. We cannot change <code>y</code> to something else either, because what would we even change it to?</p>
			<p>We need a way to signal to the caller of the function that we cannot accept a value of zero for <code>y</code>.</p>
			<p>One way to do this would be to let the exception happen and remove the <code>if</code> statement again. If we did that, the caller could handle the error. </p>
			<p>Let's see how we can handle an exception when we call a function. The call to the function would then need to be within a special block of code called a <code>try</code> statement. It could look something like this:</p>
			<pre>try
    calculate(10, 0)
catch ZeroDivisionError
   // We will end up here if we get a ZeroDivisionError    // exception
end_catch</pre>
			<p>Here, we can see that the call to the <code>calculate</code> function is located within a <code>try</code> block.</p>
			<p>If everything is fine and we return from the function without any exception, the program will jump to the line after <code>end_catch</code> and resume its execution.</p>
			<p>But if we get an exception and that exception is of the <code>ZeroDivisionError</code> type, we will end up in the block below, which begins with a <code>catch</code>. </p>
			<p>Exceptions can <a id="_idIndexMarker576"/>be caught, but we need to specify what exception it is we want to handle. If we get another exception, one that does not have a matching <code>catch</code>, the program will crash as before.</p>
			<p>Calling the function like this could be a solution for us, but is it a good solution? Not really. Imagine that the <code>calculate</code> function is located in a different module that is in a different file. It might even be written by somebody else. In this situation, how do we know that it will perform a division and that it will use the second value we pass to it as the divisor in that division? We will most likely not know anything about that, or we should at least assume that the users do not know anything about how the function is written.</p>
			<p>Therefore, we could not assume that they will use a <code>ZeroDivisionError</code> exception in their <code>catch</code> statement. Instead, we could give them another exception that might make more sense.</p>
			<p>Let's change our <code>calculate</code> function, as follows:</p>
			<pre>function calculate(x, y)
    if y == 0 then
	  throw ValueError("Second argument cannot be zero")
    end_if
    // The function does some things ere
    result = x / y
    // And even more things here
    // It might even return a value
end_function</pre>
			<p><code>throw</code> will create <a id="_idIndexMarker577"/>another exception; this time, one called <code>ValueError</code>. We are also passing a string to this exception. If someone now calls our function and gives us a value of zero for <code>y</code>, they will get this exception with the message we provided.</p>
			<p>When they call our function, they could now check for this exception instead:</p>
			<pre>try
    calculate(10, 0)
catch ValueError
   // We will end up here if we get a ValueError exception
end_catch</pre>
			<p>Since this is the location where the bad value for <code>y</code> originated, it is much more likely that this is where we can change it. If this, for example, was a value that was given to us by the user of the program, we could give a nice error message back, saying that they cannot enter a value of zero.</p>
			<p>We can say that this is the location that <em class="italic">owns</em> the data and therefore has the opportunity to change it.</p>
			<p>If we use <code>try…catch</code> blocks around calls to functions that can throw exceptions, the program will no longer crash. In this case, the <code>calculate</code> function will still exit as soon as we throw the <code>ValueError</code> exception, but since we are catching it right after the call to the function, we might be able to correct the problem and call the function again with a correct value.</p>
			<p>Exceptions are a <a id="_idIndexMarker578"/>great way to handle conditions when we can't decide what to do due to a condition that we could not predict when we wrote the program. Without them, it would be very difficult to signal to other parts of the program that something is wrong. We should use them when we need to, but also ensure proper care. Exceptions always send a clear message regarding what is wrong and assist the author of the code that receives the exception with understanding what the problem is.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor144"/>Summary</h1>
			<p>In this chapter, we realized that we, as humans, make mistakes, but we can go back and fix them as well.</p>
			<p>A software bug is an error in an application that can have several causes. Depending on what is behind the bug, we must approach it differently when trying to fix it.</p>
			<p>In some cases, as with syntax errors, we will be told what the cause of the bug is right away, and even be directed to the correct location in the code.</p>
			<p>Other bugs will be harder to find. When the programming language syntax is correct, but the logic is not, the program will behave in unexpected ways. To be able to find these bugs, we can use a tool called a debugger. It helps us track down the bugs by letting us pause the execution of the program and see all the values the variables have; it will even let us step through the execution one line at a time.</p>
			<p>An exceptional event is when things that should not happen still happen. In programming, they are referred to as exceptions. When they happen, they will immediately halt the execution of the program if they are not handled. Fortunately, we can handle them by inserting code that will only run if the exceptional event occurs so that we can try to fix the problem.</p>
			<p>In the next chapter, we will look at different ways to approach a problem and create a solution with code. This is called a paradigm. A programming language will use one of these. As we will see, some languages will use concepts from more than one paradigm.</p>
		</div>
	</body></html>