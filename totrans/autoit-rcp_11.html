<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Time in the Zone</h1></div></div></div><p>Time calculations are fun, interesting, and tedious at the same time. Fun, when you first learn to read time, interesting, when you learn about daylight saving and tedious, when a customer complains about not able to schedule meetings across time zones through your web application.</p><p>In this chapter, we will cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with time, date, and calendar</li><li class="listitem" style="list-style-type: disc">Comparing and combining dates, and date arithmetic</li><li class="listitem" style="list-style-type: disc">Formatting and parsing dates</li><li class="listitem" style="list-style-type: disc">Dealing with time zone calculations</li><li class="listitem" style="list-style-type: disc">Automating invoicing based on time zone</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec83"/>Introduction</h1></div></div></div><div><blockquote class="blockquote"><p>
<em>"If you love life, don't waste time, for time is what life is made up of."
                                                                                             --Bruce Lee.</em>
</p></blockquote></div><p>Time is the measure of all things. We have so many things to do in life, and yet the irony is we have so much less time on our hands. These days, we plan for time intuitively: what time should I travel at to avoid traffic, what's my deadline for this task among many other things, and so on. Businesses plan their activities for the complete year even before the calendar begins.</p><p>Time calculations are almost everywhere. Want to schedule a meeting with your colleague in Australia? Get the time zone right, work on a good time for you and your colleague, and then schedule it. Want to write code to perform a task for your customer when the time is right? Manage time objects in the database and keep track of all the tasks for your users. Even in the Hollywood movie, <em>National Treasure</em>, Nicholas Cage had to depend on time zone calculations to get to the next clue that took him closer to the treasure.</p><p>Essentially, you can't run away from time calculations wherever you are and whatever you do. In this chapter, we will work with <code class="literal">date</code> and <code class="literal">time</code> objects in Python. We will also learn how to perform arithmetic operations on dates and work with time zone calculations. We will also learn how to automate a business process based on users' time zone.</p><p>During the course of this chapter, we will majorly use built-in Python modules. The following built-in modules will be used in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">datetime</code> (<a class="ulink" href="https://docs.python.org/2/library/datetime.html">https://docs.python.org/2/library/datetime.html</a>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">calendar</code> (<a class="ulink" href="https://docs.python.org/2/library/calendar.html">https://docs.python.org/2/library/calendar.html</a>)</li></ul></div><p>We will also use this external module to work with time zones:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">pytz</code> (<a class="ulink" href="http://pytz.sourceforge.net/">http://pytz.sourceforge.net/</a>)</li></ul></div><p>The <code class="literal">pytz</code> library brings the Olson timezone database into Python. It allows accurate and cross-platform timezone calculations in Python 2. It also helps in performing calculations with respect to daylight savings.</p><p>Before we get into the recipes, let's check if we have the relevant modules in our Python installation and also install the ones we need in this chapter. We start by creating a virtual environment for this chapter and activating it:</p><pre class="programlisting">
<strong>chetans-MacBookPro:ch12 Chetan$ virtualenv date</strong>
<strong>New python executable in date/bin/python2.7</strong>
<strong>Also creating executable in date/bin/python</strong>
<strong>Installing setuptools, pip, wheel...done.</strong>
<strong>chetans-MacBookPro:ch12 Chetan$ source date/bin/activate</strong>
<strong>(date)chetans-MacBookPro:ch12 Chetan$ </strong>
</pre><p>Now, let's install the <code class="literal">pytz</code> module in our virtual environment using Python <code class="literal">pip</code>. Once we install the module, we will move ahead to the first recipe and start working with <code class="literal">time</code> and <code class="literal">date</code> objects:</p><pre class="programlisting">
<strong>(date)chetans-MacBookPro:ch12 Chetan$ pip install pytz</strong>
<strong>Collecting pytz</strong>
<strong>  Using cached pytz-2016.7-py2.py3-none-any.whl</strong>
<strong>Installing collected packages: pytz</strong>
<strong>Successfully installed pytz-2016.7 </strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec84"/>Working with time, date, and calendar</h1></div></div></div><p>In this recipe, we will use built in Python modules and we don't need to install anything explicitly. So let's get started.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec237"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Go to your favorite editor, create a file named <code class="literal">time_ex.py</code>, and write the following code in the Python file:<pre class="programlisting">        import datetime &#13;
        time_obj = datetime.time(13, 2, 23) &#13;
        print "Time object is:", time_obj &#13;
        print 'Hour  :', time_obj.hour &#13;
        print 'Minute:', time_obj.minute &#13;
        print 'Second:', time_obj.second &#13;
        print 'Microsecond:', time_obj.microsecond &#13;
</pre><p>If we run the preceding Python code, we will see the following output. Observe how we created a given time object using Python and retrieved the <em>hour, minute, second,</em> and <em>microsecond</em> details for the given time object:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_001.jpg"/></div><p>
</p></li><li class="listitem">Python's <code class="literal">Time</code> class has some more attributes that can be effectively used for time calculations. For instance, in the following code snippet, I can get the valid time range for a given day:<pre class="programlisting">        import datetime &#13;
        print "Time Attributes are:" &#13;
        print "Earliest time of the day :", datetime.time.min &#13;
        print "Latest time of the day :", datetime.time.max</pre><p>The output of the preceding code snippet can be seen in the following screenshot. Observe how we get the first and the last available time for the day:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_002.jpg"/></div><p>
</p></li><li class="listitem">Neat! Now, let's look at the <code class="literal">date</code> object. The following Python code gets today's date for you. We also retrieve the <code class="literal">year</code>, <code class="literal">month</code>, and <code class="literal">day</code> attributes with the following code:<pre class="programlisting">        import datetime &#13;
        today = datetime.date.today() &#13;
        print 'Date object:', today &#13;
        print 'Year:', today.year &#13;
        print 'Mon :', today.month &#13;
        print 'Day :', today.day</pre><p>The output of the preceding code snippet is shown in the following screenshot:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_003.jpg"/></div><p>
</p></li><li class="listitem">Ok, cool! We can also create a new <code class="literal">date</code> object or modify an existing one with Python's <code class="literal">date()</code> and <code class="literal">replace()</code> methods. The following code demonstrates how to use these methods:<pre class="programlisting">        import datetime &#13;
        date_1 = datetime.date(2011, 12, 31) &#13;
        print '  Date is:', date_1 &#13;
        date_2 = date_1.replace(year=2012, month=1) &#13;
        print '  New Date is:', date_2</pre><p>The output of the preceding snippet is as follows:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_004.jpg"/></div><p>
</p></li><li class="listitem">Fantastic! Let's move ahead and see if we can work with months or even years. With Python, it's very easy to work with the whole calendar. The following code prints out the calendar for the complete year on the console. In this case, it returns the calendar for the year 2017. Let me check my birthday... oh it's on Tuesday this year and I have to go to the office:<pre class="programlisting">        import calendar &#13;
        from calendar import TextCalendar &#13;
        cal = TextCalendar() &#13;
        cal.pryear(2017) &#13;
        cal.prmonth(2017, 11)</pre><p>The output of the preceding code snippet is shown in the following screenshot. The first screenshot returns the complete calendar for the year 2017:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_005.jpg"/></div><p>
</p><p>The following screenshot only returns the calendar for the eleventh month of 2017, that is, November 2017:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_006.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec238"/>How it works...</h2></div></div></div><p>In this recipe, we started working with <code class="literal">time</code> objects. We created a <code class="literal">time</code> object with the <code class="literal">datetime.time()</code> method that takes hour, minute, and second as input parameters. We also read the time object with <code class="literal">hour</code>, <code class="literal">minute</code>, and <code class="literal">second</code> attributes, and got the earliest and latest times of the day with <code class="literal">datetime.time.min</code> and <code class="literal">datetime.time.max</code> attributes.</p><p>Next, we moved onto working with dates using the <code class="literal">datetime.date()</code> method. We got today's date with the <code class="literal">datetime.date()</code> method and printed the year, month, and day for today with the <code class="literal">today.year</code>, <code class="literal">today.month</code>, and <code class="literal">today.day</code> attributes.</p><p>We also created a new date with the <code class="literal">datetime.date()</code> method by passing the <code class="literal">year</code>, <code class="literal">month</code>, and <code class="literal">day</code> as parameters. Once the <code class="literal">date</code> object was available, we used it to get the new date with the <code class="literal">replace()</code> method. We passed <code class="literal">year</code> and <code class="literal">month</code> as parameters to the <code class="literal">replace()</code> method to create the new <code class="literal">date</code> object.</p><p>We also worked with the <code class="literal">calendar</code> object in this section. We used the <code class="literal">calendar</code> module available in Python installation for this purpose. First, we instantiated the <code class="literal">TextCalendar</code> class to create a text calendar object. Later, we used this object to print the calendar for the year 2017 on the console with <code class="literal">pryear()</code> method.</p><p>We could also show the calendar for just the month of November for the year, 2017, using the <code class="literal">prmonth()</code> method. Nice!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec85"/>Comparing and combining the date and time objects, and date arithmetic</h1></div></div></div><p>Creating <code class="literal">date</code> objects and using them is great, but the tasks we need to perform for business use cases are often related to comparing or calculating differences in the date and time objects. In this recipe, we will learn how to perform these operations in Python. It is, however, important to note a major change that we will see in this recipe. In the last recipe, we worked with the time and date objects independently. But Python's <code class="literal">datetime</code> module provides a great benefit, in the sense that we get to work on objects that include both date and time attributes. You will see this difference in the How to do it section.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec239"/>Getting ready</h2></div></div></div><p>In this recipe, we will work with the <code class="literal">datetime</code> Python module that we used for the last couple of examples. We don't have any new installations to be done for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec240"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's start by getting the difference between two datetime objects. The following code does this operation and calculates the difference between two <code class="literal">datetime</code> objects. Though this operation only tells you the difference in seconds, you can also use these to get the difference in months or years. In the following screenshot, notice how <code class="literal">datetime.now()</code> returns a string with both today's date and the current time. It is important to understand that we are working on an object that comprises the date and time attributes. If you think about it, in the actual world also, when we have to calculate the time difference between two events, working on the date and time objects together will be the most useful to us. Even if we independently work on the date object or the time object, we will end up performing the same calculation that we will perform with the datetime object, so imagine the benefits we get with this approach:<pre class="programlisting">        from datetime import datetime &#13;
        import time &#13;
        now_1 = datetime.now() &#13;
        print "  Time Now", now_1 &#13;
        time.sleep(5) &#13;
        now_2 = datetime.now() &#13;
        print "  Time Now", now_2 &#13;
        print "  Difference in the times is:", (now_2 - now_1).seconds &#13;
</pre><p>The output of the preceding code snippet is shown in the following screenshot. See how we get the difference between the datetime objects in seconds:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_007.jpg"/></div><p>
</p></li><li class="listitem">This is fine, but you may ask what happens if the difference in the <code class="literal">datetime</code> objects is negative. In this example, if we calculate <code class="literal">now_1 - now_2</code>, we get a high number and not the actual difference. For this, we have a nice trick to get the difference between two <code class="literal">datetime</code> objects. We can use <code class="literal">(now_1 - now_2).total_seconds()</code> to get the negative value, that is, <code class="literal">-5</code> seconds.</li><li class="listitem">OK, now let's move forward to perform more calculations on the <code class="literal">datetime</code> objects. For instance, how about getting the time from the past or into the future? The following code helps us perform these operations; see how we got the date and time at this moment and also could return the date and time for the next day, that is, tomorrow:<pre class="programlisting">        from datetime import datetime, timedelta &#13;
        now = datetime.now() &#13;
        print "  Time Now is:", now &#13;
        one_day_later = now + timedelta(days=1) &#13;
        print "  Tomorrow is:", one_day_later</pre><p>The output of the preceding code is as follows:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_008.jpg"/></div><p>
</p></li><li class="listitem">If we want to get the time in the past, we could do it in the same way as shown in the following code snippet:<pre class="programlisting">        from datetime import datetime, timedelta &#13;
        now = datetime.now() &#13;
        print "  Time Now is:", now &#13;
        days_in_past = now - timedelta(days=365, hours=1) &#13;
        print "  Last year:", days_in_past</pre><p>The output of the preceding code is shown in the following screenshot. Note that we asked for a past date, which is 365 days back. However, it shows November 28, 2015. Why? Shouldn't it show the same day? Oh, of course, 2016 was a leap year!</p><p>
</p><div><img alt="How to do it..." src="img/image_12_009.jpg"/></div><p>
</p></li><li class="listitem">OK, now we're comfortable working with getting the difference or adding time to <code class="literal">date</code> and <code class="literal">time</code> objects. But we also often need to compare between times, right? Let's learn this with the help of a code snippet. The following Python code compares <code class="literal">time</code> and <code class="literal">date</code> objects separately:<pre class="programlisting">        import datetime &#13;
 &#13;
        time_1 = datetime.time(8, 9, 10) &#13;
        print "  Time 1:", time_1 &#13;
        time_2 = datetime.time(13, 19, 50) &#13;
        print "  Time 2:", time_2 &#13;
        print "  Comparing times: time_2 &gt; time_1?", time_2 &gt; time_1 &#13;
 &#13;
        date_1 = datetime.date.today() &#13;
        print "  Date 1:", date_1 &#13;
        date_2 = date_1 + datetime.timedelta(days=2) &#13;
        print "  Date 2:", date_2 &#13;
        print "  Comparing dates: date_1 &gt; date_2?", date_1 &gt; date_2 &#13;
</pre><p>The output of the preceding piece of code can be seen in the following screenshot:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_010.jpg"/></div><p>
</p></li><li class="listitem">As we saw in the previous recipe, you also feel the need to combine your <code class="literal">time</code> objects with the <code class="literal">date</code> objects. For instance, you have developed your program for a use case where you want to compare <code class="literal">time</code> objects and take some action. But you may end up doing the date comparison also since the <code class="literal">time</code> objects you are comparing fall on different dates. Since you're already aware how easy it is to work with <code class="literal">datetime</code> objects, you may want to combine your <code class="literal">time</code> and <code class="literal">date</code> objects into a single <code class="literal">datetime</code> object and easily work on them. We can easily achieve this in Python; the following code demonstrates combining independent times and dates to <code class="literal">datetime</code> objects:<pre class="programlisting">        import datetime &#13;
 &#13;
        time_1 = datetime.time(13, 44, 55) &#13;
        time_2 = datetime.time(13, 44, 55) &#13;
        print "  Times:", time_1, time_2 &#13;
 &#13;
        date_1 = datetime.date.today() &#13;
        date_2 = date_1 + datetime.timedelta(days=1) &#13;
        print "  Dates:", date_1, date_2 &#13;
 &#13;
        datetime_1 = datetime.datetime.combine(date_1, time_1) &#13;
        datetime_2 = datetime.datetime.combine(date_2, time_2) &#13;
        print "  Datetime Difference:", datetime_2 - datetime_1</pre><p>The output of the preceding piece of code is:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_011.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec241"/>How it works...</h2></div></div></div><p>In the last section, we worked on <code class="literal">time</code>, <code class="literal">date</code>, and <code class="literal">calendar</code> objects independently. In this recipe, we started working on the complete <code class="literal">datetime</code> object.</p><p>In the first code example of this recipe, we calculated the difference between the <code class="literal">datetime</code> objects. We could easily do that with the same subtraction (<code class="literal">-</code>) operator we're used to. That means the <code class="literal">__sub__()</code> method has been overridden for the <code class="literal">datetime</code> class.</p><p>Then, in the second and third code snippets, we used the <code class="literal">timedelta()</code> method to get to the future <code class="literal">datetime</code> objects or move in the past. The <code class="literal">timedelta()</code> method supports conveniently named attributes such as <code class="literal">days</code> or <code class="literal">hours</code> to shift the current <code class="literal">datetime</code> objects to the past or future. We get to the past with <code class="literal">- timedelta()</code> and move ahead with <code class="literal">+ timedelta()</code> operations.</p><p>Next, we understood how to compare the <code class="literal">datetime</code> objects. This was again simply done like any other Python object. In Python, we check if an integer is less than or greater than another integer with the <code class="literal">&lt;</code> and <code class="literal">&gt;</code> operators, respectively. Same is the case with the <code class="literal">datetime</code> objects. We simply use these operators to compare even the <code class="literal">datetime</code> objects.</p><p>Finally, we looked at the use case where we needed to work on <code class="literal">date</code> and <code class="literal">time</code> objects to get the difference or compare them. For this, we wrote a Python code to combine the <code class="literal">date</code> and <code class="literal">time</code> objects and used the <code class="literal">datetime.combine()</code> method. This made sure that the comparison or the difference operation can be easily done on the <code class="literal">datetime</code> objects instead of doing them individually on <code class="literal">date</code> or <code class="literal">time</code> objects and then merging the results.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec86"/>Formatting and parsing dates</h1></div></div></div><p>In all the recipes so far, we performed multiple operations on the <code class="literal">date</code> or <code class="literal">time</code> objects. But the objects themselves are represented in certain formats. For instance, by default, the <code class="literal">date()</code> object is represented in a YYYY-MM-DD format and the <code class="literal">time()</code> object is represented in a HH:MM:SS format. While these representations are good, we can't always use these formats for representing data to the users on a website or while scheduling meetings from a web page.</p><p>In this section, we quickly look at the different formats in which the <code class="literal">date</code> and <code class="literal">time</code> objects can be manifested to the users.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec242"/>Getting ready</h2></div></div></div><p>For this recipe, we end up using the same <code class="literal">datetime</code> module that gets packaged with the default Python installation.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec243"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's get started with something we know. The following Python code will print the date and time in ISO format. This format is the most used format around the world and is universally acceptable:<pre class="programlisting">        import datetime &#13;
        today = datetime.datetime.today() &#13;
        print "  ISO datetime: ", today &#13;
</pre></li><li class="listitem">However, as you would have already imagined, this format is not quite readable. For instance, it reads the month in digits (11 for November) and returns the time even till microseconds (which I don't think is very useful). How about formats where we solve these issues and make the date more readable? Yes, we can easily do that with the following code snippet. In this code, with the help of certain format specifiers such as <code class="literal">'%b'</code>, we manage to make the month readable:<pre class="programlisting">        import datetime &#13;
        today = datetime.datetime.today() &#13;
        print "  ISO datetime: ", today &#13;
  &#13;
        format = "%a %b %d %H:%M:%S %Y" &#13;
        string_format = today.strftime(format) &#13;
        print "  Datetime in String format:", string_format &#13;
 &#13;
</pre></li><li class="listitem">You must have seen some web applications using Unix timestamp or epochs to store time. Even though this is a nice way to store objects, you still need to represent the actual time or date to the user in the format she understands.</li><li class="listitem">Unix time, also known as POSIX time or epoch time, is a system for describing times defined as seconds that have elapsed since Thursday, January 01, 1970, 00:00:00 UTC. Unix timestamps are useful as they represent time independent of time zones. For example, a Unix time can represent 1:00 pm in London and 8:00 am in New York.<p>The following code snippets show how to convert timestamps to <code class="literal">datetime</code> objects and vice versa:</p><pre class="programlisting">        import datetime &#13;
        import time &#13;
 &#13;
        time_1 = time.time() &#13;
        print "  Datetime from unix timestamp:",&#13;
        datetime.datetime.fromtimestamp(1284101485) &#13;
 &#13;
        date_1 = datetime.datetime(2012,4,1,0,0) &#13;
        print "  Unix timestamp", date_1.strftime('%s')  &#13;
</pre></li><li class="listitem">Another fun representation of the <code class="literal">datetime</code> objects can be to show the date from the <em>n</em><sup>th</sup> day from when the world began. For instance, can you print the date for the 1000<sup>th</sup> day after Jan 1, 0001? It is the date corresponding to the propletic Gregorian calendar where 01/01/01 has an ordinal 1:<pre class="programlisting">        import datetime &#13;
        date_1 = datetime.date.fromordinal(1000) &#13;
        print "  1000th day from 1 Jan 0001: ", date_1 &#13;
</pre><p>If you run the preceding Python code snippet, you will be able to see the desired objects as in the following screenshot:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_012.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec244"/>How it works...</h2></div></div></div><p>In this recipe, we looked at the various ways of representing <code class="literal">datetime</code> objects. In the first example, we printed the date and time in ISO format. This is the most used format and you can read more about the ISO format at <a class="ulink" href="https://en.wikipedia.org/wiki/ISO_8601">https://en.wikipedia.org/wiki/ISO_8601</a>. As you can see, we need not use a new method for this representation; we simply used <code class="literal">datetime.today()</code> to get the date in ISO format.</p><p>In the second example, we looked at defining our own format for representing the date in the string format. We took the help of format specifiers, such as <code class="literal">%a</code>, <code class="literal">%b</code>, and <code class="literal">%d</code> to work with date and <code class="literal">%H</code>, <code class="literal">%M</code>, and <code class="literal">%S</code> to work with time. We specified the format in the <code class="literal">format</code> variable and used it to pass it to <code class="literal">strftime()</code> method that formatted the ISO <code class="literal">datetime</code> object to our custom String format.</p><p>The next two examples helped us convert a Unix timestamp or an epoch to a <code class="literal">datetime</code> object and vice versa. For the first use case, we use the <code class="literal">datetime.fromtimestamp(&lt;unixtimestamp&gt;)</code> method to convert a Unix time stamp to a <code class="literal">datetime</code> object, and in the successive example, we converted a <code class="literal">datetime</code> object to a Unix timestamp with the <code class="literal">strftime()</code> method. The Unix time (1284101485) used in this example is the number of seconds that have elapsed since January 01, 1970.</p><p>In the last and interesting example, we get the date and time in a Gregorian calendar ordinal format with <code class="literal">fromordinal()</code> method. You will not use this method, in all likelihood, but I have included it in this chapter as an interesting date format for you to know.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec87"/>Dealing with time zone calculations</h1></div></div></div><p>One of the trickiest calculations that you will have to perform on <code class="literal">date</code> or <code class="literal">time</code> objects is the one that involves time zones. Your colleague works in San Francisco and you are in Sydney, how do you plan to do a conference call? When you set up a meeting, you should be aware of your colleague's time zone, else you may set up a meeting for 8 pm Sydney time while for your colleague in San Francisco, it is already past midnight. Time zone calculations are often tedious and need to be handled cautiously while developing business applications. Let's see how Python can help us in this regard.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec245"/>Getting ready</h2></div></div></div><p>For this recipe, we will use the <code class="literal">pytz</code> module that we installed at the beginning of this chapter. In fact, the Python standard library doesn't have a time zone library, but we can completely rely on the modules contributed by the Python community for our needs.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec246"/>How to do it...</h2></div></div></div><p>You need to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's get started with a trivial operation of getting the local time in UTC. <strong>UTC</strong> stands for <strong>Universal Time Converter</strong>, a worldwide standard for regulating clocks and time measurements. UTC is also popularly known as Greenwich Mean Time (GMT).<pre class="programlisting">        from datetime import datetime, timedelta &#13;
        now = datetime.now() &#13;
        print "  Local time now is:", now &#13;
        utcnow = datetime.utcnow() &#13;
        print "  UTC time now is:", utcnow</pre><p>The output of the preceding code snippet is shown in the following screenshot. Look at how my local time is +5:30 hours ahead of UTC:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_013.jpg"/></div><p>
</p></li><li class="listitem">OK, this is nice. So, you can convert your local time to UTC, but this is not always enough. Your customers (for whom you develop the application) can be from anywhere in the world. Their accounts also need to be managed with respect to their time zones and local times. Let's see how we can figure out the local time for a user in a given time zone:<pre class="programlisting">        from pytz import timezone &#13;
        import pytz &#13;
        utc = pytz.utc &#13;
        print "  Selected time zone:", utc &#13;
        eastern = timezone('US/Eastern') &#13;
        print "  Switched to time zone:", eastern &#13;
        loc_dt = datetime(2016, 11, 27, 12, 0, 0, tzinfo=pytz.utc) &#13;
        est = loc_dt.astimezone(eastern) &#13;
        fmt = '%Y-%m-%d %H:%M:%S %Z%z' &#13;
        print "  Local time in Eastern time zone:", est.strftime(fmt)</pre><p>The output of the preceding piece of code is shown in the following screenshot. Observe how we converted a local UTC time to <strong>Eastern Standard Time</strong> (<strong>EST</strong>) by getting the eastern time zone. In fact, UTC works out to be the best way to convert time across time zones:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_014.jpg"/></div><p>
</p></li><li class="listitem">Performing arithmetic calculations on <code class="literal">datetime</code> objects with time zone information is also trivial in Python. Look at the following code and see how we perform arithmetic operations on <code class="literal">date</code> objects:<pre class="programlisting">        from datetime import datetime, timedelta &#13;
        au_tz = timezone('Australia/Sydney') &#13;
        local = datetime(2002, 10, 27, 6, 0, 0, tzinfo=au_tz) &#13;
        print "  Local time in Sydney:", local &#13;
        past = local - timedelta(minutes=10) &#13;
        print "  10 minutes before time was:", past &#13;
        future = local + timedelta(hours=18) &#13;
        print "  18 hours later it is:", future</pre><p>Now, if we run this piece of code on our Python interpreter, we get the following output:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_015.jpg"/></div><p>
</p></li><li class="listitem">We can't finish any topic on time zones without really talking about this, can we? Yes, how do we deal with daylight savings in time zone calculations? Thanks to Benjamin Franklin for the gift he gave to the world on daylight savings. Let's understand this with the help of a code example:<pre class="programlisting">        eastern = timezone('US/Eastern') &#13;
        dt = datetime(2016, 11, 06, 1, 30, 0) &#13;
        dt1 = eastern.localize(dt, is_dst=True) &#13;
        print "  Date time 1 with day light savings:", dt1.strftime(fmt) &#13;
        dt2 = eastern.localize(dt, is_dst=False) &#13;
        print "  Date time 2 without day light savings:", dt2.strftime(fmt)</pre><p>If you run the code snippet, you'd see two <code class="literal">datetime</code> objects represented in the String format. The first one takes care of the daylight savings and the second one disregards it. November 6, 2016 is when the daylight savings ended this year in the eastern time zone and the clock moved backwards:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_016.jpg"/></div><p>
</p></li><li class="listitem">Lastly, there are a few helper methods that are available in the <code class="literal">pytz</code> module that are often useful, for instance, getting the time zones for a given country based on the ISO country code, or simply getting the country name from the ISO country code. Let's look at the following examples:<pre class="programlisting">        tz_au = '\n  '.join(pytz.country_timezones['au']) &#13;
        print "  Time zones in Australia:", tz_au &#13;
        country_gb, country_fr = pytz.country_names['gb'], &#13;
                                pytz.country_names['fr'] &#13;
       print "\n  Country names are:\n", "  ", &#13;
       country_gb, "\n  ", "  ", country_gb, "\n  ", country_fr</pre><p>The output of the preceding code snippet can be viewed in the following screenshot:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_017.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec247"/>How it works...</h2></div></div></div><p>In this recipe, we looked at the various ways of working with time zones, which are integral to date-time calculations. In the first code example of this recipe, we calculate the current local time with <code class="literal">datetime.now()</code> and then got the same local time in UTC with <code class="literal">datetime.utcnow()</code>. The <code class="literal">utcnow()</code> method becomes very handy when we have to store date/time objects in the database for further processing, such as scheduling events.</p><p>Next, we looked at how to switch to a different time zone and retrieve the local time in that time zone. The <code class="literal">pytz</code> class has a simple attribute, <code class="literal">utc</code>, to set the time zone to UTC; we used it to set our current time zone to UTC. Later we used the <code class="literal">timezone()</code> method of the <code class="literal">pytz</code> module to switch to the eastern time zone with <code class="literal">timezone('US/Eastern')</code>.</p><p>In all the recipes before this one, we created a <code class="literal">datetime</code> object with the <code class="literal">datetime()</code> method; in this recipe also, we used the <code class="literal">datetime</code> method but with the <code class="literal">tzinfo</code> parameter in this way: <code class="literal">datetime(YYYY, MM, DD, HH, MM, SS, tzinfo=&lt;timezone&gt;)</code>. The <code class="literal">tzinfo</code> parameter makes sure to add the time zone information to the <code class="literal">datetime</code> object, which is important while performing calculations across time zones.</p><p>The <code class="literal">datetime</code> class has another convenient method that will represent the <code class="literal">datetime</code> object to a time zone of our choice: the <code class="literal">astimezone()</code> method. Using this method, we converted the UTC <code class="literal">datetime</code> object to eastern time with this code, <code class="literal">loc_dt.astimezone(eastern)</code>.</p><p>Finally, we created a custom string format to represent the eastern time with the <code class="literal">strftime(format)</code> method.</p><p>We can also add or remove time/days during the time zone calculations like we did with <code class="literal">datetime</code> objects. In the third code sample of this recipe, we switched to the Australia/Sydney time zone and created a <code class="literal">datetime</code> object for this time zone; this operation returned us the local time in Sydney. With the help of the <code class="literal">timedelta()</code> method, we then removed ten minutes from the local time with <code class="literal">local - timedelta(mins=10)</code> and also added 18 hours to the time with <code class="literal">local + timedelta(hours=18)</code>. This way, we could access the time from the past or in the future. Think of it as time travel.</p><p>In the fourth code snippet, we understood how to work with daylight savings. To understand this, we created a <code class="literal">datetime</code> object without any time zone information and assigned it to the <code class="literal">dt</code> variable. We also created a time zone object for eastern time with the code, <code class="literal">eastern = timezone('US/Eastern')</code>. We then used the <code class="literal">localize()</code> method on the time zone object to convert the <code class="literal">dt</code> object to eastern time. Here is where we add another parameter, <code class="literal">is_dst</code>, to the <code class="literal">localize(is_dst=&lt;True/False&gt;)</code> method to return the local time in eastern time zone, with or without considering daylight savings.</p><p>In 2016, November 6 was the day when the clock moved backwards at 2 am. So, in our example, when we queried for 1:30 am eastern time with <code class="literal">is_dst=True</code>, it returned time in <strong>Eastern Daylight Time</strong> (<strong>EDT</strong>), which is four hours behind <strong>Coordinated Universal Time</strong> (UTC-0400 hours). When we queried for the same time with <code class="literal">is_dst=False</code>, it returns the time in EST, which is UTC-0500 hours.</p><p>In the last example of this recipe, we looked at a few useful helper methods provided by the <code class="literal">pytz</code> module. For instance, <code class="literal">pytz.country_timezones['au']</code> returned all the time zones available in Au (Australia) and <code class="literal">pytz.country_names['gb']</code> returned the name of the country, that is, Britain (UK), based on the ISO country code <code class="literal">gb</code>. You will realize the utility of these libraries when you actually solve some of the time zone problems.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec88"/>Automating invoicing based on user time zone</h1></div></div></div><p>Jacob is a Finance Manager at Anzee Corporation in North America and is responsible for customer invoicing. Anzee Corporation provides a <strong>Software as a Service</strong> (<strong>SaaS</strong>) platform to its customers and charges customers based on the platform usage. Anzee's customers have raised complaints regarding incorrect monthly invoices. In their words, "<em>Invoices for the previous month are available on the 1<sup>st</sup> day of the next month, which is fine, but a part of our usage is not accounted for. This messes up our accounting.</em>"</p><p>Currently, Jacob generates invoices in a manual way by getting the data for customer's payments and platform usage from the platform's database records. With an increasing number of customers each month, Jacob realizes that the manual process is going to be laborious and time consuming. He also wants someone to look at the issue the customers are complaining about. Can we help Jacob?</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec248"/>Getting ready</h2></div></div></div><p>In this recipe, we'll use all the built-in Python modules that we've used in the previous recipes as well as install the <code class="literal">fpdf</code> module for generating the PDF invoice to solve Jacob's need for an automated way to prepare invoices for his customers. We install the module using Python <code class="literal">pip</code>:</p><pre class="programlisting">
<strong>        (date)chetans-MacBookPro:ch12 Chetan$ pip install fpdf &#13;
        You are using pip version 7.1.0, however version 9.0.1 is&#13;
        available. &#13;
        You should consider upgrading via the &#13;
            'pip install --upgrade pip' command. &#13;
        Collecting fpdf &#13;
        Downloading fpdf-1.7.2.tar.gz &#13;
        Building wheels for collected packages: fpdf &#13;
        Running setup.py bdist_wheel for fpdf &#13;
        Stored in directory: /Users/chetan/Library/Caches/pip/wheels/&#13;
        c9/22/63/16731bdbcccd4a91f5f9e9bea98b1e51855a678f2c6510ae76 &#13;
        Successfully built fpdf &#13;
        Installing collected packages: fpdf &#13;
        Successfully installed fpdf-1.7.2</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec249"/>How to do it...</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's get started by looking at the database records. Anzee Corporation uses MongoDB to store the records of customer payments and charges for the month. For this example, lets assume, the payment records of Anzee Corporation are stored in JSON format.</li><li class="listitem">We use a <code class="literal">users</code> document that contains the list of all the users with fields such as <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">city</code>, and <code class="literal">timezone</code>, like any other user table would. It also maintains the records of all the payments done by the users in <code class="literal">payments</code>, which contains the <code class="literal">id</code> of the user who paid for the platform services, the amount paid, and the date on which the amount is paid.</li><li class="listitem">The timestamp for all the payments done is in the UTC format. Like payments, it also maintains the <code class="literal">usage</code> records that again contain the user ID of the person who used the platform, the amount she was charged for the usage, and the time at which she was charged:<pre class="programlisting">        users = [{"id":12, "name":"John", "city":"New York",&#13;
                  "timezone":"US/Eastern"}, &#13;
                 {"id":13, "name":"Johny", "city":"Indiana",&#13;
                  "timezone":"US/Central"}] &#13;
 &#13;
        #All time stamps are in UTC &#13;
        payments = [{"id":12, "amount":12.00, &#13;
                     "created_at":"2016-11-29T11:46:07.141Z"}, &#13;
                    {"id":13, "amount":22.00, &#13;
                     "created_at":"2016-11-30T23:46:07.141Z"}, &#13;
                    {"id":12, "amount":5.00, &#13;
                     "created_at":"2016-12-01T01:00:00.141Z"}] &#13;
 &#13;
        usage = [{"id":12, "charge":5.00, &#13;
                  "created_at":"2016-11-29T11:46:07.141Z"}] &#13;
</pre></li><li class="listitem">OK cool, now that we have all the data, let's work on writing the code to generate our invoice. We start by writing methods to get the payments and usages for the users for a given month. The following code snippet does this task for us:<pre class="programlisting">        user_ids = [] &#13;
        user_names = [] &#13;
        for usr in users: &#13;
        user_ids.append(usr["id"]) &#13;
        user_names.append(usr["name"]) &#13;
 &#13;
        def get_payments(user_id, month):&#13;
            tz = [ x for x in users if x["id"] == user_id] &#13;
            tot_payment = 0.00 &#13;
            for p in payments: &#13;
                dt = datetime.strptime(p["created_at"], &#13;
                                       '%Y-%m-%dT%H:%M:%S.%fZ') &#13;
                if p["id"] == user_id and dt.month == month: &#13;
                   tot_payment += p["amount"] &#13;
            return tot_payment &#13;
 &#13;
        def get_usage(user_id, month): &#13;
        tz = [ x for x in users if x["id"] == user_id]&#13;
            tot_usage = 0.00 &#13;
            for u in usage: &#13;
              dt = datetime.strptime(u["created_at"], &#13;
                                     '%Y-%m-%dT%H:%M:%S.%fZ') &#13;
              if u["id"] == user_id and dt.month == month: &#13;
                 tot_usage += u["charge"] &#13;
            return tot_usage &#13;
 &#13;
</pre></li><li class="listitem">Next, let's write the code to generate a PDF invoice in an automated manner, as Jacob wanted for his platform. We use the <code class="literal">fpdf</code> module for this purpose. The following code generates the invoice:<pre class="programlisting">        def get_invoice(user_name, user_id, month): &#13;
            html = """ &#13;
        &lt;p&gt;Anzee Corporation&lt;/p&gt;&lt;br&gt; &#13;
        &lt;b&gt;&lt;p&gt;Account Name: """ + user_name + """&lt;/p&gt; &#13;
        &lt;p&gt;Invoice for month of: """ + &#13;
           str(calendar.month_name[month]) + """&lt;/p&gt;&lt;/b&gt; &#13;
        &lt;br&gt;&lt;br&gt; &#13;
        &lt;p&gt;&lt;b&gt;Payments and Usage:&lt;/b&gt;&lt;/p&gt; &#13;
        &lt;table align="center" width="50%"&gt; &#13;
          &lt;thead&gt; &#13;
            &lt;tr&gt; &#13;
              &lt;th align="left" width="50%"&gt;Charge Type&lt;/th&gt; &#13;
              &lt;th align="right" width="50%"&gt;Amount&lt;/th&gt; &#13;
            &lt;/tr&gt; &#13;
          &lt;/thead&gt; &#13;
          &lt;tbody&gt; &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;Payments Done&lt;/td&gt; &#13;
              &lt;td align="right"&gt;$""" + str(get_payments&#13;
                               (user_id, month)) + """&lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;Total Usage&lt;/td&gt; &#13;
              &lt;td align="right"&gt;$""" + str(get_usage&#13;
                               (user_id, month)) + """&lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
          &lt;/tbody&gt; &#13;
        &lt;/table&gt; &#13;
        &lt;br&gt;&lt;br&gt; &#13;
          """ &#13;
          return html &#13;
 &#13;
        class MyFPDF(FPDF, HTMLMixin): &#13;
        pass &#13;
 &#13;
        html = get_invoice("John", 12, 11) &#13;
        pdf=MyFPDF() &#13;
        pdf.add_page() &#13;
        pdf.write_html(html) &#13;
        pdf.output('invoice.pdf','F')  &#13;
</pre></li><li class="listitem">If we run the preceding code snippet in entirety, we get the generated invoice, which looks like the following screenshot:<p>
</p><div><img alt="How to do it..." src="img/image_12_018.jpg"/></div><p>
</p></li><li class="listitem">OK, this is cool! We could generate the invoice like Jacob expected. We are now able to save a lot of time for him by automating the complete process. But then he also wanted us to look at the customer complaints regarding the invoice not containing accurate information. Let's see what could have happened.</li><li class="listitem">Now, Anzee Corporation stores all the transactions and usage timestamps in UTC so that it becomes very easy for them to retrieve the time and show it to the user based on the user's time zone. So when we look up all records to get the transactions in that month for the invoice, we're looking at the UTC timestamps and not the time in the user's time zones.</li><li class="listitem">For instance, if you look deeper into the JSON data, there is a mention of another payment made by <code class="literal">John</code>, user ID <code class="literal">12</code>, which has a <code class="literal">created_at</code> timestamp as <code class="literal">2016-12-01T01:00:00.141Z</code>. This time may not fall under the month of November from a UTC perspective, but the user who made the payment belongs to the US/Eastern time zone. So, 1 am on December 1, 2016 in UTC is actually 8 pm on November 30 in the Eastern time zone. Obviously, the user doesn't find his payment featuring in the invoice.</li><li class="listitem">The following code snippet solves the problem by generating invoices based on the user time zones:<pre class="programlisting">        from datetime import datetime &#13;
        import pytz &#13;
        from pytz import timezone &#13;
        from fpdf import FPDF, HTMLMixin &#13;
        import calendar &#13;
 &#13;
        users = [{"id":12, "name":"John", &#13;
                  "city":"New York", "timezone":"US/Eastern"}, &#13;
                 {"id":13, "name":"Johny", &#13;
                  "city":"Indiana", "timezone":"US/Central"}] &#13;
 &#13;
        #All time stamps are in UTC &#13;
        payments = [{"id":12, "amount":12.00, &#13;
                     "created_at":"2016-11-29T11:46:07.141Z"}, &#13;
                    {"id":13, "amount":22.00, &#13;
                     "created_at":"2016-11-30T23:46:07.141Z"}, &#13;
                    {"id":12, "amount":5.00, &#13;
                     "created_at":"2016-12-01T01:00:00.141Z"}] &#13;
        usage = [{"id":12, "charge":5.00, &#13;
                  "created_at":"2016-11-29T11:46:07.141Z"}] &#13;
 &#13;
        user_ids = [] &#13;
        user_names = [] &#13;
        for usr in users: &#13;
            user_ids.append(usr["id"]) &#13;
        user_names.append(usr["name"]) &#13;
 &#13;
        def get_payments(user_id, month): &#13;
            tz = [ x for x in users if x["id"] == user_id] &#13;
            tot_payment = 0.00 &#13;
            for p in payments: &#13;
                dt = datetime.strptime(p["created_at"], &#13;
                               '%Y-%m-%dT%H:%M:%S.%fZ') &#13;
                dt = dt.replace(tzinfo=pytz.UTC) &#13;
                dt = dt.astimezone(timezone(tz[0]["timezone"])) &#13;
                if p["id"] == user_id and dt.month == month: &#13;
                   tot_payment += p["amount"] &#13;
            return tot_payment &#13;
         &#13;
        def get_usage(user_id, month): &#13;
            tz = [ x for x in users if x["id"] == user_id] &#13;
            tot_usage = 0.00 &#13;
            for u in usage: &#13;
                dt = datetime.strptime(u["created_at"], &#13;
                               '%Y-%m-%dT%H:%M:%S.%fZ') &#13;
                dt = dt.replace(tzinfo=pytz.UTC) &#13;
                dt = dt.astimezone(timezone(tz[0]["timezone"])) &#13;
                if u["id"] == user_id and dt.month == month: &#13;
                   tot_usage += u["charge"] &#13;
        return tot_usage &#13;
 &#13;
        def get_invoice(user_name, user_id, month): &#13;
          html = """ &#13;
        &lt;p&gt;Anzee Corporation&lt;/p&gt;&lt;br&gt; &#13;
        &lt;b&gt;&lt;p&gt;Account Name: """ + user_name + """&lt;/p&gt; &#13;
        &lt;p&gt;Invoice for month of: """ + &#13;
           str(calendar.month_name[month]) + """&lt;/p&gt;&lt;/b&gt; &#13;
        &lt;br&gt;&lt;br&gt; &#13;
        &lt;p&gt;&lt;b&gt;Payments and Usage:&lt;/b&gt;&lt;/p&gt; &#13;
        &lt;table align="center" width="50%"&gt; &#13;
          &lt;thead&gt; &#13;
            &lt;tr&gt; &#13;
              &lt;th align="left" width="50%"&gt;Charge Type&lt;/th&gt; &#13;
              &lt;th align="right" width="50%"&gt;Amount&lt;/th&gt; &#13;
            &lt;/tr&gt; &#13;
          &lt;/thead&gt; &#13;
          &lt;tbody&gt; &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;Payments Done&lt;/td&gt; &#13;
              &lt;td align="right"&gt;$""" + str(get_payments(&#13;
                             user_id, month)) + """&lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
            &lt;tr&gt; &#13;
              &lt;td&gt;Total Usage&lt;/td&gt; &#13;
              &lt;td align="right"&gt;$""" + str(get_usage(&#13;
                          user_id, month)) + """&lt;/td&gt; &#13;
            &lt;/tr&gt; &#13;
          &lt;/tbody&gt; &#13;
        &lt;/table&gt; &#13;
        &lt;br&gt;&lt;br&gt; &#13;
          """ &#13;
          return html &#13;
 &#13;
 &#13;
        class MyFPDF(FPDF, HTMLMixin): &#13;
              pass &#13;
 &#13;
        html = get_invoice("John", 12, 11) &#13;
        pdf=MyFPDF() &#13;
        pdf.add_page() &#13;
        pdf.write_html(html) &#13;
        pdf.output('invoice.pdf','F') &#13;
</pre><p>The output for the preceding code snippet is shown in the following screenshot. See how the payments column now reflects the correct data and includes the $5 payment done at 8 pm on November 30, 2016, taking the total to <em>$12 + $5 = $17</em>:</p><p>
</p><div><img alt="How to do it..." src="img/image_12_019.jpg"/></div><p>
</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec250"/>How it works...</h2></div></div></div><p>We first looked at automating the invoice generation for Jacob. We parsed the JSON data for all the users and calculated the payments and usage for all the users for the month of November.</p><p>We developed <code class="literal">get_payments(user_id, month)</code> and <code class="literal">get_usage(user_id, month)</code> to go through the <code class="literal">payments</code> and <code class="literal">usage</code> records and picked the records for the month of November. We did this by working on the <code class="literal">created_at</code> JSON strings and converting them to date/time objects, with <code class="literal">dt = datetime.strptime(u["created_at"], '%Y-%m-%dT%H:%M:%S.%fZ')</code>.</p><p>But as we understood in the previous section, just converting the string to a timestamp didn't help, as we didn't consider the time with respect to the user's time zone. For this, we used the date/time object, <code class="literal">dt</code>, to convert it to the UTC time zone with <code class="literal">dt.replace(tzinfo=pytz.UTC)</code>, and then converted <code class="literal">dt</code> to reflect the time in the user's time zone with the <code class="literal">dt.astimezone(timezone(&lt;&gt;))</code> method. This way, we could get the payment time in the user's time zone and the invoice data reflected correct figures for the month of November.</p><p>Next, we created HTML content for the invoice by adding the appropriate username, time of invoice, and stored this in the <code class="literal">html</code> variable. Later, we created a <code class="literal">MyFPDF</code> class that inherited <code class="literal">FPDF</code> and <code class="literal">HTMLMixin</code> classes from the <code class="literal">fpdf</code> module. The <code class="literal">MyFPDP</code> class was then used to create a <code class="literal">pdf</code> object, which represented an empty PDF file object. We added a page to the <code class="literal">pdf</code> object with the <code class="literal">add_page()</code> method and updated it with HTML content (our invoice content) with the <code class="literal">write_html(html)</code> method. Eventually, we dumped the <code class="literal">pdf</code> object with all the data on the disk with the <code class="literal">output(&lt;filename&gt;)</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec251"/>There's more...</h2></div></div></div><p>There are many other interesting use cases with time and time zone operations in Python. It can get tricky if not used well, as we saw in our last examples. As a general guideline, I recommend you to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Always use <code class="literal">datetime</code> objects that are time zone aware. You will never go wrong with this approach. It will always serve you as a reminder.</li><li class="listitem" style="list-style-type: disc">Return the <code class="literal">datetime</code> in an ISO format that also returns you the time zone information for the given object.</li></ul></div><p>Hope you liked this chapter and enjoyed the examples! Stay tuned.</p></div></div></body></html>