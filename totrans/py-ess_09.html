<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Exceptions</h1></div></div></div><p>Python's general approach to unexpected situations is to raise an <span class="strong"><strong>exception</strong></span>. The idea is that an<a class="indexterm" id="id492"/> operation should either work normally and completely, or raise an exception. In some languages, complex numeric status codes are used to indicate success. In Python, success is assumed; if there's a problem, an exception is raised to indicate that the operation did not succeed.</p><p>Exceptions can be raised by all aspects of Python programs. All of the built-in classes involve exceptions for various kinds of unexpected conditions. Many library packages define their own unique exceptions which extend the built-in hierarchy of exceptions.</p><p>We'll look at the essential concept behind exceptions first. Python has a number of statements that we'll use. The <code class="literal">raise</code> statement creates an exception object. The <code class="literal">try</code> statement allows us to deal with exceptions.</p><p>The <code class="literal">except</code> clause in a <code class="literal">try</code> statement is used to match the class of exception being raised. With some kinds of programming, we narrowly match a specific class of exceptions. In other cases, we use a less specific class of exceptions, or a list of exception classes, to treat a variety of exceptions in a uniform manner.</p><div class="section" title="The core exception concept"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec80"/>The core exception concept</h1></div></div></div><p>The core <a class="indexterm" id="id493"/>concept behind exceptions can be summarized as, "when in doubt, raise an exception". In a typical situation, each Python function or method will return a value or have some documented side-effect. For everything that isn't on the "happy path" that leads to success, the Python approach is to raise an exception.</p><p>Even though most exceptions describe erroneous situations, an exception is not necessarily an error. It's merely an exceptional condition that a given function can't handle. For example, iterators raise the <code class="literal">StopIteration</code> exception when they can no longer produce a result item. This is an exceptional situation that occurs just once in the life cycle of an iterator object.</p><p>When working with numbers, as a second example, division by zero is exceptional. If we divide by any other value, the happy path leads us to a result. While it's possible to contrive a <span class="strong"><strong>Not a Number</strong></span> (<span class="strong"><strong>NaN</strong></span>) value<a class="indexterm" id="id494"/> as the result of division by zero, it's simpler—and more<a class="indexterm" id="id495"/> universal—for the division operator to raise a <code class="literal">ZeroDivisionError</code> exception. Division by zero isn't a normal or <a class="indexterm" id="id496"/>expected design. Almost universally, division by zero indicates one of these things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A design problem</strong></span>: Zero was a possible condition, but the design didn't deal with this situation. The <code class="literal">ZeroDivisionError</code> exception is unexpected. The root cause of a design problem may be a failure to understand the requirements: perhaps a hastily groomed story, perhaps other problems in understanding the problem domain.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>An implementation problem</strong></span>: Zero is cropping up because of a bug. A <code class="literal">ZeroDivisionError</code> exception is similarly unexpected. The root cause may include inadequate unit testing.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A misuse of the application</strong></span>: The user provided input that led to division by zero. The overall application can offer a helpful error message and await different input. Or perhaps the overall application can use a different calculation that's more appropriate to the input values.</li></ul></div><p>An exception can be profound or shallow in its meaning.</p><p>When working with strings, for example, there are a number of situations where an exception is raised. There are also some situations where a status code is returned instead of raising an exception. We can compare <code class="literal">str.find()</code> and <code class="literal">str.index()</code> for two differences in approach:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "abc".index("x")
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: substring not found

&gt;&gt;&gt; "abc".find("x")
-1.</pre></div><p>The first example shows the <code class="literal">index()</code> method, which raises an exception when a substring can't be found. The second example shows the <code class="literal">find()</code> method, which returns a peculiar number if the substring can't be found.</p><p>Exceptions are used widely. Status codes are rarely used in Python.</p><div class="section" title="Examining the exception object"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec79"/>Examining the exception object</h2></div></div></div><p>When<a class="indexterm" id="id497"/> an exception is raised, it involves both a processing change and some data about the condition. An exception is an instance of a more general class. We'll talk generally about an <code class="literal">EOFError</code> exception without emphasizing that the given exception is an instance of the <code class="literal">EOFError</code> exception class.</p><p>The data associated with an exception can include a root cause exception, and a collection of additional arguments. Sometimes the additional arguments are merely a string message. Some exceptions may have a more complex collection of arguments.</p><p>There is also a traceback object which contains the call stack. This identifies the function which raised the exception, the function which called that function, and so on, back to the initial function that started things off. This traceback information is in a specially named attribute called <code class="literal">__traceback__</code>.</p><p>We can<a class="indexterm" id="id498"/> create an exception in several different ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can create exception objects and later raise them to signal a problem:<div class="informalexample"><pre class="programlisting">obj = Exception("some message")
raise obj</pre></div></li><li class="listitem" style="list-style-type: disc">We can create and raise the exception in one smooth motion:<div class="informalexample"><pre class="programlisting">raise Exception("Some Argument", "additional details")</pre></div></li><li class="listitem" style="list-style-type: disc">We can create an exception which wraps a root-cause exception:<div class="informalexample"><pre class="programlisting">raise MyError("problem") from some_exception</pre></div></li></ul></div><p>In the last case, where an exception wraps a root cause, the root cause information is in an attribute named <code class="literal">__cause__</code>.</p></div></div></div>
<div class="section" title="Using the try and except statements"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Using the try and except statements</h1></div></div></div><p>When an <a class="indexterm" id="id499"/>exception is raised, the ordinary sequential exception<a class="indexterm" id="id500"/> of statements stops. The next sequential statement is not executed. Instead, the exception handlers are examined to find an <code class="literal">except</code> clause which matches the given exception's class. This search proceeds down the call stack from the current function to the function which called it. If an <code class="literal">except</code> clause is found which matches the exception, then ordinary sequential execution resumes in that <code class="literal">except</code> clause. When the <code class="literal">except</code> clause finishes, the <code class="literal">try</code> statement is also finished. From there, the normal sequential statement execution continues after the <code class="literal">try</code> statement.</p><p>If no <code class="literal">except</code> clause matches the given exception, the exception and the traceback information is printed. Processing stops, and Python exits. Generally, the exit status is non-zero to indicate that the Python program ended abnormally.</p><p>A <code class="literal">try</code> statement inside a function looks like this:</p><div class="informalexample"><pre class="programlisting">def clean_number(text):
    try:
        value= float(text)
    except ValueError:
        value= None
    return value</pre></div><p>We've defined a function which will convert text to a number. We're going to silence the <code class="literal">ValueError</code> exception and return the <code class="literal">None</code> object instead of raising an exception. We might use this when cleaning a CSV file so that cells without proper numeric values are replaced with the <code class="literal">None</code> object.</p><p>We can see it in operation when we apply it to numbers, like this.</p><div class="informalexample"><pre class="programlisting">    &gt;&gt;&gt; row = ['heading', '23', '2.718']
    &gt;&gt;&gt; list(map(clean_number, row))
    [None, 23.0, 2.718]
    &gt;&gt;&gt; clean_number("1,956")</pre></div><p>In this<a class="indexterm" id="id501"/> example, we're applying the <code class="literal">clean_number()</code> function<a class="indexterm" id="id502"/> to a row of data from the CSV reader. The sample row of data shows both the happy path and the exception path. On the happy path, the two numbers are converted from a string to a proper float value. On the exception path, the improper text was converted into a <code class="literal">None</code>.</p><p>We've also included a test case that isn't handled well. This number-like string, "<code class="literal">1,956</code>" turns into <code class="literal">None</code>. We might have wanted it to be turned into a proper number, in spite of the embedded comma. We can see that a simplistic <code class="literal">except</code> clause isn't really doing everything we'd like it to do.</p><p>Note that some financially-oriented spreadsheet values should be converted to <code class="literal">Decimal</code> values instead of <code class="literal">float</code> values. We can make a higher-order function which will use either the <code class="literal">float()</code> function or the <code class="literal">Decimal()</code> function (or any other conversion function for that matter) to create values of a desired type.</p><p>Here's a revised version that has two <code class="literal">try</code> statements:</p><div class="informalexample"><pre class="programlisting">from decimal import Decimal,  InvalidOperation
def clean_number3(text, num_type=Decimal):
    try:
        value= num_type(text)
    except (ValueError, InvalidOperation):
        text= text.replace(",","").replace("$","")
        try:
            value= num_type(text)
        except (ValueError, InvalidOperation):
            value= None
    return value</pre></div><p>In this version of our number cleaning function, we have an additional parameter, <code class="literal">num_type</code>, with a conversion function to apply. We've provided a default value, <code class="literal">Decimal</code>, so that it is optional. The body of the function has the same happy path as the previous version. We've updated the first <code class="literal">except</code> clause to do more sophisticated fallback processing. This more sophisticated processing involves creating a new string without the <code class="literal">","</code> or <code class="literal">"$"</code> characters that commonly pollute numeric data.</p><p>If this<a class="indexterm" id="id503"/> second string is converted, we'll return a useful numeric <a class="indexterm" id="id504"/>result. If this revised string is not a number, we're stumped, and forced to return a <code class="literal">None</code> object.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>As an exercise, the reader can create an algorithm to convert words to numbers as a fallback. Convert "twenty one" to 21. The complexity of languages like English makes this is an interesting challenge.</p></div></div><div class="section" title="Using nested try statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec80"/>Using nested try statements</h2></div></div></div><p>The <code class="literal">clean_number3()</code> function shows one of the two ways that we can have nested <code class="literal">try</code> statements. In<a class="indexterm" id="id505"/> this case, the <code class="literal">try</code> statements are nested inside a single function. If an exception is raised in the inner <code class="literal">try</code> statement, then the inner <code class="literal">try</code> statement's <code class="literal">except</code> clause is checked first for a matching exception. The outer <code class="literal">try</code> statement's <code class="literal">except</code> clauses are checked next. If none of these match, then the function which called this is checked.</p><p>Consider this example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; clean_number3(',2/0,', Fraction)</pre></div><p>This produces a traceback dump that shows how nested try blocks behave:</p><div class="informalexample"><pre class="programlisting">Traceback (most recent call last):
  ...
ValueError: Invalid literal for Fraction: ',2/0,'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  ...
ZeroDivisionError: Fraction(2, 0)</pre></div><p>We've elided some details with line numbers to focus on the relevant portions of the message. The first exception was raised by the first attempt to apply <code class="literal">Fraction(',2/0,')</code>. This raised a <code class="literal">ValueError</code> exception, knocking us off the happy path. Python resumes sequential execution in the <code class="literal">except</code> clause. This creates a new string with the <code class="literal">","</code> characters removed. The second attempt at conversion does not raise a <code class="literal">ValueError</code> exception, it raises a <code class="literal">ZeroDivisionError</code> exception.</p><p>The inner <code class="literal">try</code> statement has no <code class="literal">except</code> clause to match this exception. Python must then search the outer <code class="literal">try</code> statement's <code class="literal">except</code> clauses for a matching exception. Since the outer <code class="literal">try</code> statement doesn't match the exception, the script as a whole ends with an unhandled exception.</p><p>The more<a class="indexterm" id="id506"/> common situation is to have <code class="literal">try</code> statements in separate functions. The nesting occurs via the function call stack, not the structure of a single suite of statements. Here's a function which calls our <code class="literal">clean_number3()</code> function to create a row of <code class="literal">Fraction</code> objects.</p><div class="informalexample"><pre class="programlisting">def fraction_row(row):
    try:
        return [clean_number3(item,Fraction) for item in row]
    except (TypeError, ZeroDivisionError):
        return [None for item in row]</pre></div><p>This function includes another <code class="literal">try</code> statement. When this function calls <code class="literal">clean_number3()</code> the calls stack will include <code class="literal">fraction_row()</code> and <code class="literal">clean_number3()</code>. If the <code class="literal">clean_number3()</code> function raises an unhandled exception, Python moves down the call stack and searches this <code class="literal">try</code> statement for matching <code class="literal">except</code> clauses.</p></div></div>
<div class="section" title="Matching exception classes in an except clause"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Matching exception classes in an except clause</h1></div></div></div><p>In the <a class="indexterm" id="id507"/>previous examples, we've shown<a class="indexterm" id="id508"/> two kinds of <code class="literal">except</code> clauses:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">except SomeException:</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">except (OneException, AnotherException):</code></li></ul></div><p>The first example matches a single specific exception. The second example matches any of the exceptions in the list of specific exceptions.</p><p>In many cases, the details of the exception are not important. On the other hand, there are some cases where we want to do some processing on the exception object's arguments. We can have the exception object assigned to a variable using this syntax:</p><div class="informalexample"><pre class="programlisting">except SomeException as exc:</pre></div><p>This will assign the exception instance to the <code class="literal">exc</code> variable. We can then write this to a log, or examine the arguments, or modify the traceback that gets printed.</p><div class="section" title="Matching more general exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec81"/>Matching more general exceptions</h2></div></div></div><p>The<a class="indexterm" id="id509"/> Python exceptions form a class hierarchy. Generally, we match exceptions specifically. In a few cases, we'll use exception superclasses instead of specific classes. Some of the most common superclasses are the <code class="literal">OSError</code> and <code class="literal">ArithmeticError</code> exceptions. There are a number of subclasses of <code class="literal">OSError</code> that provide more detailed information about the exception; in many cases, we're not too interested in the nuances of the <code class="literal">OSError</code> superclass. Similarly, the distinction between <code class="literal">OverflowError</code> and <code class="literal">ZeroDivisionError</code> may not be helpful.</p><p>We can use the superclass exception like this:</p><div class="informalexample"><pre class="programlisting">import os
def names(path="."):
    try:
        return [name
            for name in os.listdir(path)
            if not name.startswith('.')]
    except OSError as exc:
        print( exc.__class__.__name__, exc )
        <span class="strong"><strong>raise</strong></span>
</pre></div><p>We've used the superclass <code class="literal">OSError</code> to match all of the various <code class="literal">OSError</code> subclasses. While the most likely exceptions are <code class="literal">FileNotFoundError</code> and <code class="literal">NotADirectoryError</code>, we may also get one of the other subclasses of <code class="literal">OSError</code>. In this case, we don't care about the specific problem, so we can use a superclass error.</p><p>This example also uses the <code class="literal">raise</code> statement with no argument. Within an <code class="literal">except</code> clause, this will reraise the exception after doing some initial handling. The exception will now propagate down the call stack as Python searches for a handler.</p></div><div class="section" title="The empty except clause"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec82"/>The empty except clause</h2></div></div></div><p>Python<a class="indexterm" id="id510"/> allows an <code class="literal">except</code> clause with no exception named. This is the most general exception matcher: it matches all exception classes.</p><p>Since it matches the <code class="literal">SystemExit</code> and <code class="literal">KeyboardInterrupt</code> exceptions, using this casually can create problems. When we're handling this exception, we may find that we can no longer gracefully exit from our program and must resort to the SIGKILL signal to stop the program.</p><p>The undecorated <code class="literal">except</code> clause should be viewed skeptically.</p></div></div>
<div class="section" title="Creating our own exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Creating our own exceptions</h1></div></div></div><p>The<a class="indexterm" id="id511"/> hierarchy of exceptions has a superclass for error-related exceptions, called <code class="literal">Exception</code>. All of the exceptions which reflect essentially erroneous conditions are subclasses of the <code class="literal">Exception</code> class. The base class for all exceptions is the <code class="literal">BaseException</code> class; some non-error-related exceptions are direct subclasses of the <code class="literal">BaseException</code> class.</p><p>We can summarize the hierarchy like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BaseException</code><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SystemExit</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">KeyboardInterrupt</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">GeneratorExit</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Exception</code><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All other exceptions</li></ul></div></li></ul></div></li></ul></div><p>The superclass of all error-related exceptions, <code class="literal">Exception</code>, is quite broad. We can use this in a long-running server like this:</p><div class="informalexample"><pre class="programlisting">def server():
        try:
        while True:
            try:
                one_request()
            except Exception as e:
                print(e.__class__.__name__, e)
    except Shutdown_Request:
        print("Shutting Down")</pre></div><p>This example depends on a function, <code class="literal">one_request()</code>, which handles a single request. The <code class="literal">while</code> loop runs forever, evaluating the <code class="literal">one_request()</code> function. If any of the error-related subclasses of <code class="literal">Exception</code> are raised, the error will be logged, but request handling will continue.</p><p>When a <code class="literal">Shutdown_Request</code> exception is raised, the inner <code class="literal">try</code> statement won't match this. The exception will propagate out of the loop into the outer <code class="literal">try</code> statement. We can log the shutdown request, do any other cleanup that's required, and exit the <code class="literal">server()</code> function.</p><p>The class hierarchy assures us that two of the non-error exceptions—<code class="literal">KeyboardInterrupt</code> and <code class="literal">SystemExit</code>—will not be erroneously handled in the inner <code class="literal">try</code> statement. These exceptions are peers of the <code class="literal">Exception</code> class, which is why they will not be matched. This means that a <code class="literal">SIGINT</code> signal (the effect of hitting <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> on the keyboard) will terminate the server cleanly. Additionally, if some part of the request handling evaluates <code class="literal">sys.exit()</code>, the server will shut down gracefully.</p></div>
<div class="section" title="Using a finally clause"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Using a finally clause</h1></div></div></div><p>We <a class="indexterm" id="id512"/>can include a <code class="literal">finally</code> clause on a <code class="literal">try</code> statement. This contains a suite of statements that will always be executed at the end of the <code class="literal">try</code> statement. This means that the happy path, as well as the exception paths, will always execute the <code class="literal">finally</code> suite. Here's a summary of how this looks:</p><div class="informalexample"><pre class="programlisting">try:
    # Something that might fail.
except SomeException:
    # Fallback plan to handle failure.
finally:
    # Always executed.</pre></div><p>We use this when we have cleanup or a concluding suite of statements that must always be executed. One of the most common use cases for this is to close a file or a network connection even if an exception was raised and handled properly.</p><p>In many cases, we can use a context manager to properly close a file or network connection. We can use <code class="literal">contextlib.closing()</code> to wrap objects which have a <code class="literal">close()</code> method but are not proper context managers. We'll look at context managers in <a class="link" href="ch10.html" title="Chapter 10. Files, Databases, Networks, and Contexts">Chapter 10</a>, <span class="emphasis"><em>Files, Databases, Networks, and Contexts</em></span>.</p></div>
<div class="section" title="Use cases for exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Use cases for exceptions</h1></div></div></div><p>The use<a class="indexterm" id="id513"/> cases for exceptions are very broad. We'll identify a few significant areas where exceptions are used in Python.</p><p>Some exceptions are entirely benign. The <code class="literal">StopIteration</code> exception is raised by an iterable that has run out of values. The <code class="literal">for</code> statement consumes items from the iterable until this exception is raised to signal that there's no more data. Similarly, a <code class="literal">GeneratorExit</code> is used when a generator is closed before producing all of its data. This is not an error; it's a signal that more data will not be requested.</p><p>Conditions that are entirely outside the program may be seen as exceptions. Unexpected OS conditions or errors are signaled by exceptions which are subclasses of the <code class="literal">OSError</code> exception. Some OS conditions can be ignored; others may indicate a serious problem in the environment or in the application. There are over a dozen subclasses of this error to provide a more detailed description of the OS condition. Additionally, internal OS error numbers are also provided as an argument to these exceptions to help distinguish the details of the problem.</p><p>Some exceptions are the result of perfectly ordinary things inside a program. When we use the <code class="literal">str.index()</code> method, this may raise a <code class="literal">ValueError</code> exception instead of returning a numeric value. We can capture and leverage this exception information as part of a program's normal operation.</p><p>We'll often detect the misuse of a program with exceptions. Bad data may be involved, or unsupported operations may be attempted. In these cases, a program may use exceptions to signal a problem that stems from user input problems. A common design pattern is to have exception handling at a high enough level to capture, log, and display these problems in a meaningful way to the user. A long-running server may merely log and then process the next request. A web page may wrap input form validation in exception handling so that the user's response is the form page decorated with error messages.</p><p>Some <a class="indexterm" id="id514"/>exceptions reflect design or implementation problems. An unexpected occurrence of a <code class="literal">ValueError</code> exception may indicate a design problem or an implementation problem. It might indicate inadequate test cases. In this case, it's best for the program as a whole to crash so that the traceback information can be used to locate and correct the problem.</p><p>Unexpected exceptions generally indicate that the program is broken. The program will stop; the output from the exception can provide valuable debugging information. We can interfere with this normal behavior by writing needlessly broad exception handlers, but concealing unexpected exceptions is generally a bad idea, since valuable debugging information is lost.</p><p>In <span class="emphasis"><em>The Zen of Python</em></span> by Tim Peters, there's some poetic advice:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Errors should never pass silently.</em></span></p><p><span class="emphasis"><em>Unless explicitly silenced.</em></span></p></blockquote></div><p>The idea here is that unexpected exceptions in Python will stop the program with a big, noisy error traceback. If we need to silence exceptions, we can use broad, general <code class="literal">except</code> statements to capture and silence them.</p></div>
<div class="section" title="Issuing warnings instead of exceptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Issuing warnings instead of exceptions</h1></div></div></div><p>The Python <code class="literal">warnings</code> module handles a special subclass of exceptions. We can use the <code class="literal">warnings</code> module<a class="indexterm" id="id515"/> to identify potential problems in our application. The warnings module is used internally to track a number of internal considerations.</p><p>The warning concept fits into the middle ground between perfectly normal operations and erroneous conditions. Our program may not be performing optimally, but it's not completely broken, either.</p><p>There are three notable warning classes that we might encounter when running unit tests. Since the unit test framework displays <code class="literal">all</code> warnings, we may see some warnings in a test context that we don't see in the normal operational use of our software.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">DeprecationWarning</code>: This warning is raised by modules, functions, or classes<a class="indexterm" id="id516"/> that have been deprecated. It's a reminder that we need to fix our code to stop using this feature.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PendingDeprecationWarning</code>: A function, module or class for which deprecation<a class="indexterm" id="id517"/> has been announced may raise this warning. This is a hint that we need to stop using this feature before it becomes deprecated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ImportWarning</code>: Since some modules are optional or platform-specific, some<a class="indexterm" id="id518"/> import statements are wrapped in a <code class="literal">try</code> block; this warning is raised instead of an exception. We can expose these warnings to be sure that imports are being processed properly.</li></ul></div><p>We can<a class="indexterm" id="id519"/> leverage the <code class="literal">warnings</code> module to expose the warnings which are normally silenced. We can use <code class="literal">warnings.simplefilter("always")</code> to see all warnings.</p><p>We can raise the generic <code class="literal">UserWarning</code> like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import warnings
&gt;&gt;&gt; warnings.warn("oopsie")
__main__:1: UserWarning: oopsie</pre></div><p>Using <code class="literal">warnings.warn()</code> allows us to include warning messages in an application with very little overhead. We can use this as a debugging aid to track rare situations that are questionable or potentially confusing.</p></div>
<div class="section" title="Permission versus forgiveness &#x2013; a Pythonic approach"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Permission versus forgiveness – a Pythonic approach</h1></div></div></div><p>A common<a class="indexterm" id="id520"/> piece of Pythonic wisdom is the following advice from RADM Grace Murray Hopper:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"It is Easier to Ask for Forgiveness than Permission"</em></span></p></blockquote></div><p>In the Python community, this is sometimes summarized as EAFP programming. This is in contrast <a class="indexterm" id="id521"/>to <span class="strong"><strong>Look Before You Leap</strong></span> (<span class="strong"><strong>LBYL</strong></span>) programming.</p><p>Python exception handling is fast. More importantly, all of the necessary precondition checks for potential problems are already part of the language itself. We never need to bracket processing with extraneous <code class="literal">if</code> statements to see whether or not the input could possibly raise an exception.</p><p>It's generally considered a bad practice to write LBYL code that looks like this:</p><div class="informalexample"><pre class="programlisting">if text.isdigit():
    num= int(text)
else:
    num= None</pre></div><p>The bad idea shown here is an attempt to check carefully to prevent an exception from being raised. This is ineffective for a number of reasons.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">isdigit()</code> test fails to properly handle negative numbers. For a <code class="literal">float()</code> conversion, this kind of test misses a large number of valid syntax alternatives.</li><li class="listitem" style="list-style-type: disc">The overhead of checking the validity of characters and syntax is already part of the <code class="literal">int()</code> function. Checking validity in advance duplicates the checking already in place.</li></ul></div><p>The <a class="indexterm" id="id522"/>more Pythonic approach is to handle the built-in exceptions. For example:</p><div class="informalexample"><pre class="programlisting">try:
    num= int(text)
except ValueError:
    num= None</pre></div><p>This is the same number of lines of code. It properly converts all possible Python integer strings. It does not include any redundant validity checks.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec88"/>Summary</h1></div></div></div><p>In this chapter, we've seen how we can use Python exceptions to write programs which properly handle unexpected conditions. The various kinds of exceptions reflect external conditions as well as internal conditions that may alter how our program behaves. We can use exception clauses to implement fallback processing so that our program handles these exceptional conditions gracefully.</p><p>We've also seen some things which are discouraged. The empty <code class="literal">except</code> clause—which matches too many kinds of exception classes—is something which is legal but should not be used.</p><p>The idea of <span class="strong"><strong>Look Before You Leap</strong></span> (<span class="strong"><strong>LBYL</strong></span>) programming is also generally discouraged. The Pythonic approach is summarized as <span class="strong"><strong>Easier to Ask Forgiveness than to ask Permission</strong></span> (<span class="strong"><strong>EAFP</strong></span>). The general approach is to wrap operations in a <code class="literal">try</code> statement and write appropriate exception handlers for the meaningful exceptions.</p><p>Some exceptions, such as <code class="literal">RuntimeError</code> or <code class="literal">SyntaxError</code>, should not be handled by ordinary application programming. These exceptions usually indicate problems so serious that the program really should crash.</p><p>Other exceptions, such as <code class="literal">IndexError</code> or <code class="literal">KeyError</code>, may be an expected part of the design. When these exceptions are unexpected, we've uncovered a design problem. This may also indicate that we have inadequate unit tests.</p><p>In <a class="link" href="ch10.html" title="Chapter 10. Files, Databases, Networks, and Contexts">Chapter 10</a>, <span class="emphasis"><em>Files, Databases, Networks, and Contexts</em></span>, we'll look at a number of ways in which Python can be used to work with persistent data files and network data transmission. This kind of processing will often require exception handling.</p></div></body></html>