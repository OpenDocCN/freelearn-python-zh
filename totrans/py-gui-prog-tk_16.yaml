- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging with setuptools and cxFreeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Word of your application has spread throughout the ABQ corporation, and you've
    been asked to provide it for use at other facilities. Unfortunately, running and
    installing the application is not a very friendly process; you've been installing
    it through a tedious and error-prone copy-and-paste procedure, and users launch
    it from a batch or shell script you create by hand on each machine. You need to
    package your application in a professional way that makes it easy to install and
    run across Windows, macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Creating distributable packages with setuptools*, you'll learn to create
    distributable Python source and `wheel` packages using the `setuptools` library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Creating executables with cx_Freeze*, you'll learn to create a standalone
    executable of your application, including specific instructions for Windows and
    macOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating distributable packages with setuptools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The distribution process has often been cited as a major shortcoming for Python;
    it is an area with a storied history of ever-evolving tools and approaches, often
    caught between the vestiges of the past and competing visions of the future.
  prefs: []
  type: TYPE_NORMAL
- en: That said, it works surprisingly well, as evidenced by the ease with which we
    have installed components using `pip` throughout this book. The aim of this section
    is to cut through some of the confusion and provide you with a process that respects
    both traditional approaches and future trends.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library contains the `distutils` library, a collection of functionalities
    related to packaging and distributing Python code. However, both the `distutils`
    documentation ([https://docs.python.org/3/library/distutils.html](https://docs.python.org/3/library/distutils.html))
    and the official packaging guide recommend against using it and instead direct
    you to use `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: The `setuptools` library is an extension of the `distutils` library that adds
    some important functionality such as dependency handling, bundling non-Python
    files, and generation of executables. Although `setuptools` is not part of the
    standard library, it is included in the official Python distributions for Windows
    and macOS, and is readily available from the package repositories of most Linux
    distributions. `setuptools` is used by the `pip` package installer, and we can
    use it to create packages that can be installed on any system with Python and
    `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create packages that can be uploaded to PyPI, `setuptools` is
    what you need. For more information about preparing and uploading packages to
    PyPI, see the official Python packaging guide at [https://packaging.python.org](https://packaging.python.org).
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our package for distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although the restructuring of our project directory we did in *Chapter 6*, *Planning
    for the Expansion of Our Application*, left us in fairly good shape for packaging
    our application, there are a few minor additions and changes we need to make for
    our Python package to be a good citizen as a distributed package. Let's go through
    what those are.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a requirements.txt file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `requirements.txt` file is a plaintext file, typically placed in the application
    root directory, that lists all the third-party modules that we used to develop
    our application. Although not used by `setuptools`, this file can be used by `pip`
    to install a package's dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `requirements.txt` file that contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the file specifies the index from which we want to install
    packages; strictly speaking, this line isn't necessary since PyPI will be used
    by default. However, we can override this URL if we want to use a different package
    index; for example, if ABQ decided to create its own private Python package index
    for security reasons, we could redirect `pip` to that server instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ve specified runtime requirements. Our application depends on four
    external libraries: `requests`, `paramiko`, `psycopg2`, and `matplotlib`, and
    these are simply specified one per line. Note that we can also add comments to
    the file by beginning a line with a `#` sign.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've included `flask` as a requirement, which is not used by the application
    but was required by the test service we used for REST. It might seem odd to include
    these kinds of requirements, but the purpose of the `requirements.txt` file is
    to make it simple for other developers (including your future self) to reproduce
    the development environment for this application. You might choose to place non-runtime
    requirements like this in a separate file, for example, `requirements.development.txt`
    or `requirements.testing.txt.`
  prefs: []
  type: TYPE_NORMAL
- en: 'This file can then be used to direct `pip` to install these dependencies using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command causes `pip` to read through the file one line at a time to install
    the dependencies. For each dependency, `pip` will first check to see if the package
    is already installed; if not, it will install the latest version of the package
    from the specified package index.
  prefs: []
  type: TYPE_NORMAL
- en: This presents a small problem, though; what if our code depends on a newer version
    of the package than the user has installed on their system? Or, what if an incompatible
    change in a newer version of a library requires that we run an older version than
    the latest in the index?
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, we can include version specifier strings in `requirements.txt`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A version specifier consists of a comparison operator followed by a version
    string. This will direct `pip` to ensure that the version installed matches the
    requirement; in this case, it would specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`requests` would have to be *exactly* version 2.26.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paramiko` would have to be at least 2.6 or higher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`psycopg2` would have to be less than 3.0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matplotlib` would have to be greater than 3.2 (not including 3.2!), but 3.3
    or lower'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether you include version specifiers, and how specific you make them, depends
    somewhat on the needs of your project and users. In general, you shouldn't limit
    `pip` from installing newer versions of a library so that you don't miss out on
    bug fixes and security patches, but in situations where there are known bugs with
    newer versions, it may be essential.
  prefs: []
  type: TYPE_NORMAL
- en: The command `pip freeze` will print a list of all your installed packages with
    exact versions specified. Developers in mission-critical environments who want
    to guarantee the ability to reproduce their exact development environment often
    just copy this output directly to `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a pyproject.toml file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although `setuptools` is still the de facto standard for packaging Python projects,
    the Python community is moving toward tool-agnostic configuration to accommodate
    newer options as well. As part of this move, the official packaging guide recommends
    creating a `pyproject.toml` file in your project's root directory. Currently,
    this file is only used to specify your project's build system and build system
    requirements, but there is indication that more project settings will migrate
    to this file in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our project, the file should contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This file indicates that our project requires the `setuptools` and `wheel` packages,
    and that we're using `setuptools.build_meta` to actually build our project. These
    are the recommended configurations if you wish to use `setuptools` to build your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the requirements listed here are *build requirements*, meaning they
    are the packages required by the build tool used to create a distributable package.
    This is distinct from the requirements we listed in `requirements.txt`, which
    are the packages needed to *use* the package.
  prefs: []
  type: TYPE_NORMAL
- en: '**TOML** (**Tom''s Obvious, Minimal Language**) is a relatively new configuration
    file format introduced in 2013\. It extends the traditional INI-style format with
    new features like hierarchical structures and nested lists. It is growing in popularity
    particularly as a configuration format for build tools in languages like Rust,
    JavaScript, and of course Python. Learn more about TOML at [https://toml.io](https://toml.io).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a license file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you distribute code, it's important that the recipients know what they're
    allowed to do with that code. Unlike compiled languages such as C or Java, Python
    source code is necessarily included when you distribute your project using `setuptools`.
    To make sure that recipients use the code appropriately, we need to include a
    license file with our code.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding on a license, there are a few concerns you need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: First, if you're developing software as part of your job (such as our ABQ Data
    Entry program), your employer typically owns the code and you need to make sure
    you're specifying their preferred license for the code. Consult your employer
    for their policy on this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, if you''ve used third-party libraries, you''ll need to make sure your
    license is compatible with the license of those libraries. For example, if you
    are using a software library licensed under the **GNU Public License** (**GPL**),
    you may be required to release your software under the GPL or a similar, compatible
    license. Python and Tkinter are distributed under fairly permissive licenses;
    here are the licenses of our four dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Package | License | Reference |'
  prefs: []
  type: TYPE_TB
- en: '| `requests` | Apache2 | [https://2.python-requests.org/projects/3/user/intro/](https://2.python-requests.org/projects/3/user/intro/)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `paramiko` | LGPL 2.1 | [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko)
    (`LICENSE` file) |'
  prefs: []
  type: TYPE_TB
- en: '| `psycopg2` | LGPL 2.1 | [https://www.psycopg.org/license](https://www.psycopg.org/license)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `matplotlib` | Matplotlib License (BSD-based) | [https://matplotlib.org/stable/users/license.html](https://matplotlib.org/stable/users/license.html)
    |'
  prefs: []
  type: TYPE_TB
- en: Be sure to consult these licenses before distributing your package to make sure
    you're complying with the requirements for software using the libraries. If neither
    of these situations applies, you should simply consider what license best suits
    the project and describes the intention you have in distributing it.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever you choose, this should be included in your project root directory
    in a file called `LICENSE`.
  prefs: []
  type: TYPE_NORMAL
- en: Making our package executable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to this point in the project, we''ve been executing our application by running
    the `abq_data_entry.py` file, which we''ve placed in the project root directory
    *outside* the package. Ideally, though, we''d like all our Python code – even
    this trivial launcher script – to be located inside the package. We could just
    copy `abq_data_entry.py` into the package directory, right? It would seem that
    simple, but when we execute the script now we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the relative imports we have in the package will not work correctly
    when executing code inside the package. However, Python provides a solution here:
    we can make our *package* executable, rather than relying on a particular Python
    *script* for execution.'
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to create a `__main__.py` file inside our package. This
    special file inside a Python package makes the package executable; when the module
    is executed, Python will run the `__main__.py` script. However, it will run it
    in a slightly special way that will allow our relative imports to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `abq_data_entry/__main__.py` and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The contents of `__main__.py` are nearly identical to `abq_data_entry.py`; the
    only difference is that we've put the creation of `Application` and the execution
    of `mainloop()` in a function called `main()`. The reason for this will be explained
    shortly when we start building our package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve created `__main__.py`, we can execute the module like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `-m` flag tells Python to load and execute the provided module. Note that,
    for the moment, this command must be executed inside the project root folder.
    Once we create and install our Python package, we'll be able to run it from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a setup.py script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that our code is ready, we can start creating our `setuptools` configuration.
    To package our project using `setuptools`, we need to create a **setup script**;
    by convention, this is called `setup.py` and is created in the application's root
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `setuptools` configuration can also be created as an INI-style configuration
    file, `setup.cfg`. Eventually, this may replace `setup.py`, but in this book we're
    going to stick with the Python script approach, because it allows us to execute
    some necessary Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic structure of a `setup.py` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The vast majority of our configuration will be passed as arguments to the `setup()`
    function, defining the basic metadata for our package, what will be packaged,
    and providing some functionality after installation.
  prefs: []
  type: TYPE_NORMAL
- en: Basic metadata arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, let''s define some basic metadata about our application using these
    arguments in `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Metadata such as this will be used in naming the package as well as providing
    information for PyPI. Not all of the fields are necessary if you are just packaging
    for personal or internal use, but if you plan to upload to PyPI, you should include
    all these fields as well as `long_description`, which should be a reStructuredText
    string that provides extended information about the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, the `README.rst` file can simply be used. Since this configuration script
    is just a Python script, we can use normal Python to read the file and use its
    contents for this configuration option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Packages and dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have specified the metadata, we need to tell `setuptools` which packages
    we''re actually bundling using the `packages` argument. In our case, we only have
    the `abq_data_entry` package, so we''ll specify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've specified both the main package and the sub-modules `images`
    and `test`. We need to specify all the sub-modules we want to include explicitly
    here, as `setuptools` will not automatically include them.
  prefs: []
  type: TYPE_NORMAL
- en: 'That could get tedious with very complex packages, so `setuptools` also includes
    the `find_packages()` function, which can be used instead like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will locate and include all the packages in our project directory automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the modules defined in our project, our application depends on
    third-party modules such as `psycopg2`, `requests`, `paramiko`, and `matplotlib`.
    We can specify these dependencies in `setup()`, and, assuming they're available
    from PyPI, `pip` will install them automatically when our package is installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done using the `install_requires` argument as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that these required packages may have their own dependencies as well; for
    example, `matplotlib` requires several other libraries including `numpy` and `pillow`.
    We don't have to specify all of those sub-dependencies; they will also be automatically
    installed by `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the package requires particular versions of these modules, we can specify
    that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This looks rather familiar, doesn't it? These are the same kind of rules we
    can put in `requirements.txt`, and the same list of runtime dependencies. Some
    developers take the approach of just reading in `requirements.txt` and sending
    its contents to the `install_requires` list; there are even tools available to
    help translate some of the incompatible syntax between them. Remember, though,
    that the intention of our `requirements.txt` file was to recreate our specific
    development environment. As such, it contains non-runtime packages, and may have
    very specific version specifiers for the sake of testing consistency. The `install_requires`
    list, by contrast, is meant solely for runtime requirements, and in general should
    be more abstract about versions and package sources. For example, while it might
    be helpful to specify `psycopg2` version `2.9.1` for the development environment,
    unless we know for certain that it only works correctly with that one version,
    we would specify something more general here like `psycopg2<3.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we can specify package version requirements, we can also specify the
    version of Python required by our application using the `python_requires` argument,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is always a good idea to do if you're using Python features not found in
    earlier releases (for example, the f-strings used in our application do not work
    before Python 3.6), or if you want to be sure that only a specific, tested version
    of Python is used. If the user is not running a matching version of Python, `pip
    install` will abort with an error.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for version specifiers used in `setuptools` is laid out in PEP 440,
    which you can find at [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding extra files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, `setuptools` will only copy Python files into your package. Our
    package contains more than that, though: we have documentation in RST, SQL scripts,
    and most importantly our PNG images, without which our program won''t run correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Non-Python files that are located *inside* our package structure can be specified
    using the `package_data` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `package_data` argument takes a dictionary that matches module paths to
    a list of files (or globbing expressions that match a list of files) to be included
    in that module. Here, we're telling `setuptools` to include all the PNG and XBM
    files in the `images` module.
  prefs: []
  type: TYPE_NORMAL
- en: Our project also contains necessary files outside the `abq_data_entry` module;
    these aren't needed for the program to operate, but should nevertheless be distributed
    with the package. We cannot specify these in `setup()`, since it only deals with
    the in-package files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add these, we need to create a separate file in the project root directory
    called `MANIFEST.in`. For our application, the file should contain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `MANIFEST.in` file contains a series of the `include` directives with filenames
    or globbing expressions that match files we want to include. Here, we're including
    all files in our `docs` directory, all the `.sql` files in the `sql` directory,
    the `requirements.txt` file, and the `README.rst` file. Since `setup.py` relies
    on the `README.rst` and `requirements.txt` files for setup data, it's imperative
    that we include it in the package. Otherwise, our package won't be buildable on
    other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Defining commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, we created a `__main__.py` file in our package that allows our package
    to be run using the command `python -m abq_data_entry`. This is certainly cleaner
    than having to hunt down the right Python script to execute, but ideally we'd
    like our package to set up a simple command that a user can execute to launch
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: The `setuptools` library offers a way to add executable commands in our package
    using the `entry_points` argument. **Entry points** are ways for external environments
    to access our code. One particular entry point, `console_scripts`, defines a list
    of module functions that will be mapped to external commands. When the package
    is installed, `setuptools` will create a simple, platform-appropriate executable
    file for each `console_scripts` item that, when executed, will run the function
    specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t point `console_scripts` to a Python file or package, however; it
    must point instead to a *function* inside the package. This is why we created
    the `main()` function in our `__main__.py` file earlier, so that we can specify
    `__main__.main()` as a console script entry point, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Each item in the `console_scripts` list is a string in the format `{executable_name}
    = {module}.{submodule}:{function_name}`. Our code here will cause `setuptools`
    to create an executable called `abq`, which will run the `main()` function we
    defined in `__main__.py`. Thus, after installation, we can execute the application
    by just typing `abq` at a command line. You could define other scripts here if
    there were functions in the package that could run standalone.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we move on to creating distributable packages from our configuration,
    we can check it for proper syntax and content by running the following command
    in the project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If all is well, this will simply return the string `running check` with no
    other output. If something were missing, you would get an error message. For example,
    if you comment out the `name` and `version` arguments to `setup()` and run the
    check, you''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While it won't find every potential problem with your `setup.py`, the `check`
    command will at least ensure you have the essential metadata specified, which
    is especially important if you wish to upload your package to PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using source distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our configuration files all set, we can now create a **source distribution**.
    This kind of distribution bundles all the relevant files for building our package
    from source into a `.tar.gz` archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the source distribution, run `setup.py` with the `sdist` option in
    the project root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, two new directories will appear under the project root:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABQ_Data_Entry.egg-info`: This directory contains the metadata files generated
    by `setuptools`. If you explore this directory, you''ll find that all the information
    we passed to `setup()` is here in some form or other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dist`: This directory contains the files generated for distribution; in this
    case, there is just a single `.tar.gz` file that contains our source package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To install the source distribution on another computer, it first needs to be
    extracted. This can be done with GUI utilities or in a terminal with the `tar`
    command, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once extracted, we can install the package by running `setup.py` inside the
    extracted directory using the `install` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Testing our source distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't have a second computer handy to test your source installer on,
    you can use a Python **virtual environment** instead. A virtual environment is
    a clean, isolated Python installation that can be activated on demand to keep
    installed packages from polluting your system's main Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create one, first make sure you have the `virtualenv` package installed
    using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a directory anywhere on your system and generate a Python 3 environment
    in it with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will create a virtual environment, essentially a copy of the Python interpreter
    and standard library, in the `testenv` directory along with some supporting scripts
    and files. This environment can be modified in any way you wish without affecting
    your system's Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the new virtual environment, you need to **activate** it by executing
    the following code in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Activating a virtual environment means that invocations of `python` will use
    the binaries and libraries in the virtual environment rather than your system
    installation. This includes Python-related commands like `pip`, meaning that a
    `pip install` will install packages to the environment's library rather than to
    your system or user Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: With your test environment active, you can now run `setup.py install` on your
    source distribution. You'll notice that Python will install `psycopg2`, `requests`,
    `paramiko`, and `matplotlib`, as well as their individual dependencies, even if
    you already have those packages on your system. That's because the virtual environment
    starts clean with no third-party packages, so everything must be installed again
    in the new environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the install was successful, you should find the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a command called `abq` available in your virtual environment, which
    launches the ABQ Data Entry application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can open a Python prompt from any directory on the system (not just in the
    project root) and import `abq_data_entry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `abq_data_entry` package directory can be found in `testenv/lib/python3.9/sitepackages`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When finished with your virtual environment, you can type `deactivate` in the
    terminal to go back to your system Python. If you want to remove the environment,
    just delete the `testenv` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Building a wheel distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While a source distribution may be fine for simple software such as our application,
    packages with complicated build steps such as code compilation may benefit from
    a **built distribution**. As the name implies, a built distribution is one where
    any building operations (compilation or code generation, for example) has already
    been done. The current format used by `setuptools` for built distributions is
    the **wheel format**.
  prefs: []
  type: TYPE_NORMAL
- en: The wheel format replaces an older `distutils` distribution format called `egg`.
    You will still see references to `egg` when using `setuptools` or other `distutils`
    derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `wheel` (`.whl`) file is basically a ZIP-format archive file containing pre-built
    code. It comes in the following three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Universal**: This type of `wheel` file contains only Python code that will
    run on any platform with any major version of Python (2 and 3).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure Python**: This type of `wheel` file contains only Python code that will
    run on any platform, but is compatible with only one version of Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform**: This `wheel` file is limited to a particular OS, platform, or
    architecture, usually because it contains compiled binary code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default `wheel` file created by `setuptools` is a pure Python wheel, which
    is what our application should be (since we have no compiled code, but are compatible
    only with Python 3). Creating one is simply a matter of calling `setup.py` with
    the `bdist_wheel` option, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `sdist`, this command creates a new file in the `dist` directory, only
    this time it''s a `.whl` file. The filename will be `ABQ_Data_Entry-1.0-py3-none-any.whl`,
    the segments of which represent the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: The package name, in this case `ABQ_Data_Entry`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version, in this case `1.0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether it's Python 3, Python 2, or universal; in this case, `py3` for Python
    3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Application Binary Interface** (**ABI**) tag, which would indicate a particular
    implementation of Python (for example, CPython vs. IronPython). In this case,
    it's `none`, since we have no particular ABI requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The supported platform, in this case `any`, since our application is not platform-specific.
    Note that this component can include a CPU architecture as well as an operating
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the `bdist_wheel` process also creates a `build` directory, which
    is where built code is staged before it is compressed into the `wheel` file. You
    can inspect this directory to make sure that your package is being assembled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once built, your `wheel` file can be installed using `pip`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As with the source install, `pip` will first install any dependencies specified
    in the setup configuration, then install the package itself to the environment's
    `site-packages` directory. The executable `abq` file will also be created and
    copied to an executable location appropriate to your platform.
  prefs: []
  type: TYPE_NORMAL
- en: If you get an error when trying to use `bdist_wheel`, you may need to install
    the `wheel` module, as it's not always included with `setuptools`. This module
    can be installed with the command `pip install --user wheel`. Recall that we specified
    `wheel` as a build dependency in `pyproject.toml`, though, so this step should
    be taken care of by `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating executables with cx_Freeze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While source and wheel distributions are useful, they both require that Python
    and any third-party library dependencies be installed on the system before the
    program can be run. Often, it would be much handier if we could provide a file
    or set of files that can simply be copied and run on a system without installing
    anything else first. Better yet, we'd like to have platform-appropriate installation
    packages that set up desktop shortcuts and perform other common system configurations.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to go about this with Python code, and several projects
    to choose from; in this book, we're going to look at one called `cx_Freeze`.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea of `cx_Freeze` is to bundle up all the code and shared library
    files for a Python project along with a Python interpreter, and then generate
    a small executable file that will launch the code with the bundled interpreter.
    This approach is commonly known as **freezing** the code (hence the package name),
    and it works fairly well most of the time. However, as we'll see, there are some
    limitations and difficulties to work around. One significant limitation is that
    `cx_Freeze` can only make executables for the platform that it's running on; in
    other words, if you want a Windows executable, you'll need to build it on Windows;
    if you want a Linux executable, you'll have to build it on Linux, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Complete documentation on `cx_Freeze` can be found at [https://cx-freeze.readthedocs.io](https://cx-freeze.readthedocs.io).
  prefs: []
  type: TYPE_NORMAL
- en: First steps with cx_Freeze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install `cx_Freeze` using `pip` as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Linux users may also need to install the `patchelf` utility, generally available
    in your distribution's package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `setuptools`, `cx_Freeze` is an extension of `distutils`; it shares many
    similarities with `setuptools`, but as you''ll see, it takes a different approach
    to solving certain problems. Just like `setuptools`, we''ll start with a script
    in the project directory that calls the `setup()` function. To distinguish this
    script from our `setuptools` script, we''ll call it `cxsetup.py`. Open this file
    and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So far, this is identical to a `setuptools` script apart from us using the `cx_Freeze.setup()`
    function instead of the `setuptools` one. From here, though, things will diverge
    considerably.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where `setuptools` uses the `entry_points` argument, `cx_Freeze` uses an `executables`
    argument. This argument takes a list of `cx_Freeze.Excecutable` objects, each
    of which describes various attributes of an executable file we want to generate.
    Add the following code that does this for ABQ Data Entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At a minimum, we need to provide a Python script that should be executed when
    the executable will run; we're using our `abq_data_entry/__main__.py` script for
    this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the generated executable will be the script name without the `.py`
    extension. In this case, that would be `__main__`, which is not a terribly descriptive
    name for our application. Fortunately, we can override this default with the `target_name`
    argument, as we've done here. By specifying `abq` here, `cx_Freeze` will build
    an executable file called `abq`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify an icon to use for the application using the `icon` argument.
    This needs to be a path to a `.ico` file, so you'll need to convert PNG or other
    formats to `.ico` before using them. The path to the file is relative to the project
    directory where the `cxsetup.py` file is, and does not need to be inside the package
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The build_exe options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arguments to specific `cx_Freeze` operations can be passed into `setup()` using
    the `options` argument. This argument takes a dictionary in which each item is
    a `cx_Freeze` operation name paired with a `dict` object of operation-specific
    arguments. The first operation we're going to look at is `build_exe`, which is
    a universal first step for all other operations. As the name implies, this is
    the stage where the executable and its accompanying files are built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Among other things, this is where we specify the package dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `packages` argument is a list of the packages that need to be installed.
    It's similar to the `install_requires` argument for `setuptools`, with the important
    difference that it does not support version specifiers. Also, note that we've
    included some things beyond our three main dependencies. Unfortunately, because
    `cx_Freeze` doesn't always do a great job at identifying all the dependencies,
    it's often necessary to explicitly list sub-dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Where `packages` is a list of the packages that should be included, we can also
    specify specific *modules* to be included using the `includes` argument. In theory,
    we shouldn't need to specify anything here, but in practice `cx_Freeze` sometimes
    fails to bundle modules that our program needs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `includes` directive, we can explicitly request modules to ensure
    that they are included.
  prefs: []
  type: TYPE_NORMAL
- en: 'To figure out what should go in the list, follow a basic trial-and-error procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you get a `ModuleNotFoundError` exception stating that a module cannot be
    found, add the module to the `includes` list and run the build command again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you find several modules from the same package are missing, it may be more
    effective to add the package to the `packages` list and rebuild.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, suppose you build ABQ Data Entry and get the following error when
    running `abq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this situation, `zlib` would be a dependency of one of our required packages
    that for some reason `cx_Freeze` did not identify as necessary. To fix this, we
    would simply force its inclusion by updating the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After that, a rebuilt executable should include the missing module. Generally,
    you don't need to do this for widely used modules, but depending on your platform
    and the packages you require, these issues do come up.
  prefs: []
  type: TYPE_NORMAL
- en: Including external files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with `setuptools`, `cx_Freeze` only includes Python files by default. To
    get other files like images and documentation included, we can use the `include_files`
    argument to `build_exe`. However, there is a problem: because of the way that
    `cx_Freeze` bundles our Python module in a compressed archive, accessing file
    paths inside the module takes some extra code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `images` module presents such a problem: it contains PNG files that our
    application accesses by calculating a relative path from its `__init__.py` file.'
  prefs: []
  type: TYPE_NORMAL
- en: To address the issue, the PNG files will need to be relocated to a directory
    outside the package during the build process. Our code will then have to find
    them in the new location when it's been frozen, and in the original location when
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it work, modify `images/__init__.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When running a Python script that has been frozen using `cx_Freeze`, the `sys`
    module has an attribute called `frozen`. We can test for the presence of this
    attribute to specify behavior that changes when the app is frozen. In this case,
    when our app is frozen, we're going to look for our images in an `images` directory
    located in the same directory as the executable file. The location of the executable
    can be found from the `sys.executable` variable. If the application is not frozen,
    we'll look for the images in the module directory as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the script knows where to look for the images, we need to configure
    our `cx_Freeze` setup to copy the images into the location we set. To do that,
    we need to update our `build_exe` options like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `include_files` argument is a list of two-tuples. The first tuple member
    is a source path relative to the `cxsetup.py` script, while the second is a destination
    path relative to the executable file. In this case, we're telling it to copy the
    files in the `abq_data_entry/images` directory to a directory called `images`
    in the generated executable directory.
  prefs: []
  type: TYPE_NORMAL
- en: Building executables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we can build an executable by running the following command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `build` command runs all steps up to `build_exe`, leaving you with the built
    code in a platform-specific directory under `./build` in the format `exe.(os)-(cpu_arch)-(python_version)`.
    For example, if you ran this command on 64-bit Linux with Python 3.9, you'd have
    a `build/exe.linux-x86_64-3.9` directory containing the compiled code. You can
    inspect this directory to make sure files are being copied over and created properly,
    as well as testing the generated executable binary file. In the case of our application,
    `cx_Freeze` should have created a binary executable file called `abq`, which will
    launch your application when run. It should also have created `lib` and `images`
    directories, and copied the `abq.ico` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all files in the platform-specific build directory must be present
    for the program to run; `cx_Freeze` does not support the creation of single-file
    standalone executables.
  prefs: []
  type: TYPE_NORMAL
- en: For Linux and BSD, this build directory can be zipped up and distributed as
    is; users on other computers should be able to just extract the directory and
    execute the file. For Windows and macOS, though, we're going to need to do some
    more work to get it ready for distribution. In fact, you may even have gotten
    an error running the build command or executing the binary. We'll talk about the
    platform-specific tweaks and configurations that need to happen in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '`cx_Freeze` supports the creation of RPM files, the package format used by
    certain Linux distributions such as Fedora or SUSE. If you''re on an RPM-based
    distribution, you may want to investigate this option. Unfortunately, there is
    no build operation to build packages for non-RPM distributions such as Debian,
    Ubuntu, or Arch.'
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up the build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we have a working executable file, you might have noticed that the
    distributable folder is extremely large for such a simple project as ours.
  prefs: []
  type: TYPE_NORMAL
- en: Before calling it a day, it's worth poking around inside the build directories
    to see what files `cx_Freeze` is bundling into your application and whether you
    really need all of it.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the platform-specific build directory under `lib/python(python_version)/`,
    you'll find all the libraries that were pulled in as dependencies of our package.
    You may find that some of these aren't actually necessary for running our application.
    For example, if you happen to have alternative GUI libraries like PyQt or PySide
    installed on your system, `matplotlib` may pull them in as dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do end up with extra packages like this, we can remove them using the
    `excludes` option of `build_exe`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: After adding this change, delete your `build` directory and rerun the build
    command. You'll see that all these packages are no longer there, and the size
    of your build is significantly smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what can be included or excluded takes research and some trial and error,
    but with careful pruning we can bring down the size of our distributable files
    and the build time for our package considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Building Windows executables with cx_Freeze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build executables on Microsoft Windows, we need to properly set the `base`
    argument to the `Executable` initializer. Recall from *Chapter 10*, *Maintaining
    Cross-Platform Compatibility*, that Windows programs launch in either console
    or GUI mode. For each platform, `cx_Freeze` has one or more base executables from
    which it builds the frozen executable; on Linux, BSD, and macOS the default base
    executable is acceptable, but on Windows the default base launches the application
    in console mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to specify a base that will launch our script in GUI mode instead.
    This can be done by passing a value of `Win32GUI` to the `base` argument. So,
    at the top of our `cxsetup.py` script, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As we learned to do in *Chapter 10*, *Maintaining Cross-Platform Compatibility*,
    we've used `platform.system()` to determine the operating system we're running
    on; if it's Windows, we'll set the base to `Win32GUI`. For other platforms, `base`
    should just be `None`, causing it to use the default base executable.
  prefs: []
  type: TYPE_NORMAL
- en: The application should now build successfully on Windows using `python cxsetup.py
    build`, and you should find `abq.exe` in the `build/exe.win-amd64-(python_version)`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Windows installer file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to building a Windows executable, we can build a Windows installer
    file (`.msi`) using the `bdist_msi` operation. While our application could be
    distributed as is by simply zipping up the build folder and extracting it on the
    target system, there are a few advantages to using MSI files:'
  prefs: []
  type: TYPE_NORMAL
- en: MSI files can be more easily deployed by system administrators in a large-scale
    Windows environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSI files register the application with the OS when installed, making operations
    like upgrades, repairs, and uninstallations cleaner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MSI files have additional setup capabilities, such as an install wizard and
    desktop shortcut generation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started generating an MSI file with `cx_Freeze`, we'll need to configure
    some aspects of our MSI by setting values in the `bdist_msi` dictionary of the
    `options` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by specifying an **upgrade code**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The upgrade code is a **globally unique identifier** (**GUID**) value that will
    identify this program on the OS. By specifying this, subsequent builds of this
    `.msi` file will remove and replace any existing installations of the same program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upgrade codes consist of five segments of 8, 4, 4, 4, and 12 characters from
    0 to 9 and A to F. They can be created in Microsoft Visual Studio, or using this
    PowerShell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once specified, you should not change the upgrade code in subsequent builds
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The MSI installation process can also create application shortcuts, which will
    be placed on the desktop and/or programs menu when the package is installed. To
    do this, we''ll need to define our shortcuts by creating a list of **shortcut
    table** tuples like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding two tuples define a shortcut for the desktop and menu, respectively.
    The data contained in them matches the shortcut table layout described by Microsoft
    at [https://msdn.microsoft.com/en-us/library/windows/desktop/aa371847.aspx](https://docs.microsoft.com/en-us/windows/win32/msi/shortcut-table?redirectedfrom=MSDN).
  prefs: []
  type: TYPE_NORMAL
- en: 'Those fields, in order, are defined by Microsoft as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shortcut**: The type of shortcut to create; in our case either `DesktopShortcut`
    or `MenuShortcut`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directory**: A special directory key into which the shortcut will be copied.
    Here, `DesktopFolder` points to the desktop, and `ProgramMenuFolder` points to
    the programs folder in the menu.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Name**: The name of the shortcut; in our case, `ABQ Data Entry`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component**: This indicates a program whose installed or uninstalled state
    determines whether our shortcut should be installed or uninstalled. By specifying
    `TARGETDIR`, the install/uninstall state of our shortcuts matches the install/uninstall
    state of the program directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: The executable file that is launched by the shortcut. This will
    be our `target_name` attribute, located inside `TARGETDIR`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arguments**: A string of arguments passed to the command. Whatever you specify
    here is simply appended to the target executable for the shortcut and available
    in our program from `sys.argv`. You might use this to, for example, create a second
    shortcut that launches your application in a test mode. In our case, the ABQ program
    expects no command-line arguments, so this is `None`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A string used in the description field of the shortcut.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Icon** and **IconIndex**: These are used to locate an icon for the shortcut,
    if we want it to be different from the icon of the executable. These can be left
    as `None` since our executable''s icon will be used by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ShowCmd**: Specifies if the program will be launched minimized, maximized,
    or normally. Leaving this as `None` will launch it normally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WkDir**: Indicates the working directory to be used. We want this to be the
    program''s directory, so we use `TARGETDIR` here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once created, these shortcut tables need to be included in the data argument
    of our `bdist_msi` options, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Currently, `data` is not documented in the `cx_Freeze` documentation; `cx_Freeze`
    uses the standard library's `msilib` module to build the `.msi` files, and anything
    passed into this argument is passed along to the `add_data()` function of `msilib`.
    Refer to the standard library documentation for `msilib` at [https://docs.python.org/3/library/msilib.html](https://docs.python.org/3/library/msilib.html)
    if you're interested in exploring this option further.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `bdist_msi` options specified, let''s build the `.msi` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a new installer file in the `dist` directory, which you
    should be able to install on any compatible Windows system, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1: The MSI install wizard for ABQ Data Entry](img/B17578_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: The MSI install wizard for ABQ Data Entry'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that `cx_Freeze` uses Python binaries from your build environment
    in the application build; as a result, 64-bit Python will build a 64-bit executable,
    and 32-bit Python will build a 32-bit executable. Additionally, builds created
    on newer versions of Windows may not be compatible with older versions of Windows.
    For maximum compatibility, build your binaries on a 32-bit version of the oldest
    release of Windows you plan to support.
  prefs: []
  type: TYPE_NORMAL
- en: Building macOS executables with cx_Freeze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two build operations that `cx_Freeze` implements that are specific
    to macOS: `bdist_mac` and `bdist_dmg`. These operations create an **application
    bundle** and a **compressed disk image** file, respectively. Let''s look at each
    operation in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: Building macOS application bundles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `bdist_mac` build operation creates an application bundle, a specially
    formatted directory with an `.app` extension that the Mac desktop treats as though
    it were an executable file. `bdist_mac` has several configuration options, but
    we''re only going to use two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, `bundle_name` sets the name of our application bundle directory, without
    the `.app` extension. Normally, this would default to the `name` argument passed
    to `setup()`, which in our case is `ABQ_Data_Entry`. We're overriding it here
    to use dashes instead of underscores, as it looks a little less technical for
    end users. Note that using spaces in this value, while technically valid, tends
    to create problems for `cx_Freeze` and is best avoided. The `iconfile` setting
    allows us to point to an ICNS file that macOS will use for the application's icon.
    The dimensions of this image file need to be a square number of pixels that is
    a power of 2 between 16 and 1,024\. A compatible ABQ logo is included in the example
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the `cx_Freeze` documentation for additional options here, which include
    code signing and explicitly specifying additional frameworks for the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your configuration options are added, run the `cxsetup.py` script by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When this process completes, `ABQ-Data-Entry.app` should appear in the build
    directory. You can double-click this directory in the macOS GUI to run it from
    any location, or drag it to the `/Applications` directory to install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should appear something like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2: ABQ-Data-Entry bundle in the build directory](img/B17578_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: ABQ-Data-Entry bundle in the build directory'
  prefs: []
  type: TYPE_NORMAL
- en: If you launch the application from this bundle, you'll see that the app menu
    no longer reads **Python**, as we first saw in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*; it now reads **abq**, the name of the executable file, which is
    what we want.
  prefs: []
  type: TYPE_NORMAL
- en: As with Windows executables, `cx_Freeze`-generated bundles for macOS are not
    necessarily backward-compatible, so it's best to create them on the oldest version
    of macOS that you need to support.
  prefs: []
  type: TYPE_NORMAL
- en: Building macOS .dmg files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applications on macOS are generally distributed inside a compressed disk image
    (`.dmg`) file. The `cx_Freeze` `build_dmg` operation allows you to build an application
    bundle and package it in a DMG file for easy distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, simply execute this command instead of the `bdist_mac` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This command first runs `bdist_mac` to build the application bundle and then
    packages it into a DMG file. The configuration options for `bdist_dmg` allow you
    to override the filename and include a shortcut to the `/Applications` directory
    for easy installation. The built file will appear in the `build` directory, from
    which you can copy it to another Macintosh to be mounted and used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to prepare and package your application for
    distribution. You learned how to make your package executable, and how to use
    `setuptools` to create source and built distributions of it for internal use within
    your organization or for distribution in a public index such as PyPI. You also
    learned how to use `cx_Freeze` to convert your Python script into an executable
    file that can be distributed to other systems without installing Python or dependent
    packages, and how to make application installation packages for Windows and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on finishing this book! Together we've taken a simple CSV file
    and turned it into a complex and robust graphical application. You now have the
    knowledge and confidence to create user-friendly GUI applications that work with
    files, databases, networks, and APIs across all major platforms.
  prefs: []
  type: TYPE_NORMAL
- en: As for your career with ABQ, you've just received a promotion offer to work
    with the corporate office as a software developer. There will be much more to
    learn, but with the skills you've learned so far you are ready for whatever challenges
    come next. Good luck!
  prefs: []
  type: TYPE_NORMAL
