- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Packaging with setuptools and cxFreeze
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 setuptools 和 cxFreeze 打包
- en: Word of your application has spread throughout the ABQ corporation, and you've
    been asked to provide it for use at other facilities. Unfortunately, running and
    installing the application is not a very friendly process; you've been installing
    it through a tedious and error-prone copy-and-paste procedure, and users launch
    it from a batch or shell script you create by hand on each machine. You need to
    package your application in a professional way that makes it easy to install and
    run across Windows, macOS, and Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序在 ABQ 公司内部广为人知，你被要求在其他设施中使用它。不幸的是，运行和安装应用程序的过程并不友好；你一直通过繁琐且容易出错的复制粘贴过程来安装它，并且用户从你在每台机器上手动创建的批处理或脚本中启动它。你需要以专业的方式打包你的应用程序，使其在
    Windows、macOS 和 Linux 上安装和运行变得容易。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: In *Creating distributable packages with setuptools*, you'll learn to create
    distributable Python source and `wheel` packages using the `setuptools` library.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用 setuptools 创建可分发软件包* 中，你将学习如何使用 `setuptools` 库创建可分发的 Python 源代码和 `wheel`
    软件包。
- en: In *Creating executables with cx_Freeze*, you'll learn to create a standalone
    executable of your application, including specific instructions for Windows and
    macOS.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *使用 cx_Freeze 创建可执行文件* 中，你将学习如何创建应用程序的独立可执行文件，包括针对 Windows 和 macOS 的具体说明。
- en: Creating distributable packages with setuptools
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 setuptools 创建可分发软件包
- en: The distribution process has often been cited as a major shortcoming for Python;
    it is an area with a storied history of ever-evolving tools and approaches, often
    caught between the vestiges of the past and competing visions of the future.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 分发过程经常被引用为 Python 的一个主要缺点；这是一个有着不断发展的工具和方法的悠久历史领域，常常处于过去的遗迹和未来竞争愿景之间。
- en: That said, it works surprisingly well, as evidenced by the ease with which we
    have installed components using `pip` throughout this book. The aim of this section
    is to cut through some of the confusion and provide you with a process that respects
    both traditional approaches and future trends.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，它的工作效果出奇地好，正如我们在整本书中通过 `pip` 安装组件的便利性所证明的那样。本节的目标是消除一些混淆，并为你提供一个既尊重传统方法又符合未来趋势的流程。
- en: The standard library contains the `distutils` library, a collection of functionalities
    related to packaging and distributing Python code. However, both the `distutils`
    documentation ([https://docs.python.org/3/library/distutils.html](https://docs.python.org/3/library/distutils.html))
    and the official packaging guide recommend against using it and instead direct
    you to use `setuptools`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包含 `distutils` 库，这是一个与打包和分发 Python 代码相关的功能集合。然而，`distutils` 文档（[https://docs.python.org/3/library/distutils.html](https://docs.python.org/3/library/distutils.html)）和官方打包指南都建议不要使用它，而是建议你使用
    `setuptools`。
- en: The `setuptools` library is an extension of the `distutils` library that adds
    some important functionality such as dependency handling, bundling non-Python
    files, and generation of executables. Although `setuptools` is not part of the
    standard library, it is included in the official Python distributions for Windows
    and macOS, and is readily available from the package repositories of most Linux
    distributions. `setuptools` is used by the `pip` package installer, and we can
    use it to create packages that can be installed on any system with Python and
    `pip`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools` 库是 `distutils` 库的扩展，它增加了一些重要的功能，例如依赖关系处理、打包非 Python 文件以及生成可执行文件。尽管
    `setuptools` 不是标准库的一部分，但它包含在 Windows 和 macOS 的官方 Python 发行版中，并且可以从大多数 Linux 发行版的软件仓库中轻松获取。`setuptools`
    被用于 `pip` 软件包安装器，我们可以使用它来创建可以在任何安装了 Python 和 `pip` 的系统上安装的软件包。'
- en: If you want to create packages that can be uploaded to PyPI, `setuptools` is
    what you need. For more information about preparing and uploading packages to
    PyPI, see the official Python packaging guide at [https://packaging.python.org](https://packaging.python.org).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建可以上传到 PyPI 的软件包，你需要 `setuptools`。有关准备和上传软件包到 PyPI 的更多信息，请参阅官方 Python 打包指南，网址为
    [https://packaging.python.org](https://packaging.python.org)。
- en: Preparing our package for distribution
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备我们的软件包以供分发
- en: Although the restructuring of our project directory we did in *Chapter 6*, *Planning
    for the Expansion of Our Application*, left us in fairly good shape for packaging
    our application, there are a few minor additions and changes we need to make for
    our Python package to be a good citizen as a distributed package. Let's go through
    what those are.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在 *第 6 章* 中对项目目录进行的重构，即 *为应用程序的扩展做准备*，使我们能够很好地打包我们的应用程序，但我们需要对 Python 包进行一些小的添加和更改，以便它作为一个分布式包成为良好的公民。让我们来看看这些是什么。
- en: Creating a requirements.txt file
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 requirements.txt 文件
- en: The `requirements.txt` file is a plaintext file, typically placed in the application
    root directory, that lists all the third-party modules that we used to develop
    our application. Although not used by `setuptools`, this file can be used by `pip`
    to install a package's dependencies.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt` 文件是一个纯文本文件，通常放置在应用程序根目录中，列出了我们用于开发应用程序的所有第三方模块。尽管此文件不被 `setuptools`
    使用，但它可以被 `pip` 用于安装包的依赖项。'
- en: 'Create a `requirements.txt` file that contains the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 `requirements.txt` 文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line of the file specifies the index from which we want to install
    packages; strictly speaking, this line isn't necessary since PyPI will be used
    by default. However, we can override this URL if we want to use a different package
    index; for example, if ABQ decided to create its own private Python package index
    for security reasons, we could redirect `pip` to that server instead.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一行指定了我们要从哪个索引安装包；严格来说，这一行不是必需的，因为默认情况下会使用 PyPI。然而，如果我们想使用不同的包索引，我们可以覆盖这个
    URL；例如，如果 ABQ 决定出于安全原因创建自己的私有 Python 包索引，我们可以将 `pip` 重定向到那个服务器。
- en: 'Next, we''ve specified runtime requirements. Our application depends on four
    external libraries: `requests`, `paramiko`, `psycopg2`, and `matplotlib`, and
    these are simply specified one per line. Note that we can also add comments to
    the file by beginning a line with a `#` sign.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们已指定了运行时需求。我们的应用程序依赖于四个外部库：`requests`、`paramiko`、`psycopg2` 和 `matplotlib`，这些库简单地按行指定。请注意，我们也可以通过在行首添加
    `#` 符号来向文件添加注释。
- en: Finally, we've included `flask` as a requirement, which is not used by the application
    but was required by the test service we used for REST. It might seem odd to include
    these kinds of requirements, but the purpose of the `requirements.txt` file is
    to make it simple for other developers (including your future self) to reproduce
    the development environment for this application. You might choose to place non-runtime
    requirements like this in a separate file, for example, `requirements.development.txt`
    or `requirements.testing.txt.`
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经将 `flask` 作为依赖项包含在内，尽管它没有被应用程序使用，但它是我们用于 REST 的测试服务所要求的。包含这类需求可能看起来有些奇怪，但
    `requirements.txt` 文件的目的就是让其他开发者（包括你未来的自己）能够轻松地重现这个应用程序的开发环境。你可能选择将这类非运行时需求放在一个单独的文件中，例如，`requirements.development.txt`
    或 `requirements.testing.txt`。
- en: 'This file can then be used to direct `pip` to install these dependencies using
    the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用以下命令使用此文件指导 `pip` 安装这些依赖项：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command causes `pip` to read through the file one line at a time to install
    the dependencies. For each dependency, `pip` will first check to see if the package
    is already installed; if not, it will install the latest version of the package
    from the specified package index.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会导致 `pip` 逐行读取文件以安装依赖项。对于每个依赖项，`pip` 会首先检查该包是否已经安装；如果没有，它将从指定的包索引安装该包的最新版本。
- en: This presents a small problem, though; what if our code depends on a newer version
    of the package than the user has installed on their system? Or, what if an incompatible
    change in a newer version of a library requires that we run an older version than
    the latest in the index?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这虽然带来了一点小问题；如果我们的代码依赖于用户系统上安装的包的新版本，会发生什么？或者，如果库的新版本中的不兼容更改要求我们运行比索引中最新版本更旧的版本，会发生什么？
- en: 'To address this, we can include version specifier strings in `requirements.txt`,
    like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在 `requirements.txt` 中包含版本指定符字符串，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A version specifier consists of a comparison operator followed by a version
    string. This will direct `pip` to ensure that the version installed matches the
    requirement; in this case, it would specify the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 版本指定符由一个比较运算符后跟一个版本字符串组成。这将指导 `pip` 确保安装的版本与要求匹配；在这种情况下，它将指定以下内容：
- en: '`requests` would have to be *exactly* version 2.26.0'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requests` 必须是 *正好* 版本 2.26.0'
- en: '`paramiko` would have to be at least 2.6 or higher'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paramiko` 至少需要 2.6 或更高版本'
- en: '`psycopg2` would have to be less than 3.0'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psycopg2` 必须小于 3.0'
- en: '`matplotlib` would have to be greater than 3.2 (not including 3.2!), but 3.3
    or lower'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matplotlib` 必须大于 3.2（不包括 3.2！），但 3.3 或更低版本'
- en: Whether you include version specifiers, and how specific you make them, depends
    somewhat on the needs of your project and users. In general, you shouldn't limit
    `pip` from installing newer versions of a library so that you don't miss out on
    bug fixes and security patches, but in situations where there are known bugs with
    newer versions, it may be essential.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否包含版本指定符，以及你使它们有多具体，这在一定程度上取决于你的项目和用户的需求。一般来说，你不应该限制 `pip` 安装库的新版本，以免错过错误修复和安全补丁，但在存在已知新版本错误的情况下，这可能至关重要。
- en: The command `pip freeze` will print a list of all your installed packages with
    exact versions specified. Developers in mission-critical environments who want
    to guarantee the ability to reproduce their exact development environment often
    just copy this output directly to `requirements.txt`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip freeze` 命令将打印出所有已安装的包及其确切版本列表。在关键任务环境中工作的开发者，他们希望确保能够重现其确切的开发环境，通常会直接将此输出复制到
    `requirements.txt` 文件中。'
- en: Creating a pyproject.toml file
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 pyproject.toml 文件
- en: Although `setuptools` is still the de facto standard for packaging Python projects,
    the Python community is moving toward tool-agnostic configuration to accommodate
    newer options as well. As part of this move, the official packaging guide recommends
    creating a `pyproject.toml` file in your project's root directory. Currently,
    this file is only used to specify your project's build system and build system
    requirements, but there is indication that more project settings will migrate
    to this file in the future.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `setuptools` 仍然是打包 Python 项目的既定标准，但 Python 社区正在向工具无关的配置转变，以适应新的选项。作为这一转变的一部分，官方打包指南建议在项目的根目录中创建一个
    `pyproject.toml` 文件。目前，此文件仅用于指定项目的构建系统和构建系统要求，但有迹象表明，未来更多的项目设置将迁移到该文件。
- en: 'For our project, the file should contain the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，文件应包含以下内容：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This file indicates that our project requires the `setuptools` and `wheel` packages,
    and that we're using `setuptools.build_meta` to actually build our project. These
    are the recommended configurations if you wish to use `setuptools` to build your
    project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件表示我们的项目需要 `setuptools` 和 `wheel` 包，并且我们正在使用 `setuptools.build_meta` 实际构建我们的项目。如果你希望使用
    `setuptools` 构建项目，这些是推荐的配置。
- en: Note that the requirements listed here are *build requirements*, meaning they
    are the packages required by the build tool used to create a distributable package.
    This is distinct from the requirements we listed in `requirements.txt`, which
    are the packages needed to *use* the package.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里列出的要求是 *构建要求*，这意味着它们是构建工具所需的包，用于创建可分发包。这与我们在 `requirements.txt` 中列出的要求不同，后者是需要使用包的包。
- en: '**TOML** (**Tom''s Obvious, Minimal Language**) is a relatively new configuration
    file format introduced in 2013\. It extends the traditional INI-style format with
    new features like hierarchical structures and nested lists. It is growing in popularity
    particularly as a configuration format for build tools in languages like Rust,
    JavaScript, and of course Python. Learn more about TOML at [https://toml.io](https://toml.io).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**TOML**（**Tom''s Obvious, Minimal Language**）是一种相对较新的配置文件格式，于 2013 年推出。它通过引入层次结构和嵌套列表等新特性扩展了传统的
    INI 风格格式。它在 Rust、JavaScript 以及当然还有 Python 等语言中作为构建工具的配置格式越来越受欢迎。更多关于 TOML 的信息请访问
    [https://toml.io](https://toml.io)。'
- en: Adding a license file
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加许可文件
- en: When you distribute code, it's important that the recipients know what they're
    allowed to do with that code. Unlike compiled languages such as C or Java, Python
    source code is necessarily included when you distribute your project using `setuptools`.
    To make sure that recipients use the code appropriately, we need to include a
    license file with our code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分发代码时，确保接收者知道他们可以如何使用该代码非常重要。与 C 或 Java 等编译型语言不同，当你使用 `setuptools` 分发项目时，Python
    源代码必然会被包含在内。为了确保接收者适当地使用代码，我们需要在我们的代码中包含一个许可文件。
- en: When deciding on a license, there are a few concerns you need to consider.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定许可时，你需要考虑一些问题。
- en: First, if you're developing software as part of your job (such as our ABQ Data
    Entry program), your employer typically owns the code and you need to make sure
    you're specifying their preferred license for the code. Consult your employer
    for their policy on this issue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果你在工作中开发软件（例如我们的ABQ数据录入程序），你的雇主通常拥有代码的所有权，你需要确保你指定了他们为代码所偏好的许可证。就这个问题咨询你的雇主以了解他们的政策。
- en: 'Second, if you''ve used third-party libraries, you''ll need to make sure your
    license is compatible with the license of those libraries. For example, if you
    are using a software library licensed under the **GNU Public License** (**GPL**),
    you may be required to release your software under the GPL or a similar, compatible
    license. Python and Tkinter are distributed under fairly permissive licenses;
    here are the licenses of our four dependencies:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果你使用了第三方库，你需要确保你的许可证与这些库的许可证兼容。例如，如果你正在使用许可为**GNU公共许可证**（**GPL**）的软件库，你可能需要将你的软件以GPL或类似、兼容的许可证发布。Python和Tkinter是以相当宽松的许可证分发的；以下是我们的四个依赖项的许可证：
- en: '| Package | License | Reference |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 包 | 许可证 | 参考 |'
- en: '| `requests` | Apache2 | [https://2.python-requests.org/projects/3/user/intro/](https://2.python-requests.org/projects/3/user/intro/)
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `requests` | Apache2 | [https://2.python-requests.org/projects/3/user/intro/](https://2.python-requests.org/projects/3/user/intro/)
    |'
- en: '| `paramiko` | LGPL 2.1 | [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko)
    (`LICENSE` file) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `paramiko` | LGPL 2.1 | [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko)
    (`LICENSE` 文件) |'
- en: '| `psycopg2` | LGPL 2.1 | [https://www.psycopg.org/license](https://www.psycopg.org/license)
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `psycopg2` | LGPL 2.1 | [https://www.psycopg.org/license](https://www.psycopg.org/license)
    |'
- en: '| `matplotlib` | Matplotlib License (BSD-based) | [https://matplotlib.org/stable/users/license.html](https://matplotlib.org/stable/users/license.html)
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `matplotlib` | Matplotlib 许可证（基于BSD） | [https://matplotlib.org/stable/users/license.html](https://matplotlib.org/stable/users/license.html)
    |'
- en: Be sure to consult these licenses before distributing your package to make sure
    you're complying with the requirements for software using the libraries. If neither
    of these situations applies, you should simply consider what license best suits
    the project and describes the intention you have in distributing it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在分发你的包之前，务必查阅这些许可证，以确保你遵守使用这些库的软件的要求。如果上述任何情况都不适用，你应该简单地考虑哪种许可证最适合项目，并描述你分发它的意图。
- en: Whichever you choose, this should be included in your project root directory
    in a file called `LICENSE`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种，都应该包含在你的项目根目录中，文件名为`LICENSE`。
- en: Making our package executable
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使我们的包可执行
- en: 'Up to this point in the project, we''ve been executing our application by running
    the `abq_data_entry.py` file, which we''ve placed in the project root directory
    *outside* the package. Ideally, though, we''d like all our Python code – even
    this trivial launcher script – to be located inside the package. We could just
    copy `abq_data_entry.py` into the package directory, right? It would seem that
    simple, but when we execute the script now we get an error:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过运行放置在项目根目录*外部*包中的`abq_data_entry.py`文件来执行我们的应用程序。理想情况下，我们希望所有我们的Python代码——甚至这个微不足道的启动脚本——都位于包内部。我们只需将`abq_data_entry.py`复制到包目录中，对吧？这似乎很简单，但当我们现在执行脚本时，我们得到了一个错误：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unfortunately, the relative imports we have in the package will not work correctly
    when executing code inside the package. However, Python provides a solution here:
    we can make our *package* executable, rather than relying on a particular Python
    *script* for execution.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们在包中使用的相对导入在包内部执行代码时将无法正确工作。然而，Python在这里提供了一个解决方案：我们可以使我们的*包*可执行，而不是依赖于特定的Python
    *脚本*来执行。
- en: To do that, we need to create a `__main__.py` file inside our package. This
    special file inside a Python package makes the package executable; when the module
    is executed, Python will run the `__main__.py` script. However, it will run it
    in a slightly special way that will allow our relative imports to work.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在我们的包内部创建一个`__main__.py`文件。这个Python包内的特殊文件使包可执行；当模块被执行时，Python将运行`__main__.py`脚本。然而，它将以一种稍微特殊的方式运行，这将允许我们的相对导入正常工作。
- en: 'Create a new file called `abq_data_entry/__main__.py` and add the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`abq_data_entry/__main__.py`的新文件，并添加以下内容：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The contents of `__main__.py` are nearly identical to `abq_data_entry.py`; the
    only difference is that we've put the creation of `Application` and the execution
    of `mainloop()` in a function called `main()`. The reason for this will be explained
    shortly when we start building our package.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`__main__.py`的内容几乎与`abq_data_entry.py`相同；唯一的区别是我们将`Application`的创建和`mainloop()`的执行放在了一个名为`main()`的函数中。原因将在我们开始构建包时简要解释。'
- en: 'Once we''ve created `__main__.py`, we can execute the module like so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`__main__.py`，我们可以像这样执行模块：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `-m` flag tells Python to load and execute the provided module. Note that,
    for the moment, this command must be executed inside the project root folder.
    Once we create and install our Python package, we'll be able to run it from anywhere.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m`标志告诉Python加载并执行提供的模块。注意，目前，这个命令必须在项目根目录内执行。一旦我们创建并安装了我们的Python包，我们就可以从任何地方运行它。'
- en: Configuring a setup.py script
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置`setup.py`脚本
- en: Now that our code is ready, we can start creating our `setuptools` configuration.
    To package our project using `setuptools`, we need to create a **setup script**;
    by convention, this is called `setup.py` and is created in the application's root
    directory.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们代码准备好了，我们可以开始创建我们的`setuptools`配置。要使用`setuptools`打包我们的项目，我们需要创建一个**配置脚本**；按照惯例，这个文件叫做`setup.py`，并且创建在应用程序的根目录中。
- en: The `setuptools` configuration can also be created as an INI-style configuration
    file, `setup.cfg`. Eventually, this may replace `setup.py`, but in this book we're
    going to stick with the Python script approach, because it allows us to execute
    some necessary Python code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`配置也可以创建为一个INI风格的配置文件，`setup.cfg`。最终，这可能会取代`setup.py`，但在这本书中，我们将坚持使用Python脚本方法，因为它允许我们执行一些必要的Python代码。'
- en: 'The basic structure of a `setup.py` file looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件的基本结构如下所示：'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The vast majority of our configuration will be passed as arguments to the `setup()`
    function, defining the basic metadata for our package, what will be packaged,
    and providing some functionality after installation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数配置都将作为参数传递给`setup()`函数，定义我们包的基本元数据，包括要打包的内容以及安装后提供的一些功能。
- en: Basic metadata arguments
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本元数据参数
- en: 'To begin, let''s define some basic metadata about our application using these
    arguments in `setup.py`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`setup.py`中的这些参数定义一些关于我们应用程序的基本元数据：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Metadata such as this will be used in naming the package as well as providing
    information for PyPI. Not all of the fields are necessary if you are just packaging
    for personal or internal use, but if you plan to upload to PyPI, you should include
    all these fields as well as `long_description`, which should be a reStructuredText
    string that provides extended information about the program.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的元数据将被用于命名包以及为PyPI提供信息。如果你只是用于个人或内部打包，并非所有字段都是必要的，但如果你计划上传到PyPI，你应该包括所有这些字段以及`long_description`，它应该是一个reStructuredText字符串，提供有关程序的扩展信息。
- en: 'Often, the `README.rst` file can simply be used. Since this configuration script
    is just a Python script, we can use normal Python to read the file and use its
    contents for this configuration option, like so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以直接使用`README.rst`文件。因为这个配置脚本只是一个Python脚本，我们可以使用正常的Python来读取文件，并使用其内容进行此配置选项，如下所示：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Packages and dependencies
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包和依赖项
- en: 'Once we have specified the metadata, we need to tell `setuptools` which packages
    we''re actually bundling using the `packages` argument. In our case, we only have
    the `abq_data_entry` package, so we''ll specify it as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们指定了元数据，我们需要告诉`setuptools`我们实际上正在捆绑哪些包，使用`packages`参数。在我们的例子中，我们只有`abq_data_entry`包，所以我们将如下指定它：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that we've specified both the main package and the sub-modules `images`
    and `test`. We need to specify all the sub-modules we want to include explicitly
    here, as `setuptools` will not automatically include them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经指定了主包以及子模块`images`和`test`。我们需要明确指定我们想要包含的所有子模块，因为`setuptools`不会自动包含它们。
- en: 'That could get tedious with very complex packages, so `setuptools` also includes
    the `find_packages()` function, which can be used instead like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常复杂的包，这可能会变得繁琐，所以`setuptools`还包括`find_packages()`函数，可以像这样使用：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will locate and include all the packages in our project directory automatically.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动定位并包含我们项目目录中的所有包。
- en: In addition to the modules defined in our project, our application depends on
    third-party modules such as `psycopg2`, `requests`, `paramiko`, and `matplotlib`.
    We can specify these dependencies in `setup()`, and, assuming they're available
    from PyPI, `pip` will install them automatically when our package is installed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们项目中定义的模块外，我们的应用程序还依赖于第三方模块，如`psycopg2`、`requests`、`paramiko`和`matplotlib`。我们可以在`setup()`中指定这些依赖项，并且假设它们可以从PyPI获取，当我们的包被安装时，`pip`将自动安装它们。
- en: 'This is done using the `install_requires` argument as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`install_requires`参数实现的，如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that these required packages may have their own dependencies as well; for
    example, `matplotlib` requires several other libraries including `numpy` and `pillow`.
    We don't have to specify all of those sub-dependencies; they will also be automatically
    installed by `pip`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些所需的软件包可能也有它们自己的依赖项；例如，`matplotlib`需要包括`numpy`和`pillow`在内的几个其他库。我们不必指定所有这些子依赖项；它们也将由`pip`自动安装。
- en: 'If the package requires particular versions of these modules, we can specify
    that as well:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该包需要这些模块的特定版本，我们也可以指定：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This looks rather familiar, doesn't it? These are the same kind of rules we
    can put in `requirements.txt`, and the same list of runtime dependencies. Some
    developers take the approach of just reading in `requirements.txt` and sending
    its contents to the `install_requires` list; there are even tools available to
    help translate some of the incompatible syntax between them. Remember, though,
    that the intention of our `requirements.txt` file was to recreate our specific
    development environment. As such, it contains non-runtime packages, and may have
    very specific version specifiers for the sake of testing consistency. The `install_requires`
    list, by contrast, is meant solely for runtime requirements, and in general should
    be more abstract about versions and package sources. For example, while it might
    be helpful to specify `psycopg2` version `2.9.1` for the development environment,
    unless we know for certain that it only works correctly with that one version,
    we would specify something more general here like `psycopg2<3.0`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当熟悉，不是吗？这些是我们可以在`requirements.txt`中放入的相同类型的规则，以及相同的运行时依赖项列表。一些开发者采取的方法是只读取`requirements.txt`并将其内容发送到`install_requires`列表；甚至有工具可以帮助翻译它们之间的一些不兼容语法。但是，请记住，我们的`requirements.txt`文件的目的是为了重新创建我们的特定开发环境。因此，它包含非运行时包，并且可能包含非常具体的版本指定符以测试一致性。相比之下，`install_requires`列表仅用于运行时要求，并且通常应该对版本和包来源更加抽象。例如，虽然指定`psycopg2`版本`2.9.1`对于开发环境可能是有帮助的，除非我们确定它只与该版本正确工作，否则我们在这里会指定更通用的版本，例如`psycopg2<3.0`。
- en: 'Just as we can specify package version requirements, we can also specify the
    version of Python required by our application using the `python_requires` argument,
    like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以指定包的版本要求一样，我们也可以使用`python_requires`参数指定我们的应用程序所需的Python版本，如下所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is always a good idea to do if you're using Python features not found in
    earlier releases (for example, the f-strings used in our application do not work
    before Python 3.6), or if you want to be sure that only a specific, tested version
    of Python is used. If the user is not running a matching version of Python, `pip
    install` will abort with an error.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用在早期版本中找不到的Python特性（例如，我们应用程序中使用的f-strings在Python 3.6之前无法工作），或者您想确保只使用特定的、经过测试的Python版本，那么这始终是一个好主意。如果用户没有运行匹配的Python版本，`pip
    install`将因错误而终止。
- en: The syntax for version specifiers used in `setuptools` is laid out in PEP 440,
    which you can find at [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setuptools`中使用的版本指定符的语法在PEP 440中有详细说明，您可以在[https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)找到。
- en: Adding extra files
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加额外文件
- en: 'By default, `setuptools` will only copy Python files into your package. Our
    package contains more than that, though: we have documentation in RST, SQL scripts,
    and most importantly our PNG images, without which our program won''t run correctly.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`setuptools`只会将Python文件复制到您的包中。然而，我们的包包含的不仅仅是这些：我们还有RST格式的文档、SQL脚本，最重要的是我们的PNG图像，没有这些图像，我们的程序将无法正确运行。
- en: 'Non-Python files that are located *inside* our package structure can be specified
    using the `package_data` argument:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 位于我们包结构内部的非Python文件可以使用`package_data`参数进行指定：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `package_data` argument takes a dictionary that matches module paths to
    a list of files (or globbing expressions that match a list of files) to be included
    in that module. Here, we're telling `setuptools` to include all the PNG and XBM
    files in the `images` module.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`package_data` 参数接受一个字典，将模块路径与要包含在该模块中的文件列表（或匹配文件列表的 globbing 表达式）相匹配。在这里，我们告诉
    `setuptools` 包含 `images` 模块中的所有 PNG 和 XBM 文件。'
- en: Our project also contains necessary files outside the `abq_data_entry` module;
    these aren't needed for the program to operate, but should nevertheless be distributed
    with the package. We cannot specify these in `setup()`, since it only deals with
    the in-package files.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目还包含 `abq_data_entry` 模块之外必要的文件；这些文件对于程序运行不是必需的，但应该与软件包一起分发。我们无法在 `setup()`
    中指定这些文件，因为它只处理软件包内的文件。
- en: 'To add these, we need to create a separate file in the project root directory
    called `MANIFEST.in`. For our application, the file should contain this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些，我们需要在项目根目录中创建一个名为 `MANIFEST.in` 的单独文件。对于我们的应用程序，该文件应包含以下内容：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `MANIFEST.in` file contains a series of the `include` directives with filenames
    or globbing expressions that match files we want to include. Here, we're including
    all files in our `docs` directory, all the `.sql` files in the `sql` directory,
    the `requirements.txt` file, and the `README.rst` file. Since `setup.py` relies
    on the `README.rst` and `requirements.txt` files for setup data, it's imperative
    that we include it in the package. Otherwise, our package won't be buildable on
    other systems.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`MANIFEST.in` 文件包含一系列的 `include` 指令，其中包含文件名或匹配我们想要包含的文件的 globbing 表达式。在这里，我们包括
    `docs` 目录中的所有文件，`sql` 目录中的所有 `.sql` 文件，`requirements.txt` 文件和 `README.rst` 文件。由于
    `setup.py` 依赖于 `README.rst` 和 `requirements.txt` 文件来设置数据，因此我们务必将它们包含在软件包中。否则，我们的软件包在其他系统上可能无法构建。'
- en: Defining commands
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义命令
- en: Earlier, we created a `__main__.py` file in our package that allows our package
    to be run using the command `python -m abq_data_entry`. This is certainly cleaner
    than having to hunt down the right Python script to execute, but ideally we'd
    like our package to set up a simple command that a user can execute to launch
    the program.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们在包中创建了一个 `__main__.py` 文件，允许我们通过命令 `python -m abq_data_entry` 运行我们的包。这当然比寻找要执行的正确
    Python 脚本要干净得多，但理想情况下，我们希望我们的软件包设置一个简单的命令，用户可以执行以启动程序。
- en: The `setuptools` library offers a way to add executable commands in our package
    using the `entry_points` argument. **Entry points** are ways for external environments
    to access our code. One particular entry point, `console_scripts`, defines a list
    of module functions that will be mapped to external commands. When the package
    is installed, `setuptools` will create a simple, platform-appropriate executable
    file for each `console_scripts` item that, when executed, will run the function
    specified.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools` 库提供了一个使用 `entry_points` 参数在我们的软件包中添加可执行命令的方法。**入口点**是外部环境访问我们代码的方式。一个特定的入口点，`console_scripts`，定义了一个将映射到外部命令的模块函数列表。当软件包安装时，`setuptools`
    将为每个 `console_scripts` 项创建一个简单、平台适当的可执行文件，当执行时，将运行指定的函数。'
- en: 'We can''t point `console_scripts` to a Python file or package, however; it
    must point instead to a *function* inside the package. This is why we created
    the `main()` function in our `__main__.py` file earlier, so that we can specify
    `__main__.main()` as a console script entry point, like so:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能将 `console_scripts` 指向一个 Python 文件或包；它必须指向包内的一个 *函数*。这就是为什么我们之前在 `__main__.py`
    文件中创建 `main()` 函数的原因，这样我们就可以指定 `__main__.main()` 作为控制台脚本入口点，如下所示：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each item in the `console_scripts` list is a string in the format `{executable_name}
    = {module}.{submodule}:{function_name}`. Our code here will cause `setuptools`
    to create an executable called `abq`, which will run the `main()` function we
    defined in `__main__.py`. Thus, after installation, we can execute the application
    by just typing `abq` at a command line. You could define other scripts here if
    there were functions in the package that could run standalone.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`console_scripts` 列表中的每个项都是一个格式为 `{executable_name} = {module}.{submodule}:{function_name}`
    的字符串。我们的代码将导致 `setuptools` 创建一个名为 `abq` 的可执行文件，该文件将运行我们在 `__main__.py` 中定义的 `main()`
    函数。因此，安装后，我们只需在命令行中键入 `abq` 即可执行应用程序。如果包中有可以独立运行的函数，您还可以在这里定义其他脚本。'
- en: Testing the configuration
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试配置
- en: 'Before we move on to creating distributable packages from our configuration,
    we can check it for proper syntax and content by running the following command
    in the project root directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建可分发包之前，我们可以通过在项目根目录中运行以下命令来检查其语法和内容：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If all is well, this will simply return the string `running check` with no
    other output. If something were missing, you would get an error message. For example,
    if you comment out the `name` and `version` arguments to `setup()` and run the
    check, you''ll get the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，这将简单地返回字符串`running check`，没有其他输出。如果缺少某些内容，你会得到一个错误消息。例如，如果你注释掉`setup()`中的`name`和`version`参数并运行检查，你会得到以下输出：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: While it won't find every potential problem with your `setup.py`, the `check`
    command will at least ensure you have the essential metadata specified, which
    is especially important if you wish to upload your package to PyPI.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不会找到你`setup.py`中所有潜在的问题，但`check`命令至少会确保你指定了所有必要的元数据，这对于你希望将包上传到PyPI来说尤为重要。
- en: Creating and using source distributions
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用源分布
- en: With our configuration files all set, we can now create a **source distribution**.
    This kind of distribution bundles all the relevant files for building our package
    from source into a `.tar.gz` archive.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件全部设置完毕后，我们现在可以创建一个**源分布**。这种分布将所有构建我们包所需的相关文件打包成一个`.tar.gz`存档。
- en: 'To create the source distribution, run `setup.py` with the `sdist` option in
    the project root directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建源分布，请在项目根目录中运行带有`sdist`选项的`setup.py`：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After doing this, two new directories will appear under the project root:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，在项目根目录下将出现两个新的目录：
- en: '`ABQ_Data_Entry.egg-info`: This directory contains the metadata files generated
    by `setuptools`. If you explore this directory, you''ll find that all the information
    we passed to `setup()` is here in some form or other.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABQ_Data_Entry.egg-info`：这个目录包含由`setuptools`生成的元数据文件。如果你探索这个目录，你会发现我们传递给`setup()`的所有信息都以某种形式存储在这里。'
- en: '`dist`: This directory contains the files generated for distribution; in this
    case, there is just a single `.tar.gz` file that contains our source package.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist`：这个目录包含为分发而生成的文件；在这种情况下，只有一个包含我们的源包的单个`.tar.gz`文件。'
- en: 'To install the source distribution on another computer, it first needs to be
    extracted. This can be done with GUI utilities or in a terminal with the `tar`
    command, as shown in the following example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在另一台计算机上安装源分布，首先需要将其提取出来。这可以使用GUI工具或使用以下示例中的`tar`命令在终端中完成：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once extracted, we can install the package by running `setup.py` inside the
    extracted directory using the `install` option, like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 提取后，我们可以在提取的目录中通过运行带有`install`选项的`setup.py`来安装包，如下所示：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Testing our source distribution
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们的源分布
- en: If you don't have a second computer handy to test your source installer on,
    you can use a Python **virtual environment** instead. A virtual environment is
    a clean, isolated Python installation that can be activated on demand to keep
    installed packages from polluting your system's main Python environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有第二台计算机来测试你的源安装器，你可以使用Python **虚拟环境**。虚拟环境是一个干净、隔离的Python安装，可以根据需要激活，以防止安装的包污染系统的主要Python环境。
- en: 'To create one, first make sure you have the `virtualenv` package installed
    using `pip`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个，首先确保你已经使用`pip`安装了`virtualenv`包：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, create a directory anywhere on your system and generate a Python 3 environment
    in it with these commands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在你的系统上的任何位置创建一个目录，并使用以下命令在其中生成一个Python 3环境：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will create a virtual environment, essentially a copy of the Python interpreter
    and standard library, in the `testenv` directory along with some supporting scripts
    and files. This environment can be modified in any way you wish without affecting
    your system's Python environment.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`testenv`目录中创建一个虚拟环境，本质上是一个Python解释器和标准库的副本，以及一些支持脚本和文件。这个环境可以按你的意愿进行修改，而不会影响你的系统Python环境。
- en: 'To use the new virtual environment, you need to **activate** it by executing
    the following code in a terminal:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新的虚拟环境，你需要通过在终端中执行以下代码来**激活**它：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Activating a virtual environment means that invocations of `python` will use
    the binaries and libraries in the virtual environment rather than your system
    installation. This includes Python-related commands like `pip`, meaning that a
    `pip install` will install packages to the environment's library rather than to
    your system or user Python libraries.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境意味着 `python` 的调用将使用虚拟环境中的二进制和库，而不是你的系统安装。这包括与 Python 相关的命令，如 `pip`，这意味着
    `pip install` 将将包安装到环境的库中，而不是你的系统或用户 Python 库中。
- en: With your test environment active, you can now run `setup.py install` on your
    source distribution. You'll notice that Python will install `psycopg2`, `requests`,
    `paramiko`, and `matplotlib`, as well as their individual dependencies, even if
    you already have those packages on your system. That's because the virtual environment
    starts clean with no third-party packages, so everything must be installed again
    in the new environment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试环境激活后，你现在可以在你的源分发上运行 `setup.py install`。你会注意到 Python 将安装 `psycopg2`、`requests`、`paramiko`
    和 `matplotlib`，以及它们的各个依赖项，即使你已经在你的系统上安装了这些包。这是因为虚拟环境从没有第三方包的干净状态开始，所以在新环境中必须重新安装一切。
- en: 'If the install was successful, you should find the following things:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，你应该找到以下内容：
- en: You have a command called `abq` available in your virtual environment, which
    launches the ABQ Data Entry application.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在你的虚拟环境中有一个名为 `abq` 的命令，它启动 ABQ 数据输入应用程序。
- en: You can open a Python prompt from any directory on the system (not just in the
    project root) and import `abq_data_entry`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从系统的任何目录（而不仅仅是项目根目录）打开 Python 提示符并导入 `abq_data_entry`。
- en: The `abq_data_entry` package directory can be found in `testenv/lib/python3.9/sitepackages`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abq_data_entry` 包目录位于 `testenv/lib/python3.9/sitepackages`。'
- en: When finished with your virtual environment, you can type `deactivate` in the
    terminal to go back to your system Python. If you want to remove the environment,
    just delete the `testenv` directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成虚拟环境后，你可以在终端中输入 `deactivate` 以返回到你的系统 Python。如果你想删除环境，只需删除 `testenv` 目录。
- en: Building a wheel distribution
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建wheel分发
- en: While a source distribution may be fine for simple software such as our application,
    packages with complicated build steps such as code compilation may benefit from
    a **built distribution**. As the name implies, a built distribution is one where
    any building operations (compilation or code generation, for example) has already
    been done. The current format used by `setuptools` for built distributions is
    the **wheel format**.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源分发可能适合像我们的应用程序这样的简单软件，但具有复杂构建步骤（如代码编译）的包可能从 **构建分发** 中受益。正如其名所示，构建分发是指任何构建操作（编译或代码生成等）已经完成的分发。`setuptools`
    用于构建分发的当前格式是 **wheel 格式**。
- en: The wheel format replaces an older `distutils` distribution format called `egg`.
    You will still see references to `egg` when using `setuptools` or other `distutils`
    derivatives.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: wheel 格式取代了旧的 `distutils` 分发格式，称为 `egg`。当使用 `setuptools` 或其他 `distutils` 衍生工具时，你仍然会看到对
    `egg` 的引用。
- en: 'A `wheel` (`.whl`) file is basically a ZIP-format archive file containing pre-built
    code. It comes in the following three types:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `wheel`（`.whl`）文件基本上是一个包含预构建代码的 ZIP 格式存档文件。它有以下三种类型：
- en: '**Universal**: This type of `wheel` file contains only Python code that will
    run on any platform with any major version of Python (2 and 3).'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**：这种类型的 `wheel` 文件只包含在任何平台和任何主要版本的 Python（2 和 3）上运行的 Python 代码。'
- en: '**Pure Python**: This type of `wheel` file contains only Python code that will
    run on any platform, but is compatible with only one version of Python.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯 Python**：这种类型的 `wheel` 文件只包含在任何平台上运行的 Python 代码，但只与一个版本的 Python 兼容。'
- en: '**Platform**: This `wheel` file is limited to a particular OS, platform, or
    architecture, usually because it contains compiled binary code.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台**：这个 `wheel` 文件限制在特定的操作系统、平台或架构上，通常是因为它包含编译的二进制代码。'
- en: 'The default `wheel` file created by `setuptools` is a pure Python wheel, which
    is what our application should be (since we have no compiled code, but are compatible
    only with Python 3). Creating one is simply a matter of calling `setup.py` with
    the `bdist_wheel` option, like so:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `setuptools` 创建的默认 `wheel` 文件是一个纯 Python wheel，这正是我们的应用程序应该使用的（因为我们没有编译代码，但只与
    Python 3 兼容）。创建一个很简单，只需使用 `bdist_wheel` 选项调用 `setup.py`，如下所示：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Like `sdist`, this command creates a new file in the `dist` directory, only
    this time it''s a `.whl` file. The filename will be `ABQ_Data_Entry-1.0-py3-none-any.whl`,
    the segments of which represent the following information:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与`sdist`命令类似，这个命令在`dist`目录下创建一个新的文件，但这次是一个`.whl`文件。文件名将是`ABQ_Data_Entry-1.0-py3-none-any.whl`，其各个部分代表以下信息：
- en: The package name, in this case `ABQ_Data_Entry`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包名，在本例中为`ABQ_Data_Entry`。
- en: The version, in this case `1.0`.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本，在本例中为`1.0`。
- en: Whether it's Python 3, Python 2, or universal; in this case, `py3` for Python
    3.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不论是Python 3、Python 2还是通用版；在本例中，为Python 3的`py3`。
- en: The **Application Binary Interface** (**ABI**) tag, which would indicate a particular
    implementation of Python (for example, CPython vs. IronPython). In this case,
    it's `none`, since we have no particular ABI requirements.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用二进制接口**（**ABI**）标签，它将指示特定的Python实现（例如，CPython与IronPython）。在本例中，它是`none`，因为我们没有特定的ABI要求。'
- en: The supported platform, in this case `any`, since our application is not platform-specific.
    Note that this component can include a CPU architecture as well as an operating
    system.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持的平台，在本例中为`any`，因为我们的应用程序不是平台特定的。请注意，这个组件可以包括CPU架构以及操作系统。
- en: Notice that the `bdist_wheel` process also creates a `build` directory, which
    is where built code is staged before it is compressed into the `wheel` file. You
    can inspect this directory to make sure that your package is being assembled correctly.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`bdist_wheel`过程还会创建一个`build`目录，这是在代码被压缩进`wheel`文件之前，代码被暂存的地方。您可以检查这个目录，以确保您的包正在正确组装。
- en: 'Once built, your `wheel` file can be installed using `pip`, like so:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，您可以使用`pip`安装`wheel`文件，如下所示：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As with the source install, `pip` will first install any dependencies specified
    in the setup configuration, then install the package itself to the environment's
    `site-packages` directory. The executable `abq` file will also be created and
    copied to an executable location appropriate to your platform.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与源代码安装一样，`pip`将首先安装在设置配置中指定的任何依赖项，然后安装包到环境的`site-packages`目录。可执行文件`abq`也将被创建并复制到适合您平台的可执行位置。
- en: If you get an error when trying to use `bdist_wheel`, you may need to install
    the `wheel` module, as it's not always included with `setuptools`. This module
    can be installed with the command `pip install --user wheel`. Recall that we specified
    `wheel` as a build dependency in `pyproject.toml`, though, so this step should
    be taken care of by `setuptools`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在尝试使用`bdist_wheel`时遇到错误，您可能需要安装`wheel`模块，因为这个模块并不总是包含在`setuptools`中。可以使用命令`pip
    install --user wheel`安装此模块。然而，请记住，我们在`pyproject.toml`中指定了`wheel`作为构建依赖项，因此这一步应该由`setuptools`处理。
- en: Creating executables with cx_Freeze
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cx_Freeze创建可执行文件
- en: While source and wheel distributions are useful, they both require that Python
    and any third-party library dependencies be installed on the system before the
    program can be run. Often, it would be much handier if we could provide a file
    or set of files that can simply be copied and run on a system without installing
    anything else first. Better yet, we'd like to have platform-appropriate installation
    packages that set up desktop shortcuts and perform other common system configurations.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源代码和轮子发行版很有用，但它们都需要在程序运行之前在系统上安装Python和任何第三方库依赖项。通常，如果我们能提供一个或一组文件，可以直接复制并在系统上运行而不需要先安装其他任何东西，那就方便多了。更好的是，我们希望有适合平台的安装包，这些包可以设置桌面快捷方式并执行其他常见的系统配置。
- en: There are several ways to go about this with Python code, and several projects
    to choose from; in this book, we're going to look at one called `cx_Freeze`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以用Python代码来实现这一点，也有几个项目可供选择；在这本书中，我们将探讨一个名为`cx_Freeze`的项目。
- en: The basic idea of `cx_Freeze` is to bundle up all the code and shared library
    files for a Python project along with a Python interpreter, and then generate
    a small executable file that will launch the code with the bundled interpreter.
    This approach is commonly known as **freezing** the code (hence the package name),
    and it works fairly well most of the time. However, as we'll see, there are some
    limitations and difficulties to work around. One significant limitation is that
    `cx_Freeze` can only make executables for the platform that it's running on; in
    other words, if you want a Windows executable, you'll need to build it on Windows;
    if you want a Linux executable, you'll have to build it on Linux, and so on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`cx_Freeze`的基本思想是将Python项目的所有代码和共享库文件以及Python解释器捆绑在一起，然后生成一个小的可执行文件，该文件将使用捆绑的解释器启动代码。这种方法通常被称为**冻结**代码（因此得名），并且大多数时候效果相当不错。然而，正如我们将看到的，有一些限制和困难需要克服。一个显著的限制是`cx_Freeze`只能为其运行的平台生成可执行文件；换句话说，如果你想生成Windows的可执行文件，你需要在Windows上构建它；如果你想生成Linux的可执行文件，你必须在Linux上构建它，依此类推。'
- en: Complete documentation on `cx_Freeze` can be found at [https://cx-freeze.readthedocs.io](https://cx-freeze.readthedocs.io).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`cx_Freeze`的完整文档可以在[https://cx-freeze.readthedocs.io](https://cx-freeze.readthedocs.io)找到。'
- en: First steps with cx_Freeze
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`cx_Freeze`的第一步
- en: 'Install `cx_Freeze` using `pip` as shown in the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令使用`pip`安装`cx_Freeze`：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Linux users may also need to install the `patchelf` utility, generally available
    in your distribution's package manager.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用户可能还需要安装`patchelf`实用程序，通常可在您发行版的包管理器中找到。
- en: 'Like `setuptools`, `cx_Freeze` is an extension of `distutils`; it shares many
    similarities with `setuptools`, but as you''ll see, it takes a different approach
    to solving certain problems. Just like `setuptools`, we''ll start with a script
    in the project directory that calls the `setup()` function. To distinguish this
    script from our `setuptools` script, we''ll call it `cxsetup.py`. Open this file
    and enter the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与`setuptools`一样，`cx_Freeze`是`distutils`的扩展；它与`setuptools`有很多相似之处，但正如您将看到的，它采取了不同的方法来解决某些问题。就像`setuptools`一样，我们将从一个项目目录中的脚本开始，该脚本调用`setup()`函数。为了将此脚本与我们的`setuptools`脚本区分开来，我们将将其命名为`cxsetup.py`。打开此文件并输入以下内容：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So far, this is identical to a `setuptools` script apart from us using the `cx_Freeze.setup()`
    function instead of the `setuptools` one. From here, though, things will diverge
    considerably.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这与`setuptools`脚本相同，除了我们使用`cx_Freeze.setup()`函数而不是`setuptools`的函数。然而，从现在开始，事情将会有很大的不同。
- en: 'Where `setuptools` uses the `entry_points` argument, `cx_Freeze` uses an `executables`
    argument. This argument takes a list of `cx_Freeze.Excecutable` objects, each
    of which describes various attributes of an executable file we want to generate.
    Add the following code that does this for ABQ Data Entry:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`使用`entry_points`参数，而`cx_Freeze`使用`executables`参数。此参数接受一个`cx_Freeze.Excecutable`对象的列表，每个对象都描述了我们想要生成的可执行文件的各种属性。为ABQ数据输入添加以下代码：'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At a minimum, we need to provide a Python script that should be executed when
    the executable will run; we're using our `abq_data_entry/__main__.py` script for
    this purpose.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们需要提供一个Python脚本，当可执行文件运行时应该执行；我们正在使用我们的`abq_data_entry/__main__.py`脚本为此目的。
- en: By default, the generated executable will be the script name without the `.py`
    extension. In this case, that would be `__main__`, which is not a terribly descriptive
    name for our application. Fortunately, we can override this default with the `target_name`
    argument, as we've done here. By specifying `abq` here, `cx_Freeze` will build
    an executable file called `abq`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，生成的可执行文件将是脚本名称，不带`.py`扩展名。在这种情况下，将是`__main__`，这不是我们应用程序的一个非常描述性的名称。幸运的是，我们可以使用`target_name`参数来覆盖此默认设置，就像我们在这里所做的那样。通过在这里指定`abq`，`cx_Freeze`将构建一个名为`abq`的可执行文件。
- en: We can also specify an icon to use for the application using the `icon` argument.
    This needs to be a path to a `.ico` file, so you'll need to convert PNG or other
    formats to `.ico` before using them. The path to the file is relative to the project
    directory where the `cxsetup.py` file is, and does not need to be inside the package
    itself.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`icon`参数指定应用程序要使用的图标。这需要是一个`.ico`文件的路径，因此在使用之前，您需要将PNG或其他格式转换为`.ico`。文件的路径相对于包含`cxsetup.py`文件的项目目录，并且不需要在包内部。
- en: The build_exe options
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建可执行文件选项
- en: Arguments to specific `cx_Freeze` operations can be passed into `setup()` using
    the `options` argument. This argument takes a dictionary in which each item is
    a `cx_Freeze` operation name paired with a `dict` object of operation-specific
    arguments. The first operation we're going to look at is `build_exe`, which is
    a universal first step for all other operations. As the name implies, this is
    the stage where the executable and its accompanying files are built.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`options`参数将特定`cx_Freeze`操作的参数传递给`setup()`。此参数接受一个字典，其中每个项都是一个与操作特定参数的`dict`对象配对的`cx_Freeze`操作名称。我们将首先查看的操作是`build_exe`，这是所有其他操作的一个通用第一步。正如其名所示，这是可执行文件及其伴随文件被构建的阶段。
- en: 'Among other things, this is where we specify the package dependencies:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方面，这是我们指定包依赖项的地方：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `packages` argument is a list of the packages that need to be installed.
    It's similar to the `install_requires` argument for `setuptools`, with the important
    difference that it does not support version specifiers. Also, note that we've
    included some things beyond our three main dependencies. Unfortunately, because
    `cx_Freeze` doesn't always do a great job at identifying all the dependencies,
    it's often necessary to explicitly list sub-dependencies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`packages`参数是需要安装的包列表。它与`setuptools`的`install_requires`参数类似，但有一个重要的区别，即它不支持版本指定符。此外，请注意，我们已经包含了一些超出我们三个主要依赖项的内容。不幸的是，由于`cx_Freeze`并不总是能够很好地识别所有依赖项，因此通常需要明确列出子依赖项。'
- en: Where `packages` is a list of the packages that should be included, we can also
    specify specific *modules* to be included using the `includes` argument. In theory,
    we shouldn't need to specify anything here, but in practice `cx_Freeze` sometimes
    fails to bundle modules that our program needs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当`packages`是一个需要包含的包列表时，我们也可以使用`includes`参数指定要包含的特定*模块*。从理论上讲，我们在这里不应该需要指定任何内容，但在实践中，`cx_Freeze`有时无法捆绑我们的程序需要的模块。
- en: Using the `includes` directive, we can explicitly request modules to ensure
    that they are included.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`includes`指令，我们可以明确请求模块以确保它们被包含。
- en: 'To figure out what should go in the list, follow a basic trial-and-error procedure:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定列表中应该包含什么，遵循基本的试错程序：
- en: Build the executable.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建可执行文件。
- en: Run the executable.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行可执行文件。
- en: If you get a `ModuleNotFoundError` exception stating that a module cannot be
    found, add the module to the `includes` list and run the build command again.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你收到一个`ModuleNotFoundError`异常，表明无法找到模块，请将模块添加到`includes`列表，并再次运行构建命令。
- en: If you find several modules from the same package are missing, it may be more
    effective to add the package to the `packages` list and rebuild.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你发现同一个包中的多个模块缺失，将包添加到`packages`列表并重新构建可能更有效。
- en: 'For example, suppose you build ABQ Data Entry and get the following error when
    running `abq`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你构建了ABQ数据输入，并在运行`abq`时得到以下错误：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this situation, `zlib` would be a dependency of one of our required packages
    that for some reason `cx_Freeze` did not identify as necessary. To fix this, we
    would simply force its inclusion by updating the configuration:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`zlib`是我们所需的某个包的一个依赖项，由于某种原因`cx_Freeze`没有将其识别为必要的。为了解决这个问题，我们只需通过更新配置强制其包含。
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After that, a rebuilt executable should include the missing module. Generally,
    you don't need to do this for widely used modules, but depending on your platform
    and the packages you require, these issues do come up.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，重新构建的可执行文件应包含缺失的模块。通常，对于广泛使用的模块，你不需要这样做，但根据你的平台和所需的包，这些问题确实会出现。
- en: Including external files
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含外部文件
- en: 'As with `setuptools`, `cx_Freeze` only includes Python files by default. To
    get other files like images and documentation included, we can use the `include_files`
    argument to `build_exe`. However, there is a problem: because of the way that
    `cx_Freeze` bundles our Python module in a compressed archive, accessing file
    paths inside the module takes some extra code.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 与`setuptools`一样，`cx_Freeze`默认只包含Python文件。为了包含其他文件，如图像和文档，我们可以使用`build_exe`的`include_files`参数。然而，存在一个问题：由于`cx_Freeze`以压缩归档的方式捆绑我们的Python模块，因此访问模块内部的文件路径需要一些额外的代码。
- en: 'Our `images` module presents such a problem: it contains PNG files that our
    application accesses by calculating a relative path from its `__init__.py` file.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`images`模块就存在这样的问题：它包含PNG文件，我们的应用程序通过从其`__init__.py`文件计算相对路径来访问这些文件。
- en: To address the issue, the PNG files will need to be relocated to a directory
    outside the package during the build process. Our code will then have to find
    them in the new location when it's been frozen, and in the original location when
    not.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在构建过程中需要将 PNG 文件重新定位到包外的目录。然后，我们的代码将在冻结时在新位置找到它们，在未冻结时在原始位置找到它们。
- en: 'To make it work, modify `images/__init__.py` as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，按照以下方式修改 `images/__init__.py`：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When running a Python script that has been frozen using `cx_Freeze`, the `sys`
    module has an attribute called `frozen`. We can test for the presence of this
    attribute to specify behavior that changes when the app is frozen. In this case,
    when our app is frozen, we're going to look for our images in an `images` directory
    located in the same directory as the executable file. The location of the executable
    can be found from the `sys.executable` variable. If the application is not frozen,
    we'll look for the images in the module directory as before.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行使用 `cx_Freeze` 冻结的 Python 脚本时，`sys` 模块有一个名为 `frozen` 的属性。我们可以测试该属性的存在来指定当应用程序冻结时改变的行为。在这种情况下，当我们的应用程序冻结时，我们将寻找位于可执行文件相同目录下的
    `images` 目录中的图像。可执行文件的位置可以通过 `sys.executable` 变量找到。如果应用程序未冻结，我们将像以前一样在模块目录中寻找图像。
- en: 'Now that the script knows where to look for the images, we need to configure
    our `cx_Freeze` setup to copy the images into the location we set. To do that,
    we need to update our `build_exe` options like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在脚本知道在哪里查找图像，我们需要配置我们的 `cx_Freeze` 设置，将图像复制到我们设定的位置。为此，我们需要更新我们的 `build_exe`
    选项，如下所示：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `include_files` argument is a list of two-tuples. The first tuple member
    is a source path relative to the `cxsetup.py` script, while the second is a destination
    path relative to the executable file. In this case, we're telling it to copy the
    files in the `abq_data_entry/images` directory to a directory called `images`
    in the generated executable directory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`include_files` 参数是一个包含两个元组的列表。第一个元组成员是相对于 `cxsetup.py` 脚本的源路径，而第二个是相对于可执行文件的目标路径。在这种情况下，我们告诉它将
    `abq_data_entry/images` 目录中的文件复制到生成的可执行目录下的 `images` 目录中。'
- en: Building executables
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建可执行文件
- en: 'At this point, we can build an executable by running the following command
    line:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以通过运行以下命令来构建一个可执行文件：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `build` command runs all steps up to `build_exe`, leaving you with the built
    code in a platform-specific directory under `./build` in the format `exe.(os)-(cpu_arch)-(python_version)`.
    For example, if you ran this command on 64-bit Linux with Python 3.9, you'd have
    a `build/exe.linux-x86_64-3.9` directory containing the compiled code. You can
    inspect this directory to make sure files are being copied over and created properly,
    as well as testing the generated executable binary file. In the case of our application,
    `cx_Freeze` should have created a binary executable file called `abq`, which will
    launch your application when run. It should also have created `lib` and `images`
    directories, and copied the `abq.ico` file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`build` 命令运行所有步骤直到 `build_exe`，留下你在 `./build` 下的平台特定目录中的构建代码，格式为 `exe.(os)-(cpu_arch)-(python_version)`。例如，如果你在64位Linux上使用Python
    3.9运行此命令，你将有一个包含编译代码的 `build/exe.linux-x86_64-3.9` 目录。你可以检查此目录以确保文件被正确复制和创建，以及测试生成的可执行二进制文件。在我们的应用程序中，`cx_Freeze`
    应该创建一个名为 `abq` 的二进制可执行文件，运行时将启动你的应用程序。它还应创建 `lib` 和 `images` 目录，并复制 `abq.ico`
    文件。'
- en: Note that all files in the platform-specific build directory must be present
    for the program to run; `cx_Freeze` does not support the creation of single-file
    standalone executables.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，平台特定构建目录中的所有文件都必须存在，程序才能运行；`cx_Freeze` 不支持创建单文件独立可执行文件。
- en: For Linux and BSD, this build directory can be zipped up and distributed as
    is; users on other computers should be able to just extract the directory and
    execute the file. For Windows and macOS, though, we're going to need to do some
    more work to get it ready for distribution. In fact, you may even have gotten
    an error running the build command or executing the binary. We'll talk about the
    platform-specific tweaks and configurations that need to happen in the next section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Linux 和 BSD，此构建目录可以打包并直接分发；其他计算机上的用户应该能够只需提取目录并执行文件。然而，对于 Windows 和 macOS，我们需要做一些额外的工作来使其准备好分发。实际上，你可能甚至遇到了在运行构建命令或执行二进制文件时出现的错误。我们将在下一节中讨论需要发生的特定于平台的小调整和配置。
- en: '`cx_Freeze` supports the creation of RPM files, the package format used by
    certain Linux distributions such as Fedora or SUSE. If you''re on an RPM-based
    distribution, you may want to investigate this option. Unfortunately, there is
    no build operation to build packages for non-RPM distributions such as Debian,
    Ubuntu, or Arch.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`cx_Freeze` 支持创建 RPM 文件，这是 Fedora 或 SUSE 等某些 Linux 发行版使用的包格式。如果你在一个基于 RPM 的发行版上，你可能想调查这个选项。不幸的是，没有构建操作来为
    Debian、Ubuntu 或 Arch 等非 RPM 发行版构建包。 '
- en: Cleaning up the build
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理构建
- en: Although we have a working executable file, you might have noticed that the
    distributable folder is extremely large for such a simple project as ours.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有一个可工作的可执行文件，但你可能已经注意到，对于像我们这样的简单项目，可分发文件夹非常大。
- en: Before calling it a day, it's worth poking around inside the build directories
    to see what files `cx_Freeze` is bundling into your application and whether you
    really need all of it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束一天的工作之前，值得在构建目录内部进行一些探索，看看 `cx_Freeze` 将哪些文件捆绑到你的应用程序中，以及你是否真的需要所有这些文件。
- en: If you look in the platform-specific build directory under `lib/python(python_version)/`,
    you'll find all the libraries that were pulled in as dependencies of our package.
    You may find that some of these aren't actually necessary for running our application.
    For example, if you happen to have alternative GUI libraries like PyQt or PySide
    installed on your system, `matplotlib` may pull them in as dependencies.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `lib/python(python_version)/` 下的平台特定构建目录，你会找到所有作为我们包依赖项拉入的库。你可能发现其中一些实际上并不是运行我们的应用程序所必需的。例如，如果你恰好在你的系统上安装了
    PyQt 或 PySide 这样的替代 GUI 库，`matplotlib` 可能会将其作为依赖项拉入。
- en: 'If we do end up with extra packages like this, we can remove them using the
    `excludes` option of `build_exe`, like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们最终有像这样的额外包，我们可以使用 `build_exe` 的 `excludes` 选项来删除它们，如下所示：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After adding this change, delete your `build` directory and rerun the build
    command. You'll see that all these packages are no longer there, and the size
    of your build is significantly smaller.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此更改后，删除你的 `build` 目录并重新运行构建命令。你会发现所有这些包都不再存在，并且你的构建大小显著减小。
- en: Knowing what can be included or excluded takes research and some trial and error,
    but with careful pruning we can bring down the size of our distributable files
    and the build time for our package considerably.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 了解可以包含或排除的内容需要研究和一些试错，但通过仔细修剪，我们可以显著降低我们的可分发文件的大小和包的构建时间。
- en: Building Windows executables with cx_Freeze
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cx_Freeze 构建 Windows 可执行文件
- en: To build executables on Microsoft Windows, we need to properly set the `base`
    argument to the `Executable` initializer. Recall from *Chapter 10*, *Maintaining
    Cross-Platform Compatibility*, that Windows programs launch in either console
    or GUI mode. For each platform, `cx_Freeze` has one or more base executables from
    which it builds the frozen executable; on Linux, BSD, and macOS the default base
    executable is acceptable, but on Windows the default base launches the application
    in console mode.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Microsoft Windows 上构建可执行文件，我们需要正确设置 `Executable` 初始化器的 `base` 参数。回想一下 *第
    10 章*，*维护跨平台兼容性*，Windows 程序以控制台或 GUI 模式启动。对于每个平台，`cx_Freeze` 有一个或多个基础可执行文件，它从中构建冻结的可执行文件；在
    Linux、BSD 和 macOS 上，默认基础可执行文件是可以接受的，但在 Windows 上，默认基础会在控制台模式下启动应用程序。
- en: 'We need to specify a base that will launch our script in GUI mode instead.
    This can be done by passing a value of `Win32GUI` to the `base` argument. So,
    at the top of our `cxsetup.py` script, add this code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指定一个基础，以便以 GUI 模式启动我们的脚本。这可以通过将 `Win32GUI` 的值传递给 `base` 参数来实现。因此，在我们的 `cxsetup.py`
    脚本顶部添加以下代码：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As we learned to do in *Chapter 10*, *Maintaining Cross-Platform Compatibility*,
    we've used `platform.system()` to determine the operating system we're running
    on; if it's Windows, we'll set the base to `Win32GUI`. For other platforms, `base`
    should just be `None`, causing it to use the default base executable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *第 10 章*，*维护跨平台兼容性* 中所学到的，我们使用了 `platform.system()` 来确定我们正在运行的操作系统；如果是
    Windows，我们将基础设置为 `Win32GUI`。对于其他平台，`base` 应该只是 `None`，这将导致它使用默认的基础可执行文件。
- en: The application should now build successfully on Windows using `python cxsetup.py
    build`, and you should find `abq.exe` in the `build/exe.win-amd64-(python_version)`
    directory.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该在 Windows 上使用 `python cxsetup.py build` 成功构建应用程序，你应该能在 `build/exe.win-amd64-(python_version)`
    目录中找到 `abq.exe`。
- en: Building a Windows installer file
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 Windows 安装程序文件
- en: 'In addition to building a Windows executable, we can build a Windows installer
    file (`.msi`) using the `bdist_msi` operation. While our application could be
    distributed as is by simply zipping up the build folder and extracting it on the
    target system, there are a few advantages to using MSI files:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建Windows可执行文件外，我们还可以使用`bdist_msi`操作构建Windows安装程序文件（`.msi`）。虽然我们的应用程序可以通过简单地压缩构建文件夹并在目标系统上提取它来分发，但使用MSI文件有一些优点：
- en: MSI files can be more easily deployed by system administrators in a large-scale
    Windows environment.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大规模Windows环境中，系统管理员可以更轻松地部署MSI文件。
- en: MSI files register the application with the OS when installed, making operations
    like upgrades, repairs, and uninstallations cleaner.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当安装MSI文件时，它会将应用程序注册到操作系统，使得升级、修复和卸载等操作更加干净。
- en: MSI files have additional setup capabilities, such as an install wizard and
    desktop shortcut generation.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSI文件具有额外的设置功能，例如安装向导和桌面快捷方式生成。
- en: To get started generating an MSI file with `cx_Freeze`, we'll need to configure
    some aspects of our MSI by setting values in the `bdist_msi` dictionary of the
    `options` argument.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`cx_Freeze`生成MSI文件，我们需要通过设置`options`参数的`bdist_msi`字典中的值来配置我们的MSI的一些方面。
- en: 'We''ll start by specifying an **upgrade code**:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将指定一个**升级代码**：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The upgrade code is a **globally unique identifier** (**GUID**) value that will
    identify this program on the OS. By specifying this, subsequent builds of this
    `.msi` file will remove and replace any existing installations of the same program.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 升级代码是一个**全局唯一标识符**（GUID）值，它将在操作系统上识别此程序。通过指定此代码，后续构建的此`.msi`文件将删除并替换任何现有程序的安装。
- en: 'Upgrade codes consist of five segments of 8, 4, 4, 4, and 12 characters from
    0 to 9 and A to F. They can be created in Microsoft Visual Studio, or using this
    PowerShell command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 升级代码由五个部分组成，每个部分由8、4、4、4和12个字符组成，字符范围从0到9和A到F。它们可以在Microsoft Visual Studio中创建，或者使用以下PowerShell命令：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once specified, you should not change the upgrade code in subsequent builds
    of your application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指定，你不应该在应用程序后续构建中更改升级代码。
- en: 'The MSI installation process can also create application shortcuts, which will
    be placed on the desktop and/or programs menu when the package is installed. To
    do this, we''ll need to define our shortcuts by creating a list of **shortcut
    table** tuples like these:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: MSI安装过程还可以创建应用程序快捷方式，当安装包安装时，这些快捷方式将被放置在桌面和/或程序菜单上。为此，我们需要通过创建类似于以下这些的**快捷方式表**元组来定义我们的快捷方式：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding two tuples define a shortcut for the desktop and menu, respectively.
    The data contained in them matches the shortcut table layout described by Microsoft
    at [https://msdn.microsoft.com/en-us/library/windows/desktop/aa371847.aspx](https://docs.microsoft.com/en-us/windows/win32/msi/shortcut-table?redirectedfrom=MSDN).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个元组分别定义了桌面和菜单的快捷方式。它们包含的数据与微软在[https://msdn.microsoft.com/en-us/library/windows/desktop/aa371847.aspx](https://docs.microsoft.com/en-us/windows/win32/msi/shortcut-table?redirectedfrom=MSDN)中描述的快捷方式表布局相匹配。
- en: 'Those fields, in order, are defined by Microsoft as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，这些字段由微软定义为以下内容：
- en: '**Shortcut**: The type of shortcut to create; in our case either `DesktopShortcut`
    or `MenuShortcut`.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快捷方式**: 要创建的快捷方式类型；在我们的例子中是`DesktopShortcut`或`MenuShortcut`。'
- en: '**Directory**: A special directory key into which the shortcut will be copied.
    Here, `DesktopFolder` points to the desktop, and `ProgramMenuFolder` points to
    the programs folder in the menu.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**: 一个特殊的目录键，快捷键将被复制到其中。在这里，`DesktopFolder`指向桌面，而`ProgramMenuFolder`指向菜单中的程序文件夹。'
- en: '**Name**: The name of the shortcut; in our case, `ABQ Data Entry`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: 快捷键的名称；在我们的例子中，`ABQ 数据录入`。'
- en: '**Component**: This indicates a program whose installed or uninstalled state
    determines whether our shortcut should be installed or uninstalled. By specifying
    `TARGETDIR`, the install/uninstall state of our shortcuts matches the install/uninstall
    state of the program directory.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**: 这表示一个程序，其安装或卸载状态决定了我们的快捷方式是否应该安装或卸载。通过指定`TARGETDIR`，我们的快捷方式的安装/卸载状态与程序目录的安装/卸载状态相匹配。'
- en: '**Target**: The executable file that is launched by the shortcut. This will
    be our `target_name` attribute, located inside `TARGETDIR`.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**: 由快捷方式启动的可执行文件。这将是我们位于`TARGETDIR`内的`target_name`属性。'
- en: '**Arguments**: A string of arguments passed to the command. Whatever you specify
    here is simply appended to the target executable for the shortcut and available
    in our program from `sys.argv`. You might use this to, for example, create a second
    shortcut that launches your application in a test mode. In our case, the ABQ program
    expects no command-line arguments, so this is `None`.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：传递给命令的参数字符串。在这里指定的任何内容都将简单地附加到快捷方式的目标可执行文件中，并在我们的程序中通过 `sys.argv` 可用。例如，您可以使用此功能创建一个启动测试模式的第二个快捷方式。在我们的情况下，ABQ
    程序不期望任何命令行参数，因此这是 `None`。'
- en: '**Description**: A string used in the description field of the shortcut.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：用于快捷方式描述字段中的字符串。'
- en: '**Icon** and **IconIndex**: These are used to locate an icon for the shortcut,
    if we want it to be different from the icon of the executable. These can be left
    as `None` since our executable''s icon will be used by default.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图标** 和 **IconIndex**：这些用于定位快捷方式的图标，如果我们希望它与可执行文件的图标不同。这些可以保留为 `None`，因为我们的可执行文件的图标将默认使用。'
- en: '**ShowCmd**: Specifies if the program will be launched minimized, maximized,
    or normally. Leaving this as `None` will launch it normally.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ShowCmd**：指定程序将以最小化、最大化还是正常方式启动。将其保留为 `None` 将以正常方式启动。'
- en: '**WkDir**: Indicates the working directory to be used. We want this to be the
    program''s directory, so we use `TARGETDIR` here.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WkDir**：指示要使用的当前工作目录。我们希望这是程序的目录，因此在这里使用 `TARGETDIR`。'
- en: 'Once created, these shortcut tables need to be included in the data argument
    of our `bdist_msi` options, like so:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，这些快捷方式表需要包含在我们的 `bdist_msi` 选项的数据参数中，如下所示：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Currently, `data` is not documented in the `cx_Freeze` documentation; `cx_Freeze`
    uses the standard library's `msilib` module to build the `.msi` files, and anything
    passed into this argument is passed along to the `add_data()` function of `msilib`.
    Refer to the standard library documentation for `msilib` at [https://docs.python.org/3/library/msilib.html](https://docs.python.org/3/library/msilib.html)
    if you're interested in exploring this option further.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`data` 在 `cx_Freeze` 文档中未记录；`cx_Freeze` 使用标准库的 `msilib` 模块来构建 `.msi` 文件，并将传递给此参数的任何内容传递给
    `msilib` 的 `add_data()` 函数。如果您想进一步探索此选项，请参阅 [https://docs.python.org/3/library/msilib.html](https://docs.python.org/3/library/msilib.html)
    中的标准库 `msilib` 文档。
- en: 'With the `bdist_msi` options specified, let''s build the `.msi` file as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了 `bdist_msi` 选项后，让我们按照以下方式构建 `.msi` 文件：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This command creates a new installer file in the `dist` directory, which you
    should be able to install on any compatible Windows system, as shown in the following
    screenshot:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 `dist` 目录中创建一个新的安装文件，您应该能够在任何兼容的 Windows 系统上安装它，如下面的截图所示：
- en: '![Figure 16.1: The MSI install wizard for ABQ Data Entry](img/B17578_16_01.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1：ABQ 数据输入的 MSI 安装向导](img/B17578_16_01.png)'
- en: 'Figure 16.1: The MSI install wizard for ABQ Data Entry'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1：ABQ 数据输入的 MSI 安装向导
- en: Keep in mind that `cx_Freeze` uses Python binaries from your build environment
    in the application build; as a result, 64-bit Python will build a 64-bit executable,
    and 32-bit Python will build a 32-bit executable. Additionally, builds created
    on newer versions of Windows may not be compatible with older versions of Windows.
    For maximum compatibility, build your binaries on a 32-bit version of the oldest
    release of Windows you plan to support.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`cx_Freeze` 使用构建环境中的 Python 二进制文件来构建应用程序；因此，64 位 Python 将构建 64 位可执行文件，而
    32 位 Python 将构建 32 位可执行文件。此外，在较新版本的 Windows 上创建的构建可能不与较旧版本的 Windows 兼容。为了获得最大兼容性，请在您计划支持的最早版本
    Windows 的 32 位版本上构建您的二进制文件。
- en: Building macOS executables with cx_Freeze
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 cx_Freeze 构建 macOS 可执行文件
- en: 'There are two build operations that `cx_Freeze` implements that are specific
    to macOS: `bdist_mac` and `bdist_dmg`. These operations create an **application
    bundle** and a **compressed disk image** file, respectively. Let''s look at each
    operation in more detail.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`cx_Freeze` 实现了两个特定于 macOS 的构建操作：`bdist_mac` 和 `bdist_dmg`。这些操作分别创建 **应用程序包**
    和 **压缩磁盘映像** 文件。让我们更详细地查看每个操作。'
- en: Building macOS application bundles
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 macOS 应用程序包
- en: 'The `bdist_mac` build operation creates an application bundle, a specially
    formatted directory with an `.app` extension that the Mac desktop treats as though
    it were an executable file. `bdist_mac` has several configuration options, but
    we''re only going to use two:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`bdist_mac` 构建操作创建了一个应用程序包，一个具有 `.app` 扩展名的特殊格式目录，Mac 桌面将其视为可执行文件。`bdist_mac`
    有几个配置选项，但我们只将使用两个：'
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, `bundle_name` sets the name of our application bundle directory, without
    the `.app` extension. Normally, this would default to the `name` argument passed
    to `setup()`, which in our case is `ABQ_Data_Entry`. We're overriding it here
    to use dashes instead of underscores, as it looks a little less technical for
    end users. Note that using spaces in this value, while technically valid, tends
    to create problems for `cx_Freeze` and is best avoided. The `iconfile` setting
    allows us to point to an ICNS file that macOS will use for the application's icon.
    The dimensions of this image file need to be a square number of pixels that is
    a power of 2 between 16 and 1,024\. A compatible ABQ logo is included in the example
    code.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`bundle_name`设置应用程序包目录的名称，不包括`.app`扩展名。通常，这会默认为传递给`setup()`的`name`参数，在我们的例子中是`ABQ_Data_Entry`。我们在这里覆盖它，使用破折号而不是下划线，因为它对最终用户来说看起来不那么技术化。请注意，虽然在这个值中使用空格在技术上有效，但往往会给`cx_Freeze`带来问题，最好避免。`iconfile`设置允许我们指向macOS将用于应用程序图标的ICNS文件。此图像文件的尺寸需要是16到1,024像素之间的平方数，且是2的幂。示例代码中包含了一个兼容的ABQ标志。
- en: Refer to the `cx_Freeze` documentation for additional options here, which include
    code signing and explicitly specifying additional frameworks for the bundle.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`cx_Freeze`文档以获取此处额外的选项，包括代码签名和明确指定用于包的额外框架。
- en: 'Once your configuration options are added, run the `cxsetup.py` script by using
    the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了配置选项，请使用以下命令运行`cxsetup.py`脚本：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When this process completes, `ABQ-Data-Entry.app` should appear in the build
    directory. You can double-click this directory in the macOS GUI to run it from
    any location, or drag it to the `/Applications` directory to install it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当此过程完成后，`ABQ-Data-Entry.app`应出现在构建目录中。您可以在macOS GUI中双击此目录从任何位置运行它，或者将其拖到`/Applications`目录中安装。
- en: 'It should appear something like what is shown in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像以下屏幕截图所示：
- en: '![Figure 16.2: ABQ-Data-Entry bundle in the build directory](img/B17578_16_02.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2：构建目录中的ABQ-Data-Entry包](img/B17578_16_02.png)'
- en: 'Figure 16.2: ABQ-Data-Entry bundle in the build directory'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：构建目录中的ABQ-Data-Entry包
- en: If you launch the application from this bundle, you'll see that the app menu
    no longer reads **Python**, as we first saw in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*; it now reads **abq**, the name of the executable file, which is
    what we want.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从这个包中启动应用程序，您会看到应用程序菜单不再读取**Python**，正如我们在第10章*维护跨平台兼容性*中首次看到的；现在它读取**abq**，这是可执行文件的名称，这正是我们想要的。
- en: As with Windows executables, `cx_Freeze`-generated bundles for macOS are not
    necessarily backward-compatible, so it's best to create them on the oldest version
    of macOS that you need to support.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与Windows可执行文件一样，`cx_Freeze`为macOS生成的包不一定向下兼容，因此最好在您需要支持的macOS最旧版本上创建它们。
- en: Building macOS .dmg files
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 macOS .dmg 文件
- en: Applications on macOS are generally distributed inside a compressed disk image
    (`.dmg`) file. The `cx_Freeze` `build_dmg` operation allows you to build an application
    bundle and package it in a DMG file for easy distribution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: macOS上的应用程序通常分布在压缩磁盘映像（`.dmg`）文件中。`cx_Freeze`的`build_dmg`操作允许您构建应用程序包并将其打包成DMG文件，以便于分发。
- en: 'To do this, simply execute this command instead of the `bdist_mac` command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，只需执行此命令而不是`bdist_mac`命令：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This command first runs `bdist_mac` to build the application bundle and then
    packages it into a DMG file. The configuration options for `bdist_dmg` allow you
    to override the filename and include a shortcut to the `/Applications` directory
    for easy installation. The built file will appear in the `build` directory, from
    which you can copy it to another Macintosh to be mounted and used.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令首先运行`bdist_mac`来构建应用程序包，然后将其打包成DMG文件。`bdist_dmg`的配置选项允许您覆盖文件名并包括指向`/Applications`目录的快捷方式，以便于安装。构建的文件将出现在`build`目录中，您可以从该目录复制到另一台Macintosh上以进行挂载和使用。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to prepare and package your application for
    distribution. You learned how to make your package executable, and how to use
    `setuptools` to create source and built distributions of it for internal use within
    your organization or for distribution in a public index such as PyPI. You also
    learned how to use `cx_Freeze` to convert your Python script into an executable
    file that can be distributed to other systems without installing Python or dependent
    packages, and how to make application installation packages for Windows and macOS.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何为分发准备和打包你的应用程序。你学习了如何使你的包可执行，以及如何使用`setuptools`创建源代码和构建版本，以便在组织内部使用或在公共索引如PyPI上分发。你还学习了如何使用`cx_Freeze`将你的Python脚本转换为可执行文件，这样就可以在不安装Python或依赖包的情况下将其分发到其他系统，以及如何为Windows和macOS制作应用程序安装包。
- en: Congratulations on finishing this book! Together we've taken a simple CSV file
    and turned it into a complex and robust graphical application. You now have the
    knowledge and confidence to create user-friendly GUI applications that work with
    files, databases, networks, and APIs across all major platforms.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你完成这本书！我们一起将一个简单的CSV文件变成了一个复杂且健壮的图形应用程序。你现在拥有了创建用户友好的GUI应用程序的知识和信心，这些应用程序可以在所有主要平台上与文件、数据库、网络和API协同工作。
- en: As for your career with ABQ, you've just received a promotion offer to work
    with the corporate office as a software developer. There will be much more to
    learn, but with the skills you've learned so far you are ready for whatever challenges
    come next. Good luck!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 至于你在ABQ的职业发展，你刚刚收到了一份晋升提议，将作为软件开发者与公司总部一起工作。你还有更多东西要学习，但凭借你迄今为止学到的技能，你已经准备好迎接接下来的任何挑战。祝你好运！
