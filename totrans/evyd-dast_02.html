<html><head></head><body>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2.  Arrays: Foundational Collections </h1></div></div></div><p class="calibre7">Quite often, our applications need to store multiple pieces of user data or objects in memory at runtime. One solution is to define multiple fields (properties) in our various classes to store each of our required data points. Unfortunately, even when working with the simplest workflows, this approach quickly becomes ineffective. We will either have too many fields to work with, or we simply won't have any way of anticipating all of the dynamic requirements for our project at compile time.</p><p class="calibre7">One solution to this problem is to use an array. Arrays are simple collections of data, and they are one of the most common data structures you will encounter in your day-to-day programming experience due to the fact that many other data structures are built on top of them.</p><p class="calibre7">Arrays are containers that hold a fixed number of items of a particular type. The size of an array in C and its descendant languages are determined when the array is created, and the length remains fixed from that point forward. Each item in an array is called an <strong class="calibre16">element</strong>, and each element can be accessed by its index number. Generally speaking, an array is a collection of data items that can be selected by indices that are determined at runtime.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Definition</li><li class="listitem">Mutable arrays versus immutable arrays</li><li class="listitem">Example applications for arrays</li><li class="listitem">Linear searches</li><li class="listitem">Primitive arrays</li><li class="listitem">Object arrays</li><li class="listitem">Mixed arrays</li><li class="listitem">Multidimensional arrays</li><li class="listitem">Jagged arrays</li></ul></div><div><h3 class="title1"><a id="note12" class="calibre1"/>Note</h3><p class="calibre7">Note that arrays in most languages use what is known as a <strong class="calibre16">zero-based index</strong>, meaning that the first item in the array has an index of 0, the second has an index of 1, and so on.</p><p class="calibre7"><strong class="calibre16">Off-by-one errors</strong> occur when the source code attempts to access an item at a given index that is one point away from the actual item you intended to access. This type of mistake is common to new and experienced programmers alike and can very often be the source of <strong class="calibre16">Index is out of range</strong> or <strong class="calibre16">Index is out of bounds</strong> runtime errors.</p></div><p class="calibre7">
</p><div><img src="img/00002.jpeg" alt="Arrays: Foundational Collections" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><div><h3 class="title1"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre7"><strong class="calibre16">Compile time and runtime</strong></p><p class="calibre7">In compiled programming languages (as opposed to interpreted languages), the difference between compile time and runtime is simply the difference between when an application is compiled and when it is run. During compiling, the high-level source code that the developer has written is fed into another program (usually called a compiler, oddly enough). The compiler checks whether the source code has the proper syntax, confirms type constraints are enforced, optimizes the code, and then produces an executable in a low-level language that the target architecture can utilize. If a program succeeds in compiling, we know that the source code is well formed and the resulting executable can be started. Note that developers will sometimes use the term <em class="calibre20">compile time</em> to include the actual process of writing the source code, although this is semantically incorrect.</p><p class="calibre7">During runtime, the compiled code runs in the execution environment, but it can still experience errors. For example, attempting to divide by zero, dereferencing null memory pointers, running out of memory, or attempting to access resources that do not exist could all potentially crash your application if your source code does not handle these scenarios gracefully.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec11" class="calibre1"/>Mutable versus immutable arrays</h1></div></div></div><p class="calibre7">Typically, languages that are based on the C language share many of the same fundamental characteristics. For example, in C the size of a plain array cannot be changed once the array has been created. Since the four languages we are examining here are all based on C, the arrays we will be working with also have a fixed length in. However, although the size of an array cannot be changed, the contents of the structure can change after the array is created.</p><p class="calibre7">So, are arrays mutable or immutable? In terms of mutability, we say that <em class="calibre20">plain C arrays are </em>
<em class="calibre20">immutable</em> because the structure itself cannot change once it has been created. For this reason, it is typically a bad idea to use a plain C array for anything other than static datasets. This is because, whenever the dataset changes, your program will need to copy the modified data into a new array object and dispose of the old one, which are both costly operations.</p><p class="calibre7">Most of the array objects you will be working with in higher-level languages are not plain C arrays, but rather wrapper classes created for the developer's convenience. Array wrapper classes encapsulate the complexities of the underlying data structure in favor of methods that handle the heavy lifting behind the scenes and properties that expose the characteristics of the dataset.</p><div><h3 class="title1"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre7">Whenever a language provides a wrapper class for a particular type or data structure, you should take advantage of it. These are more convenient than writing your own implementation, and typically more reliable.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title2" id="calibre_pb_2"><a id="ch02lvl2sec12" class="calibre1"/>Case study: users logged in to a web service</h2></div></div></div><p class="calibre7"><strong class="calibre16">Business problem</strong>: A developer has created an application that logs mobile users in to a particular web service. Due to limitations in the server hardware, the web service can only permit 30 connected users at any given time. Therefore, the developer needs a way to track and limit the number of mobile device users who have connected to the service. In order to avoid duplicate users being permitted to log in and overload the service, a simple count of the connections is insufficient, as the developer will have no way of differentiating between the owners of each connection. Maintaining an array of objects representing a logged-in user is chosen as a core component of the solution.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><pre class="programlisting">    using System; 
    //... 
    User[] _users; 
    public LoggedInUserArray () 
    { 
        User[] users = new User[0]; 
       _users = users; 
    } 
</pre><p class="calibre7">There are a few important pieces of the preceding example we need to make note of. First, we are storing our <code class="literal">User</code> instances in a private class field called <code class="literal">_users</code>. Next, the constructor is instantiating a new array of <code class="literal">User</code> objects. Finally, we are instantiating the array to be 0 items in length and then assigning that collection to our private backer field. This is because our array doesn't have any users assigned to it yet, and we don't want to further complicate this code by trying to keep track of null values. In a real-world example, you might choose to instantiate and assign the private backer field all in one line:</p><pre class="programlisting">    _users = new User[0]; 
</pre><p class="calibre7">The former example is more verbose and, therefore, more readable. However, using the more succinct example takes up less space. Either approach will work. Next we'll look at a method that allows us to add <code class="literal">User</code> objects to the array:</p><pre class="programlisting">    bool CanAddUser(User user) 
    { 
        bool containsUser = false; 
        foreach (User u in _users) 
        { 
            if (user == u) 
            { 
                containsUser = true; 
                break; 
            } 
        } 
 
        if (containsUser) 
        { 
            return false; 
        } else { 
            if (_users.Length &gt;= 30) 
            { 
                return false; 
            } else { 
                return true; 
            } 
        } 
    } 
</pre><p class="calibre7">Here, we introduced a private method for some form of <strong class="calibre16">validation</strong>. The purpose of this method is to determine whether adding a user to the array is a valid operation at this time. First, we declared a <code class="literal">bool</code> variable called <code class="literal">containsUser</code>. We'll use this flag to signal whether or not the array already contains the <code class="literal">User</code> object being passed in. Next, we performed a <code class="literal">for</code> loop to check every object in the array against the passed in <code class="literal">User</code> object. If we find a match, we set the <code class="literal">containsUser</code> flag to <code class="literal">true</code> and break out of the <code class="literal">for</code> loop to save processor time. If <code class="literal">containsUser</code> is <code class="literal">true</code>, we know that the user object was found, and adding another copy would be a violation of our specified business rules. So, the method returns <code class="literal">false</code>. If the user does not exist in the array, execution continues.</p><p class="calibre7">Next, we checked whether the array already contains 30 or more items by evaluating its <code class="literal">Length</code> property. If <code class="literal">true</code>, we return <code class="literal">false</code> because the array is full according to our business rules and adding more would be a violation. Otherwise, we return <code class="literal">true</code> and program execution can continue:</p><pre class="programlisting">    public void UserAuthenticated(User user) 
    { 
        if (this.CanAddUser(user)) 
        { 
            Array.Resize(ref _users, _users.Length + 1); 
            _users[_users.Length - 1] = user; 
            Console.WriteLine("Length after adding user {0}: {1}", user.Id, _users.Length); 
        } 
    } 
</pre><p class="calibre7">This method is called once the user has been authenticated, which is the only time we want to add a user to the user rolls. In this method, we validated the add user operation by calling the <code class="literal">CanAddUser()</code> method. If the <code class="literal">CanAddUser()</code> method returns <code class="literal">true</code>, method execution continues. First, we used the <code class="literal">Array</code> wrapper class' <code class="literal">Resize()</code> method to grow the array by one and make room for our new addition. Next, we assigned the new <code class="literal">User</code> object to the last position in the resized array. Finally, we performed some simple housekeeping by logging the user id and new length of the <code class="literal">_users</code> array to the console:</p><pre class="programlisting">    public void UserLoggedOut(User user) 
    { 
        int index = Array.IndexOf(_users, user); 
        if (index &gt; -1) 
        { 
            User[] newUsers = new User[_users.Length - 1]; 
            for (int i = 0, j = 0; i &lt; newUsers.Length - 1; i++, j++) 
            { 
                if (i == index) 
                { 
                    j++; 
                } 
                newUsers[i] = _users[j]; 
            }  
            _users = newUsers; 
        } 
        else 
        { 
            Console.WriteLine("User {0} not found.", user.Id); 
        } 
        Console.WriteLine("Length after logging out user {0}: {1}", user.Id, _users.Length); 
    }  
</pre><p class="calibre7">This method is called when a previously authenticated user has been logged out of the web service. It uses the array wrapper class' <code class="literal">IndexOf()</code> method to determine whether the passed-in <code class="literal">User</code> object exists in the array. Since the <code class="literal">IndexOf()</code> returns <code class="literal">-1</code> if no matching object can be found, this method confirms that the value of <code class="literal">i</code> is equal to <code class="literal">-1</code>. If the value of<code class="literal"> index</code> is equal to <code class="literal">-1</code> we perform some housekeeping in the form of a console message stating this user ID is not currently logged in. Otherwise, we begin the process of deleting an object from an array.</p><p class="calibre7">First, we have to create a temporary array that is one element shorter than the old array. Next, we loop from 0 to the length of the new array, with <code class="literal">i</code> marking the position in the new array and <code class="literal">j</code> marking the position in the old array. If <code class="literal">i</code> equals the position of the item we want to remove, we increment <code class="literal">j</code> to skip past that element in the old array. Finally, we assign a user we intend to keep from the correct position in the old array to the new array. Once we're done iterating over the array, we assign the new list to the <code class="literal">_users</code> property. After this, we perform some simple housekeeping by logging the deleted user ID and new length of the <code class="literal">_users</code> array to the console.</p><p class="calibre7"><strong class="calibre16">Java</strong></p><pre class="programlisting">    User[] _users; 
 
    public LoggedInUserArray() 
    { 
        User[] users = new User[0]; 
        _users = users; 
    } 
</pre><p class="calibre7">There are a few important pieces of the preceding example we need to make note of. First, we are storing our <code class="literal">User</code> instances in a private class field called <code class="literal">_users</code>. Next, the constructor is instantiating a new array of <code class="literal">User</code> objects. Finally, we are instantiating the array as 0 items in length and then assigning that collection to our private backer field. This is because our array doesn't have any users assigned to it yet, and we don't want to further complicate this code by trying to keep track of null values. In a real-world example, you might choose to instantiate and assign the private backer field all in one line:</p><pre class="programlisting">    _users = new User[0]; 
</pre><p class="calibre7">The former example is more verbose and, therefore, more readable. However, using the more succinct example takes up less space. As with C#, either approach will work:</p><pre class="programlisting">    boolean CanAddUser(User user) 
    { 
        boolean containsUser = false; 
        for (User u : _users) 
        { 
            if (user.equals(u)) 
            { 
                containsUser = true; 
                break; 
            } 
        } 
 
        if (containsUser) 
        { 
            return false; 
        } else { 
            if (_users.length &gt;= 30) 
            { 
                return false; 
            } else { 
                return true; 
            } 
        } 
    } 
</pre><p class="calibre7">Here, we are introducing a private method for some sort of validation. The purpose of this method is to determine whether adding a user to the array is a valid operation at this time. First, we declared a <code class="literal">boolean</code> variable called <code class="literal">containsUser</code>. We'll use this flag to signal whether or not the array already contains the <code class="literal">User</code> object being passed in. Next, we performed a <code class="literal">for</code> loop to check every object in the array against the passed-in <code class="literal">User</code> object. If we find a match, we set the <code class="literal">containsUser</code> flag to <code class="literal">true</code> and break out of the <code class="literal">for</code> loop to save processor time. If <code class="literal">containsUser</code> is true<code class="literal">,</code> we know the user object was found, and adding another copy would be a violation of our specified business rules. So, the method returns <code class="literal">false</code>. If the user does not exist in the array, execution continues.</p><p class="calibre7">Next, we check whether the array already contains 30 or more items by evaluating its <code class="literal">Length</code> property. If <code class="literal">true</code>, we return <code class="literal">false</code> because the array is full according to our business rules, and adding more would be a violation. Otherwise, we return <code class="literal">true</code>, and program execution can continue:</p><pre class="programlisting">    public void UserAuthenticated(User user) 
    { 
        if (this.CanAddUser(user)) 
        { 
            _users = Arrays.copyOf(_users, _users.length + 1); 
            _users[_users.length - 1] = user; 
            System.out.println("Length after adding user " + user.GetId() + ": " + _users.length); 
        } 
    } 
</pre><p class="calibre7">This method is called once the user has been authenticated, which is the only time we want to add a user to the user rolls. In this method, we validated the add user operation by calling the <code class="literal">CanAddUser()</code> method. If <code class="literal">CanAddUser()</code> returns <code class="literal">true</code>, the method execution continues. First, we used the <code class="literal">Arrays</code> wrapper class' <code class="literal">copyOf()</code> method to create a new copy of the array that is one element larger, making room for our new addition. Next, we assign the new <code class="literal">User</code> object to the last position in the resized array. Finally, we performed some simple housekeeping by logging the user id and the new length of the <code class="literal">_users</code> array to the console:</p><pre class="programlisting">    public void UserLoggedOut(User user) 
    { 
        int index = -1; 
        int k = 0; 
        for (User u : _users) 
        { 
            if (user == u) 
            { 
                index = k; 
                break; 
            } 
            k++; 
        } 
 
        if (index == -1) 
        { 
            System.out.println("User " + user.GetId() + " not found."); 
        } 
        else 
        { 
            User[] newUsers = new User[_users.length - 1]; 
            for (int i = 0, j = 0; i &lt; newUsers.length - 1; i++, j++) 
            { 
                if (i == index) 
                { 
                    j++; 
                } 
                newUsers[i] = _users[j]; 
            } 
 
            _users = newUsers; 
        } 
 
        System.out.println("Length after logging out user " + user.GetId() + ": " + _users.length); 
    } 
</pre><p class="calibre7">This method is called when a previously authenticated user has been logged out of the web service. First, it loops through the <code class="literal">_users</code> array to locate a matching object to the <code class="literal">User</code> object that has been passed in. We instantiate the index value to <code class="literal">-1</code> so that, if no matching object can be found, this value does not change. This method next confirms that the value of <code class="literal">index</code> is equal to <code class="literal">-1</code>. If <code class="literal">true</code>, we perform some housekeeping by logging in to the console this user id is not currently logged in. Otherwise, we begin the process of deleting the object from the <code class="literal">_users</code> array.</p><p class="calibre7">First, we have to create a temporary array that is one element shorter than the old array. Next, we loop from 0 to the length of the new array, with <code class="literal">i</code> marking the position in the new array and <code class="literal">j</code> marking the position in the old array. If <code class="literal">i</code> equals the position of the item we want to remove, we increment <code class="literal">j</code> to skip past that element in the old array. Finally, we assign a user we intend to keep from the correct position in the old array to the new array. Once we're done looping, we assign the new list to the <code class="literal">_users</code> property. After this, we perform some simple housekeeping by logging the deleted user id and new length of the <code class="literal">_users</code> array to the console.</p><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><p class="calibre7">Working with a primitive C array in Objective-C is considerably different than in C# or Java, predominantly because Objective-C does not provide methods for working <em class="calibre20">directly</em> with the primitive type. However, Objective-C does provide the <code class="literal">NSArray</code> wrapper class, which we will use in our code example here:</p><pre class="programlisting">    @interface EDSLoggedInUserArray() 
    { 
        NSArray *_users; 
    } 
 
    -(instancetype)init 
    { 
        if (self = [super init]) 
        { 
            _users = [NSArray array]; 
        } 
        return self; 
    } 
</pre><p class="calibre7">First, our Objective-C class interface defines an <strong class="calibre16">ivar</strong> property for our array. Next, our initializer instantiates the <code class="literal">_users</code> object using the <code class="literal">[NSArrayarray]</code> convenience initializer:</p><pre class="programlisting">    -(BOOL)canAddUser:(EDSUser *)user 
    { 
        BOOL containsUser = [_users containsObject:user]; 
 
        if (containsUser) 
        { 
            return false; 
        } 
        else 
        { 
            if ([_users count] &gt;= 30) 
            { 
                return false; 
            } 
            else 
            { 
                return true; 
            } 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">canAddUser:</code> method also serves as internal validation in our Objective-C example. The purpose of this method is to determine whether adding a user to the array is a valid operation at this time. Since we're working with <code class="literal">NSArray</code>, we have access to the <code class="literal">containsUser:</code> method, which can immediately determine whether the passed-in <code class="literal">User</code> object exists in the <code class="literal">_users</code> array. Don't be fooled by the simplicity of this code, however, because, under the <code class="literal">NSArray</code> hood, the <code class="literal">containsUser:</code> method looks something like this:</p><pre class="programlisting">    BOOL containsUser = NO; 
    for (EDSUser *u in _users) { 
        if (user.userId == u.userId) 
        { 
            containsUser = YES; 
            break; 
        } 
    } 
</pre><p class="calibre7">If that code looks familiar, it should because it is nearly identical in function to our previous C# and Java examples. The <code class="literal">containsObject:</code> method exists for our convenience, and it performs the heavy lifting for us behind the scenes. Again, if the user object is found, adding another copy is a violation of our specified business rules, and the method returns <code class="literal">false</code>. If the user does not exist, execution continues.</p><p class="calibre7">Next, we check whether the array already contains 30 or more items by evaluating its <code class="literal">count</code> property. If <code class="literal">true</code>, we return <code class="literal">false</code> because the array is full according to our business rules, and adding more would be a violation. Otherwise, we return <code class="literal">true</code>, and program execution can continue:</p><pre class="programlisting">    -(void)userAuthenticated:(EDSUser *)user 
    { 
        if ([self canAddUser:user]) 
        { 
            _users = [_users arrayByAddingObject:user]; 
            NSLog(@"Length after adding user %lu: %lu", user.userId, [_users count]); 
        } 
    } 
</pre><p class="calibre7">This method is called once the user has been authenticated, which is the only time we want to add a user to the user rolls. In this method, we validated the add user operation by calling <code class="literal">canAddUser:</code>. If <code class="literal">canAddUser:</code> returns <code class="literal">true</code>, the method execution continues. We use the <code class="literal">NSArray</code> class' <code class="literal">arrayByAddingObject:</code> method to create a new copy of the array that includes our new <code class="literal">User</code> object. Last, we performed some simple housekeeping by logging the user id and new length of the <code class="literal">_users</code> array to the console:</p><pre class="programlisting">-(void)userLoggedOut:(EDSUser *)user 
{ 
    NSUInteger index = [_users indexOfObject:user]; 
    if (index == NSNotFound) 
    { 
        NSLog(@"User %lu not found.", user.userId); 
    } 
    else 
    { 
        NSArray *newUsers = [NSArray array]; 
        for (EDSUser *u in _users) 
        { 
            if (user != u) 
            { 
                newUsers = [newUsers arrayByAddingObject:u]; 
            } 
        } 
         
        _users = newUsers; 
    } 
     
    NSLog(@"Length after logging out user %lu: %lu", user.userId, [_users count]); 
} 
</pre><p class="calibre7">This method is called when a previously authenticated user has been logged out of the web service. First, it uses the <code class="literal">NSArray indexOfObject:</code> array to get an index for any object matching the <code class="literal">User</code> object that has been passed in. If the object is not found, the method returns <code class="literal">NSNotFound</code>, which is equivalent to <code class="literal">NSIntegerMax</code>.</p><p class="calibre7">This method next confirms that the value of <code class="literal">index</code> is equal to <code class="literal">NSNotFound</code>. If <code class="literal">true</code>, we perform some housekeeping by logging in to the console to which this user id is not currently logged in. Otherwise, we begin the process of deleting the object from the <code class="literal">_users</code> array.</p><p class="calibre7">Unfortunately, <code class="literal">NSArray</code> does not provide a method for deleting an object from the underlying immutable array, so we need to get a little creative. First, we create a temporary array object called <code class="literal">newUsers</code> to hold all the <code class="literal">User</code> objects that we want to keep. Next, we loop through the <code class="literal">_users</code> array, checking each object to see whether it matches the <code class="literal">User</code> we want to delete. If there is no match, we add it to the <code class="literal">newUsers</code> array in the same way we added a new user to <code class="literal">_users</code> when a user is authenticated. If the <code class="literal">User</code> object matches, we simply skip it, effectively deleting it from the final array of objects. As you can imagine, this procedure is very costly, and this pattern should be avoided if at all possible. Once the loop is complete, we assign the new array to the <code class="literal">_users</code> property. Finally, we perform some simple housekeeping by logging the deleted user id and the new count of the <code class="literal">_users</code> array to the console.</p><p class="calibre7"><strong class="calibre16">Swift</strong></p><p class="calibre7">Working with a primitive C array in Swift is very similar to doing so in C# or Java, in that it provides the <code class="literal">Array</code> class, which we will use in our code example here:</p><pre class="programlisting">var _users: Array = [EDSUser]() 
</pre><p class="calibre7">We only need one class property to support our array of users. Swift arrays are type-dependent just as in C# and Java, and we must declare the type when declaring the array property. Note the difference in how Swift initializes arrays by surrounding the type name or object class name with the subscription operator, rather than appending the operator to the name:</p><pre class="programlisting">    func canAddUser(user: EDSUser) -&gt; Bool 
    { 
        if (_users.contains(user)) 
        { 
            return false; 
        } 
        else 
        { 
            if (_users.count &gt;= 30) 
            { 
                return false; 
            } 
            else 
            { 
                return true; 
            } 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">canAddUser:</code> method also serves as internal validation. The purpose of this method is to determine whether adding a user to the array is a valid operation at this time. First, we're using the <code class="literal">Array.contains()</code> method to determine whether the user we want to add already exists in the array. If the user object is found, adding another copy is a violation of our specified business rules, and the method returns <code class="literal">false</code>. If the user does not exist, execution continues.</p><p class="calibre7">Next, we use the <code class="literal">count</code> property of the <code class="literal">_users</code> array to check that the total number of objects within the array is not greater than or equal to 30. If <code class="literal">true</code>, we return <code class="literal">false</code> because the array is full according to our business rules, and adding more would be a violation. Otherwise, we return <code class="literal">true</code>, and program execution can continue:</p><pre class="programlisting">    public func userAuthenticated(user: EDSUser) 
    { 
        if (self.canAddUser(user)) 
        { 
            _users.append(user) 
        }  
        print("Length after adding user \(user._userId): \ (_users.count)"); 
    } 
</pre><p class="calibre7">Again, this method is called once the user has been authenticated, which is the only time we want to add a user to the user rolls. In this method, we validate the add user operation by calling the <code class="literal">canAddUser()</code> method. If <code class="literal">canAddUser()</code> returns <code class="literal">true</code>, the method execution continues, and we add the user to the array using the <code class="literal">Array.append()</code> method. Last, we perform some simple housekeeping by logging the user id and new length of the <code class="literal">_users</code> array to the console:</p><pre class="programlisting">    public func userLoggedOut(user: EDSUser) 
    { 
        if let index = _users.indexOf(user) 
        { 
            _users.removeAtIndex(index) 
        }  
        print("Length after logging out user \(user._userId): \(_users.count)") 
    } 
</pre><p class="calibre7">Finally, to remove a user during logout, we first need to determine whether the object exists in the array and get its index within the array. Swift allows us to simultaneously declare the <code class="literal">index</code> variable, perform this check, and assign a value to <code class="literal">index</code>. If this check returns <code class="literal">true</code>, we call <code class="literal">Array.removeAtIndex()</code> to take the <code class="literal">user</code> object out of the array. Finally, we perform some simple housekeeping by logging the deleted user ID and the new count of the <code class="literal">_users</code> array to the console.</p><div><h3 class="title1"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre7"><strong class="calibre16">Separation of concerns</strong></p><p class="calibre7">When you examine the previous examples, you might wonder what happens to all those <code class="literal">User</code> objects we have been adding once we are done with them. If so, great catch! If you look closely, you will see we have not instantiated or modified a single <code class="literal">User</code> object in this example-only the array that was contained the objects. This is by design.</p><p class="calibre7">In object-oriented programming, the concept of <strong class="calibre16">separation of concerns</strong> dictates that computer programs should be broken up into distinct operational features that overlap as little as possible. For example, a class named <code class="literal">LoggedInUserArray</code>, which operates as a wrapper to an underlying array structure, should only manipulate its array's operations and have little bearing on objects within the array. In this case, the inner workings and details of the <code class="literal">User</code> class objects that are passed in are not the <code class="literal">LoggedInUserArray</code> class's concern.</p><p class="calibre7">Once each <code class="literal">User</code> is removed from the array, the object goes on its merry way. If the application retains no other references to the <code class="literal">User</code> object, some form of <strong class="calibre16">garbage collection</strong> will eventually dispose it off from memory. Either way, the <code class="literal">LoggedInUserArray</code> class is not responsible for garbage collection and remains agnostic concerning these types of detail.</p></div></div></div></div>

<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec12" class="calibre1"/>Advanced topics</h1></div></div></div><p class="calibre7">Now that we have seen how arrays are used in common practice, let's examine a few advanced topics relating to arrays: search patterns and variations on the basic types of objects that can be stored in an array.</p></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_1"><a id="ch02lvl2sec13" class="calibre1"/>Linear search</h2></div></div></div><p class="calibre7">When learning about data structures, it is impossible to avoid discussing the subjects of <strong class="calibre16">searching</strong> and <strong class="calibre16">sorting</strong>. Without the ability to search a data structure, the data would be fairly useless to us. Without the ability to sort the data set for use in a particular application, the data would be extremely tedious to manage.</p><p class="calibre7">The steps or process we follow to perform a search or a sort of a particular data structure are called an <strong class="calibre16">algorithm</strong>. The performance or the complexity of an algorithm in computer science is measured using the <strong class="calibre16">big O notation</strong>, which is derived from the function <em class="calibre20">f(n) = </em>
<strong class="calibre16">O</strong>
<em class="calibre20">(g(n))</em>, read as <em class="calibre20">f of n equals big oh of g of n</em>. In the simplest terms, <strong class="calibre16">big</strong>
<strong class="calibre16">O</strong> is the terminology we use to describe the worst case for how long an algorithm takes to run. For example, if we know the index of the object we are searching for in an array, it takes only one comparison to locate and retrieve that object. Therefore, the worst case requires one comparison, and the cost of the search is <strong class="calibre16">O</strong>(<em class="calibre20">1</em>).</p><p class="calibre7">Although we will examine searching and sorting in much greater detail later, for now, we will examine <strong class="calibre16">linear searching</strong>, or sequential searching, which is the simplest and least efficient pattern for searching a collection. Iteration means repeating a process over and over again. With a linear search, we iterate sequentially over the collection of objects until we find a match to our search pattern. For collections containing <em class="calibre20">n</em> items, the best-case search is when the target value is equal to the first item in the collection, which means, only one comparison is required. In the worst-case scenario, the target value is not found in the collection at all, which means <em class="calibre20">n</em> comparisons are required. This means the cost of a linear search is <strong class="calibre16">O</strong>(<em class="calibre20">n</em>). If you look back at the code examples, you will see <strong class="calibre16">O</strong>(<em class="calibre20">n</em>) searches in several places:</p><p class="calibre7"><strong class="calibre16">C#</strong></p><p class="calibre7">Here's the linear search algorithm from our C# code but reformatted to use a <code class="literal">for</code> loop, which better demonstrates the concept of <strong class="calibre16">O</strong>(<em class="calibre20">n</em>) cost:</p><pre class="programlisting">    for (int i = 0; i &lt; _users.Count; i++) 
    { 
        if (_users[i] == u) 
        { 
            containsUser = true; 
            break; 
        }  
    } 
</pre><p class="calibre7"><strong class="calibre16">Java</strong></p><p class="calibre7">Here's the linear search algorithm from our Java code but reformatted to use a <code class="literal">for</code> loop, which better demonstrates the concept of <strong class="calibre16">O</strong>(<em class="calibre20">n</em>) cost:</p><pre class="programlisting">    for (int i = 0; I &lt; _users.size(); i++) 
    { 
        if (_users[i].equals(u)) 
        { 
            containsUser = true; 
            break; 
        } 
    } 
</pre><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><p class="calibre7">Here's the linear search algorithm from our Objective-C code but reformatted to use a <code class="literal">for</code> loop which better demonstrates the concept of <strong class="calibre16">O</strong>(<em class="calibre20">n</em>) cost:</p><pre class="programlisting">    for (int i = 1; i &lt; [_users count]; i++)  
    { 
        if (((User*)[_users objectAtIndex:i]).userId == u.userId) 
        { 
            containsUser = YES; 
            break; 
        } 
    } 
</pre><p class="calibre7"><strong class="calibre16">Swift</strong></p><p class="calibre7">Our Swift code does not include an example of a linear search, but one example could look like this:</p><pre class="programlisting">    for i in 1..&lt;_users.count 
    { 
        //Perform comparison 
    } 
</pre></div></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_2"><a id="ch02lvl2sec14" class="calibre1"/>Primitive arrays</h2></div></div></div><p class="calibre7">Primitive arrays are simply arrays that only contain primitive types. In C#, Java, and Swift, you declare a primitive array by declaring an array on a primitive type. As a weakly typed language, Objective-C does not support explicitly typed arrays, and therefore does not support explicitly primitive arrays.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><pre class="programlisting">    int[] array = new int[10]; 
</pre><p class="calibre7"><strong class="calibre16">Java</strong></p><pre class="programlisting">    int[] array = new int[10]; 
</pre><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><pre class="programlisting">    NSArray *array = [NSArray array]; 
</pre><p class="calibre7"><strong class="calibre16">Swift</strong></p><pre class="programlisting">    var array: Array = [UInt]() 
</pre></div></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_3"><a id="ch02lvl2sec15" class="calibre1"/>Object arrays</h2></div></div></div><p class="calibre7">Object arrays are simply arrays that contain only instances of a particular object. In C#, Java, and Swift, you declare an object array by declaring an array on class. As a weakly typed language, Objective-C does not support explicitly typed arrays and, therefore, does not support explicitly object arrays.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><pre class="programlisting">    Vehicle[] cars = new Vehicle[10]; 
</pre><p class="calibre7"><strong class="calibre16">Java</strong></p><pre class="programlisting">    Vehicle[] cars = new Vehicle[10]; 
</pre><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><pre class="programlisting">    NSArray *array = [NSArray array]; 
</pre><p class="calibre7"><strong class="calibre16">Swift</strong></p><pre class="programlisting">    var vehicle: Array = [Vehicle]() 
</pre></div></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_4"><a id="ch02lvl2sec16" class="calibre1"/>Mixed arrays</h2></div></div></div><p class="calibre7">When working with arrays, you declare the array using one data type, and all of the elements in the array must match that data type. Typically, this constraint is suitable, since the elements are normally closely related to one another or share similar property values. At other times, the elements in your array are not closely related or do not have similar property values. In these circumstances, it is desirable to have the ability to mix-and-match types within the same array. C# and Java share a similar mechanism for accomplishing this--declaring the array as the root class object type. Arrays in Objective-C are already mixed by default due to the language being weakly typed. Swift provides the <code class="literal">AnyObject</code> type for declaring mixed arrays.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><pre class="programlisting">    Object[] data = new Object[10]; 
</pre><p class="calibre7"><strong class="calibre16">Java</strong></p><pre class="programlisting">    Object[] data = new Object[10]; 
</pre><p class="calibre7"><strong class="calibre16">Objective-C</strong></p><pre class="programlisting">    NSArray *data = [NSArray array]; 
</pre><p class="calibre7"><strong class="calibre16">Swift</strong></p><pre class="programlisting">    var data: Array = [AnyObject]() 
</pre><p class="calibre7">Working with mixed arrays can seem convenient at the first glance, but be aware that you as the developer take the responsibility for type checking away from the compiler. This won't be a major adjustment for developers with weakly typed languages such as Objective-C, but developers experienced in strongly typed languages will need to be very attentive to this concern.</p></div></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_5"><a id="ch02lvl2sec17" class="calibre1"/>Multidimensional arrays</h2></div></div></div><p class="calibre7">A multidimensional array is an array containing one or more additional arrays. The four languages we are working with can each support multidimensional arrays of <em class="calibre20">1...n</em> dimensions. However, be aware that multidimensional arrays greater than three levels deep become extremely difficult to manage.</p><p class="calibre7">It sometimes helps to conceptualize multidimensional arrays in terms relative to their dimensions. For example, a 2D array might have rows and columns, or <em class="calibre20">x</em> and <em class="calibre20">y</em> values. Similarly, a 3D array might have <em class="calibre20">x</em>, <em class="calibre20">y</em>, and <em class="calibre20">z</em> values. Let's look at an example of 2D and 3D arrays in each language.</p><p class="calibre7"><strong class="calibre16">C#</strong></p><p class="calibre7">Multidimensional arrays in C# are created with the <code class="literal">[,]</code> syntax, where each <code class="literal">,</code> represents one additional dimension within the array. The corresponding <code class="literal">new</code> initializer must provide the correct number of size arguments to match the definition or the code will not compile:</p><pre class="programlisting">    //Initialize 
    int<strong class="calibre16">[,]</strong> twoDArray = new int<strong class="calibre16">[5, 5]</strong>; 
    int<strong class="calibre16">[, ,]</strong> threeDArray = new int<strong class="calibre16">[5, 6, 7]</strong>; 
 
    //Set values 
    twoDArray[2,5] = 90; 
    threeDArray[0, 0, 4] = 18; 
 
    //Get values 
    int x2y5 = twoDArray[2,5]; 
    int x0y0z4 = threeDArray[0,0,4]; 
</pre><p class="calibre7"><strong class="calibre16">Java</strong></p><p class="calibre7">The syntax for creating multidimensional arrays in Java simply involves stringing pairs of <code class="literal">[]</code> where each pair represents one dimension within the array. The corresponding <code class="literal">new</code> initializer must provide the correct number of bracketed size arguments to match the definition or the code will not compile:</p><pre class="programlisting">    //Initialize 
    int<strong class="calibre16">[][]</strong> twoDArray = new int<strong class="calibre16">[5][5]</strong>; 
    int<strong class="calibre16">[][][]</strong> threeDArray = new int<strong class="calibre16">[5][6][7]</strong>; 
 
    //Set values 
    twoDArray[2][5] = 90; 
    threeDArray[0][0][4] = 18; 
 
    //Get values 
    int x2y5 = twoDArray[2][5]; 
    int x0y0z4 = threeDArray[0][0][4]; 
</pre><strong class="calibre16">Objective-C</strong><p class="calibre7">Objective-C does not directly support multidimensional arrays with the <code class="literal">NSArray</code> class. If a multidimensional array is required in your code, you will need to use <code class="literal">NSMutableArray</code> or a plain C array, both of which are outside the scope of this chapter.</p><p class="calibre7"><strong class="calibre16">Swift</strong></p><p class="calibre7">Multidimensional arrays in Swift can seem somewhat confusing at first glance, but what you need to realize is that you are creating arrays of arrays. The definition syntax is <code class="literal">[[Int]]</code> while the initialization syntax is <code class="literal">[[1, 2], [3, 4]]</code> where the values used at initialization can be any value of the specified type:</p><pre class="programlisting">    //Initialize 
    var twoDArray: [[Int]] = [[1, 2], [3, 4]] 
    var threeDArray: [[[Int]]] = [[[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2, 3], [4, 5, 6], [7, 8, 9]]] 
 
    //Set values 
    twoDArray[0][1] = 90; 
    threeDArray[0][0][2] = 18; 
 
    //Get values 
    var x0y1: Int = twoDArray[0][1]; 
    var x0y0z2: Int = threeDArray[0][0][2]; 
</pre></div></div>

<div><div><div><div><div><h2 class="title2" id="calibre_pb_6"><a id="ch02lvl2sec18" class="calibre1"/>Jagged Arrays</h2></div></div></div><p class="calibre7">Jagged arrays are created when a multidimensional array contains arrays of different sizes. There are rare scenarios when such a design is necessary, but be aware that jagged arrays can be very complex and difficult to manage. C#, Java, and Swift support jagged arrays. Objective-C does not support multidimensional arrays using <code class="literal">NSArray</code>, and therefore, does not support jagged arrays using it. As with multidimensional arrays, Objective-C can support jagged arrays using either <code class="literal">NSMutableArray</code> or plain C arrays.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned the basic definition of an array structure, how arrays look in memory, and how each of the four languages we are discussing implement some form of the plain C array structure. Next, we discussed the difference between mutable and immutable arrays. Using examples, we looked at how each of the four languages we are discussing implements arrays and array functionality. In the remainder of the chapter, we examined the linear search algorithm and introduced the big <strong class="calibre16">O</strong> notation, including how this notation is applied to arrays with examples of simple iteration. We discussed the difference between primitive arrays, object arrays, and mixed arrays. Finally, we examined multidimensional arrays and their counterpart, jagged arrays.</p><p class="calibre7">As a final note, it is important to know when to use an array. Arrays are great for containing small lists of constant data or data that changes very little to not at all. If you find yourself constantly manipulating the data in your array or constantly adding and removing objects, then you will want to examine alternative data structures such as the List which we will discuss in the following chapter.</p></div></body></html>