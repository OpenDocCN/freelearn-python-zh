- en: 'Chapter 11. Graphs: Values with Relationships'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final data structure that we will examine is the **Graph**. Graphs are sets
    of objects with no specifically structured relationship, where each object can
    have links to one or many other objects in the collection. Objects in graphs are
    typically referred to as nodes, vertices, or points. Links, or the relationships
    between the objects, are referred to as edges, lines, or arcs. These links can
    be simple references or they can be objects with values of their own. More formally
    stated, graphs are a pair of sets *(N, E)*, where *N* is the set of nodes and
    *E* is the set of edges in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: One excellent example of graph applications would be visualizing the relationships
    between individuals in a social media database. In such a database, each person
    in the database represents one node, and each of their links to other people in
    their circle of acquaintances represents an edge. In such a circle of acquaintances,
    it would be perfectly reasonable to see circular or even intertwined relationships
    between nodes as one person can share many of the same friends or coworkers as
    another person. Tree and heap structures would very rapidly break down when attempting
    to rationalize these sets, while the graph data structure was practically designed
    with such scenarios in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of the graph data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual conception of the graph structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual graph concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is sometimes easier to grasp the concept of graph data structures using
    visual representations of some collections. Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual graph concepts](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a basic graph consisting of eleven nodes and twelve edges. Sets *N*
    and *E* can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*E = {2:38, 2:77, 2:97, 3:19, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5, 11:52, 77:9}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, in this example, there are only unidirectional edges between nodes.
    This is perfectly acceptable, but graphs are much more powerful when bidirectional
    nodes are permitted. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual graph concepts](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the same graph we saw earlier, but set *E* now contains several new
    reciprocal edges between existing nodes. Sets *N* and *E* can now be described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*E = {2:5, 2:38, 2:77, 2:97, 3:19, 4:11, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5,
    11:52, 77:9, 97:2}*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, edges between nodes can also be defined with a particular value. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual graph concepts](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this figure, we see a graph with a set of six nodes and seven edges. In
    this case, however, the edges are further defined by a specific value. This value
    is not limited to integers, but it can be represented by any type or custom object
    you need. Sets *N* and *E* for this graph can be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N = {2, 4, 5, 52, 97}*'
  prefs: []
  type: TYPE_NORMAL
- en: '*E = {2:5(84), 4:11(97), 11:2(70), 11:4(97), 11:5(16), 11:52(102), 97:2(14)}*'
  prefs: []
  type: TYPE_NORMAL
- en: Graph operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since graphs support bidirectional references between nodes and nodes can virtually
    have unlimited neighbors, it is necessary to define two basic objects in order
    to implement the collection. These include the nodes that make up the graph as
    well as the graph collection itself. Optionally, an edge object may be required
    if the implementation supports edges that contain a value. Therefore, note that
    some of these common graph operations will have components in more than one class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AddNode**: This operation is sometimes called the **AddVertex** or **AddPoint**
    operation, and is dependent on the language used to define the graph. The AddNode
    operation simply inserts new nodes into the graph without defining any edges or
    references to neighboring nodes. Since a node does not necessarily need to have
    neighbors to exist in the graph, the AddNode operation represents an **O**(1)
    operation. Also note that the AddNode operation is exclusively implemented in
    the graph collection object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RemoveNode**: This operation is sometimes called the **RemoveVertex** or
    RemovePoint operation, and it is dependent on the language used to define the
    graph. The RemoveNode operation deletes the node from the graph and removes any
    edges or references to and from neighboring nodes. This operation has an **O**(*n*
    + *k*) operational cost, where *n* is the number of nodes in our graph and *k*
    is the number of edges. The RemoveNode operation is exclusively implemented in
    the graph collection object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This may seem expensive for a simple remove operation, but keep in mind that
    references in a graph can be bidirectional, meaning that our node could potentially
    have edges to every other node in the graph while every other node in the graph
    could simultaneously have edges pointing back to our node.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is primarily a concern with graphs designed to support edges that contain
    a value. In that case, each edge must be individually examined to determine if
    it points to the node being removed, and it must be handled accordingly if that
    is the case. In graphs where edges are merely pointers between objects, setting
    an object to `null` or `nil` will effectively eliminate any edges that point to
    it, potentially reducing this operation's cost to **O**(1).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**AddEdge**: This operation is sometimes called the **AddArc** or **AddLine**
    operation, and it is dependent on the language used to define the node. The AddEdge
    operation simply adds a new edge from node `x` to node `y`. The AddEdge operation
    is implemented in both the collection object and the node object. At the node
    level, only the target node `y` must be passed as a parameter; while at the graph
    level, both `x` and `y` must be provided. If the graph supports edges with values,
    the new value must also be passed as a parameter, to the graph operation. Since
    graphs support bidirectional relationships between nodes, there is no need to
    first confirm that an edge already exists from node `y` to node `x`. This means
    adding a new edge between nodes is a simple process with an **O**(1) operational
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RemoveEdge**: This operation is sometimes called the **RemoveArc** or **RemoveLine**
    operation, and it is dependent on the language used to define the node. The RemoveEdge
    operation simply removes an existing edge from node `x` to node `y` if it exists.
    At the node level, only the target node `y` must be passed as a parameter, while
    at the graph level, both `x` and `y` must be provided. If the graph supports edges
    with values, the new value must also be passed as a parameter to the graph operation.
    Since graphs support bidirectional relationships between nodes, removing an edge
    from node `x` to node `y` as an operation is completely independent of existing
    edges from node `y` to node `x`; and this process, therefore, has an **O**(1)
    operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetNodeValue**: The GetNodeValue operation is sometimes called the **GetVertexValue**
    or **GetPointValue** operation, and this is dependent on the language used to
    define the node. This operation returns the value associated with the node, whether
    it is a primitive or some custom object type, and the operation has an **O**(1)
    operational cost. This operation can be defined at either the graph or node level,
    but if it is defined as a part of the graph object, the node to be interrogated
    must be passed into the operation as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetNodeValue**: The SetNodeValue operation is sometimes called the **SetVertexValue**
    or **SetPointValue** operation, and it is dependent on the language used to define
    the node. This operation sets the value of the node and has an **O**(1) operational
    cost. Again, this operation can be defined at either the graph or node level but,
    if it is defined as a part of the graph object, the node to be set must be passed
    into the operation as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adjacent**: The Adjacent operation checks whether an edge exists from node
    `x` to node `y`, and typically returns a Boolean value representing the result.
    This operation is typically defined at the graph level and requires both node
    `x` and node `y` to be provided. This simple operation has an **O**(1) operational
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Neighbors**: This operation functions similarly to the children operation
    in a tree data structure. The Neighbors operation returns a list containing all
    of the nodes `y` where there is an edge from node `x` to node `y`. This operation
    is typically defined at the graph level and requires node `x` be provided. This
    operation has an **O**(1) operational cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Count**: As with many other collections, graphs typically expose a count
    operation that returns the number of nodes contained in the collection. Although
    dependent on the implementation, this operation typically has an **O**(1) operational
    cost.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GetEdgeValue**: This operation is sometimes called the GetArcValue or GetLineValue
    operation, and it is dependent on the language used to define the node. In graphs
    that support edges with values, this operation returns the value associated with
    the edge, whether it is a primitive or some custom object type, and the operation
    has an **O**(1) operational cost. This operation can also be defined as a part
    of the node object, in which case the edge to be interrogated must be passed into
    the operation as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SetEdgeValue**: This operation is sometimes called the **SetArcValue** or
    **SetLineValue** operation, and this is dependent on the language used to define
    the edge. This operation sets the value of the edge and has an **O**(1) operational
    cost. Again, this operation can be defined as a part of the node object, in which
    case the edge to be set must be passed into the operation as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with heaps, graphs are a form of tree data structure and, therefore, we will
    not find a native concrete implementation in the languages we are discussing.
    However, the graph data structure is surprisingly easy to implement, so we will
    build our own `Graph` class from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: The graph data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we begin, we need to detail a few characteristics that our graph structure
    will possess. Our graph will support nodes that have no edges to or from other
    nodes. Our graph will also support exclusive and bidirectional edges. For the
    sake of brevity, the edges in our graph collection will not support edge values,
    but adding values to edges is a simple matter if you decide to use them in your
    custom implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our graph will be made up of two classes. The first is the `Graph` class itself,
    which in our implementation will contain most of the standard graph operations.
    The next is a `GraphNode` class, which will represent the nodes of our collection.
    Note that this class could also be named `GraphVertex` or `GraphPoint`, but in
    keeping with our tree `Node` class example from [Chapter 9](part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 9. Trees: Non-Linear Structures"), *Trees: Non-linear Structures*, we
    will stick with nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Graph` class will be based on an array or list that contains the root references
    to the nodes. Each `GraphNode` object will also contain an array or list that
    holds the references to other nodes. In this implementation, these references
    represent the edges in our data structure. This class will support instantiation
    from scratch or by passing in an existing list of `GraphNode` objects. Operations
    for adding and removing both nodes and edges will be implemented in the `Graph`
    class. The `Graph` class will also contain operations for checking node adjacency,
    node neighbors, and the total count of nodes in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '**C#**'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# does not provide a concrete `Graph` or `GraphNode` class out of the box,
    so we will need to create our own. We will start with the `GraphNode` class. Here
    is what a basic implementation of a `GraphNode` class might look like in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class is very simple, containing a public field named `Value` to store
    our integer data and a `List<GraphNode>` object named `neighbors` that represents
    the edges between this node and its neighbors. The class also has two constructors
    both of which instantiate the `_neighbors` list. The overloaded `GraphNode(Int16
    value)` constructor also allows a value to be defined at instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `Graph` class might look like in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Graph` class includes one public field, a `List<GraphNode>` collection
    named `Nodes` that exposes read-only access to the private `List<GraphNode> _nodes`
    field. This field maintains the list of edges to neighboring nodes. Finally, our
    constructor accepts one parameter of the type `List<Graphnode>` and sets `_nodes`
    to this value if it is not null; otherwise, it initializes the `_nodes` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two public methods in `Graph` are `AddNode(GraphNode node)` and `AddNodeForValue(Int16
    value)`, which add two versions of the AddNode functionality to our class. The
    first adds a pre-existing node to the `_nodes` collection, while the second instantiates
    a new node using `value`, then adds that node to the `_nodes` collection. Both
    of these methods add nodes without defining any edges and, therefore, these operations
    have an **O**(1) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `RemoveNode(Int16 value)` method provides the RemoveNode functionality to
    our class. This method accepts one parameter of type `Int16` and named `value`,
    representing the node that the caller is asking to remove. The method begins by
    using a **LINQ** statement to examine each of the nodes in the collection, searching
    for a match to `value`. If no match is found, the method returns `false`. Otherwise,
    the matching node is removed from the `_nodes` collection and the method execution
    continues.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node's neighbors to find a match for `nodeToRemove`. A match found
    means an edge exists from the `node` object to the `nodeToRemove` object and returns
    an index value for that match. By removing the `nodeToRemove` object from the
    `node.Neighbors` collection using `index`, we eliminate the reference and delete
    the edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we examined in the discussion on graph operations, the `RemoveNode` operation
    has an operational cost of **O**(*n* + *k*), where *n* is the number of nodes
    in the collection and *k* is the number of edges. In the `RemoveNode(Int16 value)`
    method, the first half represents *n* and the second half represents *k* in that
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddEdge(GraphNode from, GraphNode to)` and `AddBidirectedEdge(GraphNode
    from, GraphNode to)` methods provide the AddEdge functionality to the `Graph`
    class. The first method is the standard AddEdge operation, while the second method
    exists more as a convenience in case the caller wants to immediately add bidirectional
    references. The first method has an **O**(1) operational cost, while the second
    technically has a more unusual **O**(2) operational cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Adjacent(GraphNode from, GraphNode to)` method returns a Boolean value
    denoting whether an edge exists between two nodes, `from` and `to`. Hopefully
    the signature makes the direction of this edge clear but, for clarity, this method
    only confirms that an edge exists from the `from` node and to the `to` node, but
    not the reciprocal. Since this method is based on the `contains` function, it
    has an **O**(*n*) operational cost where *n* is the number of edges contained
    in `from.Neighbors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Neighbors(Int16 value)` method provides the Neighbors functionality to
    our class. This method accepts one parameter of type `Int16` and named `value`,
    representing the node the caller is asking to examine. The method begins by using
    a LINQ statement to examine each of the nodes in the collection searching for
    a match to `value`. If no match is found, the method returns `null`. Otherwise,
    the method returns the matching node''s `Neighbors` collection. If the `GraphNode`
    object was known in advance, this operation would have an **O**(1) operational
    cost. However, since we are examining the entire collection of `_nodes` at the
    `Graph` level based on the value of a specific node, this implementation has an
    **O**(*n*) operational cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `Count` field is a read-only value that returns the total number
    of nodes contained in the collection by returning `_nodes.Count`. This field provides
    the Count functionality to our `Graph` class and has an **O**(1) operational cost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Java**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like C#, Java does not provide a concrete `Graph` or `GraphNode` class out-of-the-box,
    so we will need to create our own. Again, we will start with the `GraphNode` class.
    Here is what a basic implementation of a `GraphNode` class will look like in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This class is very simple, containing a public field named `Value` to store
    our integer data and a private `LinkedList<GraphNode>` object named `_neighbors`
    that represents the edges between this node and its neighbors. There is also a
    public method called `GetNeighbors()` that exposes the private `_neighbors` list.
    The class also has two constructors, both of which instantiate the `_neighbors`
    list. The overloaded `GraphNode(Int16 value)` constructor also allows a value
    to be defined at instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `Graph` class will look like in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Graph` class includes one private field, a `List<GraphNode>` collection
    named `_nodes` and a method named `GetNodes()`, which exposes read-only access
    to the private `List<GraphNode> _nodes` field. This field maintains a list of
    edges between the current node and its neighboring nodes. Finally, our constructor
    accepts one parameter of the type `List<Graphnode>`, and sets `_nodes` to this
    value if it is not `null`; otherwise, it initializes the `_nodes` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two public methods in `Graph` are `AddNode(GraphNode node)` and `AddNodeForValue(int
    value)`, which add two versions of the AddNode functionality to our class. The
    first adds a pre-existing node to the `_nodes` collection, while the second instantiates
    a new node using `value` and then adds that node to the `_nodes` collection. Both
    of these methods add nodes without defining any edges, and therefore these operations
    have an **O**(1) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `RemoveNode(int value)` method provides the `RemoveNode` functionality to
    our class. This method accepts one parameter of type `int` named `value`, representing
    the node the caller is asking to remove. The method begins by looping through
    each of the nodes, searching for a match for `value`. If no match is found, the
    method returns `false`. Otherwise, the matching node is removed from the `_nodes`
    collection using the `remove(E)` function and method execution continues.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node's neighbors to find a match for `nodeToRemove`. A match found
    means an edge exists from `node` and `nodeToRemove` and returns an index value
    for that match. By removing `nodeToRemove` from that `node.Neighbors` using `index`,
    we eliminate the reference and delete the edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The operational cost in Java is the same as that in C#. The `RemoveNode` operation
    has a cost of **O**(*n* + *k*), where *n* is the number of nodes in the collection
    and *k* is the number of edges. In the `RemoveNode(int value)` method, the first
    half represents *n* and the second half represents *k* in that equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddEdge(GraphNode from, GraphNode to)` and `AddBidirectedEdge(GraphNode
    from, GraphNode to)` methods provide the `AddEdge` functionality to the `Graph`
    class. The first method is the standard AddEdge operation, while the second is
    more of a convenience method in case the caller wants to immediately add bidirectional
    references. The first method has an **O**(1) operational cost, while the second
    technically has a more unusual **O**(2) operational cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Adjacent(GraphNode from, GraphNode to)` method returns a Boolean value
    denoting whether an edge exists between two nodes, `from` and `to`. Hopefully,
    the signature makes the direction of this edge clear, but for clarity, this method
    only confirms that an edge exists from the `from` node and to the `to` node, but
    not the reciprocal. Since this method is based on the `contains` function, it
    has an **O**(*n*) operational cost, where *n* is the number of edges contained
    in `from.Neighbors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Neighbors(int value)` method provides the Neighbors functionality to our
    class. This method accepts one parameter of type `int` and named `value`, representing
    the node the caller is asking to examine. The method begins by looping through
    the collection of nodes, searching for a match for `value`. If no match is found,
    the method returns `null`. Otherwise, the method returns the matching node''s
    `Neighbors` collection using `GetNeighbors()`. If the `GraphNode` object was known
    in advance, this operation will have an **O**(1) operational cost. However, since
    we are examining the entire collection of `_nodes` at the `Graph` level based
    on the value of a specific node, this implementation has an **O**(*n*) operational
    cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `GetCount()` method exposes read-only access to the total number
    of nodes contained in the collection by returning `_nodes.size()`. This field
    provides the Count functionality to our `Graph` class and has an **O**(1) operational
    cost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective-C**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Objective-C does not provide a concrete `Graph` or `GraphNode` class, but it
    does provide the basic components necessary to build them. Here is what a basic
    implementation of a `EDSGraphNode` class will look like in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This class contains two ivar properties named `_value` and `_neighbors`. The
    `_value` property is an `NSInteger` object and stores our integer data, while
    `_neighbors` is an `NSMutableArray` object that represents the edges between this
    node and its neighbors. The class has two initializers, both of which instantiate
    the `_neighbors` list. The `initGraphNode:` method simply instantiates the `_neighbors`
    array, while the `initGraphNodeWithValue:` also sets `_value` to the passed value
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `EDSGraph` class will look like in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `EDSGraph` class includes one ivar property, an `NSMutableArray<EDSGraphNode*>*`
    named `_nodes` that maintains the list of edges to neighboring nodes. There is
    also a method named `nodes` that exposes read-only access to the private `_nodes`
    property. Finally, our initializer `initGraphWithNodes:(NSMutableArray<EDSGraphNode
    *> *)nodes` accepts one array of `EDSGraphnode` and sets `_nodes` to this value
    if it is not `nil`. Otherwise, the initializer method initializes the `_nodes`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `countOfNodes` method exposes read-only access to the total number of nodes
    contained in the collection by returning `[_nodes count]`. This method provides
    the Count functionality to our `EDSGraph` class and has an **O**(1) operational
    cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two public methods in `EDSGraph` are `addNode:` and `addNodeForValue:`
    that add two versions of the `AddNode` functionality to our class. The first adds
    a pre-existing node to the `_nodes` collection, while the second instantiates
    a new node using `value` and then adds that node to the `_nodes` collection. Both
    of these methods add nodes without defining any edges, and therefore these operations
    have an **O**(1) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `removeNodeForValue:` method provides the RemoveNode functionality to our
    class. This method accepts one parameter of type `NSInteger` and named `value`,
    representing the node the caller is asking to remove. The method begins by looping
    through the collection of nodes searching for a match for `value`. If no match
    is found, the method returns `NO`. Otherwise, the matching node is removed from
    the `_nodes` collection using `removeObject:` and the method execution continues.
  prefs: []
  type: TYPE_NORMAL
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node's neighbors to find a match for `nodeToRemove`. A match found
    means an edge exists from `node` and `nodeToRemove` and returns an index value
    for that match. By removing `nodeToRemove` from that `node.Neighbors` using `index`,
    we eliminate the reference and delete the edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we examined in the discussion on graph operations, the `RemoveNode` operation
    has an operational cost of **O**(*n* + *k*), where *n* is the number of nodes
    in the collection and *k* is the number of edges. In the `removeNodeForValue:`
    method, the first half represents *n* and the second half represents *k* in that
    equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addEdgeFromNode:toNode:` and `addBidirectionalEdgeFromNode:toNode:` methods
    provide the AddEdge functionality to the `Graph` class. The first method is the
    standard AddEdge operation, while the second is more of a convenience method in
    case the caller wants to immediately add bidirectional references. The first method
    has an **O**(1) operational cost, while the second has an **O**(2) operational
    cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `adjacent:toNode:` method returns a `BOOL` value denoting whether an edge
    exists between two nodes, `from` and `to`. Hopefully, the signature makes the
    direction of this edge clear, but for clarity, this method only confirms that
    an edge exists from the `from` node and to the `to` node, but not the reciprocal.
    Since this method is based on the `containsObject:` function, it has an **O**(*n*)
    operational cost, where *n* is the number of edges contained in `from.neighbors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `neighborsOfValue:` method provides the Neighbors functionality to our class.
    This method accepts one parameter of type `NSInteger` and named `value`, representing
    the node the caller is asking to examine. The method begins by looping through
    the collection of nodes searching for a match for `value`. If no match is found,
    the method returns `nil`. Otherwise, the method returns the matching node's `neighbors`
    collection. If the `EDSGraphNode` object was known in advance, this operation
    would have an **O**(1) operational cost. However, since we are examining the entire
    collection of `_nodes` at the `EDSGraph` level based on the value of a specific
    node, this implementation has an **O**(*n*) operational cost.
  prefs: []
  type: TYPE_NORMAL
- en: '**Swift**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like its counterparts, Swift does not provide a concrete `Graph` or `GraphNode`
    class by default, so we will need to create our own. We will start with the `GraphNode`
    class. Here is what a basic implementation of a `GraphNode` class might look like
    in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This class extends `Equatable`. This is necessary to support searching by value
    and by object. The class contains two public properties. The first is an array
    of `GraphNode` objects named `neighbors` that represents the edges between the
    node and its neighboring nodes. The second is an `Int` variable named `value`,
    and it is used to store our integer data for the object. The class has one custom
    constructor that accepts `Int` and assigns that value to the `value` variable.
    Finally, the class defines an overloaded comparison operator to support the `Equatable`
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `Graph` class might look like in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Graph` class includes one public `Array` property named `nodes`. This
    property maintains the list of edges to neighboring nodes. The class has one custom
    constructor that accepts one parameter of the type `Array<GraphNode>` and sets
    `_nodes` to this value if it is not `nil`. Since the `nodes` object is initialized
    when it is declared, there is no need to initialize it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method in this class is `count()`, which exposes read-only access
    to the total number of nodes contained in the collection by returning `nodes.count`.
    This method provides the Count functionality to our `Graph` class and has an **O**(1)
    operational cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two public methods in `Graph`, `AddNode(node: GraphNode)` and `AddNodeForValue(value:
    Int)`, add two versions of the `AddNode` functionality to our class. The first
    adds a pre-existing node to the `nodes` collection, while the second instantiates
    a new node using `value` and then adds that node to the `nodes` collection. Both
    of these methods add nodes without defining any edges, and therefore these operations
    have an **O**(1) cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `removeNodeForValue(value: Int)` method provides the `RemoveNode` functionality
    to our class. This method accepts one parameter of type `Int` and named `value`
    representing the node the caller is asking to remove. The method begins by looping
    through each of the nodes in the collection searching for a match to the `value`,
    object. If no match is found, the method returns `false`. Otherwise, the matching
    node is removed from the `nodes` collection and method execution continues.'
  prefs: []
  type: TYPE_NORMAL
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node element's neighbors to find a match for `nodeToRemove`. A
    match found means an edge exists between the `node` and `nodeToRemove` objects
    and returns an index value for that match. By removing `nodeToRemove` from `node.neighbors`
    using `index`, we eliminate the reference and delete the edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we examined in the discussion on graph operations, the `RemoveNode` operation
    has an operational cost of **O**(*n* + *k*), where *n* is the number of nodes
    in the collection and *k* is the number of edges. In the `removeNodeForValue(value:
    Int)` method, the first half represents *n* and the second half represents *k*
    in that equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addEdgeFromNodeToNode(from: GraphNode, to: GraphNode)` and `addBidirectedEdge(from:
    GraphNode, to: GraphNode)` methods provide the `AddEdge` functionality to the
    `Graph` class. The first method is the standard AddEdge operation, while the second
    is more of a convenience method in case the caller wants to immediately add bidirectional
    references. The first method has an **O**(1) operational cost, while the second
    technically has an **O**(2) operational cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `adjacent(from: GraphNode, to: GraphNode)` method returns a `Bool` value
    denoting whether an edge exists between two nodes, `from` and `to`. Hopefully,
    the signature makes the direction of this edge clear, but for clarity, this method
    only confirms that an edge exists from the `from` node and to the `to` node, but
    not the reciprocal. Since this method is based on the `contains` function, it
    has an **O**(*n*) operational cost, where *n* is the number of edges contained
    in `from.Neighbors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `neighborsOfValue(value: Int)` provides the Neighbors functionality to
    our class. This method accepts one parameter of type `Int` and named `value` representing
    the node the caller is asking to examine. The method begins by looping through
    the collection of nodes searching for a match to `value`. If no match is found,
    the method returns `nil`. Otherwise, the method returns the matching node''s `neighbors`
    collection. If the `GraphNode` object was known in advance, this operation would
    have an **O**(1) operational cost. However, since we are examining the entire
    collection of `nodes` at the `Graph` level based on the value of a specific node,
    this implementation has an **O**(*n*) operational cost.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about graph data structures. We used visual representations
    of graphs to gain a better understanding of how they are structured and how they
    can be used. Next, we examined the most common operations when working with graphs
    and discussed their typical complexity cost. Following this, we created our own
    simple graph node object and graph data structure class from scratch in each of
    the four languages we have examined in this book.
  prefs: []
  type: TYPE_NORMAL
