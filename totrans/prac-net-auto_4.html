<html><head></head><body>
        

                            
                    <h1 class="header-title">Web Framework for Automation Triggers</h1>
                
            
            
                
<p>As we move on and get better at understanding the coding techniques and Python, the next step is to ensure that scripts are executed without the end users actually running the code locally, and ensure a platform or OS independent approach in code execution. This chapter focuses on putting our scripts on a web platform. We will cover the following topics:</p>
<ul>
<li>Creating a web accessible script with examples</li>
<li>Accessing the script from HTML/dynamic HTML</li>
<li>Understanding and configuring the environment for the web framework using IIS</li>
<li>The basics of APIs and creating a sample API using C#</li>
<li>Using the API in Python</li>
<li>Creating a task to understand the full end-to-end functionality of a web framework</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Why create web-based scripts/frameworks?</h1>
                
            
            
                
<p>A <strong>web framework</strong> is a collection of scripts, hosted on a web platform such as <strong>Internet Information Services</strong> (<strong>IIS</strong>) (on Windows) or Apache (on Linux), and calling the same script using front-end web-based languages such as HTML.</p>
<p>There are times when people ask why we want to migrate our current scripts or create scripts on a web framework. The answer is very simple. A web framework ensures that our scripts are used by multiple end users using just the browser. This gives the programmer the independence to code the script on their preferred platform (such as Windows or Linux), and people can use the scripts on their choice of browser. They don't need to understand how you have written the code, or what you are calling or using in the back-end, and of course, this ensures that you prevent your code from being directly visible to end users. </p>
<p>Let's say  you have written a script that calls four or five libraries for specific tasks. There are general libraries, but as we have seen in previous chapters, some specific libraries need to be installed for the tasks. In this case, if you want to ensure that end users can execute your script, they need to install the same libraries on their machines. Also, they need to be running a Python environment on their machines, without which the scripts would not run. So, to run a small script of let's say five lines, users need to customize their environment by installing Python, installing libraries, and so on. </p>
<p>This might not be feasible for a lot of users because of restrictions on their machines (such as installation not being allowed), so even though there is a requirement to run the scripts for those users, they would be unable to use the scripts, which would effectively lower efficiency. But the same users, if given the option, could easily open the browser of their choice and use those scripts like opening any other web page, which would ensure that our scripts bring greater efficiency to the tasks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding and configuring IIS for web framework</h1>
                
            
            
                
<p>Here we are going to focus on what IIS is and how to configure it, to ensure our Python scripts are executed by harnessing the power of a web server framework.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding IIS</h1>
                
            
            
                
<p>IIS is a tool available on Windows that is used to host web services. In other words, if we install IIS we ensure that the machine on which it is installed is now acting as a web server. IIS is a fully functional program that is available from Add or Remove Programs in Windows. It supports the machine becoming a web server, an FTP server, and other things as well. </p>
<p>The following screenshot shows the first screen that appears after IIS is installed and opened using the IIS icon in Windows:</p>
<div><img src="img/833bb345-30ef-4b22-9066-4bad30036fb0.jpg" style="width:72.83em;height:27.58em;"/></div>
<p>As we can see in the screenshot, the left side of the application indicates the server name, and the right side shows the properties that we can configure for different purposes.</p>
<p>It is important to select <strong>Common Gateway Interface</strong> (<strong>CGI</strong>) support when installing IIS from the Windows Add or Remove Programs. After selecting IIS, Windows gives us the option to select specific sub-items in IIS, from which CGI and CGI support is an option. If this option is not selected during installation, the Python scripts will fail to run from the web server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring IIS for Python script support</h1>
                
            
            
                
<p>Now, let us configure IIS to ensure it supports execution of Python scripts on the web server itself, and allows end users to directly run Python scripts by calling the web URLs from the web server. The following are the steps to do this: </p>
<ol>
<li>As we expand the properties on the left, we see the Default Web Site option. If you right-click on this, there is a section called Add Application. Click on it to see the following screenshot:</li>
</ol>
<div><img src="img/a632887a-93aa-431a-a134-863091026f53.jpg" style="width:55.50em;height:31.75em;"/></div>
<p style="padding-left: 60px">In this screen, we have to enter two specific values:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>Alias: This is a value that is part of our web URL. For example, <kbd>http://&lt;servername&gt;/test</kbd> will be the URL if our selected Alias is <kbd>test</kbd>.</li>
<li>Physical Path:<strong> </strong>This is the the actual physical directory mapping on which our scripts will reside. For example, our script, <kbd>testscript.py</kbd>, has the following path. To call it from the URL we will type the following in our browser:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 150px">http://&lt;server IP&gt;/test/testscript.py</pre>
<p style="padding-left: 60px">Once we have these values, we click on OK and our website reference is created.</p>
<ol start="2">
<li>Now we need to map our Python scripts to use the Python interpreter while being executed. Once we create the website, we see an option called Handler Mappings in the right panel. Click on it and open the section as shown in the following screenshot. To add the Python reference, click on <kbd>Add Script Map...</kbd><strong> </strong> as shown on the right-hand side of the screenshot:</li>
</ol>
<div><img src="img/9732acee-d630-4921-a62b-951693957c23.jpg"/></div>
<p style="padding-left: 60px">In this section, we fill in three values:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>Request path: This is always <kbd>*.py</kbd>, because any script we call will have the extension <kbd>.py</kbd>.</li>
<li>Executable:<strong> </strong> This is an important section where we reference the actual location of <kbd>python.exe</kbd>. The full path of <kbd>python.exe</kbd> is needed. In addition to the path, we need to add <kbd>%s</kbd><strong> </strong>twice after the executable file path, because this is interpreted to take arguments passed from IIS. For example, if our path to Python is <kbd>C:\Python</kbd>, then we would add the following:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 150px">C:\Python:\python.exe %s %s</pre>
<ul>
<li style="list-style-type: none">
<ul>
<li>Name:<strong> </strong>This is simple reference name for the current settings that we have configured. It can be any name of your choice.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>There is a button called Request Restrictions inside the Add Script Map section. We need to click on that button, and under Access, select the Execute option and click OK:</li>
</ol>
<div><img src="img/8d339304-5b45-41b0-a4ec-16f5ca543352.jpg" style="width:28.50em;height:22.58em;"/></div>
<ol start="4">
<li>Once we click OK, a prompt comes from IIS to allow the extension. We need to select Yes for the settings to be effective:</li>
</ol>
<div><img src="img/d5069e66-3b7c-40bc-baae-90772fb95514.jpg" style="width:33.58em;height:13.42em;"/></div>
<ol start="5">
<li>As the final step, we select the newly created script map (<kbd>Python</kbd> in our case) and click on Edit Feature Permissions... on the right-hand side. In the dialog box, select the Execute option and click OK:</li>
</ol>
<div><img src="img/1761816f-aec0-48b2-aaa9-716a39051761.jpg"/></div>
<p style="padding-left: 60px">Once all of the preceding steps are followed, we have a running environment that supports the execution of Python scripts from a web browser.</p>
<p>Once the web server is running, you can test to ensure that it is configured correctly by invoking the default page on the web server itself. This is done using the <kbd>http://localhost</kbd> URL from the browser, which should show the Welcome IIS page. If this does not show up, then we need to go back and validate the web server installation because it means that web server is not up and running.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating web-specific scripts</h1>
                
            
            
                
<p>Now that we have a running environment that's ready to run our scripts, let's create a very basic script to take a look at how it works:</p>
<pre>print('Content-Type: text/plain')<br/>print('')<br/>print('Hello, world!')</pre>
<p>On IDLE, we type the preceding code and save it as a Python file (such as <kbd>testscript.py</kbd>). Now, as we discussed earlier, for our web reference we mapped a physical directory or location in IIS. The newly created <kbd>testscript.py</kbd> needs to be in that folder to be accessible from the web.</p>
<p>The output of the web based URL call for Python script is as follows:</p>
<div><img src="img/b0d4ddad-b535-4b70-b4ba-3cc5f13c3347.jpg" style="width:74.33em;height:8.67em;"/></div>
<ul>
<li>As we can see in the preceding screenshot, the script is now called from the browser using the localhost URL. The output is a simple <kbd>Hello, world !</kbd> that was called to be printed in script code.</li>
<li>Additionally, the value <kbd>Content-Type: text/plain</kbd> specifies that the return values from Python will be simple text that the browser will interpret as plain text rather than HTML.</li>
</ul>
<p class="mce-root">Now let's look at an example of modifying it to HTML:</p>
<pre>print('Content-Type: text/html')<br/>print('')<br/>print("&lt;font color='red'&gt;Hello, &lt;b&gt;world!&lt;/b&gt;&lt;/font&gt;")</pre>
<p>The output of the URL with modified values is as follows:</p>
<div><img src="img/91fbb29c-60d4-4b4e-9cfc-5a081ebbd892.jpg" style="width:70.17em;height:10.00em;"/></div>
<p>As we can see, the first line of the code has been modified to <kbd>Content-Type: text/html</kbd><strong>. </strong>This ensures that the text now being returned from the script is HTML, and hence the last print statement, with <kbd>font color</kbd> as <kbd>red</kbd> and <kbd>world!</kbd> in bold html tag is being interpreted correctly in the browser. In real-life scenarios, if we want to print a pass, fail, or any other specific message or output from our scripts, we should return the values in HTML color-coded and bold formats so that they are clearly readable in the browser.</p>
<p>Let's see an example of printing a table of 5 in a tabular format in HTML:</p>
<pre>print('Content-Type: text/html')<br/>print('')<br/>value=5<br/>xval=0<br/>tval="&lt;table border='1' style='border-collapse: collapse'&gt;&lt;tr&gt;&lt;th&gt;Table for "+str(value)+"&lt;/th&gt;&lt;/tr&gt;"<br/>for xval in range(1,11):<br/>    mval=value*xval<br/>    tval=tval+"&lt;tr&gt;&lt;td&gt;"+str(value)+"&lt;/td&gt;&lt;td&gt;*&lt;/td&gt;&lt;td&gt;"+str(xval)+"&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&lt;font color='blue'&gt;&lt;b&gt;"+str(mval)+"&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;"<br/><br/>tval=tval+"&lt;/table&gt;"<br/><br/>print(tval)</pre>
<p>The output of the preceding code is as follows:</p>
<div><img src="img/c73f060b-6bab-4460-8286-dcd3f5e65891.jpg" style="width:30.92em;height:21.33em;"/></div>
<ul>
<li>As we can see, the first line indicates the return type as HTML. In the next few lines, we take a variable named <kbd>value</kbd> with a value of <kbd>5</kbd>. Using a <kbd>for</kbd> loop, we create the HTML table and its values (for each row and cell) in a <kbd>tval</kbd> variable. </li>
<li>The final statement returns the value of the <kbd>tval</kbd> variable to the browser where we called the script.</li>
</ul>
<p>Getting deeper into this example, now let's create the same table, but the number needs to be provided by the web user in the URL. In other words, rather than sticking to the static value of <kbd>5</kbd> in our example, the table needs to be generated for the value that is entered by the user in the URL:</p>
<pre>import cgi<br/><br/>form = cgi.FieldStorage()<br/>value=int(form.getvalue('number'))<br/><br/>print('Content-Type: text/html')<br/>print('')<br/>xval=0<br/>tval="&lt;table border='1' style='border-collapse: collapse'&gt;&lt;tr&gt;&lt;th&gt;Table for "+str(value)+"&lt;/th&gt;&lt;/tr&gt;"<br/>for xval in range(1,11):<br/>    mval=value*xval<br/>    tval=tval+"&lt;tr&gt;&lt;td&gt;"+str(value)+"&lt;/td&gt;&lt;td&gt;*&lt;/td&gt;&lt;td&gt;"+str(xval)+"&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&lt;font color='blue'&gt;&lt;b&gt;"+str(mval)+"&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;"<br/><br/>tval=tval+"&lt;/table&gt;"<br/><br/>print(tval)</pre>
<p>The output of the preceding code is as follows:</p>
<div><img src="img/eed90d41-a775-4220-8ea1-287aafa9d825.jpg" style="width:33.92em;height:23.08em;"/></div>
<ul>
<li>As we can see in the change in the URL, we pass the number using the enhanced URL <kbd>http://localhost/test/testscript.py?number=8</kbd>. The value specified after the question mark, which is referenced as the value passed to the parameter number, is now taken as an input in the script. The code now imports a specific inbuilt library called <kbd>cgi</kbd> to read the parameters passed to itself from the browser. </li>
<li class="mce-root">These are next two lines:</li>
</ul>
<pre style="padding-left: 90px" class="mce-root">form = cgi.FieldStorage()<br/>value=int(form.getvalue('number'))</pre>
<p style="padding-left: 60px">They are used to take a reference of the form as returned from the browser, and from the form, the specific parameter named <kbd>number</kbd><strong>.</strong> The parameter returned is always in string format, so we need to ensure it is converted to our specific datatype depending on our usage.</p>
<ul>
<li>The <kbd>value</kbd> variable now has the number that we passed from the browser, and the rest of the script is executed in the same manner given in previous examples.</li>
</ul>
<p>As we can see in the preceding examples, the end user is now only calling the script with specific values based upon their needs, and is not concerned about the back-end logic or program. For the developer, if there is a bug identified in the script, the fix can be done on the main web server as soon as the end users start getting correct results. This also saves a lot of effort compared to users downloading the new fixed script from a specific location on their machines and then running it on their own. Sometimes, even calling the script from the browser with parameters becomes a bit tough. In this case, we use form tags in HTML to pass values to scripts to fetch outputs.</p>
<p>For example, ask the user for their name, the number for which the table needs to be generated, and output the generated table in a friendly manner with the caller's name in the output. Here's the HTML code:</p>
<pre>&lt;html&gt;<br/>&lt;form action="testscript.py" method="get"&gt;<br/> Enter your name: &lt;br&gt;<br/>  &lt;input type="text" name="name"&gt;<br/>  &lt;br&gt;<br/>  Enter your number:&lt;br&gt;<br/>  &lt;input type="text" name="number"&gt;<br/>  &lt;br&gt;&lt;br&gt;<br/>  &lt;input type="submit" value="Submit"&gt;<br/>&lt;/form&gt;<br/>&lt;/html&gt;    </pre>
<p>Here's the Python code:</p>
<pre>import cgi<br/><br/>form = cgi.FieldStorage()<br/>value=int(form.getvalue('number'))<br/>callername=form.getvalue('name')<br/><br/>print('Content-Type: text/html')<br/>print('')<br/>xval=0<br/>tval="&lt;h2&gt;Hello &lt;font color='red'&gt;"+callername+"&lt;/font&gt;&lt;h2&gt;&lt;br&gt;&lt;h3&gt;Your requested output is below:&lt;/h3&gt;"<br/>tval=tval+"&lt;table border='1' style='border-collapse: collapse'&gt;&lt;tr&gt;&lt;th&gt;Table for "+str(value)+"&lt;/th&gt;&lt;/tr&gt;"<br/>for xval in range(1,11):<br/>    mval=value*xval<br/>    tval=tval+"&lt;tr&gt;&lt;td&gt;"+str(value)+"&lt;/td&gt;&lt;td&gt;*&lt;/td&gt;&lt;td&gt;"+str(xval)+"&lt;/td&gt;&lt;td&gt;=&lt;/td&gt;&lt;td&gt;&lt;font color='blue'&gt;&lt;b&gt;"+str(mval)+"&lt;/b&gt;&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;"<br/><br/>tval=tval+"&lt;/table&gt;"<br/><br/>print(tval)</pre>
<p>The output of the preceding code is as follows:</p>
<div><img src="img/1355169a-d721-4d70-a1db-54967b7c7e42.jpg" style="width:31.75em;height:13.83em;"/></div>
<p>HTML Page</p>
<p>Using the HTML code, we create a form that takes the input needed for our script. In this case, it asks for a name and the number from which the table needs to be generated. Once the user enters this information, the Submit button needs to be clicked for the values to be passed to the script:</p>
<div><img src="img/df0bc049-3729-4bde-a55a-e3eb6f13d59b.jpg" style="width:33.67em;height:26.17em;"/></div>
<p>Script Output</p>
<p>As the user clicks on the Submit button, the values are passed to the script. In the code, we get the values using the same <kbd>form.getvalue()</kbd> method for each of the HTML elements. Once the script has the values fetched from the browser, the script logic takes care of what needs to be returned. In our case, as we can see in the example, the username has been displayed in the browser, along with the table that the user wanted to see as the output.</p>
<p class="mce-root">Let's take an example in which we type in the IP address of a device and the command that we want to see from the device, using the form and browser output. Here's the HTML code:</p>
<pre>&lt;html&gt;<br/>&lt;form action="getweboutput.py" method="get"&gt;<br/> Enter device IP address: &lt;br&gt;<br/>  &lt;input type="text" name="ipaddress"&gt;<br/>  &lt;br&gt;<br/>  Enter command:&lt;br&gt;<br/>  &lt;input type="text" name="cmd"&gt;<br/>  &lt;br&gt;&lt;br&gt;<br/>  &lt;input type="submit" value="Submit"&gt;<br/>&lt;/form&gt;<br/>&lt;/html&gt;    </pre>
<p class="mce-root">In this code, the only difference is that now we are calling the <kbd>getweboutput.py</kbd> script, into which we are sending the parameters of the device IP address (for the device from which we want the output), and the actual command. Here's the Python code:</p>
<pre>import cgi<br/>from netmiko import ConnectHandler<br/>import time<br/><br/>form = cgi.FieldStorage()<br/>ipvalue=form.getvalue('ipaddress')<br/>cmd=form.getvalue('cmd')<br/><br/>def getoutput(cmd):<br/>    global ipvalue<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=ipvalue, username=uname, password=passwd)<br/>    output=device.send_command(cmd)<br/>    return (output)<br/><br/>print('Content-Type: text/plain')<br/>print('')<br/>print ("Device queried for ",ipvalue)<br/>print ("\nCommand:",cmd)<br/>print ("\nOutput:")<br/>print (getoutput(cmd))<br/><br/></pre>
<p>The Python code is now taking the input parameter of <kbd>ipaddress</kbd> for the device IP, and <kbd>cmd</kbd> for the actual command that needs to be sent to the router. It again uses Netmiko, as in <a href="463dbdd3-1fde-4886-b582-f6de051b1440.xhtml" target="_blank">Chapter 2</a>, <em>Python for Network Engineers</em>, to fetch the information and return it using the <kbd>getoutput()</kbd> function:</p>
<p><strong>Sample 1</strong>: <strong>We provide the IP address and the command show clock</strong>:</p>
<div><img src="img/438a3e32-d3e2-454e-ab2b-841678717512.jpg" style="width:23.92em;height:13.33em;"/></div>
<p>Landing page</p>
<p>Click on the Submit button:</p>
<div><img src="img/8cd167fa-51a4-47c1-a7df-532c627e2d9a.jpg" style="width:34.92em;height:11.25em;"/></div>
<p><strong>Sample 2</strong>: <strong>For the same script with different parameters provided</strong>:</p>
<div><img src="img/020a64cf-bb7e-438b-8183-c377a31907c7.jpg" style="width:20.33em;height:14.00em;"/></div>
<p>Landing Page</p>
<p>This is the output when the Submit button is clicked:</p>
<div><img src="img/104c3097-f2db-4f7e-a998-0534eb9b2a04.jpg" style="width:39.50em;height:36.50em;"/></div>
<p>As we saw, we can create a web-based query tool to fetch information from devices with specified commands, which can act as a quick reference for device validations. Additionally, with this methodology we are also hiding our username and password (<kbd>cisco</kbd>:<kbd>cisco</kbd> in this case) without exposing the device credentials to end users. The end user is only providing inputs on the web page, and is unaware of the code that is being executed at the back-end, which has the device credentials. </p>
<p>We can even have additional checks to ensure that users can only run <kbd>show</kbd> commands and display appropriate messages depending on the various commands users will try to call on the web page.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing a script from dynamic HTML</h1>
                
            
            
                
<p>There are times when we run a Python script to create dynamic HTML pages (which are based upon certain triggers that we put in the script). These pages can be enhanced to add additional URLs to invoke other scripts when we click on those pages.</p>
<p>As an example, let's say we need to find out how many models of devices are in our network. For this we create a script, schedule it to run every hour with the task scheduler, and after each run a dynamic HTML page is created to show the updated stats or inventory. In a BYOD<strong> </strong>scenario, this also plays an important role, because each hour we can monitor what devices are on our network, and if we click on any of the discovered devices, we can get additional information such as a detailed show version.</p>
<p>Here's the Python code to create the dynamic HTML:</p>
<pre>from pysnmp.hlapi import *<br/><br/>print('Content-Type: text/html')<br/>print('')<br/><br/>def finddevices(ip):<br/>    errorIndication, errorStatus, errorIndex, varBinds = next(<br/>        getCmd(SnmpEngine(),<br/>               CommunityData('public', mpModel=0),<br/>               UdpTransportTarget((ip, 161)),<br/>               ContextData(),<br/>               ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0)))<br/>    )<br/><br/>    if errorIndication:<br/>        print(errorIndication)<br/>    elif errorStatus:<br/>        print('%s at %s' % (errorStatus.prettyPrint(),<br/>                            errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))<br/>    else:<br/>        for varBind in varBinds:<br/>            xval=(' = '.join([x.prettyPrint() for x in varBind]))<br/>            xval=xval.replace("SNMPv2-MIB::sysDescr.0 = ","")<br/>            xval=xval.split(",")<br/>            return (xval[1])<br/><br/>ipaddress="192.168.255.248,192.168.255.249"<br/>ipaddress=ipaddress.split(",")<br/>tval="&lt;table border='1'&gt;&lt;tr&gt;&lt;td&gt;IP address&lt;/td&gt;&lt;td&gt;Model&lt;/td&gt;&lt;/tr&gt;"<br/>for ip in ipaddress:<br/>    version=finddevices(ip)<br/>    version=version.strip()<br/>    ahref="http://localhost/test/showversion.py?ipaddress="+ip<br/>    tval=tval+"&lt;tr&gt;&lt;td&gt;&lt;a href='"+ahref+"' target='_blank'&gt;"+ip+"&lt;/a&gt;&lt;/td&gt;"<br/>    <br/>    tval=tval+"&lt;td&gt;"+version+"&lt;/td&gt;&lt;/tr&gt;"<br/><br/>tval=tval+"&lt;/table&gt;"<br/>print (tval)   </pre>
<p>The output of the preceding code is as follows:</p>
<div><img src="img/7bfb5a1b-c5c0-4e1b-95b5-d1431e487dc4.jpg" style="width:26.33em;height:7.83em;"/></div>
<p>The preceding code creates the dynamic HTML shown in the previous screenshot. It queries the vendor from SNMP for the given IP addresses, and creates the table based upon the values. The blue color in the IP addresses denotes the hyperlink, which, when clicked, will result in the output as shown here:</p>
<div><img src="img/bdbe3530-7fd8-48e2-807d-dcd480392933.jpg" style="width:32.92em;height:27.50em;"/></div>
<p>Here's the Python code for the output of show version:</p>
<pre>import cgi<br/>from netmiko import ConnectHandler<br/>import time<br/><br/>form = cgi.FieldStorage()<br/>ipvalue=form.getvalue('ipaddress')<br/><br/>def getoutput(cmd):<br/>    global ipvalue<br/>    uname="cisco"<br/>    passwd="cisco"<br/>    device = ConnectHandler(device_type='cisco_ios', ip=ipvalue, username=uname, password=passwd)<br/>    output=device.send_command(cmd)<br/>    return (output)<br/><br/>print('Content-Type: text/plain')<br/>print('')<br/>print ("Device queried for ",ipvalue)<br/>print ("\nOutput:")<br/>print (getoutput("show version"))</pre>
<p>As we can see in the URL, when the user clicked on the main dynamic HTML page, it invoked another script (the one that was listed earlier) that takes the input parameter of the IP address from the URL and, using Netmiko, fetches the version of the device.</p>
<p>Similarly, we can gather other stats, such as CPU, memory, a routing summary, and other tasks for each of the devices quickly using the web framework approach.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the backend API in C#</h1>
                
            
            
                
<p>As we move ahead, there are times when as a developer we not only need to consume APIs, but create our own APIs for others to use. Even if we find recurring usage of some functions, keeping in mind web framework strategy, we need to ensure that instead of simply creating functions for that task, we need to convert them to APIs. A big advantage of that is that the usage of our function or task will then not be limited only to Python, but it can be used in any scripting language or web language.</p>
<p>Here we will see a very basic approach to creating a functional API to say <kbd>Hello World</kbd> in C#. As a prerequisite, we will need IIS to run the web services, and Visual Studio (Community edition is free to use) to create our own API. Later on, we will see how to consume that API in Python.</p>
<p>Additionally, we will ensure that the return value is in the JSON format, which is the industry standard for API communication, replacing XML.</p>
<ol>
<li>Invoke the C# Web project in Visual Studio:</li>
</ol>
<div><img src="img/7f523e58-f1f1-4bb3-9127-e1fdc1e0a99a.jpg"/></div>
<ol start="2">
<li>Select the Web API checkbox in the next screen shown as follows:</li>
</ol>
<div><img src="img/b1a0df4e-d93b-4eed-9c24-6cce40f0bca8.jpg" style="width:60.25em;height:24.50em;"/></div>
<ol start="3">
<li>Add the Controller (this is the main component that will ensure the API framework is active):</li>
</ol>
<div><img src="img/ba348a19-b854-4eca-85bc-50f0607cc120.jpg"/></div>
<ol start="4">
<li>Give a meaningful name to the controller. Note, the name must be followed by the word <kbd>Controller</kbd> (example <kbd>testController</kbd>), otherwise the controller will not function and the API framework will be broken:</li>
</ol>
<div><img src="img/9d249e72-4e1f-4416-bf5d-a8a49cc7b1e2.jpg"/></div>
<ol start="5">
<li>Once the controller is added, under the <kbd>WebApiConfig.cs</kbd> file add the new <kbd>JsonMediaTypeFormatter()</kbd> config, as shown in the next screenshot. This ensures that every output returned from the API will be in JSON format:</li>
</ol>
<div><img src="img/64018700-c1fb-49d1-8962-a58fc2e0bf12.jpg"/></div>
<ol start="6">
<li>In the main <kbd>apitestController.cs</kbd> program, return the value <kbd>Hello World</kbd> once the <kbd>Get</kbd> method is called:</li>
</ol>
<div><img src="img/73d860b4-94a2-4cb8-a07d-0bda4ef3d515.jpg"/></div>
<ol start="7">
<li>Once done, click on the <kbd>Run</kbd> button that is available in the Visual Studio application. A screen similar to the following screenshot will be opened, which ensures that the local IIS server is being invoked and the application is initialized for testing:</li>
</ol>
<div><img src="img/7900d45b-f90a-44ca-8bc5-1546018e295d.jpg"/></div>
<ol start="8">
<li>Once the application is loaded, a URL similar to the following will confirm our API is working fine. Note that, at this point, the local IIS Express is being used and the API is still not published for external use:</li>
</ol>
<div><img src="img/fa52c019-c5c0-452b-b48e-3e5e97060756.jpg" style="width:57.25em;height:17.75em;"/></div>
<ol start="9">
<li>Once validated, now we need to publish this to our IIS. Similar to what we did earlier, we create a new application in IIS (named <kbd>apitest</kbd> in our case):</li>
</ol>
<div><img src="img/878f8386-6690-4df3-980d-ed644acd7e21.jpg" style="width:46.42em;height:28.58em;"/></div>
<ol start="10">
<li>Once the IIS mapping has been done, we use Visual Studio to publish our API project to this web folder:</li>
</ol>
<div><img src="img/2a5873a4-3849-4176-a523-62b4058a119d.jpg" style="width:32.92em;height:24.00em;"/></div>
<ol start="11">
<li>We create a web Publish profile, and publish it to the local folder that we mapped to our IIS:</li>
</ol>
<div><img src="img/e525a06b-13ec-4923-b118-c373b2b13435.jpg" style="width:50.08em;height:28.17em;"/></div>
<ol start="12">
<li>Our API is ready to be used. We can validate it by going to <kbd>http://localhost</kbd> on our browser:</li>
</ol>
<div><img src="img/a15ccb68-ce3f-4993-89f2-515685693803.jpg" style="width:32.25em;height:12.58em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Consuming the API in Python</h1>
                
            
            
                
<p>Now, as we have the API created, let us see how to consume the API in Python.</p>
<p>The code is as follows:</p>
<pre>import requests<br/>r = requests.get('http://localhost/apitest/api/apitest/5')<br/>print (r.json())</pre>
<p>The output for the preceding code is as follows:</p>
<div><img src="img/a0dfd313-d468-4755-acb2-3f2febe8eba4.jpg" style="width:40.58em;height:13.17em;"/></div>
<p>For API interaction, we use the <kbd>requests</kbd> library in Python. When we perform a call to the API, the API returns the string in JSON format. The <kbd>r.json()</kbd><strong> </strong>method converts the returned JSON to extract the text value and displays the output as <kbd>Hello World</kbd>.</p>
<p>In a similar way, we can use the requests library to fetch API results from various web-based API calls. The result is generally in XML or JSON format, with JSON being the preferred return method for the API calls.</p>
<p>Let us see another example to fetch some more JSON from GitHub:</p>
<pre>import requests<br/>r = requests.get('https://github.com/timeline.json')<br/>jsonvalue=r.json()<br/>print (jsonvalue)<br/>print ("\nNow printing value of message"+"\n")<br/>print (jsonvalue['message']+"\n")<br/><br/></pre>
<p>The output for the preceding code is as follows:</p>
<div><img src="img/e64ff339-7c8f-4d71-b47a-5664b533ab01.jpg" style="width:31.83em;height:18.33em;"/></div>
<p>As we now call the GitHub API, we get the JSON value as shown previously. As we can see, the return value is like a dictionary in the JSON return data of the API call, so we can explicitly get the text inside the <kbd>message</kbd> dictionary key. In the preceding output, the first output is the raw JSON return value, and the next output is the extracted text from the <kbd>message</kbd> key.</p>
<p>In addition to calling the standard APIs, there are times when we need to pass credentials to the API to fetch information. In other words, there needs to be an authentication in place for the APIs to respond with requested data. In our API, let us now enable basic authentication from IIS:</p>
<ol>
<li>In the IIS, select your website (<kbd>apitest</kbd> in our case), and under the Authentication section, select Basic Authentication:</li>
</ol>
<div><img src="img/7c4bd726-2d81-4a5d-9d5b-d2d8dea242fc.jpg" style="width:66.92em;height:14.42em;"/></div>
<p style="padding-left: 60px">This ensures that any request that calls this API needs to have basic authentication (a username and a password) to access the content. Additionally, we create a simple user <kbd>testuser</kbd> with a password <kbd>testpassword</kbd> in the Users application on a Windows machine.</p>
<ol start="2">
<li>Since authentication is now enabled, let us see what we get if no credentials are passed:</li>
</ol>
<pre style="padding-left: 90px">import requests<br/><br/>r = requests.get('http://localhost/apitest/api/apitest/5')<br/>print (r)</pre>
<p style="padding-left: 90px">The output for the preceding code is as follows:</p>
<div><img src="img/833d1d8d-18fe-4d0a-97f1-ca48b78c6c9c.jpg" style="width:31.67em;height:11.08em;"/></div>
<p style="padding-left: 60px">We get a Response [401], which means <em>unauthorized</em> access in a HTTP call. In other words, the API call is unauthorized and hence no output will be given back.</p>
<ol start="3">
<li>Next, we see the same call, but this time with authentication:</li>
</ol>
<pre style="padding-left: 90px">import requests<br/>from requests.auth import HTTPBasicAuth<br/>r = requests.get('http://localhost/apitest/api/apitest/5', auth=('testuser', 'testpassword'))<br/>print (r)<br/>print (r.json())</pre>
<p style="padding-left: 90px">The output for the preceding code is as follows:</p>
<div><img src="img/ad4bf86f-8630-4fc8-95ee-d600411f7982.jpg" style="width:32.17em;height:12.67em;"/></div>
<p style="padding-left: 60px">In this case, we call the authentication method <kbd>HTTPBasicAuth</kbd>, and pass the username and password in the <kbd>requests.get</kbd> call. As we have provided the correct credentials, we get back a Response [200], which is OK in HTTP, and in the last line we print the output of the returned value, which in our case is <kbd>Hello World</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sample summary task</h1>
                
            
            
                
<p>As we are now familiar with the web framework, let us perform a task that covers all the aspects that we saw earlier:</p>
<ol>
<li>We write a HTML page that asks for the username and password from the user. Those values will be passed into a Python script which will call the API that we created earlier to authenticate. If the return value is authorized, then we display the IP addresses of the devices that we want to view the additional information for on another web page. </li>
</ol>
<p> </p>
<ol start="2">
<li>Next, the user can click on any of the IP addresses to view the <kbd>show ip int brief</kbd> output. If the authorization fails, the script returns the message Not Authorized and will not display the IP addresses. For reference (valid set of username and password): 
<ul>
<li><strong>Username</strong>: <kbd>Abhishek</kbd></li>
<li><strong>Password</strong>: <kbd>password</kbd></li>
</ul>
</li>
</ol>
<p style="padding-left: 60px" class="mce-root">HTML Code is as follows:</p>
<pre style="padding-left: 60px">&lt;html&gt;<br/>&lt;form action="validatecreds.py" method="post"&gt;<br/> Enter your name: &lt;br&gt;<br/>  &lt;input type="text" name="name"&gt;<br/>  &lt;br&gt;<br/>  Enter your password:&lt;br&gt;<br/>  &lt;input type="password" name="password"&gt;<br/>  &lt;br&gt;&lt;br&gt;<br/>  &lt;input type="submit" value="Submit"&gt;<br/>&lt;/form&gt;<br/>&lt;/html&gt;    </pre>
<p>We have used the <kbd>POST</kbd> method in this case, since the password will be shown in clear text on the browser URL if we use the default <kbd>GET</kbd> method. In the <kbd>POST</kbd> method, there is a separate connection made at the back-end, and the URL does not show the values that are being passed on to the script.</p>
<p style="padding-left: 60px">The Python code is as follows:</p>
<pre style="padding-left: 60px">import cgi, cgitb<br/>import requests<br/>from requests.auth import HTTPBasicAuth<br/><br/>form = cgi.FieldStorage()<br/>uname=form.getvalue('name')<br/>password=form.getvalue('password')<br/><br/>r = requests.get('http://localhost/apitest/api/apitest/5', auth=(uname, password))<br/><br/>print('Content-Type: text/HTML')<br/>print('')<br/>print ("&lt;h2&gt;Hello "+uname+"&lt;/h2&gt;")<br/><br/>htmlform="&lt;form action='showoutput.py' method='post'&gt;"<br/>htmlform=htmlform+"&lt;br&gt;&lt;input type='radio' name='ipaddress' value='192.168.255.248' /&gt; 192.168.255.248"<br/>htmlform=htmlform+"&lt;br&gt;&lt;input type='radio' name='ipaddress' value='192.168.255.249' /&gt; 192.168.255.249"<br/>htmlform=htmlform+"&lt;br&gt;&lt;input type='submit' value='Select IPaddress' /&gt;&lt;/form&gt;"<br/><br/>if (r.status_code != 200):<br/>    print ("&lt;h3&gt;&lt;font color='red'&gt;Not Authorized.&lt;/font&gt; Try again!!!!&lt;/h3&gt;")<br/>else:<br/>    print ("&lt;h3&gt;&lt;font color='lime'&gt;Authorized.&lt;/font&gt; Please select from list below:&lt;/h3&gt;")<br/>    print (htmlform)</pre>
<ol start="3">
<li>In case of incorrect credentials (credentials that are not valid, like dummy credentials) being provided:</li>
</ol>
<div><img src="img/c6aacd4b-9466-440d-8345-75a2731f76c7.jpg" style="width:34.33em;height:14.17em;"/></div>
<p style="padding-left: 60px">When we click on Submit button, it will display the message as shown in the following screenshot:</p>
<div><img src="img/06309a5b-bfac-4185-835b-50727c2161aa.jpg" style="width:27.50em;height:10.17em;"/></div>
<ol start="4">
<li>In case of correct credentials (that are correct and authenticated successfully at web server):</li>
</ol>
<div><img src="img/2857b776-ace6-4a8f-8aad-e248b6072ecf.jpg" style="width:27.50em;height:11.33em;"/> </div>
<p style="padding-left: 60px">When we click on Submit button:</p>
<div><img src="img/f9568740-10fc-4180-9561-e7b39b47cfa6.jpg" style="width:28.50em;height:14.83em;"/></div>
<ol start="5">
<li>Next, we see the IP addresses, which we can now use to get the output. We select the IP address that we want to use and click on Select IPaddress:</li>
</ol>
<div><img src="img/52320f4e-56fa-46ea-a102-27fd7471a40f.jpg" style="width:23.00em;height:13.83em;"/></div>
<p style="padding-left: 60px">Once we click on Submit (or the Select IPaddress button), we get the following output:</p>
<div><img src="img/d96ed8d1-af13-428d-851c-490d4070b36b.jpg" style="width:46.50em;height:15.33em;"/></div>
<p style="padding-left: 60px">Again, if we look at the preceding output URL, since we used the <kbd>POST</kbd> method for this selection, we only see the script but not the parameters that were passed in the URL. This ensures that people need to go from the landing page (in our case, <kbd>main.html</kbd>), and cannot directly call any URL with parameters that could have been given if we were using the <kbd>GET</kbd> method. </p>
<p>By doing this, we are also ensuring that end users executing this follow a step-by-step selection, and are not jumping from one URL to the other without performing the sequential steps.</p>
<p>In a similar manner, end users can create their own APIs to fetch information such as bulk device names and IP addresses, and can use that information in their script to create front-end, back-end, or web-enabled scenarios quickly accessible from any browser without the need for any end user installations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We have now understood the web framework and with relevant examples, the usage of APIs. This includes how to create an API, access APIs, and even work with authentication on APIs. Using this knowledge, we will now be able to develop web based tools for end users. The IIS functionality has also been introduced, which helps developers to customize various web-based settings such as authentications, authorizations, and creating websites.</p>
<p>Additionally, with a fully functional example of a given scenario, readers can quickly build web-based Python scripts, which remove the need for any end user installations of Python and customized libraries. This makes support and bug fixing much easier, owing to having a single machine to fix. A fix done on the server will ensure that all end users will now be using the fixed or enhanced functions of the script, rather than downloading a local copy on their machines to get the fixed or enhanced script.</p>
<p>In the next chapter, we will introduce the use of Ansible, which is a popular open source automation platform.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>