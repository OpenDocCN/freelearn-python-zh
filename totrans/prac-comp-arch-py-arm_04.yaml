- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Data Flow in a Computer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算机中的数据流
- en: In this chapter, we will learn how a computer executes an instruction. We have
    to understand how a computer operates internally before we can simulate its behavior
    in Python. We will also introduce the concept of a computer instruction (the smallest
    operation that it can be commanded to perform) and show you what a computer instruction
    looks like.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习计算机如何执行指令。在我们能够在 Python 中模拟计算机的行为之前，我们必须理解计算机的内部运作方式。我们还将介绍计算机指令（它可以被命令执行的最小操作）的概念，并展示计算机指令的外观。
- en: What is a computer? How does it work? What does it do? We will answer these
    questions by demonstrating how a computer can be designed using Python, and how
    programs can be run on this simulated computer. Here, we are interested only in
    how a computer behaves at the machine level – that is, the type of operations
    it carries out. We are not concerned with the internal design of the computer
    or how the computer is implemented electronically (i.e., the circuits used to
    build a computer).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是计算机？它是如何工作的？它能做什么？我们将通过演示如何使用 Python 设计计算机，以及如何在模拟计算机上运行程序来回答这些问题。在这里，我们只对计算机在机器级别上的行为感兴趣——也就是说，它执行的操作类型。我们不关心计算机的内部设计或计算机是如何电子实现的（即用于构建计算机的电路）。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: The instruction set architecture (ISA)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令集架构（ISA）
- en: The Von Neumann architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冯·诺伊曼架构
- en: An assembly-level program
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编级程序
- en: The machine-level instruction
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器级指令
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章使用的程序，链接为 [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03)。
- en: The Instruction Architecture Level (ISA)
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令架构级别（ISA）
- en: In this section, we will show how a computer can be described in different ways
    and explain that this book is about computers from the point of view of their
    instruction sets and capabilities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何以不同的方式描述计算机，并解释本书是从计算机的指令集和能力角度来探讨计算机的。
- en: The term *computer* means different things to different people. To an engineer,
    a computer is a collection of circuits that perform a certain function; to a pilot,
    it’s a machine that flies an aircraft from one airport to another and can land
    it in thick fog.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: “计算机”这个词对不同的人意味着不同的事情。对一个工程师来说，计算机是一组执行特定功能的电路集合；对一个飞行员来说，它是一架能够将飞机从一个机场飞到另一个机场并在浓雾中降落的机器。
- en: '*Table 3.1* demonstrates the hierarchy of computer languages and structures.
    At the top you have the actual application for which the computer is used. At
    this level, the application may be a user-selected program (flight simulator),
    or it may be a program that runs on an embedded system (e.g., an ATM). Communication
    with that application is universal and independent of the actual computer on which
    the application runs.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 3.1* 展示了计算机语言和结构的层次结构。在最顶层，你有计算机实际使用的应用程序。在这个级别，应用程序可能是一个用户选择的程序（例如飞行模拟器），或者它可能是在嵌入式系统上运行的程序（例如自动柜员机）。与该应用程序的通信是通用的，并且独立于运行应用程序的实际计算机。'
- en: '| **Level** | **Realization** | **Universality** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **级别** | **实现** | **通用性** |'
- en: '| --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1\. Application | Word, Excel, Photoshop, and flight sim | Universal |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1\. 应用 | Word、Excel、Photoshop 和飞行模拟器 | 通用 |'
- en: '| 2\. High-level language | Python, Java, C++ | Universal |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2\. 高级语言 | Python、Java、C++ | 通用 |'
- en: '| 3\. Assembly language | ADD r1,r2, and r3 | Computer family |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 3\. 汇编语言 | ADD r1,r2, and r3 | 计算机家族 |'
- en: '| 4\. Binary (machine code) | `00111010111100001010101110001010` binary | Computer
    family |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 4\. 二进制（机器代码） | `00111010111100001010101110001010` 二进制 | 计算机家族 |'
- en: '| 5\. Circuit (microprocessor) | Gates, adders, counters, and memory | Specific
    family member |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 5\. 电路（微处理器） | 逻辑门、加法器、计数器和内存 | 特定家族成员 |'
- en: '| 6\. Silicon | The physical silicon chip | Specific chip |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 6\. 硅 | 物理硅芯片 | 特定芯片 |'
- en: Table 3.1 – The hierarchy of computer languages and systems
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 计算机语言和系统的层次结构
- en: Below the application level, you have the high-level language used to build
    the application. This language may be Python, Java, C++, and so on. High-level
    languages were designed to enable programmers to build applications that run on
    different types of computers. For example, a program written in Python will run
    on any machine for which a Python interpreter or compiler is available. Before
    the introduction of high-level languages, you had to design the application for
    each specific computer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用层之下，是用于构建应用程序的高级语言。这种语言可能是Python、Java、C++等等。高级语言被设计成允许程序员构建能在不同类型的计算机上运行的应用程序。例如，用Python编写的程序可以在任何有Python解释器或编译器的机器上运行。在高级语言引入之前，你必须为每台特定的计算机设计应用程序。
- en: Most computers are currently unable to directly execute high-level languages.
    Each computer has a native language that is understood by a computer family (e.g.,
    Intel Core, Motorola 68K, ARMv4, and MIPS). These languages are related to the
    structure of the computer and its hardware, which is expressed by a computer’s
    ISA. This level is represented by two layers in *Table 3.1*, *assembly language
    and* *machine code*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，大多数计算机无法直接执行高级语言。每台计算机都有自己的本地语言，这种语言被计算机家族（例如，英特尔酷睿、摩托罗拉68K、ARMv4和MIPS）所理解。这些语言与计算机的结构及其硬件有关，这由计算机的ISA表达。这个层级在*表3.1*中由两层表示，即汇编语言和机器码。
- en: The layer below the high-level language is the assembly language level, which
    is a human representation of the computer’s binary machine code. People can’t
    remember or easily manipulate strings of 1s and 0s. Assembly language is a textual
    version of machine code. For example, the assembly language operation `ADD` A`,B,C`
    means add `B` to `C` and put the result in `A (i.e., A = B + C)` and might be
    represented in machine code as `00110101011100111100001010101010`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言之下的层级是汇编语言级别，这是计算机的二进制机器码的人类表示形式。人们无法记住或轻易操作由1和0组成的字符串。汇编语言是机器码的文本版本。例如，汇编语言操作`ADD
    A`,B,C`表示将`B`加到`C`上，并将结果放入`A`（即，A = B + C），在机器码中可能表示为`00110101011100111100001010101010`。
- en: The *machine code* layer is the binary code that the computer actually executes.
    In the PC world, a machine-code program has the `.exe` file extension because
    it can be *executed* by the computer. All computers execute binary code, although
    this layer is different for each type of computer – for example, Intel Core, ARM,
    and MIPS are three computer families, and each has its own machine code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*机器码*层是计算机实际执行的二进制代码。在PC世界中，机器码程序具有`.exe`文件扩展名，因为它们可以被计算机执行。所有计算机都执行二进制代码，尽管这个层对于每种类型的计算机都是不同的——例如，英特尔酷睿、ARM和MIPS是三种计算机家族，每个都有自己的机器码。'
- en: Although the assembly language layer is a representation of the machine code
    layer, there is a difference between these two layers. The assembly language layer
    includes facilities to help a programmer write programs, such as the ability to
    define variable names and to link independently written modules into a single
    machine-code program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然汇编语言层是机器码层的表示，但这两个层级之间存在差异。汇编语言层包括帮助程序员编写程序的设施，例如定义变量名和将独立编写的模块链接到单个机器码程序的能力。
- en: Below the machine-code layer are the electronic circuits, which are generically
    called microprocessors, or just chips. This is the hardware that companies such
    as Intel make, and it’s this hardware that reads programs from memory and executes
    them. In general, this layer cannot be programmed or modified any more than you
    can change the number of cylinders in your car’s engine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器码层之下是电子电路，通常被称为微处理器，或者简称为芯片。这是英特尔等公司制造的硬件，它从内存中读取程序并执行它们。一般来说，这个层级不能编程或修改，就像你不能改变你汽车引擎的气缸数量一样。
- en: Today, some digital systems do have circuits that can be modified electronically
    – that is, it is possible for the circuits of a computer to be restructured by
    changing the routing of signals through a circuit called a **field programmable
    gate array (FPGA)**. The FPGA contains a very large number of gates and special-purpose
    circuit blocks that can be interconnected by programming. An FPGA can be programmed
    to perform dedicated applications such as signal processing in medical or aerospace
    systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，一些数字系统确实有可以电子修改的电路——也就是说，通过改变通过称为**现场可编程门阵列（FPGA）**的电路的信号路由，可以重新配置计算机的电路。FPGA包含大量门和专用电路块，可以通过编程相互连接。FPGA可以被编程以执行专用应用，例如在医疗或航空航天系统中的信号处理。
- en: At the electronic circuit level, it’s possible to have different versions of
    the same set of circuits. For example, a microprocessor can be realized using
    7 nm or 14 nm device technology (these figures express the basic size of components
    on the chip, and smaller is better). The two circuits may be operationally identical
    in every way, but one version may be faster, cheaper, more reliable, or use less
    power than the other.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子电路层面，同一组电路可能有不同的版本。例如，微处理器可以使用7纳米或14纳米的器件技术来实现（这些数字表示芯片上组件的基本尺寸，尺寸越小越好）。这两个电路在各个方面可能都是操作上相同的，但一个版本可能比另一个版本更快、更便宜、更可靠或功耗更低。
- en: This book is about assembly language and machine code layers, and the layers
    in *Table 3.1* allow us to write programs that are executed by a computer. By
    the end of this book, you will be able to design your own machine code, your own
    assembly language, and your own computer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于汇编语言和机器代码层的，*表3.1*中的层允许我们编写由计算机执行的程序。到本书结束时，你将能够设计自己的机器代码、自己的汇编语言以及自己的计算机。
- en: In the 1940s and 1950s, all programming was done in assembly language (or even
    machine code). Not today. Writing assembly language programs is tedious and very
    challenging. Computer scientists have created high-level languages such as C++,
    Java, Python, and Fortran. These languages were developed to allow programmers
    to write programs in a near-English language that expresses more powerful ideas
    than assembly language. For example, in Python, you can print the text `"Hello
    World"` on the screen with the instruction `print("Hello World.")`. If you wanted
    to do that in assembly language, you would have to write out, say, 100 individual
    machine-level instructions. Moreover, the Python version will run on all computers,
    but the machine-level version has to be written for each specific computer type.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪40年代和50年代，所有的编程都是在汇编语言（甚至机器代码）中完成的。现在不是这样了。编写汇编语言程序是繁琐且极具挑战性的。计算机科学家创建了C++、Java、Python和Fortran等高级语言。这些语言是为了允许程序员用接近英语的语言编写程序而开发的，这种语言比汇编语言能表达更强大的思想。例如，在Python中，你可以使用`print("Hello
    World.")`指令在屏幕上打印文本`"Hello World"`。如果你想在汇编语言中做到这一点，你将不得不编写大约100个单独的机器级指令。此外，Python版本将在所有计算机上运行，但机器级版本必须为每种特定的计算机类型编写。
- en: The high-level language’s secret is the *compiler*. You write a program in a
    high-level language and then compile it to the machine code of the specific computer
    you want to run it on. You may come across the term *interpreter*, which performs
    the same function as a compiler. A compiler translates an entire high-level language
    program into machine code, whereas an interpreter performs the translation line
    by line, executing each line as it is interpreted.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 高级语言的秘密在于*编译器*。你用高级语言编写程序，然后将其编译成你想要运行的特定计算机的机器代码。你可能会遇到*解释器*这个术语，它执行的功能与编译器相同。编译器将整个高级语言程序翻译成机器代码，而解释器则是逐行进行翻译，并在解释的同时执行每一行。
- en: Writing code in assembly language is not popular today (outside academia). However,
    it has the advantage that (in principle) you can write optimized code that runs
    faster than compiled code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天（除学术界外），用汇编语言编写代码并不流行。然而，它有一个优点，即（原则上）你可以编写比编译代码运行更快的优化代码。
- en: A principal theme of this book is *learning by doing*. We will explain what
    a computer is, introduce the instructions it executes, and then show how it can
    be built (i.e., simulated) in a high-level language. We will call the program
    we are going to construct **TC1 (Teaching Computer 1)**. This program will execute
    the assembly language of a hypothetical computer. You will be able to write a
    program in assembly language, and the TC1 program will read the instructions and
    execute them as if they were running on a real TC1 computer.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一个主要主题是*实践学习*。我们将解释什么是计算机，介绍它执行的指令，然后展示如何用高级语言构建（即模拟）它。我们将要构建的程序称为**TC1（教学计算机1）**。这个程序将执行一个假设计算机的汇编语言。你将能够用汇编语言编写程序，TC1程序将读取指令并像在真实的TC1计算机上运行一样执行它们。
- en: When you run the program, you can execute instructions one by one and observe
    their outcomes v – that is, you can read the values of data in registers and memory
    as the program runs. The purpose of this computer is not to perform useful computing
    functions but to show what instructions look like and how they are executed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你可以逐条执行指令并观察它们的输出结果 v – 也就是说，你可以在程序运行时读取寄存器和内存中数据的值。这台计算机的目的不是执行有用的计算功能，而是展示指令的外观以及它们的执行方式。
- en: This computer demonstrates how instructions are executed and how to use assembly
    language. Moreover, you can modify the instruction set of the computer to create
    your own special-purpose instructions. You can remove instructions, add new instructions,
    extend instructions, and even change the format of instructions. TC1 was designed
    to enable students that study computer architecture to understand instruction
    formats, instruction decoding, and instruction complexity. It is also very helpful
    to understand addressing modes (i.e., how data is located in memory), such as
    pointer-based addressing. We will discuss these topics in more detail later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这台计算机演示了指令的执行方式和如何使用汇编语言。此外，你可以修改计算机的指令集以创建你自己的专用指令。你可以删除指令、添加新指令、扩展指令，甚至改变指令的格式。TC1被设计用来使学习计算机体系结构的学生能够理解指令格式、指令解码和指令复杂性。它也有助于理解寻址模式（即数据在内存中的定位方式），例如基于指针的寻址。我们将在稍后更详细地讨论这些主题。
- en: TC1 has several useful facilities that are not present in conventional computer
    instruction sets. For example, you can directly input data into the computer from
    the keyboard, and you can load random numbers into memory. This allows you to
    create data for testing purposes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: TC1有几个在传统计算机指令集中不存在的有用功能。例如，你可以直接从键盘将数据输入到计算机中，你还可以将随机数加载到内存中。这允许你为测试目的创建数据。
- en: First, we need to introduce the prototype computer, the so-called von Neumann
    machine, which was created in the 1940s and 1950s and became the template for
    most modern computers. In reality, there’s been quite a departure from the pure
    von Neumann architecture, but we still tend to use the term to distinguish between
    other classes of computers (e.g., analog computers, neural networks, and quantum
    computers).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要介绍原型计算机，即所谓的冯·诺伊曼机，它在20世纪40年代和50年代被创造出来，并成为大多数现代计算机的模板。实际上，已经相当偏离了纯冯·诺伊曼架构，但我们仍然倾向于使用这个术语来区分其他类别的计算机（例如，模拟计算机、神经网络和量子计算机）。
- en: ISAs – the Naming of Parts
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ISAs – 部件命名
- en: 'Before we introduce the structure of a computer, we need to introduce several
    terms that you need to know:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍计算机的结构之前，我们需要介绍一些你必须了解的术语：
- en: '`0` or `1`. You can set a bit to `0`, to `1`, or toggle it (flip it over).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`或`1`。你可以将位设置为`0`，设置为`1`，或者切换它（翻转它）。'
- en: '`8`, `16`, `32`, or `64`. In general, the word is the basic unit of data that
    the computer operates on. An instruction such as `ADD` a`,b,c` executed on a 64-bit
    computer would add the 64-bits of word `b` to the 64-bits or word `c` and put
    the 64-bit result in word `a`. The `a`, `b`, and `c` variables refer to storage
    locations in either memory or registers.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`8`、`16`、`32`或`64`。一般来说，字是计算机操作的基本数据单位。在64位计算机上执行`ADD a,b,c`这样的指令会将字`b`的64位与字`c`的64位相加，并将64位的结果放入字`a`中。变量`a`、`b`和`c`指的是内存或寄存器中的存储位置。'
- en: '**Instruction**: A machine-level instruction is the most primitive operation
    that a programmer can specify and defines a single action carried out by the computer.
    Even more primitive level operations may exist on the silicon, but a programmer
    cannot directly access these. Instructions largely fall into three classes – data
    movement that copies data from one place to another, arithmetic and logical operations
    that process data, and instruction sequence commands that determine the order
    in which instructions are carried out (necessary to implement decisions of the
    form *if this, then* *do that*).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指令**：机器级指令是程序员可以指定的最基本操作，它定义了计算机执行的单个动作。在硅片上可能存在更原始的操作级别，但程序员无法直接访问这些。指令主要分为三类——数据移动，将数据从一个地方复制到另一个地方，算术和逻辑操作，处理数据，以及指令序列命令，确定指令执行的顺序（这是实现形式为
    *如果这个，那么* *做那个* 的决策所必需的）。'
- en: '**Immediate access memory**: This is often just called memory or RAM or DRAM
    by many programmers. It is where programs and data are stored during the execution
    of a program. The term *random access memory* today means the same thing. However,
    strictly speaking, the term *random* indicates that the access time for a memory
    element chosen at random is the same for every element (unlike, say, magnetic
    tape, where the access time depends on where data is on the tape).'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立即访问内存**：这通常被许多程序员称为内存或 RAM 或 DRAM。这是程序执行期间程序和数据的存储位置。今天，术语 *随机访问内存* 意味着相同的东西。然而，严格来说，术语
    *随机* 指的是随机选择的一个内存元素访问时间对每个元素都是相同的（与磁带不同，磁带的访问时间取决于数据在磁带上的位置）。'
- en: '`8` to `64` registers on a chip, it requires only `3` to `6` bits to specify
    a given register, rather than the `32` or `64` bits typically used to access a
    memory location. Most computer operations act on the contents of registers rather
    than the main memory. There is no universal convention for the naming of registers.
    In this chapter, we will generally use for register names – for example, `INC
    r3` increments the contents of register `r3` by `1`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在芯片上，`8` 到 `64` 个寄存器，指定一个特定的寄存器只需要 `3` 到 `6` 位，而不是通常用来访问内存位置的 `32` 或 `64` 位。大多数计算机操作都是作用于寄存器的内容，而不是主内存。寄存器的命名没有通用的约定。在本章中，我们将一般使用以下命名方式——例如，`INC
    r3` 表示将寄存器 `r3` 的内容增加 `1`。
- en: '`32` bits or `64` bits long. However, 8- and 16-bit computers are frequently
    used in embedded control applications (e.g., toys, TVs, washing machines, and
    automobiles).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`32` 位或 `64` 位长。然而，8 位和 16 位计算机在嵌入式控制应用中经常被使用（例如，玩具、电视、洗衣机和汽车）。'
- en: '`ADD` a`,b,5` where `5` is a literal, then it means, add the `5` integer to
    `b`. Some computers use a `#` to indicate a literal – for example, `ADD` a`,b,#12`
    means, add the number `12` to the contents of memory location `b`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD a,b,5` 其中 `5` 是一个字面量，那么它的意思就是，将整数 `5` 加到 `b` 上。一些计算机使用 `#` 来表示字面量——例如，`ADD
    a,b,#12` 的意思是，将数字 `12` 加到内存位置 `b` 的内容上。'
- en: '`A` and then ends up at `B` – simplicity itself. In computing, the term *move*
    indicates that something that was at `A` ends up at `B`, as well – that is, it
    is now in both `A` and `B`. In other words, programmers use *move* to mean *copy*.
    If you *move* data from a register to memory, the data remains in the register
    and is *copied* to memory. We will introduce the prototype computer in the following
    section.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `A` 移动到 `B`——简单至极。在计算机科学中，术语 *move* 表示原本在 `A` 的东西最终到了 `B`，也就是说，它现在既在 `A` 也在
    `B`。换句话说，程序员使用 *move* 来表示 *copy*。如果你将数据从寄存器移动到内存，数据仍然保留在寄存器中，并复制到内存。我们将在下一节介绍原型计算机。
- en: The next step is to introduce the notion of the von Neumann computer, which
    can be regarded as the grandfather of most modern computers. The mathematician
    von Neumann was one of the authors of *The First Draft Report on the EDVAC* in
    1945, which characterized the structure of the digital computer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是介绍冯·诺依曼计算机的概念，它可以被认为是大多数现代计算机的祖先。数学家冯·诺依曼是 1945 年 *EDVAC 第一草案报告* 的作者之一，该报告描述了数字计算机的结构。
- en: The von Neumann architecture
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冯·诺依曼架构
- en: The prototype computer is often called a stored program von Neumann machine.
    It has a program in memory that is executed instruction by instruction sequentially.
    Moreover, the program is stored in the same memory as the data that the computer
    operates on. This structure is named in honor of one of the pioneers of computing,
    John von Neumann. Once you understand the von Neumann machine, you understand
    all computers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 原型计算机通常被称为存储程序冯·诺伊曼机。它有一个存储在内存中的程序，按指令顺序逐条执行。此外，程序存储在与计算机操作的数据相同的内存中。这种结构以计算先驱之一约翰·冯·诺伊曼的名字命名。一旦你理解了冯·诺伊曼机，你就理解了所有计算机。
- en: '*Figure 3**.1* illustrates a simplified von Neumann machine that contains three
    basic elements:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*展示了包含三个基本元素的简化冯·诺伊曼机：'
- en: A memory that holds the program and any data used by the program
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个存储程序和程序使用的任何数据的内存
- en: A set of registers that each holds one word of data (in *Figure 3**.1*, there
    is one register, `r0`)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组寄存器，每个寄存器存储一个数据字（在*图3.1*中有一个寄存器，`r0`）
- en: An **arithmetic and logic unit (ALU)** that performs all data processing
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**算术逻辑单元（ALU**），执行所有数据处理
- en: '![Figure 3.1 – The von Neumann architecture](img/Figure_3.01_B19624.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 冯·诺伊曼架构](img/Figure_3.01_B19624.jpg)'
- en: Figure 3.1 – The von Neumann architecture
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 冯·诺伊曼架构
- en: The memory contains instructions to be executed. Both data and instructions
    are stored in binary form, although we will often show operations in assembly
    language form for ease of reading. Each instruction is read from memory, decoded,
    and interpreted (i.e., executed). The principal simplification of *Figure 3**.1*
    is the lack of a means of executive conditional operations (i.e., `if… then`).
    We will fix that later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内存包含要执行的指令。数据和指令都以二进制形式存储，尽管我们经常以汇编语言形式展示操作，以便于阅读。每个指令都是从内存中读取、解码和解释（即执行）。*图3.1*的主要简化是没有执行条件操作（即`if…then`）的手段。我们将在稍后解决这个问题。
- en: '*Figure 3**.1* looks complicated. It’s not. We’ll explain its operation step
    by step. Once we see how a computer operates in principle, we can look at how
    it may be implemented in software. We describe the operation of a very simple,
    so-called *one-and-a-half* address machine, whose instructions have two operands
    – one in memory and one in a register. Instructions are written in the form `ADD`
    B`,A`, which adds `A` to `B` and puts the result in `B`. Either `A` or `B` must
    be in a register. Both operands may be in registers. The term *one-and-a-half
    address* machine is a comment about the fact that the memory address is 16 to
    32 bits and selects one of millions of memory locations, whereas the register
    address is typically 2 to 6 bits and selects only one of a small number of registers.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*看起来很复杂。其实并不复杂。我们将一步一步地解释其操作。一旦我们了解了计算机在原理上的工作方式，我们就可以看看它如何在软件中实现。我们描述了一个非常简单的、所谓的*一又二分之一地址*机的操作，其指令有两个操作数——一个在内存中，一个在寄存器中。指令的形式为`ADD
    B,A`，它将`A`加到`B`上，并将结果放入`B`。`A`或`B`必须在一个寄存器中。两个操作数都可以在寄存器中。*一又二分之一地址*机的术语是对事实的评论，即内存地址是16到32位，选择数百万个内存位置中的一个，而寄存器地址通常是2到6位，只选择少数几个寄存器中的一个。'
- en: Instead of introducing the computer all at once, we will build up a CPU step
    by step. This approach helps demonstrate how an instruction is executed because
    the development of the computer broadly follows the sequence of events taking
    place during the execution of an instruction. Real computers don’t execute an
    instruction from start to finish. Today’s computers *overlap* the execution of
    instructions. As soon as one instruction is fetched from memory, the next instruction
    is fetched before the previous instruction has completed its execution. This mechanism
    is called *pipelining* and is a major aspect of a modern computer’s organization.
    Pipelining is analogous to the automobile production line, where computer instructions
    are executed in stages so that several instructions may be in the process of being
    executed at the same time. We will begin with the address paths that are used
    to locate the next instruction to be executed. In this book, we will not cover
    pipelining because it is a factor or implementation and not an instruction set
    design.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会一次性引入计算机，而是逐步构建 CPU。这种方法有助于展示指令是如何被执行的，因为计算机的发展大体上遵循了指令执行过程中发生的事件顺序。现实中的计算机不会从开始到结束执行一个指令。今天的计算机*重叠*指令的执行。一旦一条指令从内存中取出，下一条指令就会在上一条指令完成执行之前被取出。这种机制称为*流水线*，是现代计算机组织的一个重要方面。流水线类似于汽车生产线，计算机指令在各个阶段被执行，以便同时执行多个指令。我们将从用于定位将要执行的下一个指令的地址路径开始。在这本书中，我们不会涉及流水线，因为它是一个实现因素，而不是指令集设计。
- en: The address path
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地址路径
- en: An address is a number representing the location of an item of data within memory.
    *Figure 3**.2* shows only the address paths needed to read an instruction from
    memory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 地址是一个表示内存中数据项位置的数字。*图 3**.2* 仅显示了读取内存中指令所需的地址路径。
- en: '![Figure 3.2 – The CPU’s address paths](img/Figure_3.02_B19624.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – CPU 的地址路径](img/Figure_3.02_B19624.jpg)'
- en: Figure 3.2 – The CPU’s address paths
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – CPU 的地址路径
- en: An address path is a data highway that moves addresses between the CPU and memory.
    The address tells memory where we want to read data from, or where we want to
    store it. For example, the instruction `ADD` r0`,234` indicates the operation
    *read the contents of memory location 234, add them to the contents of register
    r0, and then put the result in r0*. *Figure 3**.2* omits the data paths required
    to execute instructions to avoid clutter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 地址路径是 CPU 和内存之间移动地址的数据高速公路。地址告诉内存我们想要从哪里读取数据，或者我们想要存储在哪里。例如，指令 `ADD r0`,234`
    表示操作*从内存位置 234 读取内容，将它们加到寄存器 r0 的内容上，然后将结果放入 r0*。*图 3**.2* 省略了执行指令所需的数据路径，以避免混乱。
- en: There are three types of information flow in a computer – address, data, and
    control. Data comprises the instructions, constants, and variables stored in memory
    and registers. Control paths comprise the signals that trigger events, provide
    clocks, and determine the flow of data and addresses throughout the computer.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机中有三种类型的信息流——地址、数据和控制。数据包括存储在内存和寄存器中的指令、常量和变量。控制路径包括触发事件、提供时钟以及确定数据流和地址在计算机中流动的信号。
- en: Reading the instruction
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取指令
- en: Before the CPU can execute an instruction, the instruction must be brought from
    the computer’s memory. We begin our description of the way in which a program
    is executed with the CPU’s *program counter* (also called *instruction pointer*
    or *location counter*). The expression *program counter* is a misnomer. The program
    counter doesn’t count programs or anything else, but instead contains the address
    of the next instruction in memory to be executed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CPU 执行指令之前，必须将指令从计算机的内存中取出。我们开始描述程序是如何被执行的，从 CPU 的*程序计数器*（也称为*指令指针*或*位置计数器*）开始。*程序计数器*这个名称是不准确的。程序计数器并不计算程序或其他任何东西，而是包含内存中将要执行的下一个指令的地址。
- en: The program counter *points* to the next instruction to be executed. If, for
    example, `[PC] = 1234` (i.e., the `PC` contains the number `1234`), the next instruction
    to be executed will be found in memory location `1234`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序计数器*指向*将要执行的下一个指令。例如，如果 `[PC] = 1234`（即，`PC` 包含数字 `1234`），则将要执行的下一个指令将在内存位置
    `1234` 中找到。
- en: 'Fetching an instruction begins with the contents of the program counter being
    moved to the memory address register (i.e., `[MAR]` ← `[PC]`). Once the contents
    of the program counter have been transferred to the memory address register, the
    contents of the program counter are incremented and moved back to the program
    counter, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 获取指令的过程始于程序计数器的内容被移动到内存地址寄存器（即 `[MAR]` ← `[PC]`）。一旦程序计数器的内容已转移到内存地址寄存器，程序计数器的内容会增加并重新移动回程序计数器，如下所示：
- en: '`[PC]` ← `[PC] +` 1.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`[PC]` ← `[PC] +` 1.'
- en: The PC increment is `1` because the next instruction is one location on. Real
    computers are normally byte-addressed – that is, the bytes are numbered sequentially
    `0, 1, 2, 3 …` Modern computers have 32- or 64-bit data words – that is, 4- or
    8-byte words. Consequently, real computers increment the PC by 4 or 8 after each
    instruction.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PC 增量为 `1` 因为下一个指令位于一个位置之后。现实中的计算机通常是按字节寻址的——也就是说，字节按顺序编号 `0, 1, 2, 3 …` 现代计算机有
    32 位或 64 位数据字——即 4 字节或 8 字节字。因此，现实中的计算机在每条指令之后将 PC 增加 4 或 8。
- en: After this operation, the program counter points to the *next* instruction while
    the current instruction is executed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作之后，程序计数器指向 *下一个* 指令，而当前指令正在执行。
- en: The **memory address register (MAR)** holds the address of the location in the
    memory into which data is written in a write cycle, or from which data is read
    in a read cycle.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存地址寄存器（MAR）** 存储了在写周期中写入数据到内存中的位置地址，或在读周期中从该地址读取数据。'
- en: 'When a *memory read cycle* is performed, the contents of the memory location
    specified by the MAR are read from the memory and transferred to the **memory
    buffer register (MBR)**. We can represent this read operation in RTL terms as
    follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 *内存读周期* 时，由 MAR 指定的内存位置的内容从内存中读取并传输到 **内存缓冲寄存器（MBR）**。我们可以用 RTL 术语表示这个读操作如下：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We interpret the `[[MAR]]` expression as *the contents of the memory whose address
    is given by the contents of the MAR*. The memory buffer register is a temporary
    holding place for data received from memory in a read cycle, or for data to be
    transferred to memory in a write cycle. Some texts refer to the MBR as the **memory
    data register (MDR).** At this point in the execution of an instruction, the MBR
    contains the bit pattern of the instruction to be executed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `[[MAR]]` 表达式解释为 *由 MAR 内容指定的内存的内容*。内存缓冲寄存器是读取周期中从内存接收数据的临时存储位置，或写入周期中要传输到内存的数据的临时存储位置。一些文本将
    MBR 称为 **内存数据寄存器（MDR）**。在执行指令的这个阶段，MBR 包含要执行的指令的位模式。
- en: The instruction is next moved from the MBR to the **instruction register (IR)**,
    where it is divided into two fields. A *field* is part of a word in which the
    bits are grouped together into a logical entity – for example, a person’s name
    can be divided into two fields, the given name and the family name. One field
    in the IR contains the *operation code* (opcode) that tells the CPU what operation
    is to be carried out. The other field, called the *operand field*, contains the
    address of the data to be used by the instruction. The operand field can also
    provide a constant to be employed by the operation code when immediate or literal
    addressing is used – that is, when the operand is an actual (i.e., literal) value
    and not an address. For our current purposes, the register address is considered
    to be part of the instruction. Later, we will introduce computers with multiple
    registers. Real computers divide the instruction into more than two fields – for
    example, there may be two or three register-select fields.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，指令从 MBR 移动到 **指令寄存器（IR）**，在那里它被分为两个字段。一个 *字段* 是一个字的一部分，其中位被分组成一个逻辑实体——例如，一个人的名字可以分为两个字段，即名字和姓氏。IR
    中的一个字段包含 *操作码*（opcode），它告诉 CPU 要执行什么操作。另一个字段，称为 *操作数字段*，包含指令要使用的数据的地址。操作数字段还可以提供操作码在立即或直接寻址时使用的常数——也就是说，当操作数是一个实际（即文字）值而不是地址时。就我们当前的目的而言，寄存器地址被认为是指令的一部分。稍后，我们将介绍具有多个寄存器的计算机。现实中的计算机将指令分为超过两个字段——例如，可能有两个或三个寄存器选择字段。
- en: The **control unit (CU)** takes the opcode from the instruction register, together
    with a stream of clock pulses, and generates signals that control all parts of
    the CPU. The time between individual clock pulses is typically in the range 0.3
    ns to 100 ns (i.e., 3 x 10-10 to 10-7 s), corresponding to frequencies of 3.3
    GHz to 10 MHz. The CU is responsible for moving the contents of the program counter
    into the MAR, executing a read cycle, and moving the contents of the MBR to the
    IR.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制单元（CU）**从指令寄存器中获取操作码，以及一系列时钟脉冲，并生成控制CPU所有部分的信号。单个时钟脉冲之间的时间通常在0.3 ns到100
    ns（即3 x 10^-10到10^-7 s）的范围内，对应于3.3 GHz到10 MHz的频率。CU负责将程序计数器的内容移动到MAR，执行读周期，并将MBR的内容移动到IR。'
- en: 'Instructions are executed in a two-phase *fetch-execute cycle*. During the
    *fetch phase*, the instruction is read from memory and decoded by the control
    unit. The fetch phase is followed by an *execute phase*, in which the control
    unit generates all the signals necessary to execute the instruction. The following
    RTL notation describes the sequence of operations that take place in a fetch phase.
    `FETCH` is a label that serves to indicate a particular line in the sequence of
    operations. The notation IRopcode means the operation-code field of the instruction
    register. We use `#` to indicate a comment in Python and `@` in assembly language
    to be compatible with ARM’s convention. Some assemblers use a semicolon to indicate
    a comment field:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 指令在两阶段的*fetch-execute cycle*中执行。在*fetch phase*阶段，指令从内存中读取并由控制单元解码。fetch phase阶段之后是*execute
    phase*阶段，在这个阶段，控制单元生成执行指令所需的所有信号。以下RTL符号描述了fetch phase中发生的操作序列。`FETCH`是一个标签，用于指示操作序列中的特定行。符号IRopcode表示指令寄存器的操作码字段。我们使用`#`来表示Python中的注释，并在汇编语言中使用`@`以符合ARM的约定。一些汇编器使用分号来表示注释字段：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is an example of how we can code the fetch cycle as a function
    in Python, together with the code needed to test it. We define a 12-bit instruction
    with a 4-bit opcode and an 8-bit address. The memory has 16 locations, and we
    load the first two with dummy values to test the program. The Python expression
    p >> q takes the binary value p and shifts it q places right, and `&` performs
    a logical `AND`. We will discuss this in more detail later. For example, 0110`00001010
    >> 8` becomes 0110\. This extracts the opcode. Similarly, `0b011011111010 & 0b111111111111
    = 0b000000001010` to extract the address:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将fetch cycle编码为Python中的函数的示例，以及测试它的所需代码。我们定义了一个12位指令，其中包含4位操作码和8位地址。内存有16个位置，我们加载前两个位置以测试程序。Python表达式p
    >> q表示将二进制值p右移q位，`&`执行逻辑`AND`操作。我们将在稍后详细讨论这个问题。例如，`0110`00001010 >> 8`变为`0110`。这提取了操作码。同样，`0b011011111010
    & 0b111111111111 = 0b000000001010`以提取地址：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the numeric `0b011000001010` value is expressed in binary
    form by the `0b` prefix. Similarly, the `0xFF` notation indicates a number in
    hexadecimal form – that is, `255` in decimal or `11111111` in binary form.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，数值`0b011000001010`通过`0b`前缀以二进制形式表示。同样，`0xFF`表示法表示十六进制形式的数字——即十进制中的`255`或二进制形式中的`11111111`。
- en: 'The function is tested by calling it twice with `opCode,address = fetch(mem)`.
    Python lets us receive the two returned parameters, opcode and address, on one
    line. Note how closely the Python code follows the RTL. In practice, you would
    not write this code. We don’t need the MAR and MBR registers. I included them
    to help model the hardware. We can simply write the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过两次调用`opCode,address = fetch(mem)`来测试函数。Python允许我们在一行中接收两个返回的参数，即操作码和地址。注意Python代码如何紧密地遵循RTL。在实际应用中，你不会编写这样的代码。我们不需要MAR和MBR寄存器。我包括它们是为了帮助模拟硬件。我们可以简单地编写以下代码：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The CPU’s data paths
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU的数据路径
- en: Having sorted out the fetch phase, let’s see what else we need to execute instructions.
    *Figure 3**.3* adds data paths to the CPU of *Figure 3**.2*, plus an address path
    from the address field of the instruction register to the memory address register.
    Other additions are a data register, `r0`, and an ALU that does the actual computing.
    The operations it performs are typically arithmetic (add, subtract, multiply,
    and divide) and logical (`AND`, `OR`, `EOR`, and shift left or right).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决了fetch phase之后，让我们看看还需要什么来执行指令。*图3**.3*将数据路径添加到*图3**.2*的CPU中，以及从指令寄存器的地址字段到内存地址寄存器的地址路径。其他添加包括数据寄存器`r0`和一个执行实际计算的ALU。它执行的运算通常是算术运算（加、减、乘、除）和逻辑运算（`AND`、`OR`、`EOR`以及左移或右移）。
- en: '![Figure 3.3 – The CPU’s address and data paths](img/Figure_3.03_B19624.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The CPU’s address and data paths
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The data register, `r0`, holds temporary results during a calculation. You need
    a data register (i.e., an accumulator) because *dyadic* operations with two operands
    such as `ADD` use one operand specified by the instruction, and the other register
    is the contents of a data register. `ADD` `,P` adds the contents of the memory
    location, `P`, to the contents of the general-purpose register, `r0`, and deposits
    the sum in the data register, destroying one of the original operands. The arrangement
    of *Figure 3**.3* has one general-purpose data register that we’ve called `r0`.
    A real processor, the ARM, has 16 registers, `r0` to `r15` (although not all of
    them are general-purpose data registers).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Typical data movement instructions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All computers have data move instructions that transfer (i.e., copy) data from
    one place to another. These are the simplest instructions because they don’t involve
    processing data. Data movement instructions vary from computer to computer. Here,
    we will provide a few typical examples that will help you follow the examples
    in this chapter. Note that we will use different conventions in this text. For
    example, we will sometimes prefix a literal by `#` (e.g., `ADD` `,#6`) and sometimes
    add the suffix `L` to the instruction (e.g., `ADDL` r1`,6`). This is because there
    are several standards/conventions in use in computing, and they vary from computer
    to computer. The following are simply generic examples of code. Note the duplication
    of load a literal. Some processors use `move` and some use `load`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mnemonic** | **Example** | **Name** | **RTL** | **Comment** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `MOV` | `MOV`  r1`,r4` | move register | [r1] ← [r4] | Copy register r4 to
    register r1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `MOVL` | `MOVL` r1`,5` | move literal | [r1] ← 5 | Copy the integer 5 to
    register r1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `LDR` | `LDR`  r3`,12` | load register | [r3] ← [12] | Load r3 with contents
    of memory location 12 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `LDRL` | `LDRL` r0`,13` | load literal | [r0] ← 13 | Load register r0 with
    the integer 13 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `STR` | `STR`  `r4,`8 | store register | [8] ← [r4] | Store contents of r4
    in memory location 8 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – Typical data movement instructions
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Data processing instructions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a typical data-processing operation. We can represent an `ADD`
    r0`,X` instruction with the RTL expression:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The ALU is the workhorse of the CPU because it performs all calculations. Arithmetic
    and logical operations are applied to the contents of a data register and the
    contents of a data register or the MBR. The output of the ALU is fed back to the
    data register or to the MBR.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental difference between arithmetic and logical operations is that
    logical operations don’t generate a carry when bit ai of word `A` and bit bi of
    `B` are operated upon. *Table 3.2* provides examples of typical arithmetic and
    logical operations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Class** | **Typical mnemonic** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **类别** | **典型助记符** |'
- en: '| --- | --- | --- |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Addition | Arithmetic | ADD (a = b + c) |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | 算术 | ADD (a = b + c) |'
- en: '| Subtraction | Arithmetic | SUB (a = b - c) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | 算术 | SUB (a = b - c) |'
- en: '| Negation | Arithmetic | NEG (a = -b) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 取反 | 算术 | NEG (a = -b) |'
- en: '| Multiplication | Arithmetic | MUL (a = b * c) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | 算术 | MUL (a = b * c) |'
- en: '| Division | Arithmetic | DIV (a = b / c) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 除法 | 算术 | DIV (a = b / c) |'
- en: '| Divide by 2 | Arithmetic | ASR (a = b / 2) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 除以 2 | 算术 | ASR (a = b / 2) |'
- en: '| Multiply by 2 | Arithmetic | ASL (a = b * 2) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 乘以 2 | 算术 | ASL (a = b * 2) |'
- en: '| AND | Logical | AND (a = b & c) |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| AND | 逻辑 | AND (a = b & c) |'
- en: '| OR | Logical | OR (a = b &#124; c) |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| OR | 逻辑 | OR (a = b ∨ c) |'
- en: '| NOT | Logical | NOT (a = !b) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| NOT | 逻辑 | NOT (a = !b) |'
- en: '| EOR | Logical | EOR (a = b ⊕ c) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| EOR | 逻辑 | EOR (a = b ⊕ c) |'
- en: '| Shift left | Logical | LSL (shift all bits left a = b << 1) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 左移 | 逻辑 | LSL (将所有位左移 a = b << 1) |'
- en: '| Shift right | Logical | LSR (shift all bits right a = b >> 1) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 右移 | 逻辑 | LSR (将所有位右移 a = b >> 1) |'
- en: Table 3.3 – Typical arithmetic and logical operations
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.3 – 典型的算术和逻辑运算
- en: A logical shift treats an operand as a string of bits that are moved left or
    right. An arithmetic shift treats a number as a signed 2s complement value and
    propagates the sign bit during a right shift (i.e., the sign bit is replicated
    and duplicated). Most of these operations are implemented by computers such as
    the 68K, Intel Core, and ARM.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑移位将操作数视为一个位串，这些位向左或向右移动。算术移位将数字视为一个有符号的 2 的补码值，并在右移时传播符号位（即符号位被复制和重复）。这些操作中的大多数都由
    68K、Intel Core 和 ARM 等计算机实现。
- en: Another look at the data flow
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次看看数据流
- en: Let’s have another look at data flow in a computer to cement the basic concepts
    together. In *Figure 3**.4*, we have a computer that supports operations involving
    three registers (a hallmark of computers such as the ARM). Here, we have three
    registers, `r1`, `r2`, and `r3`. The block labeled *adder* is part of the ALU
    and serves to add two numbers to produce a sum. Instruction `LDR` r2`,X` loads
    the contents of memory address `X` into register `r2`. Instruction `STR r1,`Z
    stores the contents of register `r1` in memory address `Z`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看计算机中的数据流，以巩固基本概念。在 *图 3*.*4* 中，我们有一个支持涉及三个寄存器（如 ARM 计算机的特点）的操作的计算机。在这里，我们有三个寄存器，`r1`、`r2`
    和 `r3`。标记为 *加法器* 的块是 ALU 的一部分，用于将两个数字相加以产生和。指令 `LDR r2,X` 将内存地址 `X` 的内容加载到寄存器
    `r2`。指令 `STR r1,Z` 将寄存器 `r1` 的内容存储在内存地址 `Z`。
- en: The instruction `ADD` r1`,r2,r3` reads the contents of registers `r2` and `r3`,
    adds them together, and deposits the result in register, `r1`. Since it’s not
    clear which register is the destination register (i.e., the result), we use a
    bold font to highlight the destination operand, which is normally the leftmost
    operand.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 `ADD r1,r2,r3` 读取寄存器 `r2` 和 `r3` 的内容，将它们相加，并将结果存入寄存器 `r1`。由于不清楚哪个寄存器是目标寄存器（即结果），我们使用粗体字来突出目标操作数，这通常是左边的操作数。
- en: '*Figure 3**.4* shows several fundamental components of a computer. This is,
    essentially, the same as the more detailed structures we used to demonstrate the
    fetch/execute cycle. Here, we are interested in data flow into and out of memory.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3*.*4* 展示了计算机的几个基本组件。这本质上与我们在演示取指/执行周期时使用的更详细的结构相同。在这里，我们关注的是数据流向内存以及从内存中流出。'
- en: '![Figure 3.4 – Details of the von Neumann machine](img/Figure_3.04_B19624.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 冯·诺依曼机的细节](img/Figure_3.04_B19624.jpg)'
- en: Figure 3.4 – Details of the von Neumann machine
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 冯·诺依曼机的细节
- en: 'The elements of interest are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们感兴趣的部分：
- en: A clock that generates timing pulses. All operations take place when triggered
    by the clock.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产生定时脉冲的时钟。所有操作都在时钟触发时进行。
- en: An interpreter or control unit that takes an instruction, together with a stream
    of clock pulses, and converts it into the actions required to perform the required
    operation. In *Figure 3**.4*, the interpreter routes the contents of registers
    `r2` and `r3` to the adder, makes the adder add the two values together, and then
    routes the result from the adder to the destination register.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个解释器或控制单元，它接受一条指令，以及一系列时钟脉冲，并将其转换为执行所需操作所需的动作。在 *图 3*.*4* 中，解释器将寄存器 `r2` 和
    `r3` 的内容路由到加法器，使加法器将两个值相加，然后将结果从加法器路由到目标寄存器。
- en: The program in memory. Data is loaded from memory into registers `r2` and `r2`.
    Then, `r2` and `r3` are added together and the result is put in `r3`. Finally,
    the contents of `r3` are moved to memory.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储器中的程序。数据从存储器加载到寄存器 `r2` 和 `r2`。然后，`r2` 和 `r3` 相加，结果存入 `r3`。最后，将 `r3` 的内容移动到存储器中。
- en: Now that we’ve covered the basic structure of a computer and introduced some
    instructions, the next step is to look at a complete program that carries out
    a specific function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了计算机的基本结构和一些指令，下一步是查看一个执行特定功能的完整程序。
- en: An assembly-level program
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 汇编级程序
- en: 'Having developed our computer a little further, in this section, we will show
    how a simple program is executed. Assume that this computer doesn’t provide three-address
    instructions (i.e., you can’t specify an operation with three registers and/or
    memory addresses) and we want to implement the high-level language operation `Z
    = X + Y`. Here, the *plus* symbol means arithmetic addition. An assembly language
    program that carries out this operation is given in the following code block.
    Remember that `X`, `Y`, and `Z` are symbolic names referring to the *locations*
    of the variables in memory. Logically, the store operation should be written `STR
    Z,r2`, with the destination operand on the left just like other instructions.
    By convention, it is written as `STR r2,Z`, with the source register on the left.
    This is a quirk of programming history:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步开发我们的计算机之后，在本节中，我们将展示如何执行一个简单的程序。假设这台计算机不提供三地址指令（即，你不能指定三个寄存器和/或内存地址的操作），我们想要实现高级语言操作
    `Z = X + Y`。在这里，`+` 符号表示算术加法。执行此操作的汇编语言程序如下所示。记住，`X`、`Y` 和 `Z` 是指代内存中变量位置的符号名称。从逻辑上讲，存储操作应该写成
    `STR Z,r2`，目标操作数在左边，就像其他指令一样。按照惯例，它被写成 `STR r2,Z`，源寄存器在左边。这是编程历史的一个怪癖：
- en: '`LDR``,X``r2` with the contents of memory location `X`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDR`,X``r2` 从内存位置 `X` 获取内容'
- en: '`ADD``,Y``Y` to data register `r2`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`,Y``Y` 将数据寄存器 `r2` 的内容加到 `Y`'
- en: '`STR``r2,`Z`r2` in memory location `Z`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`STR`,r2,`Z` 将 `r2` 存入内存位置 `Z`'
- en: 'Eight-bit computers had a one-address machine, requiring a rather cumbersome
    sequence of operations just to carry out the simple act of adding two numbers.
    If we had a computer with a three-address format, we could have written the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 八位计算机有一个单地址机，仅为了执行加法这样简单的操作，就需要一个相当繁琐的操作序列。如果我们有一个三地址格式的计算机，我们可以写出以下内容：
- en: '`ADD``,X,Y`Add the contents of X to the contents of Y and put the result in
    Z'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`,X,Y` 将 X 的内容加到 Y 的内容上，并将结果存入 Z'
- en: Three-address machines are *potentially* faster than one-address machines because
    they can do in one instruction things that take other machines three operations.
    Unfortunately, it is a factor of technological development that on-chip registers
    are faster than DRAM, and computer designers try to keep data in registers on-chip
    as much as possible.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 三地址机相对于单地址机来说**可能**更快，因为它们可以在一个指令中完成其他机器需要三个操作才能完成的事情。不幸的是，这是技术发展的一个因素，片上寄存器比
    DRAM 快，计算机设计者试图尽可能地将数据保持在片上寄存器中。
- en: The reality is more complicated. Accessing memory is slow compared to accessing
    registers. This is a property of the hardware. Consequently, it is more efficient
    to keep data in registers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是更复杂的。与访问寄存器相比，访问内存要慢。这是硬件的一个特性。因此，将数据保持在寄存器中更有效率。
- en: 'The way in which the CPU operates can best be seen by examining the execution
    of, say, `ADD` r2`,Y` in terms of register-transfer language. In the following
    code block, we describe the operations carried out during the fetch and execute
    phases of an `ADD` r2`,Y` instruction:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查例如 `ADD r2,Y` 的执行，可以最好地了解 CPU 的工作方式。在以下代码块中，我们描述了 `ADD r2,Y` 指令的取指和执行阶段所执行的操作：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Operations sharing the same line are executed simultaneously.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 同一行上的操作是同时执行的。
- en: During the fetch phase, the opcode is fed to the control unit by CU ← [IRopcode]
    and used to generate all the internal signals required to place the ALU in its
    addition mode. When the ALU is programmed for addition, it adds together the data
    at its two input terminals to produce a sum at its output terminals.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在取指阶段，操作码通过 CU ← [IRopcode] 传送到控制单元，并用于生成放置 ALU 在加法模式所需的所有内部信号。当 ALU 被编程为加法时，它将两个输入端的数据相加，在输出端产生一个和。
- en: Operations of the form `[PC]` ← `[MAR]` or `[r2]` ← `[r2] + [MBR]` are often
    referred to as *microinstructions*. Each assembly-level instruction (e.g., `MOV,
    ADD`) is executed as a series of microinstructions. Microinstructions are the
    province of the computer designer. In the 1970s, some machines were user-microprogrammable
    – that is, you could define your own instruction set.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 `[PC]` ← `[MAR]` 或 `[r2]` ← `[r2] + [MBR]` 的操作通常被称为 *微指令*。每个汇编级指令（例如，`MOV,
    ADD`）都作为一系列微指令执行。微指令是计算机设计者的领域。在20世纪70年代，一些机器是用户可微编程的——也就是说，你可以定义自己的指令集。
- en: 'We can test the execute phase by extending the fetch phase code. The following
    Python code provides three instructions – load a register with a literal, add
    memory contents to the register, and stop. We have also made the Python code more
    compact – for example, you can put expressions in a function’s return statement.
    In this example, we return two values: `ir >> 8` and `ir & 0xFF`. The operation
    `x >> y` takes the binary value of `x` and shifts the bits `y` places right; for
    example, `0b0011010110 >> 2` gives `0b0000110101`. The shaded part of the code
    is the machine-level program we execute:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过扩展取指阶段代码来测试执行阶段。以下Python代码提供了三条指令——将字面量加载到寄存器中，将内存内容加到寄存器中，以及停止。我们还使Python代码更加紧凑——例如，你可以在函数的返回语句中放置表达式。在这个例子中，我们返回两个值：`ir
    >> 8` 和 `ir & 0xFF`。操作`x >> y`将`x`的二进制值右移`y`位；例如，`0b0011010110 >> 2`给出`0b0000110101`。代码的阴影部分是我们执行的机器级程序：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output from this code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the Python term `elif` is short for *else if*. The preceding case
    says, “*Is the opcode stop. If not, is the opcode load. If not, is the opcode
    add.*” This allows for a sequence of tests. We discuss `elif` in more detail later.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python术语`elif`是*else if*的缩写。前面的情况说明，“*操作码是否为停止。如果不是，操作码是否为加载。如果不是，操作码是否为加法。*”这允许进行一系列测试。我们将在稍后更详细地讨论`elif`。
- en: Executing conditional instructions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行条件指令
- en: So far, we’ve looked at the structure of a CPU capable of executing programs
    in a purely *sequential* mode – that is, the computer can execute only a stream
    of instructions, one by one, in strict order. We introduced conditional behavior
    in the previous chapter, and now we will extend the CPU so that it can execute
    instructions, such as `BEQ Target` (a branch on a zero flag set to `Target`),
    that are able to execute instructions out of sequence.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已查看了一种能够以纯**顺序**模式执行程序的CPU结构——也就是说，计算机只能按严格顺序逐个执行指令流。我们在上一章中介绍了条件行为，现在我们将扩展CPU，使其能够执行诸如`BEQ
    Target`（在零标志设置为`Target`时的分支）之类的指令，这些指令能够执行非顺序指令。
- en: The computer in *Figure 3**.1* lacks a mechanism to make choices or repeat a
    group of instructions. To do this, the CPU must be able to execute *conditional
    branches* or *jumps*. The block diagram of *Figure 3**.5* shows the new address
    and data paths required by the CPU to implement conditional branches.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.1**中的计算机缺乏做出选择或重复一组指令的机制。为此，CPU必须能够执行**条件分支**或**跳转**。**图3.5**的框图显示了CPU实现条件分支所需的新地址和数据路径。'
- en: '![Figure 3.5 – Information paths in the CPU and conditional instructions](img/Figure_3.05_B19624.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![**图3.5**——CPU中的信息路径和条件指令](img/Figure_3.05_B19624.jpg)'
- en: Figure 3.5 – Information paths in the CPU and conditional instructions
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**图3.5**——CPU中的信息路径和条件指令'
- en: 'Three items have been added to our computer in *Figure 3**.5*. These are highlighted:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图3.5**中，我们向我们的计算机添加了三项内容。这些内容被突出显示：
- en: A **condition code** **register (CCR)**
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件码** **寄存器 (CCR)**'
- en: A path between the CCR and the control unit
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CCR和控制单元之间的路径
- en: A path between the address field of the instruction register and the program
    counter.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令寄存器的地址字段和程序计数器之间的路径。
- en: 'The *condition code register* or *processor status register* records the ALU
    state after each instruction has been executed, and updates the carry, negative,
    zero, and overflow flag bits. A conditional branch instruction interrogates the
    CCR’s flags. The CU then either executes the next instruction in sequence or branches
    to another instruction. Let’s look at the details of the conditional branch. The
    following is a reminder of the CCR bit functions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**条件码寄存器**或**处理器状态寄存器**记录了每个指令执行后的ALU状态，并更新进位、负数、零和溢出标志位。条件分支指令会查询CCR的标志。CU随后要么按顺序执行下一条指令，要么跳转到另一条指令。让我们看看条件分支的细节。以下是对CCR位功能的提醒：'
- en: C = Carry:  A carry occurs when an operation in n bits yields an n+1 bit result
    (e.g., when your car odometer winds round from 999...9 to 000...0). In 8-bit computer
    terms, this is when 11111111 + 1 = 0000000 carry 1.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z = Zero:   This is set if the last operation generated a zero result.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'N = Negative: This is set if the last result generated a negative result in
    2s complement arithmetic – that is, set if the most significant bit of a word
    is 1 (for example, 00101010 is positive and 10101010 is negative when the number
    is viewed as a two’s complement value).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'V = Overflow: This is set if the last operation resulted in an arithmetic overflow,
    which occurs in two’s complement arithmetic if the result is outside its allowable
    range. In this text, we generally don’t implement the V-flag for the sake of simplicity.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The condition code register is connected to the control unit, enabling an instruction
    to interrogate it. For example, some instructions test whether an operation yielded
    a positive result, whether the carry bit was set, or whether an arithmetic overflow
    occurred. We need a mechanism that does one thing if the result of the test is
    `true` and does another thing if the result of the test is `false`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The final modification included in *Figure 3**.5* is the addition of a path
    between the operand field (i.e., the target address) of the instruction register
    and the program counter. It’s this feature that enables the computer to respond
    to the result of its interrogation of the CCR.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: A *conditional branch* instruction such as **branch on carry set (BCS)** tests
    the carry bit of the CCR, and if the bit tested is clear, the next instruction
    is obtained from memory in the normal way. If the bit tested is set, the next
    instruction is obtained from the location whose *target address* is in the instruction
    register. In the preceding description, we said that a branch is made if a bit
    of the CCR is set; equally, a branch can be made if the bit is clear (branches
    can also be made on the combined state of several CCR bits).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Branch operations can be expressed in register-transfer language in the following
    form:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Typical machine-level conditional operations expressed in RTL are as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Branch on carry clear (jump to the target address if the carry bit in the CCR
    is 0)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BCC target: IF [C] = 0 THEN [PC]** **←** **[IR**address**]**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Branch on equal (jump to the target address if the Z bit in the CCR is 1)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BEQ target: IF [Z] = 1 THEN [PC]** **←** **[IR**address**]**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Both these actions have an `ELSE` condition, which is the default `[PC]` ← `[PC]
    +` `1`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a conditional branch in assembly language is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The final step in extending the computer architecture is the introduction of
    data paths to permit literals to be loaded into a register – that is, to load
    a register with a number that is in the instruction rather than from memory. The
    z-bit can be confusing. The z-bit is set to 1 if a result yields zero, and it’s
    set to 0 if the result is not zero.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展计算机体系结构的最后一步是引入数据路径，允许将字面量加载到寄存器中——也就是说，将一个数字加载到寄存器中，这个数字在指令中而不是从内存中。z 位可能会令人困惑。如果结果为零，则
    z 位设置为 1，如果结果不为零，则设置为 0。
- en: Dealing with literal operands
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理字面量操作数
- en: 'Computer instructions such as `ADD` r0,`abc` refer to an operand somewhere
    within the CPU’s memory. Sometimes, we want to use an instruction such as ADD
    r0,#12, where the source operand supplies the *actual value* of the data being
    referred to by the opcode part of the instruction – in this case, 12\. Although
    the symbol `#` appears as part of the operand when this instruction is written
    in mnemonic form, the assembler uses a different opcode code for the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `ADD r0,`abc`` 这样的计算机指令指的是 CPU 内存中的某个操作数。有时，我们想要使用像 `ADD r0,#12` 这样的指令，其中源操作数提供了指令操作码部分所引用数据的
    *实际值*——在这种情况下，12。尽管当这个指令以助记符形式编写时，符号 `#` 出现在操作数部分，但汇编器使用不同的操作码代码。
- en: '`ADD`  r0`,#literal` and `ADD`  r0`,address`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD r0,#literal` 和 `ADD r0,address`。'
- en: The instruction `ADD`  r0`,#12` is defined in `RTL` as [r0] ← [r0] + 12.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 指令 `ADD r0,#12` 在 `RTL` 中定义为 [r0] ← [r0] + 12.
- en: Note that we use two conventions for literals. One is `ADD r0,`#`12` and the
    other is `ADD`L `r0,12`. This matches typical instruction sets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用两种字面量的约定。一种是 `ADD r0,#12`，另一种是 `ADDL r0,12`。这符合典型的指令集。
- en: '*Figure 3**.6* shows that an additional data path is required between the operand
    field of the IR and the data register and ALU to deal with literal operands. *Figure
    3**.6* includes three general-purpose registers, `r0`, `r1`, and `r2`. In principle,
    there is nothing stopping us from adding any number of registers. However, the
    number of internal registers is limited by the number of bits available to specify
    a register in the instruction. As you can see, three data buses, `A`, `B`, and
    `C`, are used to transfer data between the registers and ALU.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.6* 显示，在 IR 的操作数字段和数据寄存器以及 ALU 之间需要额外的数据路径来处理字面量操作数。*图 3.6* 包含三个通用寄存器，`r0`、`r1`
    和 `r2`。原则上，我们无法添加任何数量的寄存器。然而，内部寄存器的数量受指令中指定寄存器所需位数的限制。正如你所看到的，三个数据总线 `A`、`B` 和
    `C` 用于在寄存器和 ALU 之间传输数据。'
- en: 'The structure of *Figure 3**.6* can implement instructions with more complex
    addressing modes than the simple direct (absolute) addressing we have used so
    far. Consider `MOV` r1`,[r0]`, which copies the contents of the memory location
    whose address is in `r0`. Here, `r0` is a pointer to the actual data. This instruction
    can be implemented by the following sequence of micro-operations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3.6* 的结构可以实现比我们迄今为止使用的简单直接（绝对）寻址更复杂的寻址模式。考虑 `MOV r1,[r0]`，它复制了地址在 `r0` 中的内存位置的值。在这里，`r0`
    是实际数据的指针。这个指令可以通过以下微操作序列来实现：'
- en: '[PRE12]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This sequence has been simplified because, as you can see from *Figure 3**.6*,
    there is no direct path between register `r0` and the MBR. You would have to put
    the contents of r0 onto bus A, pass the contents of bus A through the ALU to bus
    C, and then copy bus C to the MAR.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列已经被简化，因为，正如你从 *图 3.6* 中看到的，寄存器 `r0` 和 MBR 之间没有直接路径。你将不得不将 r0 的内容放到总线 A 上，通过
    ALU 将总线 A 的内容传递到总线 C，然后将总线 C 复制到 MAR。
- en: '![Figure 3.6 – Modifying the CPU to deal with literal operands](img/Figure_3.06_B19624.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 修改 CPU 以处理字面量操作数](img/Figure_3.06_B19624.jpg)'
- en: Figure 3.6 – Modifying the CPU to deal with literal operands
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 修改 CPU 以处理字面量操作数
- en: 'Let’s extend our Python code to include both literal operations and conditional
    operations. The following Python code implements a load register with literal
    instruction, an add/subtract, a conditional branch on zero, and a stop. Here,
    we use `LDRL` to indicate a literal, rather than prefixing the literal with #.
    The program to be executed is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们扩展我们的 Python 代码，包括字面量操作和条件操作。以下 Python 代码实现了一个加载寄存器的字面量指令、加/减操作、零条件分支和停止。在这里，我们使用
    `LDRL` 来表示字面量，而不是在字面量前加 #。要执行的程序如下：'
- en: '| **Address** | **Mnemonic** | **Instruction** | **Binary code** | **Note**
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **地址** | **助记符** | **指令** | **二进制代码** | **备注** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | `LDRL` r0`,9` | load `r0` with the literal `9` | 0001`00001001` | `[r0]`
    ← `9` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| 1 | `SUB` r0`,7` | subtract mem`[7]` from `r0` | `0`011`00000111` | `[r0]`
    ← `[r0] –` `mem[7]` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| 2 | `BEQ` 6 | branch on zero to 6 | `0`100`00000110` | if `z = 1 [PC] ← 6`
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| 3 | `STOP` | top execution | 1111`00000000` |  |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| 4 |  |  |  |  |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| 5 |  |  |  |  |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| 6 | `STOP` | top execution | 1111`00000000` |  |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: Table 3.4 – Caption
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: To implement a load register, we simply move the literal in the instruction
    to the register. The subtraction tests the result and sets the zero-status bit,
    `z`, to `1` if the result is `0` and `0` if it is not. The conditional branch
    tests the z-bit and loads the pc with the literal from the instruction if `z =`
    `1`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output from this Python code is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We load the literal `9` into `r0`, subtract the contents of memory location
    `7` (which contains `9`), and then branch to location `6` if the result was `0`.
    And that’s what happens.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Having described the structure of a computer, the next step is to look at the
    instructions that are executed by a computer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The machine-level instruction
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having described how a computer works, we now take a closer look at the computer.
    We are interested in what an instruction does and what resources it needs (i.e.,
    data locations or constants). A low-level computer operation (i.e., machine code
    or assembly language) operates on binary data in memory or registers. Although
    computers have become millions of times faster over the decades, the nature of
    the low-level instruction has hardly changed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Many first-generation microprocessors (e.g., 8080, 6800, Z80, and 6502) of the
    1970s and 1980s used 8-bit instructions that had to be chained together to create
    a more practical instruction – for example, 8-bit microprocessors provide 16-bit
    instructions by chaining together two consecutive 8-bit instructions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The second generation of microprocessors, such as Intel’s 8086 and Motorola’s
    68000, had 16-bit instructions. These too were chained together to create sufficiently
    long instructions to perform all the necessary operations. Indeed, the 68000 actually
    chained up to five consecutive 16-bit words to create a gigantic 80-bit instruction.
    Modern high-performance microprocessors (e.g., ARM, MIPS, and RISC-V) have 32-bit
    or 64-bit instructions that provide a full instruction set without the need to
    chain consecutive instructions. The CISC approach to chaining instructions together
    to increase the number of opcodes was a great idea at the time. However, it reduces
    performance by making it difficult to execute instructions in parallel because
    a computer does not know where the boundaries lie between instructions until they
    have been decoded.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, we will take a brief look at the concept of multi-length
    instruction sets.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Instruction types and formats
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will describe the type of primitive operations computers perform. First,
    a surprise. How many different instructions does a computer need? I mean, how
    many does it need to solve any problem that can be solved by a computer, today,
    tomorrow, and at any point in the future? The remarkable answer is one. Yes, you
    can solve any problem with the permutations of one single instruction.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将描述计算机执行的基本操作类型。首先，一个惊喜。计算机需要多少种不同的指令？我的意思是，它需要多少种来解决问题，这些问题今天、明天以及未来任何时刻都可以通过计算机解决？惊人的答案是只有一个。是的，你可以通过一个单一指令的排列来解决任何问题。
- en: 'According to Wikipedia, the `SBNZ a,b,c,d` instruction *(“subtract and branch
    if not equal to zero”*) subtracts the contents at address `a` from the contents
    at address `b`, stores the result at address `c`, and then, if the result is not
    `0`, transfers control to address `d` (if the result is equal to zero, the execution
    proceeds to the next instruction in sequence). Expressed in RTL, the `SBNZ` instruction
    is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，`SBNZ a,b,c,d` 指令（“如果非零则减去并分支”）从地址 `a` 的内容减去地址 `b` 的内容，将结果存储在地址 `c`，然后，如果结果不是
    `0`，则将控制权转移到地址 `d`（如果结果是零，则执行顺序中的下一个指令）。用 RTL 表达，`SBNZ` 指令如下：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All computation can be done using this single instruction alone. In practice,
    such a computer would be impossibly inefficient and impractical. However, it hints
    that a large and complex set of instructions is not necessarily required to build
    a computer. Most computers today have a relatively modest number of instructions.
    However, some computer designers now create optimized special-purpose instruction
    set enhancements for specific applications (e.g., graphics, signal processing,
    and AI).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的计算都可以使用这个单一指令来完成。实际上，这样的计算机将是不可能的低效和不切实际的。然而，它暗示了一个庞大而复杂的指令集并不是构建计算机的必要条件。今天的大多数计算机都有相对有限的指令数量。然而，一些计算机设计师现在为特定应用（例如，图形、信号处理和人工智能）创建优化的专用指令集增强。
- en: From the first computer to today’s chips with over 10 billion transistors, computers
    have had instruction sets that include the following three classes of operation.
    *Table 3.3* gives the name of the instruction group, an example of an operation
    in Python, and a typical assembly language instruction.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一台计算机到今天拥有超过 1000 亿个晶体管的芯片，计算机的指令集包括以下三个操作类别。*表 3.3* 给出了指令组的名称、Python 中的操作示例以及典型的汇编语言指令。
- en: '| **Instruction Group** | **Typical** **Python Code** | **Assembly Language**
    |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **指令组** | **典型** **Python 代码** | **汇编语言** |'
- en: '| --- | --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Arithmetic and logical | `c = (a + b) * c` | `ADD` `,r2,r3` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 算术和逻辑 | `c = (a + b) * c` | `ADD` `,r2,r3` |'
- en: '| Data movement | `x = y` | `MOV` `,r2` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 数据移动 | `x = y` | `MOV` `,r2` |'
- en: '| Conditional | `if x == 4: y = 7` | `BEQ next` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | `if x == 4: y = 7` | `BEQ next` |'
- en: Table 3.5 – Instruction classes
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.5 – 指令类别
- en: The TC1 that we are going to design has a 32-bit instruction and can provide
    up to 232 = 4,294,967,296 unique instructions. In practice, the instruction provides
    memory addresses, numerical constants (i.e., literals), and register numbers,
    which means that the number of unique instructions you can define is a lot smaller.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要设计的 TC1 有 32 位指令，可以提供高达 2^32 = 4,294,967,296 个独特的指令。实际上，指令提供内存地址、数值常数（即，字面量）和寄存器编号，这意味着你可以定义的独特指令的数量要小得多。
- en: TC1 has a 32-bit instruction but only a 16-bit data word. This arrangement makes
    it easier to design and understand the computer, and you can load a 16-bit data
    word with a single 32-bit instruction. Computers with 32-bit instructions and
    data have to use convoluted methods to load 32-bit data words, as we shall see
    when we introduce the ARM.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: TC1 有 32 位指令，但只有 16 位数据字。这种配置使得设计和理解计算机更容易，你可以用单个 32 位指令加载一个 16 位数据字。具有 32 位指令和数据的计算机必须使用复杂的加载方法来加载
    32 位数据字，正如我们将在介绍 ARM 时看到的那样。
- en: It may seem strange that I allow a binary number to be specified as either `0b1101`
    or `%1101`, and I allow hexadecimal numbers to be formatted as `0x1AC` or `$1AC`.
    I did this for two reasons. The first is that I was brought up in a Motorola world
    where the `%` and `$` prefixes were used, but now I live in a C world where the
    `0b` and `0x` prefixes are used. Habit makes `%` and `$` more natural for me.
    Secondly, I want to show you that you can choose your own formats and conventions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: TC1’s instruction set is designed for simplicity rather than computational elegance.
    The instruction set is realistic in terms of the concepts it involves but not
    in terms of its implementation. For our purposes, we have given all instructions
    in identical formats. In a real computer, there are usually several classes of
    instruction, each with its own format. By having a single format, we can simplify
    instruction decoding and execution.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: A 32-bit instruction set is used by many high-performance microprocessors and
    is ideal for demonstration and teaching purposes. Typically, computers use the
    same size for data elements as they do for instructions. TC1 uses 32-bit instructions
    but 16-bit data elements because it is easier for students to read and manipulate
    16-bit values than 32-bit values (modifying the TC1 computer to operate with 32-bit
    data would be a very easy task).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: In order to write a machine-level program for TC1, you would have to hand-code
    each instruction into a 32-bit binary sequence. This is easy to do, but it’s horribly
    tedious. We have also designed a simple assembler that allows you to write instructions
    in assembly language form. The TC1 assembler translates an instruction in the
    form `ADD`r7`,r2,r3` into a binary string such as `000000111101001100000000000000000`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Normally, an assembler is a separate piece of code from a simulator. You provide
    the assembler with a *source file* (in text format), and the assembler creates
    a *binary code file* that the simulator executes. The TC1 assembler is part of
    the simulator, so you don’t have to worry about creating binary files for the
    simulator.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: We have made the TC1 assembler as simple as possible to reduce the level of
    complexity and keep the final Python program reasonably short. It would take a
    lot more high-level language code to write a comprehensive assembler. This assembler
    performs no error-checking on the source program (i.e., it doesn’t detect an error
    when you mistype something). It supports the use of symbolic values for variables
    and addresses – that is, you can write `BEQ loop` rather than `BEQ 7`, where the
    symbolic name `loop` labels line number `7`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The TC1 assembler allows you to enter numbers in decimal, binary, or hexadecimal
    formats – for example, you can write `LDRL` r0`,255, LDRL` r0`,0xFF, or LDRL`
    r0`,%11111111`. The operation `LDRL` means, “*load a register with a literal (i.e.,
    an actual) value*.” In each case, the instruction puts the binary value for `255`
    in register `r0`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: All computers operate on data that is either in memory or in one of a few on-chip
    registers. Typically, a computer has between `2` and `32` on-chip registers. The
    TC1 computer has eight registers, `r0` to `r7`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'Computer instructions have many different formats, depending on the architecture
    of the computer. The two fundamental formats are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: CISC-style operations allow general instructions to access memory (e.g., `ADD`
    r3`,1200` means, add the contents of memory location 1,200 to register 3)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RISC-style: All data-processing operations are between registers (e.g., `ADD`
    r1`,r2,r3`), and the only memory accesses are *load a register from memory and
    store a register* *in memory*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical assembly language instruction formats that we will use in our first
    computer are as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **Mnemonic** | **Action** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| Two address | `MOV`r0`,r1` | Copy the contents of register `r1` to register
    `r0` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| Three address | `ADD`r0`,r1,r2` | Add the contents of register `r1` to `r2`
    put the result in `r0` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| Literal | `ADDL` r0`,r1,24` | Add literal `24` to `r1` and put the result
    in `r0` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| Branch | `BEQ``5` | If z-bit set, jump to instruction at address `5` |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| Load register indirect | `LDRI`r0`,[r1,10]` | Load `r0` with the contents
    of memory at address `r1 +` `10` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: There is no universal assembly language format, and conventions differ from
    assembler to assembler (even for the same machine). For example, one assembly
    language might use the format `MOV` r1`,r2` to load `r1` with `r2`, and the other
    might use it to load `r2` with `r1` – that is, the destination can be on the left
    or the right. I put the destination for operands on the left, which appears to
    be the more common convention. I also put the destination in bold font as a reminder.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a program that adds together the first 10 integers is shown
    in the following code snippet in a hypothetical assembly language. This is not
    the most efficient way of writing this fragment of code; it’s just intended as
    a demonstration. The version of the TC1 assembler we design here accepts uppercase
    or lowercase characters, and either a space or a comma can be used as a separator
    – for example, you can happily write the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`lOOp aDdL r1` `R2,r3 or`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`Loop` `ADDL R1,r2,R3.`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following example of TC1 assembly language. Note that I use `@`
    to indicate a comment field because that is the standard for the ARM assembly
    language, which we will introduce later. We will continue to use the `#` symbol
    for comments in Python.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: CISC and RISC
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we use the terms RISC and CISC repeatedly. These two terms are
    vital to the understanding of a modern computer. They describe two different approaches
    to the implementation of a computer. The early 1980s saw the CISC versus RISC
    war when two different architectures competed for the computing market. The term
    **complex instruction set computer (CISC)** is analogous to the term *analog watch*.
    When the digital watch was invented, watches with moving hands suddenly became
    analog watches in order to distinguish them from digital watches. Similarly, the
    term *complex instruction set computer* didn’t exist until it was coined to contrast
    with the new **reduced instruction set** **computer (RISC)**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: From the moment computers were invented, they just grew. As technology advanced,
    new features were just bolted onto existing computers. Someone once said that
    if the aircraft had developed like the computer, every jumbo jet would have had
    a 1903 Wright Flyer at its core. This approach wasn’t cost-effective because technology
    had changed so dramatically that the design of computers needed to be reconsidered.
    In particular, memory capacity had grown exponentially, and the cost per bit had
    plummeted. Similarly, the 8- and 16-bit wordlengths gave way to the 32- and 64-bit
    instruction sets. Doing things the old way was not efficient.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'First- and second-generation microprocessors were *accumulator*-based. They
    applied operations to an accumulator on the processor and a memory location. Instructions
    were called *one-and-a-half addresses* because they had a memory address and an
    accumulator address (since there were only a few accumulators, they were jokingly
    referred to as having “*half an address*”). To perform `C = A + B` (where `A`,
    `B`, and `C` are memory addresses), you would have to write the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Passing all data through the accumulator creates a bottleneck. Because computer
    speed increased faster than memory speed, programmers wanted to keep as much data
    on-chip as possible.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'The RISC solution adopted a *register-to-register* architecture. The only operations
    permitted on memory are the transfer of data between a register and memory. Instead
    of having one or two accumulators, RISC processors have 16 or 32 registers. The
    preceding code on a RISC processor can be typically represented by the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All data movement is between memory and a register, and data-processing operations
    apply only to registers. Instructions have three operands.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: RISC computers introduced other enhancements, such as overlapping the execution
    of instructions (called *pipelining*). Many in the 1980s expected Intel’s CISC
    computers to die out. They didn’t. Intel cleverly incorporated RISC features into
    its CISC processors. AMD designed a RISC architecture that took Intel’s CISC instructions
    and translated them into a sequence of RISC commands before executing them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, CISC processors have instruction sets that perform operations
    between an operand in memory and one in a register. All RISC data-processing operations
    take place between operands in registers. The only memory operations RISC processors
    permit are *loading a register from memory and storing a register* *in memory*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Two ways of representing literals
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assemblers differ in how they represent instructions because assemblers developed
    rapidly over a few short years in competitive industries. Each manufacturer designed
    an assembler for their own microprocessors. Some adopted a left-to-right convention
    with the destination operand on the right, and some adopted a right-to-left convention
    with the destination operand on the right. Consequently, one manufacturer’s `mov
    a,b` meant `a ← b`, and another’s meant `b ← a`. Similarly, mnemonics were also
    unstandardized – for example, `MOVE, MOV`, and `LDA` all define a copy operation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Since the assembler is just a human-readable version of machine code, it doesn’t
    actually matter how we represent an instruction. It’s the binary code that gets
    executed, irrespective of how we represent it in text form. However, from a teaching
    and learning perspective, the variations in conventions are a nuisance. Consider
    the representation of a literal value in an instruction.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Some assemblers represent a literal by using a special instruction – for example,
    ADDr1`,r2,r3` for a three-register addition, and `ADDL r1,r2,24` for a literal
    operand. Other assemblers use the *same* mnemonic in both cases but prefix the
    literal by a symbol to indicate that it’s a literal operation – for example, `ADD
    r1,r2,#25`. Some assemblers use `#` to indicate a literal and others use `%`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: In this text, we’ve used the `ADDL` convention in the design of some simulators,
    but we will use the `#` convention when we introduce the ARM processor because
    that’s used by ARM assemblers. In retrospect, if I were writing this book again,
    I think I might have been tempted to use only one representation, the `#` symbol.
    However, by using `ADD` and `ADDL`, I was able to simplify the Python code because
    the *decision point* between register and literal operands was made when examining
    the mnemonic, not when examining the literal.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this key chapter, we introduced the von Neumann computer with its `fetch-execute`
    cycle, where an instruction is read from memory, decoded, and executed in a two-phase
    operation. It is precisely these actions that we will learn to simulate in later
    chapters in order to build a computer in software. We have looked at the flow
    of information as an instruction is executed. The model of the computer we introduced
    here is the traditional model and does not take into account current technology
    that executes multiple instructions in a pipeline.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the instruction format and described how it has several fields
    – for example, the opcode that defines the operation and the data required by
    the operation (e.g., addresses, literals, and register numbers). You will eventually
    be able to design your own instructions (thereby defining the computer’s instruction
    set architecture) and create a computer that will execute these instructions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: While describing the operation of a von Neumann computer, we introduced sufficient
    Python code to show the direction we are heading in and hint at how simulation
    can be carried out.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin to look more closely at the concept of an
    interpreter that reads a machine-level instruction and carries out its intended
    actions.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
