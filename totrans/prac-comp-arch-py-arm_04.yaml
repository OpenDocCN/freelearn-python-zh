- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Flow in a Computer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how a computer executes an instruction. We have
    to understand how a computer operates internally before we can simulate its behavior
    in Python. We will also introduce the concept of a computer instruction (the smallest
    operation that it can be commanded to perform) and show you what a computer instruction
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: What is a computer? How does it work? What does it do? We will answer these
    questions by demonstrating how a computer can be designed using Python, and how
    programs can be run on this simulated computer. Here, we are interested only in
    how a computer behaves at the machine level – that is, the type of operations
    it carries out. We are not concerned with the internal design of the computer
    or how the computer is implemented electronically (i.e., the circuits used to
    build a computer).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The instruction set architecture (ISA)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Von Neumann architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An assembly-level program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The machine-level instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: The Instruction Architecture Level (ISA)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show how a computer can be described in different ways
    and explain that this book is about computers from the point of view of their
    instruction sets and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The term *computer* means different things to different people. To an engineer,
    a computer is a collection of circuits that perform a certain function; to a pilot,
    it’s a machine that flies an aircraft from one airport to another and can land
    it in thick fog.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 3.1* demonstrates the hierarchy of computer languages and structures.
    At the top you have the actual application for which the computer is used. At
    this level, the application may be a user-selected program (flight simulator),
    or it may be a program that runs on an embedded system (e.g., an ATM). Communication
    with that application is universal and independent of the actual computer on which
    the application runs.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Level** | **Realization** | **Universality** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. Application | Word, Excel, Photoshop, and flight sim | Universal |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. High-level language | Python, Java, C++ | Universal |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. Assembly language | ADD r1,r2, and r3 | Computer family |'
  prefs: []
  type: TYPE_TB
- en: '| 4\. Binary (machine code) | `00111010111100001010101110001010` binary | Computer
    family |'
  prefs: []
  type: TYPE_TB
- en: '| 5\. Circuit (microprocessor) | Gates, adders, counters, and memory | Specific
    family member |'
  prefs: []
  type: TYPE_TB
- en: '| 6\. Silicon | The physical silicon chip | Specific chip |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – The hierarchy of computer languages and systems
  prefs: []
  type: TYPE_NORMAL
- en: Below the application level, you have the high-level language used to build
    the application. This language may be Python, Java, C++, and so on. High-level
    languages were designed to enable programmers to build applications that run on
    different types of computers. For example, a program written in Python will run
    on any machine for which a Python interpreter or compiler is available. Before
    the introduction of high-level languages, you had to design the application for
    each specific computer.
  prefs: []
  type: TYPE_NORMAL
- en: Most computers are currently unable to directly execute high-level languages.
    Each computer has a native language that is understood by a computer family (e.g.,
    Intel Core, Motorola 68K, ARMv4, and MIPS). These languages are related to the
    structure of the computer and its hardware, which is expressed by a computer’s
    ISA. This level is represented by two layers in *Table 3.1*, *assembly language
    and* *machine code*.
  prefs: []
  type: TYPE_NORMAL
- en: The layer below the high-level language is the assembly language level, which
    is a human representation of the computer’s binary machine code. People can’t
    remember or easily manipulate strings of 1s and 0s. Assembly language is a textual
    version of machine code. For example, the assembly language operation `ADD` A`,B,C`
    means add `B` to `C` and put the result in `A (i.e., A = B + C)` and might be
    represented in machine code as `00110101011100111100001010101010`.
  prefs: []
  type: TYPE_NORMAL
- en: The *machine code* layer is the binary code that the computer actually executes.
    In the PC world, a machine-code program has the `.exe` file extension because
    it can be *executed* by the computer. All computers execute binary code, although
    this layer is different for each type of computer – for example, Intel Core, ARM,
    and MIPS are three computer families, and each has its own machine code.
  prefs: []
  type: TYPE_NORMAL
- en: Although the assembly language layer is a representation of the machine code
    layer, there is a difference between these two layers. The assembly language layer
    includes facilities to help a programmer write programs, such as the ability to
    define variable names and to link independently written modules into a single
    machine-code program.
  prefs: []
  type: TYPE_NORMAL
- en: Below the machine-code layer are the electronic circuits, which are generically
    called microprocessors, or just chips. This is the hardware that companies such
    as Intel make, and it’s this hardware that reads programs from memory and executes
    them. In general, this layer cannot be programmed or modified any more than you
    can change the number of cylinders in your car’s engine.
  prefs: []
  type: TYPE_NORMAL
- en: Today, some digital systems do have circuits that can be modified electronically
    – that is, it is possible for the circuits of a computer to be restructured by
    changing the routing of signals through a circuit called a **field programmable
    gate array (FPGA)**. The FPGA contains a very large number of gates and special-purpose
    circuit blocks that can be interconnected by programming. An FPGA can be programmed
    to perform dedicated applications such as signal processing in medical or aerospace
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: At the electronic circuit level, it’s possible to have different versions of
    the same set of circuits. For example, a microprocessor can be realized using
    7 nm or 14 nm device technology (these figures express the basic size of components
    on the chip, and smaller is better). The two circuits may be operationally identical
    in every way, but one version may be faster, cheaper, more reliable, or use less
    power than the other.
  prefs: []
  type: TYPE_NORMAL
- en: This book is about assembly language and machine code layers, and the layers
    in *Table 3.1* allow us to write programs that are executed by a computer. By
    the end of this book, you will be able to design your own machine code, your own
    assembly language, and your own computer.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1940s and 1950s, all programming was done in assembly language (or even
    machine code). Not today. Writing assembly language programs is tedious and very
    challenging. Computer scientists have created high-level languages such as C++,
    Java, Python, and Fortran. These languages were developed to allow programmers
    to write programs in a near-English language that expresses more powerful ideas
    than assembly language. For example, in Python, you can print the text `"Hello
    World"` on the screen with the instruction `print("Hello World.")`. If you wanted
    to do that in assembly language, you would have to write out, say, 100 individual
    machine-level instructions. Moreover, the Python version will run on all computers,
    but the machine-level version has to be written for each specific computer type.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level language’s secret is the *compiler*. You write a program in a
    high-level language and then compile it to the machine code of the specific computer
    you want to run it on. You may come across the term *interpreter*, which performs
    the same function as a compiler. A compiler translates an entire high-level language
    program into machine code, whereas an interpreter performs the translation line
    by line, executing each line as it is interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code in assembly language is not popular today (outside academia). However,
    it has the advantage that (in principle) you can write optimized code that runs
    faster than compiled code.
  prefs: []
  type: TYPE_NORMAL
- en: A principal theme of this book is *learning by doing*. We will explain what
    a computer is, introduce the instructions it executes, and then show how it can
    be built (i.e., simulated) in a high-level language. We will call the program
    we are going to construct **TC1 (Teaching Computer 1)**. This program will execute
    the assembly language of a hypothetical computer. You will be able to write a
    program in assembly language, and the TC1 program will read the instructions and
    execute them as if they were running on a real TC1 computer.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you can execute instructions one by one and observe
    their outcomes v – that is, you can read the values of data in registers and memory
    as the program runs. The purpose of this computer is not to perform useful computing
    functions but to show what instructions look like and how they are executed.
  prefs: []
  type: TYPE_NORMAL
- en: This computer demonstrates how instructions are executed and how to use assembly
    language. Moreover, you can modify the instruction set of the computer to create
    your own special-purpose instructions. You can remove instructions, add new instructions,
    extend instructions, and even change the format of instructions. TC1 was designed
    to enable students that study computer architecture to understand instruction
    formats, instruction decoding, and instruction complexity. It is also very helpful
    to understand addressing modes (i.e., how data is located in memory), such as
    pointer-based addressing. We will discuss these topics in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: TC1 has several useful facilities that are not present in conventional computer
    instruction sets. For example, you can directly input data into the computer from
    the keyboard, and you can load random numbers into memory. This allows you to
    create data for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to introduce the prototype computer, the so-called von Neumann
    machine, which was created in the 1940s and 1950s and became the template for
    most modern computers. In reality, there’s been quite a departure from the pure
    von Neumann architecture, but we still tend to use the term to distinguish between
    other classes of computers (e.g., analog computers, neural networks, and quantum
    computers).
  prefs: []
  type: TYPE_NORMAL
- en: ISAs – the Naming of Parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we introduce the structure of a computer, we need to introduce several
    terms that you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0` or `1`. You can set a bit to `0`, to `1`, or toggle it (flip it over).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`8`, `16`, `32`, or `64`. In general, the word is the basic unit of data that
    the computer operates on. An instruction such as `ADD` a`,b,c` executed on a 64-bit
    computer would add the 64-bits of word `b` to the 64-bits or word `c` and put
    the 64-bit result in word `a`. The `a`, `b`, and `c` variables refer to storage
    locations in either memory or registers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instruction**: A machine-level instruction is the most primitive operation
    that a programmer can specify and defines a single action carried out by the computer.
    Even more primitive level operations may exist on the silicon, but a programmer
    cannot directly access these. Instructions largely fall into three classes – data
    movement that copies data from one place to another, arithmetic and logical operations
    that process data, and instruction sequence commands that determine the order
    in which instructions are carried out (necessary to implement decisions of the
    form *if this, then* *do that*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Immediate access memory**: This is often just called memory or RAM or DRAM
    by many programmers. It is where programs and data are stored during the execution
    of a program. The term *random access memory* today means the same thing. However,
    strictly speaking, the term *random* indicates that the access time for a memory
    element chosen at random is the same for every element (unlike, say, magnetic
    tape, where the access time depends on where data is on the tape).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`8` to `64` registers on a chip, it requires only `3` to `6` bits to specify
    a given register, rather than the `32` or `64` bits typically used to access a
    memory location. Most computer operations act on the contents of registers rather
    than the main memory. There is no universal convention for the naming of registers.
    In this chapter, we will generally use for register names – for example, `INC
    r3` increments the contents of register `r3` by `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`32` bits or `64` bits long. However, 8- and 16-bit computers are frequently
    used in embedded control applications (e.g., toys, TVs, washing machines, and
    automobiles).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD` a`,b,5` where `5` is a literal, then it means, add the `5` integer to
    `b`. Some computers use a `#` to indicate a literal – for example, `ADD` a`,b,#12`
    means, add the number `12` to the contents of memory location `b`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A` and then ends up at `B` – simplicity itself. In computing, the term *move*
    indicates that something that was at `A` ends up at `B`, as well – that is, it
    is now in both `A` and `B`. In other words, programmers use *move* to mean *copy*.
    If you *move* data from a register to memory, the data remains in the register
    and is *copied* to memory. We will introduce the prototype computer in the following
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step is to introduce the notion of the von Neumann computer, which
    can be regarded as the grandfather of most modern computers. The mathematician
    von Neumann was one of the authors of *The First Draft Report on the EDVAC* in
    1945, which characterized the structure of the digital computer.
  prefs: []
  type: TYPE_NORMAL
- en: The von Neumann architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prototype computer is often called a stored program von Neumann machine.
    It has a program in memory that is executed instruction by instruction sequentially.
    Moreover, the program is stored in the same memory as the data that the computer
    operates on. This structure is named in honor of one of the pioneers of computing,
    John von Neumann. Once you understand the von Neumann machine, you understand
    all computers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.1* illustrates a simplified von Neumann machine that contains three
    basic elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A memory that holds the program and any data used by the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of registers that each holds one word of data (in *Figure 3**.1*, there
    is one register, `r0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **arithmetic and logic unit (ALU)** that performs all data processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The von Neumann architecture](img/Figure_3.01_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The von Neumann architecture
  prefs: []
  type: TYPE_NORMAL
- en: The memory contains instructions to be executed. Both data and instructions
    are stored in binary form, although we will often show operations in assembly
    language form for ease of reading. Each instruction is read from memory, decoded,
    and interpreted (i.e., executed). The principal simplification of *Figure 3**.1*
    is the lack of a means of executive conditional operations (i.e., `if… then`).
    We will fix that later.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.1* looks complicated. It’s not. We’ll explain its operation step
    by step. Once we see how a computer operates in principle, we can look at how
    it may be implemented in software. We describe the operation of a very simple,
    so-called *one-and-a-half* address machine, whose instructions have two operands
    – one in memory and one in a register. Instructions are written in the form `ADD`
    B`,A`, which adds `A` to `B` and puts the result in `B`. Either `A` or `B` must
    be in a register. Both operands may be in registers. The term *one-and-a-half
    address* machine is a comment about the fact that the memory address is 16 to
    32 bits and selects one of millions of memory locations, whereas the register
    address is typically 2 to 6 bits and selects only one of a small number of registers.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of introducing the computer all at once, we will build up a CPU step
    by step. This approach helps demonstrate how an instruction is executed because
    the development of the computer broadly follows the sequence of events taking
    place during the execution of an instruction. Real computers don’t execute an
    instruction from start to finish. Today’s computers *overlap* the execution of
    instructions. As soon as one instruction is fetched from memory, the next instruction
    is fetched before the previous instruction has completed its execution. This mechanism
    is called *pipelining* and is a major aspect of a modern computer’s organization.
    Pipelining is analogous to the automobile production line, where computer instructions
    are executed in stages so that several instructions may be in the process of being
    executed at the same time. We will begin with the address paths that are used
    to locate the next instruction to be executed. In this book, we will not cover
    pipelining because it is a factor or implementation and not an instruction set
    design.
  prefs: []
  type: TYPE_NORMAL
- en: The address path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An address is a number representing the location of an item of data within memory.
    *Figure 3**.2* shows only the address paths needed to read an instruction from
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The CPU’s address paths](img/Figure_3.02_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The CPU’s address paths
  prefs: []
  type: TYPE_NORMAL
- en: An address path is a data highway that moves addresses between the CPU and memory.
    The address tells memory where we want to read data from, or where we want to
    store it. For example, the instruction `ADD` r0`,234` indicates the operation
    *read the contents of memory location 234, add them to the contents of register
    r0, and then put the result in r0*. *Figure 3**.2* omits the data paths required
    to execute instructions to avoid clutter.
  prefs: []
  type: TYPE_NORMAL
- en: There are three types of information flow in a computer – address, data, and
    control. Data comprises the instructions, constants, and variables stored in memory
    and registers. Control paths comprise the signals that trigger events, provide
    clocks, and determine the flow of data and addresses throughout the computer.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the instruction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the CPU can execute an instruction, the instruction must be brought from
    the computer’s memory. We begin our description of the way in which a program
    is executed with the CPU’s *program counter* (also called *instruction pointer*
    or *location counter*). The expression *program counter* is a misnomer. The program
    counter doesn’t count programs or anything else, but instead contains the address
    of the next instruction in memory to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The program counter *points* to the next instruction to be executed. If, for
    example, `[PC] = 1234` (i.e., the `PC` contains the number `1234`), the next instruction
    to be executed will be found in memory location `1234`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetching an instruction begins with the contents of the program counter being
    moved to the memory address register (i.e., `[MAR]` ← `[PC]`). Once the contents
    of the program counter have been transferred to the memory address register, the
    contents of the program counter are incremented and moved back to the program
    counter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[PC]` ← `[PC] +` 1.'
  prefs: []
  type: TYPE_NORMAL
- en: The PC increment is `1` because the next instruction is one location on. Real
    computers are normally byte-addressed – that is, the bytes are numbered sequentially
    `0, 1, 2, 3 …` Modern computers have 32- or 64-bit data words – that is, 4- or
    8-byte words. Consequently, real computers increment the PC by 4 or 8 after each
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: After this operation, the program counter points to the *next* instruction while
    the current instruction is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The **memory address register (MAR)** holds the address of the location in the
    memory into which data is written in a write cycle, or from which data is read
    in a read cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a *memory read cycle* is performed, the contents of the memory location
    specified by the MAR are read from the memory and transferred to the **memory
    buffer register (MBR)**. We can represent this read operation in RTL terms as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We interpret the `[[MAR]]` expression as *the contents of the memory whose address
    is given by the contents of the MAR*. The memory buffer register is a temporary
    holding place for data received from memory in a read cycle, or for data to be
    transferred to memory in a write cycle. Some texts refer to the MBR as the **memory
    data register (MDR).** At this point in the execution of an instruction, the MBR
    contains the bit pattern of the instruction to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction is next moved from the MBR to the **instruction register (IR)**,
    where it is divided into two fields. A *field* is part of a word in which the
    bits are grouped together into a logical entity – for example, a person’s name
    can be divided into two fields, the given name and the family name. One field
    in the IR contains the *operation code* (opcode) that tells the CPU what operation
    is to be carried out. The other field, called the *operand field*, contains the
    address of the data to be used by the instruction. The operand field can also
    provide a constant to be employed by the operation code when immediate or literal
    addressing is used – that is, when the operand is an actual (i.e., literal) value
    and not an address. For our current purposes, the register address is considered
    to be part of the instruction. Later, we will introduce computers with multiple
    registers. Real computers divide the instruction into more than two fields – for
    example, there may be two or three register-select fields.
  prefs: []
  type: TYPE_NORMAL
- en: The **control unit (CU)** takes the opcode from the instruction register, together
    with a stream of clock pulses, and generates signals that control all parts of
    the CPU. The time between individual clock pulses is typically in the range 0.3
    ns to 100 ns (i.e., 3 x 10-10 to 10-7 s), corresponding to frequencies of 3.3
    GHz to 10 MHz. The CU is responsible for moving the contents of the program counter
    into the MAR, executing a read cycle, and moving the contents of the MBR to the
    IR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instructions are executed in a two-phase *fetch-execute cycle*. During the
    *fetch phase*, the instruction is read from memory and decoded by the control
    unit. The fetch phase is followed by an *execute phase*, in which the control
    unit generates all the signals necessary to execute the instruction. The following
    RTL notation describes the sequence of operations that take place in a fetch phase.
    `FETCH` is a label that serves to indicate a particular line in the sequence of
    operations. The notation IRopcode means the operation-code field of the instruction
    register. We use `#` to indicate a comment in Python and `@` in assembly language
    to be compatible with ARM’s convention. Some assemblers use a semicolon to indicate
    a comment field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of how we can code the fetch cycle as a function
    in Python, together with the code needed to test it. We define a 12-bit instruction
    with a 4-bit opcode and an 8-bit address. The memory has 16 locations, and we
    load the first two with dummy values to test the program. The Python expression
    p >> q takes the binary value p and shifts it q places right, and `&` performs
    a logical `AND`. We will discuss this in more detail later. For example, 0110`00001010
    >> 8` becomes 0110\. This extracts the opcode. Similarly, `0b011011111010 & 0b111111111111
    = 0b000000001010` to extract the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the numeric `0b011000001010` value is expressed in binary
    form by the `0b` prefix. Similarly, the `0xFF` notation indicates a number in
    hexadecimal form – that is, `255` in decimal or `11111111` in binary form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is tested by calling it twice with `opCode,address = fetch(mem)`.
    Python lets us receive the two returned parameters, opcode and address, on one
    line. Note how closely the Python code follows the RTL. In practice, you would
    not write this code. We don’t need the MAR and MBR registers. I included them
    to help model the hardware. We can simply write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The CPU’s data paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having sorted out the fetch phase, let’s see what else we need to execute instructions.
    *Figure 3**.3* adds data paths to the CPU of *Figure 3**.2*, plus an address path
    from the address field of the instruction register to the memory address register.
    Other additions are a data register, `r0`, and an ALU that does the actual computing.
    The operations it performs are typically arithmetic (add, subtract, multiply,
    and divide) and logical (`AND`, `OR`, `EOR`, and shift left or right).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The CPU’s address and data paths](img/Figure_3.03_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The CPU’s address and data paths
  prefs: []
  type: TYPE_NORMAL
- en: The data register, `r0`, holds temporary results during a calculation. You need
    a data register (i.e., an accumulator) because *dyadic* operations with two operands
    such as `ADD` use one operand specified by the instruction, and the other register
    is the contents of a data register. `ADD` `,P` adds the contents of the memory
    location, `P`, to the contents of the general-purpose register, `r0`, and deposits
    the sum in the data register, destroying one of the original operands. The arrangement
    of *Figure 3**.3* has one general-purpose data register that we’ve called `r0`.
    A real processor, the ARM, has 16 registers, `r0` to `r15` (although not all of
    them are general-purpose data registers).
  prefs: []
  type: TYPE_NORMAL
- en: Typical data movement instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All computers have data move instructions that transfer (i.e., copy) data from
    one place to another. These are the simplest instructions because they don’t involve
    processing data. Data movement instructions vary from computer to computer. Here,
    we will provide a few typical examples that will help you follow the examples
    in this chapter. Note that we will use different conventions in this text. For
    example, we will sometimes prefix a literal by `#` (e.g., `ADD` `,#6`) and sometimes
    add the suffix `L` to the instruction (e.g., `ADDL` r1`,6`). This is because there
    are several standards/conventions in use in computing, and they vary from computer
    to computer. The following are simply generic examples of code. Note the duplication
    of load a literal. Some processors use `move` and some use `load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mnemonic** | **Example** | **Name** | **RTL** | **Comment** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MOV` | `MOV`  r1`,r4` | move register | [r1] ← [r4] | Copy register r4 to
    register r1 |'
  prefs: []
  type: TYPE_TB
- en: '| `MOVL` | `MOVL` r1`,5` | move literal | [r1] ← 5 | Copy the integer 5 to
    register r1 |'
  prefs: []
  type: TYPE_TB
- en: '| `LDR` | `LDR`  r3`,12` | load register | [r3] ← [12] | Load r3 with contents
    of memory location 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `LDRL` | `LDRL` r0`,13` | load literal | [r0] ← 13 | Load register r0 with
    the integer 13 |'
  prefs: []
  type: TYPE_TB
- en: '| `STR` | `STR`  `r4,`8 | store register | [8] ← [r4] | Store contents of r4
    in memory location 8 |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – Typical data movement instructions
  prefs: []
  type: TYPE_NORMAL
- en: Data processing instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at a typical data-processing operation. We can represent an `ADD`
    r0`,X` instruction with the RTL expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The ALU is the workhorse of the CPU because it performs all calculations. Arithmetic
    and logical operations are applied to the contents of a data register and the
    contents of a data register or the MBR. The output of the ALU is fed back to the
    data register or to the MBR.
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental difference between arithmetic and logical operations is that
    logical operations don’t generate a carry when bit ai of word `A` and bit bi of
    `B` are operated upon. *Table 3.2* provides examples of typical arithmetic and
    logical operations.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Class** | **Typical mnemonic** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Addition | Arithmetic | ADD (a = b + c) |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | Arithmetic | SUB (a = b - c) |'
  prefs: []
  type: TYPE_TB
- en: '| Negation | Arithmetic | NEG (a = -b) |'
  prefs: []
  type: TYPE_TB
- en: '| Multiplication | Arithmetic | MUL (a = b * c) |'
  prefs: []
  type: TYPE_TB
- en: '| Division | Arithmetic | DIV (a = b / c) |'
  prefs: []
  type: TYPE_TB
- en: '| Divide by 2 | Arithmetic | ASR (a = b / 2) |'
  prefs: []
  type: TYPE_TB
- en: '| Multiply by 2 | Arithmetic | ASL (a = b * 2) |'
  prefs: []
  type: TYPE_TB
- en: '| AND | Logical | AND (a = b & c) |'
  prefs: []
  type: TYPE_TB
- en: '| OR | Logical | OR (a = b &#124; c) |'
  prefs: []
  type: TYPE_TB
- en: '| NOT | Logical | NOT (a = !b) |'
  prefs: []
  type: TYPE_TB
- en: '| EOR | Logical | EOR (a = b ⊕ c) |'
  prefs: []
  type: TYPE_TB
- en: '| Shift left | Logical | LSL (shift all bits left a = b << 1) |'
  prefs: []
  type: TYPE_TB
- en: '| Shift right | Logical | LSR (shift all bits right a = b >> 1) |'
  prefs: []
  type: TYPE_TB
- en: Table 3.3 – Typical arithmetic and logical operations
  prefs: []
  type: TYPE_NORMAL
- en: A logical shift treats an operand as a string of bits that are moved left or
    right. An arithmetic shift treats a number as a signed 2s complement value and
    propagates the sign bit during a right shift (i.e., the sign bit is replicated
    and duplicated). Most of these operations are implemented by computers such as
    the 68K, Intel Core, and ARM.
  prefs: []
  type: TYPE_NORMAL
- en: Another look at the data flow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s have another look at data flow in a computer to cement the basic concepts
    together. In *Figure 3**.4*, we have a computer that supports operations involving
    three registers (a hallmark of computers such as the ARM). Here, we have three
    registers, `r1`, `r2`, and `r3`. The block labeled *adder* is part of the ALU
    and serves to add two numbers to produce a sum. Instruction `LDR` r2`,X` loads
    the contents of memory address `X` into register `r2`. Instruction `STR r1,`Z
    stores the contents of register `r1` in memory address `Z`.
  prefs: []
  type: TYPE_NORMAL
- en: The instruction `ADD` r1`,r2,r3` reads the contents of registers `r2` and `r3`,
    adds them together, and deposits the result in register, `r1`. Since it’s not
    clear which register is the destination register (i.e., the result), we use a
    bold font to highlight the destination operand, which is normally the leftmost
    operand.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.4* shows several fundamental components of a computer. This is,
    essentially, the same as the more detailed structures we used to demonstrate the
    fetch/execute cycle. Here, we are interested in data flow into and out of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Details of the von Neumann machine](img/Figure_3.04_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Details of the von Neumann machine
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of interest are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A clock that generates timing pulses. All operations take place when triggered
    by the clock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interpreter or control unit that takes an instruction, together with a stream
    of clock pulses, and converts it into the actions required to perform the required
    operation. In *Figure 3**.4*, the interpreter routes the contents of registers
    `r2` and `r3` to the adder, makes the adder add the two values together, and then
    routes the result from the adder to the destination register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program in memory. Data is loaded from memory into registers `r2` and `r2`.
    Then, `r2` and `r3` are added together and the result is put in `r3`. Finally,
    the contents of `r3` are moved to memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve covered the basic structure of a computer and introduced some
    instructions, the next step is to look at a complete program that carries out
    a specific function.
  prefs: []
  type: TYPE_NORMAL
- en: An assembly-level program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having developed our computer a little further, in this section, we will show
    how a simple program is executed. Assume that this computer doesn’t provide three-address
    instructions (i.e., you can’t specify an operation with three registers and/or
    memory addresses) and we want to implement the high-level language operation `Z
    = X + Y`. Here, the *plus* symbol means arithmetic addition. An assembly language
    program that carries out this operation is given in the following code block.
    Remember that `X`, `Y`, and `Z` are symbolic names referring to the *locations*
    of the variables in memory. Logically, the store operation should be written `STR
    Z,r2`, with the destination operand on the left just like other instructions.
    By convention, it is written as `STR r2,Z`, with the source register on the left.
    This is a quirk of programming history:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDR``,X``r2` with the contents of memory location `X`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD``,Y``Y` to data register `r2`'
  prefs: []
  type: TYPE_NORMAL
- en: '`STR``r2,`Z`r2` in memory location `Z`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Eight-bit computers had a one-address machine, requiring a rather cumbersome
    sequence of operations just to carry out the simple act of adding two numbers.
    If we had a computer with a three-address format, we could have written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD``,X,Y`Add the contents of X to the contents of Y and put the result in
    Z'
  prefs: []
  type: TYPE_NORMAL
- en: Three-address machines are *potentially* faster than one-address machines because
    they can do in one instruction things that take other machines three operations.
    Unfortunately, it is a factor of technological development that on-chip registers
    are faster than DRAM, and computer designers try to keep data in registers on-chip
    as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: The reality is more complicated. Accessing memory is slow compared to accessing
    registers. This is a property of the hardware. Consequently, it is more efficient
    to keep data in registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way in which the CPU operates can best be seen by examining the execution
    of, say, `ADD` r2`,Y` in terms of register-transfer language. In the following
    code block, we describe the operations carried out during the fetch and execute
    phases of an `ADD` r2`,Y` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Operations sharing the same line are executed simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: During the fetch phase, the opcode is fed to the control unit by CU ← [IRopcode]
    and used to generate all the internal signals required to place the ALU in its
    addition mode. When the ALU is programmed for addition, it adds together the data
    at its two input terminals to produce a sum at its output terminals.
  prefs: []
  type: TYPE_NORMAL
- en: Operations of the form `[PC]` ← `[MAR]` or `[r2]` ← `[r2] + [MBR]` are often
    referred to as *microinstructions*. Each assembly-level instruction (e.g., `MOV,
    ADD`) is executed as a series of microinstructions. Microinstructions are the
    province of the computer designer. In the 1970s, some machines were user-microprogrammable
    – that is, you could define your own instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the execute phase by extending the fetch phase code. The following
    Python code provides three instructions – load a register with a literal, add
    memory contents to the register, and stop. We have also made the Python code more
    compact – for example, you can put expressions in a function’s return statement.
    In this example, we return two values: `ir >> 8` and `ir & 0xFF`. The operation
    `x >> y` takes the binary value of `x` and shifts the bits `y` places right; for
    example, `0b0011010110 >> 2` gives `0b0000110101`. The shaded part of the code
    is the machine-level program we execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the Python term `elif` is short for *else if*. The preceding case
    says, “*Is the opcode stop. If not, is the opcode load. If not, is the opcode
    add.*” This allows for a sequence of tests. We discuss `elif` in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: Executing conditional instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve looked at the structure of a CPU capable of executing programs
    in a purely *sequential* mode – that is, the computer can execute only a stream
    of instructions, one by one, in strict order. We introduced conditional behavior
    in the previous chapter, and now we will extend the CPU so that it can execute
    instructions, such as `BEQ Target` (a branch on a zero flag set to `Target`),
    that are able to execute instructions out of sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The computer in *Figure 3**.1* lacks a mechanism to make choices or repeat a
    group of instructions. To do this, the CPU must be able to execute *conditional
    branches* or *jumps*. The block diagram of *Figure 3**.5* shows the new address
    and data paths required by the CPU to implement conditional branches.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Information paths in the CPU and conditional instructions](img/Figure_3.05_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Information paths in the CPU and conditional instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'Three items have been added to our computer in *Figure 3**.5*. These are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: A **condition code** **register (CCR)**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path between the CCR and the control unit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path between the address field of the instruction register and the program
    counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *condition code register* or *processor status register* records the ALU
    state after each instruction has been executed, and updates the carry, negative,
    zero, and overflow flag bits. A conditional branch instruction interrogates the
    CCR’s flags. The CU then either executes the next instruction in sequence or branches
    to another instruction. Let’s look at the details of the conditional branch. The
    following is a reminder of the CCR bit functions:'
  prefs: []
  type: TYPE_NORMAL
- en: C = Carry:  A carry occurs when an operation in n bits yields an n+1 bit result
    (e.g., when your car odometer winds round from 999...9 to 000...0). In 8-bit computer
    terms, this is when 11111111 + 1 = 0000000 carry 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Z = Zero:   This is set if the last operation generated a zero result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'N = Negative: This is set if the last result generated a negative result in
    2s complement arithmetic – that is, set if the most significant bit of a word
    is 1 (for example, 00101010 is positive and 10101010 is negative when the number
    is viewed as a two’s complement value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'V = Overflow: This is set if the last operation resulted in an arithmetic overflow,
    which occurs in two’s complement arithmetic if the result is outside its allowable
    range. In this text, we generally don’t implement the V-flag for the sake of simplicity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The condition code register is connected to the control unit, enabling an instruction
    to interrogate it. For example, some instructions test whether an operation yielded
    a positive result, whether the carry bit was set, or whether an arithmetic overflow
    occurred. We need a mechanism that does one thing if the result of the test is
    `true` and does another thing if the result of the test is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The final modification included in *Figure 3**.5* is the addition of a path
    between the operand field (i.e., the target address) of the instruction register
    and the program counter. It’s this feature that enables the computer to respond
    to the result of its interrogation of the CCR.
  prefs: []
  type: TYPE_NORMAL
- en: A *conditional branch* instruction such as **branch on carry set (BCS)** tests
    the carry bit of the CCR, and if the bit tested is clear, the next instruction
    is obtained from memory in the normal way. If the bit tested is set, the next
    instruction is obtained from the location whose *target address* is in the instruction
    register. In the preceding description, we said that a branch is made if a bit
    of the CCR is set; equally, a branch can be made if the bit is clear (branches
    can also be made on the combined state of several CCR bits).
  prefs: []
  type: TYPE_NORMAL
- en: 'Branch operations can be expressed in register-transfer language in the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Typical machine-level conditional operations expressed in RTL are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Branch on carry clear (jump to the target address if the carry bit in the CCR
    is 0)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BCC target: IF [C] = 0 THEN [PC]** **←** **[IR**address**]**'
  prefs: []
  type: TYPE_NORMAL
- en: Branch on equal (jump to the target address if the Z bit in the CCR is 1)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**BEQ target: IF [Z] = 1 THEN [PC]** **←** **[IR**address**]**'
  prefs: []
  type: TYPE_NORMAL
- en: Both these actions have an `ELSE` condition, which is the default `[PC]` ← `[PC]
    +` `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a conditional branch in assembly language is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The final step in extending the computer architecture is the introduction of
    data paths to permit literals to be loaded into a register – that is, to load
    a register with a number that is in the instruction rather than from memory. The
    z-bit can be confusing. The z-bit is set to 1 if a result yields zero, and it’s
    set to 0 if the result is not zero.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with literal operands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computer instructions such as `ADD` r0,`abc` refer to an operand somewhere
    within the CPU’s memory. Sometimes, we want to use an instruction such as ADD
    r0,#12, where the source operand supplies the *actual value* of the data being
    referred to by the opcode part of the instruction – in this case, 12\. Although
    the symbol `#` appears as part of the operand when this instruction is written
    in mnemonic form, the assembler uses a different opcode code for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD`  r0`,#literal` and `ADD`  r0`,address`.'
  prefs: []
  type: TYPE_NORMAL
- en: The instruction `ADD`  r0`,#12` is defined in `RTL` as [r0] ← [r0] + 12.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use two conventions for literals. One is `ADD r0,`#`12` and the
    other is `ADD`L `r0,12`. This matches typical instruction sets.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3**.6* shows that an additional data path is required between the operand
    field of the IR and the data register and ALU to deal with literal operands. *Figure
    3**.6* includes three general-purpose registers, `r0`, `r1`, and `r2`. In principle,
    there is nothing stopping us from adding any number of registers. However, the
    number of internal registers is limited by the number of bits available to specify
    a register in the instruction. As you can see, three data buses, `A`, `B`, and
    `C`, are used to transfer data between the registers and ALU.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of *Figure 3**.6* can implement instructions with more complex
    addressing modes than the simple direct (absolute) addressing we have used so
    far. Consider `MOV` r1`,[r0]`, which copies the contents of the memory location
    whose address is in `r0`. Here, `r0` is a pointer to the actual data. This instruction
    can be implemented by the following sequence of micro-operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This sequence has been simplified because, as you can see from *Figure 3**.6*,
    there is no direct path between register `r0` and the MBR. You would have to put
    the contents of r0 onto bus A, pass the contents of bus A through the ALU to bus
    C, and then copy bus C to the MAR.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Modifying the CPU to deal with literal operands](img/Figure_3.06_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Modifying the CPU to deal with literal operands
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s extend our Python code to include both literal operations and conditional
    operations. The following Python code implements a load register with literal
    instruction, an add/subtract, a conditional branch on zero, and a stop. Here,
    we use `LDRL` to indicate a literal, rather than prefixing the literal with #.
    The program to be executed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Mnemonic** | **Instruction** | **Binary code** | **Note**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | `LDRL` r0`,9` | load `r0` with the literal `9` | 0001`00001001` | `[r0]`
    ← `9` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `SUB` r0`,7` | subtract mem`[7]` from `r0` | `0`011`00000111` | `[r0]`
    ← `[r0] –` `mem[7]` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `BEQ` 6 | branch on zero to 6 | `0`100`00000110` | if `z = 1 [PC] ← 6`
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `STOP` | top execution | 1111`00000000` |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 5 |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `STOP` | top execution | 1111`00000000` |  |'
  prefs: []
  type: TYPE_TB
- en: Table 3.4 – Caption
  prefs: []
  type: TYPE_NORMAL
- en: To implement a load register, we simply move the literal in the instruction
    to the register. The subtraction tests the result and sets the zero-status bit,
    `z`, to `1` if the result is `0` and `0` if it is not. The conditional branch
    tests the z-bit and loads the pc with the literal from the instruction if `z =`
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this Python code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We load the literal `9` into `r0`, subtract the contents of memory location
    `7` (which contains `9`), and then branch to location `6` if the result was `0`.
    And that’s what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Having described the structure of a computer, the next step is to look at the
    instructions that are executed by a computer.
  prefs: []
  type: TYPE_NORMAL
- en: The machine-level instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having described how a computer works, we now take a closer look at the computer.
    We are interested in what an instruction does and what resources it needs (i.e.,
    data locations or constants). A low-level computer operation (i.e., machine code
    or assembly language) operates on binary data in memory or registers. Although
    computers have become millions of times faster over the decades, the nature of
    the low-level instruction has hardly changed.
  prefs: []
  type: TYPE_NORMAL
- en: Many first-generation microprocessors (e.g., 8080, 6800, Z80, and 6502) of the
    1970s and 1980s used 8-bit instructions that had to be chained together to create
    a more practical instruction – for example, 8-bit microprocessors provide 16-bit
    instructions by chaining together two consecutive 8-bit instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The second generation of microprocessors, such as Intel’s 8086 and Motorola’s
    68000, had 16-bit instructions. These too were chained together to create sufficiently
    long instructions to perform all the necessary operations. Indeed, the 68000 actually
    chained up to five consecutive 16-bit words to create a gigantic 80-bit instruction.
    Modern high-performance microprocessors (e.g., ARM, MIPS, and RISC-V) have 32-bit
    or 64-bit instructions that provide a full instruction set without the need to
    chain consecutive instructions. The CISC approach to chaining instructions together
    to increase the number of opcodes was a great idea at the time. However, it reduces
    performance by making it difficult to execute instructions in parallel because
    a computer does not know where the boundaries lie between instructions until they
    have been decoded.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this book, we will take a brief look at the concept of multi-length
    instruction sets.
  prefs: []
  type: TYPE_NORMAL
- en: Instruction types and formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will describe the type of primitive operations computers perform. First,
    a surprise. How many different instructions does a computer need? I mean, how
    many does it need to solve any problem that can be solved by a computer, today,
    tomorrow, and at any point in the future? The remarkable answer is one. Yes, you
    can solve any problem with the permutations of one single instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia, the `SBNZ a,b,c,d` instruction *(“subtract and branch
    if not equal to zero”*) subtracts the contents at address `a` from the contents
    at address `b`, stores the result at address `c`, and then, if the result is not
    `0`, transfers control to address `d` (if the result is equal to zero, the execution
    proceeds to the next instruction in sequence). Expressed in RTL, the `SBNZ` instruction
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All computation can be done using this single instruction alone. In practice,
    such a computer would be impossibly inefficient and impractical. However, it hints
    that a large and complex set of instructions is not necessarily required to build
    a computer. Most computers today have a relatively modest number of instructions.
    However, some computer designers now create optimized special-purpose instruction
    set enhancements for specific applications (e.g., graphics, signal processing,
    and AI).
  prefs: []
  type: TYPE_NORMAL
- en: From the first computer to today’s chips with over 10 billion transistors, computers
    have had instruction sets that include the following three classes of operation.
    *Table 3.3* gives the name of the instruction group, an example of an operation
    in Python, and a typical assembly language instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction Group** | **Typical** **Python Code** | **Assembly Language**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic and logical | `c = (a + b) * c` | `ADD` `,r2,r3` |'
  prefs: []
  type: TYPE_TB
- en: '| Data movement | `x = y` | `MOV` `,r2` |'
  prefs: []
  type: TYPE_TB
- en: '| Conditional | `if x == 4: y = 7` | `BEQ next` |'
  prefs: []
  type: TYPE_TB
- en: Table 3.5 – Instruction classes
  prefs: []
  type: TYPE_NORMAL
- en: The TC1 that we are going to design has a 32-bit instruction and can provide
    up to 232 = 4,294,967,296 unique instructions. In practice, the instruction provides
    memory addresses, numerical constants (i.e., literals), and register numbers,
    which means that the number of unique instructions you can define is a lot smaller.
  prefs: []
  type: TYPE_NORMAL
- en: TC1 has a 32-bit instruction but only a 16-bit data word. This arrangement makes
    it easier to design and understand the computer, and you can load a 16-bit data
    word with a single 32-bit instruction. Computers with 32-bit instructions and
    data have to use convoluted methods to load 32-bit data words, as we shall see
    when we introduce the ARM.
  prefs: []
  type: TYPE_NORMAL
- en: It may seem strange that I allow a binary number to be specified as either `0b1101`
    or `%1101`, and I allow hexadecimal numbers to be formatted as `0x1AC` or `$1AC`.
    I did this for two reasons. The first is that I was brought up in a Motorola world
    where the `%` and `$` prefixes were used, but now I live in a C world where the
    `0b` and `0x` prefixes are used. Habit makes `%` and `$` more natural for me.
    Secondly, I want to show you that you can choose your own formats and conventions.
  prefs: []
  type: TYPE_NORMAL
- en: TC1’s instruction set is designed for simplicity rather than computational elegance.
    The instruction set is realistic in terms of the concepts it involves but not
    in terms of its implementation. For our purposes, we have given all instructions
    in identical formats. In a real computer, there are usually several classes of
    instruction, each with its own format. By having a single format, we can simplify
    instruction decoding and execution.
  prefs: []
  type: TYPE_NORMAL
- en: A 32-bit instruction set is used by many high-performance microprocessors and
    is ideal for demonstration and teaching purposes. Typically, computers use the
    same size for data elements as they do for instructions. TC1 uses 32-bit instructions
    but 16-bit data elements because it is easier for students to read and manipulate
    16-bit values than 32-bit values (modifying the TC1 computer to operate with 32-bit
    data would be a very easy task).
  prefs: []
  type: TYPE_NORMAL
- en: In order to write a machine-level program for TC1, you would have to hand-code
    each instruction into a 32-bit binary sequence. This is easy to do, but it’s horribly
    tedious. We have also designed a simple assembler that allows you to write instructions
    in assembly language form. The TC1 assembler translates an instruction in the
    form `ADD`r7`,r2,r3` into a binary string such as `000000111101001100000000000000000`.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, an assembler is a separate piece of code from a simulator. You provide
    the assembler with a *source file* (in text format), and the assembler creates
    a *binary code file* that the simulator executes. The TC1 assembler is part of
    the simulator, so you don’t have to worry about creating binary files for the
    simulator.
  prefs: []
  type: TYPE_NORMAL
- en: We have made the TC1 assembler as simple as possible to reduce the level of
    complexity and keep the final Python program reasonably short. It would take a
    lot more high-level language code to write a comprehensive assembler. This assembler
    performs no error-checking on the source program (i.e., it doesn’t detect an error
    when you mistype something). It supports the use of symbolic values for variables
    and addresses – that is, you can write `BEQ loop` rather than `BEQ 7`, where the
    symbolic name `loop` labels line number `7`.
  prefs: []
  type: TYPE_NORMAL
- en: The TC1 assembler allows you to enter numbers in decimal, binary, or hexadecimal
    formats – for example, you can write `LDRL` r0`,255, LDRL` r0`,0xFF, or LDRL`
    r0`,%11111111`. The operation `LDRL` means, “*load a register with a literal (i.e.,
    an actual) value*.” In each case, the instruction puts the binary value for `255`
    in register `r0`.
  prefs: []
  type: TYPE_NORMAL
- en: All computers operate on data that is either in memory or in one of a few on-chip
    registers. Typically, a computer has between `2` and `32` on-chip registers. The
    TC1 computer has eight registers, `r0` to `r7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computer instructions have many different formats, depending on the architecture
    of the computer. The two fundamental formats are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CISC-style operations allow general instructions to access memory (e.g., `ADD`
    r3`,1200` means, add the contents of memory location 1,200 to register 3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RISC-style: All data-processing operations are between registers (e.g., `ADD`
    r1`,r2,r3`), and the only memory accesses are *load a register from memory and
    store a register* *in memory*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Typical assembly language instruction formats that we will use in our first
    computer are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **Mnemonic** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Two address | `MOV`r0`,r1` | Copy the contents of register `r1` to register
    `r0` |'
  prefs: []
  type: TYPE_TB
- en: '| Three address | `ADD`r0`,r1,r2` | Add the contents of register `r1` to `r2`
    put the result in `r0` |'
  prefs: []
  type: TYPE_TB
- en: '| Literal | `ADDL` r0`,r1,24` | Add literal `24` to `r1` and put the result
    in `r0` |'
  prefs: []
  type: TYPE_TB
- en: '| Branch | `BEQ``5` | If z-bit set, jump to instruction at address `5` |'
  prefs: []
  type: TYPE_TB
- en: '| Load register indirect | `LDRI`r0`,[r1,10]` | Load `r0` with the contents
    of memory at address `r1 +` `10` |'
  prefs: []
  type: TYPE_TB
- en: There is no universal assembly language format, and conventions differ from
    assembler to assembler (even for the same machine). For example, one assembly
    language might use the format `MOV` r1`,r2` to load `r1` with `r2`, and the other
    might use it to load `r2` with `r1` – that is, the destination can be on the left
    or the right. I put the destination for operands on the left, which appears to
    be the more common convention. I also put the destination in bold font as a reminder.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a program that adds together the first 10 integers is shown
    in the following code snippet in a hypothetical assembly language. This is not
    the most efficient way of writing this fragment of code; it’s just intended as
    a demonstration. The version of the TC1 assembler we design here accepts uppercase
    or lowercase characters, and either a space or a comma can be used as a separator
    – for example, you can happily write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lOOp aDdL r1` `R2,r3 or`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Loop` `ADDL R1,r2,R3.`'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following example of TC1 assembly language. Note that I use `@`
    to indicate a comment field because that is the standard for the ARM assembly
    language, which we will introduce later. We will continue to use the `#` symbol
    for comments in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: CISC and RISC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we use the terms RISC and CISC repeatedly. These two terms are
    vital to the understanding of a modern computer. They describe two different approaches
    to the implementation of a computer. The early 1980s saw the CISC versus RISC
    war when two different architectures competed for the computing market. The term
    **complex instruction set computer (CISC)** is analogous to the term *analog watch*.
    When the digital watch was invented, watches with moving hands suddenly became
    analog watches in order to distinguish them from digital watches. Similarly, the
    term *complex instruction set computer* didn’t exist until it was coined to contrast
    with the new **reduced instruction set** **computer (RISC)**.
  prefs: []
  type: TYPE_NORMAL
- en: From the moment computers were invented, they just grew. As technology advanced,
    new features were just bolted onto existing computers. Someone once said that
    if the aircraft had developed like the computer, every jumbo jet would have had
    a 1903 Wright Flyer at its core. This approach wasn’t cost-effective because technology
    had changed so dramatically that the design of computers needed to be reconsidered.
    In particular, memory capacity had grown exponentially, and the cost per bit had
    plummeted. Similarly, the 8- and 16-bit wordlengths gave way to the 32- and 64-bit
    instruction sets. Doing things the old way was not efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'First- and second-generation microprocessors were *accumulator*-based. They
    applied operations to an accumulator on the processor and a memory location. Instructions
    were called *one-and-a-half addresses* because they had a memory address and an
    accumulator address (since there were only a few accumulators, they were jokingly
    referred to as having “*half an address*”). To perform `C = A + B` (where `A`,
    `B`, and `C` are memory addresses), you would have to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Passing all data through the accumulator creates a bottleneck. Because computer
    speed increased faster than memory speed, programmers wanted to keep as much data
    on-chip as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RISC solution adopted a *register-to-register* architecture. The only operations
    permitted on memory are the transfer of data between a register and memory. Instead
    of having one or two accumulators, RISC processors have 16 or 32 registers. The
    preceding code on a RISC processor can be typically represented by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All data movement is between memory and a register, and data-processing operations
    apply only to registers. Instructions have three operands.
  prefs: []
  type: TYPE_NORMAL
- en: RISC computers introduced other enhancements, such as overlapping the execution
    of instructions (called *pipelining*). Many in the 1980s expected Intel’s CISC
    computers to die out. They didn’t. Intel cleverly incorporated RISC features into
    its CISC processors. AMD designed a RISC architecture that took Intel’s CISC instructions
    and translated them into a sequence of RISC commands before executing them.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, CISC processors have instruction sets that perform operations
    between an operand in memory and one in a register. All RISC data-processing operations
    take place between operands in registers. The only memory operations RISC processors
    permit are *loading a register from memory and storing a register* *in memory*.
  prefs: []
  type: TYPE_NORMAL
- en: Two ways of representing literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assemblers differ in how they represent instructions because assemblers developed
    rapidly over a few short years in competitive industries. Each manufacturer designed
    an assembler for their own microprocessors. Some adopted a left-to-right convention
    with the destination operand on the right, and some adopted a right-to-left convention
    with the destination operand on the right. Consequently, one manufacturer’s `mov
    a,b` meant `a ← b`, and another’s meant `b ← a`. Similarly, mnemonics were also
    unstandardized – for example, `MOVE, MOV`, and `LDA` all define a copy operation.
  prefs: []
  type: TYPE_NORMAL
- en: Since the assembler is just a human-readable version of machine code, it doesn’t
    actually matter how we represent an instruction. It’s the binary code that gets
    executed, irrespective of how we represent it in text form. However, from a teaching
    and learning perspective, the variations in conventions are a nuisance. Consider
    the representation of a literal value in an instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Some assemblers represent a literal by using a special instruction – for example,
    ADDr1`,r2,r3` for a three-register addition, and `ADDL r1,r2,24` for a literal
    operand. Other assemblers use the *same* mnemonic in both cases but prefix the
    literal by a symbol to indicate that it’s a literal operation – for example, `ADD
    r1,r2,#25`. Some assemblers use `#` to indicate a literal and others use `%`.
  prefs: []
  type: TYPE_NORMAL
- en: In this text, we’ve used the `ADDL` convention in the design of some simulators,
    but we will use the `#` convention when we introduce the ARM processor because
    that’s used by ARM assemblers. In retrospect, if I were writing this book again,
    I think I might have been tempted to use only one representation, the `#` symbol.
    However, by using `ADD` and `ADDL`, I was able to simplify the Python code because
    the *decision point* between register and literal operands was made when examining
    the mnemonic, not when examining the literal.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this key chapter, we introduced the von Neumann computer with its `fetch-execute`
    cycle, where an instruction is read from memory, decoded, and executed in a two-phase
    operation. It is precisely these actions that we will learn to simulate in later
    chapters in order to build a computer in software. We have looked at the flow
    of information as an instruction is executed. The model of the computer we introduced
    here is the traditional model and does not take into account current technology
    that executes multiple instructions in a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the instruction format and described how it has several fields
    – for example, the opcode that defines the operation and the data required by
    the operation (e.g., addresses, literals, and register numbers). You will eventually
    be able to design your own instructions (thereby defining the computer’s instruction
    set architecture) and create a computer that will execute these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: While describing the operation of a von Neumann computer, we introduced sufficient
    Python code to show the direction we are heading in and hint at how simulation
    can be carried out.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin to look more closely at the concept of an
    interpreter that reads a machine-level instruction and carries out its intended
    actions.
  prefs: []
  type: TYPE_NORMAL
