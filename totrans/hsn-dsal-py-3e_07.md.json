["```py\n class MinHeap: \n        def __init__(self): \n            self.heap = [0] \n            self.size = 0 \n```", "```py\n def arrange(self, k):\n        while k // 2 > 0:\n            if self.heap[k] < self.heap[k//2]:\n                self.heap[k], self.heap[k//2] = self.heap[k//2], self.heap[k]\n            k //= 2 \n```", "```py\n while k // 2 > 0: \n```", "```py\n if self.heap[k] < self.heap[k//2]: \n            self.heap[k], self.heap[k//2] = self.heap[k//2], self.heap[k] \n```", "```py\n k //= 2 \n```", "```py\n def insert(self, item): \n        self.heap.append(item) \n        self.size += 1 \n        self.arrange(self.size) \n```", "```py\n h = MinHeap()\n    for i in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6): \n        h.insert(i) \n```", "```py\n print(h.heap) \n```", "```py\n[0, 1, 2, 5, 3, 6, 10, 7, 8, 4, 9] \n```", "```py\n def minchild(self, k):\n        if k * 2 + 1 > self.size:\n            return k * 2\n        elif self.heap[k*2] < self.heap[k*2+1]:\n            return k * 2\n        else:\n            return k * 2 + 1 \n```", "```py\n if k * 2 + 1 > self.size: \n            return k * 2 \n```", "```py\n elif self.heap[k*2] < self.heap[k*2+1]: \n            return k * 2 \n        else: \n            return k * 2 + 1 \n```", "```py\ndef sink(self, k):\n        while k * 2 <= self.size:\n            mc = self.minchild(k)\n            if self.heap[k] > self.heap[mc]:\n                self.heap[k], self.heap[mc] = self.heap[mc], self.heap[k]\n            k = mc \n```", "```py\n def sink(self, k): \n          while k*2 <= self.size: \n```", "```py\n mi = self.minchild(k) \n```", "```py\n if self.heap[k] > self.heap[mc]: \n                self.heap[k], self.heap[mc] = self.heap[mc], self.heap[k] \n```", "```py\n k = mc \n```", "```py\n def delete_at_root(self): \n        item = self.heap[1] \n        self.heap[1] = self.heap[self.size] \n        self.size -= 1 \n        self.heap.pop() \n        self.sink(1) \n        return item \n```", "```py\nself.heap[1] = self.heap[self.size] \n```", "```py\nh = MinHeap()\nfor i in (2, 3, 5, 7, 9, 10, 6):\n    h.insert(i)\nprint(h.heap)\nn = h.delete_at_root()\nprint(n)\nprint(h.heap) \n```", "```py\n[0, 2, 3, 5, 7, 9, 10, 6]\n2\n[0, 3, 6, 5, 7, 9, 10] \n```", "```py\n def delete_at_location(self, location):\n        item = self.heap[location]\n        self.heap[location] = self.heap[self.size]\n        self.size -= 1\n        self.heap.pop()\n        self.sink(location)\n        return item \n{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}:\n```", "```py\nh = MinHeap()  \nfor i in (4, 8, 7, 2, 9, 10, 5, 1, 3, 6):  \n    h.insert(i)    \nprint(h.heap)\n\nn = h.delete_at_location(2)\nprint(n)\nprint(h.heap) \n```", "```py\n[0, 1, 2, 5, 3, 6, 10, 7, 8, 4, 9]\n2\n[0, 1, 3, 5, 4, 6, 10, 7, 8, 9] \n```", "```py\n h = MinHeap() \n    unsorted_list = [4, 8, 7, 2, 9, 10, 5, 1, 3, 6] \n    for i in unsorted_list: \n        h.insert(i) \n    print(\"Unsorted list: {}\".format(unsorted_list)) \n```", "```py\n def heap_sort(self): \n            sorted_list = [] \n            for node in range(self.size): \n                n = self.delete_at_root() \n                sorted_list.append(n) \n            return sorted_list \n```", "```py\nprint(\"Unsorted list: {}\".format(unsorted_list))\nprint(\"Sorted list: {}\".format(h.heap_sort())) \n```", "```py\nUnsorted list: [4, 8, 7, 2, 9, 10, 5, 1, 3, 6]\nSorted list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] \n```", "```py\n# class for Node with data and priority\nclass Node:\n  def __init__(self, info, priority):\n    self.info = info\n    self.priority = priority \n```", "```py\n# class for Priority queue\nclass PriorityQueue:\n  def __init__(self):\n    self.queue = [] \n```", "```py\n def insert(self, node):        \n        if len(self.queue) == 0:\n            # add the new node\n            self.queue.append(node)\n        else:\n            # traverse the queue to find the right place for new node\n            for x in range(0, len(self.queue)):\n                # if the priority of new node is greater\n                if node.priority >= self.queue[x].priority:\n                    # if we have traversed the complete queue\n                    if x == (len(self.queue)-1):\n                        # add new node at the end\n                        self.queue.insert(x+1, node)\n                    else:\n                        continue\n                else:\n                    self.queue.insert(x, node)\n                    return True \n```", "```py\n def delete(self):\n        # remove the first node from the queue\n        x = self.queue.pop(0)\n        print(\"Deleted data with the given priority-\", x.info, x.priority)\n        return x \n```", "```py\n def show(self):\n        for x in self.queue:\n            print(str(x.info)+ \" - \"+ str(x.priority)) \n```", "```py\np = PriorityQueue()\np.insert(Node(\"Cat\", 13))\np.insert(Node(\"Bat\", 2))\np.insert(Node(\"Rat\", 1))\np.insert(Node(\"Ant\", 26))\np.insert(Node(\"Lion\", 25))\np.show()\np.delete() \n```", "```py\nRat – 1\nBat – 2\nCat – 13\nLion – 25\nAnt – 26\nDeleted data with the given priority- Rat 1 \n```", "```py\nclass PriorityQueueHeap:\n    def __init__(self):\n        self.heap = [()]\n        self.size = 0\n\n    def arrange(self, k):\n        while k // 2 > 0:\n            if self.heap[k][0] < self.heap[k//2][0]:\n                self.heap[k], self.heap[k//2] = self.heap[k//2], self.heap[k]\n            k //= 2\n\n    def insert(self,priority, item):\n        self.heap.append((priority, item))\n        self.size += 1\n        self.arrange(self.size)\n\n    def sink(self, k):\n        while k * 2 <= self.size:\n            mc = self.minchild(k)\n            if self.heap[k][0] > self.heap[mc][0]:\n                self.heap[k], self.heap[mc] = self.heap[mc], self.heap[k]\n            k = mc\n\n    def minchild(self, k):\n        if k * 2 + 1 > self.size:\n            return k * 2\n        elif self.heap[k*2][0] < self.heap[k*2+1][0]:\n            return k * 2\n        else:\n            return k * 2 + 1\n\n    def delete_at_root(self):\n        item = self.heap[1][1]\n        self.heap[1] = self.heap[self.size]\n        self.size -= 1\n        self.heap.pop()\n        self.sink(1)\n        return item \n```", "```py\nh = PriorityQueueHeap() \nh.insert(2, \"Bat\") \nh.insert(13,\"Cat\")\nh.insert(18, \"Rat\")\nh.insert(26, \"Ant\")\nh.insert(3, \"Lion\")\nh.insert(4, \"Bear\")\nh.heap \n```", "```py\n[(), (2, 'Bat'), (3, 'Lion'),  (4, 'Bear'),  (26, 'Ant'),  (13, 'Cat'),  (18, 'Rat')] \n```", "```py\nfor i in range(h.size):\n    n = h.delete_at_root()\n    print(n)\n    print(h.heap) \n```", "```py\n'Bat\n[(), (3, 'Lion'), (13, 'Cat'), (4, 'Bear'), (26, 'Ant'), (18, 'Rat')]\nLion\n[(), (4, 'Bear'), (13, 'Cat'), (18, 'Rat'), (26, 'Ant')]\nBear\n[(), (13, 'Cat'), (26, 'Ant'), (18, 'Rat')]\nCat\n[(), (18, 'Rat'), (26, 'Ant')]\nRat\n[(), (26, 'Ant')]\nAnt\n[()] \n```"]