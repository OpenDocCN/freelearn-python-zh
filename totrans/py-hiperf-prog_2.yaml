- en: Chapter 2. Fast Array Operations with NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy is the *de facto* standard for scientific computing in Python. It extends
    Python with a flexible multidimensional array that allows fast mathematical calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy works as a framework that allows coding complex operations using a concise
    syntax. The multidimensional array (`numpy.ndarray`) is internally based on C
    arrays: in this way, the developer can easily interface NumPy with existing C
    and FORTRAN code. NumPy constitutes a bridge between Python and the legacy code
    written using those languages.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to create and manipulate NumPy arrays. We
    will also explore the NumPy broadcasting feature to rewrite complex mathematical
    expressions in an efficient and succinct manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years a number of packages were developed to further increase
    the speed of NumPy. We will explore one of these packages, `numexpr`, that optimizes
    array expressions and takes advantage of multi-core architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NumPy is founded around its multidimensional array object, `numpy.ndarray`.
    NumPy arrays are a collection of elements of the same data type; this fundamental
    restriction allows NumPy to pack the data in an efficient way. By storing the
    data in this way NumPy can handle arithmetic and mathematical operations at high
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create NumPy arrays using the `numpy.array` function. It takes a list-like
    object (or another array) as input and, optionally, a string expressing its data
    type. You can interactively test the array creation using an IPython shell as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Every NumPy array has a data type that can be accessed by the `dtype` attribute,
    as shown in the following code. In the following code example, `dtype` is a 64-bit
    integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want those numbers to be treated as a `float` type of variable, we can
    either pass the `dtype` argument in the `np.array` function or cast the array
    to another data type using the `astype` method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an array with two dimensions (an array of arrays) we can initialize
    the array using a nested sequence, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The array created in this way has two dimensions—**axes** in NumPy''s jargon.
    Such an array is like a table that contains two rows and three columns. We can
    access the axes structure using the `ndarray.shape` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can also be reshaped, only as long as the product of the shape dimensions
    is equal to the total number of elements in the array. For example, we can reshape
    an array containing 16 elements in the following ways: (2, 8), (4, 4), or (2,
    2, 4). To reshape an array, we can either use the `ndarray.reshape` method or
    directly change the `ndarray.shape` attribute. The following code illustrates
    the use of the `ndarray.reshape` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this property you are also free to add dimensions of size one. You
    can reshape an array with 16 elements to (16, 1), (1, 16), (16, 1, 1), and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy provides convenience functions, shown in the following code, to create
    arrays filled with zeros, filled with ones, or without an initialization value
    (*empty*—their actual value is meaningless and depends on the memory state). Those
    functions take the array shape as a tuple and optionally its `dtype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our examples, we will use the `numpy.random` module to generate random floating
    point numbers in the (0, 1) interval. In the following code we use the `np.random`.`rand`
    function to generate an array of random numbers of shape (3, 3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, it is convenient to initialize arrays that have a similar shape
    to other arrays. Again, NumPy provides some handy functions for that purpose such
    as `zeros_like`, `empty_like`, and `ones_like`. These functions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Accessing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NumPy array interface is, on a shallow level, similar to Python lists.
    They can be indexed using integers, and can also be iterated using a `for` loop.
    The following code shows how to index and iterate an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to index an array in multiple dimensions. If we take a
    (3, 3) array (an array containing 3 triplets) and we index the first element,
    we obtain the first triplet shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can index the triplet again by adding the other index separated by a comma.
    To get the second element of the first triplet we can index using [0, 1], as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy allows you to slice arrays in single and multiple dimensions. If we index
    on the first dimension we will get a collection of triplets shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we slice the array with [0:2]. for every selected triplet we extract the
    first two elements, resulting in a (2, 2) array shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Intuitively, you can update values in the array by using both numerical indexes
    and slices. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indexing with the slicing syntax is fast because it doesn''t make copies of
    the array. In NumPy terminology it returns a *view* over the same memory area.
    If we take a slice of the original array and then change one of its values; the
    original array will be updated as well. The following code illustrates an example
    of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take a look at another example that shows how the slicing syntax can
    be used in a real-world scenario. We define an array `r_i`, shown in the following
    line of code, which contains a set of 10 coordinates (x, y); its shape will be
    (10, 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical operation is extracting the x component of each coordinate. In other
    words, you want to extract the items [0, 0], [1, 0], [2, 0], and so on, resulting
    in an array with shape (10,). It is helpful to think that the first index is *moving*
    while the second one is *fixed* (at 0). With this in mind, we will slice every
    index on the first axis (the moving one) and take the first element (the fixed
    one) on the second axis, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the following expression of code will keep the first index
    fixed and the second index moving, giving the first (x, y) coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Slicing all the indexes over the last axis is optional; using `r_i[0]` has the
    same effect as `r_i[0, :]`.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy allows to index an array by using another NumPy array made of either integer
    or Boolean values—a feature called *fancy indexing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you index with an array of integers, NumPy will interpret the integers as
    indexes and will return an array containing their corresponding values. If we
    index an array containing 10 elements with `[0, 2, 3]`, we obtain an array of
    size 3 containing the elements at positions 0, 2 and 3\. The following code gives
    us an illustration of this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use fancy indexing on multiple dimensions by passing an array for each
    dimension. If we want to extract the elements [0, 2] and [1, 3] we have to pack
    all the indexes acting on the first axis in one array, and the ones acting on
    the second axis in another. This can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use normal lists as index arrays, but not tuples. For example
    the following two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you use a tuple, NumPy will interpret the following statement as
    an index on multiple dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The index arrays are not required to be one-dimensional; we can extract elements
    from the original array in any shape. For example we can select elements from
    the original array to form a (2, 2) array shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The array slicing and fancy indexing features can be combined. For example,
    this is useful if we want to swap the x and y columns in a coordinate array. In
    the following code, the first index will be running over all the elements (a slice),
    and for each of those we extract the element in position 1 (the y) first and then
    the one in position 0 (the x):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When the index array is a boolean there are slightly different rules. The Boolean
    array will act like a *mask*; every element corresponding to `True` will be extracted
    and put in the output array. This procedure is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The same rules apply when dealing with multiple dimensions. Furthermore, if
    the index array has the same shape as the original array, the elements corresponding
    to `True` will be selected and put in the resulting array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexing in NumPy is a reasonably fast operation. Anyway, when speed is critical,
    you can use the slightly faster `numpy.take` and `numpy.compress` functions to
    squeeze out a little more speed. The first argument of `numpy.take` is the array
    we want to operate on, and the second is the list of indexes we want to extract.
    The last argument is `axis`; if not provided, the indexes will act on the flattened
    array, otherwise they will act along the specified axis. The following code shows
    the use of `np.take` and its execution time compared to fancy indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The similar, but a faster way to index using Boolean arrays is `numpy.compress`
    which works in the same way as `numpy.take`. The use of `numpy.compress` is shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The true power of NumPy lies in its fast mathematical operations. The approach
    used by NumPy is to avoid stepping into Python by performing an element-wise calculation
    between matching arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you do an arithmetic operation on two arrays (like a product), if
    the two operands have the same shape, the operation will be applied in an element-wise
    fashion. For example, upon multiplying two (2, 2) arrays, the operation will be
    done between pairs of corresponding elements, producing another (2, 2) array,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the shapes of the operand don''t match, NumPy will attempt to match them
    using certain rules—a feature called *broadcasting*. If one of the operands is
    a single value, it will be applied to every element of the array, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If the operand is another array, NumPy will try to match the shapes starting
    from the last axis. For example, if we want to combine an array of shape (3, 2)
    with one of shape (2,), the second array is repeated three times to generate a
    (3, 2) array. The array is *broadcasted* to match the shape of the other operand,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Broadcasting](img/8458OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the shapes mismatch, for example by combining an array (3, 2) with an array
    (2, 2), NumPy will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'If one of the axes size is 1, the array will be repeated over this axis until
    the shapes match. To illustrate that point, if we have an array of the following
    shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'and we want to broadcast it with an array (5, 1, 2), the array will be repeated
    on the second axis for 10 times which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen earlier, that we can freely reshape arrays to add axes of size
    1\. Using the `numpy.newaxis` constant while indexing will introduce an extra
    dimension. For instance, if we have a (5, 2) array and we want to combine it with
    one of shape (5, 10, 2), we could add an extra axis in the middle, as shown in
    the following code, to obtain a compatible (5, 1, 2) array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This feature can be used, for example, to operate on all possible combinations
    of the two arrays. One of these applications is the *outer product*. If we have
    the following two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The outer product is a matrix containing the product of all the possible combinations
    (i, j) of the two array elements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To calculate this using NumPy we will repeat the elements `[a1, a2, a3]` in
    one dimension, the elements `[b1, b2, b3]` in another dimension, and then take
    their product, as shown in the following figure:.
  prefs: []
  type: TYPE_NORMAL
- en: '![Broadcasting](img/8458OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our strategy will be to transform the array `a` from shape (3,) to shape (3,
    1), and the array `b` from shape (3,) to shape (1, 3). The two arrays are broadcasted
    in the two dimensions and get multiplied together using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This operation is very fast and extremely effective as it avoids Python loops
    and is able to process a high number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'NumPy includes the most common mathematical operations available for broadcasting,
    by default, ranging from simple algebra to trigonometry, rounding, and logic.
    For instance, to take the square root of every element in the array we can use
    the `numpy.sqrt` function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The comparison operators are extremely useful when trying to filter certain
    elements based on a condition. Imagine that we have an array of random numbers
    in the range [0, 1] and we want to extract the numbers greater than 0.5\. We can
    use the `>` operator on the array; The result will be a boolean array, shown as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting boolean array can then be reused as an index to retrieve the
    elements greater than 0.5, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'NumPy also implements methods such as `ndarray.sum`, which takes the sum of
    all the elements on an axis. If we have an array (5, 3), we can use the `ndarray.sum`
    method, as follows, to add elements on the first axis, the second axis, or over
    all the elements of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice that by summing the elements over an axis we eliminate that axis. From
    the previous example, the sum on the axis 0 produces a (3,) array while the sum
    on the axis 1 produces a (5,) array.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Norm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can review the basic concepts illustrated in this section by calculating
    the Norm of a set of coordinates. For a two-dimensional vector the norm is defined
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Given an array of 10 coordinates (x, y) we want to find the Norm of each coordinate.
    We can calculate the norm by taking these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Square the coordinates: obtaining an array which contains `(x**2, y**2)` elements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sum those using `numpy.sum` over the last axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the square root, element-wise, using `numpy.sqrt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The final expression can be compressed in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Rewriting the particle simulator in NumPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will optimize our particle simulator by rewriting some
    parts of it in NumPy. From the profiling we did in [Chapter 1](ch01.html "Chapter 1. Benchmarking
    and Profiling"), *Benchmarking and Profiling*, the slowest part of our program
    is the following loop contained in the `ParticleSimulator.evolve` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We may notice that the body of the loop acts solely on the current particle.
    If we had an array containing the particle positions and angular speed, we could
    rewrite the loop using a broadcasted operation. In contrast, the loop over the
    time steps depends on the previous step and cannot be treated in a parallel fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s natural then, to store all the array coordinates in an array of shape
    (nparticles, 2) and the angular speed in an array of shape (nparticles,). We''ll
    call those arrays `r_i` and `ang_speed_i` and initialize them using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The velocity direction, perpendicular to the vector (x, y), was defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The Norm can be calculated using the strategy illustrated in the *Calculating
    the Norm* section under the *Getting Started with NumPy* heading. The final expression
    is shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For the components (-y, x) we need first to swap the x and y columns in `r_i`
    and then multiply the first column by -1, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate the displacement we need to compute the product of `v_i`, `ang_speed_i`,
    and `timestep`. Since `ang_speed_i` is of shape (nparticles,) it needs a new axis
    in order to operate with `v_i` of shape (nparticles, 2). We will do that using
    `numpy.newaxis` constant as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Outside the loop, we have to update the particle instances with the new coordinates
    x and y as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize, we will implement a method called `ParticleSimulator.evolve_numpy`
    and benchmark it against the pure Python version, renamed as `ParticleSimulator.evolve_python`.
    The complete `ParticleSimulator.evolve_numpy` method is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We also update the benchmark to conveniently change the number of particles
    and the simulation method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the updated benchmark in an IPython session as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We have some improvement but it doesn''t look like a huge speed boost. The
    power of NumPy is revealed when handling big arrays. If we increase the number
    of particles, we will notice a more significant performance boost. We can re-run
    the benchmark with a higher number of particles using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The plot in the following figure was produced by running the benchmark with
    different particle numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rewriting the particle simulator in NumPy](img/8458OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The plot shows that both implementations scale linearly with the particle size,
    but the runtime in the pure Python version (denoted with diamonds) grows much
    faster than the NumPy version (denoted with circles); at greater sizes we have
    a greater NumPy advantage. In general, when using NumPy you should try to pack
    things into large arrays and group the calculations by using the broadcasting
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Reaching optimal performance with numexpr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When handling complex expressions, NumPy stores intermediate results in the
    memory. David M. Cooke wrote a package called `numexpr` which optimizes and compiles
    array expressions on-the-fly. It works by optimizing the usage of the CPU cache
    and by taking advantage of multiple processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its usage is generally straightforward and is based on a single function—`numexpr.evaluate`.
    The function takes a string containing an array expression as its first argument.
    The syntax is basically identical to that of NumPy. For example, we can calculate
    a simple `a + b * c` expression in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `numexpr` package increases the performances in almost all cases, but to
    achieve a substantial advantage you should use it with large arrays. An application
    that involves a large array is the calculation of a *distance matrix*. In a particle
    system, a distance matrix contains all the possible distances between the particles.
    To calculate it, we should first calculate all the vectors connecting any two
    particles (i, j) defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we calculate the length of this vector by taking its Norm, as in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write this in NumPy by employing the usual broadcasting rules (the operation
    is similar to the outer product):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we calculate the Norm over the last axis using the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Rewriting the same expression using the `numexpr` syntax is extremely easy.
    The `numexpr` package doesn''t support slicing in its array expression, therefore
    we first need to prepare the operands for broadcasting by adding an extra dimension
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At that point, we should try to pack as many operations as possible in a single
    expression to allow a significant optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the NumPy mathematical functions are also available in `numexpr`; however,
    there is a limitation. The reduction operations—the ones which reduce an axis,
    such as sum—have to happen last. So, we have to first calculate the sum, step
    out of `numexpr`, and calculate the square root in another expression. The `numexpr`
    code for those operations is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `numexpr` compiler will optimize memory usage by avoiding the storage of
    intermediate results and by taking advantage of multiple processors. In the `distance_matrix.py`
    file you will find two functions that implement the two versions of the distance
    matrix calculation: `distance_matrix_numpy` and `distance_matrix_numexpr`. We
    can import and benchmark them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: By simply copying the expressions using `numexpr` we were able to obtain a 4.5x
    increase in performance in a real-world scenario over standard NumPy. The `numexpr`
    package can be used every time you need to optimize a NumPy expression that involves
    large arrays and complex operations, and you can do so with minimal changes in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to manipulate NumPy arrays and how to write
    fast mathematical expressions using array broadcasting. This knowledge will help
    you to design better programs while obtaining massive performance gains. We also
    introduced the `numexpr` library to further increase the speed of our calculations
    with a minimal amount of effort.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy works very well when handling independent sets of inputs, but it's not
    suitable when the expressions grow complex and cannot be split in element-wise
    operations. In such cases, we can leverage Python capabilities as a glue language
    by interfacing it with C using the Cython package.
  prefs: []
  type: TYPE_NORMAL
