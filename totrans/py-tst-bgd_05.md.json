["```py\n    from unittest import TestCase, main\n    from mocker import Mocker\n\n    import pid\n\n    class test_pid_constructor(TestCase):\n        def test_without_when(self):\n            mocker = Mocker()\n            mock_time = mocker.replace('time.time')\n            mock_time()\n            mocker.result(1.0)\n\n            mocker.replay()\n\n            controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                                 setpoint=0, initial=12)\n\n            mocker.restore()\n            mocker.verify()\n\n            self.assertEqual(controller.gains, (0.5, 0.5, 0.5))\n            self.assertAlmostEqual(controller.setpoint[0], 0.0)\n            self.assertEqual(len(controller.setpoint), 1)\n            self.assertAlmostEqual(controller.previous_time, 1.0)\n            self.assertAlmostEqual(controller.previous_error, -12.0)\n            self.assertAlmostEqual(controller.integrated_error, 0)\n\n        def test_with_when(self):\n            controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                                 setpoint=1, initial=12,\n                                 when=43)\n\n            self.assertEqual(controller.gains, (0.5, 0.5, 0.5))\n            self.assertAlmostEqual(controller.setpoint[0], 1.0)\n            self.assertEqual(len(controller.setpoint), 1)\n            self.assertAlmostEqual(controller.previous_time, 43.0)\n            self.assertAlmostEqual(controller.previous_error, -11.0)\n            self.assertAlmostEqual(controller.integrated_error, 0)\n\n    class test_calculate_response(TestCase):\n        def test_without_when(self):\n            mocker = Mocker()\n            mock_time = mocker.replace('time.time')\n            mock_time()\n            mocker.result(1.0)\n            mock_time()\n            mocker.result(2.0)\n            mock_time()\n            mocker.result(3.0)\n            mock_time()\n            mocker.result(4.0)\n            mock_time()\n            mocker.result(5.0)\n\n            mocker.replay()\n\n            controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                                 setpoint=0, initial=12)\n\n            self.assertEqual(controller.calculate_response(6), -3)\n            self.assertEqual(controller.calculate_response(3), -4.5)\n            self.assertEqual(controller.calculate_response(-1.5), -0.75)\n            self.assertEqual(controller.calculate_response(-2.25), -1.125)\n\n            mocker.restore()\n            mocker.verify()\n        def test_with_when(self):\n            controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                                 setpoint=0, initial=12,\n                                 when=1)\n\n            self.assertEqual(controller.calculate_response(6, 2), -3)\n            self.assertEqual(controller.calculate_response(3, 3), -4.5)\n            self.assertEqual(controller.calculate_response(-1.5, 4), -0.75)\n            self.assertEqual(controller.calculate_response(-2.25, 5), -1.125)\n\n    if __name__ == '__main__':\n        main()\n    ```", "```py\n    $ python test_pid.py\n\n    ```", "```py\nfrom unittest import TestCase, main\nfrom mocker import Mocker\n\nimport pid\n\nclass test_pid_constructor(TestCase):\n    def test_without_when(self):\n        mocker = Mocker()\n        mock_time = mocker.replace('time.time')\n        mock_time()\n        mocker.result(1.0)\n\n        mocker.replay()\n\n        controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                             setpoint=0, initial=12)\n\n        mocker.restore()\n        mocker.verify()\n\n        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))\n        self.assertAlmostEqual(controller.setpoint[0], 0.0)\n        self.assertEqual(len(controller.setpoint), 1)\n        self.assertAlmostEqual(controller.previous_time, 1.0)\n        self.assertAlmostEqual(controller.previous_error, -12.0)\n        self.assertAlmostEqual(controller.integrated_error, 0)\n```", "```py\n    def test_with_when(self):\n        controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                             setpoint=1, initial=12,\n                             when=43)\n\n        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))\n        self.assertAlmostEqual(controller.setpoint[0], 1.0)\n        self.assertEqual(len(controller.setpoint), 1)\n        self.assertAlmostEqual(controller.previous_time, 43.0)\n        self.assertAlmostEqual(controller.previous_error, -11.0)\n        self.assertAlmostEqual(controller.integrated_error, 0)\n```", "```py\nclass test_calculate_response(TestCase):\n    def test_without_when(self):\n        mocker = Mocker()\n        mock_time = mocker.replace('time.time')\n        mock_time()\n        mocker.result(1.0)\n        mock_time()\n        mocker.result(2.0)\n        mock_time()\n        mocker.result(3.0)\n        mock_time()\n        mocker.result(4.0)\n        mock_time()\n        mocker.result(5.0)\n\n        mocker.replay()\n\n        controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                             setpoint=0, initial=12)\n\n        self.assertEqual(controller.calculate_response(6), -3)\n        self.assertEqual(controller.calculate_response(3), -4.5)\n        self.assertEqual(controller.calculate_response(-1.5), -0.75)\n        sel+f.assertEqual(controller.calculate_response(-2.25), -1.125)\n\n        mocker.restore()\n        mocker.verify()\n```", "```py\n    def test_with_when(self):\n        controller = pid.PID(P=0.5, I=0.5, D=0.5,\n                             setpoint=0, initial=12,\n                             when=1)\n\n        self.assertEqual(controller.calculate_response(6, 2), -3)\n        self.assertEqual(controller.calculate_response(3, 3), -4.5)\n        self.assertEqual(controller.calculate_response(-1.5, 4), -0.75)\n        self.assertEqual(controller.calculate_response(-2.25, 5), -1.125)\n```", "```py\nfrom unittest import TestCase, main\n\nclass two_failing_tests(TestCase):\n    def test_assertTrue(self):\n        self.assertTrue(1 == 1 + 1)\n\n    def test_assertEqual(self):\n        self.assertEqual(1, 1 + 1)\n\nif __name__ == '__main__':\n    main()\n```", "```py\nfrom unittest import TestCase, main\n\nclass floating_point_problems(TestCase):\n    def test_assertEqual(self):\n        self.assertEqual((7.0 ** 0.5) ** 2.0, 7.0)\n    def test_assertAlmostEqual(self):\n        self.assertAlmostEqual((7.0 ** 0.5) ** 2.0, 7.0)\n\nif __name__ == '__main__':\n\n    main()\n```", "```py\nfrom unittest import TestCase, main\n\nclass silly_int_test(TestCase):\n    def test_int_from_string(self):\n        self.assertRaises(ValueError, int, '8ca2', base = 16)\n\nif __name__ == '__main__':\n    main()\n```", "```py\nfrom unittest import TestCase, main\n\nclass test_with_fail(TestCase):\n    def test_less_than(self):\n        if not (2.3 < 5.6):\n            self.fail('2.3 is not less than 5.6, but it should be')\n\nif __name__ == '__main__':\n    main()\n```", "```py\n    >>> try:\n    ...     int('123')\n    ... except ValueError:\n    ...     pass\n    ... else:\n    ...     print 'Expected exception was not raised'\n    ```", "```py\nclass employees:\n    def __init__(self, connection):\n        self.connection = connection\n\n    def add_employee(self, first, last, date_of_employment):\n        cursor = self.connection.cursor()\n        cursor.execute('''insert into employees\n                            (first, last, date_of_employment)\n                          values\n                            (:first, :last, :date_of_employment)''',\n                       locals())\n        self.connection.commit()\n\n        return cursor.lastrowid\n\n    def find_employees_by_name(self, first, last):\n        cursor = self.connection.cursor()\n        cursor.execute('''select * from employees\n                          where\n                            first like :first\n                          and\n                            last like :last''',\n                       locals())\n\n        for row in cursor:\n            yield row\n\n    def find_employees_by_date(self, date):\n        cursor = self.connection.cursor()\n        cursor.execute('''select * from employees\n                          where date_of_employment = :date''',\n                       locals())\n\n        for row in cursor:\n            yield row\n```", "```py\n    from unittest import TestCase, main\n    from sqlite3 import connect, PARSE_DECLTYPES\n    from datetime import date\n    from employees import employees\n\n    class test_employees(TestCase):\n    ```", "```py\n        def setUp(self):\n            connection = connect(':memory:',\n                                 detect_types=PARSE_DECLTYPES)\n            cursor = connection.cursor()\n\n            cursor.execute('''create table employees\n                                (first text,\n                                 last text,\n                                 date_of_employment date)''')\n\n            cursor.execute('''insert into employees\n                                (first, last, date_of_employment)\n                              values\n                                (\"Test1\", \"Employee\", :date)''',\n                           {'date': date(year = 2003,\n                                         month = 7,\n                                         day = 12)})\n\n            cursor.execute('''insert into employees\n                                (first, last, date_of_employment)\n                              values\n                                (\"Test2\", \"Employee\", :date)''',\n                           {'date': date(year = 2001,\n                                         month = 3,\n                                         day = 18)})\n\n            self.connection = connection\n    ```", "```py\n        def tearDown(self):\n            self.connection.close()\n    ```", "```py\n        def test_add_employee(self):\n            to_test = employees(self.connection)\n            to_test.add_employee('Test1', 'Employee', date.today())\n\n            cursor = self.connection.cursor()\n            cursor.execute('''select * from employees\n                              order by date_of_employment''')\n\n            self.assertEqual(tuple(cursor),\n                             (('Test2', 'Employee', date(year=2001,\n                                                         month=3,\n                                                         day=18)),\n                              ('Test1', 'Employee', date(year=2003,\n                                                         month=7,\n                                                         day=12)),\n                              ('Test1', 'Employee', date.today())))\n\n        def test_find_employees_by_name(self):\n            to_test = employees(self.connection)\n\n            found = tuple(to_test.find_employees_by_name('Test1', 'Employee'))\n            expected = (('Test1', 'Employee', date(year=2003,\n                                                   month=7,\n                                                   day=12)),)\n\n            self.assertEqual(found, expected)\n\n        def test_find_employee_by_date(self):\n            to_test = employees(self.connection)\n\n            target = date(year=2001, month=3, day=18)\n            found = tuple(to_test.find_employees_by_date(target))\n\n            expected = (('Test2', 'Employee', target),)\n\n            self.assertEqual(found, expected)\n\n    if __name__ == '__main__':\n        main()\n\n    ```", "```py\nfrom os.path import isfile, isdir, exists, join\nfrom os import makedirs, rmdir, unlink\n\nclass path:\n    r\"\"\"\n\n    Instances of this class represent a file path, and facilitate\n    several operations on files and directories.\n\n    Its most surprising feature is that it overloads the division\n    operator, so that the result of placing a / operator between two\n    paths (or between a path and a string) results in a longer path,\n    representing the two operands joined by the system's path\n    separator character.\n\n    \"\"\"\n\n    def __init__(self, target):\n        self.target = target\n\n    def exists(self):\n        return exists(self.target)\n\n    def isfile(self):\n        return isfile(self.target)\n\n    def isdir(self):\n        return isdir(self.target)\n\n    def mkdir(self, mode = 493):\n        makedirs(self.target, mode)\n\n    def rmdir(self):\n        if self.isdir():\n            rmdir(self.target)\n        else:\n            raise ValueError('Path does not represent a directory')\n\n    def delete(self):\n        if self.exists():\n            unlink(self.target)\n        else:\n            raise ValueError('Path does not represent a file')\n\n    def open(self, mode = \"r\"):\n        return open(self.target, mode)\n\n    def __div__(self, other):\n        if isinstance(other, path):\n            return path(join(self.target, other.target))\n        return path(join(self.target, other))\n\n    def __repr__(self):\n        return '<path %s>' % self.target\n\n```", "```py\nfrom unittest import main\nfrom mocker import MockerTestCase\nfrom time import time\n\nclass test_mocker_integration(MockerTestCase):\n    def test_mocking_context(self):\n        mocker = self.mocker\n        time_mock = mocker.replace('time.time')\n        time_mock()\n        mocker.result(1.0)\n\n        mocker.replay()\n\n        self.assertAlmostEqual(time(), 1.0)\n\nif __name__ == '__main__':\n    main()\n```"]