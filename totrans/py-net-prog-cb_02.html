<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 2. Multiplexing Socket I/O for Better Performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Multiplexing Socket I/O for Better Performance</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using ForkingMixIn in your socket server applications</li><li class="listitem" style="list-style-type: disc">Using ThreadingMixIn in your socket server applications</li><li class="listitem" style="list-style-type: disc">Writing a chat server using select.select</li><li class="listitem" style="list-style-type: disc">Multiplexing a web server using select.epoll</li><li class="listitem" style="list-style-type: disc">Multiplexing an echo server using Diesel concurrent library</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Introduction</h1></div></div></div><p>This chapter focuses on improving the socket server performance using a few useful techniques. Unlike the previous chapter, here we consider multiple clients that will be connected to the server and the communication can be asynchronous. The server does not need to process the request from clients in a blocking manner, this can be done independent of each other. If one client takes more time to receive or process data, the server does not need to wait for that. It can talk to other clients using separate threads or processes.</p><p>In this chapter, we will also explore the <code class="literal">select</code> module that provides the platform-specific I/O monitoring functions. This module is built on top of the select system call of the underlying operating system's kernel. For Linux, the manual page is located at <a class="ulink" href="http://man7.org/linux/man-pages/man2/select.2.html">http://man7.org/linux/man-pages/man2/select.2.html</a> and can be checked to see the available features of this system call. Since our socket server would like to interact with many clients, <code class="literal">select</code> can be very helpful to monitor non-blocking sockets. There are some third-party Python libraries that can also help us to deal with multiple clients at the same time. We have included one sample recipe of using Diesel concurrent library.</p><p>Although, for the sake of brevity, we will be using two or few clients, readers are free to extend the recipes of this chapter and use them with tens and hundreds of clients.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using ForkingMixIn in your socket server applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Using ForkingMixIn in your socket server applications</h1></div></div></div><p>You have decided to write an <a id="id77" class="indexterm"/>asynchronous Python socket server application. <a id="id78" class="indexterm"/>The server will not block in processing a client request. So the server needs a mechanism to deal with each client independently.</p><p>Python 2.7 version's <code class="literal">SocketServer</code> class comes <a id="id79" class="indexterm"/>with two utility classes: <code class="literal">ForkingMixIn</code> and <code class="literal">ThreadingMixIn</code>. The <code class="literal">ForkingMixin</code> class will spawn a new process for each client request. This class is discussed in this section. The <code class="literal">ThreadingMixIn</code> class will be discussed in the next section. For more information, you can refer to the Python documentation at <a class="ulink" href="http://docs.python.org/2/library/socketserver.html">http://docs.python.org/2/library/socketserver.html</a>.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec36"/>How to do it...</h2></div></div></div><p>Let us rewrite our echo server, previously described in <a class="link" href="ch01.html" title="Chapter 1. Sockets, IPv4, and Simple Client/Server Programming">Chapter 1</a>, <span class="emphasis"><em>Sockets, IPv4, and Simple Client/Server Programming</em></span>. We can utilize the subclasses of the <code class="literal">SocketServer</code> class family. It has ready-made TCP, UDP, and other protocol servers. We can create a <code class="literal">ForkingServer</code> class<a id="id80" class="indexterm"/> inherited from <code class="literal">TCPServer</code> and <code class="literal">ForkingMixin</code>. The former parent will enable our <code class="literal">ForkingServer</code> class to do all the necessary server operations that we did manually before, such as creating a socket, binding to an address, and listening for incoming connections. Our server also needs to inherit from <code class="literal">ForkingMixin</code> to handle clients asynchronously.</p><p>The <code class="literal">ForkingServer</code> class also needs to set up a request handler that dictates how to handle a client request. Here our server will echo back the text string received from the client. Our request handler class <code class="literal">ForkingServerRequestHandler</code> is inherited from the <code class="literal">BaseRequestHandler</code> provided with the <code class="literal">SocketServer</code> library.</p><p>We can code the client of our echo server, <code class="literal">ForkingClient</code>, in an object-oriented fashion. In Python, the constructor method of a class is called <code class="literal">__init__()</code>. By convention, it takes a self-argument to attach attributes or properties of that particular class. The <code class="literal">ForkingClient</code> echo server will be initialized at <code class="literal">__init__()</code> and sends the message to the server at the <code class="literal">run()</code> method respectively.</p><p>If you are not familiar with <span class="strong"><strong>object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>)<a id="id81" class="indexterm"/> at all, it might be helpful to review the basic concepts of OOP while attempting to grasp this recipe.</p><p>In order to test our <code class="literal">ForkingServer</code> class, we can launch multiple echo clients and see how the server responds back to the clients.</p><p>Listing 2.1 shows a sample <a id="id82" class="indexterm"/>code using <code class="literal">ForkingMixin</code> in a <a id="id83" class="indexterm"/>socket server<a id="id84" class="indexterm"/> application as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 2
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
# See more: http://docs.python.org/2/library/socketserver.html

import os
import socket
import threading
import SocketServer


SERVER_HOST = 'localhost'
SERVER_PORT = 0 # tells the kernel to pick up a port dynamically
BUF_SIZE = 1024
ECHO_MSG = 'Hello echo server!'


class ForkedClient():
    """ A client to test forking server"""    
    def __init__(self, ip, port):
        # Create a socket
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        # Connect to the server
	     self.sock.connect((ip, port))
    
    def run(self):
        """ Client playing with the server"""
        # Send the data to server
        current_process_id = os.getpid()
        print 'PID %s Sending echo message to the server : "%s"' % (current_process_id, ECHO_MSG)
        sent_data_length = self.sock.send(ECHO_MSG)
        print "Sent: %d characters, so far..." %sent_data_length
        
        # Display server response
        response = self.sock.recv(BUF_SIZE)
        print "PID %s received: %s" % (current_process_id, response[5:])
    
    def shutdown(self):
        """ Cleanup the client socket """
        self.sock.close()
      
  
class ForkingServerRequestHandler(SocketServer.BaseRequestHandler):
  
    def handle(self):        
        # Send the echo back to the client
        data = self.request.recv(BUF_SIZE)
        current_process_id = os.getpid()
        response = '%s: %s' % (current_process_id, data)
        print "Server sending response [current_process_id: data] = [%s]" %response
        self.request.send(response)
        return

  
class ForkingServer(SocketServer.ForkingMixIn,
                    SocketServer.TCPServer,
                    ):
    """Nothing to add here, inherited everything necessary from parents"""
    pass


def main():
    # Launch the server
    server = ForkingServer((SERVER_HOST, SERVER_PORT), ForkingServerRequestHandler)
    ip, port = server.server_address # Retrieve the port number
    server_thread = threading.Thread(target=server.serve_forever)
    server_thread.setDaemon(True) # don't hang on exit
    server_thread.start()
    print 'Server loop running PID: %s' %os.getpid()
    
    # Launch the client(s)
    client1 =  ForkedClient(ip, port)
    client1.run()
    
    client2 =  ForkedClient(ip, port)
    client2.run()

    # Clean them up
    server.shutdown()
    client1.shutdown()
    client2.shutdown()
    server.socket.close()

if __name__ == '__main__':
    main()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec37"/>How it works...</h2></div></div></div><p>An instance of <code class="literal">ForkingServer</code> is launched in the main thread, which has been daemonized to run in the background.<a id="id85" class="indexterm"/> Now, the two clients have started interacting with the server.</p><p>If you run the script, it will show<a id="id86" class="indexterm"/> the following <a id="id87" class="indexterm"/>output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 2_1_forking_mixin_socket_server.py</strong></span>
<span class="strong"><strong>Server loop running PID: 12608</strong></span>
<span class="strong"><strong>PID 12608 Sending echo message to the server : "Hello echo server!"</strong></span>
<span class="strong"><strong>Sent: 18 characters, so far...</strong></span>
<span class="strong"><strong>Server sending response [current_process_id: data] = [12610: Hello echo server!]</strong></span>
<span class="strong"><strong>PID 12608 received: : Hello echo server!</strong></span>
<span class="strong"><strong>PID 12608 Sending echo message to the server : "Hello echo server!"</strong></span>
<span class="strong"><strong>Sent: 18 characters, so far...</strong></span>
<span class="strong"><strong>Server sending response [current_process_id: data] = [12611: Hello echo server!]</strong></span>
<span class="strong"><strong>PID 12608 received: : Hello echo server!</strong></span>
</pre></div><p>The server port number might be different in your machine since this is dynamically chosen by the operating system kernel.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Using ThreadingMixIn in your socket server applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Using ThreadingMixIn in your socket server applications</h1></div></div></div><p>Perhaps you prefer writing a<a id="id88" class="indexterm"/> multi-threaded application <a id="id89" class="indexterm"/>over a process-based one due to any<a id="id90" class="indexterm"/> particular reason, for example, sharing the states of that application across threads, avoiding the complexity of inter-process communication, or something else. In such a situation, if you like to write an asynchronous network server using <code class="literal">SocketServer</code> library, you will need <code class="literal">ThreadingMixin</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec38"/>Getting ready</h2></div></div></div><p>By making a few minor changes to our previous recipe, you can get a working version of socket server using <code class="literal">ThreadingMixin</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec39"/>How to do it...</h2></div></div></div><p>As seen in the previous socket server based on <code class="literal">ForkingMixIn</code>, <code class="literal">ThreadingMixIn</code> socket server will follow the same coding pattern of an echo server except a few things. First, our <code class="literal">ThreadedTCPServer</code> will inherit from <code class="literal">TCPServer</code> and <code class="literal">TheadingMixIn</code>. This multi-threaded version will launch a new thread when a client connects to it. Some more details can be found at <a class="ulink" href="http://docs.python.org/2/library/socketserver.html">http://docs.python.org/2/library/socketserver.html</a>.</p><p>The request handler class of our socket server, <code class="literal">ForkingServerRequestHandler</code>, sends the echo back to the client from a new thread. You can check the thread information here. For the sake of simplicity, we put the<a id="id91" class="indexterm"/> client code in a function instead of a class. The client code creates the client socket and sends<a id="id92" class="indexterm"/> the message to the<a id="id93" class="indexterm"/> server.</p><p>Listing 2.2 shows a sample code on echo socket server using <code class="literal">ThreadingMixIn</code> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 2
# This program is optimized for Python 2.7
# It may run on any other version with/without modifications.
import os
import socket
import threading
import SocketServer
SERVER_HOST = 'localhost'
SERVER_PORT = 0 # tells the kernel to pick up a port dynamically
BUF_SIZE = 1024

def client(ip, port, message):
    """ A client to test threading mixin server"""    
    # Connect to the server
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((ip, port))
    try:
        sock.sendall(message)
        response = sock.recv(BUF_SIZE)
        print "Client received: %s" %response
    finally:
        sock.close()

class ThreadedTCPRequestHandler(SocketServer.BaseRequestHandler):
    """ An example of threaded TCP request handler """
    def handle(self):
        data = self.request.recv(1024)
        current_thread = threading.current_thread()
        response = "%s: %s" %(current_thread.name, data)
        self.request.sendall(response)

class ThreadedTCPServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    """Nothing to add here, inherited everything necessary from parents"""
    pass
if __name__ == "__main__":
    # Run server
    server = ThreadedTCPServer((SERVER_HOST, SERVER_PORT), ThreadedTCPRequestHandler)
    ip, port = server.server_address # retrieve ip address
    # Start a thread with the server -- one  thread per request
    server_thread = threading.Thread(target=server.serve_forever)
    # Exit the server thread when the main thread exits
    server_thread.daemon = True
    server_thread.start()
    print "Server loop running on thread: %s"  %server_thread.name
    # Run clients
    client(ip, port, "Hello from client 1")
    client(ip, port, "Hello from client 2")
    client(ip, port, "Hello from client 3")
    # Server cleanup
    server.shutdown()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec40"/>How it works...</h2></div></div></div><p>This recipe first creates a <a id="id94" class="indexterm"/>server thread and launches it in the background. Then it launches three test clients to send <a id="id95" class="indexterm"/>messages to the server.<a id="id96" class="indexterm"/> In response, the server echoes back the message to the clients. In the <code class="literal">handle()</code> method<a id="id97" class="indexterm"/> of the server's request handler, you can see that we retrieve the current thread information and print it. This should be different in each client connection.</p><p>In this <a id="id98" class="indexterm"/>client/server conversation, the <code class="literal">sendall()</code> method<a id="id99" class="indexterm"/> has been used to guarantee the sending of all data without<a id="id100" class="indexterm"/> any<a id="id101" class="indexterm"/> loss:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 2_2_threading_mixin_socket_server.py</strong></span>
<span class="strong"><strong>Server loop running on thread: Thread-1</strong></span>
<span class="strong"><strong>Client received: Thread-2: Hello from client 1</strong></span>
<span class="strong"><strong>Client received: Thread-3: Hello from client 2</strong></span>
<span class="strong"><strong>Client received: Thread-4: Hello from client 3</strong></span>
</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing a chat server using select.select"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Writing a chat server using select.select</h1></div></div></div><p>Launching a separate thread or process per client may not be viable in any larger network server application where several<a id="id102" class="indexterm"/> hundred or thousand clients are concurrently<a id="id103" class="indexterm"/> connected to the server. Due to the limited available memory and host CPU power, we need a better technique to deal with large number of clients. Fortunately, Python provides the <code class="literal">select</code> module to overcome this problem.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec41"/>How to do it...</h2></div></div></div><p>We need to write an efficient chat server that can handle several hundred or a large number of client connections. We will use the <code class="literal">select()</code> method from the <code class="literal">select</code> module that will enable our chat server and client to do any task without blocking a send or receive call all the time.</p><p>Let us design this recipe such that a single script can launch both client and server with an additional <code class="literal">--name</code> argument. Only if <code class="literal">--name=server</code> is passed from the command line, the script will launch the chat server. Any other value passed to the <code class="literal">--name</code> argument, for example, <code class="literal">client1</code>, <code class="literal">client2</code>, will launch a chat client. Let's specify our char server port number from the command line using <code class="literal">--port</code> argument. For a larger application, it may be preferable to write separate modules for the server and client.</p><p>Listing 2.3 shows an example of chat application using <code class="literal">select.select</code> as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 2
# This program is optimized for Python 2.7
# It may run on any other version with/without modifications
import select
import socket
import sys
import signal
import cPickle
import struct
import argparse

SERVER_HOST = 'localhost'
CHAT_SERVER_NAME = 'server'

# Some utilities
def send(channel, *args):
    buffer = cPickle.dumps(args)
    value = socket.htonl(len(buffer))
    size = struct.pack("L",value)
    channel.send(size)
    channel.send(buffer)

def receive(channel):
    size = struct.calcsize("L")
    size = channel.recv(size)
    try:
        size = socket.ntohl(struct.unpack("L", size)[0])
    except struct.error, e:
        return ''
    buf = ""
    while len(buf) &lt; size:
        buf = channel.recv(size - len(buf))
    return cPickle.loads(buf)[0]</pre></div><p>The <code class="literal">send()</code> method<a id="id104" class="indexterm"/> takes one <a id="id105" class="indexterm"/>named argument channel and<a id="id106" class="indexterm"/> positional argument <code class="literal">*args</code>. It serializes the data using the <code class="literal">dumps()</code> method<a id="id107" class="indexterm"/> from the <code class="literal">cPickle</code> module. It determines the size of the data using the <code class="literal">struct</code> module. Similarly, <code class="literal">receive()</code> takes one named argument <code class="literal">channel</code>.</p><p>Now we can code the <code class="literal">ChatServer</code> class as follows:</p><div class="informalexample"><pre class="programlisting">class ChatServer(object):
    """ An example chat server using select """
 def __init__(self, port, backlog=5):
   self.clients = 0
   self.clientmap = {}
   self.outputs = [] # list output sockets
   self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
   # Enable re-using socket address
   self.server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
   self.server.bind((SERVER_HOST, port))
   print 'Server listening to port: %s ...' %port
   self.server.listen(backlog)
   # Catch keyboard interrupts
   signal.signal(signal.SIGINT, self.sighandler)
        
    def sighandler(self, signum, frame):
        """ Clean up client outputs"""
        # Close the server
        print 'Shutting down server...'
        # Close existing client sockets
        for output in self.outputs:
            output.close()            
        self.server.close()

    def get_client_name(self, client):
        """ Return the name of the client """
        info = self.clientmap[client]
        host, name = info[0][0], info[1]
        return '@'.join((name, host))</pre></div><p>Now the main<a id="id108" class="indexterm"/> executable method of the <code class="literal">ChatServer</code> class<a id="id109" class="indexterm"/> should look like the following code:</p><div class="informalexample"><pre class="programlisting">    def run(self):
        inputs = [self.server, sys.stdin]
        self.outputs = []
        running = True
        while running:
         try:
          readable, writeable, exceptional = \
          select.select(inputs, self.outputs, [])
            except select.error, e:
                break
            for sock in readable:
                if sock == self.server:
                    # handle the server socket
                    client, address = self.server.accept()
                    print "Chat server: got connection %d from %s" %\                     (client.fileno(), address)
                    # Read the login name
                    cname = receive(client).split('NAME: ')[1]
                    # Compute client name and send back
                    self.clients += 1
                    send(client, 'CLIENT: ' + str(address[0]))
                    inputs.append(client)
                    self.clientmap[client] = (address, cname)
                    # Send joining information to other clients
                    msg = "\n(Connected: New client (%d) from %s)" %\                   (self.clients, self.get_client_name(client))
                    for output in self.outputs:
                        send(output, msg)
                    self.outputs.append(client)
                elif sock == sys.stdin:
                    # handle standard input
                    junk = sys.stdin.readline()
                    running = False
                else:
                    # handle all other sockets
                    try:
                        data = receive(sock)
                        if data:
                            # Send as new client's message...
                            msg = '\n#[' + self.get_client_name(sock)\
                                   + ']&gt;&gt;' + data
                            # Send data to all except ourself
                            for output in self.outputs:
                                if output != sock:
                                    send(output, msg)
                        else:
                            print "Chat server: %d hung up" % \
                            sock.fileno()
                            self.clients -= 1
                            sock.close()
                            inputs.remove(sock)
                            self.outputs.remove(sock)
                            # Sending client leaving info to others
                            msg = "\n(Now hung up: Client from %s)" %\                             self.get_client_name(sock)
                            for output in self.outputs:
                                send(output, msg)
                    except socket.error, e:
                        # Remove
                        inputs.remove(sock)
                        self.outputs.remove(sock)
        self.server.close()</pre></div><p>The chat server initializes with a few data attributes. It stores the count of clients, map of each client, and output sockets. The usual server socket creation also sets the option to reuse an address so that there is no problem restarting the server again using the same port. An optional backlog argument to the chat server constructor sets the maximum number of queued connections to listen by the server.</p><p>An interesting aspect of this chat server is to catch the user interrupt, usually via keyboard, using the <code class="literal">signal</code> module. So a signal handler <code class="literal">sighandler</code> is registered for the interrupt signal (<code class="literal">SIGINT</code>). This signal handler catches the keyboard interrupt signal and closes all output sockets where data may be waiting to be sent.</p><p>The main executive method of our<a id="id110" class="indexterm"/> chat server <code class="literal">run()</code> performs its operation inside a <code class="literal">while</code> loop. This method registers with a select interface where the input argument is the chat server socket, <code class="literal">stdin</code>. The output<a id="id111" class="indexterm"/> argument is specified by the server's output socket list. In return, <code class="literal">select</code> provides three lists: readable, writable, and exceptional sockets. The chat server is only interested<a id="id112" class="indexterm"/> in readable sockets where some data is ready to be read. If that socket indicates to itself, then that will mean a new client connection has been established. So the server retrieves the client's name and broadcasts this information to other clients. In another case, if anything comes from the input arguments, the chat server exits. Similarly, the chat server deals with the other client's socket inputs. It relays the data received from any client to others and also shares their joining/leaving information.</p><p>The chat client code class should contain the following code:</p><div class="informalexample"><pre class="programlisting">class ChatClient(object):
    """ A command line chat client using select """

    def __init__(self, name, port, host=SERVER_HOST):
        self.name = name
        self.connected = False
        self.host = host
        self.port = port
        # Initial prompt
        self.prompt='[' + '@'.join((name, socket.gethostname().split('.')[0])) + ']&gt; '
        # Connect to server at port
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((host, self.port))
            print "Now connected to chat server@ port %d" % self.port
            self.connected = True
            # Send my name...
            send(self.sock,'NAME: ' + self.name)
            data = receive(self.sock)
            # Contains client address, set it
            addr = data.split('CLIENT: ')[1]
            self.prompt = '[' + '@'.join((self.name, addr)) + ']&gt; '
        except socket.error, e:
            print "Failed to connect to chat server @ port %d" % self.port
            sys.exit(1)

    def run(self):
        """ Chat client main loop """
        while self.connected:
            try:
                sys.stdout.write(self.prompt)
                sys.stdout.flush()
                # Wait for input from stdin and socket
                readable, writeable,exceptional = select.select([0, self.sock], [],[])
                for sock in readable:
                    if sock == 0:
                        data = sys.stdin.readline().strip()
                        if data: send(self.sock, data)
                    elif sock == self.sock:
                        data = receive(self.sock)
                        if not data:
                            print 'Client shutting down.'
                            self.connected = False
                            break
                        else:
                            sys.stdout.write(data + '\n')
                            sys.stdout.flush()
                            
            except KeyboardInterrupt:
                print " Client interrupted. """
                self.sock.close()
                break</pre></div><p>The chat client initializes with <a id="id113" class="indexterm"/>a name argument and<a id="id114" class="indexterm"/> sends this name to<a id="id115" class="indexterm"/> the chat server upon connecting. It also sets up a custom prompt <code class="literal">[ name@host ]&gt;</code>. The executive method of this client <code class="literal">run()</code> continues its operation as long as the connection to the server is active. In a manner similar to the chat server, the chat client also registers with <code class="literal">select()</code>. If anything in<a id="id116" class="indexterm"/> readable sockets is ready, it enables the client to receive data. If the sock value is <code class="literal">0</code> and there's any data available then the data can be sent. The same information is also shown in stdout or, in our case, the command-line console. Our main method should now get command-line arguments and call either the server or client as follows:</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Socket Server Example with Select')
    parser.add_argument('--name', action="store", dest="name", required=True)
    parser.add_argument('--port', action="store", dest="port", type=int, required=True)
    given_args = parser.parse_args()
    port = given_args.port
    name = given_args.name
    if name == CHAT_SERVER_NAME:
        server = ChatServer(port)
        server.run()
    else:
        client = ChatClient(name=name, port=port)
        client.run()</pre></div><p>We would like to run this<a id="id117" class="indexterm"/> script thrice: once for the chat server and<a id="id118" class="indexterm"/> twice for two chat clients. For the server, we pass <code class="literal">–name=server</code> and <code class="literal">port=8800</code>. For <code class="literal">client1</code>, we change the name argument <code class="literal">--name=client1</code> and for <code class="literal">client2</code>, we put <code class="literal">--name=client2</code>. Then from the <code class="literal">client1</code> value prompt we send the message <code class="literal">"Hello from client 1"</code>, which is printed in the prompt of the<code class="literal"> client2</code>. Similarly, we send <code class="literal">"hello from client 2</code>" from the prompt of the <code class="literal">client2</code>, which is shown in the prompt of the <code class="literal">client1</code>.</p><p>The output for the server is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 2_3_chat_server_with_select.py --name=server --port=8800</strong></span>
<span class="strong"><strong>Server listening to port: 8800 ...</strong></span>
<span class="strong"><strong>Chat server: got connection 4 from ('127.0.0.1', 56565)</strong></span>
<span class="strong"><strong>Chat server: got connection 5 from ('127.0.0.1', 56566)</strong></span>
</pre></div><p>The output for <code class="literal">client1</code> is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 2_3_chat_server_with_select.py --name=client1 --port=8800</strong></span>
<span class="strong"><strong>Now connected to chat server@ port 8800</strong></span>
<span class="strong"><strong>[client1@127.0.0.1]&gt;</strong></span>
<span class="strong"><strong>(Connected: New client (2) from client2@127.0.0.1)</strong></span>
<span class="strong"><strong>[client1@127.0.0.1]&gt; Hello from client 1</strong></span>
<span class="strong"><strong>[client1@127.0.0.1]&gt;</strong></span>
<span class="strong"><strong>#[client2@127.0.0.1]&gt;&gt;hello from client 2</strong></span>
</pre></div><p>The output for <code class="literal">client2</code> is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 2_3_chat_server_with_select.py --name=client2 --port=8800</strong></span>
<span class="strong"><strong>Now connected to chat server@ port 8800</strong></span>
<span class="strong"><strong>[client2@127.0.0.1]&gt;</strong></span>
<span class="strong"><strong>#[client1@127.0.0.1]&gt;&gt;Hello from client 1</strong></span>
<span class="strong"><strong>[client2@127.0.0.1]&gt; hello from client 2</strong></span>
<span class="strong"><strong>[client2@127.0.0.1]</strong></span>
</pre></div><p>The whole interaction is shown in the following screenshot:</p><div class="mediaobject"><img src="images/3463OS_02_01.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec42"/>How it works...</h2></div></div></div><p>At the top of our module, <a id="id119" class="indexterm"/>we defined two utility functions: <code class="literal">send()</code> and <code class="literal">receive()</code>.</p><p>The chat <a id="id120" class="indexterm"/>server and client use these utility functions, which were demonstrated earlier. The details of the chat server and client methods were also discussed earlier.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Multiplexing a web server using select.epoll"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Multiplexing a web server using select.epoll</h1></div></div></div><p>Python's <code class="literal">select</code> module has<a id="id121" class="indexterm"/> a few platform-specific, networking event management functions. On a Linux machine, <code class="literal">epoll</code> is available. This will utilize<a id="id122" class="indexterm"/> the operating system kernel that will poll network events and let our script know whenever something happens. This sounds more efficient than the previously mentioned <code class="literal">select.select</code> approach.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec43"/>How to do it...</h2></div></div></div><p>Let's write a simple web server that can return a single line of text to any connected web browser.</p><p>The core idea is during the initialization of this web server, we should make a call to <code class="literal">select.epoll()</code> and register our server's file descriptor for event notifications. In the web server's executive code, the socket event is monitored as follows:</p><div class="informalexample"><pre class="programlisting">Listing 2.4 Simple web server using select.epoll
#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 2
# This program is optimized for Python 2.7
# It may run on any other version with/without modifications.
import socket
import select
import argparse
SERVER_HOST = 'localhost'
EOL1 = b'\n\n'
EOL2 = b'\n\r\n'
SERVER_RESPONSE  = b"""HTTP/1.1 200 OK\r\nDate: Mon, 1 Apr 2013 01:01:01 GMT\r\nContent-Type: text/plain\r\nContent-Length: 25\r\n\r\n
Hello from Epoll Server!"""

class EpollServer(object):
    """ A socket server using Epoll"""
    def __init__(self, host=SERVER_HOST, port=0):
      self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
      self.sock.bind((host, port))
      self.sock.listen(1)
      self.sock.setblocking(0)
      self.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
      print "Started Epoll Server"
      self.epoll = select.epoll()
      self.epoll.register(self.sock.fileno(), select.EPOLLIN)
    
 def run(self):
  """Executes epoll server operation"""
  try:
     connections = {}; requests = {}; responses = {}
     while True:
   events = self.epoll.poll(1)
   for fileno, event in events:
     if fileno == self.sock.fileno():
       connection, address = self.sock.accept()
       connection.setblocking(0)
       self.epoll.register(connection.fileno(), select.EPOLLIN)
       connections[connection.fileno()] = connection
       requests[connection.fileno()] = b''
       responses[connection.fileno()] = SERVER_RESPONSE
     elif event &amp; select.EPOLLIN:
       requests[fileno] += connections[fileno].recv(1024)
       if EOL1 in requests[fileno] or EOL2 in requests[fileno]:
             self.epoll.modify(fileno, select.EPOLLOUT)
             print('-'*40 + '\n' + requests[fileno].decode()[:-2])
      elif event &amp; select.EPOLLOUT:
         byteswritten = connections[fileno].send(responses[fileno])
         responses[fileno] = responses[fileno][byteswritten:]
         if len(responses[fileno]) == 0:
             self.epoll.modify(fileno, 0)
             connections[fileno].shutdown(socket.SHUT_RDWR)
         elif event &amp; select.EPOLLHUP:
              self.epoll.unregister(fileno)
              connections[fileno].close()
              del connections[fileno]
 finally:
   self.epoll.unregister(self.sock.fileno())
   self.epoll.close()
   self.sock.close()

if __name__ == '__main__':
 parser = argparse.ArgumentParser(description='Socket Server Example with Epoll')
 parser.add_argument('--port', action="store", dest="port", type=int, required=True)
    given_args = parser.parse_args()
    port = given_args.port
    server = EpollServer(host=SERVER_HOST, port=port)
    server.run()</pre></div><p>If you run this script and access<a id="id123" class="indexterm"/> the web server from your browser,<a id="id124" class="indexterm"/> such as Firefox or IE, by entering <code class="literal">http://localhost:8800/</code>, the following output will be shown in the console:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 2_4_simple_web_server_with_epoll.py --port=8800</strong></span>
<span class="strong"><strong>Started Epoll Server</strong></span>
<span class="strong"><strong>----------------------------------------</strong></span>
<span class="strong"><strong>GET / HTTP/1.1</strong></span>
<span class="strong"><strong>Host: localhost:8800</strong></span>
<span class="strong"><strong>Connection: keep-alive</strong></span>
<span class="strong"><strong>Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</strong></span>
<span class="strong"><strong>User-Agent: Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31</strong></span>
<span class="strong"><strong>DNT: 1</strong></span>
<span class="strong"><strong>Accept-Encoding: gzip,deflate,sdch</strong></span>
<span class="strong"><strong>Accept-Language: en-GB,en-US;q=0.8,en;q=0.6</strong></span>
<span class="strong"><strong>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3</strong></span>
<span class="strong"><strong>Cookie: MoodleSession=69149dqnvhett7br3qebsrcmh1; MOODLEID1_=%257F%25BA%2B%2540V</strong></span>

<span class="strong"><strong>----------------------------------------</strong></span>
<span class="strong"><strong>GET /favicon.ico HTTP/1.1</strong></span>
<span class="strong"><strong>Host: localhost:8800</strong></span>
<span class="strong"><strong>Connection: keep-alive</strong></span>
<span class="strong"><strong>Accept: */*</strong></span>
<span class="strong"><strong>DNT: 1</strong></span>
<span class="strong"><strong>User-Agent: Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31</strong></span>
<span class="strong"><strong>Accept-Encoding: gzip,deflate,sdch</strong></span>
<span class="strong"><strong>Accept-Language: en-GB,en-US;q=0.8,en;q=0.6</strong></span>
<span class="strong"><strong>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3</strong></span>
</pre></div><p>You will also be able to see the following line in your browser:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Hello from Epoll Server!</strong></span>
</pre></div><p>The following screenshot shows the scenario:</p><div class="mediaobject"><img src="images/3463OS_02_02.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec44"/>How it works...</h2></div></div></div><p>In our <code class="literal">EpollServer</code> web server's constructor, a socket server is created and bound to a localhost at a given port. The server's socket is set to the non-blocking mode (<code class="literal">setblocking(0)</code>). The <code class="literal">TCP_NODELAY</code> option is also set so that our server can exchange data without buffering<a id="id125" class="indexterm"/> (as in the case of an SSH connection).<a id="id126" class="indexterm"/> Next, the <code class="literal">select.epoll()</code> instance is created and the socket's file descriptor is passed to that instance to help monitoring.</p><p>In the <code class="literal">run()</code> method of the web server, it starts receiving the socket events. These events are denoted as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">EPOLLIN</code>: This socket reads events</li><li class="listitem" style="list-style-type: disc"><code class="literal">EPOLLOUT</code>: This socket writes events</li></ul></div><p>In case of a server socket, it sets up the response <code class="literal">SERVER_RESPONSE</code>. When the socket has any connection that wants to write data, it can do that inside the <code class="literal">EPOLLOUT</code> event<a id="id127" class="indexterm"/> case. The <code class="literal">EPOLLHUP</code> event<a id="id128" class="indexterm"/> signals an unexpected close to a socket that is due to the internal error conditions.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Multiplexing an echo server using Diesel concurrent library"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Multiplexing an echo server using Diesel concurrent library</h1></div></div></div><p>Sometimes you need to write a large custom networking application that wants to avoid repeated server initialization<a id="id129" class="indexterm"/> code that creates a socket,<a id="id130" class="indexterm"/> binds to an address, listens, and handles basic errors. There are numerous Python networking libraries out there to help you to remove boiler-plate code. Here, we can examine such a library called Diesel.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec45"/>Getting ready</h2></div></div></div><p>Diesel uses a non-blocking technique with co-routines to write networking severs efficiently. As stated on the website, <span class="emphasis"><em>Diesel's core is a tight event loop that uses epoll to deliver nearly flat performance out to 10,000 connections and beyond</em></span>. Here, we introduce Diesel with a simple echo server. You also need diesel library 3.0 or any later version. You can do that with pip command: <code class="literal">$ pip install diesel &gt;= 3.0</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec46"/>How to do it...</h2></div></div></div><p>In the Python Diesel framework, applications are initialized with an instance of the <code class="literal">Application()</code> class<a id="id131" class="indexterm"/> and an event handler is registered with this instance. Let's see how simple it is to write an echo server.</p><p>Listing 2.5 shows the code on the echo server example using Diesel as follows:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python
# Python Network Programming Cookbook -- Chapter - 2
# This program is optimized for Python 2.7.
# It may run on any other version with/without modifications.
# You also need diesel library 3.0 or any later version

import diesel
import argparse

class EchoServer(object):
    """ An echo server using diesel"""

    def handler(self, remote_addr):
        """Runs the echo server"""
        host, port = remote_addr[0], remote_addr[1]
        print "Echo client connected from: %s:%d" %(host, port)
        
        while True:
            try:
                message = diesel.until_eol()
                your_message = ': '.join(['You said', message])
                diesel.send(your_message)
            except Exception, e:
                print "Exception:",e

def main(server_port):
    app = diesel.Application()
    server = EchoServer()    
    app.add_service(diesel.Service(server.handler, server_port))
    app.run()

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Echo server example with Diesel')
    parser.add_argument('--port', action="store", dest="port", type=int, required=True)
    given_args = parser.parse_args()
    port = given_args.port
    main(port)</pre></div><p>If you run this script, the server <a id="id132" class="indexterm"/>will show the following output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python 2_5_echo_server_with_diesel.py --port=8800</strong></span>
<span class="strong"><strong>[2013/04/08 11:48:32] {diesel} WARNING:Starting diesel &lt;hand-rolled select.epoll&gt;</strong></span>
<span class="strong"><strong>Echo client connected from: 127.0.0.1:56603</strong></span>
</pre></div><p>On another console <a id="id133" class="indexterm"/>window, another Telnet client can be launched and the echoing message to our server can be tested as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ telnet localhost 8800</strong></span>
<span class="strong"><strong>Trying 127.0.0.1...</strong></span>
<span class="strong"><strong>Connected to localhost.</strong></span>
<span class="strong"><strong>Escape character is '^]'.</strong></span>
<span class="strong"><strong>Hello Diesel server ?</strong></span>
<span class="strong"><strong>You said: Hello Diesel server ?</strong></span>
</pre></div><p>The following screenshot illustrates the interaction of the Diesel chat server:</p><div class="mediaobject"><img src="images/3463OS_02_03.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec47"/>How it works...</h2></div></div></div><p>Our script has taken a command-line argument for <code class="literal">--port</code> and passed this to the <code class="literal">main()</code> function where our<a id="id134" class="indexterm"/> Diesel application has been initialized and run.</p><p>Diesel has a notion of service<a id="id135" class="indexterm"/> where an application can be built with many services. <code class="literal">EchoServer</code> has a <code class="literal">handler()</code> method. This enables the server to deal with individual client connections. The <code class="literal">Service()</code> method<a id="id136" class="indexterm"/> takes the <code class="literal">handler</code> method and a port number to run that service.</p><p>Inside the <code class="literal">handler()</code> method, we determine the behavior of the server. In this case, the server is simply returning the message text.</p><p>If we compare this code with <a class="link" href="ch01.html" title="Chapter 1. Sockets, IPv4, and Simple Client/Server Programming">Chapter 1</a>, <span class="emphasis"><em>Sockets, IPv4, and Simple Client/Server Programming</em></span>, in the <span class="emphasis"><em>Writing a simple echo client/server application</em></span> recipe (<span class="emphasis"><em>listing 1.13a</em></span>), it is very clear that we do not need to write any boiler-plate code and hence it's very easy to concentrate on high-level application logic.</p></div></div></div>
</body></html>