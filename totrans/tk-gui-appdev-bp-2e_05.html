<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Building an Audio Player</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's build an audio player! Our application should have the features offered by typical audio players, such as play, pause, fast forward, rewind, next, mute, volume scale, time seek, and more. It should let listeners easily access media files or a media library on their local drive. The audio player should do all this and more. Let's begin!</p>
<p class="mce-root">The following are the key objectives of this chapter:</p>
<ul>
<li class="mce-root">Exploring Tkinter widgets, namely Slider, Listbox, Radiobutton, and Canvas</li>
<li class="mce-root">Creating new widgets in Tkinter by extending the existing widgets</li>
<li class="mce-root">Understanding virtual events and their usage</li>
<li class="mce-root">Learning the most common coding pattern used in Tkinter-based animations</li>
<li class="mce-root">Learning some common Tkinter extensions such as Pmw, WCK, and TIX</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the chapter</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's call our audio player <em>Achtung Baby</em>.</p>
<p class="mce-root">The audio player will be capable of playing audio files in <strong>AU</strong>, <strong>MP2</strong>, <strong>MP3</strong>, <strong>OGG/Vorbis</strong>, <strong>WAV</strong>, and <strong>WMA</strong> formats. It will have all the controls that you would expect of a small media player.</p>
<p class="mce-root">We will use cross-platform modules to write the code. This will ensure that the player can play audio files on Windows, macOS X, and Linux platforms.</p>
<p>On completion, the audio player will look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="298" src="assets/7c22414e-0c82-4cbc-87c0-faafb41f3d77.png" width="322"/></div>
<p>Perhaps the most important takeaway from this chapter is to learn how to create your own widgets in Tkinter.</p>
<p>The seek bar in the preceding screenshot is an example of a custom-made widget that was not natively available in Tkinter, but was handcrafted for this particular use case.</p>
<p>After you learn how to create custom widgets, what you can then create will only be limited by what you can imagine.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">External library requirements</h1>
                </header>
            
            <article>
                
<p>In addition to the several built-in modules of Python, we will use the following two external modules in this project:</p>
<ol>
<li>The <kbd>pyglet</kbd> library for audio manipulation</li>
<li><strong>Pmw</strong> (short for <strong>Python megawidget</strong>) for the widgets that are not available in core Tkinter</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The pyglet module</h1>
                </header>
            
            <article>
                
<p>Pyglet is a cross-platform windowing and multimedia library for Python. It can be downloaded at <a href="https://bitbucket.org/pyglet/pyglet/wiki/Download">https://bitbucket.org/pyglet/pyglet/wiki/Download</a>.</p>
<p>Pyglet can be installed using the pip installer, which is the default package manager for Python  by using the following command:</p>
<pre><strong>pip3 install pyglet</strong></pre>
<p>Windows users can also download and install binary packages for <kbd>pyglet</kbd> from <a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet">http://www.lfd.uci.edu/~gohlke/pythonlibs/#pyglet</a>.</p>
<p>Pyglet needs another module called <kbd>AVbin</kbd> to support playback of file formats such as MP2 and MP3. <kbd>AVbin</kbd> can be obtained for Windows, Linux, and macOS from the download section at <a href="http://avbin.github.io">http://avbin.github.io</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pmw Tkinter extension</h1>
                </header>
            
            <article>
                
<p>We will use the Pmw Tkinter extension to code some widget features that are not available in core Tkinter. Pmw can be installed by using the pip command-line tool, as follows:</p>
<pre><strong>pip3 install pmw </strong></pre>
<p>Pmw can also be installed from the source package for all the platforms. The package can be downloaded from <a href="http://sourceforge.net/projects/pmw/">http://sourceforge.net/projects/pmw/</a>.</p>
<p>After installing <kbd>pyglet</kbd>, <kbd>AVbin</kbd>, and Pmw, execute the following command from the Python shell:</p>
<pre><strong>&gt;&gt; import pyglet, Pmw</strong><br/><strong>&gt;&gt;&gt; pyglet.version</strong><br/><strong> '1.3.0'</strong><br/><strong>&gt;&gt;&gt; Pmw.version()</strong><br/><strong> '2.0.1'</strong> </pre>
<p>If the commands execute without an error message and the version of <kbd>pyglet</kbd> and Pmw are the same as what's shown in the preceding code, you are ready to code your audio player.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Program structure and broadview skeleton</h1>
                </header>
            
            <article>
                
<p>Our first goal is to build the broad modular structure for the program. As usual, we will keep the data structure, audio-related logic, and the presentation logic in three separate files. Therefore, we will create three separate files named <kbd>model.py</kbd>, <kbd>player.py</kbd>, and <kbd>view.py</kbd> (see <kbd>code 5.01</kbd>).</p>
<p>Let's create an empty <kbd>Model</kbd> class and an empty <kbd>Player</kbd> class in their respective files. The following is the code for <kbd>5.01</kbd>—<kbd>model.py</kbd>:</p>
<pre>class Model:<br/>  def __init__(self):<br/>    pass</pre>
<p>Here's the code for <kbd>5.01</kbd>—<kbd>player.py</kbd>:</p>
<pre>import pyglet<br/>class Player():<br/>  def __init__(self):<br/>    pass</pre>
<p>Next, let's create the <kbd>View</kbd> class. We will leave the <kbd>Model</kbd> and <kbd>Player</kbd> classes empty for now. However, we will complete this iteration by coding the majority of the view elements for the player.</p>
<p>Let's begin by importing the required modules in the <kbd>View</kbd> class, as follows:</p>
<pre>import <span>tkinter as tk</span><br/>import <span>tkinter.filedialog</span><br/>import <span>tkinter.messagebox</span><br/>import <span>tkinter.ttk</span></pre>
<p>Also, import the blank <kbd>Model</kbd> and <kbd>Player</kbd> classes in the <kbd>View</kbd> namespace (see code <kbd>5.01</kbd>—<kbd>view.py</kbd>):</p>
<pre>import model<br/>import player</pre>
<p>However, since we do not want to mix the logic with its representation, we do not import <kbd>View</kbd> in the <kbd>Model</kbd> class. In short, the <kbd>Model</kbd> class knows nothing about how its data will be presented to the frontend user.</p>
<div class="packt_infobox">Note that we are not using the <kbd>Controller</kbd> class in this program. We saw how to use controllers in <a href="7e561bee-a102-437c-bfdf-018694145027.xhtml" target="_blank">Chapter 4</a>, <em>Game of Chess</em>. While controllers are a great way to avoid direct coupling between the <kbd>Model</kbd> and <kbd>View</kbd> classes, they can be an overkill for small programs like this one.</div>
<p>Now, let's create the top-level window. Also, we'll create instances of the <kbd>Model</kbd> and <kbd>Player</kbd> classes and pass them as arguments to the <kbd>View</kbd> class, as follows (see code <kbd>5.01</kbd>—<kbd>view.py</kbd>):</p>
<pre>if __name__ == '__main__':<br/>  root = Tk()<br/>  root.resizable(width=False, height=False)<br/>  player = player.Player()<br/>  model = model.Model()<br/>  app = View(root, model, player)<br/>  root.mainloop()</pre>
<p>Now that the boilerplate code is written, let's start coding the actual <kbd>View</kbd> class, as follows (see code <kbd>5.01</kbd>—<kbd>view.py</kbd>):</p>
<pre> class View:<br/>   def __init__(self,root, model, player):<br/>    self.root = root<br/>    self.model = model<br/>    self.player = player<br/>    self.create_gui()<br/> <br/>  def create_gui(self):<br/>    self.root.title(AUDIO_PLAYER_NAME)<br/>    self.create_top_display()<br/>    self.create_button_frame()<br/>    self.create_list_box()<br/>    self.create_bottom_frame()<br/>    self.create_context_menu()<br/> </pre>
<p>The <kbd>__init__</kbd> method should look familiar to you by now. The final line of the <kbd>__init__</kbd> calls a method called <kbd>create_gui</kbd>, which is responsible for the creation of the entire GUI. The <kbd>create_gui</kbd> method in turn simply calls five different methods, where each method is responsible for the creation of different sections of the GUI.</p>
<p>We also made the root window nonresizable by adding <kbd>root.resizable(width=False, height=False)</kbd> to the code.</p>
<p>We will not reproduce the entire code that creates the GUI, since we have coded similar widgets in the past. But all of these five methods, when combined, create the GUI shown in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="219" src="assets/9365cfd3-e4a3-42b4-b66f-e96abf36d72c.png" width="244"/></div>
<p>For the sake of separation, we have also marked the four sections differently in the preceding screenshot. The fifth method creates the right-click context menu and is not visible here.</p>
<p>The code used to create all of these GUI elements should be familiar to you by now. However, note a few things about the code (see code <kbd>5.01</kbd>—<kbd>view.py</kbd>):</p>
<ul>
<li>All the images used in the preceding code have been stored in a separate folder named <kbd>icons</kbd>.</li>
<li>We have used the grid geometry manager to place all the elements on the top-level window.</li>
<li>The Top Display section creates a Canvas widget and places an overlay image using the <kbd>canvas.create_image()</kbd> method. The currently playing text and the timer displayed in the top display have been created by using the <kbd>canvas.create_text()</kbd> method. The coordinates used to place these elements have been decided on a trial-and-error basis. As a reminder, the canvas coordinates are measured from the top-left corner.</li>
<li>The <strong>Button Frame</strong> section simply creates buttons and uses images instead of text, using the following code:
<pre>button=tk.Button(parent, image=previous_track_icon)</pre></li>
<li>The <strong>Button Frame</strong> section also uses a ttk Scale widget, which can be used as a volume slider. This has been created by using the following code:
<pre>self.volume_scale = tkinter.ttk.Scale(frame, from_=0.0, to=1.0, command=self.on_volume_scale_changed)</pre></li>
<li>The <kbd>from</kbd> and <kbd>to</kbd> values for the Scale widget have been chosen as <kbd>0.0</kbd> and <kbd>1.0</kbd> because these are the numbers that the <kbd>pyglet</kbd> library uses to denote the minimum and maximum volume, which will be seen in the following section.</li>
<li>The Listbox section creates a playlist by using the Tkinter Listbox widget, which uses the following code:
<pre>self.list_box = tk.Listbox(frame, activestyle='none', cursor='hand2', bg='#1C3D7D', fg='#A0B9E9', selectmode=tk.EXTENDED, height=10)</pre></li>
<li>The <kbd>select mode=EXTENDED</kbd> option in the preceding code means that this list box will allow multiple list items to be selected at once. If this line is omitted, the default behavior of the Listbox widget is to allow only a single selection at a time.</li>
<li>The <kbd>activestyle='none'</kbd> option means that we do not want to underline the selected item.</li>
<li>The Listbox section is attached to the Scrollbar widget, which is similar to what we have done in the earlier chapters.</li>
<li>The <strong>Bottom Frame</strong> section adds a few image buttons as we did earlier. It also creates three Radiobutton widgets using a <kbd>for</kbd> loop.</li>
<li>Finally, note that we have completely skipped the creation of the seek bar, as it is a custom widget that is not natively defined in Tkinter. This is something that we will create in a dedicated section of its own.</li>
</ul>
<div class="packt_tip">The Listbox widget offers the following four selection modes via the selectmode option:<br/>
<ul>
<li><kbd>SINGLE</kbd>: <span>This allows only a single row to be selected at a time</span></li>
<li><kbd>BROWSE</kbd> <span>(the default mode): This is similar to <kbd>SINGLE</kbd>, but it allows you to move a selection by dragging the mouse</span></li>
<li><kbd>MULTIPLE</kbd>: <span>This allows for multiple selections by clicking on items one at a time</span></li>
<li><kbd>EXTENDED</kbd><span>: This allows for the selection of a multiple range of items using the <em>Shift</em> and <em>Ctrl</em> keys</span></li>
</ul>
</div>
<p>In addition to creating all of these widgets, we have also added a command callback to most of these widgets. These command callbacks currently point to the following empty, nonfunctional methods (see code <kbd>5.01</kbd>—<kbd>view.py</kbd>):</p>
<pre> on_previous_track_button_clicked()<br/> on_rewind_button_clicked()<br/> on_play_stop_button_clicked()<br/> on_pause_unpause_button_clicked()<br/> on_mute_unmute_button_clicked()<br/> on_fast_forward_button_clicked()<br/> on_next_track_button_clicked()<br/> on_volume_scale_changed(, value)<br/> on_add_file_button_clicked()<br/> on_remove_selected_button_clicked()<br/> on_add_directory_button_clicked()<br/> on_empty_play_list_button_clicked()<br/> on_remove_selected_context_menu_clicked()<br/> on_play_list_double_clicked(event=None)<br/> </pre>
<p class="mce-root">None of these methods are functional now. We will end the iteration here, as there are a few other things that we need to do before we can think of making the widgets functional.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deciding the data structure</h1>
                </header>
            
            <article>
                
<p>Sticking to the model first philosophy, let's spend some time on deciding the appropriate data structure or model for the program.</p>
<p>The data structure of the audio player is fairly simple. All that we expect of the model is to keep a track of playlists. The main data then is a list called <kbd>play_list</kbd>, and the <kbd>Model</kbd> class is then simply responsible for the addition and removal of items to and from the playlist.</p>
<p>Accordingly we came up with the following <kbd>Model</kbd> class for the program (see code <kbd>5.02</kbd>—<kbd>model.py</kbd>):</p>
<pre>class Model:<br/>  def __init__(self):<br/>    self.__play_list = []<br/> <br/>  @property<br/>  def play_list(self):<br/>     return self.__play_list<br/> <br/>  def get_file_to_play(self, file_index):<br/>    return self.__play_list[file_index]<br/> <br/>  def clear_play_list(self):<br/>    self.__play_list.clear()<br/> <br/>  def add_to_play_list(self, file_name):<br/>    self.__play_list.append(file_name)<br/> <br/>  def remove_item_from_play_list_at_index(self, index):<br/>    del self.__play_list[index]</pre>
<p>Nothing fancy in the preceding code. The object simply consists of a Python list with various utility methods that can be used to add and remove items from the list.</p>
<p>The <kbd>play_list</kbd> method has been declared as a property so that we need not write the <kbd>getter</kbd> method for the playlist. This is definitely more Pythonic because a statement such as <kbd>play_list = self.play_list</kbd> is more readable than <kbd>play_list = self.get_play_list()</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Player class</h1>
                </header>
            
            <article>
                
<p>Now, let's write the code for the <kbd>Player</kbd> class. This class will be responsible for the handling of audio playback and its related functions, such as pause, stop, seek, fast forward, rewind, change of volume, mute, and so on.</p>
<p>We will use the <kbd>pyglet</kbd> library to handle these functions.</p>
<p>Pyglet is a cross-platform library that uses the <kbd>AVbin</kbd> module to support a large variety of audio files.</p>
<p class="mce-root CDPAlignLeft CDPAlign">You might want to look at the API documentation of the pyglet player, which is available at <a href="https://bitbucket.org/pyglet/pyglet/wiki/Home">https://bitbucket.org/pyglet/pyglet/wiki/Home</a>.</p>
<p>You can also access the documentation for the pyglet media player class by typing the following two lines in the Python interactive shell:</p>
<pre><strong>&gt;&gt;&gt; import pyglet</strong><br/><strong>&gt;&gt;&gt; help(pyglet.media)</strong> </pre>
<p>The online documentation at <a href="https://pyglet.readthedocs.org/">https://pyglet.readthedocs.org/</a> tells us that we can play an audio file by using the following code:</p>
<pre> player= pyglet.media.Player()<br/> source = pyglet.media.load(&lt;&lt;audio file to be played&gt;&gt;)<br/> player.queue(source)<br/> player.play()</pre>
<p>Accordingly, the code for the <kbd>Player</kbd> class is as follows (see code <kbd>5.02</kbd>—<kbd>player.py</kbd>):</p>
<pre> import pyglet<br/><br/> FORWARD_REWIND_JUMP_TIME = 20<br/><br/> class Player:<br/>   def __init__(self):<br/>     self.player = pyglet.media.Player()<br/>     self.player.volume = 0.6<br/> <br/>  def play_media(self, audio_file):<br/>    self.reset_player()<br/>    self.player = pyglet.media.Player()<br/>    self.source = pyglet.media.load(audio_file)<br/>    self.player.queue(self.source)<br/>    self.player.play()<br/> <br/>  def reset_player(self):<br/>    self.player.pause()<br/>    self.player.delete()<br/> <br/> def is_playing(self):<br/>   try:<br/>     elapsed_time = int(self.player.time)<br/>     is_playing = elapsed_time &lt; int(self.track_length)<br/>   except:<br/>     is_playing = False<br/>   return is_playing<br/><br/> def seek(self, time):<br/>   try:<br/>    self.player.seek(time)<br/>   except AttributeError:<br/>    pass<br/> <br/> @property<br/> def track_length(self):<br/>   try:<br/>     return self.source.duration<br/>   except AttributeError:<br/>     return 0<br/> <br/> @property<br/> def volume(self):<br/>   return self.player.volume<br/> <br/> @property<br/> def elapsed_play_duration(self):<br/>  return self.player.time<br/> <br/>@volume.setter<br/>def volume(self, volume):<br/>  self.player.volume = volume<br/><br/>def unpause(self):<br/>  self.player.play()<br/><br/>def pause(self):<br/>  self.player.pause()<br/><br/>def stop(self):<br/>  self.reset_player()<br/><br/>def mute(self):<br/> self.player.volume = 0.0<br/> <br/>def unmute(self, newvolume_level):<br/> self.player.volume = newvolume_level<br/> <br/>def fast_forward(self):<br/>  time = self.player.time + FORWARD_REWIND_JUMP_TIME<br/>  try:<br/>    if self.source.duration &gt; time:<br/>      self.seek(time)<br/>    else:<br/>      self.seek(self.source.duration)<br/>  except AttributeError:<br/>    pass<br/> <br/>def rewind(self):<br/> time = self.player.time - FORWARD_REWIND_JUMP_TIME<br/> try:<br/>   self.seek(time)<br/> except:<br/>   self.seek(0)</pre>
<p>The preceding code is built on the <kbd>pyglet</kbd> API, which is quite intuitive. We will not get into the details of audio programming here and trust the <kbd>pyglet</kbd> library as a black box that delivers what it says, namely, to be able to play and control audio.</p>
<p>The following are the important things that you should note about the preceding code:</p>
<ul>
<li>We defined the <kbd>play_media</kbd> method, which is responsible for the playing of audio. All the other methods support other functions related to playback, such as pause, stop, rewind, forward, mute, and so on.</li>
<li>Note that the code defines a new pyglet <kbd>Player</kbd> class every time it wants to play an audio file. Though we could have used the same player instance to play multiple audio files, it turns out that the <kbd>pyglet</kbd> library does not have a <kbd>stop</kbd> method. The only way we can stop an audio file from playing is by killing the <kbd>Player</kbd> object and creating a fresh <kbd>Player</kbd> object for the next audio file playback.</li>
<li>When it came to choosing an external implementation as we did for the audio API here, we first searched through the Python standard library at <a href="https://docs.python.org/3.6/library/">https://docs.python.org/3.6/library/</a>.</li>
<li>Because the standard library does not have a suitable package for us, we turned our attention to the Python package index to check whether there exists another high-level audio interface implementation. The Python package index can be found at <a href="http://pypi.python.org/">http://pypi.python.org/</a>. </li>
<li>Fortunately, we came across several audio packages. After comparing the packages against our needs and seeing how active their communities were, we settled for <kbd>pyglet</kbd>. The same program could have been implemented with several other packages, though this would be done with varying levels of complexity. </li>
</ul>
<div class="packt_tip">In general, the lower you go down the protocol stack, the more complex your programs will get.<br/>
However, at the lower layers of the protocol, you will get a finer control over the implementation at the cost of increasing learning curves.<br/>
Also, note that most of the audio libraries change over a period of time. While this current audio library may become nonfunctional over time, you can easily modify the <kbd>Player</kbd> class to use some other audio library and still be able to use this program as long as you keep the interface defined in the <kbd>Player</kbd> class.</div>
<p>This concludes the iteration. We now have a functional <kbd>Player</kbd> class that can manipulate audio files. We have a data structure that consists of a <kbd>play_list</kbd> with various methods to add and remove files from a playlist. We will next look at how to add and remove files from a playlist from the frontend of the program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding and removing items from a playlist</h1>
                </header>
            
            <article>
                
<p>Let's write some code for a feature that allows us to add and remove items from a playlist. To be more specific, we will write the code for a function for the four buttons marked in the following screenshot:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/68cc3347-c466-46e2-be08-8fccefdaa0fa.png"/></div>
<p>The four buttons, from left to right, perform the following functions:</p>
<ul>
<li>The first button from the left adds individual audio files to a playlist</li>
<li>The second button deletes all the selected items from the playlist</li>
<li>The third button scans a directory for audio files and adds all the found audio files to the playlist</li>
<li>The last button empties the playlist</li>
</ul>
<p>Since adding these features requires us to interact with the Listbox widget of Tkinter, let's spend some time getting to know the Listbox widget:</p>
<p>We can create a Listbox widget like we'd create any other widget, as follows:</p>
<pre> play_list = tk.ListBox(parent, **configurable options)</pre>
<p>When you initially create a Listbox widget, it is empty. To insert one or more lines of text into the Listbox, use the <kbd>insert()</kbd> method, which takes two arguments, namely an index of the position where the text needs to be inserted and the actual string that needs to be inserted, as follows:</p>
<pre> play_list.insert(0, "First Item")<br/> play_list.insert(1, "Second Item")<br/> play_list.insert(END, "Last Item")</pre>
<p>The <kbd>curselection()</kbd> method returns the index of all the items selected in the list, and the <kbd>get()</kbd> method returns the list item for a given index, as follows:</p>
<pre> play_list.curselection() # returns a tuple of all selected items<br/> play_list.curselection()[0] # returns first selected item<br/> play_list.get(1) # returns second item from the list<br/> play_list.get(0, END) # returns all items from the list</pre>
<p>In addition to this, the Listbox widget has several other configurable options.</p>
<p>For a complete Listbox widget reference, type the following into the Python interactive shell:</p>
<pre><strong> &gt;&gt;&gt; import tkinter</strong><br/><strong> &gt;&gt;&gt; help(tkinter.Listbox)</strong></pre>
<p>Now that we know how to add and remove items from the Listbox widget, let's code these functions into the player.</p>
<p>Let's begin by modifying the command callback attached to the four buttons, as follows (see code <kbd>5.03</kbd>—<kbd>view.py</kbd>):</p>
<pre>def on_add_file_button_clicked(self):<br/> self.add_audio_file()<br/><br/>def on_remove_selected_button_clicked(self):<br/> self.remove_selected_file()<br/><br/>def on_add_directory_button_clicked(self):<br/> self.add_all_audio_files_from_directory()<br/><br/>def on_clear_play_list_button_clicked(self):<br/> self.clear_play_list()<br/><br/>def on_remove_selected_context_menu_clicked(self):<br/> self.remove_selected_file()</pre>
<p>All that these four methods do is call four other methods that do the actual task of adding or removing items to the playlist. All the methods will update the <kbd>play_list</kbd> items at the following two places:</p>
<ul>
<li>In the visible Listbox widget</li>
<li>In the backend data structure playlist maintained by the <kbd>Model</kbd> class</li>
</ul>
<p>Let's define the four new methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a single audio file</h1>
                </header>
            
            <article>
                
<p>Adding a file involves asking for the location using Tkinter <kbd>filedialog</kbd> and updating the frontend and backend, as follows (see code <kbd>5.03</kbd>—<kbd>view.py</kbd>):</p>
<pre>def add_audio_file(self):<br/> audio_file = tkinter.filedialog.askopenfilename(filetypes=[(<br/>       'All supported', '.mp3 .wav'), ('.mp3 files', '.mp3'),('.wav files', '.wav')])<br/> if audio_file:<br/>   self.model.add_to_play_list(audio_file)<br/>   file_path, file_name = os.path.split(audio_file)<br/>   self.list_box.insert(tk.END, file_name)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing the selected files from a playlist</h1>
                </header>
            
            <article>
                
<p>Since the Listbox allows for multiple selections, we iterate through all the selected items, removing them from the frontend Listbox widget as well as from the model <kbd>play_list</kbd>, as follows (see code <kbd>5.03</kbd>—<kbd>view.py</kbd>):</p>
<pre>def remove_selected_files(self):<br/> try:<br/>  selected_indexes = self.list_box.curselection()<br/>  for index in reversed(selected_indexes):<br/>    self.list_box.delete(index)<br/>    self.model.remove_item_from_play_list_at_index(index)<br/> except IndexError:<br/>   pass</pre>
<p>Note that we reverse the tuple before removing items from the playlist because we want to start removing items from the end, as a removal causes a change in the index of playlist items. If we do not remove items from the end, we may end up removing the wrong items from the list, as its index gets modified in each iteration.</p>
<p>Since we have defined this method here, let's add it as a command callback to the right-click delete menu, as follows:</p>
<pre>def on_remove_selected_context_menu_clicked(self):<br/>  self.remove_selected_files()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding all files from a directory</h1>
                </header>
            
            <article>
                
<p>The following code uses the <kbd>os.walk()</kbd> method to recursively walk through all the files looking for  <kbd>.wav</kbd> and <kbd>.mp3</kbd> files, as follows (see code <kbd>5.03</kbd>—<kbd>view.py</kbd>):</p>
<pre>def add_all_audio_files_from_directory(self):<br/>  directory_path = tkinter.filedialog.askdirectory()<br/>  if not directory_path: return<br/>  audio_files_in_directory =  self.get_all_audio_file_from_directory(directory_path)<br/>  for audio_file in audio_files_in_directory:<br/>     self.model.add_to_play_list(audio_file)<br/>     file_path, file_name = os.path.split(audio_file)<br/>     self.list_box.insert(tk.END, file_name)<br/> <br/>def get_all_audio_file_from_directory(self, directory_path):<br/>  audio_files_in_directory = []<br/>  for (dirpath, dirnames, filenames) in os.walk(directory_path):<br/>    for audio_file in filenames:<br/>      if audio_file.endswith(".mp3") or audio_file.endswith(".wav"):<br/>        audio_files_in_directory.append(dirpath + "/"  + audio_file)<br/>  return audio_files_in_directory</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Emptying the playlist</h1>
                </header>
            
            <article>
                
<p>The code is as follows (<span>see code </span><kbd>5.03</kbd><span>—</span><kbd>view.py</kbd><span>):</span></p>
<pre>def empty_play_list(self):<br/> self.model.empty_play_list()<br/> self.list_box.delete(0, END)</pre>
<p>This completes our third iteration. In this iteration, we saw how to work with the Listbox widget. In particular, we saw how to add items to the Listbox widget, select a particular item from the Listbox widget, and delete one or more items from it.</p>
<p>You now have a playlist where you can add and delete items using the four buttons at the bottom-left corner of the audio player.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Playing audio and adding audio controls</h1>
                </header>
            
            <article>
                
<p>In this iteration, we will code the features marked in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="77" src="assets/3bd65c1e-acc7-4c28-9967-c2fc5eefc226.png" width="322"/></div>
<p>This includes the play/stop, pause/unpause, next track, previous track, fast forward, rewind, volume change, and mute/unmute features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the play/stop function</h1>
                </header>
            
            <article>
                
<p>Now that we have a playlist and a <kbd>Player</kbd> class that can play audio, playing audio is simply about updating the current track index and calling the <kbd>play</kbd> method. </p>
<p>Accordingly, let's add an attribute, as follows (see code <kbd>5.04</kbd>—<kbd>view.py</kbd>):</p>
<pre>current_track_index = 0 </pre>
<p>Furthermore, the <strong>Play</strong> button should act as a toggle between the <kbd>play</kbd> and <kbd>stop</kbd> functions. The Python <kbd>itertools</kbd> module provides the <kbd>cycle</kbd> method, which is a very convenient way to toggle between two or more values.</p>
<p>Accordingly, import the <kbd>itertools</kbd> module and define a new attribute, as follows (see code <kbd>5.04</kbd>—<kbd>view.py</kbd>):</p>
<pre>toggle_play_stop = itertools.cycle(["play","stop"]) </pre>
<p>Now, every time we call <kbd>next(toggle_play_stop)</kbd>, the value returned toggles between the <kbd>play</kbd> and <kbd>stop</kbd> strings.</p>
<div class="packt_tip">Itertools is a very powerful standard library of Python that can emulate many <strong>iterables</strong> from a functional programming paradigm. An iterable in Python is an interface that implements the <kbd>next()</kbd> method. Every subsequent call to <kbd>next()</kbd> is <strong>lazily evaluated</strong>—thereby making them suitable for iterating over large sequences in the most efficient manner. The <kbd>cycle()</kbd> tool used here is an example of an iterator that can provide infinite sequences of alternating values without the need to define a large data structure. <br/>
<br/>
The following is the documentation of the <kbd>itertools</kbd> module:<br/>
 <a href="https://docs.python.org/3/library/itertools.html">https://docs.python.org/3/library/itertools.html</a></div>
<p>Next, modify the <kbd>on_play_stop_button_clicked()</kbd> method so that it looks like this (see code <kbd>5.04</kbd>—<kbd>view.py</kbd>):</p>
<pre>def on_play_stop_button_clicked(self):<br/>  action = next(self.toggle_play_stop)<br/>  if action == 'play':<br/>   try:<br/>     self.current_track_index = self.list_box.curselection()[0]<br/>   except IndexError:<br/>     self.current_track_index = 0<br/>   self.start_play()<br/> elif action == 'stop':<br/>   self.stop_play()<br/> </pre>
<p>The preceding method simply toggles between calling the <kbd>start_play()</kbd> and <kbd>stop_play()</kbd> methods, which are defined as follows:</p>
<pre>def start_play(self):<br/> try:<br/>   audio_file = self.model.get_file_to_play(self.current_track_index)<br/> except IndexError:<br/>   return<br/> self.play_stop_button.config(image=self.stop_icon)<br/> self.player.play_media(audio_file)<br/><br/>def stop_play(self):<br/> self.play_stop_button.config(image=self.play_icon)<br/> self.player.stop()</pre>
<p>The preceding code calls the <kbd>play</kbd> and <kbd>stop</kbd> methods defined in the <kbd>Player</kbd> class. It also changes the button image from the <em>play</em> icon to the <em>stop</em> icon by using the <kbd>widget.config(image=new_image_icon)</kbd> method.</p>
<p>While we are handling the <kbd>play</kbd> function, let's modify the command callback so that a user can play a track simply by double-clicking on it. We have already defined a method named <kbd>on_play_list_double_clicked</kbd> earlier, which is currently empty.</p>
<p>Simply modify it, as follows:</p>
<pre>def on_play_list_double_clicked(self, event=None):<br/> self.current_track_index = int(self.list_box.curselection()[0])<br/> self.start_play()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the pause/unpause function</h1>
                </header>
            
            <article>
                
<p>Since we need a single button to toggle between pause and unpause, we will again use the <kbd>cycle()</kbd> method from the <kbd>itertools</kbd> module. Define an attribute, as follows (see code <kbd>5.04</kbd>—<kbd>view.py</kbd>):</p>
<pre>toggle_pause_unpause = itertools.cycle(["pause","unpause"])</pre>
<p>Then, modify the command callback attached to the button, as follows:</p>
<pre>def on_pause_unpause_button_clicked(self):<br/> action = next(self.toggle_pause_unpause)<br/> if action == 'pause':<br/>   self.player.pause()<br/> elif action == 'unpause':<br/>   self.player.unpause()<br/><br/></pre>
<p>This takes care of the pause and unpause features of the program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the mute/unmute function</h1>
                </header>
            
            <article>
                
<p>This is similar to coding the pause/unpause feature. We need an attribute that can toggle between the <kbd>mute</kbd> and <kbd>unmute</kbd> strings. Accordingly, add an attribute, as follows (see code <kbd>5.04</kbd>—<kbd>view.py</kbd>):</p>
<pre>toggle_mute_unmute = itertools.cycle(["mute","unmute"]) </pre>
<p>Then, modify the command callback to call the <kbd>mute</kbd> or <kbd>unmute</kbd> functions from the <kbd>player</kbd> class, change the button icon to the mute or unmute image, and shift the volume scale accordingly, as follows <span>(see code </span><kbd>5.04</kbd><span>—</span><kbd>view.py</kbd><span>):</span></p>
<pre>def on_mute_unmute_button_clicked(self):<br/>  action = next(self.toggle_mute_unmute)<br/>  if action == 'mute':<br/>    self.volume_at_time_of_mute = self.player.volume<br/>    self.player.mute()<br/>    self.volume_scale.set(0)<br/>    self.mute_unmute_button.config(image=self.mute_icon)<br/>  elif action == 'unmute':<br/>    self.player.unmute(self.volume_at_time_of_mute)<br/>    self.volume_scale.set(self.volume_at_time_of_mute)<br/>    self.mute_unmute_button.config(image=self.unmute_icon)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Fast forward/rewind function</h1>
                </header>
            
            <article>
                
<p>The codes for fast forward and rewind are the simplest. We have already defined the methods to handle this in the <kbd>Player</kbd> class. Now, it's only a matter of connecting them to the concerned command callback, as follows:</p>
<pre>def on_fast_forward_button_clicked(self):<br/>  self.player.fast_forward()<br/><br/>def on_rewind_button_clicked(self):<br/>  self.player.rewind()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the next track/previous track function</h1>
                </header>
            
            <article>
                
<p>While we had defined the code for fast forward and rewind in the <kbd>Player</kbd> class, we did not define the method related to next track and previous track there, because this can be handled by the existing <kbd>play</kbd> method. All that you need to do is simply increment or decrement the value of <kbd>current_track</kbd> and then call the <kbd>play</kbd> method. Accordingly, define two methods in the <kbd>View</kbd> class, as follows <span>(see code </span><kbd>5.04</kbd><span>—</span><kbd>view.py</kbd><span>):</span></p>
<pre>def play_previous_track(self):<br/>  self.current_track_index = max(0, self.current_track_index - 1)<br/>  self.start_play()<br/> <br/>def play_next_track(self):<br/>  self.current_track_index = min(self.list_box.size() - 1, <br/>    self.current_track_index + 1)<br/>  self.start_play()<br/> </pre>
<p>Then, simply attach these two methods to the respective command callback, as follows <span>(see code </span><kbd>5.04</kbd><span>—</span><kbd>view.py</kbd><span>):</span></p>
<pre>def on_previous_track_button_clicked(self):<br/>  self.play_previous_track()<br/><br/>def on_next_track_button_clicked(self):<br/>  self.play_next_track()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the volume change function</h1>
                </header>
            
            <article>
                
<p>We have already defined the <kbd>volume</kbd> method in the <kbd>Player</kbd> class. Now, all that you need to do is simply get the value of the Volume Scale widget and set the volume in the <kbd>Player</kbd> class.</p>
<p>Also, ensure that in case the volume becomes zero, we change the volume button icon to the mute image <span>(see code </span><kbd>5.04</kbd><span>—</span><kbd>view.py</kbd><span>):</span></p>
<pre>def on_volume_scale_changed(self, value):<br/>  self.player.volume = self.volume_scale.get()<br/>  if self.volume_scale.get() == 0.0:<br/>    self.mute_unmute_button.config(image=self.mute_icon)<br/>  else:<br/>    self.mute_unmute_button.config(image=self.unmute_icon)</pre>
<p>This concludes the iteration. The player is now functional enough to be called an audio player. Go ahead and add some music files to the player. Press the play button and enjoy the music! Try out other player controls that we defined in this iteration and they should work as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a seek bar</h1>
                </header>
            
            <article>
                
<p>Now, let's add a seek bar to the audio player. Tkinter offers the Scale widget that we used for the volume scale. The Scale widget could have functioned as a seek bar.</p>
<p>But we want something fancier. Moreover, the Scale widget would look different on different platforms. Instead, we want the seek bar to look uniform on all platforms. This is where we can create our own widget to meet the custom needs of the audio player.</p>
<p>Let's create our own Seekbar widget, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="68" src="assets/fd25afb3-8f5a-4483-a745-9c000bb5bf70.png" width="256"/></div>
<p>The simplest way to create our own widget is to inherit one from an existing widget or the <kbd>Widget</kbd> class.</p>
<p>When you look at the source code of Tkinter, you will find that all the widgets inherit from a class named <kbd>Widget</kbd>. The <kbd>Widget</kbd> class, in turn, inherits from another class called <kbd>BaseWidget</kbd>. The <kbd>BaseWidget</kbd> class contains the code that is used to handle a widget's <kbd>destroy()</kbd> method, but it is not aware of a geometry manager.</p>
<p>Therefore, if we want our custom widget to be aware of and use geometry managers such as <kbd>pack</kbd>, <kbd>grid</kbd>, or <kbd>place</kbd>, we need to inherit from the <kbd>Widget</kbd> class or from another Tkinter widget.</p>
<p>Let's assume that we want to create a widget named <kbd>Wonderwidget</kbd>. We can do so simply by inheriting from the <kbd>Widget</kbd> class, as follows: </p>
<pre>from tkinter import *<br/><br/>class Wonderwidget(Widget):<br/> def __init__(self, parent, **options):<br/>    Widget.__init__(self, parent, options)</pre>
<p>These four lines of code create a widget named <kbd>Wonderwidget</kbd>, which can be positioned with geometry managers such as <kbd>pack</kbd>, <kbd>place</kbd>, or <kbd>grid</kbd>.</p>
<p>However, for more practical use cases, we generally inherit from the existing Tkinter widgets, such as <kbd>Text</kbd>, <kbd>Button</kbd>, <kbd>Scale</kbd>, <kbd>Canvas</kbd>, and so on. In our case, we will create the <kbd>Seekbar</kbd> widget by inheriting from the <kbd>Canvas</kbd> class.</p>
<p>Create a new file called <kbd>seekbar.py</kbd> (see code <kbd>5.05.py</kbd>). Then, create a new class named <kbd>Seekbar</kbd> that inherits from the <kbd>Canvas</kbd> widget, as follows:</p>
<pre>from tkinter import *<br/><br/>class Seekbar(Canvas):<br/>  <br/>  def __init__(self, parent, called_from, **options):<br/>    Canvas.__init__(self, parent, options)<br/>    self.parent = parent<br/>    self.width = options['width']<br/>    self.red_rectangle = self.create_rectangle(0, 0, 0, 0,fill="red")<br/>    self.seekbar_knob_image = PhotoImage(file="../icons/seekbar_knob.gif")<br/>    self.seekbar_knob = self.create_image(0, 0, <br/>      image=self.seekbar_knob_image)</pre>
<p>The preceding code calls the <kbd>__init__</kbd> method of the parent <kbd>Canvas</kbd> class to initialize the underlying canvas with all the canvas-related options that are passed as an argument.</p>
<p>With as little code as that, let's go back and modify the <kbd>create_top_display()</kbd>method in the <kbd>View</kbd> class to add this new widget, as follows:</p>
<pre>self.seek_bar = Seekbar(frame, background="blue", width=SEEKBAR_WIDTH, height=10)<br/>self.seek_bar.grid(row=2, columnspan=10, sticky='ew', padx=5)</pre>
<p>Here, <kbd>SEEKBAR_WIDTH</kbd> is a constant that we defined as equal to 360 pixels in the program.</p>
<p>If you now run <kbd>view.py</kbd>, you will see the <kbd>Seekbar</kbd> widget at its place. </p>
<p>The seek bar is not functional, as it does not move when the seek bar knob is clicked. </p>
<p>In order to make the seek bar slide along, we will bind the mouse buttons by defining a new method and calling it from the <kbd>__init__</kbd> method, as follows (see code <kbd>5.05</kbd>—<kbd>seekbar.py</kbd>):</p>
<pre>def bind_mouse_button(self):<br/>  self.bind('&lt;Button-1&gt;', self.on_seekbar_clicked)<br/>  self.bind('&lt;B1-Motion&gt;', self.on_seekbar_clicked)<br/>  self.tag_bind(self.red_rectangle, '&lt;B1-Motion&gt;',<br/>  self.on_seekbar_clicked)<br/>  self.tag_bind(self.seekbar_knob, '&lt;B1-Motion&gt;',<br/>  self.on_seekbar_clicked) </pre>
<p>We bind the entire canvas, the red rectangle, and the seek bar knob to a single method named <kbd>on_seekbar_clicked</kbd>, which can be defined as follows (see code <kbd>5.05</kbd>—<kbd>seekbar.py</kbd>):</p>
<pre>def on_seekbar_clicked(self, event=None):<br/>  self.slide_to_position(event.x) </pre>
<p>The preceding method simply calls another method named <kbd>slide_to_position</kbd>,  which is responsible for changing the position of the knob and the size of the red rectangle <span>(see code </span><kbd>5.05</kbd><span>—</span><kbd>seekbar.py</kbd><span>):</span></p>
<pre>def slide_to_position(self, new_position):<br/>  if 0 &lt;= new_position &lt;= self.width:<br/>  self.coords(self.red_rectangle, 0, 0, new_position, new_position)<br/>  self.coords(self.seekbar_knob, new_position, 0)<br/>  self.event_generate("&lt;&lt;SeekbarPositionChanged&gt;&gt;", x=new_position)</pre>
<p>The preceding code slides the knob to the new position. More importantly, the last line creates a custom event named <kbd>SeekbarPositionChanged</kbd>. This event will let any code that uses this custom widget handle the event appropriately.</p>
<p>The second argument, <kbd>x=new_position</kbd>, adds the value of <kbd>x</kbd> to <kbd>event.x</kbd>, making it available to the event handler.</p>
<p>So far, we have only been handling events. Tkinter also lets us create our own events, which are called <strong>virtual events</strong>.</p>
<p>We can specify any name for the event by enclosing the name in double pairs of <kbd>&lt;&lt;...&gt;&gt;</kbd>.</p>
<p>In the preceding code, we generated a virtual event named <kbd>&lt;&lt;SeekbarPositionChanged&gt;&gt;</kbd>.</p>
<p>We then bound it to the appropriate event handler in the <kbd>View</kbd> class, as follows:</p>
<pre>self.root.bind("&lt;&lt;SeekbarPositionChanged&gt;&gt;",self.seek_new_position)</pre>
<p>That's all that there is to the custom <kbd>Seekbar</kbd> widget. We can write a small test in <kbd>seekbar.py</kbd> that will check whether the <kbd>Seekbar</kbd> widget works as expected:</p>
<pre>class TestSeekBar :<br/>  def __init__(self):<br/>    root = tk.Tk()<br/>    root.bind("&lt;&lt;SeekbarPositionChanged&gt;&gt;", self.seek_new_position)<br/>    frame = tk.Frame(root)<br/>    frame.grid(row=1, pady=10, padx=10)<br/>    c = Seekbar(frame, background="blue", width=360, height=10)<br/>    c.grid(row=2, columnspan=10, sticky='ew', padx=5)<br/>    root.mainloop()<br/> <br/>  def seek_new_position(self, event):<br/>    print("Dragged to x:", event.x)<br/> <br/>if __name__ == '__main__':<br/> TestSeekBar()<br/> </pre>
<p>Go ahead and run the <kbd>5.05</kbd>—<kbd>seekbar.py</kbd> program; it should produce a seek bar. The seek bar should slide when you drag the seek bar knob or click at various places on the canvas.</p>
<p>This concludes the iteration. We will make the audio player's seek bar functional in the next iteration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One-time updates during audio playback</h1>
                </header>
            
            <article>
                
<p>The audio program must update some information as soon as an audio track starts playing. Broadly speaking, there are two kinds of updates that the program needs to monitor and update:</p>
<ul>
<li><strong>One-time updates</strong>: Examples of this include the name of the track and the total length of the track.</li>
<li><strong>Continuous updates</strong>: Examples of this include the position of the seek bar knob and the elapsed play duration. We also need to check <span>continuously </span>whether a track has ended either to play the next track, play the current track again, or stop playing, depending on the loop choice made by the user.</li>
</ul>
<p>These two kinds of updates will affect sections of the audio player, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/50ad1983-d89e-4f73-a016-a2b2eec1858e.png"/></div>
<p>Let's start with the one-time updates, as they are relatively simple to implement.</p>
<p>Since these updates must occur when the playback starts, let's define a method named <kbd>manage_one_time_updates()</kbd> and call it from within the <kbd>start_play()</kbd> method of the <kbd>View</kbd> class, as follows (see code <kbd>5.06</kbd>—<kbd>view.py</kbd>):</p>
<pre>def manage_one_time_track_updates_on_play_start(self):<br/>  self.update_now_playing_text()<br/>  self.display_track_duration()</pre>
<p>Next, define all the methods called from within the preceding method, as follows:</p>
<pre>def update_now_playing_text(self):<br/>  current_track = self.model.play_list[self.current_track_index]<br/>  file_path, file_name = os.path.split(current_track)<br/>  truncated_track_name = truncate_text(file_name, 40)<br/>  self.canvas.itemconfig(self.track_name, text=truncated_track_name)<br/><br/>def display_track_duration(self):<br/>  self.track_length = self.player.track_length<br/>  minutes, seconds = get_time_in_minute_seconds(self.track_length)<br/>  track_length_string = 'of {0:02d}:{1:02d}'.format(minutes, seconds)<br/>  self.canvas.itemconfig(self.track_length_text, text=track_length_string)</pre>
<p>These two methods simply find out the track name and track duration and update the related canvas text by using a call to <kbd>canvas.itemconfig</kbd>.</p>
<p>Just like we use <kbd>config</kbd> to change the value of widget-related options, the <kbd>Canvas</kbd> widget uses <kbd>itemconfig</kbd> to change the options for individual items within the canvas.  The format for <kbd>itemconfig</kbd> is as follows:</p>
<pre>canvas.itemconfig(itemid, **options).</pre>
<p>Let's define two helper methods in a new file named <kbd>helpers.py</kbd> and import the methods in the view namespace. The two methods are <kbd>truncate_text</kbd> and <kbd>get_time_in_minutes_seconds</kbd>. The code for this can be found in the <kbd>5.06</kbd>—<kbd>helpers.py</kbd> file.</p>
<p>That takes care of one-time updates. Now, when you run <kbd>5.06</kbd>—<kbd>view.py</kbd> and play some audio file, the player should update the track name, and the total track duration in the top console, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1679bd68-61e9-407d-8b0d-5fcfcb822d49.png"/></div>
<p>We will take care of periodic updates in the next iteration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing continuous updates</h1>
                </header>
            
            <article>
                
<p>Next, we will update the position of the seek bar knob and the elapsed play duration, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/afb5eac3-dbaf-4742-ba55-ca90aa9d129a.png"/></div>
<p>This is nothing but a simple form of Tkinter-based animation.</p>
<p>The most common pattern of animating with Tkinter involves drawing a single frame and then calling the same method using the after method of Tkinter, as follows:</p>
<pre>def animate(self):<br/> self.draw_frame()<br/> self.after(500, self.animate)</pre>
<div class="packt_infobox">Take a note of the <kbd>self.after</kbd> method, which calls the <kbd>animate</kbd> method in a loop. Once called, this function will keep updating frames once every <kbd>500</kbd> milliseconds. You can also add some conditions to break out of the animation loop. This is generally how all animations are handled in Tkinter. We will use this technique over and over again in several upcoming examples. </div>
<p>Now that we know how to manage animations in Tkinter, let's use the pattern to define a method that takes care of these periodic updates.</p>
<p>Define a method named <kbd>manage_periodic_updates_during_play</kbd>, which calls itself every 1 second to update the timer and the seek bar, as follows (see code <kbd>5.07</kbd>—<kbd>view.py</kbd>):</p>
<pre>def manage_periodic_updates_during_play(self):<br/> self.update_clock()<br/> self.update_seek_bar()<br/> self.root.after(1000, self.manage_periodic_updates_during_play)</pre>
<p>Then, define two methods named <kbd>update_clock</kbd> and <kbd>update_seek_bar</kbd>, which update the sections highlighted in the preceding screenshot.</p>
<p>The <kbd>update_clock</kbd> method gets the elapsed duration in seconds from the <kbd>Player</kbd> class, converts it into minutes and seconds, and updates the canvas text using <kbd>canvas.itemconfig</kbd>, as follows (see code <kbd>5.07</kbd>—<kbd>view.py</kbd>):</p>
<pre>def update_clock(self):<br/>  self.elapsed_play_duration = self.player.elapsed_play_duration<br/>  minutes, seconds = get_time_in_minute_seconds(self.elapsed_play_duration)<br/>  current_time_string = '{0:02d}:{1:02d}'.format(minutes, seconds)<br/>  self.canvas.itemconfig(self.clock, text=current_time_string)</pre>
<p>You may recall that we had previously defined a <kbd>slide_to_position</kbd> method in the <kbd>Seekbar</kbd> class. The <kbd>update_seek_bar</kbd> method simply calculates the proportionate position of the seek bar and then calls the <kbd>slide_to_position</kbd> method to slide the knob of the seekbar, as follows (see code <kbd>5.07</kbd>—<kbd>view.py</kbd>):</p>
<pre>def update_seek_bar(self):<br/>  seek_bar_position = SEEKBAR_WIDTH *<br/>  self.player.elapsed_play_duration /self.track_length<br/>  self.seek_bar.slide_to_position(seek_bar_position)</pre>
<p>Now, if you run <kbd>5.07</kbd>–<kbd>view.py</kbd>, add an audio file, and play it, the elapsed duration should be updated <span>continuously </span>in the top display. The seek bar should also move forward as the play progresses.</p>
<p>That's great, but there is still one small detail missing. We want that when a user clicks somewhere on the seek bar, the playing audio seeks the new position. The code for seeking a new position is simple (see code <kbd>5.07</kbd>—<kbd>view.py</kbd>):</p>
<pre>def seek_new_position(self, event=None):<br/> time = self.player.track_length * event.x /SEEKBAR_WIDTH<br/> self.player.seek(time) </pre>
<p>However, the preceding method needs to be called whenever the seek bar position is changed. Let's do this by adding a binding to the virtual event from within <kbd>5.07</kbd>—<kbd>view.py</kbd>, as follows:</p>
<pre>self.root.bind("&lt;&lt;SeekbarPositionChanged&gt;&gt;", self.seek_new_position)</pre>
<p>Now, when you run <span> </span><kbd>5.07</kbd><span>—</span><kbd>view.py</kbd>, play an audio file and click on the seek bar; the audio should start playing from the new position.</p>
<p>This concludes the iteration. We will look at how to loop over tracks in the next iteration.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Looping over tracks</h1>
                </header>
            
            <article>
                
<p>Let's add the feature that allows users to loop over tracks. We have already defined radio buttons to allow three choices, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/49e96b01-b2c0-4c28-af95-f6baf379556e.png"/></div>
<p>In essence, the player should provide a choice from the following three options:</p>
<ul>
<li><span class="packt_screen">No Loop</span>: Play a track and end there</li>
<li><span class="packt_screen">Loop Current</span>: Play a single track repeatedly</li>
<li><span class="packt_screen">Loop All</span>: Looping through the entire playlist, one after another</li>
</ul>
<p>The decision to follow one of these three options needs to be taken immediately after a particular track ends playing. The best place to judge whether a track has come to its end is from within the periodic updates loop that we created earlier.</p>
<p>Therefore, modify the <kbd>manage_periodic_updates_during_play()</kbd> method to add the following two lines of highlighted code (see code <kbd>5.08</kbd>—<kbd>view.py</kbd><span>):</span></p>
<pre>def manage_periodic_updates_during_play(self):<br/>  self.update_clock()<br/>  self.update_seek_bar()<br/>  if not self.player.is_playing():<br/>    if self.not_to_loop(): return<br/>  self.root.after(1000, self.manage_periodic_updates_during_play)</pre>
<p>This in effect means that the looping decision is checked only when the currently playing track ends. Then, define the <kbd>not_to_loop()</kbd> method, as follows (see code <kbd>5.09</kbd>—<kbd>view.py</kbd>):</p>
<pre>def not_to_loop(self):<br/>  selected_loop_choice = self.loop_value.get()<br/>  if selected_loop_choice == 1: # no loop<br/>    return True<br/>  elif selected_loop_choice == 2: # loop current<br/>    self.start_play()<br/>    return False<br/>  elif selected_loop_choice == 3: #loop all<br/>    self.play_next_track()<br/>  return True </pre>
<p>The code first checks the value of the selected radio button and, based on the selected choice, makes the looping choice:</p>
<ul>
<li>If the selected loop value is <kbd>1</kbd> (No Loop), it does nothing and returns <kbd>True</kbd>, breaking out of the continuous update loop.</li>
<li>If the selected loop value is <kbd>2</kbd> (loop over the current song), it again calls the <kbd>start_play</kbd> method and returns <kbd>False</kbd>. Thus, we do not break out of the update loop.</li>
<li>If the loop value is <kbd>3</kbd> (Loop All), it calls the <kbd>play_next_track</kbd> method and returns <kbd>True</kbd>. Thus, we break out of the previous update loop.</li>
</ul>
<p>The audio player can now loop over the playlist based on the looping preference set by the user.</p>
<p>Let's conclude this iteration by overriding the close button so that the audio player properly deletes the player object when the user decides to close the player while it is playing.</p>
<p>To override the destroy method, first add a protocol override command to the <kbd>View __init__</kbd> method, as follows (see code <kbd>5.08</kbd>—<kbd>view.py</kbd>):</p>
<pre>self.root.protocol('WM_DELETE_WINDOW', self.close_player) </pre>
<p>Finally, define the <kbd>close_player</kbd> method, as follows:</p>
<pre>def close_player(self):<br/> self.player.stop()<br/> self.root.destroy() </pre>
<p>This concludes the iteration. We coded the logic required to loop over tracks and then overrode the close button to ensure that a playing track is stopped before we exit the player.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding a tooltip</h1>
                </header>
            
            <article>
                
<p>In this final iteration, we will add a tooltip named the <strong>Balloon widget</strong> to all the buttons in our player.</p>
<p>A tooltip is a small <strong>popup</strong> that shows up when you hover your mouse over the Bound widget (buttons, in our case). A typical tooltip for the application will look as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a2d47813-10e2-47b2-8351-f8fa620f0dbf.png"/></div>
<p>Although core Tkinter has many useful widgets, it is far from complete. For us, the tooltip or Balloon widget is not provided as a core Tkinter widget. Therefore, we look for these widgets in what are called <strong>Tkinter extensions</strong>.</p>
<p>These extensions are nothing but a collection of extended Tkinter widgets, just like the custom seek bar that we created.</p>
<p>There are literally hundreds of Tkinter extensions. In fact, we just wrote our own Tkinter extension in this chapter.</p>
<p>However, the following are some of the popular Tkinter extensions:</p>
<ul>
<li><strong>Pmw</strong>: (<a href="http://pmw.sourceforge.net">http://pmw.sourceforge.net</a>)</li>
<li><strong>Tix</strong>: (<a href="http://wiki.Python.org/moin/Tix">http://wiki.Python.org/moin/Tix</a>)</li>
<li><strong>TkZinc</strong>: (<a href="http://wiki.Python.org/moin/TkZinc">http://wiki.Python.org/moin/TkZinc</a>)</li>
<li><strong>Widget Construction Kit (WCK)</strong>: (<a href="http://effbot.org/zone/wck.htm">http://effbot.org/zone/wck.htm</a>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pmw list of extensions</h1>
                </header>
            
            <article>
                
<p>Talking about Pmw, here is a quick list of widget extensions and dialogs from the package.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Widgets</h1>
                </header>
            
            <article>
                
<p>The following table shows a list of widget extensions:</p>
<table>
<tbody>
<tr>
<td>ButtonBox</td>
<td>ComboBox</td>
<td>Counter</td>
<td>EntryField</td>
</tr>
<tr>
<td>Group</td>
<td>HistoryText</td>
<td>LabeledWidget</td>
<td>MainMenuBar</td>
</tr>
<tr>
<td>MenuBar</td>
<td>MessageBar</td>
<td>NoteBook</td>
<td>OptionMenu</td>
</tr>
<tr>
<td>PanedWidget</td>
<td>RadioSelect</td>
<td>ScrolledCanvas</td>
<td>ScrolledField</td>
</tr>
<tr>
<td>ScrolledFrame</td>
<td>ScrolledListBox</td>
<td>ScrolledText</td>
<td>TimeCounter</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dialogs</h1>
                </header>
            
            <article>
                
<p>The following table shows a list of widget dialogs:</p>
<table>
<tbody>
<tr>
<td>AboutDialog</td>
<td>ComboBoxDialog</td>
<td>CounterDialog</td>
<td>Dialog</td>
</tr>
<tr>
<td>MessageDialog</td>
<td>PromptDialog</td>
<td>SelectionDialog</td>
<td>TextDialog</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Miscellaneous</h1>
                </header>
            
            <article>
                
<p>The following is a list of miscellaneous widgets offered by Pmw:</p>
<ul>
<li><kbd>Balloon</kbd></li>
<li><kbd>Blt</kbd> (used for graph generation)</li>
<li>The <kbd>Color Module</kbd> functions</li>
</ul>
<div class="packt_tip">Pmw offers a large list of extended widgets. For a demonstration of all these widgets, browse the Pmw package that you installed earlier and look for a directory named <kbd>demo</kbd>. Within <kbd>demo</kbd>, look for a file named <kbd>All.py</kbd>, which demonstrates all of these Pmw extensions with a sample working code.</div>
<p>Pmw provides the <kbd>Balloon</kbd> widget implementation, which will be used in the current example. Begin by importing <kbd>Pmw</kbd> into the namespace, as follows (see code <kbd>5.09</kbd>—<kbd>view.py</kbd>):</p>
<pre>import Pmw </pre>
<p>Next, instantiate the <kbd>Balloon</kbd> widget within the <kbd>create_gui</kbd> method, as follows:</p>
<pre>self.balloon = Pmw.Balloon(self.root) </pre>
<p>Finally, bind the <kbd>Balloon</kbd> widget to each button widget in the audio player. We will not reproduce the code for each button. However, the format is as follows: </p>
<pre>balloon.bind(name of widget, 'Description for the balloon') </pre>
<p>Thus, the <span class="packt_screen">Add File</span> button will have a balloon binding, as follows:</p>
<pre>self.balloon.bind(add_file_button, 'Add New File') </pre>
<p>Add similar code for each button in <kbd>5.09</kbd>—<kbd>view.py</kbd>.</p>
<p>This completes the iteration. We added Balloon tooltips to the audio player's buttons using the Pmw Tkinter extension. Most importantly, we got to know about the Tkinter extensions and when to use them.</p>
<div class="packt_tip">When you need a widget implementation that is not available as a core widget, try looking for its implementations in Pmw or TIX. If you don't find one that suits your needs, search the internet for some other Tkinter extension. If you still don't find your desired implementation, it's time to build one.</div>
<p>This brings us to the end of this chapter. The audio player is ready!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Let's recap the things that we touched upon in this chapter.</p>
<p>In addition to reinforcing a lot of GUI programming techniques that we discussed in the previous chapters, you learned how to work with more widgets such as Listbox, ttk Scale, and Radiobutton. We looked deeper into the features of the Canvas widget.</p>
<p>Most importantly, we learned how to create our custom widgets, thereby extending Tkinter's core widgets. This is a really powerful technique that can be applied to build all sorts of features into programs.</p>
<p>We saw how to generate and handle virtual events.</p>
<p>We saw the most common technique for applying animation in Tkinter programs. This technique can also be used to build all sorts of interesting games.</p>
<p>Finally, we got to know about some common Tkinter extensions, such as Pmw, WCK, TIX, and so on.</p>
<p>Now, let's lose ourselves in some music!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p>Before you proceed to the next chapter, make sure you can answer these questions to your<br/>
satisfaction:</p>
<ul>
<li>How can we create our own custom widgets in Tkinter?</li>
<li>How do you create animations with Tkinter?</li>
<li>What are virtual events? When and how do we use them?</li>
<li>What are Tkinter extensions? What are the most popular ones?</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>Look at the documentation for popular Tkinter extensions such as Pmw, Tix, WCK, and others.  Take a note of the commonly available widgets in these extensions.</p>
<p> </p>
<p> </p>
<p> </p>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>