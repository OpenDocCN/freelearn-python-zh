<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Sorting</h1>
            </header>

            <article>
                
<p class="CDPAlignLeft CDPAlign">Whenever data is collected, there comes a time when it becomes necessary to sort the data. The sorting operation is common to all datasets, be it a collection of names, telephone numbers, or items on a simple to-do list.</p>
<p>In this chapter, we'll study a few sorting techniques, including the following:</p>
<ul>
<li>Bubble sort</li>
<li>Insertion sort</li>
<li>Selection sort</li>
<li>Quick sort</li>
<li>Heap sort</li>
</ul>
<p>In our treatment of these sorting algorithms, we will take into consideration their asymptotic behavior. Some of the algorithms are relatively easy to develop but may perform poorly. Other algorithms that are a little complex to write will show impressive performance.</p>
<p>After sorting, it becomes much easier to conduct search operations on a collection of items. We'll start with the simplest of all sorting algorithms--the bubble sort algorithm.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Sorting algorithms</h1>
            </header>

            <article>
                
<p>In this chapter, we will go through a number of sorting algorithms that have varying levels of difficulty of implementation. Sorting algorithms are categorized by their memory usage, complexity, recursion, whether they are comparison-based among other considerations.</p>
<p>Some of the algorithms use more CPU cycles and as such have bad asymptotic values. Others chew on more memory and other computing resources as they sort a number of values. Another consideration is how sorting algorithms lend themselves to being expressed recursively or iteratively or both. There are algorithms that use comparison as the basis for sorting elements. An example of this is the bubble sort algorithm. Examples of a non-comparison sorting algorithm are the buck sort and pigeonhole sort.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Bubble sort</h1>
            </header>

            <article>
                
<p>The idea behind a bubble sort algorithm is very simple. Given an unordered list, we compare adjacent elements in the list, each time, putting in the right order of magnitude, only two elements. The algorithm hinges on a swap procedure.</p>
<p>Take a list with only two elements:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="66" src="assets/image_10_001.jpg" width="71"/></div>
<p>To sort this list, simply swap them into the right position with <strong>2</strong> occupying index <strong>0</strong> and <strong>5</strong> occupying index <strong>1</strong>. To effectively swap these elements, we need to have a temporary storage area:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="224" src="assets/image_10_002.jpg" width="232"/></div>
<p>Implementation of the bubble sort algorithm starts with the swap method, illustrated in the preceding image. First, element <strong>5</strong> will be copied to a temporary location, <kbd>temp</kbd>. Then element <strong>2</strong> will be moved to index <strong>0</strong>. Finally, <strong>5</strong> will be moved from temp to index <strong>1</strong>. At the end of it all, the elements will have been swapped. The list will now contain the element: <kbd>[2, 5]</kbd>. The following code will swap the elements of <kbd>unordered_list[j]</kbd> with <kbd>unordered_list[j+1]</kbd> if they are not in the right order:</p>
<pre>
    temp = unordered_list[j] <br/>    unordered_list[j] = unordered_list[j+1] <br/>    unordered_list[j+1] = temp 
</pre>
<p>Now that we have been able to swap a two-element array, it should be simple to use this same idea to sort a whole list.</p>
<p>We'll run this swap operation in a double-nested loop. The inner loop is as follows:</p>
<pre>
    for j in range(iteration_number): <br/>        if unordered_list[j] &gt; unordered_list[j+1]: <br/>            temp = unordered_list[j] <br/>            unordered_list[j] = unordered_list[j+1] <br/>            unordered_list[j+1] = temp 
</pre>
<p>Knowing how many times to swap is important when implementing a bubble sort algorithm. To sort a list of numbers such as <kbd>[3, 2, 1]</kbd>, we need to swap the elements a maximum of twice. This is equal to the length of the list minus 1, <kbd>iteration_number = len(unordered_list)-1</kbd>. We subtract <kbd>1</kbd> because it gives us exactly the maximum number of iterations to run:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="232" src="assets/image_10_003.jpg" width="225"/></div>
<p>By swapping the adjacent elements in exactly two iterations, the largest number ends up at the last position on the list.</p>
<p>The <kbd>if</kbd> statement makes sure that no needless swaps occur if two adjacent elements are already in the right order. The inner <kbd>for</kbd> loop only causes the swapping of adjacent elements to occur exactly twice in our list.</p>
<p>However, you'll realize that the running of the <kbd>for</kbd> loop for the first time does not entirely sort our list. How many times does this swapping operation have to occur in order for the entire list to be sorted? If we repeat the whole process of swapping the adjacent elements a number of times, the list will be sorted. An outer loop is used to make this happen. The swapping of elements in the list results in the following dynamics:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="254" src="assets/image_10_004.jpg" width="251"/></div>
<p>We recognize that a total of four comparisons at most were needed to get our list sorted. Therefore, both inner and outer loops have to run <kbd>len(unordered_list)-1</kbd> times for all elements to be sorted:</p>
<pre>
iteration_number = len(unordered_list)-1 <br/>    for i in range(iteration_number): <br/>        for j in range(iteration_number): <br/>            if unordered_list[j] &gt; unordered_list[j+1]: <br/>                temp = unordered_list[j] <br/>                unordered_list[j] = unordered_list[j+1] <br/>                unordered_list[j+1] = temp 
</pre>
<p>The same principle is used even if the list contains many elements. There are a lot of variations of the bubble sort too that minimize the number of iterations and comparisons.</p>
<p>The bubble sort is a highly inefficient sorting algorithm with a time complexity of <kbd>O(n2)</kbd> and best case of <kbd>O(n)</kbd>. Generally, the bubble sort algorithm should not be used to sort large lists. However, on relatively small lists, it performs fairly well.</p>
<p>There is a variant of the bubble sort algorithm where if there is no comparison within the inner loop, we simply quit the entire sorting process. The absence of the need to swap elements in the inner loop suggests the list has already been sorted. In a way, this can help speed up the generally considered slow algorithm.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Insertion sort</h1>
            </header>

            <article>
                
<p>The idea of swapping adjacent elements to sort a list of items can also be used to implement the insertion sort. In the insertion sort algorithm, we assume that a certain portion of the list has already been sorted, while the other portion remains unsorted. With this assumption, we move through the unsorted portion of the list, picking one element at a time. With this element, we go through the sorted portion of the list and insert it in the right order so that the sorted portion of the list remains sorted. That is a lot of grammar. Let's walk through the explanation with an example.</p>
<p>Consider the following array:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="78" src="assets/image_10_005.jpg" width="212"/></div>
<p>The algorithm starts by using a <kbd>for</kbd> loop to run between the indexes <strong>1</strong> and <strong>4</strong>. We start from index <strong>1</strong> because we assume the sub-array with index <strong>0</strong> to already be in the sorted order:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="145" src="assets/image_10_006.jpg" width="193"/></div>
<p>At the start of the execution of the loop, we have the following:</p>
<pre>
    for index in range(1, len(unsorted_list)): <br/>        search_index = index <br/>        insert_value = unsorted_list[index] 
</pre>
<p>At the beginning of the execution of each run of the <kbd>for</kbd> loop, the element at <kbd>unsorted_list[index]</kbd> is stored in the <kbd>insert_value</kbd> variable. Later, when we find the appropriate position in the sorted portion of the list, <kbd>insert_value</kbd> will be stored at that index or location:</p>
<pre>
    for index in range(1, len(unsorted_list)): <br/>        search_index = index <br/>        insert_value = unsorted_list[index] <br/><br/>        while search_index &gt; 0 and unsorted_list[search_index-1] &gt;     <br/>              insert_value : <br/>            unsorted_list[search_index] = unsorted_list[search_index-1] <br/>            search_index -= 1 <br/><br/>        unsorted_list[search_index] = insert_value 
</pre>
<p>The <kbd>search_index</kbd> is used to provide information to the <kbd>while</kbd> loop--exactly where to find the next element that needs to be inserted in the sorted portion of the list.</p>
<p>The <kbd>while</kbd> loop traverses the list backwards, guided by two conditions: first, if <kbd>search_index &gt; 0</kbd>, then it means that there are more elements in the sorted portion of the list; second, for the <kbd>while</kbd> loop to run, <kbd>unsorted_list[search_index-1]</kbd> must be greater than the <kbd>insert_value</kbd>. The <kbd>unsorted_list[search_index-1]</kbd> array will do either of the following things:</p>
<ul>
<li>Point to the element just before the <kbd>unsorted_list[search_index]</kbd> before the <kbd>while</kbd> loop is executed the first time</li>
<li>Point to one element before <kbd>unsorted_list[search_index-1]</kbd> after the <kbd>while</kbd> loop has been run the first time</li>
</ul>
<p>In our list example, the <kbd>while</kbd> loop will be executed because <kbd>5 &gt; 1</kbd>. In the body of the while loop, the element at <kbd>unsorted_list[search_index-1]</kbd> is stored at <kbd>unsorted_list[search_index]</kbd>. <kbd>search_index -= 1</kbd> moves the list traversal backwards till it bears the value <kbd>0</kbd>.</p>
<p>Our list now looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="39" src="assets/image_10_007.jpg" width="173"/></div>
<p>After the <kbd>while</kbd> loop exits, the last known position of <kbd>search_index</kbd> (which in this case is <kbd>0</kbd>) now helps us to know where to insert <kbd>insert_value</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="233" src="assets/image_10_008.jpg" width="253"/></div>
<p>On the second iteration of the <kbd>for</kbd> loop, <kbd>search_index</kbd> will have the value <strong>2</strong>, which is the index of the third element in the array. At this point, we start our comparison in the direction to the left (towards index <strong>0</strong>). <strong>100</strong> will be compared with <strong>5</strong> but because <strong>100</strong> is greater than <strong>5</strong>, the while loop will not be executed. <strong>100</strong> will be replaced by itself because the <kbd>search_index</kbd> variable never got decremented. As such, <kbd>unsorted_list[search_index] = insert_value</kbd> will have no effect.</p>
<p>When <kbd>search_index</kbd> is pointing at index <strong>3</strong>, we compare <strong>2</strong> with <strong>100</strong> and move <strong>100</strong> to where <strong>2</strong> is stored. We then compare <strong>2</strong> with <strong>5</strong> and move <strong>5</strong> to where <strong>100</strong> was initially stored. At this point, the <kbd>while</kbd> loop will break and <strong>2</strong> will be stored in index <strong>1</strong>. The array will be partially sorted with the values <kbd>[1, 2, 5, 100, 10]</kbd>.</p>
<p>The preceding step will occur one last time for the list to be sorted.</p>
<p>The insertion sort algorithm is considered stable in that it does not change the relative order of elements that have equal keys. It also only requires no more memory than what is consumed by the list because it does the swapping in-place.</p>
<p>Its worst case value is <strong>O</strong>(n<sup>2</sup>) and its best case is <strong>O</strong>(n).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Selection sort</h1>
            </header>

            <article>
                
<p>Another popular sorting algorithm is the selection sort. This sorting algorithm is simple to understand, yet also inefficient, with its worst and best asymptotic values being <strong>O</strong>(<em>n<sup>2</sup></em>). It begins by finding the smallest element in an array and interchanging it with data at, for instance, array index [<strong>0</strong>]. The same operation is done a second time; however, the smallest element in the remainder of the list after finding the first smallest element is interchanged with the data at index [<strong>1</strong>].</p>
<p>In a bid to throw more light on how the algorithm works, lets sort a list of numbers:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="72" src="assets/image_10_009.jpg" width="242"/></div>
<p>Starting at index <strong>0</strong>, we search for the smallest item in the list that exists between index <strong>1</strong> and the index of the last element. When this element has been found, it is exchanged with the data found at index <strong>0</strong>. We simply repeat this process until the list becomes sorted.</p>
<p>Searching for the smallest item within the list is an incremental process:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="118" src="assets/image_10_010.jpg" width="165"/></div>
<p>A comparison of elements <strong>2</strong> and <strong>5</strong> selects <strong>2</strong> as the lesser of the two. The two elements are swapped.</p>
<p>After the swap operation, the array looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="53" src="assets/image_10_011.jpg" width="194"/></div>
<p>Still at index <strong>0</strong>, we compare <strong>2</strong> with <strong>65</strong>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="159" src="assets/image_10_012.jpg" width="201"/></div>
<p>Since <strong>65</strong> is greater than <strong>2</strong>, the two elements are not swapped. A further comparison is made between the element at index <strong>0</strong>, which is <strong>2</strong>, with element at index <strong>3</strong>, which is <strong>10</strong>. No swap takes place. When we get to the last element in the list, we will have the smallest element occupying index <strong>0</strong>.</p>
<p>A new set of comparisons will begin, but this time, from index <strong>1</strong>. We repeat the whole process of comparing the element stored there with all the elements between index <strong>2</strong> through to the last index.</p>
<p>The first step of the second iteration will look like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="126" src="assets/image_10_013.jpg" width="159"/></div>
<p>The following is an implementation of the selection sort algorithm. The argument to the function is the unsorted list of items we want to put in ascending order of magnitude:</p>
<pre>
    def selection_sort(unsorted_list): <br/><br/>        size_of_list = len(unsorted_list) <br/><br/>        for i in range(size_of_list): <br/>            for j in range(i+1, size_of_list): <br/><br/>                if unsorted_list[j] &lt; unsorted_list[i]: <br/>                    temp = unsorted_list[i] <br/>                    unsorted_list[i] = unsorted_list[j] <br/>                    unsorted_list[j] = temp 
</pre>
<p>The algorithm begins by using the outer <kbd>for</kbd> loop to go through the list, <kbd>size_of_list</kbd>, a number of times. Because we pass <kbd>size_of_list</kbd> to the <kbd>range</kbd> method, it will produce a sequence from <strong>0</strong> through to <kbd>size_of_list-1</kbd>. It is a subtle note.</p>
<p>The inner loop is responsible for going through the list and making the necessary swap any time that we encounter an element less than the element pointed to by <kbd>unsorted_list[i]</kbd>. Notice that the inner loop begins from <kbd>i+1</kbd> up to <kbd>size_of_list-1</kbd>. The inner loop begins its search for the smallest element between <kbd>i+1</kbd> but uses the <kbd>j</kbd> index:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="128" src="assets/image_10_014.jpg" width="269"/></div>
<p>The preceding diagram shows the direction in which the algorithm searches for the next smallest item.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Quick sort</h1>
            </header>

            <article>
                
<div class="chapter-content">
<p>The quick sort algorithm falls under the divide and conquer class of algorithms, where we break (divide) a problem into smaller chunks that are much simpler to solve (conquer). In this case, an unsorted array is broken into sub-arrays that are partially sorted, until all elements in the list are in the right position, by which time our unsorted list will have become sorted.</p>
</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">List partitioning</h1>
            </header>

            <article>
                
<p>Before we divide the list into smaller chunks, we have to partition it. This is the heart of the quick sort algorithm. To partition the array, we must first select a pivot. All the elements in the array will be compared with this pivot. At the end of the partitioning process, all elements that are less than the pivot will be to the left of the pivot, while all elements greater than the pivot will lie to the right of the pivot in the array.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Pivot selection</h1>
            </header>

            <article>
                
<p>For the sake of simplicity, we'll take the first element in any array as the pivot. This kind of pivot selection degrades in performance, especially when sorting an already sorted list. Randomly picking the middle or last element in the array as the pivot does not improve the situation any further. In the next chapter, we will adopt a better approach to selecting the pivot in order to help us find the smallest element in a list.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Implementation</h1>
            </header>

            <article>
                
<p>Before we delve into the code, let's run through the sorting of a list using the quick sort algorithm. The partitioning step is very important to understand so we'll tackle that operation first.</p>
<p>Consider the following list of integers. We shall partition this list using the partition function below:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="26" src="assets/image_10_015.jpg" width="517"/></div>
<pre>
 <br/>    def partition(unsorted_array, first_index, last_index): <br/><br/>        pivot = unsorted_array[first_index] <br/>        pivot_index = first_index <br/>        index_of_last_element = last_index <br/><br/>        less_than_pivot_index = index_of_last_element <br/>        greater_than_pivot_index = first_index + 1 <br/>        ... 
</pre>
<p>The partition function receives the array that we need to partition as its parameters: the index of its first element and the index of its last element.</p>
<p>The value of the pivot is stored in the <kbd>pivot</kbd> variable, while its index is stored in <kbd>pivot_index</kbd>. We are not using <kbd>unsorted_array[0]</kbd> because when the unsorted array parameter is called with a segment of an array, index <kbd>0</kbd> will not necessarily point to the first element in that array. The index of the next element to the pivot, <kbd>first_index + 1</kbd>, marks the position where we begin to look for the element in the array that is greater than the <kbd>pivot</kbd>, <kbd>greater_than_pivot_index = first_index + 1</kbd>.</p>
<p><kbd>less_than_pivot_index = index_of_last_element</kbd> marks the position of the last element in the list which is, where we begin the search for the element that is less than the pivot:</p>
<pre>
    while True: <br/><br/>        while unsorted_array[greater_than_pivot_index] &lt; pivot and <br/>              greater_than_pivot_index &lt; last_index: <br/>              greater_than_pivot_index += 1 <br/><br/>        while unsorted_array[less_than_pivot_index] &gt; pivot and <br/>              less_than_pivot_index &gt;= first_index: <br/>              less_than_pivot_index -= 1 
</pre>
<p>At the beginning of the execution of the main <kbd>while</kbd> loop the array looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="163" src="assets/image_10_016.jpg" width="395"/></div>
<p>The first inner <kbd>while</kbd> loop moves one index to the right until it lands on index <strong>2</strong>, because the value at that index is greater than <strong>43</strong>. At this point, the first <kbd>while</kbd> loop breaks and does not continue. At each test of the condition in the first <kbd>while</kbd> loop, <kbd>greater_than_pivot_index += 1</kbd> is evaluated only if the <kbd>while</kbd> loop's test condition evaluates to <kbd>True</kbd>. This makes the search for the element greater than the pivot progress to the next element on the right.</p>
<p>The second inner <kbd>while</kbd> loop moves one index at a time to the left, until it lands on index <strong>5</strong>, whose value, <strong>20</strong>, is less than <strong>43</strong>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border" height="123" src="assets/image_10_017.jpg" width="405"/></div>
<p>At this point, neither inner <kbd>while</kbd> loop can be executed any further:</p>
<pre>
    if greater_than_pivot_index &lt; less_than_pivot_index: <br/>        temp = unsorted_array[greater_than_pivot_index] <br/>            unsorted_array[greater_than_pivot_index] =    <br/>                unsorted_array[less_than_pivot_index] <br/>            unsorted_array[less_than_pivot_index] = temp <br/>    else: <br/>        break 
</pre>
<p>Since <kbd>greater_than_pivot_index &lt; less_than_pivot_index</kbd>, the body of the if statement swaps the element at those indexes. The else condition breaks the infinite loop any time <kbd>greater_than_pivot_index</kbd> becomes greater than <kbd>less_than_pivot_index</kbd>. In such a condition, it means that <kbd>greater_than_pivot_index</kbd> and <kbd>less_than_pivot_index</kbd> have crossed over each other.</p>
<p>Our array now looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="151" src="assets/image_10_018.jpg" width="447"/></div>
<p>The break statement is executed when <kbd>less_than_pivot_index</kbd> is equal to <kbd>3</kbd> and <kbd>greater_than_pivot_index</kbd> is equal to <kbd>4</kbd>.</p>
<p>As soon as we exit the <kbd>while</kbd> loop, we interchange the element at <kbd>unsorted_array[less_than_pivot_index]</kbd> with that of <kbd>less_than_pivot_index</kbd>, which is returned as the index of the pivot:</p>
<pre>
    unsorted_array[pivot_index]=unsorted_array[less_than_pivot_index] <br/>    unsorted_array[less_than_pivot_index]=pivot <br/>    return less_than_pivot_index 
</pre>
<p class="packt_figure CDPAlignLeft CDPAlign">The image below shows how the code interchanges 4 with 43 as the last step in the partitioning process:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="image-border aligncenter" height="143" src="assets/image_10_019.jpg" width="302"/></div>
<p>To recap, the first time the quick sort function was called, it was partitioned about the element at index <strong>0</strong>. After the return of the <span>partitioning</span> function, we obtain the array <kbd>[4, 3, 20, 43, 89, 77]</kbd>.</p>
<p>As you can see, all elements to the right of element <strong>43</strong> are greater, while those to the left are smaller. The partitioning is complete.</p>
<p>Using the split point 43 with index 3, we will recursively sort the two sub-arrays <kbd>[4, 30, 20]</kbd> and <kbd>[89, 77]</kbd> using the same process we just went through.</p>
<p>The body of the main <kbd>quick sort</kbd> function is as follows:</p>
<pre>
    def quick_sort(unsorted_array, first, last): <br/>        if last - first &lt;= 0: <br/>            return <br/>    else: <br/>        partition_point = partition(unsorted_array, first, last) <br/>        quick_sort(unsorted_array, first, partition_point-1) <br/>        quick_sort(unsorted_array, partition_point+1, last) 
</pre>
<p>The <kbd>quick sort</kbd> function is a very simple method, no more than 6 lines of code. The heavy lifting is done by the <kbd>partition</kbd> function. When the <kbd>partition</kbd> method is called it returns the partition point. This is the point in the <kbd>unsorted_array</kbd> where all elements to the left are less than the pivot and all elements to its right are greater than it.</p>
<p>When we print the state of <kbd>unsorted_array</kbd> immediately after the partition progress, we see clearly how the partitioning is happening:</p>
<pre>
<strong>Output:</strong><br/><strong>[43, 3, 20, 89, 4, 77]</strong><br/><strong>[4, 3, 20, 43, 89, 77]</strong><br/><strong>[3, 4, 20, 43, 89, 77]</strong><br/><strong>[3, 4, 20, 43, 77, 89]</strong><br/><strong>[3, 4, 20, 43, 77, 89]</strong>
</pre>
<p>Taking a step back, let's sort the first sub array after the first partition has happened. The partitioning of the <kbd>[4, 3, 20]</kbd> sub array will stop when <kbd>greater_than_pivot_index</kbd> is at index <kbd>2</kbd> and <kbd>less_than_pivot_index</kbd> is at index <kbd>1</kbd>. At that point, the two markers are said to have crossed. Because <kbd>greater_than_pivot_index</kbd> is greater than <kbd>less_than_pivot_index</kbd>, further execution of the <kbd>while</kbd> loop will cease. Pivot 4 will be exchanged with <kbd>3</kbd>, while index <kbd>1</kbd> is returned as the partition point.</p>
<p>The quick sort algorithm has a <strong>O</strong>(<em>n<sup>2</sup></em>) worst case complexity, but it is efficient when sorting large amounts of data.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Heap sort</h1>
            </header>

            <article>
                
<p>In <a href="3119407a-e9f1-4aab-8a06-8eea85b17c33.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 8</span></a>, <em>Graphs and Other Algorithms</em>, we implemented the (binary) heap data structure. Our implementation always made sure that after an element has been removed or added to a heap, the heap order property is maintained by using the sink and float helper methods.</p>
<p>The heap data structure can be used to implement the sorting algorithm called the heap sort. As a recap, let's create a simple heap with the following items:</p>
<pre>
    h = Heap() <br/>    unsorted_list = [4, 8, 7, 2, 9, 10, 5, 1, 3, 6] <br/>    for i in unsorted_list: <br/>        h.insert(i) <br/>    print("Unsorted list: {}".format(unsorted_list)) 
</pre>
<p>The heap, <kbd>h</kbd>, is created and the elements in the <kbd>unsorted_list</kbd> are inserted. After each method call to <kbd>insert</kbd>, the heap order property is restored by the subsequent call to the <kbd>float</kbd> method. After loop has terminated, at the top of our heap will be element <kbd>4</kbd>.</p>
<p>The number of elements in our heap is <kbd>10</kbd>. If we call the <kbd>pop</kbd> method on the heap object <kbd>h</kbd>, 10 times and store the actual elements being popped, we end up with a sorted list. After each <kbd>pop</kbd> operation, the heap is readjusted to maintain the heap order property.</p>
<p>The <kbd>heap_sort</kbd> method is as follows:</p>
<pre>
    class Heap: <br/>        ... <br/>        def heap_sort(self): <br/>            sorted_list = [] <br/>            for node in range(self.size): <br/>                n = self.pop() <br/>                sorted_list.append(n) <br/><br/>            return sorted_list 
</pre>
<p>The <kbd>for</kbd> loop simply calls the <kbd>pop</kbd> method <kbd>self.size</kbd> number of times. <kbd>sorted_list</kbd> will contain a sorted list of items after the loop terminates.</p>
<p>The <kbd>insert</kbd> method is called <em>n</em> number of times. Together with the <kbd>float</kbd> method, the <kbd>insert</kbd> operation takes a worst case runtime of <strong>O</strong>(<em>n log n</em>), as does the <kbd>pop</kbd> method. As such, this sorting algorithm incurs a worst case runtime of <strong>O</strong>(<em>n log n</em>).</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we have explored a number of sorting algorithms. Quick sort performs much better than the other sorting algorithms. Of all the algorithms discussed, quick sort preserves the index of the list that it sorts. We'll use this property in the next chapter as we explore the selection algorithms.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>