- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Introduction to Type Hinting
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示简介
- en: ”Knowing yourself is the beginning of all wisdom.”
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “知己知彼，百战不殆。”
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Aristotle
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: – 亚里士多德
- en: In this chapter, we are going to explore the topic of **type hinting** . Type
    hinting is perhaps the biggest change introduced in Python since Python 2.2, which
    saw the unification of types and classes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨**类型提示**这一主题。类型提示可能是自Python 2.2以来Python引入的最大变化，它实现了类型和类的统一。
- en: 'Specifically, we will study the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究以下主题：
- en: Python approach to types.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python对类型的处理方法。
- en: Types available for annotations.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于注解的类型。
- en: Protocols (in brief).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议（简要介绍）。
- en: Mypy, a static type checker for Python.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mypy，Python的静态类型检查器。
- en: Python approach to types
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python对类型的处理方法
- en: Python is both a **strongly typed** and a **dynamically typed** language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种**强类型**和**动态类型**的语言。
- en: '*Strongly typed* means that Python does not allow implicit type conversions
    that could lead to unexpected behaviors. Consider the following **php** code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*强类型*意味着Python不允许可能导致意外行为的隐式类型转换。考虑以下**php**代码：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In php, variables are prepended with a `$` sign. In the above code, we set
    `$a` to the integer number `2` , and `$b` to the string `"2"` . To add them together,
    php performs an implicit conversion of `$b` , from string to integer. This is
    referred to as **type juggling** . This might seem a convenient feature, but the
    fact that php is weakly typed has the potential to lead to bugs in the code. If
    we tried to do the same in Python, the result would be much different:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在php中，变量前面有一个`$`符号。在上面的代码中，我们将`$a`设置为整数`2`，将`$b`设置为字符串`"2"`。要将它们相加，php会执行从字符串到整数的隐式转换。这被称为**类型魔术**。这看起来可能很方便，但php是弱类型的，这可能导致代码中的bug。如果我们尝试在Python中做同样的事情，结果将大不相同：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running the above produces:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码会产生：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Python is strongly typed, so when we try to add an integer to a string – or
    any pair of incompatible types – we get `TypeError` .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python是强类型的，所以当我们尝试将整数加到字符串上——或者任何不兼容类型的组合——我们会得到`TypeError`。
- en: '*Dynamically typed* means that Python determines the type of a variable at
    runtime, which means that we do not specify types explicitly in the code.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态类型*意味着Python在运行时确定变量的类型，这意味着我们不需要在代码中显式指定类型。'
- en: 'In contrast, languages like C++, Java, C#, and Swift are all **statically typed**
    . When we declare variables in these languages, we must specify their type. For
    example, in Java, it is common to see variables declared like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，像C++、Java、C#和Swift这样的语言都是**静态类型**的。当我们在这类语言中声明变量时，我们必须指定它们的类型。例如，在Java中，常见的变量声明如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are pros and cons to both approaches, so it’s hardly a matter of which
    is best. Python was designed to be concise, lean, and elegant. One of the advantages
    of its design is known as **duck typing** .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都有优点和缺点，所以很难说哪一种最好。Python被设计成简洁、精炼和优雅。其设计的一个优点就是**鸭子类型**。
- en: Duck typing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Another concept that Python helped popularize is **duck typing** . In essence,
    this means that the type or class of an object is less important than the methods
    it defines or the operations it supports. As the saying goes: *“If it looks like
    a duck, swims like a duck, and quacks like a duck, then it probably is a duck.”*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Python帮助普及的概念是**鸭子类型**。本质上，这意味着一个对象的数据类型或类不如它定义的方法或支持的运算重要。俗话说：“如果它看起来像鸭子，游泳像鸭子，叫起来像鸭子，那么它可能就是一只鸭子。”
- en: 'Duck typing is used extensively in Python because the language is dynamically
    typed. It allows for greater flexibility and code reuse. Consider the following
    example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python是动态类型的语言，鸭子类型在Python中被广泛使用。它提供了更大的灵活性和代码重用。考虑以下示例：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the above code, the `print_shape_info()` function does not care about the
    specific type of `shape` . It only cares that `shape` has a method called `area()`
    .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`print_shape_info()`函数不关心`shape`的具体类型。它只关心`shape`有一个名为`area()`的方法。
- en: History of type hinting
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示的历史
- en: Although Python’s approach to types is one of the features that contributed
    to the success of its wide adoption, in Python 3, we saw the beginning of a gradual
    and carefully designed evolution toward the integration of type safety features
    that still maintained Python’s dynamic nature.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python对类型的处理方法是导致其广泛采用成功的一个特征，但在Python 3中，我们看到了一个逐渐且精心设计的演变，旨在整合类型安全特性，同时保持Python的动态特性。
- en: This began in Python 3.0, with the introduction of function annotations, through
    PEP 3107 ( [https://peps.python.org/pep-3107/](https://peps.python.org/pep-3107/)
    ). This addition allowed developers to add arbitrary metadata to function parameters
    and return values. These annotations were initially intended as a tool for documentation
    and had no semantic meaning. This step was the foundation layer that allowed the
    introduction of the explicit support of type hinting.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这始于 Python 3.0，随着函数注解的引入，由 PEP 3107 ([https://peps.python.org/pep-3107/](https://peps.python.org/pep-3107/))
    提出。这一新增功能允许开发者向函数参数和返回值添加任意元数据。这些注解最初是作为文档工具而设计的，没有语义意义。这一步是引入显式类型提示支持的基础层。
- en: In Python 3.5, with the landing of PEP 484 ( [https://peps.python.org/pep-0484/](https://peps.python.org/pep-0484/)
    ), the real inception of type hinting came about. PEP 484 formalized the addition
    of type hints, building on the syntax laid out by PEP 3107. It defined a standard
    way to declare types for function parameters, return values, and variables.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.5 中，随着 PEP 484 ([https://peps.python.org/pep-0484/](https://peps.python.org/pep-0484/))
    的落地，类型提示的真正起点出现了。PEP 484 正式化了类型提示的添加，建立在 PEP 3107 提出的语法之上。它定义了声明函数参数、返回值和变量类型的标准方式。
- en: This enabled optional static type checking, and developers could now use tools
    like **Mypy** to detect type-related errors before runtime.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可选的静态类型检查成为可能，开发者现在可以使用 **Mypy** 等工具在运行前检测类型相关的错误。
- en: In Python 3.6, we saw the introduction of annotations for variable declarations.
    This was brought by PEP 526 ( [https://peps.python.org/pep-0526/](https://peps.python.org/pep-0526/)
    ). This new addition meant that types could be explicitly declared throughout
    the code, and not just in functions. It included class attributes and module-level
    variables as well. This further improved Python’s type hinting capabilities and
    made it easier to statically analyze code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.6 中，我们看到了变量声明注解的引入。这是由 PEP 526 ([https://peps.python.org/pep-0526/](https://peps.python.org/pep-0526/))
    带来的。这一新功能意味着类型可以在整个代码中显式声明，而不仅仅是函数中。它还包括类属性和模块级变量。这进一步提高了 Python 的类型提示能力，并使得静态分析代码变得更加容易。
- en: 'Subsequent enhancements and PEPs refined and expanded Python’s type system
    even further. The main ones were the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 随后的增强和 PEP 进一步精炼和扩展了 Python 的类型系统。主要的有以下几项：
- en: PEP 544 ( [https://peps.python.org/pep-0544/](https://peps.python.org/pep-0544/)
    ) landed in Python 3.8 and introduced the concept of protocols, which enabled
    duck typing and further static type checking.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 544 ([https://peps.python.org/pep-0544/](https://peps.python.org/pep-0544/))
    在 Python 3.8 中落地，引入了协议的概念，这实现了鸭子类型和进一步的静态类型检查。
- en: PEP 585 ( [https://peps.python.org/pep-0585/](https://peps.python.org/pep-0585/)
    ) landed in Python 3.9 and set another milestone. It revolutionized type hinting
    by integrating it directly with Python core collections. This removed the need
    to import types from the `typing` module for common data structures, such as dictionaries
    and lists.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 585 ([https://peps.python.org/pep-0585/](https://peps.python.org/pep-0585/))
    在 Python 3.9 中落地，并设立了另一个里程碑。它通过直接与 Python 核心集合集成，彻底改变了类型提示。这消除了从 `typing` 模块导入类型以用于常见数据结构（如字典和列表）的需要。
- en: PEP 586 ( [https://peps.python.org/pep-0586/](https://peps.python.org/pep-0586/)
    ) landed in Python 3.8 and added literal types, allowing functions to specify
    literal values as parameters.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 586 ([https://peps.python.org/pep-0586/](https://peps.python.org/pep-0586/))
    在 Python 3.8 中落地，并添加了字面量类型，允许函数指定字面量值作为参数。
- en: PEP 589 ( [https://peps.python.org/pep-0589/](https://peps.python.org/pep-0589/)
    ) landed in Python 3.8 and introduced `TypedDict` , which enabled precise type
    hints for dictionaries with a fixed set of keys.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 589 ([https://peps.python.org/pep-0589/](https://peps.python.org/pep-0589/))
    在 Python 3.8 中落地，引入了 `TypedDict`，它为具有固定键集的字典提供了精确的类型提示。
- en: PEP 604 ( [https://peps.python.org/pep-0604/](https://peps.python.org/pep-0604/)
    ) landed in Python 3.10 and introduced a simplification of the syntax for union
    types, which streamlined annotations and improved the readability of the code.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 604 ([https://peps.python.org/pep-0604/](https://peps.python.org/pep-0604/))
    在 Python 3.10 中落地，简化了联合类型的语法，从而简化了注解并提高了代码的可读性。
- en: 'Other notable PEPs are:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的 PEP 包括：
- en: PEP 561 ( [https://peps.python.org/pep-0561/](https://peps.python.org/pep-0561/)
    ), which specifies how to distribute packages that support type checking.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 561 ([https://peps.python.org/pep-0561/](https://peps.python.org/pep-0561/))
    规定了如何分发支持类型检查的包。
- en: PEP 563 ( [https://peps.python.org/pep-0563/](https://peps.python.org/pep-0563/)
    ), which changed the evaluation of annotations such that they are not evaluated
    at function definition time. This postponement was made the default behavior in
    Python 3.10.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 563 ([https://peps.python.org/pep-0563/](https://peps.python.org/pep-0563/))，它改变了注解的评估方式，使得它们不在函数定义时进行评估。这种延迟在
    Python 3.10 中被设置为默认行为。
- en: PEP 593 ( [https://peps.python.org/pep-0593/](https://peps.python.org/pep-0593/)
    ), which introduced a way to augment existing type hints with arbitrary metadata,
    potentially for use by third-party tools.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 593 ([https://peps.python.org/pep-0593/](https://peps.python.org/pep-0593/))，它介绍了一种方法来增强现有的类型提示，使用任意元数据，可能用于第三方工具。
- en: PEP 612 ( [https://peps.python.org/pep-0612/](https://peps.python.org/pep-0612/)
    ), which introduced parameter specifications, which allow more complex types of
    variable annotations, particularly useful for decorators that modify function
    signatures.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 612 ([https://peps.python.org/pep-0612/](https://peps.python.org/pep-0612/))，它引入了参数规范，允许更复杂的变量注解类型，特别是对于修改函数签名的装饰器非常有用。
- en: PEP 647 ( [https://peps.python.org/pep-0647/](https://peps.python.org/pep-0647/)
    ), which introduced type guards, functions that enable more precise type inference
    in conditional blocks.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 647 ([https://peps.python.org/pep-0647/](https://peps.python.org/pep-0647/))，它引入了类型守卫，这些函数可以在条件块中实现更精确的类型推断。
- en: PEP 673 ( [https://peps.python.org/pep-0673/](https://peps.python.org/pep-0673/)
    ), which introduced the `Self` type to represent the instance type within class
    bodies and method returns, making type hints involving classes more expressive
    and accurate.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PEP 673 ([https://peps.python.org/pep-0673/](https://peps.python.org/pep-0673/))，它引入了
    `Self` 类型来表示类体和方法返回中的实例类型，使得涉及类的类型提示更加表达性和准确。
- en: The evolution of type hinting in Python has been driven by the desire for greater
    robustness and scalability of code, leveraging the power of Python’s dynamic nature.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python 类型提示的演变是由对代码更强大鲁棒性和可扩展性的需求所驱动的，利用了 Python 的动态特性。
- en: 'Although Python’s type hinting popularity seems to continuously increase, it
    is important to note that, according to the authors of PEP 484 (Guido van Rossum,
    Jukka Lehtosalo, and Łukasz Langa):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python的类型提示流行度似乎持续增加，但重要的是要注意，根据PEP 484（Guido van Rossum、Jukka Lehtosalo 和
    Łukasz Langa）的作者：
- en: ”Python will remain a dynamically typed language, and the authors have no desire
    to ever make type hints mandatory, even by convention.”
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Python 将继续是一种动态类型语言，作者们没有意愿将类型提示强制化，即使是按照惯例。”
- en: The way in which Python’s type hinting has been introduced, and the philosophical
    approach of this PEP’s authors and Python’s lead developers, suggest that the
    choice of using type hinting is, and always will be, up to the developer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python 类型提示的引入方式，以及该 PEP 的作者和 Python 的主要开发者的哲学方法，表明使用类型提示的选择，现在和将来都将由开发者决定。
- en: Let us now see some of the main benefits of type hinting.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类型提示的一些主要好处。
- en: Benefits of type hinting
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示的好处
- en: 'Adopting type hinting brings several key benefits, such as enhanced code quality,
    maintainability, and improved developer efficiency. We can summarize them in a
    list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 采用类型提示带来了一些关键好处，如增强代码质量、可维护性和提高开发者效率。我们可以将它们总结成一个列表：
- en: '**Improved code readability and documentation** : Type hints are a form of
    documentation. They clarify the type of arguments a function expects, and what
    type it returns. This helps developers understand the code immediately, with no
    need to read long comments or much code.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进代码可读性和文档**：类型提示是一种文档形式。它们阐明了函数期望的参数类型以及它返回的类型。这有助于开发者立即理解代码，无需阅读冗长的注释或大量代码。'
- en: '**Enhanced error detection** : Static type checkers, such as Mypy, can scan
    the codebase and flag errors before runtime. This means that some bugs can be
    eliminated before they become a problem.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强错误检测**：静态类型检查器，如 Mypy，可以扫描代码库并在运行前标记错误。这意味着一些错误可以在它们成为问题之前被消除。'
- en: '**Better IDE experience and autocompletion** : Modern IDEs leverage type hints
    to provide better autocompletion and enhanced refactoring capabilities. Moreover,
    with type hints, the IDE can suggest appropriate methods and attributes for an
    object.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的 IDE 体验和自动完成**：现代 IDE 利用类型提示提供更好的自动完成和增强重构功能。此外，有了类型提示，IDE 可以建议对象适当的方法和属性。'
- en: '**Improved collaboration and code reviews** : The documenting quality of type
    hints makes it easier to understand the code at a glance, which, for example,
    can be useful when reading changes in a pull request.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的协作和代码审查**：类型提示的文档质量使得一眼就能理解代码，这在阅读pull request中的更改时可能很有用。'
- en: '**Code flexibility and reusability** : Python’s type hinting includes features
    such as generics, custom types, and protocols, which help developers write better-structured,
    more flexible code.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码灵活性和可重用性**：Python的类型提示包括泛型、自定义类型和协议等特性，这些特性有助于开发者编写结构更清晰、更灵活的代码。'
- en: Another important aspect of Python’s type hinting system is that it can be introduced
    gradually. It is, in fact, quite common to introduce type hints progressively
    in a codebase, initially limiting efforts to where it matters most.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型提示系统的另一个重要方面是它可以逐步引入。实际上，在代码库中逐步引入类型提示是很常见的，最初将努力限制在最重要的地方。
- en: Type annotations
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型注释
- en: Now that we have a foundational understanding of Python’s dynamic nature and
    its approach to type hinting, let us start exploring some examples and concepts
    to see how it is applied in practice.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Python的动态特性和其类型提示方法有了基础的了解，让我们开始探索一些示例和概念，看看它在实践中是如何应用的。
- en: While we expose the main types we can use to annotate our code, you might find
    slight differences with what you are used to, if you have previously used type
    annotations in your code. This is likely because type hinting in Python is currently
    still evolving, so it is different according to which Python version you are using.
    In this chapter, we will stick to the rules for Python 3.12.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们展示了我们可以用来注释代码的主要类型，但如果您之前在代码中使用过类型注释，您可能会发现一些细微的差异。这很可能是由于Python中的类型提示目前仍在不断发展，因此它根据您使用的Python版本而有所不同。在本章中，我们将坚持Python
    3.12的规则。
- en: Let us start with a basic example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本示例开始。
- en: Annotating functions
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数注释
- en: 'In Python, we can annotate both function parameters and their return values.
    Let us start with a basic `greeter` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以注释函数参数及其返回值。让我们从一个基本的`greeter`函数开始：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a simple Python function that takes a `name` and returns a greeting.
    We can now annotate the function to specify that we expect `name` to be a string
    and that the greeting returned will also be a string.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的Python函数，它接受一个`name`并返回一个问候语。我们现在可以注释这个函数，指定我们期望`name`是一个字符串，并且返回的问候语也将是一个字符串。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see from the highlighted section in this code, the syntax to annotate
    a function is simple. We specify the type using a colon after the parameter name.
    The `return` value is annotated with an arrow ( `->` ) followed by the type of
    the object returned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从代码中高亮显示的部分所示，注释函数的语法很简单。我们使用参数名后的冒号来指定类型。`return`值通过一个箭头（`->`）后跟返回的对象类型进行注释。
- en: Let us now add another parameter, `age` , which we expect to be an integer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们添加另一个参数`age`，我们期望它是一个整数。
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you probably expected, we simply did the same for the `age` parameter, only,
    this time, we specified `int` , instead of `str` .
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期的那样，我们对`age`参数做了同样的处理，只是这次我们指定了`int`，而不是`str`。
- en: If you use a relatively modern IDE, try out this code. If you type either `name`
    or `age` and then a dot ( `.` ), the editor should suggest only the methods and
    attributes that are pertinent to the type of object you are using.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是相对现代的IDE，请尝试运行此代码。如果您输入`name`或`age`然后输入一个点（`.`），编辑器应该只会建议与您正在使用的对象类型相关的方法和属性。
- en: This was a basic example designed to show you the syntax of type annotations.
    Please disregard the artificial names, such as `greeter_annotated()` and `greeter_annotated_age()`
    ; they are not good names, but they should help you spot the differences more
    quickly.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本示例，旨在向您展示类型注释的语法。请忽略人工命名的部分，如`greeter_annotated()`和`greeter_annotated_age()`；它们不是好的名字，但应该有助于您更快地发现差异。
- en: We are now going to expand on this, to show you the real capabilities of Python
    type hinting.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在此基础上进行扩展，向您展示Python类型提示的实际功能。
- en: The Any type
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意类型
- en: This is a special kind of type. Any function without a return type, or parameter
    type, will implicitly default to using `Any` . Therefore, the following function
    declarations are equivalent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种特殊类型的类型。任何没有返回类型或参数类型的函数将隐式地默认使用`Any`。因此，以下函数声明是等效的。
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The above declarations are completely equivalent. `Any` can be useful in certain
    circumstances, such as when annotating data containers, function decorators, or
    when a function is designed to handle inputs of multiple types. A simple example
    could be:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上述声明完全等效。`Any` 在某些情况下可能很有用，例如在注释数据容器、函数装饰器或当函数设计为处理多种类型的输入时。一个简单的例子可以是：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, the two definitions are again completely equivalent. The only
    difference is that in the second one, by using `Any` , we explicitly state the
    list `items` is expected to contain *any* kind of object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这两个定义再次完全等效。唯一的区别是，在第二个定义中，通过使用 `Any`，我们明确指出列表 `items` 应该包含 *任何* 类型的对象。
- en: Type aliases
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型别名
- en: We can use almost any Python type in type hints. Moreover, the `typing` module
    introduced several constructs that we can leverage to expand on them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎可以在类型提示中使用任何 Python 类型。此外，`typing` 模块引入了几个我们可以利用的结构来扩展它们。
- en: 'One such construct is **type aliases** , which are defined using a `type` statement.
    The result is an instance of `TypeAliasType` . They are a convenient way to simplify
    how the code reads. Let us see an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种结构是 **类型别名**，它使用 `type` 语句定义。结果是 `TypeAliasType` 的一个实例。它们是简化代码阅读的便捷方式。让我们看一个例子：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see in the above example, we can define our own type aliases. From
    the perspective of a static type checker, `DatabasePort` and `int` will be treated
    equivalently.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如上例所示，我们可以定义自己的类型别名。从静态类型检查器的角度来看，`DatabasePort` 和 `int` 将被同等对待。
- en: 'Although it might not be evident from such a dummy example, using a type alias
    enhances readability and simplifies refactoring. Imagine several functions expecting
    `DatabasePort` : if we wanted to refactor the codebase to represent a port using
    a string, we would just need to change the line in which we define `DatabasePort`
    . Had we simply used `int` instead, we would need to refactor all function definitions.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从这样一个示例中可能不明显，但使用类型别名可以增强可读性并简化重构。想象一下，有几个函数期望 `DatabasePort` 类型：如果我们想重构代码库，使用字符串来表示端口号，我们只需更改定义
    `DatabasePort` 的那一行。如果我们简单地使用 `int`，我们就需要重构所有函数定义。
- en: Special forms
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊形式
- en: Special forms can be used as types in annotations. They all support subscription
    using [], but each has a unique syntax. Here, we are going to see `Optional` and
    `Union` ; for the complete list of all special forms, please refer to the official
    documentation at [https://docs.python.org/3/library/typing.html#special-forms](https://docs.python.org/3/library/typing.html#special-forms)
    .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊形式可以用作注释中的类型。它们都支持使用 [] 进行索引，但每个都有独特的语法。在这里，我们将看到 `Optional` 和 `Union`；有关所有特殊形式的完整列表，请参阅官方文档[https://docs.python.org/3/library/typing.html#special-forms](https://docs.python.org/3/library/typing.html#special-forms)。
- en: Optional
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Optional
- en: 'Python allows optional arguments when a function parameter has a default. Here,
    we have a distinction to make. Let us bring back the `greeter` function, and add
    a default value to it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许在函数参数有默认值时使用可选参数。在这里，我们需要做出区分。让我们重新引入 `greeter` 函数，并给它添加一个默认值：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This time, we have added a default value to the `greeter()` function. That means
    that if we were to call it with no arguments, it would return the string `"Hello,
    stranger!"` .
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在 `greeter()` 函数中添加了一个默认值。这意味着如果我们不带任何参数调用它，它将返回字符串 `"Hello, stranger!"`。
- en: 'This definition assumes that when we call `greeter()` , if we pass `name` ,
    it will be a string. Sometimes, though, this is not what we want, and we require
    an argument to be `None` , if not provided when the function is called. For situations
    like this, the `typing` module provides us with the `Optional` special form:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义假设当我们调用 `greeter()` 时，如果我们传递 `name`，它将是一个字符串。有时，这并不是我们想要的，我们需要在函数调用时提供一个
    `None` 参数，如果没有提供。对于这种情况，`typing` 模块为我们提供了 `Optional` 特殊形式：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the `greeter_optional()` function, we don’t want to return a greeting when
    we don’t pass a name. Because `None` is not a string, we mark `name` as optional
    and set its default value to `None` .
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `greeter_optional()` 函数中，我们不想在没有传递名字的情况下返回问候语。因为 `None` 不是一个字符串，我们将 `name`
    标记为可选，并将其默认值设置为 `None`。
- en: Union
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Union
- en: 'Sometimes, an argument can be of different types. For example, when connecting
    to a database, the port can be specified as either an integer or a string. In
    these cases, it is useful to have the `Union` special form:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个参数可以有多种类型。例如，在连接数据库时，端口号可以指定为一个整数或一个字符串。在这些情况下，拥有 `Union` 特殊形式是有用的：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the above example, for the `port` parameter, we want to accept both `int`
    and `str` , and the `Union` special form allows us to do just that.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，对于 `port` 参数，我们希望接受 `int` 和 `str`，`Union` 特殊形式允许我们做到这一点。
- en: Since Python 3.10, we don’t need to import `Union` , and instead can use a pipe
    ( `|` ) to specify a union type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.10 以来，我们不需要导入 `Union`，而是可以使用管道（`|`）来指定联合类型。
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This looks leaner.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更加简洁。
- en: '`Union` , or its pipe equivalent, incidentally, enables us to avoid having
    to import `Optional` , since `Optional[str]` , for example, can be written as
    `Union[str, None]` , or simply `str | None` . Let us see the latter form in an
    example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union` 或其管道等价物，顺便提一下，使我们能够避免必须导入 `Optional`，例如，`Optional[str]` 可以写成 `Union[str,
    None]`，或者简单地写成 `str | None`。让我们通过一个例子来看看后者形式：'
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Have you noticed that some of the functions defined above have type annotations
    on their parameters, but nothing for the return value? This is to show you that
    annotations are completely optional. We could even annotate only some of the parameters
    a function takes if we wanted to.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，上面定义的一些函数在参数上有类型注解，但在返回值上没有？这是为了向你展示注解是完全可选的。如果我们愿意，甚至可以只注解函数接受的某些参数。
- en: Generics
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: Let us continue our exploration of what is possible to achieve using type hints,
    by exploring the concept of **generics** .
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨使用类型提示可以实现的内容，通过探索泛型的概念。
- en: 'Say that we wanted to write a `last()` function that takes a list of items,
    of any kind, and returns the last one, if any, or `None` . We know that all the
    items in the list are of the same type, but we don’t know what type it is. How
    can we annotate the function properly? The concept of generics helps us do that.
    The syntax is only a tad more extravagant than what we have seen till now, but
    it is not that complicated. Let us write that function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个 `last()` 函数，它接受任何类型的项的列表，并返回最后一个项（如果有），或者返回 `None`。我们知道列表中的所有项都是同一类型，但我们不知道它是什么类型。我们如何正确地注解这个函数呢？泛型的概念帮助我们做到这一点。语法只是比我们之前看到的稍微复杂一点，但并不复杂。让我们编写这个函数：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Pay particular attention to the highlighted sections in the code above. First,
    we need to add a `[T]` as a suffix to the function’s name. Then, we can specify
    that `items` is a list of objects whose type is `T` , whatever that might be.
    Finally, we can also use `T` for the return value, although, in this case, we
    have specified the return type to be the union of `T` and `None` , to cater for
    the edge case in which `items` would be empty.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请特别注意上述代码中突出显示的部分。首先，我们需要在函数名称后添加一个 `[T]` 作为后缀。然后，我们可以指定 `items` 是一个对象列表，其类型为
    `T`，无论它是什么类型。最后，我们还可以使用 `T` 来指定返回值，尽管在这种情况下，我们已经指定了返回类型为 `T` 和 `None` 的联合，以应对
    `items` 为空的情况。
- en: 'Even though the function signature is using the generic syntax, you would call
    it like this: `last([1, 2, 3])` .'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数签名使用了泛型语法，但你会这样调用它：`last([1, 2, 3])`。
- en: 'Syntactic support for generics is new to Python 3.12. Before that, to achieve
    the same result, one would have resorted to using the `TypeVar` factory, like
    this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的语法支持是 Python 3.12 的新特性。在此之前，为了达到相同的效果，人们会求助于使用 `TypeVar` 工厂，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that `first()` is not defined as `first[U](…)` in this case.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，`first()` 并没有定义为 `first[U](…)`。
- en: Thanks to the enhancements in the syntax of Python 3.12, the use of generics
    is now simpler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 3.12 语法上的增强，泛型的使用现在变得更加简单。
- en: Annotating variables
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量注解
- en: 'Let us now take a little detour from functions and discuss variable annotations.
    We can quickly show you an example that will not require much of an explanation:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时从函数转向，讨论变量注解。我们可以快速展示一个不需要太多解释的例子：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the code above, we have declared `x` to be many things, as an example. As
    you can see, the syntax is simple: we declare the name of the variable, its type
    (after the colon), and its value (after the equal sign). We also have provided
    you with a few examples of how one had to annotate variables in earlier versions
    of Python. Quite conveniently, in Python 3.12, we can use built-in types directly
    without having to import much from the `typing` module.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们声明 `x` 是许多东西，仅作为一个例子。正如你所见，语法很简单：我们声明变量的名称，其类型（冒号之后），以及其值（等号之后）。我们还为你提供了一些如何在前几版
    Python 中注解变量的例子。方便的是，在 Python 3.12 中，我们可以直接使用内置类型，而无需从 `typing` 模块导入很多内容。
- en: Annotating containers
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器注解
- en: 'The typing system assumes that all elements in Python containers will be of
    the same type. This is true for most containers. For example, consider the following
    code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类型系统假定Python容器中的所有元素都将具有相同的类型。对于大多数容器来说这是真的。例如，考虑以下代码：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see in the code above, `list` expects one type argument. In this
    context, a union, like `int | str` in the annotation of `c` , still counts as
    one type. However, the type checker will complain about `b` . This reflects the
    fact that lists in Python are typically used to store an arbitrary number of items
    of the same type.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的代码所示，`list`期望一个类型参数。在这种情况下，一个联合，如`c`注释中的`int | str`，仍然算作一个类型。然而，类型检查器会对`b`提出抱怨。这反映了Python中的列表通常用于存储任意数量的同一类型的项目。
- en: Containers that have elements of the same type are called *homogeneous* .
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 包含相同类型元素的容器被称为*同构的*。
- en: Notice that, even though the syntax is similar, `dict` expects a type for its
    keys and one for its values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管语法相似，`dict`期望其键和值都有类型。
- en: Annotating tuples
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释元组
- en: Unlike most other container types, it is common for tuples to contain a fixed
    number of items with specific types expected in each position. Tuples containing
    different types are called *heterogeneous* . Because of this, tuples are treated
    in a special way by the typing system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他容器类型不同，元组通常包含固定数量的项目，每个位置都期望有特定的类型。包含不同类型的元组被称为*异构的*。正因为如此，元组在类型系统中被特殊处理。
- en: 'There are three ways to annotate tuple types:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式来注释元组类型：
- en: 'Tuples of fixed length, which can be further categorized into:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定长度的元组，可以进一步分为：
- en: Tuples without named fields
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有命名字段的元组
- en: Tuples with named fields
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有命名字段的元组
- en: Tuples of *arbitrary* length
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意长度的元组
- en: Fixed-length tuples
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定长度元组
- en: Let us see an example of fixed-length tuples, without named fields.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个固定长度元组的例子，没有命名字段。
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the code above, both `a` and `b` are annotated correctly. However, `c` is
    incorrect, because the annotation indicates a tuple of length `1` , but `c` is
    of length `3` .
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`a`和`b`都被正确注释了。然而，`c`是不正确的，因为注释表明这是一个长度为`1`的元组，但`c`的长度是`3`。
- en: Tuples with named fields
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有命名字段的元组
- en: 'When tuples have more than one or two fields, or when they are used in several
    places in the codebase, it can be useful to annotate them using `typing.NamedTuple`
    . Here is a simple example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当元组有多个或两个以上的字段，或者它们在代码库的多个地方使用时，使用`typing.NamedTuple`来注释它们可能很有用。这里有一个简单的例子：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see by the results of the `print()` calls, this is equivalent to
    declaring a tuple, as we learned in *Chapter 2* , *Built-In Data Types* :'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如通过`print()`调用的结果所见，这相当于声明一个元组，正如我们在*第二章*，*内置数据类型*中学到的：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using `typing.NamedTuple` not only allows us to correctly annotate the tuple
    but we can even specify default values if we wish:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`typing.NamedTuple`不仅允许我们正确注释元组，如果我们愿意，甚至可以指定默认值：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice how, in the above code, we didn’t specify the third argument when we
    created `p` , but `z` still got assigned to `0` correctly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上面的代码中，当我们创建`p`时没有指定第三个参数，但`z`仍然正确地分配给了`0`。
- en: Tuples of arbitrary length
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任意长度的元组
- en: 'If we want to specify a tuple of arbitrary length in which all elements are
    of the same type, we can use a specific syntax. This can be useful, for example,
    when we use tuples as immutable sequences. Let us see a few examples:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要指定一个任意长度的元组，其中所有元素都是同一类型，我们可以使用特定的语法。这可能在某些情况下很有用，例如，当我们使用元组作为不可变序列时。让我们看看几个例子：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, there are plenty of ways to annotate a tuple. The choice of
    how strict you want to be is up to you. Remember to be consistent with the rest
    of the codebase. Also, be mindful of the value that annotations add to your code.
    If you are writing a library that is supposed to be published and used by other
    developers, it might make sense to be quite precise in the annotations. On the
    other hand, being too strict or restrictive for no good reason can hurt your productivity,
    especially in situations where such precision is not needed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有无数种方式可以注释一个元组。你想要有多严格的选择取决于你。记住要与其他代码库保持一致。同时，要意识到注释为你的代码带来的价值。如果你正在编写一个打算发布并供其他开发者使用的库，那么在注释中非常精确可能是有意义的。另一方面，没有充分的理由就过于严格或限制可能会损害你的生产力，尤其是在这种精确度不是必需的情况下。
- en: Abstract base classes (ABCs)
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象基类（ABCs）
- en: In older versions of Python, the `typing` module would provide several generic
    versions of types. For example, lists, tuples, sets, and dictionaries, could be
    annotated using the generic concrete collections `List` , `Tuple` , `Set` , `Dict`
    , and so on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 的旧版本中，`typing` 模块会提供几种类型的泛型版本。例如，列表、元组、集合和字典可以使用泛型具体集合 `List` 、`Tuple`
    、`Set` 、`Dict` 等进行注释。
- en: Starting from Python 3.9, these generic collections have been deprecated in
    favor of their corresponding built-in, which means that, for example, it is possible
    to annotate a list using `list` itself, without needing `typing.List` .
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.9 开始，这些泛型集合已经被弃用，转而使用相应的内置类型，这意味着，例如，可以使用 `list` 本身来注释列表，而不需要 `typing.List`
    。
- en: The documentation also points out that these generic collections should be used
    to annotate return values, whereas parameters should be annotated using abstract
    collections. For example, we should use `collections.abc.Sequence` to annotate
    read-only and mutable sequences, like `list` , `tuple` , `str` , `bytes` , and
    so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还指出，这些泛型集合应该用于注释返回值，而参数应该使用抽象集合进行注释。例如，我们应该使用 `collections.abc.Sequence` 来注释只读和可变序列，如
    `list` 、`tuple` 、`str` 、`bytes` 等等。
- en: 'This is in line with **Postel’s law** , also known as the **robustness principle**
    , which postulates:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 **Postel 的法则** 一致，也称为 **鲁棒性原则** ，它假设：
- en: ”Be conservative in what you send, be liberal in what you accept.”
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “发送时要保守，接受时要宽容。”
- en: '*Be liberal in what you accept* means that we should not be too restrictive
    in the way we annotate parameters. If a function takes a parameter called `items`
    , and all it does to it is iterate, or access an item based on its position, it
    makes no difference if `items` is a list or a tuple. Therefore, we should not
    annotate with `tuple` or `list` but use `collections.abc.Sequence` to allow `items`
    to be passed either as a tuple or a list.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*接受时要宽容* 意味着我们在注释参数时不应过于限制。如果一个函数接受一个名为 `items` 的参数，并且它所做的只是迭代或根据位置访问一个项目，那么
    `items` 是列表还是元组无关紧要。因此，我们不应使用 `tuple` 或 `list` 进行注释，而应使用 `collections.abc.Sequence`
    允许 `items` 以元组或列表的形式传递。'
- en: Imagine a situation where you annotate `items` using `tuple` . After a while,
    you refactor the code and now `items` is passed as a list. The function now has
    the wrong annotation, as `items` is no longer a tuple. Had we used `collections.abc.Sequence`
    instead, the function would not require any fixing, since both `tuple` and `list`
    would be okay.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这样的场景：你使用 `tuple` 来注释 `items` 。过了一段时间，你重构了代码，现在 `items` 作为列表传递。由于 `items`
    已不再是元组，函数的注释现在是不正确的。如果我们使用了 `collections.abc.Sequence` ，那么函数就不需要任何修改，因为 `tuple`
    和 `list` 都是可行的。
- en: 'Let us see an example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The above functions should help clarify things. Take `average_bad()` , for example.
    If we passed `v` as a tuple, it would disagree with the function annotation we
    used, which is `list` . On the other hand, `average()` does not suffer from the
    same issue. And of course, we can follow the same reasoning for `greet_user_bad()`
    and `greet_user()` .
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数应该有助于澄清问题。以 `average_bad()` 为例。如果我们传递 `v` 作为元组，它就会与我们所使用的函数注释不符，该注释是 `list`
    。另一方面，`average()` 没有这个问题。当然，我们也可以用同样的推理来分析 `greet_user_bad()` 和 `greet_user()`
    。
- en: Going back to Postel’s Law, when it comes to return values, it is better to
    be conservative, which means to be specific. Return values should be precise in
    indicating what the function returns.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Postel 的法则，当涉及到返回值时，最好是保守的，这意味着要具体。返回值应该精确地表明函数返回了什么。
- en: This is quite important, especially for the caller, who needs to know the type
    of object they will receive when calling the function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要，特别是对于调用者来说，他们需要知道在调用函数时将接收到的对象类型。
- en: 'Here is another simple example, from the same file, that should help:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，来自同一文件，应该有助于理解：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the two functions above, we simply add some pretend connection defaults to
    whatever is passed in the `data` argument (provided `"host"` and `"port"` keys
    are missing in `data` ). The `add_defaults_bad()` function specifies `Mapping`
    as the return type. The problem with this is that it is too generic. Objects such
    as `dict` and its siblings from the `collections` module, `defaultdict` , `Counter`
    , `OrderedDict` , `ChainMap` , and `UserDict` , for example, all implement the
    `Mapping` interface. This makes things quite confusing for the caller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述两个函数中，我们只是将一些假设的连接默认值添加到 `data` 参数传递的任何内容上（如果 `data` 中缺少 `"host"` 和 `"port"`
    键）。`add_defaults_bad()` 函数指定返回类型为 `Mapping`。问题是这太泛了。例如，`dict` 和来自 `collections`
    模块的 `defaultdict`、`Counter`、`OrderedDict`、`ChainMap` 和 `UserDict` 等对象都实现了 `Mapping`
    接口。这使得调用者感到非常困惑。
- en: 'On the other hand, `add_defaults()` is a better function, in that it specifies
    precisely the return type: `dict` .'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`add_defaults()` 是一个更好的函数，因为它精确地指定了返回类型：`dict`。
- en: Commonly used ABCs include `Iterable` , `Iterator` , `Collection` , `Sequence`
    , `Mapping` , `Set` , `MutableSequence` , `MutableMapping` , `MutableSet` , and
    `Callable` .
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的 ABC 包括 `Iterable`、`Iterator`、`Collection`、`Sequence`、`Mapping`、`Set`、`MutableSequence`、`MutableMapping`、`MutableSet`
    和 `Callable`。
- en: 'Let us see a dummy example with `Iterable` :'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个使用 `Iterable` 的示例：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All the `process_items()` function needs to do is iterate over `items` ; therefore,
    we use `Iterable` to annotate it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_items()` 函数需要做的只是遍历 `items`；因此，我们使用 `Iterable` 来注释它。'
- en: 'A more interesting example can be offered for `Callable` :'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Callable` 可以提供一个更有趣的例子：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we have the `process_callback()` function, which defines a string parameter,
    `arg` , and a `callback` callable object. We have two functions that follow, whose
    signature specifies a string parameter in input, and a string object as the return
    value. Notice how the type annotation for `callback` , which is `Callable[[str],
    str]` , indicates that the `callback` argument should take one string argument
    in input and return a string in output. When we call these functions with the
    following code, we get the output that is indicated in the inline comments.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有 `process_callback()` 函数，它定义了一个字符串参数 `arg` 和一个 `callback` 可调用对象。接下来有两个函数，它们的签名指定了输入参数为字符串，返回值为字符串对象。注意
    `callback` 的类型注解 `Callable[[str], str]`，它表明 `callback` 参数应该接受一个字符串输入参数并返回一个字符串输出。当我们用以下代码调用这些函数时，我们得到的是内联注释中指示的输出。
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This concludes our tour of abstract base classes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对抽象基类的巡礼。
- en: Special typing primitives
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊类型原语
- en: 'In the `typing` module, there is also a category of objects called **Special
    Typing Primitives** , which are quite interesting, and it is useful to know at
    least the most common of them. We have already seen one example: `Any` .'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `typing` 模块中，还有一个称为 **特殊类型原语** 的对象类别，它们非常有趣，了解其中最常见的一些是有用的。我们已经看到了一个例子：`Any`。
- en: 'Other notable examples are:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的例子包括：
- en: '`AnyStr` : Used to annotate functions that can accept `str` or `bytes` arguments
    but cannot allow the two to mix. This is known as a **constrained type variable**
    , which means that the type can only ever be exactly one of the constraints given.
    In the case of `AnyStr` , it is either `str` or `bytes` .'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnyStr`：用于注释可以接受 `str` 或 `bytes` 参数但不能混合两者的函数。这被称为 **约束类型变量**，意味着类型只能是给定的约束之一。在
    `AnyStr` 的情况下，它要么是 `str`，要么是 `bytes`。'
- en: '`LiteralString` : A special type that includes only literal strings.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiteralString`：一个只包含字面字符串的特殊类型。'
- en: '`Never` / `NoReturn` : Can be used to indicate that a function never returns
    – for example, it might raise an exception.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Never` / `NoReturn`：可以用来表示函数永远不会返回——例如，它可能会引发异常。'
- en: '`TypeAlias` : Deprecated in favor of the `type` statement.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeAlias`：已被 `type` 语句取代。'
- en: Finally, the `Self` type deserves a little more consideration.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Self` 类型值得更多关注。
- en: The Self type
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Self` 类型'
- en: 'The `Self` type was added in Python 3.11, and it is a special type used to
    represent the current enclosed class. Let us see an example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Self` 类型是在 Python 3.11 中添加的，它是一个特殊类型，用于表示当前封装的类。让我们看一个例子：'
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the above code, we have created a simple class, `Point` , which represents
    a three-dimensional point in space. To show you how to use the `Self` type, we
    have created a `sum_points()` class method, which takes an iterable, `points`
    , and produces a `Point` object in return, whose coordinates are the sums of the
    corresponding coordinates in all the items in `points` .
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个简单的类`Point`，它表示空间中的一个三维点。为了展示如何使用`Self`类型，我们创建了一个`sum_points()`类方法，它接受一个可迭代的`points`，并返回一个`Point`对象，其坐标是`points`中所有项对应坐标的总和。
- en: To annotate the `points` parameter, we pass `Self` to `Iterable` , and we do
    the same for the return value of the method. Before the introduction of the `Self`
    type, we would have had to create a unique “self” type variable for every class
    that needed it. You can find an example of this in the official documentation
    at [https://docs.python.org/3/library/typing.html#typing.Self](https://docs.python.org/3/library/typing.html#typing.Self)
    .
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要注解`points`参数，我们将`Self`传递给`Iterable`，并且对于方法的返回值也做同样的处理。在引入`Self`类型之前，我们不得不为每个需要它的类创建一个独特的“self”类型变量。你可以在官方文档中找到一个例子，见[https://docs.python.org/3/library/typing.html#typing.Self](https://docs.python.org/3/library/typing.html#typing.Self)。
- en: Notice that both the `self` and the `cls` parameters have no type annotation
    by convention.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，按照惯例，`self`和`cls`参数都没有类型注解。
- en: Let us now move on to see how to annotate variable parameters.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看如何注解可变参数。
- en: Annotating variable parameters
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解变量参数
- en: 'To annotate variable positional and keyword parameters, we use the same syntax
    we have seen until now. A quick example is better than any explanation:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要注解可变位置参数和关键字参数，我们使用迄今为止看到的相同语法。一个快速示例胜过任何解释：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the above example, we have written a dummy function, `add_query_params()`
    , that adds some query parameters to a collection of URLs. Notice how, in the
    function definition, we only needed to specify the type of the object contained
    in the tuple `urls` , and the type for the values of the `query_params` dictionary.
    Declaring `*urls: str` is equivalent to `tuple[str, …]` , while `**query_params:
    str` is equivalent to `dict[str, str]` .'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的例子中，我们编写了一个虚拟函数`add_query_params()`，它向一组URL添加一些查询参数。注意，在函数定义中，我们只需要指定元组`urls`中包含的对象的类型，以及`query_params`字典中值的类型。声明`*urls:
    str`等同于`tuple[str, …]`，而`**query_params: str`等同于`dict[str, str]`。'
- en: Protocols
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议
- en: Let us conclude our journey through type annotations by discussing **protocols**
    . In object-oriented programming, protocols define a set of methods that a class
    must implement without enforcing inheritance from any specific class. They are
    akin to the concept of interfaces in other languages, but they are more flexible
    and informal. They promote the use of polymorphism by allowing different classes
    to be used interchangeably if they follow the same protocol, even if they don’t
    share a common base class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过讨论**协议**来结束我们对类型注解的探索。在面向对象编程中，协议定义了一组类必须实现的方法，而不强制从任何特定类继承。它们类似于其他语言中的接口概念，但更加灵活和非正式。它们通过允许不同类在遵循相同协议的情况下可以互换使用来促进多态的使用，即使它们没有共享一个共同的基类。
- en: This concept has been part of Python since the beginning. This type of protocol
    is normally referred to as a **dynamic protocol** , and it is described in the
    Data Model chapter ( [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)
    ) of the **Python Language Reference** .
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念从 Python 的开始就一直是其一部分。这种类型的协议通常被称为**动态协议**，并在**Python 语言参考**的“数据模型”章节（[https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)）中进行了描述。
- en: In the context of type hints, however, a protocol is a subclass of `typing.Protocol`
    , which defines an interface that a type checker can verify.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在类型提示的上下文中，协议是`typing.Protocol`的子类，它定义了一个类型检查器可以验证的接口。
- en: Introduced by PEP 544 ( [https://peps.python.org/pep-0544/](https://peps.python.org/pep-0544/)
    ), they enable structural subtyping (informally known as *static duck typing*
    ), which we explored briefly at the beginning of this chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由PEP 544（[https://peps.python.org/pep-0544/](https://peps.python.org/pep-0544/)）引入，它们实现了结构化子类型化（非正式地称为*静态鸭子类型*），我们在本章的开头简要探讨了这一点。
- en: The compatibility of an object with a protocol is determined by the presence
    of certain methods or attributes, rather than inheritance from a specific class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象与协议的兼容性是由某些方法或属性的存在来确定的，而不是从特定类继承。
- en: Protocols are therefore quite helpful in those cases where we cannot easily
    define a type, and instead, it is more convenient to express the annotation in
    the form of *“it should support certain methods or have certain attributes.”*
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在那些我们无法轻松定义类型的情况下，协议非常有用，并且更方便以“它应该支持某些方法或具有某些属性”的形式表达注释。
- en: Protocols defined by PEP 544 are commonly referred to as **static protocols**
    .
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由PEP 544定义的协议通常被称为**静态协议**。
- en: 'Dynamic and static protocols present two key differences:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 动态和静态协议存在两个关键区别：
- en: Dynamic protocols allow for partial implementation. This means an object can
    provide an implementation for only a subset of the methods of the protocol and
    still be useful. However, static protocols require an object to provide *every*
    method declared in the protocol, even if the software doesn’t need them all.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态协议允许部分实现。这意味着一个对象可以只为协议中的一部分方法提供实现，并且仍然是有用的。然而，静态协议要求对象提供协议中声明的所有方法，即使软件不需要它们全部。
- en: Static protocols can be verified by static type checkers, while dynamic ones
    cannot.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态协议可以被静态类型检查器验证，而动态协议则不能。
- en: 'You can find a list of the protocols provided by the `typing` module here:
    [https://docs.python.org/3/library/typing.html#protocols](https://docs.python.org/3/library/typing.html#protocols)
    . Their names are prefixed with the word `Supports` , followed by a title-cased
    version of the dunder method they declare to support. Some examples are:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到`typing`模块提供的协议列表：[https://docs.python.org/3/library/typing.html#protocols](https://docs.python.org/3/library/typing.html#protocols)。它们的名称以前缀词`Supports`开头，后面跟着它们声明的支持方法的标题化版本。一些例子包括：
- en: '`SupportsAbs` : An ABC with one abstract method, `__abs__` .'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SupportsAbs`：一个具有一个抽象方法`__abs__`的ABC。'
- en: '`SupportsBytes` : An ABC with one abstract method, `__bytes__` .'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SupportsBytes`：一个具有一个抽象方法`__bytes__`的ABC。'
- en: '`SupportsComplex` : An ABC with one abstract method, `__complex__` .'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SupportsComplex`：一个具有一个抽象方法`__complex__`的ABC。'
- en: Other protocols that used to live in the `typing` module but have been migrated
    to `collections.abc` are `Iterable` , `Iterator` , `Sized` , `Container` , `Collection`
    , `Reversible` , and `ContextManager` , to name just a few.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其他曾经存在于`typing`模块但现在已迁移到`collections.abc`的协议包括`Iterable`、`Iterator`、`Sized`、`Container`、`Collection`、`Reversible`和`ContextManager`，仅举几个例子。
- en: 'You can find the complete list in the Mypy documentation: [https://mypy.readthedocs.io/en/stable/protocols.html#predefined-protocols-reference](https://mypy.readthedocs.io/en/stable/protocols.html#predefined-protocols-reference)
    .'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Mypy 文档中找到完整的列表：[https://mypy.readthedocs.io/en/stable/protocols.html#predefined-protocols-reference](https://mypy.readthedocs.io/en/stable/protocols.html#predefined-protocols-reference)。
- en: 'Now that we have an idea about what a protocol is, in the context of type hints,
    let us see an example that shows how to create a simple custom protocol:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对协议有了概念，在类型提示的背景下，让我们看看一个例子，展示如何创建一个简单的自定义协议：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the code above, we define a protocol class, `SupportsStart` , which has
    one method: `start()` . To make it a static protocol, `SupportsStart` inherits
    from `Protocol` . The interesting part comes right after it, when we create the
    `Worker` class. Note that there is no need for it to inherit from the `SupportsStart`
    class. The `Worker` class only needs to fulfill the protocol, which means it needs
    to have a `start()` method.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了一个协议类`SupportsStart`，它有一个方法：`start()`。为了使其成为静态协议，`SupportsStart`从`Protocol`继承。有趣的部分就在这里，当我们创建`Worker`类时。请注意，没有必要从`SupportsStart`类继承。`Worker`类只需要满足协议，这意味着它需要一个`start()`方法。
- en: We also wrote a function, `start_workers()` , which takes a parameter, `workers`
    , annotated as `Iterable[SupportsStart]` . That is all that is required to use
    a protocol. We define a couple of workers, `Alice` and `Bob` , and we pass them
    to the function call.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还编写了一个函数`start_workers()`，它接受一个参数`workers`，被注释为`Iterable[SupportsStart]`。这就是使用协议所需的所有内容。我们定义了几个工人，`Alice`和`Bob`，并将它们传递给函数调用。
- en: 'Running the above example will produce the following output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的例子将产生以下输出：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now imagine we also wanted to stop a worker. This is a more interesting case
    because it allows us to discuss how to subclass protocols. Let us see an example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们还想停止一个工人。这是一个更有趣的情况，因为它允许我们讨论如何子类化协议。让我们看看一个例子：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the above example, we learned that we can compose protocols as we would do
    mixins. The one key difference is that when we subclass a protocol class, as in
    the case of `SupportsWorkCycle` , we still need to explicitly add `Protocol` to
    the list of base classes. If we do not do this, the static type checker will complain.
    This is because inheriting from an existing protocol does not automatically turn
    the subclass into a protocol. It only creates a regular class or ABC that implements
    the given protocol(s).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们了解到我们可以像使用混入（mixins）一样组合协议。一个关键的区别是，当我们从协议类继承，例如在`SupportsWorkCycle`的情况下，我们仍然需要显式地将`Protocol`添加到基类列表中。如果我们不这样做，静态类型检查器会报错。这是因为从现有协议继承并不会自动将子类转换为协议。它只会创建一个实现给定协议的常规类或ABC。
- en: 'You can find more information about protocols in the Mypy documentation: [https://mypy.readthedocs.io/en/stable/protocols.html](https://mypy.readthedocs.io/en/stable/protocols.html)
    .'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Mypy文档中找到有关协议的更多信息：[https://mypy.readthedocs.io/en/stable/protocols.html](https://mypy.readthedocs.io/en/stable/protocols.html)。
- en: Let us now discuss Mypy, the static type checker most widely adopted by the
    Python community.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论Mypy，这是Python社区最广泛采用的静态类型检查器。
- en: The Mypy static type checker
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mypy静态类型检查器
- en: 'There are several static type checkers for Python. Currently, the most widely
    adopted are:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Python有几种静态类型检查器。目前最广泛采用的是：
- en: '**Mypy** : Designed to work seamlessly with Python’s type annotations defined
    by PEP 484, it supports gradual typing, integrates well with existing codebases,
    and has extensive documentation. You can find it at [https://mypy.readthedocs.io/](https://mypy.readthedocs.io/)
    .'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mypy**：设计用于与Python的PEP 484定义的类型注解无缝工作，支持渐进式类型，与现有代码库集成良好，并拥有广泛的文档。您可以在[https://mypy.readthedocs.io/](https://mypy.readthedocs.io/)找到它。'
- en: '**Pyright** : Developed by Microsoft, this fast type checker is optimized for
    use with Visual Studio Code. It does incremental analysis for fast type checking
    and supports both TypeScript and Python. You can find it at [https://github.com/microsoft/pyright](https://github.com/microsoft/pyright)
    .'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pyright**：由Microsoft开发，这是一个快速的类型检查器，针对Visual Studio Code进行了优化。它进行增量分析以实现快速类型检查，并支持TypeScript和Python。您可以在[https://github.com/microsoft/pyright](https://github.com/microsoft/pyright)找到它。'
- en: '**Pylint** : A comprehensive static analysis tool that includes type checking
    along with linting and code quality checks. It’s highly configurable, supports
    custom plugins, and generates detailed code quality reports. You can find it at
    [https://pylint.org/](https://pylint.org/) .'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pylint**：一个综合的静态分析工具，包括类型检查、代码质量检查以及代码风格检查。它高度可配置，支持自定义插件，并生成详细的代码质量报告。您可以在[https://pylint.org/](https://pylint.org/)找到它。'
- en: '**Pyre** : Developed by Facebook, it’s fast and scalable, and works well with
    large codebases. It supports gradual typing, and has a powerful type inference
    engine. It also integrates well with continuous integration systems. You can find
    it at [https://pyre-check.org/](https://pyre-check.org/) .'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pyre**：由Facebook开发，它速度快，可扩展，并且与大型代码库配合良好。它支持渐进式类型，并拥有强大的类型推断引擎。它还很好地与持续集成系统集成。您可以在[https://pyre-check.org/](https://pyre-check.org/)找到它。'
- en: '**Pytype** : Developed by Google, it infers types automatically and reduces
    the need for explicit annotations, which it can generate. It integrates well with
    Google open-source tools. You can find it at [https://github.com/google/pytype](https://github.com/google/pytype)
    .'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pytype**：由Google开发，它自动推断类型并减少了对显式注解的需求，它可以生成这些注解。它与Google开源工具集成良好。您可以在[https://github.com/google/pytype](https://github.com/google/pytype)找到它。'
- en: For this section of the chapter, we have decided to go with Mypy, since it currently
    seems to be the most popular.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的这一部分，我们决定使用Mypy，因为它目前似乎是最受欢迎的。
- en: 'To install it in your virtual environment, you can run the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要在虚拟环境中安装它，您可以运行以下命令：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Mypy is also included in the requirements file for this chapter. When Mypy
    is installed, you can run it against any files or folders you want. Mypy will
    recursively traverse any folder to find Python modules ( `*.py` files). Here is
    an example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy也被包含在本章的要求文件中。当Mypy安装后，您可以对任何文件或文件夹运行它。Mypy将递归遍历任何文件夹以查找Python模块（`*.py`文件）。以下是一个示例：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The command sports a massive set of options, which we encourage you to explore
    by running:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提供了一组庞大的选项，我们鼓励您通过运行以下命令来探索：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let us start with a very simple example of a function that has no annotations
    and see the outcome of running `mypy` against it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单的没有注解的函数示例开始，看看运行`mypy`后的结果。
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running `mypy` on this module gives this result:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模块上运行 `mypy` 得到以下结果：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is probably not what you expected, but Mypy is designed to support gradually
    adding type annotations to existing codebases. Outputting error messages for unannotated
    code would discourage developers from using it in this way. Therefore, the default
    behavior is to ignore functions that have no annotations. If we wanted Mypy to
    check the `hypothenuse()` function anyway, we could run it like this (notice we
    have re-formatted the output to fit the book’s width):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是您预期的结果，但 Mypy 被设计成支持逐步向现有代码库添加类型注解。为未注解的代码输出错误信息会阻止开发者以这种方式使用它。因此，默认行为是忽略没有注解的函数。如果我们想无论如何都让
    Mypy 检查 `hypothenuse()` 函数，我们可以这样运行它（注意我们已重新格式化输出以适应书籍的宽度）：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now Mypy is telling us that the function is missing a type annotation, so let
    us fix that.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Mypy 告诉我们，该函数缺少类型注解，因此让我们修复它。
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can run `mypy` again:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次运行 `mypy`：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Excellent – now the function is annotated, and `mypy` runs successfully. Let
    us try out some function calls:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀——现在函数已添加注解，`mypy` 运行成功。让我们尝试一些函数调用：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first two calls are fine, but the last one generates an error:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个调用是好的，但最后一个产生了错误：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Mypy is informing us that passing a `complex` where a `float` is required is
    not okay. The two types are not compatible.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 通知我们，传递一个 `complex` 类型而不是所需的 `float` 类型是不可以的。这两种类型不兼容。
- en: 'Let us try a slightly more complex example (no pun intended):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个稍微复杂一点的例子（无意中打趣）：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The above function applies title-casing to each string in `names` . First,
    we call it once, with the strings `"ALICE"` and `"bob"` , and then we call it
    with the `bytes` objects `b"ALICE"` and `b"bob"` . Both calls succeed because
    both the `str` and `bytes` objects have `title()` methods. However, running `mypy`
    yields the following result:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将 `names` 中的每个字符串应用为首字母大写格式。首先，我们用字符串 `"ALICE"` 和 `"bob"` 调用它一次，然后我们用 `bytes`
    对象 `b"ALICE"` 和 `b"bob"` 调用它。这两个调用都成功了，因为 `str` 和 `bytes` 对象都有 `title()` 方法。然而，运行
    `mypy` 得到以下结果：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once again, Mypy is pointing out the incompatibility of two types – this time,
    `str` and `bytes` . We can easily fix this, by either amending the second call
    or changing the type annotation on the function. Let us do the latter:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Mypy 指出两种类型的兼容性问题——这次是 `str` 和 `bytes`。我们可以很容易地修复这个问题，通过修改第二个调用或更改函数上的类型注解。让我们做后者：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, we use the union of the `str` and `bytes` types in the annotation, and
    `mypy` runs successfully.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在注解中使用 `str` 和 `bytes` 类型的联合，`mypy` 运行成功。
- en: Our advice is to install Mypy and run it against any existing codebase you might
    have. Try to introduce type annotations gradually and use Mypy to check the correctness
    of your code. This exercise will help you to acquire familiarity with type hints,
    and it will also benefit your code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议是安装 Mypy 并将其运行在您可能拥有的任何现有代码库上。尝试逐步引入类型注解，并使用 Mypy 检查您代码的正确性。这项练习将帮助您熟悉类型提示，并且对您的代码也有益处。
- en: Some useful resources
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些有用的资源
- en: 'We would recommend reading through (or at least skimming) all the PEPs we listed
    at the beginning of the chapter. We also recommend studying the various resources
    we pointed out along the way, some of which are listed below for your convenience:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您阅读本章开头列出的所有 PEP（Python Enhancement Proposals）。我们还建议您研究我们在过程中提到的各种资源，其中一些列在下面供您方便查阅：
- en: 'Python Typing Documentation:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 类型提示文档：
- en: '[https://typing.readthedocs.io/en/latest/](https://typing.readthedocs.io/en/latest/)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://typing.readthedocs.io/en/latest/](https://typing.readthedocs.io/en/latest/)'
- en: 'Static Typing with Python:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 进行静态类型：
- en: '[https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)'
- en: 'Abstract Base Classes:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类：
- en: '[https://docs.python.org/3/library/abc.html](https://docs.python.org/3/library/abc.html)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/abc.html](https://docs.python.org/3/library/abc.html)'
- en: 'Abstract Base Classes for Containers:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的抽象基类：
- en: '[https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)'
- en: 'The Mypy Documentation:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mypy 文档：
- en: '[https://mypy.readthedocs.io/en/stable/](https://mypy.readthedocs.io/en/stable/)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mypy.readthedocs.io/en/stable/](https://mypy.readthedocs.io/en/stable/)'
- en: 'There is also a quick *Python Types Intro* section in the FastAPI framework
    documentation, which we would recommend reading: [https://fastapi.tiangolo.com/python-types/](https://fastapi.tiangolo.com/python-types/)
    .'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 框架文档中还有一个快速的 *Python 类型简介* 部分，我们建议您阅读：[https://fastapi.tiangolo.com/python-types/](https://fastapi.tiangolo.com/python-types/)。
- en: '**FastAPI** is a modern Python framework for building APIs. *Chapter 14* ,
    *Introduction to API Development* , is dedicated to it, so we recommend at least
    reading the introduction on types prior to reading that chapter.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**FastAPI** 是一个用于构建 API 的现代 Python 框架。*第 14 章*，*API 开发简介*，专门介绍它，所以我们建议在阅读该章节之前至少阅读关于类型的介绍。'
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have explored the topic of type hints in Python. We started
    by understanding Python’s native approach to types and walked through the history
    of type hints, which were introduced gradually from Python 3 and are still evolving.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Python 中的类型提示主题。我们首先理解了 Python 对类型的原生方法，并回顾了类型提示的历史，这些类型提示是从 Python
    3 逐步引入的，并且仍在不断发展。
- en: We investigated the benefits of type hints and then learned how to annotate
    functions, classes, and variables. We explored the basics and discussed the main
    built-in types, but also ventured through more advanced topics, such as generics,
    abstract base classes, and protocols.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了类型提示的好处，然后学习了如何注释函数、类和变量。我们探讨了基础知识，并讨论了主要内置类型，同时也涉猎了更高级的主题，如泛型、抽象基类和协议。
- en: Finally, we offered a few examples of how to use the most popular static type
    checker, Mypy, to gradually introduce typing in a codebase and finished the chapter
    with a short recap of the most useful resources for you to further investigate
    this subject.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提供了一些如何使用最受欢迎的静态类型检查器 Mypy 的示例，以逐步引入代码库中的类型检查，并以一个简短的回顾结束本章，回顾了您进一步研究此主题最有用的资源。
- en: This brings us to the end of the theory part of the book. The remaining chapters
    are project-oriented and take a more practical approach, starting with an introduction
    to data science. The knowledge acquired by studying the chapters in the first
    part should be sufficient to support you while you make your way through the next
    chapters.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的理论部分到此结束。剩余的章节是项目导向的，采用更实际的方法，从数据科学的介绍开始。通过学习第一部分的内容所获得的知识应该足以支持您在阅读下一章时的学习。
- en: Join our community on Discord
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区空间，与作者和其他读者进行讨论：
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_12.xhtml)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.com/invite/uaKmaz7FEC](Chapter_12.xhtml)'
- en: '![img](img/QR_Code119001106417026468.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![img](img/QR_Code119001106417026468.png)'
