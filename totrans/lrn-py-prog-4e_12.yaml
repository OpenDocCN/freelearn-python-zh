- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Type Hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”Knowing yourself is the beginning of all wisdom.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Aristotle
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the topic of **type hinting** . Type
    hinting is perhaps the biggest change introduced in Python since Python 2.2, which
    saw the unification of types and classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will study the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python approach to types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types available for annotations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols (in brief).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mypy, a static type checker for Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python approach to types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is both a **strongly typed** and a **dynamically typed** language.
  prefs: []
  type: TYPE_NORMAL
- en: '*Strongly typed* means that Python does not allow implicit type conversions
    that could lead to unexpected behaviors. Consider the following **php** code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In php, variables are prepended with a `$` sign. In the above code, we set
    `$a` to the integer number `2` , and `$b` to the string `"2"` . To add them together,
    php performs an implicit conversion of `$b` , from string to integer. This is
    referred to as **type juggling** . This might seem a convenient feature, but the
    fact that php is weakly typed has the potential to lead to bugs in the code. If
    we tried to do the same in Python, the result would be much different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the above produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Python is strongly typed, so when we try to add an integer to a string – or
    any pair of incompatible types – we get `TypeError` .
  prefs: []
  type: TYPE_NORMAL
- en: '*Dynamically typed* means that Python determines the type of a variable at
    runtime, which means that we do not specify types explicitly in the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, languages like C++, Java, C#, and Swift are all **statically typed**
    . When we declare variables in these languages, we must specify their type. For
    example, in Java, it is common to see variables declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are pros and cons to both approaches, so it’s hardly a matter of which
    is best. Python was designed to be concise, lean, and elegant. One of the advantages
    of its design is known as **duck typing** .
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another concept that Python helped popularize is **duck typing** . In essence,
    this means that the type or class of an object is less important than the methods
    it defines or the operations it supports. As the saying goes: *“If it looks like
    a duck, swims like a duck, and quacks like a duck, then it probably is a duck.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duck typing is used extensively in Python because the language is dynamically
    typed. It allows for greater flexibility and code reuse. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, the `print_shape_info()` function does not care about the
    specific type of `shape` . It only cares that `shape` has a method called `area()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: History of type hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Python’s approach to types is one of the features that contributed
    to the success of its wide adoption, in Python 3, we saw the beginning of a gradual
    and carefully designed evolution toward the integration of type safety features
    that still maintained Python’s dynamic nature.
  prefs: []
  type: TYPE_NORMAL
- en: This began in Python 3.0, with the introduction of function annotations, through
    PEP 3107 ( [https://peps.python.org/pep-3107/](https://peps.python.org/pep-3107/)
    ). This addition allowed developers to add arbitrary metadata to function parameters
    and return values. These annotations were initially intended as a tool for documentation
    and had no semantic meaning. This step was the foundation layer that allowed the
    introduction of the explicit support of type hinting.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.5, with the landing of PEP 484 ( [https://peps.python.org/pep-0484/](https://peps.python.org/pep-0484/)
    ), the real inception of type hinting came about. PEP 484 formalized the addition
    of type hints, building on the syntax laid out by PEP 3107. It defined a standard
    way to declare types for function parameters, return values, and variables.
  prefs: []
  type: TYPE_NORMAL
- en: This enabled optional static type checking, and developers could now use tools
    like **Mypy** to detect type-related errors before runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.6, we saw the introduction of annotations for variable declarations.
    This was brought by PEP 526 ( [https://peps.python.org/pep-0526/](https://peps.python.org/pep-0526/)
    ). This new addition meant that types could be explicitly declared throughout
    the code, and not just in functions. It included class attributes and module-level
    variables as well. This further improved Python’s type hinting capabilities and
    made it easier to statically analyze code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsequent enhancements and PEPs refined and expanded Python’s type system
    even further. The main ones were the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PEP 544 ( [https://peps.python.org/pep-0544/](https://peps.python.org/pep-0544/)
    ) landed in Python 3.8 and introduced the concept of protocols, which enabled
    duck typing and further static type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 585 ( [https://peps.python.org/pep-0585/](https://peps.python.org/pep-0585/)
    ) landed in Python 3.9 and set another milestone. It revolutionized type hinting
    by integrating it directly with Python core collections. This removed the need
    to import types from the `typing` module for common data structures, such as dictionaries
    and lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 586 ( [https://peps.python.org/pep-0586/](https://peps.python.org/pep-0586/)
    ) landed in Python 3.8 and added literal types, allowing functions to specify
    literal values as parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 589 ( [https://peps.python.org/pep-0589/](https://peps.python.org/pep-0589/)
    ) landed in Python 3.8 and introduced `TypedDict` , which enabled precise type
    hints for dictionaries with a fixed set of keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 604 ( [https://peps.python.org/pep-0604/](https://peps.python.org/pep-0604/)
    ) landed in Python 3.10 and introduced a simplification of the syntax for union
    types, which streamlined annotations and improved the readability of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other notable PEPs are:'
  prefs: []
  type: TYPE_NORMAL
- en: PEP 561 ( [https://peps.python.org/pep-0561/](https://peps.python.org/pep-0561/)
    ), which specifies how to distribute packages that support type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 563 ( [https://peps.python.org/pep-0563/](https://peps.python.org/pep-0563/)
    ), which changed the evaluation of annotations such that they are not evaluated
    at function definition time. This postponement was made the default behavior in
    Python 3.10.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 593 ( [https://peps.python.org/pep-0593/](https://peps.python.org/pep-0593/)
    ), which introduced a way to augment existing type hints with arbitrary metadata,
    potentially for use by third-party tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 612 ( [https://peps.python.org/pep-0612/](https://peps.python.org/pep-0612/)
    ), which introduced parameter specifications, which allow more complex types of
    variable annotations, particularly useful for decorators that modify function
    signatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 647 ( [https://peps.python.org/pep-0647/](https://peps.python.org/pep-0647/)
    ), which introduced type guards, functions that enable more precise type inference
    in conditional blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PEP 673 ( [https://peps.python.org/pep-0673/](https://peps.python.org/pep-0673/)
    ), which introduced the `Self` type to represent the instance type within class
    bodies and method returns, making type hints involving classes more expressive
    and accurate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The evolution of type hinting in Python has been driven by the desire for greater
    robustness and scalability of code, leveraging the power of Python’s dynamic nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Python’s type hinting popularity seems to continuously increase, it
    is important to note that, according to the authors of PEP 484 (Guido van Rossum,
    Jukka Lehtosalo, and Łukasz Langa):'
  prefs: []
  type: TYPE_NORMAL
- en: ”Python will remain a dynamically typed language, and the authors have no desire
    to ever make type hints mandatory, even by convention.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The way in which Python’s type hinting has been introduced, and the philosophical
    approach of this PEP’s authors and Python’s lead developers, suggest that the
    choice of using type hinting is, and always will be, up to the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see some of the main benefits of type hinting.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of type hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adopting type hinting brings several key benefits, such as enhanced code quality,
    maintainability, and improved developer efficiency. We can summarize them in a
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved code readability and documentation** : Type hints are a form of
    documentation. They clarify the type of arguments a function expects, and what
    type it returns. This helps developers understand the code immediately, with no
    need to read long comments or much code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced error detection** : Static type checkers, such as Mypy, can scan
    the codebase and flag errors before runtime. This means that some bugs can be
    eliminated before they become a problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better IDE experience and autocompletion** : Modern IDEs leverage type hints
    to provide better autocompletion and enhanced refactoring capabilities. Moreover,
    with type hints, the IDE can suggest appropriate methods and attributes for an
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved collaboration and code reviews** : The documenting quality of type
    hints makes it easier to understand the code at a glance, which, for example,
    can be useful when reading changes in a pull request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code flexibility and reusability** : Python’s type hinting includes features
    such as generics, custom types, and protocols, which help developers write better-structured,
    more flexible code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another important aspect of Python’s type hinting system is that it can be introduced
    gradually. It is, in fact, quite common to introduce type hints progressively
    in a codebase, initially limiting efforts to where it matters most.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a foundational understanding of Python’s dynamic nature and
    its approach to type hinting, let us start exploring some examples and concepts
    to see how it is applied in practice.
  prefs: []
  type: TYPE_NORMAL
- en: While we expose the main types we can use to annotate our code, you might find
    slight differences with what you are used to, if you have previously used type
    annotations in your code. This is likely because type hinting in Python is currently
    still evolving, so it is different according to which Python version you are using.
    In this chapter, we will stick to the rules for Python 3.12.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start with a basic example.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python, we can annotate both function parameters and their return values.
    Let us start with a basic `greeter` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple Python function that takes a `name` and returns a greeting.
    We can now annotate the function to specify that we expect `name` to be a string
    and that the greeting returned will also be a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the highlighted section in this code, the syntax to annotate
    a function is simple. We specify the type using a colon after the parameter name.
    The `return` value is annotated with an arrow ( `->` ) followed by the type of
    the object returned.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now add another parameter, `age` , which we expect to be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you probably expected, we simply did the same for the `age` parameter, only,
    this time, we specified `int` , instead of `str` .
  prefs: []
  type: TYPE_NORMAL
- en: If you use a relatively modern IDE, try out this code. If you type either `name`
    or `age` and then a dot ( `.` ), the editor should suggest only the methods and
    attributes that are pertinent to the type of object you are using.
  prefs: []
  type: TYPE_NORMAL
- en: This was a basic example designed to show you the syntax of type annotations.
    Please disregard the artificial names, such as `greeter_annotated()` and `greeter_annotated_age()`
    ; they are not good names, but they should help you spot the differences more
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to expand on this, to show you the real capabilities of Python
    type hinting.
  prefs: []
  type: TYPE_NORMAL
- en: The Any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a special kind of type. Any function without a return type, or parameter
    type, will implicitly default to using `Any` . Therefore, the following function
    declarations are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The above declarations are completely equivalent. `Any` can be useful in certain
    circumstances, such as when annotating data containers, function decorators, or
    when a function is designed to handle inputs of multiple types. A simple example
    could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the two definitions are again completely equivalent. The only
    difference is that in the second one, by using `Any` , we explicitly state the
    list `items` is expected to contain *any* kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use almost any Python type in type hints. Moreover, the `typing` module
    introduced several constructs that we can leverage to expand on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such construct is **type aliases** , which are defined using a `type` statement.
    The result is an instance of `TypeAliasType` . They are a convenient way to simplify
    how the code reads. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the above example, we can define our own type aliases. From
    the perspective of a static type checker, `DatabasePort` and `int` will be treated
    equivalently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it might not be evident from such a dummy example, using a type alias
    enhances readability and simplifies refactoring. Imagine several functions expecting
    `DatabasePort` : if we wanted to refactor the codebase to represent a port using
    a string, we would just need to change the line in which we define `DatabasePort`
    . Had we simply used `int` instead, we would need to refactor all function definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: Special forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Special forms can be used as types in annotations. They all support subscription
    using [], but each has a unique syntax. Here, we are going to see `Optional` and
    `Union` ; for the complete list of all special forms, please refer to the official
    documentation at [https://docs.python.org/3/library/typing.html#special-forms](https://docs.python.org/3/library/typing.html#special-forms)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python allows optional arguments when a function parameter has a default. Here,
    we have a distinction to make. Let us bring back the `greeter` function, and add
    a default value to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This time, we have added a default value to the `greeter()` function. That means
    that if we were to call it with no arguments, it would return the string `"Hello,
    stranger!"` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition assumes that when we call `greeter()` , if we pass `name` ,
    it will be a string. Sometimes, though, this is not what we want, and we require
    an argument to be `None` , if not provided when the function is called. For situations
    like this, the `typing` module provides us with the `Optional` special form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the `greeter_optional()` function, we don’t want to return a greeting when
    we don’t pass a name. Because `None` is not a string, we mark `name` as optional
    and set its default value to `None` .
  prefs: []
  type: TYPE_NORMAL
- en: Union
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, an argument can be of different types. For example, when connecting
    to a database, the port can be specified as either an integer or a string. In
    these cases, it is useful to have the `Union` special form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, for the `port` parameter, we want to accept both `int`
    and `str` , and the `Union` special form allows us to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: Since Python 3.10, we don’t need to import `Union` , and instead can use a pipe
    ( `|` ) to specify a union type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This looks leaner.
  prefs: []
  type: TYPE_NORMAL
- en: '`Union` , or its pipe equivalent, incidentally, enables us to avoid having
    to import `Optional` , since `Optional[str]` , for example, can be written as
    `Union[str, None]` , or simply `str | None` . Let us see the latter form in an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Have you noticed that some of the functions defined above have type annotations
    on their parameters, but nothing for the return value? This is to show you that
    annotations are completely optional. We could even annotate only some of the parameters
    a function takes if we wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us continue our exploration of what is possible to achieve using type hints,
    by exploring the concept of **generics** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Say that we wanted to write a `last()` function that takes a list of items,
    of any kind, and returns the last one, if any, or `None` . We know that all the
    items in the list are of the same type, but we don’t know what type it is. How
    can we annotate the function properly? The concept of generics helps us do that.
    The syntax is only a tad more extravagant than what we have seen till now, but
    it is not that complicated. Let us write that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Pay particular attention to the highlighted sections in the code above. First,
    we need to add a `[T]` as a suffix to the function’s name. Then, we can specify
    that `items` is a list of objects whose type is `T` , whatever that might be.
    Finally, we can also use `T` for the return value, although, in this case, we
    have specified the return type to be the union of `T` and `None` , to cater for
    the edge case in which `items` would be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though the function signature is using the generic syntax, you would call
    it like this: `last([1, 2, 3])` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactic support for generics is new to Python 3.12. Before that, to achieve
    the same result, one would have resorted to using the `TypeVar` factory, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `first()` is not defined as `first[U](…)` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the enhancements in the syntax of Python 3.12, the use of generics
    is now simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us now take a little detour from functions and discuss variable annotations.
    We can quickly show you an example that will not require much of an explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code above, we have declared `x` to be many things, as an example. As
    you can see, the syntax is simple: we declare the name of the variable, its type
    (after the colon), and its value (after the equal sign). We also have provided
    you with a few examples of how one had to annotate variables in earlier versions
    of Python. Quite conveniently, in Python 3.12, we can use built-in types directly
    without having to import much from the `typing` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Annotating containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The typing system assumes that all elements in Python containers will be of
    the same type. This is true for most containers. For example, consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code above, `list` expects one type argument. In this
    context, a union, like `int | str` in the annotation of `c` , still counts as
    one type. However, the type checker will complain about `b` . This reflects the
    fact that lists in Python are typically used to store an arbitrary number of items
    of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Containers that have elements of the same type are called *homogeneous* .
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, even though the syntax is similar, `dict` expects a type for its
    keys and one for its values.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike most other container types, it is common for tuples to contain a fixed
    number of items with specific types expected in each position. Tuples containing
    different types are called *heterogeneous* . Because of this, tuples are treated
    in a special way by the typing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to annotate tuple types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples of fixed length, which can be further categorized into:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples without named fields
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples with named fields
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuples of *arbitrary* length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed-length tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us see an example of fixed-length tuples, without named fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the code above, both `a` and `b` are annotated correctly. However, `c` is
    incorrect, because the annotation indicates a tuple of length `1` , but `c` is
    of length `3` .
  prefs: []
  type: TYPE_NORMAL
- en: Tuples with named fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When tuples have more than one or two fields, or when they are used in several
    places in the codebase, it can be useful to annotate them using `typing.NamedTuple`
    . Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see by the results of the `print()` calls, this is equivalent to
    declaring a tuple, as we learned in *Chapter 2* , *Built-In Data Types* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `typing.NamedTuple` not only allows us to correctly annotate the tuple
    but we can even specify default values if we wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, in the above code, we didn’t specify the third argument when we
    created `p` , but `z` still got assigned to `0` correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples of arbitrary length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to specify a tuple of arbitrary length in which all elements are
    of the same type, we can use a specific syntax. This can be useful, for example,
    when we use tuples as immutable sequences. Let us see a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are plenty of ways to annotate a tuple. The choice of
    how strict you want to be is up to you. Remember to be consistent with the rest
    of the codebase. Also, be mindful of the value that annotations add to your code.
    If you are writing a library that is supposed to be published and used by other
    developers, it might make sense to be quite precise in the annotations. On the
    other hand, being too strict or restrictive for no good reason can hurt your productivity,
    especially in situations where such precision is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract base classes (ABCs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In older versions of Python, the `typing` module would provide several generic
    versions of types. For example, lists, tuples, sets, and dictionaries, could be
    annotated using the generic concrete collections `List` , `Tuple` , `Set` , `Dict`
    , and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Python 3.9, these generic collections have been deprecated in
    favor of their corresponding built-in, which means that, for example, it is possible
    to annotate a list using `list` itself, without needing `typing.List` .
  prefs: []
  type: TYPE_NORMAL
- en: The documentation also points out that these generic collections should be used
    to annotate return values, whereas parameters should be annotated using abstract
    collections. For example, we should use `collections.abc.Sequence` to annotate
    read-only and mutable sequences, like `list` , `tuple` , `str` , `bytes` , and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is in line with **Postel’s law** , also known as the **robustness principle**
    , which postulates:'
  prefs: []
  type: TYPE_NORMAL
- en: ”Be conservative in what you send, be liberal in what you accept.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Be liberal in what you accept* means that we should not be too restrictive
    in the way we annotate parameters. If a function takes a parameter called `items`
    , and all it does to it is iterate, or access an item based on its position, it
    makes no difference if `items` is a list or a tuple. Therefore, we should not
    annotate with `tuple` or `list` but use `collections.abc.Sequence` to allow `items`
    to be passed either as a tuple or a list.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where you annotate `items` using `tuple` . After a while,
    you refactor the code and now `items` is passed as a list. The function now has
    the wrong annotation, as `items` is no longer a tuple. Had we used `collections.abc.Sequence`
    instead, the function would not require any fixing, since both `tuple` and `list`
    would be okay.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The above functions should help clarify things. Take `average_bad()` , for example.
    If we passed `v` as a tuple, it would disagree with the function annotation we
    used, which is `list` . On the other hand, `average()` does not suffer from the
    same issue. And of course, we can follow the same reasoning for `greet_user_bad()`
    and `greet_user()` .
  prefs: []
  type: TYPE_NORMAL
- en: Going back to Postel’s Law, when it comes to return values, it is better to
    be conservative, which means to be specific. Return values should be precise in
    indicating what the function returns.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite important, especially for the caller, who needs to know the type
    of object they will receive when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another simple example, from the same file, that should help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the two functions above, we simply add some pretend connection defaults to
    whatever is passed in the `data` argument (provided `"host"` and `"port"` keys
    are missing in `data` ). The `add_defaults_bad()` function specifies `Mapping`
    as the return type. The problem with this is that it is too generic. Objects such
    as `dict` and its siblings from the `collections` module, `defaultdict` , `Counter`
    , `OrderedDict` , `ChainMap` , and `UserDict` , for example, all implement the
    `Mapping` interface. This makes things quite confusing for the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `add_defaults()` is a better function, in that it specifies
    precisely the return type: `dict` .'
  prefs: []
  type: TYPE_NORMAL
- en: Commonly used ABCs include `Iterable` , `Iterator` , `Collection` , `Sequence`
    , `Mapping` , `Set` , `MutableSequence` , `MutableMapping` , `MutableSet` , and
    `Callable` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see a dummy example with `Iterable` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All the `process_items()` function needs to do is iterate over `items` ; therefore,
    we use `Iterable` to annotate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more interesting example can be offered for `Callable` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the `process_callback()` function, which defines a string parameter,
    `arg` , and a `callback` callable object. We have two functions that follow, whose
    signature specifies a string parameter in input, and a string object as the return
    value. Notice how the type annotation for `callback` , which is `Callable[[str],
    str]` , indicates that the `callback` argument should take one string argument
    in input and return a string in output. When we call these functions with the
    following code, we get the output that is indicated in the inline comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our tour of abstract base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Special typing primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `typing` module, there is also a category of objects called **Special
    Typing Primitives** , which are quite interesting, and it is useful to know at
    least the most common of them. We have already seen one example: `Any` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other notable examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AnyStr` : Used to annotate functions that can accept `str` or `bytes` arguments
    but cannot allow the two to mix. This is known as a **constrained type variable**
    , which means that the type can only ever be exactly one of the constraints given.
    In the case of `AnyStr` , it is either `str` or `bytes` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LiteralString` : A special type that includes only literal strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Never` / `NoReturn` : Can be used to indicate that a function never returns
    – for example, it might raise an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TypeAlias` : Deprecated in favor of the `type` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `Self` type deserves a little more consideration.
  prefs: []
  type: TYPE_NORMAL
- en: The Self type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Self` type was added in Python 3.11, and it is a special type used to
    represent the current enclosed class. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, we have created a simple class, `Point` , which represents
    a three-dimensional point in space. To show you how to use the `Self` type, we
    have created a `sum_points()` class method, which takes an iterable, `points`
    , and produces a `Point` object in return, whose coordinates are the sums of the
    corresponding coordinates in all the items in `points` .
  prefs: []
  type: TYPE_NORMAL
- en: To annotate the `points` parameter, we pass `Self` to `Iterable` , and we do
    the same for the return value of the method. Before the introduction of the `Self`
    type, we would have had to create a unique “self” type variable for every class
    that needed it. You can find an example of this in the official documentation
    at [https://docs.python.org/3/library/typing.html#typing.Self](https://docs.python.org/3/library/typing.html#typing.Self)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Notice that both the `self` and the `cls` parameters have no type annotation
    by convention.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now move on to see how to annotate variable parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating variable parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To annotate variable positional and keyword parameters, we use the same syntax
    we have seen until now. A quick example is better than any explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, we have written a dummy function, `add_query_params()`
    , that adds some query parameters to a collection of URLs. Notice how, in the
    function definition, we only needed to specify the type of the object contained
    in the tuple `urls` , and the type for the values of the `query_params` dictionary.
    Declaring `*urls: str` is equivalent to `tuple[str, …]` , while `**query_params:
    str` is equivalent to `dict[str, str]` .'
  prefs: []
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us conclude our journey through type annotations by discussing **protocols**
    . In object-oriented programming, protocols define a set of methods that a class
    must implement without enforcing inheritance from any specific class. They are
    akin to the concept of interfaces in other languages, but they are more flexible
    and informal. They promote the use of polymorphism by allowing different classes
    to be used interchangeably if they follow the same protocol, even if they don’t
    share a common base class.
  prefs: []
  type: TYPE_NORMAL
- en: This concept has been part of Python since the beginning. This type of protocol
    is normally referred to as a **dynamic protocol** , and it is described in the
    Data Model chapter ( [https://docs.python.org/3/reference/datamodel.html](https://docs.python.org/3/reference/datamodel.html)
    ) of the **Python Language Reference** .
  prefs: []
  type: TYPE_NORMAL
- en: In the context of type hints, however, a protocol is a subclass of `typing.Protocol`
    , which defines an interface that a type checker can verify.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced by PEP 544 ( [https://peps.python.org/pep-0544/](https://peps.python.org/pep-0544/)
    ), they enable structural subtyping (informally known as *static duck typing*
    ), which we explored briefly at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The compatibility of an object with a protocol is determined by the presence
    of certain methods or attributes, rather than inheritance from a specific class.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols are therefore quite helpful in those cases where we cannot easily
    define a type, and instead, it is more convenient to express the annotation in
    the form of *“it should support certain methods or have certain attributes.”*
  prefs: []
  type: TYPE_NORMAL
- en: Protocols defined by PEP 544 are commonly referred to as **static protocols**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic and static protocols present two key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic protocols allow for partial implementation. This means an object can
    provide an implementation for only a subset of the methods of the protocol and
    still be useful. However, static protocols require an object to provide *every*
    method declared in the protocol, even if the software doesn’t need them all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static protocols can be verified by static type checkers, while dynamic ones
    cannot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find a list of the protocols provided by the `typing` module here:
    [https://docs.python.org/3/library/typing.html#protocols](https://docs.python.org/3/library/typing.html#protocols)
    . Their names are prefixed with the word `Supports` , followed by a title-cased
    version of the dunder method they declare to support. Some examples are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SupportsAbs` : An ABC with one abstract method, `__abs__` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SupportsBytes` : An ABC with one abstract method, `__bytes__` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SupportsComplex` : An ABC with one abstract method, `__complex__` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other protocols that used to live in the `typing` module but have been migrated
    to `collections.abc` are `Iterable` , `Iterator` , `Sized` , `Container` , `Collection`
    , `Reversible` , and `ContextManager` , to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete list in the Mypy documentation: [https://mypy.readthedocs.io/en/stable/protocols.html#predefined-protocols-reference](https://mypy.readthedocs.io/en/stable/protocols.html#predefined-protocols-reference)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an idea about what a protocol is, in the context of type hints,
    let us see an example that shows how to create a simple custom protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the code above, we define a protocol class, `SupportsStart` , which has
    one method: `start()` . To make it a static protocol, `SupportsStart` inherits
    from `Protocol` . The interesting part comes right after it, when we create the
    `Worker` class. Note that there is no need for it to inherit from the `SupportsStart`
    class. The `Worker` class only needs to fulfill the protocol, which means it needs
    to have a `start()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: We also wrote a function, `start_workers()` , which takes a parameter, `workers`
    , annotated as `Iterable[SupportsStart]` . That is all that is required to use
    a protocol. We define a couple of workers, `Alice` and `Bob` , and we pass them
    to the function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the above example will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now imagine we also wanted to stop a worker. This is a more interesting case
    because it allows us to discuss how to subclass protocols. Let us see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, we learned that we can compose protocols as we would do
    mixins. The one key difference is that when we subclass a protocol class, as in
    the case of `SupportsWorkCycle` , we still need to explicitly add `Protocol` to
    the list of base classes. If we do not do this, the static type checker will complain.
    This is because inheriting from an existing protocol does not automatically turn
    the subclass into a protocol. It only creates a regular class or ABC that implements
    the given protocol(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about protocols in the Mypy documentation: [https://mypy.readthedocs.io/en/stable/protocols.html](https://mypy.readthedocs.io/en/stable/protocols.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Let us now discuss Mypy, the static type checker most widely adopted by the
    Python community.
  prefs: []
  type: TYPE_NORMAL
- en: The Mypy static type checker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several static type checkers for Python. Currently, the most widely
    adopted are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mypy** : Designed to work seamlessly with Python’s type annotations defined
    by PEP 484, it supports gradual typing, integrates well with existing codebases,
    and has extensive documentation. You can find it at [https://mypy.readthedocs.io/](https://mypy.readthedocs.io/)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pyright** : Developed by Microsoft, this fast type checker is optimized for
    use with Visual Studio Code. It does incremental analysis for fast type checking
    and supports both TypeScript and Python. You can find it at [https://github.com/microsoft/pyright](https://github.com/microsoft/pyright)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pylint** : A comprehensive static analysis tool that includes type checking
    along with linting and code quality checks. It’s highly configurable, supports
    custom plugins, and generates detailed code quality reports. You can find it at
    [https://pylint.org/](https://pylint.org/) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pyre** : Developed by Facebook, it’s fast and scalable, and works well with
    large codebases. It supports gradual typing, and has a powerful type inference
    engine. It also integrates well with continuous integration systems. You can find
    it at [https://pyre-check.org/](https://pyre-check.org/) .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pytype** : Developed by Google, it infers types automatically and reduces
    the need for explicit annotations, which it can generate. It integrates well with
    Google open-source tools. You can find it at [https://github.com/google/pytype](https://github.com/google/pytype)
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this section of the chapter, we have decided to go with Mypy, since it currently
    seems to be the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it in your virtual environment, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Mypy is also included in the requirements file for this chapter. When Mypy
    is installed, you can run it against any files or folders you want. Mypy will
    recursively traverse any folder to find Python modules ( `*.py` files). Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The command sports a massive set of options, which we encourage you to explore
    by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Let us start with a very simple example of a function that has no annotations
    and see the outcome of running `mypy` against it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `mypy` on this module gives this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is probably not what you expected, but Mypy is designed to support gradually
    adding type annotations to existing codebases. Outputting error messages for unannotated
    code would discourage developers from using it in this way. Therefore, the default
    behavior is to ignore functions that have no annotations. If we wanted Mypy to
    check the `hypothenuse()` function anyway, we could run it like this (notice we
    have re-formatted the output to fit the book’s width):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now Mypy is telling us that the function is missing a type annotation, so let
    us fix that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run `mypy` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent – now the function is annotated, and `mypy` runs successfully. Let
    us try out some function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two calls are fine, but the last one generates an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Mypy is informing us that passing a `complex` where a `float` is required is
    not okay. The two types are not compatible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try a slightly more complex example (no pun intended):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The above function applies title-casing to each string in `names` . First,
    we call it once, with the strings `"ALICE"` and `"bob"` , and then we call it
    with the `bytes` objects `b"ALICE"` and `b"bob"` . Both calls succeed because
    both the `str` and `bytes` objects have `title()` methods. However, running `mypy`
    yields the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, Mypy is pointing out the incompatibility of two types – this time,
    `str` and `bytes` . We can easily fix this, by either amending the second call
    or changing the type annotation on the function. Let us do the latter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, we use the union of the `str` and `bytes` types in the annotation, and
    `mypy` runs successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Our advice is to install Mypy and run it against any existing codebase you might
    have. Try to introduce type annotations gradually and use Mypy to check the correctness
    of your code. This exercise will help you to acquire familiarity with type hints,
    and it will also benefit your code.
  prefs: []
  type: TYPE_NORMAL
- en: Some useful resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We would recommend reading through (or at least skimming) all the PEPs we listed
    at the beginning of the chapter. We also recommend studying the various resources
    we pointed out along the way, some of which are listed below for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python Typing Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://typing.readthedocs.io/en/latest/](https://typing.readthedocs.io/en/latest/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static Typing with Python:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/typing.html](https://docs.python.org/3/library/typing.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract Base Classes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/abc.html](https://docs.python.org/3/library/abc.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract Base Classes for Containers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/collections.abc.html](https://docs.python.org/3/library/collections.abc.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Mypy Documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://mypy.readthedocs.io/en/stable/](https://mypy.readthedocs.io/en/stable/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also a quick *Python Types Intro* section in the FastAPI framework
    documentation, which we would recommend reading: [https://fastapi.tiangolo.com/python-types/](https://fastapi.tiangolo.com/python-types/)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '**FastAPI** is a modern Python framework for building APIs. *Chapter 14* ,
    *Introduction to API Development* , is dedicated to it, so we recommend at least
    reading the introduction on types prior to reading that chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the topic of type hints in Python. We started
    by understanding Python’s native approach to types and walked through the history
    of type hints, which were introduced gradually from Python 3 and are still evolving.
  prefs: []
  type: TYPE_NORMAL
- en: We investigated the benefits of type hints and then learned how to annotate
    functions, classes, and variables. We explored the basics and discussed the main
    built-in types, but also ventured through more advanced topics, such as generics,
    abstract base classes, and protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we offered a few examples of how to use the most popular static type
    checker, Mypy, to gradually introduce typing in a codebase and finished the chapter
    with a short recap of the most useful resources for you to further investigate
    this subject.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the end of the theory part of the book. The remaining chapters
    are project-oriented and take a more practical approach, starting with an introduction
    to data science. The knowledge acquired by studying the chapters in the first
    part should be sufficient to support you while you make your way through the next
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_12.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
