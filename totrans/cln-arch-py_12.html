<html><head></head><body><div><div><div><h1 class="chapterNumber"><a id="_idTextAnchor218"/>9</h1>
    <h1 id="_idParaDest-205" class="chapterTitle"><a id="_idTextAnchor219"/>Adding Web UI: Clean Architecture’s Interface Flexibility</h1>
    <p class="normal">In previous chapters, we established Clean Architecture’s foundational patterns through our task management system. We built domain entities, implemented use cases, and created a command line interface (CLI) that demonstrated how Clean Architecture’s boundaries enable clear separation between our core business logic and user interfaces. While the CLI provides a functional interface, many applications require web-based access. This presents an excellent opportunity to show how Clean Architecture’s principles enable interface evolution without compromising architectural integrity.</p>
    <p class="normal">Through our task management system, we’ll demonstrate one of Clean Architecture’s key benefits: the ability to add new interfaces without modifying existing code. Because our domain logic, use cases, and controllers were built with proper architectural boundaries, adding a web interface becomes a purely additive exercise. No refactoring of existing components is required. This same principle that makes adding a web UI straightforward also enables long-term maintenance of multiple interfaces, as each can evolve independently while sharing the same robust core.</p>
    <p class="normal">By the end of this chapter, you’ll understand how to implement additional interfaces while maintaining architectural boundaries. You’ll be able to apply these patterns to your own projects, ensuring your applications remain adaptable as interface requirements evolve.</p>
    <p class="normal">In this chapter, we’re going to cover the following main topics:</p>
    <ul>
      <li class="bulletList">Understanding interface flexibility in Clean Architecture</li>
      <li class="bulletList">Web presentation patterns in Clean Architecture</li>
      <li class="bulletList">Integrating Flask with Clean Architecture</li>
    </ul>
    <h1 id="_idParaDest-206" class="heading-1"><a id="_idTextAnchor220"/>Technical requirements</h1>
    <p class="normal">The code examples presented in this chapter and throughout the rest of the book have been tested with Python 3.13. For brevity, most code examples in the chapter are only partially implemented. Complete versions of all examples can be found in the book’s accompanying GitHub repository at <a href="https://github.com/PacktPublishing/Clean-Architecture-with-Python">https://github.com/PacktPublishing/Clean-Architecture-with-Python</a>.</p>
    <h1 id="_idParaDest-207" class="heading-1"><a id="_idTextAnchor221"/>Understanding interface flexibility in Clean Architecture</h1>
    <p class="normal">Our task management <a id="_idIndexMarker495"/>system’s CLI (implemented in <a href="Chapter_07.xhtml#_idTextAnchor168"><em class="italic">Chapter 7</em></a>), demonstrates<a id="_idIndexMarker496"/> Clean Architecture’s careful separation between core business logic and user interfaces. This separation wasn’t just good practice—it was strategic preparation for exactly what we’ll accomplish in<a id="_idIndexMarker497"/> this <a id="_idIndexMarker498"/>chapter: adding a completely new user interface while preserving our existing functionality.</p>
    <h2 id="_idParaDest-208" class="heading-2"><a id="_idTextAnchor222"/>Understanding our web implementation</h2>
    <p class="normal">To implement our <a id="_idIndexMarker499"/>web interface, we’ll use <strong class="keyWord">Flask</strong>—a lightweight and flexible Python web framework. Flask’s explicit request handling and straightforward application structure make it ideal for demonstrating Clean Architecture’s boundaries. Its minimal core and extensive ecosystem of optional extensions align well with Clean Architecture’s preference for explicit dependencies. While the patterns we’ll explore would work equally well with Django, FastAPI, or other web frameworks, Flask’s simplicity helps keep our focus on architectural principles rather than framework-specific features.</p>
    <p class="normal">Through a browser-based interface, users can now manage their projects and tasks with familiar workflows enhanced by web-specific capabilities. When a user visits the application, they’re presented with their projects and associated tasks in a clean, hierarchical view:</p>
    <figure class="mediaobject"><img src="img/B31577_09_1.png" alt="Figure 9.1: Web UI listing page showing projects and their associated tasks" width="871" height="711"/></figure>
    <p class="packt_figref">Figure 9.1: Web UI listing page showing projects and their associated tasks</p>
    <p class="normal">The web interface enhances our existing task management capabilities through immediate visual feedback and <a id="_idIndexMarker500"/>intuitive navigation. Users can create new tasks, update their status, and organize them within projects. The interface adapts our existing business logic to web conventions, using standard patterns such as form submissions for task creation and flash messages for user feedback.</p>
    <p class="normal">To implement this interface while maintaining our architectural boundaries, our web implementation is organized into distinct components:</p>
    <figure class="mediaobject"><img src="img/B31577_09_2.png" alt="Figure 9.2: Associated files for the Web UI implementation" width="1211" height="662"/></figure>
    <p class="packt_figref">Figure 9.2: Associated files for the Web UI implementation</p>
    <p class="normal">This structure demonstrates Clean Architecture’s separation of concerns in action. In our Adapters and Interfaces (<code class="inlineCode">interfaces</code>) layer, the web presenters know how to format data for web display by creating HTML-friendly strings and structuring data for templates, but remain completely unaware of Flask or any specific web framework. These presenters could work equally well with<a id="_idIndexMarker501"/> Django, FastAPI, or any other web framework.</p>
    <p class="normal">This separation stands in stark contrast to applications built without clear architectural boundaries. In a less structured application, a request to <em class="italic">add a web interface</em> often triggers a cascade of changes throughout the codebase. Business logic mixed with presentation concerns requires extensive refactoring. Database queries embedded in display logic need restructuring. Even seemingly simple changes like formatting dates for web display can require modifications across multiple components. In extreme cases, teams find themselves essentially rewriting their application to accommodate the new interface.</p>
    <p class="normal">Our task management system, by contrast, treats the web interface as a purely additive change. No existing code needs modification: not our business rules, not our use cases, not even our CLI. This ability to add major features without disturbing existing functionality demonstrates Clean Architecture’s practical value in evolving systems.</p>
    <p class="normal">The framework-specific code lives where it belongs—in the <code class="inlineCode">infrastructure/web</code> directory within our Frameworks and Drivers layer. Here, Flask-specific concerns like route handling, template<a id="_idIndexMarker502"/> configuration, and HTTP session management stay isolated at the edges of our system. This separation means we could switch web frameworks without touching our interface adapters or core business logic.</p>
    <h2 id="_idParaDest-209" class="heading-2"><a id="_idTextAnchor223"/>Parallel interface implementations</h2>
    <p class="normal">Before diving into<a id="_idIndexMarker503"/> our web implementation details, let’s examine how our CLI and web interfaces coexist within our Clean Architecture system. While these interfaces serve users through very different mechanisms (command line versus HTTP), they share the same core components and follow identical architectural patterns.</p>
    <figure class="mediaobject"><img src="img/B31577_09_3.png" alt="Figure 9.3: Request flow comparison" width="1121" height="791"/></figure>
    <p class="packt_figref">Figure 9.3: Request flow comparison</p>
    <p class="normal">This diagram illustrates <a id="_idIndexMarker504"/>how our architecture maintains clear boundaries while supporting multiple interfaces:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">CLI </strong>transforms command-line input through Click Command Handler</li>
      <li class="bulletList"><strong class="keyWord">Web interface</strong> processes HTTP requests via Flask Route Handler</li>
      <li class="bulletList"><strong class="keyWord">Shared core</strong> contains our Task Controller, Use Cases, and Entities</li>
    </ul>
    <p class="normal">Clean Architecture enables this coexistence through strict dependency rules. Both interface handlers connect to the same task controller, but the core components remain completely unaware of how they’re being used. This isolation means our core business logic can focus on task creation rules while each interface handles its specific concerns, whether that’s parsing command-line arguments or processing form submissions.</p>
    <p class="normal">To implement this separation, we use a pragmatic dependency injection approach through our Application container:</p>
    <pre class="programlisting code"><code class="hljs-code"># todo_app/infrastructure/configuration/container.py
@dataclass
class Application:
    """Container which wires together all components."""
    task_repository: TaskRepository
    project_repository: ProjectRepository
    notification_service: NotificationPort
    task_presenter: TaskPresenter
    project_presenter: ProjectPresenter
</code></pre>
    <p class="normal">Note how each component is declared using abstract interfaces (<code class="inlineCode">TaskRepository</code>, <code class="inlineCode">NotificationPort</code>, etc.). This enables each interface implementation to provide its own specific dependencies while our application core remains unaware of the concrete implementations it <a id="_idIndexMarker505"/>will receive. The application factory demonstrates how this flexibility works in practice.</p>
    <p class="normal">Our application factory implements Clean Architecture’s composition root pattern which serves as the single point where we compose our interface-agnostic core with interface-specific implementations. The factory demonstrates two key architectural principles:</p>
    <pre class="programlisting code"><code class="hljs-code"># todo_app/infrastructure/configuration/container.py
def create_application(
    notification_service: NotificationPort,
    task_presenter: TaskPresenter,
    project_presenter: ProjectPresenter,
) -&gt; "Application":
    """Factory function for the Application container."""
    task_repository, project_repository = create_repositories()
  
    return Application(
        task_repository=task_repository,
        project_repository=project_repository,
        notification_service=notification_service,
        task_presenter=task_presenter,
        project_presenter=project_presenter,
    )
</code></pre>
    <p class="normal">First, the factory demonstrates Clean Architecture’s Dependency Inversion Principle in action: interface-specific components (presenters) are passed in as parameters, while core infrastructure (repositories) is constructed internally. This separation means interface implementations can provide their own presenters while the factory ensures everything connects properly to our shared business core.</p>
    <p class="normal">Second, the factory serves as the composition root that functions as the single point where abstract interfaces meet their concrete implementations.</p>
    <p class="normal">Our CLI application demonstrates this adaptability to different interfaces. At the application boundary, we wire <a id="_idIndexMarker506"/>together our shared core with CLI-specific components:</p>
    <pre class="programlisting code"><code class="hljs-code"># cli_main.py
def main() -&gt; int:
    """Main entry point for the CLI application."""
    app = create_application(
        notification_service=NotificationRecorder(),
        task_presenter=CliTaskPresenter(),
        project_presenter=CliProjectPresenter(),
    )
    cli = ClickCli(app)
    return cli.run()
</code></pre>
    <p class="normal">Note how <code class="inlineCode">main()</code> configures a CLI-specific application instance by providing interface-specific implementations (<code class="inlineCode">CliTaskPresenter</code>, <code class="inlineCode">CliProjectPresenter</code>) to our generic application container. The <code class="inlineCode">ClickCli</code> class then wraps this core application, handling the translation between command-line interactions and our application’s interface-agnostic operations. This pattern of wrapping interface-specific code around our core application is a fundamental Clean Architecture practice that we’ll see mirrored in our web implementation.</p>
    <p class="normal">By setting up our application this way, we’ve established a clear pattern for how new interfaces connect to our core application. To add our web interface, we’ll need to implement analogous components that fulfill the same roles but for web-specific concerns:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Presentation layer</strong>: implementing <code class="inlineCode">WebTaskPresenter</code> for HTML templates</li>
      <li class="bulletList"><strong class="keyWord">Request handling</strong>: processing form submissions and URL parameters</li>
      <li class="bulletList"><strong class="keyWord">Session state</strong>: managing persistence between requests</li>
      <li class="bulletList"><strong class="keyWord">User feedback</strong>: implementing web-specific error presentation</li>
    </ul>
    <p class="normal">The key insight is that all interface-specific concerns remain at the edges of our system. Each interface handles its own unique requirements, such as web session management or CLI argument parsing, while our core business logic remains focused and clean.</p>
    <p class="normal">In the next section, we’ll explore specific presentation patterns for web interfaces, seeing how these same principles<a id="_idIndexMarker507"/> that kept our CLI implementation clean can guide us in creating maintainable web-specific components.</p>
    <h2 id="_idParaDest-210" class="heading-2"><a id="_idTextAnchor224"/>Common interface boundary violations</h2>
    <p class="normal">Clean Architecture’s <a id="_idIndexMarker508"/>effectiveness depends on maintaining clear boundaries between layers. A common violation occurs when developers allow interface-specific formatting to creep into controllers, creating problematic dependencies that flow in the wrong direction. Consider this anti-pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"># Anti-pattern: Interface-specific logic in controller
def handle_create(self, request_data: dict) -&gt; dict:
    """DON'T: Mixing CLI formatting in controller."""
    try:
        result = self.create_use_case.execute(request_data)
        if result.is_success:
            # Wrong: CLI-specific formatting doesn't belong here
            return {
                "message": click.style(
                    f"Created task: {result.value.title}",
                    fg="green"
                )
            }
    except ValueError as e:
        # Wrong: CLI-specific error formatting
        return {"error": click.style(str(e), fg="red")}
</code></pre>
    <p class="normal">This implementation violates Clean Architecture’s Dependency Rule in a subtle but important way. The controller, which lives in our Interface Adapters layer, directly references Click (a framework that should be constrained to our outermost layer). This creates a problematic coupling, for our controller now depends on both the Application layer (inward) and the Frameworks layer (outward), breaking Clean Architecture’s fundamental rule that dependencies should only point inward. Beyond the architectural violation, this coupling has practical consequences: we couldn’t reuse this controller for our web interface, and even updating to a newer version of Click would require changes in our Interface Adapters layer.</p>
    <p class="normal">Instead, our task management system correctly delegates all formatting concerns to interface-specific presenters. Notice how our controller depends only on the abstract Presenter interface. It has no knowledge<a id="_idIndexMarker509"/> of whether it’s working with CLI, web, or any other concrete presenter implementation:</p>
    <pre class="programlisting code"><code class="hljs-code"># Correct: Interface-agnostic controller
def handle_create(self, title: str, description: str) -&gt; OperationResult:
    """DO: Keep controllers interface-agnostic."""
    try:
        request = CreateTaskRequest(title=title, description=description)
        result = self.create_use_case.execute(request)
        if result.is_success:
            view_model = self.presenter.present_task(result.value)
            return OperationResult.succeed(view_model)
        error_vm = self.presenter.present_error(
            result.error.message, str(result.error.code.name)
        )
        return OperationResult.fail(error_vm.message, error_vm.code)
    except ValueError as e:
        error_vm = self.presenter.present_error(
            str(e), "VALIDATION_ERROR")
        return OperationResult.fail(error_vm.message, error_vm.code)
</code></pre>
    <p class="normal">This corrected implementation demonstrates several Clean Architecture principles:</p>
    <ul>
      <li class="bulletList">The controller accepts simple types (<code class="inlineCode">str</code>) rather than framework-specific structures</li>
      <li class="bulletList">Error handling produces framework-agnostic <code class="inlineCode">OperationResult</code> instances</li>
      <li class="bulletList">All formatting is delegated to the abstract <code class="inlineCode">presenter</code> interface</li>
      <li class="bulletList">The controller remains focused on coordinating between use cases and presentation</li>
    </ul>
    <p class="normal">This approach yields significant practical benefits. With our clean implementation, framework changes only affect the outermost layer. We could replace Click with another CLI framework by simply implementing new adapters without touching our controllers, use cases, or domain logic. The same controller handles requests identically regardless of whether they originate from our CLI, web interface, or any future interface we might add.</p>
    <p class="normal">The Interface Adapters layer acts as a protective boundary, transforming data between our domain core and external interfaces. This architectural boundary enables us to add a web interface without disrupting existing components. Our domain entities focus solely on business rules while interface-specific concerns remain properly isolated at the system edges.</p>
    <p class="normal">Now that we’ve<a id="_idIndexMarker510"/> established how Clean Architecture’s boundaries enable interface flexibility, let’s examine the specific presentation patterns needed for web interfaces and how they maintain these same architectural principles.</p>
    <h1 id="_idParaDest-211" class="heading-1"><a id="_idTextAnchor225"/>Web presentation patterns in Clean Architecture</h1>
    <p class="normal">Having established how Clean Architecture enables interface flexibility, we now turn to the specific patterns needed for web presentation. While our CLI directly formatted data for console output, web interfaces must handle more complex presentation requirements: formatting data for HTML templates, managing state across multiple requests, and providing user feedback through form validation and flash messages (temporary notification banners that appear at the top of the page after an action, like the green success message shown in <em class="italic">Figure 9.1</em>). This section explores these web-specific challenges and shows how Clean Architecture’s boundaries guide our implementation choices.</p>
    <p class="normal">We’ll examine how web-specific presenters format domain data for HTML display, ensuring our templates receive properly structured information. We’ll see how state management across requests can respect Clean Architecture’s boundaries, and how form handling can maintain separation between web concerns and business rules. Through these patterns, we’ll demonstrate that web interfaces, despite their complexity, can integrate cleanly with our existing architecture.</p>
    <h2 id="_idParaDest-212" class="heading-2"><a id="_idTextAnchor226"/>Implementing web-specific presenters</h2>
    <p class="normal">To bridge<a id="_idIndexMarker511"/> our domain logic and web display requirements, we need presenters that understand web conventions. To understand how our web presenter should work, let’s first examine our CLI presenter from <a href="Chapter_07.xhtml#_idTextAnchor168"><em class="italic">Chapter 7</em></a>. Notice how it encapsulates all CLI-specific formatting decisions (bracketed status, colored priorities) while maintaining a clean interface through <code class="inlineCode">TaskViewModel</code>. This established pattern of transforming domain objects into interface-appropriate view models will guide our web implementation:</p>
    <pre class="programlisting code"><code class="hljs-code"># CLI Presenter from <a href="Chapter_07.xhtml#_idTextAnchor168"><em class="italic">Chapter 7</em></a>
def present_task(self, task_response: TaskResponse) -&gt; TaskViewModel:
    """Format task for CLI display."""
    return TaskViewModel(
        id=task_response.id,
        title=task_response.title,
        # CLI-specific bracketed format:
        status_display=f"[{task_response.status.value}]", 
        # CLI-specific coloring:
        priority_display=self._format_priority(task_response.priority)
    )
</code></pre>
    <p class="normal">Our web presenter follows the same pattern but adapts the formatting for HTML display:</p>
    <pre class="programlisting code"><code class="hljs-code">class WebTaskPresenter(TaskPresenter):
    def present_task(self, task_response: TaskResponse) -&gt; TaskViewModel:
        """Format task for web display."""
        return TaskViewModel(
            id=task_response.id,
            title=task_response.title,
            description=task_response.description,
            status_display=task_response.status.value,
            priority_display=task_response.priority.name,
            due_date_display=self._format_due_date(
                task_response.due_date),
            project_display=task_response.project_id,
            completion_info=self._format_completion_info(
                task_response.completion_date,
                task_response.completion_notes
            ),
        )
</code></pre>
    <p class="normal">Notice how the <code class="inlineCode">WebTaskPresenter</code> class provides additional fields and formatting specific to web display needs: HTML-friendly status values, date formatting for browser display, and structured completion <a id="_idIndexMarker512"/>information for template rendering. This implementation demonstrates how Clean Architecture’s presenters serve as a systematic translation layer between domain concepts and presentation needs:</p>
    <ul>
      <li class="bulletList">Translates domain objects into interface-appropriate formats while preserving their business meaning</li>
      <li class="bulletList">Centralizes all presentation decisions in a single, testable component</li>
      <li class="bulletList">Enables each interface to adapt domain data according to its specific needs</li>
      <li class="bulletList">Maintains clear separation between domain logic and display concerns</li>
    </ul>
    <p class="normal">The presenter doesn’t just format data; it serves as the authoritative interpreter of how domain concepts should appear in the interface. Consider our date formatting method:</p>
    <pre class="programlisting code"><code class="hljs-code">def _format_due_date(self, due_date: Optional[datetime]) -&gt; str:
    """Format due date for web display."""
    if not due_date:
        return ""
    is_overdue = due_date &lt; datetime.now(timezone.utc)
    date_str = due_date.strftime("%Y-%m-%d")
    return f"Overdue: {date_str}" if is_overdue else date_str
</code></pre>
    <p class="normal">The <code class="inlineCode">_format_due_date</code> method encapsulates all date-related formatting decisions: time zone handling, date format strings, and overdue status checks. By containing these decisions in the presenter, we ensure our domain entities remain focused on business rules (when a task is due) while presentation <a id="_idIndexMarker513"/>concerns (how to display that due date) stay in the appropriate architectural layer.</p>
    <p class="normal">This translation layer allows our templates to remain simple while still delivering rich, contextual information:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;span class="badge
    {% if 'overdue' in task.due_date_display %}bg-danger
    {%else %}bg-info
    {% endif %}"&gt;
    {{ task.due_date_display }}
&lt;/span&gt;
</code></pre>
    <p class="normal">The template exemplifies Clean Architecture’s separation of concerns in action: it focuses purely on HTML structure and styling decisions based on pre-formatted values. All business logic (<code class="inlineCode">datetime</code> comparisons) and data formatting remain in the appropriate architectural layers. The template simply adapts the presenter’s output for visual display, using simple string checks to apply appropriate CSS classes.</p>
    <p class="normal">Just as in <a href="Chapter_08.xhtml#_idTextAnchor192"><em class="italic">Chapter 8</em></a>, we can verify this formatting logic through focused unit tests. This test demonstrates a key benefit of Clean Architecture’s separation of concerns: we can verify our presentation logic in isolation, without any web framework dependencies. By testing against the presenter directly, we can ensure that our date formatting logic works correctly without setting up a full web environment. The test focuses purely on the transformation from domain data to presentation format:</p>
    <pre class="programlisting code"><code class="hljs-code">def test_web_presenter_formats_overdue_date():
    """Test that presenter properly formats overdue dates."""
    # Arrange
    past_date = datetime.now(timezone.utc) - timedelta(days=1)
    task_response = TaskResponse(
        id="123",
        title="Test Task",
        description="Test Description",
        status=TaskStatus.TODO,
        priority=Priority.MEDIUM,
        project_id="456",
        due_date=past_date
    )
    presenter = WebTaskPresenter()
    # Act
    view_model = presenter.present_task(task_response)
    # Assert
    assert "Overdue" in view_model.due_date_display
    assert past_date.strftime("%Y-%m-%d") in view_model.due_date_display
</code></pre>
    <p class="normal">This test demonstrates <a id="_idIndexMarker514"/>how Clean Architecture’s separation enables precise verification of our web formatting logic. We can test complex scenarios, like overdue dates, without any web framework setup. The same pattern applies to future dates:</p>
    <pre class="programlisting code"><code class="hljs-code">def test_web_presenter_formats_future_date():
    """Test that presenter properly formats future dates."""
    # Arrange
    future_date = datetime.now(timezone.utc) + timedelta(days=1)
    task_response = TaskResponse(
        id="123",
        title="Test Task",
        description="Test Description",
        status=TaskStatus.TODO,
        priority=Priority.MEDIUM,
        project_id="456",
        due_date=future_date
    )
    presenter = WebTaskPresenter()
    # Act
    view_model = presenter.present_task(task_response)
    # Assert
    assert "Overdue" not in view_model.due_date_display
    assert future_date.strftime("%Y-%m-%d") in view_model.due_date_display
</code></pre>
    <p class="normal">This complementary test ensures that our presenter handles future dates appropriately, completing our verification of the date formatting logic. Together with the previous test, we’ve confirmed both the presence and absence of the ‘Overdue’ indicator, all without touching any web framework code.</p>
    <p class="normal">These tests highlight key benefits of Clean Architecture’s presenter pattern. Our formatting logic can be verified <a id="_idIndexMarker515"/>without complex web setup. No need for Flask test clients, mock databases, or HTML parsing. Changes to date formatting can be tested quickly and precisely, while our templates remain focused purely on display concerns.</p>
    <p class="normal">This pattern extends across all domain concepts, from task status to priority levels, ensuring consistent translation of business objects into presentation-ready formats. Any template in our system can display task due dates without knowing how those dates are formatted. More importantly, as our formatting logic evolves with additions such as time zone support or new display formats, we only need to update the presenter and its tests. Our templates, controllers, and domain <a id="_idIndexMarker516"/>logic remain unchanged.</p>
    <h2 id="_idParaDest-213" class="heading-2"><a id="_idTextAnchor227"/>Presenters versus template-based formatting</h2>
    <p class="normal">Developers familiar <a id="_idIndexMarker517"/>with modern web frameworks like React, Vue, or template-oriented patterns in Flask/Django might question our separation of formatting logic into presenters. Many applications embed formatting directly in templates:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;!-- Common pattern in many web frameworks --&gt;
&lt;span class="badge {% if task.due_date &lt; now() %}bg-danger{% else %}bg-info{% endif %}"&gt;
    {{ task.due_date.strftime("%Y-%m-%d") }}
    {% if task.due_date &lt; now() %}(Overdue){% endif %}
&lt;/span&gt;
</code></pre>
    <p class="normal">While this pattern is widespread, it blurs the boundary between presentation decisions and display structure. In Clean Architecture, we recognize formatting as a translation concern that belongs in the Interface Adapters layer, not in the templates themselves.</p>
    <p class="normal">Even when working with template-oriented frameworks, Clean Architecture principles can still guide implementation decisions by:</p>
    <ul>
      <li class="bulletList">Recognizing where business decisions are leaking into templates</li>
      <li class="bulletList">Extracting formatting logic into dedicated components</li>
      <li class="bulletList">Treating templates purely as display structure</li>
    </ul>
    <p class="normal">The fundamental architectural principle remains the same: maintain clear boundaries between layers. Whether implemented through our explicit presenter pattern or through template helpers and components, the goal is to ensure that domain concepts are properly translated before they reach the outermost display layer.</p>
    <h2 id="_idParaDest-214" class="heading-2"><a id="_idTextAnchor228"/>Managing web-specific state</h2>
    <p class="normal">Session data and form <a id="_idIndexMarker518"/>state present unique challenges for maintaining Clean Architecture’s boundaries. Let’s examine how our system handles these web-specific concerns while keeping our core domain logic pure. Consider this anti-pattern where a domain entity directly accesses web session data:</p>
    <pre class="programlisting code"><code class="hljs-code"># Anti-pattern: Domain entity accessing web state
class Task:
    def complete(self, web_app_contatiner):
        # Wrong: Task shouldn't know about web sessions
        self.completed_by = web_app_contatiner.user.id
        self.completed_at = datetime.now()
</code></pre>
    <p class="normal">This demonstrates how mixing web concerns into domain entities creates multiple maintenance challenges:</p>
    <ul>
      <li class="bulletList">Testing requires mocking web session data even for basic domain logic</li>
      <li class="bulletList">Adding new interfaces means updating entity code rather than just adding adapters</li>
      <li class="bulletList">Session handling bugs can ripple through the entire Domain layer</li>
      <li class="bulletList">Entity behavior becomes dependent on web framework implementation details</li>
    </ul>
    <p class="normal">Our Flask route handlers act as the architectural boundary where web-specific concerns are managed. They translate HTTP concepts into domain-agnostic operations while keeping web state management where it belongs:</p>
    <pre class="programlisting code"><code class="hljs-code"># todo_app/infrastructure/web/routes.py
@bp.route("/")
def index():
    """List all projects with their tasks."""
    app = current_app.config["APP_CONTAINER"]
    show_completed = (
        request.args.get("show_completed", "false")
        .lower() == "true"
    )
    result = app.project_controller.handle_list()
    if not result.is_success:
        error = project_presenter.present_error(result.error.message)
        flash(error.message, "error")
        return redirect(url_for("todo.index"))
    return render_template(
        "index.html",
        projects=result.success,
        show_completed=show_completed
    )
</code></pre>
    <p class="normal">This handler exemplifies Clean Architecture’s boundary management in action. At this outer edge of our system, the route captures and processes web-specific state like the <code class="inlineCode">show_completed</code> preference, translating HTTP concepts into domain-agnostic operations. Instead of allowing domain entities to access session data directly, the handler extracts only the necessary information before passing it to our core business logic. Web-specific concerns such as user feedback through <a id="_idIndexMarker519"/>flash messages and template rendering stay in this outer layer, while our domain logic remains focused purely on its core responsibilities.</p>
    <h2 id="_idParaDest-215" class="heading-2"><a id="_idTextAnchor229"/>Form handling and validation</h2>
    <p class="normal">Form submissions in <a id="_idIndexMarker520"/>web applications present an architectural challenge. A common anti-pattern is to spread validation logic across templates, controllers, and domain entities, making it difficult to maintain and evolve validation rules. Let’s examine how Clean Architecture guides us to handle forms appropriately using a simple project creation form:</p>
    <pre class="programlisting code"><code class="hljs-code"># todo_app/infrastructure/web/routes.py
@bp.route("/projects/new", methods=["GET", "POST"])
def new_project():
    """Create a new project."""
    if request.method == "POST":
        name = request.form["name"]
        app = current_app.config["APP_CONTAINER"]
        result = app.project_controller.handle_create(name)
        if not result.is_success:
            error = project_presenter.present_error(result.error.message)
            flash(error.message, "error")
            return redirect(url_for("todo.index"))
        project = result.success
        flash(f'Project "{project.name}" created successfully', "success")
        return redirect(url_for("todo.index"))
    return render_template("project_form.html")
</code></pre>
    <p class="normal">The route handler <a id="_idIndexMarker521"/>demonstrates Clean Architecture’s validation flow:</p>
    <ol>
      <li class="numberedList" value="1">The route extracts web-specific inputs:<ul>
          <li class="bulletList level-2">URL parameters (<code class="inlineCode">project_id</code>)</li>
          <li class="bulletList level-2">Form fields (<code class="inlineCode">request.form["title"]</code>, etc.)</li>
          <li class="bulletList level-2">Optional fields with defaults (<code class="inlineCode">due_date</code>)</li>
        </ul>
      </li>
      <li class="numberedList">The task controller receives standard Python types:<ul>
          <li class="bulletList level-2">Strings for text fields</li>
          <li class="bulletList level-2"><code class="inlineCode">None</code> for empty optional fields</li>
          <li class="bulletList level-2">The <code class="inlineCode">project_id</code> from the URL</li>
        </ul>
      </li>
      <li class="numberedList">Domain validation occurs through established layers:<ul>
          <li class="bulletList level-2">Business rules in entities</li>
          <li class="bulletList level-2">Use case coordination</li>
          <li class="bulletList level-2">Results returned via our Result type</li>
        </ul>
      </li>
      <li class="numberedList">Web-specific responses:<ul>
          <li class="bulletList level-2">Success redirects with flash messages</li>
          <li class="bulletList level-2">Error handling through flash messages and redirects</li>
        </ul>
      </li>
    </ol>
    <div><p class="normal"> <strong class="keyWord">Syncing client-side and domain validation</strong></p>
      <p class="normal">While our domain validation provides the ultimate source of truth, modern web applications often need immediate user feedback. Flask provides mechanisms like WTForms that can mirror domain validation rules in the view layer, enabling responsive UX without duplicating validation logic. The key is to ensure that these view-layer validations remain thin wrappers around our core domain rules rather than introduce parallel validation logic.</p>
    </div>
    <p class="normal">This separation ensures<a id="_idIndexMarker522"/> that our validation rules stay with our domain logic where they belong, while the web layer focuses on collecting input and presenting feedback.</p>
    <h1 id="_idParaDest-216" class="heading-1"><a id="_idTextAnchor230"/>Integrating Flask with Clean Architecture</h1>
    <p class="normal">Having established <a id="_idIndexMarker523"/>our presentation patterns and state management approach, we now turn to the practical integration of Flask into our Clean Architecture system. Building on the application container structure seen earlier in <em class="italic">Understanding interface flexibility in Clean Architecture</em>, we’ll focus on the Flask-specific aspects of our web interface:</p>
    <ul>
      <li class="bulletList">Configuring Flask’s application factory pattern</li>
      <li class="bulletList">Managing Flask-specific settings and dependencies</li>
      <li class="bulletList">Connecting Flask routes to our core application logic</li>
    </ul>
    <p class="normal">Here’s how our Flask application factory integrates with our existing architecture:</p>
    <pre class="programlisting code"><code class="hljs-code"># todo_app/infrastructure/web/app.py
def create_web_app(app_container: Application) -&gt; Flask:
    """Create and configure Flask application."""
    flask_app = Flask(__name__)
    # Change this in production:
    flask_app.config["SECRET_KEY"] = "dev" 
    # Store container in config:
    flask_app.config["APP_CONTAINER"] = app_container 
    # Register blueprints
    from . import routes
    flask_app.register_blueprint(routes.bp)
    return flask_app
</code></pre>
    <p class="normal">Let’s examine the key components of this setup. As shown in <em class="italic">Figure 9.4</em>, <code class="inlineCode">web_main.py</code> acts as our application’s <a id="_idIndexMarker524"/>entry point, orchestrating the creation and configuration of both our business logic (Application Container) and web interface (Web Container) through Flask. The Application Container holds our core business logic while the Web Container manages Flask-specific concerns like routes and templates.</p>
    <figure class="mediaobject"><img src="img/B31577_09_4.png" alt="Figure 9.4: Flask application bootstrapping showing container relationships" width="666" height="850"/></figure>
    <p class="packt_figref">Figure 9.4: Flask application bootstrapping showing container relationships</p>
    <p class="normal">This structure follows <a id="_idIndexMarker525"/>Clean Architecture’s principles in several key ways:</p>
    <ul>
      <li class="bulletList">Keeping Flask-specific code isolated in the Web Container</li>
      <li class="bulletList">Maintaining our core Application Container’s independence from web concerns</li>
      <li class="bulletList">Enabling clear communication paths between containers through well-defined interfaces</li>
    </ul>
    <p class="normal">With these containers properly configured and connected, we’re ready to implement our routes and templates. These components will build on the presentation patterns we’ve established, showing how Clean <a id="_idIndexMarker526"/>Architecture enables us to create a full-featured web interface while maintaining clear architectural boundaries.</p>
    <h2 id="_idParaDest-217" class="heading-2"><a id="_idTextAnchor231"/>Implementing routes and templates</h2>
    <p class="normal">Earlier in this chapter<a id="_idIndexMarker527"/> we examined routes from a data flow perspective: how they represent entry points into our system and translate HTTP requests for our core domain. Now let’s look more closely at their implementation to understand how they maintain Clean Architecture’s boundaries while delivering web-specific functionality.</p>
    <p class="normal">Just as our CLI implementation translated command-line arguments into use case inputs, our web routes translate HTTP requests into operations our core application can understand. While the delivery mechanism differs (HTTP requests instead of command-line arguments), the architectural pattern remains the same: external input flows through our interface adapters before reaching our application core.</p>
    <p class="normal">Consider how our CLI handled task creation:</p>
    <pre class="programlisting code"><code class="hljs-code"># todo_app/infrastructure/cli/click_cli_app.py
def _create_task(self):
    """CLI task creation."""
    title = click.prompt("Task title", type=str)
    description = click.prompt("Description", type=str)
    result = self.app.task_controller.handle_create(
        title=title,
        description=description
    )
</code></pre>
    <p class="normal">Our web route implements the same architectural pattern as our CLI, though adapted for HTTP’s request-response cycle. Just as the CLI handler transformed command-line arguments into domain operations, this route handler serves as a clean boundary between HTTP concepts and our domain logic:</p>
    <pre class="programlisting code"><code class="hljs-code">@bp.route("/projects/&lt;project_id&gt;/tasks/new", methods=["GET", "POST"])
def new_task(project_id):
    """Create a new task in a project."""
    if request.method == "POST":
        app = current_app.config["APP_CONTAINER"]
        result = app.task_controller.handle_create(
            project_id=project_id,
            title=request.form["title"],
            description=request.form["description"],
            priority=request.form["priority"],
            due_date=(
                request.form["due_date"]
                if request.form["due_date"] else None
            ),
        )
        if not result.is_success:
            error = task_presenter.present_error(result.error.message)
            flash(error.message, "error")
            return redirect(url_for("todo.index"))
        task = result.success
        flash(f'Task "{task.title}" created successfully', "success")
        return redirect(url_for("todo.index"))
    return render_template("task_form.html", project_id=project_id)
</code></pre>
    <p class="normal">Notice how<a id="_idIndexMarker528"/> both implementations:</p>
    <ul>
      <li class="bulletList">Collect input in interface-specific ways (CLI prompts versus form data)</li>
      <li class="bulletList">Transform that input into standard parameters for our controller</li>
      <li class="bulletList">Handle success and error responses appropriately for their interface (CLI output versus HTTP redirects)</li>
    </ul>
    <p class="normal">This consistent pattern demonstrates how Clean Architecture enables multiple interfaces while keeping our core application focused on business logic.</p>
    <p class="normal">The route handling goes beyond simple form processing. The <code class="inlineCode">project_id</code> parameter comes from the URL itself (<code class="inlineCode">/projects/&lt;project_id&gt;/tasks/new</code>), while form fields contain task details. Our Clean Architecture layers handle this naturally:</p>
    <ul>
      <li class="bulletList">The route layer manages all web specifics:<ul>
          <li class="bulletList level-2">URL parameter extraction</li>
          <li class="bulletList level-2">Form data collection</li>
          <li class="bulletList level-2">Flash messages for user feedback (temporary UI messages shown after redirects)</li>
          <li class="bulletList level-2">Template selection and rendering</li>
        </ul>
      </li>
      <li class="bulletList">The controller layer handles:<ul>
          <li class="bulletList level-2">Combining URL and form data into a single operation</li>
          <li class="bulletList level-2">Coordinating with the appropriate use cases</li>
          <li class="bulletList level-2">Returning results that our web layer can interpret</li>
        </ul>
      </li>
    </ul>
    <p class="normal">The templates represent <a id="_idIndexMarker529"/>the outermost layer of our Clean Architecture system, serving as the final transformation point between our domain concepts and user interface. While our presenters handle the logical transformation of domain data into view models, templates focus exclusively on the visual representation of that data:</p>
    <pre class="programlisting code"><code class="hljs-code">{% extends 'base.html' %}
{% block content %}
    {% for project in projects %}
    &lt;div class="card mb-4"&gt;
        &lt;div class="card-header"&gt;
            &lt;h2 class="card-title h5 mb-0"&gt;{{ project.name }}&lt;/h2&gt;
        &lt;/div&gt;
        &lt;!-- Template focuses purely on structure and display --&gt;
    &lt;/div&gt;
    {% endfor %}
{% endblock %}
</code></pre>
    <p class="normal">This template demonstrates our clean separation of concerns in action. It works exclusively with the <code class="inlineCode">ProjectViewModel</code> provided by our presenters. Notice how it simply references <code class="inlineCode">project.name</code> without any knowledge of how that data was retrieved or processed. The template has no awareness of repositories, use cases, or even the HTTP layer, but focuses instead solely on rendering the provided view models in a user-friendly format. This mirrors how our CLI presenters formatted data for console output, with each interface handling only its specific display requirements.</p>
    <p class="normal">This separation means <a id="_idIndexMarker530"/>we can completely redesign our templates, whether changing layouts, adding new UI components, or even switching template engines, without touching our core application logic.</p>
    <h2 id="_idParaDest-218" class="heading-2"><a id="_idTextAnchor232"/>Running your Clean Architecture web application</h2>
    <p class="normal">Having implemented<a id="_idIndexMarker531"/> our web interface components, let’s examine how to bootstrap our Clean Architecture application. The <code class="inlineCode">web_main.py</code> script serves as our composition root—the single point where abstract interfaces meet their concrete implementations. This entry point orchestrates the creation and connection of our components while maintaining Clean Architecture’s dependency rules:</p>
    <pre class="programlisting code"><code class="hljs-code">def main():
    """Create and run the Flask web application."""
    app_container = create_application(
        notification_service=create_notification_service(),
        task_presenter=WebTaskPresenter(),
        project_presenter=WebProjectPresenter(),
    )
    web_app = create_web_app(app_container)
    web_app.run(debug=True)
if __name__ == "__main__":
    main()
</code></pre>
    <p class="normal">The Dependency Inversion Principle enables runtime configuration of concrete implementations through environment variables. Just as our CLI application could switch components without code changes, our web interface maintains this flexibility:</p>
    <pre class="programlisting con"><code class="hljs-con"># Repository Configuration
export TODO_REPOSITORY_TYPE="memory"  # or "file"
export TODO_DATA_DIR="repo_data"      # used with file repository
# Optional: Email Notification Configuration
export TODO_SENDGRID_API_KEY="your_api_key"
export TODO_NOTIFICATION_EMAIL="recipient@example.com"
</code></pre>
    <p class="normal">This configuration flexibility demonstrates a key benefit of Clean Architecture: the ability to easily switch components. For example, changing <code class="inlineCode">TODO_REPOSITORY_TYPE</code> from “memory” to “file” switches our <a id="_idIndexMarker532"/>entire storage implementation without requiring any code changes. The same pattern that enabled us to add a web interface also enables:</p>
    <ul>
      <li class="bulletList">Adding new storage backends (like PostgreSQL or MongoDB)</li>
      <li class="bulletList">Implementing additional notification services</li>
      <li class="bulletList">Creating new interfaces (such as a desktop or mobile app)</li>
      <li class="bulletList">Supporting alternative authentication methods</li>
    </ul>
    <p class="normal">Each of these enhancements can be implemented and tested in isolation, then integrated through our clean architectural boundaries. This capability empowers development teams to experiment with new features and technologies while maintaining system stability. Rather than risky ‘big bang’ code deployments, teams can gradually evolve their applications by adding and testing new components within Clean Architecture’s protective boundaries.</p>
    <p class="normal">To launch the web application, run the main script:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt; python web_main.py
 * Serving Flask app 'todo_app.infrastructure.web.app'
 * Debug mode: on
 * Running on http://127.0.0.1:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 954-447-204
127.0.0.1 - - [05/Feb/2025 13:58:57] "GET / HTTP/1.1" 200 -
</code></pre>
    <p class="normal">Visiting <code class="inlineCode">http://127.0.0.1:5000</code> in your browser presents a web interface that, while radically different in form from our CLI, operates on the exact same core components. Where our CLI interpreted command-line arguments, our web interface now processes form submissions and URL <a id="_idIndexMarker533"/>parameters. The same task creation use case that previously responded to CLI commands now handles HTTP POST requests:</p>
    <figure class="mediaobject"><img src="img/B31577_09_5.png" alt="Figure 9.5: Task creation form showing web-specific input handling" width="440" height="537"/></figure>
    <p class="packt_figref">Figure 9.5: Task creation form showing web-specific input handling</p>
    <p class="normal">This duality showcases Clean Architecture in practice. Our simple command-line application now coexists with a full web interface, complete with forms, dynamic updates, and visual feedback. Both interfaces run independently but share the same core components. The identical task creation use case that previously processed CLI commands now seamlessly handles web form submissions. Our repositories maintain consistent data regardless of which interface creates or updates records. Error handling adapts naturally, with command-line error messages for CLI users, flash messages and form validation for web users.</p>
    <p class="normal">These aren’t just two separate applications that happen to use similar code: they’re two interfaces to the exact same application core, each presenting its capabilities in a way that makes sense for its environment. A team member could create a task through the CLI while another updates it <a id="_idIndexMarker534"/>through the web interface, with both operations flowing through the same use cases and repositories, demonstrating the practical power of Clean Architecture’s boundary rules.</p>
    <h1 id="_idParaDest-219" class="heading-1"><a id="_idTextAnchor233"/>Summary</h1>
    <p class="normal">Our journey from CLI to web interface highlights Clean Architecture’s power to enable system evolution without compromising architectural integrity. This capability extends beyond web interfaces to a broader principle: well-designed architectural boundaries create systems that can adapt to changing interface requirements while maintaining a stable core.</p>
    <p class="normal">The patterns we’ve explored provide a template for future system evolution. These patterns range from interface-specific presenters to state management at system boundaries. Whether adding mobile interfaces, API endpoints, or entirely new interaction models, these same principles ensure that our core business logic remains focused and protected.</p>
    <p class="normal">This flexibility doesn’t come at the cost of maintainability. By keeping our domain entities focused on business rules and our use cases working with pure domain concepts, we’ve created a system where each layer can evolve independently. New interface requirements can be met through additional adapters, while our core business logic remains stable and untouched.</p>
    <p class="normal">In <a href="Chapter_10.xhtml#_idTextAnchor235"><em class="italic">Chapter 10</em></a>, we’ll explore how to add logging and monitoring to Clean Architecture systems, ensuring that our applications remain observable and maintainable in production environments.</p>
    <h1 id="_idParaDest-220" class="heading-1"><a id="_idTextAnchor234"/>Further reading</h1>
    <ul>
      <li class="bulletList"><em class="italic">Flask Documentation</em> (<a href="https://flask.palletsprojects.com/en/stable/">https://flask.palletsprojects.com/en/stable/</a>). Full documentation for the Flask framework.</li>
      <li class="bulletList"><em class="italic">WTForms</em> (<a href="https://wtforms.readthedocs.io/en/3.2.x/">https://wtforms.readthedocs.io/en/3.2.x/</a>). Flexible forms validation and rendering library for Python web development.</li>
    </ul>
  </div>
</div></div></body></html>