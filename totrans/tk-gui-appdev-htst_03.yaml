- en: Chapter 3. Programmable Drum Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We built a text editor in the last project. In the process, we looked at some
    common Tkinter widgets such as Menu, Buttons, Label, and Text. Now, let us now
    do some music. Let us build a cross-platform drum machine using Tkinter and some
    other Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Briefing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will build a programmable drum machine. The graphical user
    interface of the drum machine is based on Tkinter. You will be able to create
    an unlimited number of beat patterns using an unlimited number of drum samples.
    You can then store multiple riffs in a project and playback or edit the project
    later on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mission Briefing](img/7941_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To create your own drum beat patterns, simply load some drum samples using the
    buttons on the left. You can change the units that constitute a beat pattern,
    which in turn decides the tempo of the rhythm. You can also decide the number
    of beats per units. Most western beats have four beats per unit, waltz would have
    three beats per unit, and some Indian and Arabic rhythms that I composed on this
    machine had 3 to 16 beats per unit!
  prefs: []
  type: TYPE_NORMAL
- en: Why Is It Awesome?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don't be misled by the small size of the GUI. This is a powerful drum machine
    that can match features offered by some large commercial drum machine programs.
    By the end of this project, you should be in a position to extend it to outdo
    some of the commercial drum programs out there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key features of the machine include:'
  prefs: []
  type: TYPE_NORMAL
- en: Large number of beats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large number of patterns to accompany songs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable number of beats per pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of 16 bit, 44100 kHz WAV samples (mono or stereo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for various file formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to save projects comprising of several patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few drum samples are provided in the `Loops` subdirectory; however, you can
    load any other drum sample. You can download a large number of samples for free
    from the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: In the process of developing this program, we tweak Tkinter further and take
    a look at several important concepts and ideas that are normally encountered in
    GUI programming.
  prefs: []
  type: TYPE_NORMAL
- en: Your Hotshot Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the key objectives for taking up this project include:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how Tkinter is normally applied in context of OOP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a few more Tkinter widgets such as Spinbox, Button, Entry, and
    Checkbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the `grid` geometry manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ttk-themed widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding threaded programming in relation to Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with other common modules from the Python standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object persistence with the `pickle` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these key concepts, we discuss several other vital nuggets of GUI
    programming in the course of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, we will use some more built-in libraries from the standard
    Python distribution. This includes `Tkinter`, `ttk`, `tkFileDialog`, `tkMessageBox`,
    `os`, `time`, `threading`, `wave`, and `pickle` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that these modules do exist, simply run the following statement in
    the IDLE interactive prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should not cause an error as the standard Python distribution comes with
    these modules built into the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Other than this, you need to add an extra Python module called `pymedia`.
  prefs: []
  type: TYPE_NORMAL
- en: The `pymedia` module can be downloaded at [http://pymedia.org/](http://pymedia.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have installed the module, you can verify it by importing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If no errors are rported, you are ready to program the drum machine. Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the GUI in OOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The text editor program that we developed as our previous project was set up
    in procedural code. While it offered some benefit of quick coding, it essentially
    ran as a single process.
  prefs: []
  type: TYPE_NORMAL
- en: We started encountering global variables. The function definitions needed to
    be defined above the code that called them and most importantly the code was not
    reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need some way to ensure that our code is more reusable. This is
    why programmers prefer to use **Object Oriented Programming** (**OOP**) to organize
    their code into classes.
  prefs: []
  type: TYPE_NORMAL
- en: OOP is a programming paradigm that shifts the focus onto the objects we want
    to manipulate rather than the logic required to manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: This is in contrast to procedural programming that views a program as a logical
    procedure that takes input, processes it, and produces some output.
  prefs: []
  type: TYPE_NORMAL
- en: OOP provides several benefits such as data abstraction, encapsulation, inheritance,
    and polymorphism. In addition, OOP provides a clear modular structure for programs.
    Code modification and maintenance is easy as new objects can be created without
    modifying the existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Let us build our drum program using OOP to illustrate some of these features.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An indicative OOP structure for our drum program could be as follows (see the
    code in `3.01.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a class called `DrumMachine` and define a method `app()`to initialize
    the Toplevel window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the program is run as a standalone program, a new object is created and the
    `app` method is called to create the Toplevel window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code creates a blank Toplevel window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our Toplevel window ready, let us add some widgets to it. In
    this iteration we will lay the top bar, left bar (the area that lets us upload
    drum samples), the right bar (that has buttons to define the beat patterns), and
    play bar at the bottom (which has a **Play** button, a **Stop** button, and a
    **Loop** check button).
  prefs: []
  type: TYPE_NORMAL
- en: 'The four areas have been demarcated in different squares to group widgets into
    separate frames, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we will create the top bar. The top bar is one that holds the Spinbox
    widgets, which lets the user change the units and beats per unit in a rhythm pattern.
    These two together decide the tempo and the cyclical pattern of a rhythm as follows
    (see the code in `3.02.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We first create a new method in order to create the top bar. We add a frame
    `top_bar_frame` for the top bar and then add two spin boxes to keep track of the
    units and beats per unit values. We do not add `command` callbacks now. The callbacks
    will be added later.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We define two Tkinter variables `self.units` and `self.bpu` to hold the current
    value of both the Spinbox widgets. This is defined as an object variable (`self`)
    because we will need these variables outside the scope of this method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The widgets are placed using the `grid` geometry manager.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we will create the left bar. The left bar is one that will let the user
    load drum samples. Each row in the left bar allows for loading one unique drum
    sample. The drum samples are normally small `.wav` or `.ogg` file samples for
    different drums such as bass, snare, tom, bell, claves, or samples that the user
    decides.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The buttons on the left bar will open an upload file. When the user uploads
    a drum sample, the name of the drum sample will automatically populate the Entry
    widget adjacent to that button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Thus, each row has a Button and an Entry widget (refer to the code in `3.02.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The maximum number of drum samples that can be loaded is defined as a constant
    `MAX_DRUM_NUM`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We create another frame called `left_frame` to hold various widgets in this
    area
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over a loop, we create Button and Entry widgets for as many drum samples
    as we need to allow the user to load
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next we will create the right bar. The right bar is the area that lets the user
    define the beat pattern. This area consists of a series of buttons. The number
    of row of buttons is equal to the number of drum samples that can be loaded. The
    number of columns of buttons is decided by the number of units and number of beats
    per unit selected by the user from the spin boxes in the top bar. The number of
    columns of buttons is equal to product of the number of units and beats per unit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are not connecting the spin boxes with the buttons right now. For now, let
    us place buttons in four columns for each individual drum sample that can be loaded
    as follows (refer to the code in `3.02.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We create another frame `right_frame` to hold these buttons.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using list comprehension, we create an empty list of size `4 *MAX_DRUM_NUM`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, we simply add four columns of buttons to occupy the place. The number
    of rows of buttons are kept equal to the maximum number of drum samples, to have
    one row of buttons corresponding to each sample.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: There is reason behind grouping widgets into different methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, we have created the left pad and the right pad using two separate
    methods `create_left_pad` and `create_right_pad`. If we had defined these two
    groups of widgets within the same method, the user would have to reload the drum
    samples every time the left buttons changed due to changes in BPU and units. This
    would have been counterproductive for the end user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As a rule of thumb, it is always advisable to keep related widgets within a
    single method. However, the deciding class structure is more of an art than science
    to be learned and refined over a lifetime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next we will create the play bar. The play bar at the bottom includes the **Play**
    button, the **Stop** button, and a **Loop** check button. Refer to the code in
    `3.02.py`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code is pretty self-explanatory. It creates a frame `playbar_frame` and
    puts two buttons and one check button within the frame.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A Tkinter `BooleanVar()` is created to track the status of Checkbutton.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have created all the widgets, its now time to actually display
    them by explicitly calling the methods that created them. We do that within the
    main loop of our program as follows (refer to the code in `3.02.py)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than defining a separate method `app()` to run our main loop, we could
    also have run the main loop by creating an initialization method called `__init__`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In that case, we would not have to call the `app()`method explicitly to run
    the program. However, in case someone ever needs to use this class in another
    program, it would have needlessly created a GUI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Calling the `mainloop` function explicitly from the `app()` method leaves us
    room to use the code as a library for some other program.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes our first iteration. In this iteration we have managed to create
    the basic structure of our drum program. This includes creating the top, left,
    right, and bottom frames that holds different widgets as per the requirement of
    the drum program.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen one of the most common ways of structuring the Tkinter GUI
    program in an object-oriented style of programming.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the pattern editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding iteration, we coded a dummy `create_right_pad` with four columns
    of buttons. However, in the scheme of our program, the number of columns of buttons
    depends upon the choice of **Units** and beats per units (**BPU**) values selected
    by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of columns of buttons should be equal to:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of Units x BPU
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, to demarcate each unit, each consecutive unit of buttons should
    be displayed in different colors. Moreover, when a button is clicked, its color
    should change to track the user-defined pattern, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Completing the pattern editor](img/7941_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us add these three features to our drum editor.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will start by connecting buttons to the **Units** and **BPU** Spinbox
    widgets. The code is simple. We add `command` callbacks from both the Spinbox
    widgets in the top bar to call our `create_right_pad` method. Refer to the code
    in `3.03.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then modify our existing `create_right_pad` method as follows, and in code
    `3.03.py`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Within our frame `right_frame`, we iterate through a double-nested loop creating
    a two-dimensional matrix where the number of rows is equal to the constant `MAX_DRUM_NUM`,
    while the number of columns is equal to the product of **Units** and **BPU**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The color of each button is configured to either `grey55` or `khaki` depending
    on whether the factor `j/bpu` is even or odd.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now if you run the code (code `3.03.py`), you will find the number of buttons
    changing as per selections you make in the units and bpu spin boxes. Moreover,
    each unit will be colored alternately in khaki and gray colors.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice how we have defined the `grid` geometry position of buttons in terms
    of variables `i` and `j`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that the buttons respond to change in units and bpu, it is time that we
    change these buttons into toggle buttons. When a user clicks on any of the buttons,
    the color of the button should change to green. When the button is clicked again,
    the color reverts to its original color. We need this feature to define beat patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We first add a `command` callback to our buttons, passing the button''s row,
    column, and bpu as arguments to a new method `button_clicked` (refer to the code
    in `3.03.py`), as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define the `button_clicked` method as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our method `button_clicked` takes three arguments: `i, j`, and `bpu`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The variables `i` and `j` let us track which button is clicked. However, note
    that the `command` callback `self.Button_clicked(i,j,bpu)` makes a reference to
    `i` and `j` when the button is not yet created. In order to track the button that
    is clicked by the user, we enclose a separate `callback()` function within our
    `self.button_clicked` function, which then returns a callback. Now our method
    will return a different value of `i` and `j` for each button record.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bpu` argument is needed to calculate the original color of the button.
    This is needed to revert the color of button back to its original color if the
    button is toggled. Before we change the color of the button to green, we store
    its original color in a variable `color`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now completed coding the right drum pad. In the process we have created
    a two-dimensional list of buttons `self.button`, where `self.button[i][j]` refers
    to the button at the *i*th row and *j*th column.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these buttons can be toggled on or off to represent whether or not a
    drum sample is to be played for that particular button.
  prefs: []
  type: TYPE_NORMAL
- en: When a button is on, its color changes to green. If it is switched off, it reverts
    to its original color. This structure can be easily used to define a beat pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we have seen more advanced usage of the Spinbox and Button widget.
  prefs: []
  type: TYPE_NORMAL
- en: Loading drum samples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our main objective is to play sound files, in the order of a beat pattern decided
    by the user. To do this we need to add sound files to the drum machine.
  prefs: []
  type: TYPE_NORMAL
- en: Our program does not have any preloaded drum files. Instead, we want to let
    the user select from a wide variety of drum files. Thus, besides the normal drum,
    you can play a Japanese tsuzumi, an Indian tabla, Latin American bongo drums,
    or just about any other sound that you want to add to your rhythm. All you need
    is a small `.wav` or `.ogg` file containing that sound's sample.
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading drum samples](img/7941_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us code the ability to add this drum sample to our program.
  prefs: []
  type: TYPE_NORMAL
- en: The drum sample is to be loaded on the left bar, as shown in the preceding screenshot.
    We have already created buttons with folder icons to the left-hand side of our
    drum pad. The desired functionality is simple.
  prefs: []
  type: TYPE_NORMAL
- en: When a user clicks on any of the left buttons, they should open a file dialog
    letting the user choose a `.wav` or `.ogg` file. When the user selects the file
    and clicks on **Open**, the Entry widget next to that button should be populated
    with the name of the file. Further, the location of the drum sample file should
    be added to a list for playing it later.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we will import the required modules. To open the sound file, we will
    use the `tkFileDialog` module. We will also use the `tkMessageBox` module to display
    certain pop-up messages. We will also need to extract the filename of the given
    sound sample using the `os` module. Let us begin by importing the three modules
    (given in the following code) into our current namespace (refer to the same code
    present in `3.04.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will add Attributes to track the loaded samples. The user will invariably
    load more than one drum sample. Therefore, we need to track the Entry widget where
    the drum sample was loaded, the location of each of the drum samples, and a number
    indicating the current drum number. Accordingly, we create two lists called `self.widget_drum_name`
    and `self.widget_drum_file_name` to store the Entry widget instance and file location
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also declare a variable `self.current_drum_no` to track the current drum
    number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We choose to initialize these variables and list under our initialization method
    `__init__` (refer to the code in `3.04.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then modify our `create_left_pad` method to include a line that appends
    a list of all drum Entry widgets in our newly-created list `self.widget_drum_name`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add a `command` callback to the buttons in our `create_left_pad` method
    to load drum samples, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we code our `drum_load` method as follows (refer to the code in `3.04.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We define a callback function within our function because we need to track several
    drum samples.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To track the widget, through which a sound sample has been loaded, we set the
    `self.current_drum_no` value to be equal to the `drum_num` value received as an
    argument from the button `command` callback.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In a `try` block, we use `tkFileDialog.askopenfilename` to get the filename
    of the drum sample. We then check whether a filename already exists in our filename
    list. If it does, we delete it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `os.path.basename` from the `os` module, we obtain the filename from the
    file path and insert it into corresponding Entry widget.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `askopenfilename` fails, we use `tkMessageBox.showerror` to display a custom
    error message.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we imported modules to handle dialogs and message boxes.
    We then added attributes to track drum samples. Finally, we added `command` callbacks
    to buttons which when clicked open a dialog for the user to select drum samples.
  prefs: []
  type: TYPE_NORMAL
- en: Our code is now capable of loading drum samples and storing all necessary records
    that we will require to play beat patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us turn our attention to playing the beat samples as per a user-defined
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Playing the drum machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a mechanism to load drum samples and a mechanism to define
    beat patterns in place, let us add the ability to play these beat patterns. In
    many ways, this is the core of our program.
  prefs: []
  type: TYPE_NORMAL
- en: Let us first understand the functionality that we want to achieve here. Once
    the user has loaded one or more drum sample and has defined a beat pattern using
    the toggle buttons, we need to scan each column of the pattern to see if it finds
    a green button. If it finds one, our code should play the corresponding drum sample
    before moving ahead. Moreover, green buttons on the same column should play almost
    together, while there should be some time gap between each successive column,
    which would define the tempo of the music.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the `pymedia` module to play the sound files. The `pymedia` module
    can play a wide variety of sound formats such as `.wav`, `.ogg`, `.mp3`, `.avi`,
    `.divx`, `.dvd`, and `.cdda` on multiple operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without getting into the details of how pymedia plays the sound files, the
    official documentation tells us that we can play audio files using the following
    code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you run this piece of code as an independent script and supply the file location
    of a supported audio file in place of `'YOUR FILE NAME'`, this should play the
    media file on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Using this code sample, we will implement the play functionality for our drum
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us first import all of the necessary modules into our namespace (refer
    to the code in `3.05.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will define the `play_sound` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method simply takes the API provided by `pymedia` and wraps it into a method
    that takes a filename and plays it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us now define the `play` method that actually plays the beat samples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We loop through all of the buttons scanning each column before moving to the
    next column. For every button, we use `widget.cget()` to check to see if its color
    is green.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the color is green, we check if there is a corresponding drum sample loaded.
    If not, we ignore the green button and move to the next item in the loop using
    `continue`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the color is green and there is a corresponding drum sample loaded, we use
    the previously-defined `pymedia` wrapper method for playing audio to play that
    sample.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving to the next column the code is made to sleep for a small interval.
    If the code is not made to sleep for a small duration, the program would play
    all the samples at a very rapid succession.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have chosen to make the code sleep for a time period of one-eighth of a second.
    You can change this sleep time to vary the tempo.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we added the capability to play the loaded drum samples.
  prefs: []
  type: TYPE_NORMAL
- en: Our drum machine is now operational. You can load drum samples, define beat
    patterns, and when you click on the **Play** button, the drum machine plays that
    beat pattern!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we decided whether or not to play a drum sample based on the
    color of the button. This has been used here for demonstration purposes. However,
    it is not a good practice to mix logic with appearance. A better idea would be
    to implement a data structure for buttons that would keep track of button state
    as "clicked" or "not-clicked", and then play the audio based on this button's
    state. Implementation of this dual button states is left as an exercise for you
    to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Classified Intel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous code, we used `widget.cget()` to fetch the current value of
    the button's `bg` option to check if it is green. You can use `w.cget(key)` to
    return the current value of a widget option. Also, note that `cget()` always returns
    the value as a string even if you give a nonstring value when configuring the
    widget option.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `widget.cget()`method, Tkinter offers a wide variety of methods for
    all its widgets. For a list of basic widget methods, refer to the *The basic widget
    methods* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know all of the options configured for a particular widget,
    you may use the `widget.config()` method instead, as follows: (See the code in
    `3.06.py`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will print a dictionary showing all the key-value pairs for widget
    options and their values listed as tuples. For example, in the preceding code
    the line `print widget.config(''bg'')` prints a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tkinter and threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our drum machine plays patterns in the way that we want it to. However, there
    is a small problem. The `play` method blocks the main loop of our Tkinter program.
    It does not relinquish control back to the main loop until it is done playing
    all of the sound samples.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if you now want to click on the **Stop** button or change some
    other widget, you will have to wait for the `play` loop to complete.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that when you hit the **Play** button, it remains pressed
    for the time the sound loops are being played. During that time you cannot access
    any other widget in the Toplevel window.
  prefs: []
  type: TYPE_NORMAL
- en: This clearly is a glitch. We need some method to confer back the control to
    Tkinter main loop while the play is still in progress.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest ways that we can achieve this is to use the `root.update()`method
    within our `play` loop. This updates the `root.mainloop()` method after each sound
    sample is played (see the commented code in `3.07.py`).
  prefs: []
  type: TYPE_NORMAL
- en: However, this is an inelegant method because the control is passed to the main
    loop with some staggering experienced in the GUI. Thus, you may experience a slight
    delay in responses of other widgets in the Toplevel.
  prefs: []
  type: TYPE_NORMAL
- en: Further, if some other event causes the method to be called, it could result
    in a nested event loop.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution would be to run the `play` method from a separate thread.
    To do that let us employ the `threading` module of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us first import the `threading` module into our namespace (refer to the
    code in `3.07.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let us create a method that calls the `self.play()` method to run in a
    separate thread. This redirects `play` through the threading model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, change the `command` callback for the **Play** button in the `play_bar`
    method from the existing `self.play()` method to `self.play_in_thread()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now if you load some drum samples, define the beat patterns, and hit the **Play**
    button, the sound will play in a separate thread without preventing the main loop
    from updating (refer to the code in `3.07.py`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step would be that of coding the **Stop** button. The role of the
    **Stop** button is simple; it merely stops the currently playing pattern. To do
    that, we first add a `command` callback to the **Stop** button calling on a method
    `stop_play` as follows (see the code in `3.07.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we define the `stop_play` method as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our thread system now runs the `play` method from a separate thread. However,
    if the user clicks on the button more than once, this will spawn more threads,
    which will play the beat. To avoid this, the button should be configured with
    `state='disabled'`, and enabled again when the sequence finishes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To disable the **Play** button when the program starts running, we add the
    following line to our `play_in_thread` method (refer to the code in `3.07.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, when the sequence finishes playing or the **Stop** button is clicked,
    we want to enable the **Play** button again. To enable it, we add the following
    line to our `play` and `stop_play` methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tkinter and thread safety**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tkinter is not thread safe. The Tkinter interpreter is valid only in the thread
    that runs the main loop. Any call to widgets must ideally be done from the thread
    that created the main loop. Invoking widget-specific commands from other threads
    is possible (as we do here), but is not reliable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you call a widget from another thread, the events get queued for the interpreter
    thread, which executes the command and passes the result back to the calling thread.
    If the main loop is running but not processing events, it sometimes results in
    unpredictable exceptions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The only change we make to our existing `play` method is to include the entire
    code in a `try-except` block. We do this because Tkinter is not thread safe and
    can cause some unwanted exceptions when dealing with the `play` thread. The best
    we can do here is ignore those cases using a `try-except` block.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**mtTkinter – a thread-safe version of Tkinter**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you find yourself working on an inherently multithreaded project, you might
    consider looking at **mtTkinter** **—**a thread-safe version of Tkinter. For more
    information on mtTkinter, visit [http://Tkinter.unPythonic.net/wiki/mtTkinter](http://Tkinter.unPythonic.net/wiki/mtTkinter).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For more specialized multiprocessing needs you may also want to take a look
    at *multiprocessing module* or an *event model* such as **Twisted**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The last step sees us code the **Loop** Checkbutton. The role of the **Loop**
    checkbox is simple. If the **Loop** checkbox is unchecked, the pattern plays only
    once. If it is checked, the pattern keeps playing in an endless loop. The pattern
    stops playing only if the **Loop** Checkbutton is unchecked or if the **Stop**
    button is pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add a `command` callback to the **Loop** checkbox:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then define the `loop_play` method as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Equipped with these two variables, we modify our `play` method to keep playing
    while `self.keep_playing` is equal to `True` see the code in `3.07.py`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the value of `self.loop` is equal to `False`, we set the value of `self.keep_playing`
    equal to `False`, which breaks out of the play loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This completes the project iteration. In this round, we refined our `play` method
    to play the audio files from a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: We used Python's built-in threaded module to play the loops in separate thread.
    We looked at some of the threading-related limitations of Tkinter and some ways
    in which we can overcome those limitations.
  prefs: []
  type: TYPE_NORMAL
- en: We also coded for the **Stop** button and **Loop** checkbox functionality.
  prefs: []
  type: TYPE_NORMAL
- en: More beat patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our drum program is now functional. You can load drum samples and define a beat
    pattern and our drum machine will play it out. Let us now extend our drum program
    so that we are able to create more than one pattern in the same program.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than a single drum pattern, now we will have a list of patterns. While
    playing the patterns, a user will be able to switch between many different beat
    patterns. This will allow the drummer to add variations to the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do is add a Spinbox widget in the top bar (as shown
    in the following screenshot), which will keep count of the number of patterns.
    We also add an Entry widget next to the Spinbox widget to keep track of the pattern
    name, which is decided by the number selected in the spin box.![Engage Thrusters](img/7941_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is added to the `create_top_bar` method(refer to the code in `3.08.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The pattern number is stored in a Tkinter integer variable as `self.patt`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Entry widget that stores the corresponding pattern name is called `self.pat_name`.
    This widget is marked as "read only", as we do not want to allow the user to modify
    the name.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spinbox widget has a `command` callback to a new method `record_pattern`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us now code the `record_pattern` method. The role of this method is to keep
    track of the state of a given pattern. Thus, for every pattern it needs to track
    the pattern number, units, BPU, drum samples loaded, and the beat pattern defined
    by the user for that pattern number. We will store this information in a list
    named `self.pattern_list`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our pattern spin box allows for adding 10 patterns. Therefore, we first initialize
    `self.pattern_list` as an empty list comprising of 10 empty spaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We initialize it in our class `__init__` method as follows (also seen in the
    code `3.08.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us now code the `record_pattern` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first line simply fetches the value of the current pattern number, bout,
    and units for the pattern to be recorded.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next four lines of this code do one simple job. For every change in pattern,
    it simply updates the corresponding Entry widget with the new name of the pattern.
    Since the Entry widget is "read only", we first configure its state as `normal`
    to allow us to enter text into the Entry widget. We then delete anything that
    might already be written in the widget and enter the new pattern name with the
    Python string formatting of `pattern_num'Pattern %s'%pattern_num`. Finally, we
    restore the entry widget to a `read only` state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two lines keep track of the last Spinbox widget number.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The next four lines of code actually record the state of the user-defined pattern
    in a two-dimensional list named `self.buttonpickleformat`. The list is first initialized
    to an empty two-dimensional matrix, taking into consideration the size of the
    pattern maker.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop then goes through every single button in the current pattern. If the
    button is not selected (not green), it leaves the value as `0`. If the button
    is selected (green), the value at the corresponding place is changed from `0`
    to `active`. Using this list we can then easily reproduce the user-defined pattern
    later on.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, all of this pattern-related data is stored as a list of the dictionary:
    `self.pattern_list[prevpval] = {''df'': self.widget_drum_file_name, ''bl'': self.buttonpickleformat,
    ''bpu'':bpu, ''units'':units}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The key `df` stores the list of drum filenames. The key `bl` stores the pattern
    defined by the button. The key `bpu` stores the BPU for that pattern, and the
    key `units` stores the units for that pattern.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that all of these items for a pattern are stored as a dictionary, we can
    easily use the dictionary to reconstruct the pattern. The last line calls the
    method `reconstruct_pattern()`, which actually does the reconstruction for us.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have stored pattern records, we need some method to reconstruct
    those patterns on our drum board. We define a new method `reconstruct_pattern`
    to handle it, as shown in the following code see the code in `3.08.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code can be broken into three broad parts:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reconstructing drum sample uploads
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconstructing BPU and units
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconstructing beat patterns
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having reconstructed these three things, we can easily replay any beat pattern.
    A brief description of each of these is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The list of drum filenames for a given pattern can easily be acquired from the
    key-value pair of the dictionary item `self.pattern_list[pattern_num]['df']`.
    We then iterate through items in this list and fill up the Entry widgets with
    each drum sample's filename.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then fetch the value of BPU and units from the dictionary keys `self.pattern_list[pattern_num]['bpu']`
    and `self.pattern_list[pattern_num]['units']`. We insert these values in their
    respective Spinbox widgets and then call the `create_right_pad()` method, which
    places the desired number of buttons on the right pad.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last iteration, we fetch the value of dictionary key `self.pattern_list[pattern_num]['bl']`,
    which gives us the position of the green buttons. Iterating through a loop, we
    check if a particular button is to be set to `active`. If yes, we change the color
    of the button to green.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Combined together, we can now load the previously recorded drum samples, set
    their **Units** and **BPU** values, and reconstruct the beat pattern as per previously
    set values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At each stage, the code checks if it cannot reconstruct a particular pattern
    because of invalid file markup. If it does find some invalid markup, it breaks
    out of the code using appropriate exception handling.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Hit the **Play** button and the drum machine will start rolling sound. Change
    the pattern number and define a new beat pattern. The new pattern will start playing.
    Revert to older patterns and the older patterns start playing again (refer to
    the code in `3.08.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've completed coding our drum machine to support the storing of multiple beat
    patterns, and the ability to play these patterns simply by changing the pattern
    number. This gives the user the ability to make different beats for the intro,
    verse, chorus, bridge, and other parts of a song.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we saw how to use Python's built-in data types to store custom
    data and to reproduce them in any required way.
  prefs: []
  type: TYPE_NORMAL
- en: Object persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding iteration, we added the capability to define multiple beat
    patterns. However, the beat patterns can be played only on a single script run.
    When the program is closed and restarted, all previous pattern data is lost.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to persist or store the beat patterns beyond a single program
    run. We need the ability to store values in some form of file storage and reload,
    play, and even edit the patterns. We need some form of object persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides several modules for object persistence. The module that we will
    use for persistence is called the **pickle module**. This is a standard library
    of Python.
  prefs: []
  type: TYPE_NORMAL
- en: An object represented as a string of bytes is called **pickle** in Python. **Pickling**
    , also known as **object serialization** , lets us convert our object into a string
    of bytes. The process reconstructing of the object back from the string of bytes
    is called **unpickling** or **deserialization**.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the `pickle` module is available at [http://docs.python.org/2/library/pickle.html](http://docs.python.org/2/library/pickle.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us illustrate it with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, we serialize or pickle our list `PartyMenu` using `pickle.dump` and save
    it in an external file `mymenu.p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We later retrieve the object using `pickle.load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Remember that in our previous iteration, we created a list, called `self.pattern_list`,
    where each item of the list is a dictionary that stores information about one
    single beat pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to reuse this information, we only need to pickle this `self.pattern_list`.
    Having saved the object, we can later easily unpickle the file to reconstruct
    our beat patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first need to add three top menu items to our program, as shown in the following
    screenshot:![Engage Thrusters](img/7941_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File** | **Load Project**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File** | **Save Project**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**File** | **Exit**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While we are creating our menu items let us also add an **About** menu item:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**About** | **About**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we are particularly interested in saving the project (pickling), and
    loading the project back (unpickling). The code for menu items is defined in a
    separate method called `create_top_menu`, as shown in the following code (also
    refer to the code in `3.09.py`):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code is self-explanatory. We have created similar menu items in our last
    two projects. Finally, to display this menu, we call this method from our `Main`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To pickle our object, we first import the `pickle` module into the current
    namespace as follows (see the code in `3.09.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The **Save Project** menu has a `command` callback attached to `self.save_project`,
    which is where we define the pickling process:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Recall that a pattern is added to `self.pattern_list` only when the pattern
    number is changed by the user. In situations where a user might have defined a
    beat pattern but may not have clicked on the pattern number's Spinbox widget,
    the pattern is not included in `self.pattern_list`. To make sure it is added,
    we first call `self.record_pattern` to capture this beat pattern.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `save_project` method is called when the user clicks on the **Save Project**
    menu, hence, we need to give the user an option to save the project in a file.
    We have chosen to define a new file extension (`.bt`) to keep track of our beat
    patterns.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user specifies the filename with `.bt` extension, the data in the `self.pattern_list`
    object is dumped into the file using `pickle.dump`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, the title of the Toplevel window is changed to reflect the filename.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are done pickling the object. Let us now code the unpickling process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The unpickling process is handled by a method `load_project`, which is called
    from the **Load Project** menu as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When a user clicks on the **Load Project** menu, the first line of the method
    prompts him/her with an **Open File** window. When the user specifies a previously
    pickled file with a `.bt` extension, the filename is stored in a variable called
    `file_name`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the filename returned is `none` because the user cancels the **Open File**
    dialog, nothing is done.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If filename is supplied, the title of the Toplevel window is changed to add
    the filename. The file is then opened in read mode, and the contents of the file
    are read into `self.pattern_list` using `pickle.load`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `self.pattern_list` now contains the list of beat patterns defined in the
    previous pickle. The file is closed and the first pattern of `self.pattern_list`
    is reconstructed in the drum machine. If there are more than one patterns defined
    in the serialized file, you can view each of the patterns simply by changing the
    pattern number Spinbox widget.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Try playing any of the patterns, and you should be able to replay the pattern
    exactly as it was defined at the time of pickling.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Pickling, though great for serialization, is vulnerable to malicious or erroneous
    data. You may want to use pickle only if the data is from a trusted source, or
    if proper validation mechanisms are in place.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You may also find the `json` module useful for serializing objects in **JSON**
    and **ElementTree** , or **xml.minidom** libraries relevant for parsing XML data.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let us complete coding our `exit` and `about` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And add this line to our `app` method to override the **Close** button of the
    Toplevel window:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is self-explanatory. We have done similar coding in our previous project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this iteration, we used Python's built-in `pickle` module to pickle and unpickle
    the beat patterns defined by the user.
  prefs: []
  type: TYPE_NORMAL
- en: This now lets us save patterns defined by the user. We have also provided the
    ability to load, replay, and edit the project later.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you define one or more beat patterns in your program you can save the
    project with a `.bt` file extension. You can later load the project and start
    working on it from the place where you had last left it.
  prefs: []
  type: TYPE_NORMAL
- en: While we were dealing with the top menu we also completed the code for the **About**
    and **Exit** menu items.
  prefs: []
  type: TYPE_NORMAL
- en: ttk-themed widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost done programming our drum machine. However, we would like to end
    this project by introducing you to the ttk-themed widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Prepare for Lift Off
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On many platforms such as Windows and X11, Tkinter does not bind to the native
    platform widgets. The Tk toolkit (and Tkinter) originally appeared on X-Window
    systems, hence, it adopted the motif look and feel, which was the de facto standard
    for GUI development on X-Window systems. When Tk was ported to other platforms,
    such as Windows and Mac OS, this Motif style started appearing out of place with
    the look of these platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Due to this, some even argue that Tkinter widgets are rather ugly and do not
    integrate well with such desktop environments.
  prefs: []
  type: TYPE_NORMAL
- en: Another criticism of Tkinter is based on the fact that Tkinter mixes logic and
    styling by allowing both to be changed as widget options.
  prefs: []
  type: TYPE_NORMAL
- en: It was also criticized to lack any kind of theming support. While we saw an
    example of centralized styling via the option database, the method required styling
    to be done at the widget level. It does not allow for selective styling of two
    button widgets differently, as an example. This made it difficult for developers
    to implement visual consistency for similar groups of widgets while differentiating
    them from other groups of widgets. As a result of this, many GUI developers moved
    to Tkinter alternatives such as **wxPython** , **glade** , **PyQT** , and others.
  prefs: []
  type: TYPE_NORMAL
- en: With Tkinter 8.5, the makers of Tkinter have tried to address all these concerns
    by introducing the `ttk` module, which may be considered as an advance to the
    original Tkinter module.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a look at some of the features offered by the ttk-themed widgets
    module.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things that `ttk` does is that it provides a set of built-in
    themes that allows Tk widgets to look like the native desktop environment in which
    the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, it introduces six new widgets: Combobox, Notebook, Progressbar,
    Separator, Sizegrip, and Treeview to the list of widgets, in addition to supporting
    11 core Tkinter widgets, which are Button, Checkbutton, Entry, Frame, Label, LabelFrame,
    Menubutton, PanedWindow, Radiobutton, Scale, and Scrollbar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `ttk` module, we first import it into the current namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can display the `ttk` widgets as follows see the code in `3.10.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: For a comparison of displays between the normal Tkinter widgets and the counterpart
    ttk widgets, see the code in `3.10.py`, which produces a window, as shown in the
    following screenshot. Notice how the widgets look like more native widgets on
    your platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`3.10.py` also shows dummy examples of all the new widgets introduced in the
    `ttk` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can even override the basic Tkinter widgets by importing `ttk` after `Tkinter`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This causes all widgets common to Tk and ttk to be replaced by ttk widgets.
  prefs: []
  type: TYPE_NORMAL
- en: This has the direct benefit of using the new widgets, which gives a better look
    and feel across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: However, the disadvantage of this kind of import, is that you cannot distinguish
    the module from which the widget classes are imported. This is important because
    `Tkinter` and `ttk` widget classes are not completely interchangeable. In this
    case, an unambiguous solution is to import them, as shown in the following codeimport
    Tkinter as tk
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: While most of the configuration options for Tkinter and ttk widgets are common,
    ttk-themed widgets do not support styling options such as `fg`, `bg`, `relief`,
    `border`, and more. This is purposefully removed from ttk in an attempt to keep
    logic and styling in different controls.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, all styling-related options are handled by the respective style names.
    In a standard `ttk` module, each widget has an associated style name. You can
    retrieve the default style name of a widget using the `widget.winfo_class()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance consider a ttk button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This prints **Tbutton**, which is the default style name for `ttk.Button`. For
    a list of default ttk style names for different widgets, refer to the *The ttk
    widgets* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the default style, you can assign a custom style class to a
    widget or group of widgets. To set up a new style you use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To configure the style options for a default style, you use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the new style on a widget you use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Next we will discuss about ttk theming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Style is used to control the appearance for individual widgets. Themes, on
    the other hand, control the appearance of the entire GUI. More simply put, a theme
    is a collection of styles. Grouping styles into themes lets the user switch designs
    for the entire GUI all at once. Like styles, all themes are uniquely identified
    by their name. The list of available themes can be obtained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the name of the currently active theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can change to another theme using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see various styling- and theming-related options of ttk through a dummy
    example (refer to the code in `3.11.py`, which produces a window like the one
    shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Prepare for Lift Off](img/7941_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three lines of code imports `Tkinter` and `ttk,` and sets up a new
    root window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line `x = ttk.Style()` is where you give a name `x` to your style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line configures a program-wide style configuration using `x.configure`.
    The dot character (`.`), which is the first argument of `configure`, means that
    this style would apply to the Toplevel window and to all its child elements. This
    is the reason why all of our widgets get to have a yellow background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line creates an extension (`danger`) to the default style (`TButton`).
    This is how you create custom styles, which are variations to a base default style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line creates a `ttk.label` widget. Since we have not specified any
    style for this widget, it inherits the global style specified for the Toplevel
    window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line creates a `ttk.button` widget and specifies it to be styled using
    our custom style definition of `'danger.TButton.'` This is why the foreground
    color of this button turns red. Notice how it still inherits the background color,
    yellow ,from the global Toplevel style that we defined earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two lines of code demonstrate how ttk allows for styling different
    widget states. In this example we styled different states for a `ttk.button` widget
    to display in different colors. Go ahead and click on this second button to see
    how different styles apply to different states of a button. Here we use `map(style,
    query_options, **kw)` to specify dynamic values of style for changes in state
    of the widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next line fetches the current applicable theme. It then overrides some
    of the options for the theme''s Entry widget using:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we know how to make our widgets look more like native platform widgets,
    let us change the **Play** and **Stop** buttons for our drum machine to `ttk.button`.
    Let us also change the **Loop** check button from Tkinter Checkbutton to ttk Checkbutton.
  prefs: []
  type: TYPE_NORMAL
- en: Engage Thrusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first import `ttk` into our namespace and append `ttk` to the `play` and
    `stop` buttons as follows (see the code in `3.12.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then simply modify the buttons and check button in the `create_play_bar`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these changes make the button and checkbutton look closer to the native
    widgets of your working platform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, note that we cannot modify the Tkinter buttons that we have used in our
    pattern editor. This is because our code extensively plays on the button's background
    color to decide logic. The ttk buttons do not have the configurable `bg` option,
    hence, cannot be used for buttons in our right drum pad.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a quick ending exercise let us add an image in the right-hand side of the
    play bar. Let us also add an icon for our Toplevel window (refer to the code in
    `3.12.py`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To add an image we add this to our `create_play_bar` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add a Toplevel icon, we add the following line to our `Main` method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Objective Complete – Mini Debriefing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This concludes the last iteration of this project. In this iteration, we first
    saw how and why to use ttk-themed widgets to improve the look and feel of our
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: We then used ttk buttons and ttk checkbuttons in our drum program to improve
    its look. We also saw the reasons why certain Tkinter buttons in our program could
    not be replaced by ttk buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Mission Accomplished
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way in our experiments with Tkinter. In this project we
    made a highly-functional drum machine with loads of features.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, we touched upon several vital concepts that go into the making
    of a GUI program with Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, we touched upon the following vital concepts of Tkinter-based
    GUI programs:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring Tkinter program as classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with more Tkinter widgets such as Spinbox, Button, Entry, and Checkbutton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `grid` geometry manager for structuring complex layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding threaded programming in relation to Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with other common modules from the Python standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object persistence with the `pickle` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ttk-themed widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The drum machine needs your attention. As a part of your Hotshot challenge,
    add the following features to your drum machine:'
  prefs: []
  type: TYPE_NORMAL
- en: The current application checks if the button is green in color to decide whether
    the button is in the pressed state. Modify the code so that this logic is not
    decided based on the color of the button, but by a separate variable that keeps
    track of the selected buttons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a tempo scale to your drum machine, which lets the user change the tempo
    of the beats using a slider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add volume control for each drum sample, allowing the user to change the volume
    individually for each drum sample.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a mute button for each drum sample. If the Checkbutton is clicked for a
    given drum sample, the sound is not played for that row. This way, a user can
    stop a complete row from playing without changing the patterns in that row.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a time clock to your drum machine, which displays the time elapsed since
    the last press of the play button.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
