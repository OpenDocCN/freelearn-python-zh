- en: Chapter 3. Programmable Drum Machine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：可编程鼓机
- en: We built a text editor in the last project. In the process, we looked at some
    common Tkinter widgets such as Menu, Buttons, Label, and Text. Now, let us now
    do some music. Let us build a cross-platform drum machine using Tkinter and some
    other Python modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个项目中，我们构建了一个文本编辑器。在这个过程中，我们查看了一些常见的 Tkinter 小部件，如 Menu、Buttons、Label 和 Text。现在，让我们做一些音乐。让我们使用
    Tkinter 和一些其他 Python 模块构建一个跨平台鼓机。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: In this project, we will build a programmable drum machine. The graphical user
    interface of the drum machine is based on Tkinter. You will be able to create
    an unlimited number of beat patterns using an unlimited number of drum samples.
    You can then store multiple riffs in a project and playback or edit the project
    later on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将构建一个可编程的鼓机。鼓机的图形用户界面基于 Tkinter。您可以使用无限数量的鼓样本创建无限数量的节拍模式。然后您可以在项目中存储多个riff，并在以后播放或编辑项目。
- en: '![Mission Briefing](img/7941_03_01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![任务简报](img/7941_03_01.jpg)'
- en: To create your own drum beat patterns, simply load some drum samples using the
    buttons on the left. You can change the units that constitute a beat pattern,
    which in turn decides the tempo of the rhythm. You can also decide the number
    of beats per units. Most western beats have four beats per unit, waltz would have
    three beats per unit, and some Indian and Arabic rhythms that I composed on this
    machine had 3 to 16 beats per unit!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的鼓点模式，只需使用左侧的按钮加载一些鼓样本。您可以更改构成节拍模式的单位，这反过来又决定了节奏的速度。您还可以决定每个单位中的节拍数。大多数西方节拍每个单位有四个节拍，华尔兹每个单位有三个节拍，我在这台机器上创作的某些印度和阿拉伯节奏每个单位有
    3 到 16 个节拍！
- en: Why Is It Awesome?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它如此出色？
- en: Don't be misled by the small size of the GUI. This is a powerful drum machine
    that can match features offered by some large commercial drum machine programs.
    By the end of this project, you should be in a position to extend it to outdo
    some of the commercial drum programs out there.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被 GUI 的小尺寸所误导。这是一个功能强大的鼓机，可以与一些大型商业鼓机程序提供的功能相媲美。到这个项目的结束时，您应该能够扩展它，超越一些商业鼓程序。
- en: 'Some of the key features of the machine include:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 该机器的一些关键特性包括：
- en: Large number of beats
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量节拍
- en: Large number of patterns to accompany songs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量模式以伴随歌曲
- en: Variable number of beats per pattern
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个模式中节拍数可变
- en: Use of 16 bit, 44100 kHz WAV samples (mono or stereo)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 16 位，44100 kHz WAV 样本（单声道或立体声）
- en: Support for various file formats
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持各种文件格式
- en: Ability to save projects comprising of several patterns
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够保存包含多个模式的多个项目
- en: A few drum samples are provided in the `Loops` subdirectory; however, you can
    load any other drum sample. You can download a large number of samples for free
    from the Internet.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Loops` 子目录中提供了一些鼓样本；然而，您可以加载任何其他鼓样本。您可以从互联网上免费下载大量样本。
- en: In the process of developing this program, we tweak Tkinter further and take
    a look at several important concepts and ideas that are normally encountered in
    GUI programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发这个程序的过程中，我们进一步调整 Tkinter，并查看在 GUI 编程中通常遇到的一些重要概念和想法。
- en: Your Hotshot Objectives
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的热门目标
- en: 'Some of the key objectives for taking up this project include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 承担这个项目的关键目标包括：
- en: Understanding how Tkinter is normally applied in context of OOP
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Tkinter 在面向对象上下文中的应用
- en: Working with a few more Tkinter widgets such as Spinbox, Button, Entry, and
    Checkbutton
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一些其他 Tkinter 小部件，如 Spinbox、Button、Entry 和 Checkbutton
- en: Working with the `grid` geometry manager
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `grid` 几何管理器
- en: Working with ttk-themed widgets
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ttk 主题小部件
- en: Understanding threaded programming in relation to Tkinter
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与 Tkinter 相关的线程编程
- en: Working with other common modules from the Python standard library
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 标准库中的其他常见模块
- en: Object persistence with the `pickle` module
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pickle` 模块进行对象持久化
- en: Apart from these key concepts, we discuss several other vital nuggets of GUI
    programming in the course of the project.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些关键概念之外，我们在项目过程中讨论了其他几个 GUI 编程的重要要点。
- en: Mission Checklist
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务清单
- en: In this project, we will use some more built-in libraries from the standard
    Python distribution. This includes `Tkinter`, `ttk`, `tkFileDialog`, `tkMessageBox`,
    `os`, `time`, `threading`, `wave`, and `pickle` modules.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用一些标准 Python 分发中的内置库。这包括 `Tkinter`、`ttk`、`tkFileDialog`、`tkMessageBox`、`os`、`time`、`threading`、`wave`
    和 `pickle` 模块。
- en: 'To verify that these modules do exist, simply run the following statement in
    the IDLE interactive prompt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证这些模块是否存在，只需在IDLE交互式提示符中运行以下语句：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should not cause an error as the standard Python distribution comes with
    these modules built into the distribution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该导致错误，因为标准的Python发行版已经将这些模块内置到发行版中。
- en: Other than this, you need to add an extra Python module called `pymedia`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，您还需要添加一个名为`pymedia`的额外Python模块。
- en: The `pymedia` module can be downloaded at [http://pymedia.org/](http://pymedia.org/).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://pymedia.org/](http://pymedia.org/)下载`pymedia`模块。
- en: 'After you have installed the module, you can verify it by importing it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 安装模块后，您可以通过导入它来验证：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If no errors are rported, you are ready to program the drum machine. Let's start!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有报告错误，你就可以开始编程鼓机了。让我们开始吧！
- en: Setting up the GUI in OOP
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象编程设置GUI
- en: The text editor program that we developed as our previous project was set up
    in procedural code. While it offered some benefit of quick coding, it essentially
    ran as a single process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为上一个项目开发的文本编辑程序是使用过程式代码设置的。虽然它提供了一些快速编码的好处，但它本质上是一个单一的过程。
- en: We started encountering global variables. The function definitions needed to
    be defined above the code that called them and most importantly the code was not
    reusable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始遇到全局变量。函数定义需要在调用它们的代码之上定义，最重要的是，代码不可重用。
- en: Therefore, we need some way to ensure that our code is more reusable. This is
    why programmers prefer to use **Object Oriented Programming** (**OOP**) to organize
    their code into classes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要某种方式来确保我们的代码更具可重用性。这就是为什么程序员更喜欢使用**面向对象编程（OOP**）来组织他们的代码到类中。
- en: OOP is a programming paradigm that shifts the focus onto the objects we want
    to manipulate rather than the logic required to manipulate them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种编程范式，它将重点从操纵它们的逻辑转移到我们想要操纵的对象上。
- en: This is in contrast to procedural programming that views a program as a logical
    procedure that takes input, processes it, and produces some output.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这与将程序视为一个逻辑过程，该过程接受输入，处理它并产生一些输出的过程式编程相反。
- en: OOP provides several benefits such as data abstraction, encapsulation, inheritance,
    and polymorphism. In addition, OOP provides a clear modular structure for programs.
    Code modification and maintenance is easy as new objects can be created without
    modifying the existing ones.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程提供了诸如数据抽象、封装、继承和多态等好处。此外，面向对象编程为程序提供了清晰的模块化结构。由于可以创建新的对象而不必修改现有的对象，因此代码修改和维护变得容易。
- en: Let us build our drum program using OOP to illustrate some of these features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用面向对象编程来构建我们的鼓程序，以展示这些功能的一些示例。
- en: Prepare for Lift Off
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: 'An indicative OOP structure for our drum program could be as follows (see the
    code in `3.01.py`):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓程序的指示性OOP结构可能如下所示（参见`3.01.py`中的代码）：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The description of the code is listed as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下所示：
- en: We create a class called `DrumMachine` and define a method `app()`to initialize
    the Toplevel window
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个名为`DrumMachine`的类，并定义一个`app()`方法来初始化顶层窗口
- en: If the program is run as a standalone program, a new object is created and the
    `app` method is called to create the Toplevel window
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序作为独立程序运行，将创建一个新的对象，并调用`app`方法来创建顶层窗口
- en: This code creates a blank Toplevel window
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码创建一个空的顶层窗口
- en: Now that we have our Toplevel window ready, let us add some widgets to it. In
    this iteration we will lay the top bar, left bar (the area that lets us upload
    drum samples), the right bar (that has buttons to define the beat patterns), and
    play bar at the bottom (which has a **Play** button, a **Stop** button, and a
    **Loop** check button).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了顶层窗口，让我们向其中添加一些小部件。在这个迭代中，我们将放置顶部栏、左侧栏（允许我们上传鼓样本的区域）、右侧栏（具有定义节拍模式的按钮）和底部的播放栏（其中有一个**播放**按钮、一个**停止**按钮和一个**循环**复选按钮）。
- en: 'The four areas have been demarcated in different squares to group widgets into
    separate frames, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 四个区域已在不同的方框中划分，以将小部件分组到单独的框架中，如下面的截图所示：
- en: '![Prepare for Lift Off](img/7941_03_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_03_02.jpg)'
- en: Engage Thrusters
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we will create the top bar. The top bar is one that holds the Spinbox
    widgets, which lets the user change the units and beats per unit in a rhythm pattern.
    These two together decide the tempo and the cyclical pattern of a rhythm as follows
    (see the code in `3.02.py`):'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建顶部栏。顶部栏是包含Spinbox小部件的栏，允许用户在节奏模式中更改单位和每单位节拍。这两个一起决定了节奏的速度和循环模式，如下所示（参见`3.02.py`中的代码）：
- en: '[PRE3]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The description of the code is listed as follows:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We first create a new method in order to create the top bar. We add a frame
    `top_bar_frame` for the top bar and then add two spin boxes to keep track of the
    units and beats per unit values. We do not add `command` callbacks now. The callbacks
    will be added later.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的方法来创建顶部栏。我们添加一个框架`top_bar_frame`用于顶部栏，然后添加两个spin boxes来跟踪单位和每单位节拍值。现在我们不添加`command`回调。回调将在稍后添加。
- en: We define two Tkinter variables `self.units` and `self.bpu` to hold the current
    value of both the Spinbox widgets. This is defined as an object variable (`self`)
    because we will need these variables outside the scope of this method.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了两个Tkinter变量`self.units`和`self.bpu`来保存Spinbox小部件的当前值。这是因为我们将在该方法的作用域之外需要这些变量，所以将其定义为对象变量（`self`）。
- en: The widgets are placed using the `grid` geometry manager.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件使用`grid`几何管理器进行放置。
- en: Next we will create the left bar. The left bar is one that will let the user
    load drum samples. Each row in the left bar allows for loading one unique drum
    sample. The drum samples are normally small `.wav` or `.ogg` file samples for
    different drums such as bass, snare, tom, bell, claves, or samples that the user
    decides.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建左侧栏。左侧栏是允许用户加载鼓样本的栏。左侧栏的每一行都允许加载一个独特的鼓样本。鼓样本通常是不同鼓（如贝斯、钹、军鼓、钟、克拉韦斯）的小型`.wav`或`.ogg`文件样本，或者用户决定的其他样本。
- en: The buttons on the left bar will open an upload file. When the user uploads
    a drum sample, the name of the drum sample will automatically populate the Entry
    widget adjacent to that button.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 左侧栏上的按钮将打开上传文件。当用户上传鼓样本时，鼓样本的名称将自动填充到该按钮相邻的Entry小部件中。
- en: 'Thus, each row has a Button and an Entry widget (refer to the code in `3.02.py`):'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，每一行都有一个按钮和一个Entry小部件（参考`3.02.py`中的代码）：
- en: '[PRE4]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The description of the code is listed as follows:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The maximum number of drum samples that can be loaded is defined as a constant
    `MAX_DRUM_NUM`
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以加载的最大鼓样本数被定义为常量`MAX_DRUM_NUM`
- en: We create another frame called `left_frame` to hold various widgets in this
    area
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建另一个名为`left_frame`的框架来容纳这个区域的各种小部件
- en: Iterating over a loop, we create Button and Entry widgets for as many drum samples
    as we need to allow the user to load
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过循环，我们为需要允许用户加载的鼓样本数量创建Button和Entry小部件
- en: Next we will create the right bar. The right bar is the area that lets the user
    define the beat pattern. This area consists of a series of buttons. The number
    of row of buttons is equal to the number of drum samples that can be loaded. The
    number of columns of buttons is decided by the number of units and number of beats
    per unit selected by the user from the spin boxes in the top bar. The number of
    columns of buttons is equal to product of the number of units and beats per unit.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建右侧栏。右侧栏是允许用户定义节拍模式的区域。这个区域由一系列按钮组成。按钮的行数等于可以加载的鼓样本数。按钮的列数由用户在顶部栏的spin
    boxes中选择的单位和每单位节拍数决定。按钮的列数等于单位和每单位节拍数的乘积。
- en: 'We are not connecting the spin boxes with the buttons right now. For now, let
    us place buttons in four columns for each individual drum sample that can be loaded
    as follows (refer to the code in `3.02.py`):'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前我们还没有将旋转框与按钮连接起来。现在，让我们为每个可以加载的鼓样本放置四个按钮列，如下所示（参考`3.02.py`中的代码）：
- en: '[PRE5]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The description of the code is listed as follows:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We create another frame `right_frame` to hold these buttons.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建另一个框架`right_frame`来容纳这些按钮。
- en: Using list comprehension, we create an empty list of size `4 *MAX_DRUM_NUM`.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表推导，我们创建了一个大小为`4 * MAX_DRUM_NUM`的空列表。
- en: For now, we simply add four columns of buttons to occupy the place. The number
    of rows of buttons are kept equal to the maximum number of drum samples, to have
    one row of buttons corresponding to each sample.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们只是简单地添加四个按钮列来占据空间。按钮的行数保持等于最大鼓样本数，以便每行按钮对应一个样本。
- en: Note
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: There is reason behind grouping widgets into different methods.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将小部件分组到不同的方法中是有原因的。
- en: For example, we have created the left pad and the right pad using two separate
    methods `create_left_pad` and `create_right_pad`. If we had defined these two
    groups of widgets within the same method, the user would have to reload the drum
    samples every time the left buttons changed due to changes in BPU and units. This
    would have been counterproductive for the end user.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们使用两个独立的方法 `create_left_pad` 和 `create_right_pad` 创建了左侧鼓垫和右侧鼓垫。如果我们在这两个相同的方法中定义了这两组小部件，由于
    BPU 和单元的变化，每次左侧按钮改变时，用户都需要重新加载鼓样本。这对最终用户来说将是事倍功半。
- en: As a rule of thumb, it is always advisable to keep related widgets within a
    single method. However, the deciding class structure is more of an art than science
    to be learned and refined over a lifetime.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据经验法则，始终建议将相关的部件放在单个方法中。然而，决定类结构更多的是一种艺术，而不是科学，需要一生去学习和完善。
- en: 'Next we will create the play bar. The play bar at the bottom includes the **Play**
    button, the **Stop** button, and a **Loop** check button. Refer to the code in
    `3.02.py`, as shown in the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来我们将创建播放条。底部的播放条包括 **播放** 按钮、**停止** 按钮和一个 **循环** 复选按钮。请参考 `3.02.py` 中的代码，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The description of the code is listed as follows:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The code is pretty self-explanatory. It creates a frame `playbar_frame` and
    puts two buttons and one check button within the frame.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码相当直观。它创建了一个框架 `playbar_frame`，并在其中放置了两个按钮和一个复选按钮。
- en: A Tkinter `BooleanVar()` is created to track the status of Checkbutton.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个 Tkinter `BooleanVar()` 来跟踪 Checkbutton 的状态。
- en: 'Now that we have created all the widgets, its now time to actually display
    them by explicitly calling the methods that created them. We do that within the
    main loop of our program as follows (refer to the code in `3.02.py)`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了所有的小部件，现在是时候通过显式调用创建它们的那些方法来实际显示它们了。我们在程序的主循环中这样做，如下所示（请参考 `3.02.py`
    中的代码）：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rather than defining a separate method `app()` to run our main loop, we could
    also have run the main loop by creating an initialization method called `__init__`.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而不是定义一个单独的方法 `app()` 来运行我们的主循环，我们也可以通过创建一个名为 `__init__` 的初始化方法来运行主循环。
- en: In that case, we would not have to call the `app()`method explicitly to run
    the program. However, in case someone ever needs to use this class in another
    program, it would have needlessly created a GUI.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在那种情况下，我们就不需要显式调用 `app()` 方法来运行程序。然而，如果有人需要在另一个程序中使用这个类，它将无谓地创建一个 GUI。
- en: Calling the `mainloop` function explicitly from the `app()` method leaves us
    room to use the code as a library for some other program.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 `app()` 方法中显式调用 `mainloop` 函数为我们使用代码作为其他程序的库留出了空间。
- en: Objective Complete – Mini Debriefing
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes our first iteration. In this iteration we have managed to create
    the basic structure of our drum program. This includes creating the top, left,
    right, and bottom frames that holds different widgets as per the requirement of
    the drum program.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第一次迭代。在这个迭代中，我们成功地创建了鼓程序的基本结构。这包括创建顶部、左侧、右侧和底部的框架，这些框架根据鼓程序的要求持有不同的小部件。
- en: We have also seen one of the most common ways of structuring the Tkinter GUI
    program in an object-oriented style of programming.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了以面向对象编程风格构建 Tkinter GUI 程序的最常见方式之一。
- en: Completing the pattern editor
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成模式编辑器
- en: In the preceding iteration, we coded a dummy `create_right_pad` with four columns
    of buttons. However, in the scheme of our program, the number of columns of buttons
    depends upon the choice of **Units** and beats per units (**BPU**) values selected
    by the end user.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个迭代中，我们编写了一个虚拟的 `create_right_pad`，其中包含四列按钮。然而，在我们的程序方案中，按钮的列数取决于最终用户选择的
    **单元** 和每单位节拍数（**BPU**）值。
- en: 'The number of columns of buttons should be equal to:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮的列数应该等于：
- en: Number of Units x BPU
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 单元数量 x BPU
- en: 'Furthermore, to demarcate each unit, each consecutive unit of buttons should
    be displayed in different colors. Moreover, when a button is clicked, its color
    should change to track the user-defined pattern, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了区分每个单元，每个连续的按钮单元应以不同的颜色显示。此外，当按钮被点击时，其颜色应改变以跟踪用户定义的模式，如下面的截图所示：
- en: '![Completing the pattern editor](img/7941_03_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![完成模式编辑器](img/7941_03_03.jpg)'
- en: Let us add these three features to our drum editor.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这三个功能添加到我们的鼓编辑器中。
- en: Engage Thrusters
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First, we will start by connecting buttons to the **Units** and **BPU** Spinbox
    widgets. The code is simple. We add `command` callbacks from both the Spinbox
    widgets in the top bar to call our `create_right_pad` method. Refer to the code
    in `3.03.py`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从将按钮连接到**单位**和**BPU** Spinbox小部件开始。代码很简单。我们从顶部栏中的两个Spinbox小部件添加`command`回调来调用我们的`create_right_pad`方法。请参考`3.03.py`中的代码：
- en: '[PRE8]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then modify our existing `create_right_pad` method as follows, and in code
    `3.03.py`:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们按照以下方式修改现有的`create_right_pad`方法，并在`3.03.py`代码中：
- en: '[PRE9]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The description of the code is listed as follows:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下所示：
- en: Within our frame `right_frame`, we iterate through a double-nested loop creating
    a two-dimensional matrix where the number of rows is equal to the constant `MAX_DRUM_NUM`,
    while the number of columns is equal to the product of **Units** and **BPU**.
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的`right_frame`框架中，我们通过双重嵌套循环创建一个二维矩阵，其中行数等于常量`MAX_DRUM_NUM`，而列数等于**单位**和**BPU**的乘积。
- en: The color of each button is configured to either `grey55` or `khaki` depending
    on whether the factor `j/bpu` is even or odd.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个按钮的颜色配置为`grey55`或`khaki`，具体取决于因子`j/bpu`是偶数还是奇数。
- en: Now if you run the code (code `3.03.py`), you will find the number of buttons
    changing as per selections you make in the units and bpu spin boxes. Moreover,
    each unit will be colored alternately in khaki and gray colors.
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在如果您运行代码（代码`3.03.py`），您会发现按钮的数量会根据您在单位和bpu Spinbox中做出的选择而变化。此外，每个单位将以交替的土色和灰色着色。
- en: Notice how we have defined the `grid` geometry position of buttons in terms
    of variables `i` and `j`.
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意我们是如何用变量`i`和`j`定义按钮的`grid`几何位置的。
- en: Now that the buttons respond to change in units and bpu, it is time that we
    change these buttons into toggle buttons. When a user clicks on any of the buttons,
    the color of the button should change to green. When the button is clicked again,
    the color reverts to its original color. We need this feature to define beat patterns.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在按钮对单位和bpu的变化做出响应，是时候将这些按钮更改为切换按钮了。当用户点击任何按钮时，按钮的颜色应变为绿色。当按钮再次被点击时，颜色恢复到其原始颜色。我们需要这个功能来定义节拍模式。
- en: 'We first add a `command` callback to our buttons, passing the button''s row,
    column, and bpu as arguments to a new method `button_clicked` (refer to the code
    in `3.03.py`), as shown in the following code:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先为我们的按钮添加一个`command`回调，将按钮的行、列和bpu作为参数传递给新的`button_clicked`方法（请参考`3.03.py`中的代码），如下所示：
- en: '[PRE10]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then define the `button_clicked` method as follows:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们然后定义`button_clicked`方法如下所示：
- en: '[PRE11]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The description of the code is listed as follows:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下所示：
- en: 'Our method `button_clicked` takes three arguments: `i, j`, and `bpu`.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`button_clicked`方法接受三个参数：`i, j`和`bpu`。
- en: The variables `i` and `j` let us track which button is clicked. However, note
    that the `command` callback `self.Button_clicked(i,j,bpu)` makes a reference to
    `i` and `j` when the button is not yet created. In order to track the button that
    is clicked by the user, we enclose a separate `callback()` function within our
    `self.button_clicked` function, which then returns a callback. Now our method
    will return a different value of `i` and `j` for each button record.
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`i`和`j`让我们跟踪哪个按钮被点击。然而，请注意，当按钮尚未创建时，`command`回调`self.Button_clicked(i,j,bpu)`会引用`i`和`j`。为了跟踪用户点击的按钮，我们在`self.button_clicked`函数中封装了一个单独的`callback()`函数，然后它返回一个回调。现在，我们的方法将为每个按钮记录返回不同的`i`和`j`值。
- en: The `bpu` argument is needed to calculate the original color of the button.
    This is needed to revert the color of button back to its original color if the
    button is toggled. Before we change the color of the button to green, we store
    its original color in a variable `color`.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpu`参数用于计算按钮的原始颜色。如果按钮被切换，则需要此参数以将按钮的颜色恢复到其原始颜色。在我们将按钮的颜色更改为绿色之前，我们将原始颜色存储在变量`color`中。'
- en: Objective Complete – Mini Debriefing
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: We have now completed coding the right drum pad. In the process we have created
    a two-dimensional list of buttons `self.button`, where `self.button[i][j]` refers
    to the button at the *i*th row and *j*th column.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了右侧鼓垫的编码。在这个过程中，我们创建了一个按钮的二维列表`self.button`，其中`self.button[i][j]`指的是第*i*行和*j*列的按钮。
- en: Each of these buttons can be toggled on or off to represent whether or not a
    drum sample is to be played for that particular button.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些按钮中的每一个都可以打开或关闭，以表示是否为该特定按钮播放鼓样本。
- en: When a button is on, its color changes to green. If it is switched off, it reverts
    to its original color. This structure can be easily used to define a beat pattern.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮处于开启状态时，其颜色会变为绿色。如果它被关闭，它会恢复到原始颜色。这种结构可以很容易地用来定义一个节拍模式。
- en: In the process, we have seen more advanced usage of the Spinbox and Button widget.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们看到了对Spinbox和Button小部件的更高级使用。
- en: Loading drum samples
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载鼓样本
- en: Our main objective is to play sound files, in the order of a beat pattern decided
    by the user. To do this we need to add sound files to the drum machine.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要目标是播放用户决定的节拍模式顺序中的声音文件。为此，我们需要将声音文件添加到鼓机中。
- en: Our program does not have any preloaded drum files. Instead, we want to let
    the user select from a wide variety of drum files. Thus, besides the normal drum,
    you can play a Japanese tsuzumi, an Indian tabla, Latin American bongo drums,
    or just about any other sound that you want to add to your rhythm. All you need
    is a small `.wav` or `.ogg` file containing that sound's sample.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序没有预加载任何鼓文件。相反，我们希望让用户从广泛的鼓文件中选择。因此，除了正常的鼓之外，你可以播放日本的小太鼓、印度的手鼓、拉丁美洲的邦戈鼓，或者几乎任何你想添加到你的节奏中的声音。你所需要的只是一个包含该声音样本的小`.wav`或`.ogg`文件。
- en: '![Loading drum samples](img/7941_03_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![加载鼓样本](img/7941_03_04.jpg)'
- en: Let us code the ability to add this drum sample to our program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码来添加这个鼓样本到我们的程序中。
- en: The drum sample is to be loaded on the left bar, as shown in the preceding screenshot.
    We have already created buttons with folder icons to the left-hand side of our
    drum pad. The desired functionality is simple.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓样本应该加载在左侧的条上，如图中所示的前一个屏幕截图。我们已经在鼓垫的左侧创建了带有文件夹图标的按钮。所需的功能很简单。
- en: When a user clicks on any of the left buttons, they should open a file dialog
    letting the user choose a `.wav` or `.ogg` file. When the user selects the file
    and clicks on **Open**, the Entry widget next to that button should be populated
    with the name of the file. Further, the location of the drum sample file should
    be added to a list for playing it later.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击任何一个左侧按钮时，应该打开一个文件对话框，让用户选择一个`.wav`或`.ogg`文件。当用户选择文件并点击**打开**时，该按钮旁边的Entry小部件应该填充文件的名称。此外，鼓样本文件的存储位置应该添加到一个列表中，以便稍后播放。
- en: Engage Thrusters
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'First we will import the required modules. To open the sound file, we will
    use the `tkFileDialog` module. We will also use the `tkMessageBox` module to display
    certain pop-up messages. We will also need to extract the filename of the given
    sound sample using the `os` module. Let us begin by importing the three modules
    (given in the following code) into our current namespace (refer to the same code
    present in `3.04.py`):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将导入所需的模块。为了打开声音文件，我们将使用`tkFileDialog`模块。我们还将使用`tkMessageBox`模块来显示某些弹出消息。我们还需要使用`os`模块提取给定声音样本的文件名。让我们首先将以下代码中的三个模块（参考`3.04.py`中的相同代码）导入到我们的当前命名空间中：
- en: '[PRE12]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next, we will add Attributes to track the loaded samples. The user will invariably
    load more than one drum sample. Therefore, we need to track the Entry widget where
    the drum sample was loaded, the location of each of the drum samples, and a number
    indicating the current drum number. Accordingly, we create two lists called `self.widget_drum_name`
    and `self.widget_drum_file_name` to store the Entry widget instance and file location
    respectively.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加属性来跟踪加载的样本。用户不可避免地会加载多个鼓样本。因此，我们需要跟踪鼓样本加载的Entry小部件、每个鼓样本的位置以及表示当前鼓号的数字。相应地，我们创建了两个名为`self.widget_drum_name`和`self.widget_drum_file_name`的列表来存储Entry小部件实例和文件位置。
- en: We also declare a variable `self.current_drum_no` to track the current drum
    number.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还声明了一个变量`self.current_drum_no`来跟踪当前鼓号。
- en: 'We choose to initialize these variables and list under our initialization method
    `__init__` (refer to the code in `3.04.py`):'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们选择在初始化方法`__init__`（参考`3.04.py`中的代码）下初始化这些变量和列表：
- en: '[PRE13]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We then modify our `create_left_pad` method to include a line that appends
    a list of all drum Entry widgets in our newly-created list `self.widget_drum_name`:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们修改我们的`create_left_pad`方法，包括一个将所有鼓条Entry小部件的列表追加到我们新创建的列表`self.widget_drum_name`中的行：
- en: '[PRE14]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We then add a `command` callback to the buttons in our `create_left_pad` method
    to load drum samples, as shown in the following code snippet:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`create_left_pad`方法中的按钮上添加一个`command`回调来加载鼓样本，如下面的代码片段所示：
- en: '[PRE15]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we code our `drum_load` method as follows (refer to the code in `3.04.py`):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们按照以下方式编写我们的`drum_load`方法（参考`3.04.py`中的代码）：
- en: '[PRE16]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The description of the code is listed as follows:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We define a callback function within our function because we need to track several
    drum samples.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在函数内部定义一个回调函数，因为我们需要跟踪几个鼓样本。
- en: To track the widget, through which a sound sample has been loaded, we set the
    `self.current_drum_no` value to be equal to the `drum_num` value received as an
    argument from the button `command` callback.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了跟踪通过哪个小部件加载了声音样本，我们将`self.current_drum_no`的值设置为从按钮`command`回调接收到的`drum_num`值。
- en: In a `try` block, we use `tkFileDialog.askopenfilename` to get the filename
    of the drum sample. We then check whether a filename already exists in our filename
    list. If it does, we delete it.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个`try`块中，我们使用`tkFileDialog.askopenfilename`获取鼓样本的文件名。然后我们检查文件名是否已经存在于我们的文件名列表中。如果是，我们将其删除。
- en: Using `os.path.basename` from the `os` module, we obtain the filename from the
    file path and insert it into corresponding Entry widget.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.path.basename`模块从`os`模块中获取文件名，并将其插入到相应的Entry小部件中。
- en: If `askopenfilename` fails, we use `tkMessageBox.showerror` to display a custom
    error message.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`askopenfilename`失败，我们使用`tkMessageBox.showerror`来显示自定义错误消息。
- en: Objective Complete – Mini Debriefing
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: In this iteration, we imported modules to handle dialogs and message boxes.
    We then added attributes to track drum samples. Finally, we added `command` callbacks
    to buttons which when clicked open a dialog for the user to select drum samples.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们导入了处理对话框和消息框的模块。然后我们添加了跟踪鼓样本的属性。最后，我们为按钮添加了`command`回调，当按钮被点击时，会打开一个对话框供用户选择鼓样本。
- en: Our code is now capable of loading drum samples and storing all necessary records
    that we will require to play beat patterns.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的代码能够加载鼓样本并存储所有必要的记录，我们将需要这些记录来播放鼓点模式。
- en: Next, let us turn our attention to playing the beat samples as per a user-defined
    pattern.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将注意力转向根据用户定义的模式播放鼓样本。
- en: Playing the drum machine
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放鼓机
- en: Now that we have a mechanism to load drum samples and a mechanism to define
    beat patterns in place, let us add the ability to play these beat patterns. In
    many ways, this is the core of our program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了加载鼓样本和定义鼓点模式的机制，让我们添加播放这些鼓点模式的能力。在许多方面，这是我们程序的核心。
- en: Let us first understand the functionality that we want to achieve here. Once
    the user has loaded one or more drum sample and has defined a beat pattern using
    the toggle buttons, we need to scan each column of the pattern to see if it finds
    a green button. If it finds one, our code should play the corresponding drum sample
    before moving ahead. Moreover, green buttons on the same column should play almost
    together, while there should be some time gap between each successive column,
    which would define the tempo of the music.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解我们想要实现的功能。一旦用户加载了一个或多个鼓样本，并使用切换按钮定义了鼓点模式，我们需要扫描模式的每一列，看看是否找到一个绿色按钮。如果找到了，我们的代码应该在继续之前播放相应的鼓样本。此外，同一列上的绿色按钮应该几乎同时播放，而每一列之间应该有一定的间隔时间，这将定义音乐的节奏。
- en: Prepare for Lift Off
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: We will use the `pymedia` module to play the sound files. The `pymedia` module
    can play a wide variety of sound formats such as `.wav`, `.ogg`, `.mp3`, `.avi`,
    `.divx`, `.dvd`, and `.cdda` on multiple operating systems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`pymedia`模块来播放声音文件。`pymedia`模块可以在多个操作系统上播放多种声音格式，如`.wav`、`.ogg`、`.mp3`、`.avi`、`.divx`、`.dvd`和`.cdda`。
- en: 'Without getting into the details of how pymedia plays the sound files, the
    official documentation tells us that we can play audio files using the following
    code sample:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨pymedia如何播放声音文件，官方文档告诉我们可以使用以下代码示例来播放音频文件：
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you run this piece of code as an independent script and supply the file location
    of a supported audio file in place of `'YOUR FILE NAME'`, this should play the
    media file on your computer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此段代码作为一个独立的脚本运行，并用支持音频文件的文件位置替换`'YOUR FILE NAME'`，这应该在你的电脑上播放媒体文件。
- en: Using this code sample, we will implement the play functionality for our drum
    machine.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码示例，我们将实现鼓机的播放功能。
- en: Engage Thrusters
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Let us first import all of the necessary modules into our namespace (refer
    to the code in `3.05.py`):'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将所有必要的模块导入到我们的命名空间中（参考`3.05.py`中的代码）：
- en: '[PRE18]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will define the `play_sound` method as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`play_sound`方法如下：
- en: '[PRE19]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method simply takes the API provided by `pymedia` and wraps it into a method
    that takes a filename and plays it.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法只是简单地使用`pymedia`提供的API，并将其包装成一个接受文件名并播放的方法。
- en: 'Let us now define the `play` method that actually plays the beat samples:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来定义`play`方法，它实际上播放节拍样本：
- en: '[PRE20]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The description of the code is listed as follows:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We loop through all of the buttons scanning each column before moving to the
    next column. For every button, we use `widget.cget()` to check to see if its color
    is green.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们遍历所有按钮，在移动到下一列之前扫描每一列。对于每个按钮，我们使用`widget.cget()`来检查其颜色是否为绿色。
- en: If the color is green, we check if there is a corresponding drum sample loaded.
    If not, we ignore the green button and move to the next item in the loop using
    `continue`.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果颜色是绿色，我们检查是否有相应的鼓样本已加载。如果没有，我们忽略绿色按钮，并使用`continue`跳过循环中的下一个项目。
- en: If the color is green and there is a corresponding drum sample loaded, we use
    the previously-defined `pymedia` wrapper method for playing audio to play that
    sample.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果颜色是绿色，并且已加载相应的鼓样本，我们使用之前定义的`pymedia`包装方法来播放音频播放该样本。
- en: Before moving to the next column the code is made to sleep for a small interval.
    If the code is not made to sleep for a small duration, the program would play
    all the samples at a very rapid succession.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在移动到下一列之前，代码被设置为暂停一小段时间。如果代码没有暂停一小段时间，程序会以非常快的速度连续播放所有样本。
- en: We have chosen to make the code sleep for a time period of one-eighth of a second.
    You can change this sleep time to vary the tempo.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择让代码暂停八分之一秒的时间。你可以改变这个暂停时间来调整节奏。
- en: Objective Complete – Mini Debriefing
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: In this iteration, we added the capability to play the loaded drum samples.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们添加了播放已加载鼓样本的功能。
- en: Our drum machine is now operational. You can load drum samples, define beat
    patterns, and when you click on the **Play** button, the drum machine plays that
    beat pattern!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐机现在可以正常工作了。你可以加载鼓样本，定义节拍模式，当你点击**播放**按钮时，音乐机就会播放那个节拍模式！
- en: Note
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this example, we decided whether or not to play a drum sample based on the
    color of the button. This has been used here for demonstration purposes. However,
    it is not a good practice to mix logic with appearance. A better idea would be
    to implement a data structure for buttons that would keep track of button state
    as "clicked" or "not-clicked", and then play the audio based on this button's
    state. Implementation of this dual button states is left as an exercise for you
    to explore.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们根据按钮的颜色来决定是否播放鼓样本。这在这里是为了演示目的。然而，将逻辑与外观混合并不是一个好的实践。更好的想法是为按钮实现一个数据结构，它可以跟踪按钮状态为“点击”或“未点击”，然后根据这个按钮的状态播放音频。实现这种双重按钮状态留给你作为练习去探索。
- en: Classified Intel
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分类英特尔
- en: In our previous code, we used `widget.cget()` to fetch the current value of
    the button's `bg` option to check if it is green. You can use `w.cget(key)` to
    return the current value of a widget option. Also, note that `cget()` always returns
    the value as a string even if you give a nonstring value when configuring the
    widget option.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的代码中，我们使用`widget.cget()`来获取按钮`bg`选项的当前值，以检查它是否为绿色。你可以使用`w.cget(key)`来返回小部件选项的当前值。另外，请注意，即使你在配置小部件选项时给出了非字符串值，`cget()`也总是以字符串的形式返回值。
- en: Similar to `widget.cget()`method, Tkinter offers a wide variety of methods for
    all its widgets. For a list of basic widget methods, refer to the *The basic widget
    methods* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与`widget.cget()`方法类似，Tkinter为所有小部件提供了各种各样的方法。有关基本小部件方法的列表，请参阅[附录B](apb.html
    "附录 B. 快速参考表")中的*基本小部件方法*部分，*快速参考表*。
- en: 'If you want to know all of the options configured for a particular widget,
    you may use the `widget.config()` method instead, as follows: (See the code in
    `3.06.py`)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道特定小部件配置的所有选项，你可以使用`widget.config()`方法，如下所示：（参见`3.06.py`中的代码）
- en: '[PRE21]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code will print a dictionary showing all the key-value pairs for widget
    options and their values listed as tuples. For example, in the preceding code
    the line `print widget.config(''bg'')` prints a tuple:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将打印一个字典，显示所有小部件选项及其值的元组列表。例如，在前面的代码中，`print widget.config('bg')`这一行打印了一个元组：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tkinter and threading
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter和线程
- en: Our drum machine plays patterns in the way that we want it to. However, there
    is a small problem. The `play` method blocks the main loop of our Tkinter program.
    It does not relinquish control back to the main loop until it is done playing
    all of the sound samples.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的鼓机以我们想要的方式播放模式。然而，有一个小问题。`play`方法阻塞了我们的Tkinter程序的主循环。它不会将控制权交还给主循环，直到播放完所有的声音样本。
- en: This means that if you now want to click on the **Stop** button or change some
    other widget, you will have to wait for the `play` loop to complete.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你现在想点击**停止**按钮或更改其他小部件，你必须等待`play`循环完成。
- en: You might have noticed that when you hit the **Play** button, it remains pressed
    for the time the sound loops are being played. During that time you cannot access
    any other widget in the Toplevel window.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当你点击**播放**按钮时，它会在声音循环播放的时间内保持按下状态。在这段时间内，你无法访问Toplevel窗口中的任何其他小部件。
- en: This clearly is a glitch. We need some method to confer back the control to
    Tkinter main loop while the play is still in progress.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个错误。在播放仍在进行时，我们需要一种方法将控制权交还给Tkinter主循环。
- en: Prepare for Lift Off
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: One of the simplest ways that we can achieve this is to use the `root.update()`method
    within our `play` loop. This updates the `root.mainloop()` method after each sound
    sample is played (see the commented code in `3.07.py`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现的 simplest 方法之一是在`play`循环中使用`root.update()`方法。这会在每个声音样本播放后更新`root.mainloop()`方法（参见`3.07.py`中的注释代码）。
- en: However, this is an inelegant method because the control is passed to the main
    loop with some staggering experienced in the GUI. Thus, you may experience a slight
    delay in responses of other widgets in the Toplevel.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个不太优雅的方法，因为控制权在GUI中传递时会有一些延迟。因此，你可能会在其他小部件的响应中体验到轻微的延迟。
- en: Further, if some other event causes the method to be called, it could result
    in a nested event loop.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果其他事件导致该方法被调用，可能会导致嵌套的事件循环。
- en: A better solution would be to run the `play` method from a separate thread.
    To do that let us employ the `threading` module of Python.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是从单独的线程中运行`play`方法。为此，让我们使用Python的`threading`模块。
- en: Engage Thrusters
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'Let us first import the `threading` module into our namespace (refer to the
    code in `3.07.py`):'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先在我们的命名空间中导入`threading`模块（参考`3.07.py`中的代码）：
- en: '[PRE23]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let us create a method that calls the `self.play()` method to run in a
    separate thread. This redirects `play` through the threading model:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个方法，它调用`self.play()`方法在单独的线程中运行。这通过线程模型重定向`play`：
- en: '[PRE24]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, change the `command` callback for the **Play** button in the `play_bar`
    method from the existing `self.play()` method to `self.play_in_thread()`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`play_bar`方法中**播放**按钮的`command`回调从现有的`self.play()`方法更改为`self.play_in_thread()`：
- en: '[PRE25]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now if you load some drum samples, define the beat patterns, and hit the **Play**
    button, the sound will play in a separate thread without preventing the main loop
    from updating (refer to the code in `3.07.py`).
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果你加载一些鼓样本，定义节拍模式，并点击**播放**按钮，声音将在单独的线程中播放，而不会阻止主循环更新（参考`3.07.py`中的代码）。
- en: 'The next step would be that of coding the **Stop** button. The role of the
    **Stop** button is simple; it merely stops the currently playing pattern. To do
    that, we first add a `command` callback to the **Stop** button calling on a method
    `stop_play` as follows (see the code in `3.07.py`):'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步将是编写**停止**按钮的代码。**停止**按钮的作用很简单；它只是停止当前正在播放的模式。为此，我们首先为**停止**按钮添加一个`command`回调，调用`stop_play`方法，如下所示（参见`3.07.py`中的代码）：
- en: '[PRE26]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then we define the `stop_play` method as follows:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义`stop_play`方法如下：
- en: '[PRE27]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our thread system now runs the `play` method from a separate thread. However,
    if the user clicks on the button more than once, this will spawn more threads,
    which will play the beat. To avoid this, the button should be configured with
    `state='disabled'`, and enabled again when the sequence finishes.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在从单独的线程中运行`play`方法。然而，如果用户多次点击按钮，这将产生更多的线程，播放节拍。为了避免这种情况，按钮应该配置为`state='disabled'`，并在序列完成后再次启用。
- en: 'To disable the **Play** button when the program starts running, we add the
    following line to our `play_in_thread` method (refer to the code in `3.07.py`):'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在程序开始运行时禁用**播放**按钮，我们在`play_in_thread`方法中添加以下行（参考`3.07.py`中的代码）：
- en: '[PRE28]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, when the sequence finishes playing or the **Stop** button is clicked,
    we want to enable the **Play** button again. To enable it, we add the following
    line to our `play` and `stop_play` methods:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，当序列播放完毕或点击**停止**按钮时，我们希望再次启用**播放**按钮。为了启用它，我们在`play`和`stop_play`方法中添加了以下行：
- en: '[PRE29]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Tkinter and thread safety**'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Tkinter和线程安全**'
- en: Tkinter is not thread safe. The Tkinter interpreter is valid only in the thread
    that runs the main loop. Any call to widgets must ideally be done from the thread
    that created the main loop. Invoking widget-specific commands from other threads
    is possible (as we do here), but is not reliable.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Tkinter不是线程安全的。Tkinter解释器仅在运行主循环的线程中有效。任何对小部件的调用理想情况下应该从创建主循环的线程中进行。从其他线程调用特定于小部件的命令是可能的（正如我们在这里所做的那样），但并不可靠。
- en: When you call a widget from another thread, the events get queued for the interpreter
    thread, which executes the command and passes the result back to the calling thread.
    If the main loop is running but not processing events, it sometimes results in
    unpredictable exceptions.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当从另一个线程调用小部件时，事件会被排队到解释器线程，该线程执行命令并将结果传回调用线程。如果主循环正在运行但未处理事件，有时会导致不可预测的异常。
- en: The only change we make to our existing `play` method is to include the entire
    code in a `try-except` block. We do this because Tkinter is not thread safe and
    can cause some unwanted exceptions when dealing with the `play` thread. The best
    we can do here is ignore those cases using a `try-except` block.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们对现有的`play`方法所做的唯一更改是将整个代码包含在一个`try-except`块中。我们这样做是因为Tkinter不是线程安全的，在处理`play`线程时可能会引起一些不希望的异常。我们能做的最好的事情就是使用`try-except`块忽略这些情况。
- en: Tip
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**mtTkinter – a thread-safe version of Tkinter**'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**mtTkinter – Tkinter的线程安全版本**'
- en: If you find yourself working on an inherently multithreaded project, you might
    consider looking at **mtTkinter** **—**a thread-safe version of Tkinter. For more
    information on mtTkinter, visit [http://Tkinter.unPythonic.net/wiki/mtTkinter](http://Tkinter.unPythonic.net/wiki/mtTkinter).
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您发现自己正在处理一个本质上多线程的项目，您可能需要考虑查看**mtTkinter** **—**Tkinter的线程安全版本。有关mtTkinter的更多信息，请访问[http://Tkinter.unPythonic.net/wiki/mtTkinter](http://Tkinter.unPythonic.net/wiki/mtTkinter)。
- en: For more specialized multiprocessing needs you may also want to take a look
    at *multiprocessing module* or an *event model* such as **Twisted**.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于更专业的多进程需求，您还可以查看*multiprocessing模块*或一个*事件模型*，如**Twisted**。
- en: The last step sees us code the **Loop** Checkbutton. The role of the **Loop**
    checkbox is simple. If the **Loop** checkbox is unchecked, the pattern plays only
    once. If it is checked, the pattern keeps playing in an endless loop. The pattern
    stops playing only if the **Loop** Checkbutton is unchecked or if the **Stop**
    button is pressed.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是编写**循环**复选框的代码。**循环**复选框的作用很简单。如果**循环**复选框未选中，则模式只播放一次。如果选中，模式将无限循环播放。只有当**循环**复选框未选中或按下**停止**按钮时，模式才会停止播放。
- en: 'We add a `command` callback to the **Loop** checkbox:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们向**循环**复选框添加了一个`command`回调：
- en: '[PRE30]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We then define the `loop_play` method as follows:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们随后定义了`loop_play`方法如下：
- en: '[PRE31]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Equipped with these two variables, we modify our `play` method to keep playing
    while `self.keep_playing` is equal to `True` see the code in `3.07.py`).
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 配备这两个变量，我们修改了`play`方法，使其在`self.keep_playing`等于`True`时继续播放（参见`3.07.py`中的代码）。
- en: If the value of `self.loop` is equal to `False`, we set the value of `self.keep_playing`
    equal to `False`, which breaks out of the play loop.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`self.loop`的值等于`False`，我们将`self.keep_playing`的值设置为`False`，从而跳出播放循环。
- en: Objective Complete – Mini Debriefing
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This completes the project iteration. In this round, we refined our `play` method
    to play the audio files from a separate thread.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了项目迭代。在本轮中，我们改进了`play`方法，使其能够在单独的线程中播放音频文件。
- en: We used Python's built-in threaded module to play the loops in separate thread.
    We looked at some of the threading-related limitations of Tkinter and some ways
    in which we can overcome those limitations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Python内置的线程模块在单独的线程中播放循环。我们研究了Tkinter的一些线程相关限制以及一些克服这些限制的方法。
- en: We also coded for the **Stop** button and **Loop** checkbox functionality.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还编写了**停止**按钮和**循环**复选框的功能。
- en: More beat patterns
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多节奏模式
- en: Our drum program is now functional. You can load drum samples and define a beat
    pattern and our drum machine will play it out. Let us now extend our drum program
    so that we are able to create more than one pattern in the same program.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的音乐鼓程序现在功能齐全。您可以加载鼓样本并定义一个节拍模式，我们的鼓机将播放它。现在让我们扩展我们的鼓程序，以便我们能够在同一个程序中创建多个模式。
- en: Rather than a single drum pattern, now we will have a list of patterns. While
    playing the patterns, a user will be able to switch between many different beat
    patterns. This will allow the drummer to add variations to the performance.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是单个鼓模式，现在我们将有一个模式列表。在播放模式时，用户将能够在许多不同的节拍模式之间切换。这将允许鼓手在表演中添加变化。
- en: Engage Thrusters
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: The first thing we need to do is add a Spinbox widget in the top bar (as shown
    in the following screenshot), which will keep count of the number of patterns.
    We also add an Entry widget next to the Spinbox widget to keep track of the pattern
    name, which is decided by the number selected in the spin box.![Engage Thrusters](img/7941_03_05.jpg)
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在顶部栏中添加一个Spinbox小部件（如下面的截图所示），它将记录模式数量。我们还在Spinbox小部件旁边添加了一个Entry小部件，以跟踪模式名称，该名称由在Spinbox中选择的数字决定。![启动推进器](img/7941_03_05.jpg)
- en: 'This is added to the `create_top_bar` method(refer to the code in `3.08.py`):'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这段代码被添加到`create_top_bar`方法中（参考`3.08.py`中的代码）:'
- en: '[PRE32]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The description of the code is listed as follows:'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The pattern number is stored in a Tkinter integer variable as `self.patt`.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式编号存储在Tkinter整数变量`self.patt`中。
- en: The Entry widget that stores the corresponding pattern name is called `self.pat_name`.
    This widget is marked as "read only", as we do not want to allow the user to modify
    the name.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储相应模式名称的Entry小部件称为`self.pat_name`。这个小部件被标记为“只读”，因为我们不希望允许用户修改名称。
- en: The Spinbox widget has a `command` callback to a new method `record_pattern`.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spinbox小部件有一个`command`回调到新的`record_pattern`方法。
- en: Let us now code the `record_pattern` method. The role of this method is to keep
    track of the state of a given pattern. Thus, for every pattern it needs to track
    the pattern number, units, BPU, drum samples loaded, and the beat pattern defined
    by the user for that pattern number. We will store this information in a list
    named `self.pattern_list`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来编写`record_pattern`方法。这个方法的作用是跟踪给定模式的状态。因此，对于每个模式，它需要跟踪模式编号、单元、BPU、加载的鼓样本以及用户为该模式编号定义的节拍模式。我们将这些信息存储在一个名为`self.pattern_list`的列表中。
- en: Our pattern spin box allows for adding 10 patterns. Therefore, we first initialize
    `self.pattern_list` as an empty list comprising of 10 empty spaces.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的图案Spinbox允许添加10个模式。因此，我们首先初始化`self.pattern_list`为一个包含10个空格的空列表。
- en: 'We initialize it in our class `__init__` method as follows (also seen in the
    code `3.08.py`):'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们在类的`__init__`方法中初始化它，如下所示（也见于`3.08.py`中的代码）:'
- en: '[PRE33]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let us now code the `record_pattern` method:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们来编写`record_pattern`方法：
- en: '[PRE34]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The description of the code is listed as follows:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The first line simply fetches the value of the current pattern number, bout,
    and units for the pattern to be recorded.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行简单地获取当前模式编号、bout和要记录的模式单元的值。
- en: The next four lines of this code do one simple job. For every change in pattern,
    it simply updates the corresponding Entry widget with the new name of the pattern.
    Since the Entry widget is "read only", we first configure its state as `normal`
    to allow us to enter text into the Entry widget. We then delete anything that
    might already be written in the widget and enter the new pattern name with the
    Python string formatting of `pattern_num'Pattern %s'%pattern_num`. Finally, we
    restore the entry widget to a `read only` state.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码的接下来的四行执行一个简单的任务。对于每个模式的变化，它只是将新的模式名称更新到相应的Entry小部件中。由于Entry小部件是“只读”的，我们首先将其状态配置为`normal`，以便我们可以在Entry小部件中输入文本。然后我们删除可能已经写入小部件中的任何内容，并使用Python字符串格式化`pattern_num'Pattern
    %s'%pattern_num`输入新的模式名称。最后，我们将entry小部件恢复到`read only`状态。
- en: The next two lines keep track of the last Spinbox widget number.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两行代码跟踪最后一个Spinbox小部件的编号。
- en: The next four lines of code actually record the state of the user-defined pattern
    in a two-dimensional list named `self.buttonpickleformat`. The list is first initialized
    to an empty two-dimensional matrix, taking into consideration the size of the
    pattern maker.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的四行代码实际上在名为`self.buttonpickleformat`的二维列表中记录用户定义模式的当前状态。该列表首先初始化为一个空的二维矩阵，考虑到模式制作器的尺寸。
- en: The loop then goes through every single button in the current pattern. If the
    button is not selected (not green), it leaves the value as `0`. If the button
    is selected (green), the value at the corresponding place is changed from `0`
    to `active`. Using this list we can then easily reproduce the user-defined pattern
    later on.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环接着遍历当前模式中的每个按钮。如果按钮未被选中（不是绿色），它将保留值为 `0`。如果按钮被选中（绿色），相应位置的值将从 `0` 更改为 `active`。使用这个列表，我们可以在以后轻松地重现用户定义的模式。
- en: 'Finally, all of this pattern-related data is stored as a list of the dictionary:
    `self.pattern_list[prevpval] = {''df'': self.widget_drum_file_name, ''bl'': self.buttonpickleformat,
    ''bpu'':bpu, ''units'':units}`'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最后，所有这些与模式相关的数据都存储为字典的列表：`self.pattern_list[prevpval] = {''df'': self.widget_drum_file_name,
    ''bl'': self.buttonpickleformat, ''bpu'':bpu, ''units'':units}`'
- en: The key `df` stores the list of drum filenames. The key `bl` stores the pattern
    defined by the button. The key `bpu` stores the BPU for that pattern, and the
    key `units` stores the units for that pattern.
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键 `df` 存储鼓文件名列表。键 `bl` 存储按钮定义的模式。键 `bpu` 存储该模式的 BPU，键 `units` 存储该模式的单位。
- en: Now that all of these items for a pattern are stored as a dictionary, we can
    easily use the dictionary to reconstruct the pattern. The last line calls the
    method `reconstruct_pattern()`, which actually does the reconstruction for us.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在所有这些与模式相关的项都已存储为字典，我们可以轻松地使用字典来重建模式。最后一行调用 `reconstruct_pattern()` 方法，它实际上为我们完成了重建。
- en: 'Now that we have stored pattern records, we need some method to reconstruct
    those patterns on our drum board. We define a new method `reconstruct_pattern`
    to handle it, as shown in the following code see the code in `3.08.py`):'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经存储了模式记录，我们需要一种方法在鼓板上重建这些模式。我们定义了一个新的方法 `reconstruct_pattern` 来处理它，如下所示（参见
    `3.08.py` 中的代码）：
- en: '[PRE35]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code can be broken into three broad parts:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码可以分为三个主要部分：
- en: Reconstructing drum sample uploads
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建鼓样本上传
- en: Reconstructing BPU and units
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建 BPU 和单位
- en: Reconstructing beat patterns
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建节拍模式
- en: 'Having reconstructed these three things, we can easily replay any beat pattern.
    A brief description of each of these is as follows:'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在重建了这三样东西之后，我们可以轻松地重放任何节拍模式。以下是对每个部分的简要描述：
- en: The list of drum filenames for a given pattern can easily be acquired from the
    key-value pair of the dictionary item `self.pattern_list[pattern_num]['df']`.
    We then iterate through items in this list and fill up the Entry widgets with
    each drum sample's filename.
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的模式，可以从字典项 `self.pattern_list[pattern_num]['df']` 的键值对中轻松获取鼓文件名列表。然后我们遍历这个列表，并用每个鼓样本的文件名填充条目小部件。
- en: We then fetch the value of BPU and units from the dictionary keys `self.pattern_list[pattern_num]['bpu']`
    and `self.pattern_list[pattern_num]['units']`. We insert these values in their
    respective Spinbox widgets and then call the `create_right_pad()` method, which
    places the desired number of buttons on the right pad.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们从字典键 `self.pattern_list[pattern_num]['bpu']` 和 `self.pattern_list[pattern_num]['units']`
    中获取 BPU 和单位的值。我们将这些值插入到相应的 Spinbox 小部件中，然后调用 `create_right_pad()` 方法，该方法在右侧面板上放置所需数量的按钮。
- en: In the last iteration, we fetch the value of dictionary key `self.pattern_list[pattern_num]['bl']`,
    which gives us the position of the green buttons. Iterating through a loop, we
    check if a particular button is to be set to `active`. If yes, we change the color
    of the button to green.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最后一次迭代中，我们获取字典键 `self.pattern_list[pattern_num]['bl']` 的值，它给出了绿色按钮的位置。通过循环迭代，我们检查是否需要将特定的按钮设置为
    `active`。如果是，我们改变按钮的颜色为绿色。
- en: Combined together, we can now load the previously recorded drum samples, set
    their **Units** and **BPU** values, and reconstruct the beat pattern as per previously
    set values.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合起来，我们现在可以加载之前记录的鼓样本，设置它们的**单位**和**BPU**值，并根据之前设置的值重建节拍模式。
- en: At each stage, the code checks if it cannot reconstruct a particular pattern
    because of invalid file markup. If it does find some invalid markup, it breaks
    out of the code using appropriate exception handling.
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个阶段，代码检查是否因为无效的文件标记而无法重建特定的模式。如果它发现一些无效的标记，它将使用适当的异常处理跳出代码。
- en: Hit the **Play** button and the drum machine will start rolling sound. Change
    the pattern number and define a new beat pattern. The new pattern will start playing.
    Revert to older patterns and the older patterns start playing again (refer to
    the code in `3.08.py`).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**播放**按钮，鼓机将开始播放声音。更改模式编号并定义一个新的节拍模式。新模式将开始播放。回到旧的模式，旧的模式将再次播放（参考 `3.08.py`
    中的代码）。
- en: Objective Complete – Mini Debriefing
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 - 简短总结
- en: We've completed coding our drum machine to support the storing of multiple beat
    patterns, and the ability to play these patterns simply by changing the pattern
    number. This gives the user the ability to make different beats for the intro,
    verse, chorus, bridge, and other parts of a song.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了代码编写，使鼓机支持存储多个节拍模式，并且只需更改模式编号即可播放这些模式。这使用户能够为歌曲的引子、副歌、桥段和其他部分制作不同的节奏。
- en: In the process, we saw how to use Python's built-in data types to store custom
    data and to reproduce them in any required way.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们看到了如何使用Python的内置数据类型来存储自定义数据，并以任何需要的方式重现它们。
- en: Object persistence
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象持久化
- en: In the preceding iteration, we added the capability to define multiple beat
    patterns. However, the beat patterns can be played only on a single script run.
    When the program is closed and restarted, all previous pattern data is lost.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的迭代中，我们添加了定义多个节拍模式的功能。然而，节拍模式只能在单个脚本运行时播放。当程序关闭并重新启动时，所有之前的模式数据都会丢失。
- en: We need a way to persist or store the beat patterns beyond a single program
    run. We need the ability to store values in some form of file storage and reload,
    play, and even edit the patterns. We need some form of object persistence.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来持久化或存储节拍模式，使其超出单个程序运行的范围。我们需要将值以某种形式存储在文件存储中，并重新加载、播放甚至编辑模式。我们需要某种形式的对象持久化。
- en: Prepare for Lift Off
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备起飞
- en: Python provides several modules for object persistence. The module that we will
    use for persistence is called the **pickle module**. This is a standard library
    of Python.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几个用于对象持久化的模块。我们将用于持久化的模块称为**pickle模块**。这是一个Python的标准库。
- en: An object represented as a string of bytes is called **pickle** in Python. **Pickling**
    , also known as **object serialization** , lets us convert our object into a string
    of bytes. The process reconstructing of the object back from the string of bytes
    is called **unpickling** or **deserialization**.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，表示为字节串的对象称为**pickle**。**Pickling**，也称为**对象序列化**，允许我们将我们的对象转换为字节串。从字节串重新构建对象的过程称为**unpickling**或**反序列化**。
- en: More information about the `pickle` module is available at [http://docs.python.org/2/library/pickle.html](http://docs.python.org/2/library/pickle.html).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`pickle`模块的更多信息可在[http://docs.python.org/2/library/pickle.html](http://docs.python.org/2/library/pickle.html)找到。
- en: 'Let us illustrate it with a simple example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来说明：
- en: '[PRE36]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, we serialize or pickle our list `PartyMenu` using `pickle.dump` and save
    it in an external file `mymenu.p`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`pickle.dump`序列化或pickle我们的列表`PartyMenu`，并将其保存到外部文件`mymenu.p`中。
- en: 'We later retrieve the object using `pickle.load`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后使用`pickle.load`检索对象：
- en: '[PRE37]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Remember that in our previous iteration, we created a list, called `self.pattern_list`,
    where each item of the list is a dictionary that stores information about one
    single beat pattern.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在我们之前的迭代中，我们创建了一个列表，称为`self.pattern_list`，其中列表的每个项目都是一个字典，用于存储关于单个节拍模式的详细信息。
- en: If we need to reuse this information, we only need to pickle this `self.pattern_list`.
    Having saved the object, we can later easily unpickle the file to reconstruct
    our beat patterns.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要重用这些信息，我们只需要pickle这个`self.pattern_list`。保存了对象之后，我们稍后可以轻松地反pickle文件来重建我们的节拍模式。
- en: Engage Thrusters
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: We first need to add three top menu items to our program, as shown in the following
    screenshot:![Engage Thrusters](img/7941_03_06.jpg)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先需要向我们的程序中添加三个顶级菜单项，如下面的截图所示：![Engage Thrusters](img/7941_03_06.jpg)
- en: '**File** | **Load Project**'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件** | **加载项目**'
- en: '**File** | **Save Project**'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件** | **保存项目**'
- en: '**File** | **Exit**'
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件** | **退出**'
- en: 'While we are creating our menu items let us also add an **About** menu item:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们创建菜单项时，让我们也添加一个**关于**菜单项：
- en: '**About** | **About**'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关于** | **关于**'
- en: 'Here, we are particularly interested in saving the project (pickling), and
    loading the project back (unpickling). The code for menu items is defined in a
    separate method called `create_top_menu`, as shown in the following code (also
    refer to the code in `3.09.py`):'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们特别关注保存项目（pickle）和加载项目回（unpickle）。菜单项的代码定义在名为`create_top_menu`的单独方法中，如下面的代码所示（也请参阅`3.09.py`中的代码）：
- en: '[PRE38]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The code is self-explanatory. We have created similar menu items in our last
    two projects. Finally, to display this menu, we call this method from our `Main`
    method.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码是自我解释的。我们在过去两个项目中创建了类似的菜单项。最后，为了显示这个菜单，我们从`Main`方法中调用这个方法。
- en: 'To pickle our object, we first import the `pickle` module into the current
    namespace as follows (see the code in `3.09.py`):'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要序列化我们的对象，我们首先将`pickle`模块导入当前命名空间，如下所示（参见`3.09.py`中的代码）：
- en: '[PRE39]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The **Save Project** menu has a `command` callback attached to `self.save_project`,
    which is where we define the pickling process:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**保存项目**菜单有一个`command`回调函数附加到`self.save_project`，这是我们定义序列化过程的地方：'
- en: '[PRE40]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The description of the code is listed as follows:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: Recall that a pattern is added to `self.pattern_list` only when the pattern
    number is changed by the user. In situations where a user might have defined a
    beat pattern but may not have clicked on the pattern number's Spinbox widget,
    the pattern is not included in `self.pattern_list`. To make sure it is added,
    we first call `self.record_pattern` to capture this beat pattern.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回想一下，只有在用户更改模式编号时，模式才会添加到`self.pattern_list`中。在用户可能已经定义了打击模式但可能没有点击模式编号的Spinbox小部件的情况下，该模式不会包含在`self.pattern_list`中。为了确保它被添加，我们首先调用`self.record_pattern`来捕获这个打击模式。
- en: The `save_project` method is called when the user clicks on the **Save Project**
    menu, hence, we need to give the user an option to save the project in a file.
    We have chosen to define a new file extension (`.bt`) to keep track of our beat
    patterns.
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击**保存项目**菜单时，会调用`save_project`方法，因此我们需要给用户一个选项将项目保存到文件中。我们选择定义一个新的文件扩展名（`.bt`）来跟踪我们的打击模式。
- en: When the user specifies the filename with `.bt` extension, the data in the `self.pattern_list`
    object is dumped into the file using `pickle.dump`.
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户指定具有`.bt`扩展名的文件名时，使用`pickle.dump`将`self.pattern_list`对象中的数据写入文件。
- en: Lastly, the title of the Toplevel window is changed to reflect the filename.
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将Toplevel窗口的标题更改以反映文件名。
- en: We are done pickling the object. Let us now code the unpickling process.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成了对象的序列化。现在让我们编写反序列化过程。
- en: 'The unpickling process is handled by a method `load_project`, which is called
    from the **Load Project** menu as follows:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反序列化过程由一个名为`load_project`的方法处理，该方法从**加载项目**菜单调用如下：
- en: '[PRE41]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The description of the code is listed as follows:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: When a user clicks on the **Load Project** menu, the first line of the method
    prompts him/her with an **Open File** window. When the user specifies a previously
    pickled file with a `.bt` extension, the filename is stored in a variable called
    `file_name`.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击**加载项目**菜单时，方法的第一行会弹出一个**打开文件**窗口。当用户指定一个具有`.bt`扩展名的已保存文件时，文件名被存储在一个名为`file_name`的变量中。
- en: If the filename returned is `none` because the user cancels the **Open File**
    dialog, nothing is done.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回的文件名为`none`，因为用户取消了**打开文件**对话框，则不执行任何操作。
- en: If filename is supplied, the title of the Toplevel window is changed to add
    the filename. The file is then opened in read mode, and the contents of the file
    are read into `self.pattern_list` using `pickle.load`.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果提供了文件名，Toplevel窗口的标题会更改以添加文件名。然后以读取模式打开文件，并将文件内容读取到`self.pattern_list`中，使用`pickle.load`。
- en: The `self.pattern_list` now contains the list of beat patterns defined in the
    previous pickle. The file is closed and the first pattern of `self.pattern_list`
    is reconstructed in the drum machine. If there are more than one patterns defined
    in the serialized file, you can view each of the patterns simply by changing the
    pattern number Spinbox widget.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.pattern_list`现在包含了之前序列化中定义的打击模式列表。文件被关闭，`self.pattern_list`中的第一个模式在鼓机中重建。如果在序列化文件中定义了多个模式，你可以通过更改模式编号的Spinbox小部件来查看每个模式。'
- en: Try playing any of the patterns, and you should be able to replay the pattern
    exactly as it was defined at the time of pickling.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试播放任何模式，你应该能够精确地回放该模式，就像在保存时定义的那样。
- en: Tip
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Pickling, though great for serialization, is vulnerable to malicious or erroneous
    data. You may want to use pickle only if the data is from a trusted source, or
    if proper validation mechanisms are in place.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然序列化很棒，但序列化（pickle）容易受到恶意或错误数据的影响。你可能只想在数据来自可信来源或设置了适当的验证机制时使用pickle。
- en: You may also find the `json` module useful for serializing objects in **JSON**
    and **ElementTree** , or **xml.minidom** libraries relevant for parsing XML data.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你也可能发现`json`模块对于序列化**JSON**和**ElementTree**对象很有用，或者对于解析XML数据的**xml.minidom**库相关。
- en: 'Now, let us complete coding our `exit` and `about` commands:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们完成我们的`exit`和`about`命令的编码：
- en: '[PRE42]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And add this line to our `app` method to override the **Close** button of the
    Toplevel window:'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并将此行添加到我们的`app`方法中，以覆盖Toplevel窗口的**关闭**按钮：
- en: '[PRE43]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is self-explanatory. We have done similar coding in our previous project.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一点不言自明。我们在之前的项目中已经进行了类似的编码。
- en: Objective Complete – Mini Debriefing
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: In this iteration, we used Python's built-in `pickle` module to pickle and unpickle
    the beat patterns defined by the user.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次迭代中，我们使用了 Python 内置的 `pickle` 模块来序列化和反序列化用户定义的节奏模式。
- en: This now lets us save patterns defined by the user. We have also provided the
    ability to load, replay, and edit the project later.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在使我们能够保存用户定义的模式。我们还提供了加载、回放和编辑项目的功能。
- en: Now, if you define one or more beat patterns in your program you can save the
    project with a `.bt` file extension. You can later load the project and start
    working on it from the place where you had last left it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在程序中定义了一个或多个节奏模式，你可以使用 `.bt` 文件扩展名保存项目。你可以在以后加载项目，并从你上次停止的地方开始工作。
- en: While we were dealing with the top menu we also completed the code for the **About**
    and **Exit** menu items.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理顶部菜单的同时，我们也完成了 **关于** 和 **退出** 菜单项的代码。
- en: ttk-themed widgets
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ttk 主题小部件
- en: We are almost done programming our drum machine. However, we would like to end
    this project by introducing you to the ttk-themed widgets.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了鼓机的编程。然而，我们希望通过介绍 ttk 主题小部件来结束这个项目。
- en: Prepare for Lift Off
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备发射升空
- en: On many platforms such as Windows and X11, Tkinter does not bind to the native
    platform widgets. The Tk toolkit (and Tkinter) originally appeared on X-Window
    systems, hence, it adopted the motif look and feel, which was the de facto standard
    for GUI development on X-Window systems. When Tk was ported to other platforms,
    such as Windows and Mac OS, this Motif style started appearing out of place with
    the look of these platforms.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多平台如 Windows 和 X11 上，Tkinter 并未绑定到本地平台小部件。Tk 工具包（以及 Tkinter）最初出现在 X-Window
    系统上，因此，它采用了 Motif 风格，这是 X-Window 系统上 GUI 开发的既定标准。当 Tk 被移植到其他平台，如 Windows 和 Mac
    OS 时，这种 Motif 风格开始与这些平台的外观格格不入。
- en: Due to this, some even argue that Tkinter widgets are rather ugly and do not
    integrate well with such desktop environments.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，有些人甚至认为 Tkinter 小部件相当丑陋，并且与这样的桌面环境不太融合。
- en: Another criticism of Tkinter is based on the fact that Tkinter mixes logic and
    styling by allowing both to be changed as widget options.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 的另一个批评基于这样一个事实：Tkinter 允许通过将逻辑和样式作为小部件选项来更改，从而将逻辑和样式混合在一起。
- en: It was also criticized to lack any kind of theming support. While we saw an
    example of centralized styling via the option database, the method required styling
    to be done at the widget level. It does not allow for selective styling of two
    button widgets differently, as an example. This made it difficult for developers
    to implement visual consistency for similar groups of widgets while differentiating
    them from other groups of widgets. As a result of this, many GUI developers moved
    to Tkinter alternatives such as **wxPython** , **glade** , **PyQT** , and others.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 它还被批评缺乏任何类型的主题支持。虽然我们通过选项数据库看到了集中式样式的示例，但这种方法要求在组件级别进行样式设置。例如，它不允许对两个按钮组件进行不同的选择性样式设置。这使得开发者在实现类似组的小部件的视觉一致性时区分它们与其他组的小部件变得困难。因此，许多
    GUI 开发者转向了 Tkinter 的替代品，如 **wxPython**、**glade**、**PyQT** 等。
- en: With Tkinter 8.5, the makers of Tkinter have tried to address all these concerns
    by introducing the `ttk` module, which may be considered as an advance to the
    original Tkinter module.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Tkinter 8.5 中，Tkinter 的制作者通过引入 `ttk` 模块来尝试解决所有这些担忧，`ttk` 模块可以被视为对原始 Tkinter
    模块的一种改进。
- en: Let us take a look at some of the features offered by the ttk-themed widgets
    module.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 ttk 主题小部件模块提供的某些功能。
- en: One of the first things that `ttk` does is that it provides a set of built-in
    themes that allows Tk widgets to look like the native desktop environment in which
    the application is running.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`ttk` 做的第一件事是提供一组内置主题，允许 Tk 小部件看起来像应用程序正在运行的本地桌面环境。'
- en: 'Additionally, it introduces six new widgets: Combobox, Notebook, Progressbar,
    Separator, Sizegrip, and Treeview to the list of widgets, in addition to supporting
    11 core Tkinter widgets, which are Button, Checkbutton, Entry, Frame, Label, LabelFrame,
    Menubutton, PanedWindow, Radiobutton, Scale, and Scrollbar.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还引入了六个新的小部件：Combobox、Notebook、Progressbar、Separator、Sizegrip 和 Treeview，并将它们添加到小部件列表中，同时支持
    11 个核心 Tkinter 小部件，包括 Button、Checkbutton、Entry、Frame、Label、LabelFrame、Menubutton、PanedWindow、Radiobutton、Scale
    和 Scrollbar。
- en: 'To use the `ttk` module, we first import it into the current namespace:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `ttk` 模块，我们首先将其导入当前命名空间：
- en: '[PRE44]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can display the `ttk` widgets as follows see the code in `3.10.py`):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按如下方式显示 `ttk` 小部件（参见 `3.10.py` 中的代码）：
- en: '[PRE45]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For a comparison of displays between the normal Tkinter widgets and the counterpart
    ttk widgets, see the code in `3.10.py`, which produces a window, as shown in the
    following screenshot. Notice how the widgets look like more native widgets on
    your platform.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较正常Tkinter小部件和对应 ttk 小部件之间的显示效果，请参阅 `3.10.py` 中的代码，该代码生成一个窗口，如下面的截图所示。注意小部件在你的平台上看起来如何更像本地小部件。
- en: '![Prepare for Lift Off](img/7941_03_07.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_03_07.jpg)'
- en: '`3.10.py` also shows dummy examples of all the new widgets introduced in the
    `ttk` module.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`3.10.py` 还展示了 `ttk` 模块中引入的所有新小部件的示例。'
- en: Tip
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can even override the basic Tkinter widgets by importing `ttk` after `Tkinter`
    as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过以下方式在导入 `Tkinter` 之后导入 `ttk` 来覆盖基本 Tkinter 小部件：
- en: '[PRE46]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This causes all widgets common to Tk and ttk to be replaced by ttk widgets.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致所有属于 Tk 和 ttk 的公共小部件都被 ttk 小部件替换。
- en: This has the direct benefit of using the new widgets, which gives a better look
    and feel across platforms.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接的好处是使用新小部件，这为跨平台提供了更好的外观和感觉。
- en: However, the disadvantage of this kind of import, is that you cannot distinguish
    the module from which the widget classes are imported. This is important because
    `Tkinter` and `ttk` widget classes are not completely interchangeable. In this
    case, an unambiguous solution is to import them, as shown in the following codeimport
    Tkinter as tk
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种导入方式的缺点是，你无法区分小部件类是从哪个模块导入的。这很重要，因为 `Tkinter` 和 `ttk` 小部件类并不完全可互换。在这种情况下，一个明确的解决方案是按照以下代码导入它们：`import
    Tkinter as tk`
- en: '[PRE47]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While most of the configuration options for Tkinter and ttk widgets are common,
    ttk-themed widgets do not support styling options such as `fg`, `bg`, `relief`,
    `border`, and more. This is purposefully removed from ttk in an attempt to keep
    logic and styling in different controls.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Tkinter和 ttk 小部件的大多数配置选项都是通用的，但 ttk 主题小部件不支持 `fg`、`bg`、`relief`、`border` 等样式选项。这是故意从
    ttk 中移除的，以尝试将逻辑和样式分开。
- en: Instead, all styling-related options are handled by the respective style names.
    In a standard `ttk` module, each widget has an associated style name. You can
    retrieve the default style name of a widget using the `widget.winfo_class()` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，所有与样式相关的选项都由相应的样式名称处理。在标准的 `ttk` 模块中，每个小部件都有一个关联的样式名称。你可以使用 `widget.winfo_class()`
    方法检索小部件的默认样式名称。
- en: 'For instance consider a ttk button:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个 ttk 按钮：
- en: '[PRE48]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This prints **Tbutton**, which is the default style name for `ttk.Button`. For
    a list of default ttk style names for different widgets, refer to the *The ttk
    widgets* section in [Appendix B](apb.html "Appendix B. Quick Reference Sheets"),
    *Quick Reference Sheets*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出 **Tbutton**，这是 `ttk.Button` 的默认样式名称。有关不同小部件的默认 ttk 样式名称列表，请参阅 [附录 B](apb.html
    "附录 B. 快速参考表") 中的 *The ttk widgets* 部分，*快速参考表*。
- en: 'In addition to the default style, you can assign a custom style class to a
    widget or group of widgets. To set up a new style you use:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认样式外，你还可以将自定义样式类分配给小部件或小部件组。要设置新样式，请使用以下命令：
- en: '[PRE49]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To configure the style options for a default style, you use the command:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置默认样式的样式选项，请使用以下命令：
- en: '[PRE50]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To use the new style on a widget you use the command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要在某个小部件上使用新样式，请使用以下命令：
- en: '[PRE51]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next we will discuss about ttk theming.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论 ttk 主题。
- en: 'Style is used to control the appearance for individual widgets. Themes, on
    the other hand, control the appearance of the entire GUI. More simply put, a theme
    is a collection of styles. Grouping styles into themes lets the user switch designs
    for the entire GUI all at once. Like styles, all themes are uniquely identified
    by their name. The list of available themes can be obtained as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 样式用于控制单个小部件的外观。另一方面，主题控制整个 GUI 的外观。更简单地说，主题是一组样式的集合。将样式分组到主题中允许用户一次性切换整个 GUI
    的设计。像样式一样，所有主题都通过它们的名称唯一标识。可以通过以下方式获取可用主题的列表：
- en: '[PRE52]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To obtain the name of the currently active theme:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前活动主题的名称：
- en: '[PRE53]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can change to another theme using:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令切换到另一个主题：
- en: '[PRE54]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let us see various styling- and theming-related options of ttk through a dummy
    example (refer to the code in `3.11.py`, which produces a window like the one
    shown in the following screenshot):'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例（参考 `3.11.py` 中的代码，该代码生成如下截图所示的窗口）来查看 ttk 的各种样式和主题相关选项：
- en: '![Prepare for Lift Off](img/7941_03_08.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![准备起飞](img/7941_03_08.jpg)'
- en: '[PRE55]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The description of the code is listed as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下列所示：
- en: The first three lines of code imports `Tkinter` and `ttk,` and sets up a new
    root window.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的前三行导入`Tkinter`和`ttk`，并设置一个新的根窗口。
- en: The next line `x = ttk.Style()` is where you give a name `x` to your style.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行`x = ttk.Style()`是您为您的样式赋予名称`x`的地方。
- en: The next line configures a program-wide style configuration using `x.configure`.
    The dot character (`.`), which is the first argument of `configure`, means that
    this style would apply to the Toplevel window and to all its child elements. This
    is the reason why all of our widgets get to have a yellow background.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行使用`x.configure`配置了一个程序范围内的样式配置。配置的第一个参数点字符（`.`）表示此样式将应用于Toplevel窗口及其所有子元素。这就是为什么所有我们的小部件都得到了黄色的背景。
- en: The next line creates an extension (`danger`) to the default style (`TButton`).
    This is how you create custom styles, which are variations to a base default style.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行创建了一个默认样式（`TButton`）的扩展（`danger`）。这就是创建自定义样式的方法，它是基于基本默认样式的变体。
- en: The next line creates a `ttk.label` widget. Since we have not specified any
    style for this widget, it inherits the global style specified for the Toplevel
    window.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行创建了一个`ttk.label`小部件。由于我们没有为这个小部件指定任何样式，它继承了为Toplevel窗口指定的全局样式。
- en: The next line creates a `ttk.button` widget and specifies it to be styled using
    our custom style definition of `'danger.TButton.'` This is why the foreground
    color of this button turns red. Notice how it still inherits the background color,
    yellow ,from the global Toplevel style that we defined earlier.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行创建一个`ttk.button`小部件，并指定它使用我们自定义的样式定义`'danger.TButton.'`。这就是为什么这个按钮的前景色变成了红色。注意，它仍然继承了我们在之前定义的全局Toplevel样式的背景颜色，黄色。
- en: The next two lines of code demonstrate how ttk allows for styling different
    widget states. In this example we styled different states for a `ttk.button` widget
    to display in different colors. Go ahead and click on this second button to see
    how different styles apply to different states of a button. Here we use `map(style,
    query_options, **kw)` to specify dynamic values of style for changes in state
    of the widget.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一两行代码演示了ttk如何允许对不同的小部件状态进行样式化。在这个例子中，我们对一个`ttk.button`小部件的不同状态进行了样式化，以显示不同的颜色。请点击这个第二个按钮，看看不同的样式如何应用于按钮的不同状态。在这里，我们使用`map(style,
    query_options, **kw)`来指定小部件状态变化时的动态样式值。
- en: 'The next line fetches the current applicable theme. It then overrides some
    of the options for the theme''s Entry widget using:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行获取当前适用的主题。然后使用以下方式覆盖主题的Entry小部件的一些选项：
- en: '[PRE56]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now that we know how to make our widgets look more like native platform widgets,
    let us change the **Play** and **Stop** buttons for our drum machine to `ttk.button`.
    Let us also change the **Loop** check button from Tkinter Checkbutton to ttk Checkbutton.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使我们的小部件看起来更像原生平台小部件，让我们将鼓机的**播放**和**停止**按钮从Tkinter Checkbutton更改为`ttk.button`。同时，也将**循环**复选按钮从Tkinter
    Checkbutton更改为ttk Checkbutton。
- en: Engage Thrusters
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动推进器
- en: 'We first import `ttk` into our namespace and append `ttk` to the `play` and
    `stop` buttons as follows (see the code in `3.12.py`):'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将`ttk`导入我们的命名空间，并将`ttk`附加到`play`和`stop`按钮上，如下所示（参见`3.12.py`中的代码）：
- en: '[PRE57]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We then simply modify the buttons and check button in the `create_play_bar`
    method as follows:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们简单地修改`create_play_bar`方法中的按钮和复选按钮，如下所示：
- en: '[PRE58]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that these changes make the button and checkbutton look closer to the native
    widgets of your working platform.
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这些更改使按钮和复选按钮看起来更接近您工作平台的原生小部件。
- en: Also, note that we cannot modify the Tkinter buttons that we have used in our
    pattern editor. This is because our code extensively plays on the button's background
    color to decide logic. The ttk buttons do not have the configurable `bg` option,
    hence, cannot be used for buttons in our right drum pad.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请注意，我们无法修改我们在模式编辑器中使用的Tkinter按钮。这是因为我们的代码大量使用按钮的背景颜色来决定逻辑。ttk按钮没有可配置的`bg`选项，因此不能用于我们的右侧鼓垫按钮。
- en: 'As a quick ending exercise let us add an image in the right-hand side of the
    play bar. Let us also add an icon for our Toplevel window (refer to the code in
    `3.12.py`):'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为快速结束练习，让我们在播放条的右侧添加一个图像。同时，也添加一个Toplevel窗口的图标（参见`3.12.py`中的代码）：
- en: 'To add an image we add this to our `create_play_bar` method:'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要添加图像，我们将以下内容添加到`create_play_bar`方法中：
- en: '[PRE59]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To add a Toplevel icon, we add the following line to our `Main` method:'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要添加一个顶层图标，我们在`Main`方法中添加以下行：
- en: '[PRE60]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Objective Complete – Mini Debriefing
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标完成 – 简短总结
- en: This concludes the last iteration of this project. In this iteration, we first
    saw how and why to use ttk-themed widgets to improve the look and feel of our
    programs.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着这个项目的最后迭代。在这个迭代中，我们首先了解了如何以及为什么使用 ttk 主题小部件来改善我们程序的外观和感觉。
- en: We then used ttk buttons and ttk checkbuttons in our drum program to improve
    its look. We also saw the reasons why certain Tkinter buttons in our program could
    not be replaced by ttk buttons.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在鼓程序中使用了 ttk 按钮和 ttk 复选框按钮来改善其外观。我们还了解了为什么我们程序中的某些Tkinter按钮不能被 ttk按钮替换。
- en: Mission Accomplished
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务完成
- en: We have come a long way in our experiments with Tkinter. In this project we
    made a highly-functional drum machine with loads of features.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter的实验中我们已经走了很长的路。在这个项目中，我们制作了一个功能强大的鼓机，拥有众多特性。
- en: In the process, we touched upon several vital concepts that go into the making
    of a GUI program with Tkinter.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们触及了构建Tkinter GUI程序所需的一些关键概念。
- en: 'To summarize, we touched upon the following vital concepts of Tkinter-based
    GUI programs:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们探讨了Tkinter基于GUI程序的关键概念：
- en: Structuring Tkinter program as classes and objects
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Tkinter程序作为类和对象来构建
- en: Working with more Tkinter widgets such as Spinbox, Button, Entry, and Checkbutton
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Tkinter的Spinbox、Button、Entry和Checkbutton等小部件一起工作
- en: Using the `grid` geometry manager for structuring complex layout
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`grid`布局管理器来构建复杂的布局
- en: Understanding threaded programming in relation to Tkinter
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解与Tkinter相关的线程编程
- en: Working with other common modules from the Python standard library
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Python标准库中的其他常见模块一起工作
- en: Object persistence with the `pickle` module
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pickle`模块实现对象持久化
- en: Working with ttk-themed widgets
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 ttk 主题小部件一起工作
- en: A Hotshot Challenge
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热身挑战
- en: 'The drum machine needs your attention. As a part of your Hotshot challenge,
    add the following features to your drum machine:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓机需要你的关注。作为你的热身挑战的一部分，请向你的鼓机添加以下功能：
- en: The current application checks if the button is green in color to decide whether
    the button is in the pressed state. Modify the code so that this logic is not
    decided based on the color of the button, but by a separate variable that keeps
    track of the selected buttons.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序检查按钮是否为绿色来决定按钮是否处于按下状态。修改代码，使这种逻辑不是基于按钮的颜色，而是通过一个单独的变量来跟踪选中的按钮。
- en: Add a tempo scale to your drum machine, which lets the user change the tempo
    of the beats using a slider.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的鼓机中添加一个节拍速度刻度，用户可以使用滑块来改变节拍的速度。
- en: Add volume control for each drum sample, allowing the user to change the volume
    individually for each drum sample.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个鼓样本添加音量控制，允许用户分别调整每个鼓样本的音量。
- en: Add a mute button for each drum sample. If the Checkbutton is clicked for a
    given drum sample, the sound is not played for that row. This way, a user can
    stop a complete row from playing without changing the patterns in that row.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个鼓样本添加一个静音按钮。如果用户点击了某个鼓样本的Checkbutton，则该行的声音将不会播放。这样，用户可以停止整行播放，而无需更改该行的模式。
- en: Add a time clock to your drum machine, which displays the time elapsed since
    the last press of the play button.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的鼓机中添加一个计时器，显示自上次按下播放按钮以来经过的时间。
