<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Deployment</h1></div></div></div><p>Our final chapter will explain in the first section how to configure CherryPy-based applications, and then review different methods to deploy such an application through the use of Apache and lighttpd. Finally, we will review how to make your CherryPy-based application SSL enabled via the built-in CherryPy HTTP server, as well as by using Apache and lighttpd capabilities.<a id="id317" class="indexterm"/>
</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec01"/>Configuration</h1></div></div></div><p>While developing an application, you always need to parameterize it, so that it can be tuned as per the requirements of the hosting environment. For instance, the type of database used, PostgreSQL or MySQL, the directory in which the application resides, administrator contacts, etc.<a id="id318" class="indexterm"/>
</p><p>There are different levels of configuration settings required in a web application like our photoblog:</p><div><ul class="itemizedlist"><li class="listitem"><p>Web server: Settings linked to the HTTP server</p></li><li class="listitem"><p>Engine: Settings associated with the engine hosting the application</p></li><li class="listitem"><p>Application: Settings our application will use</p></li></ul></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec01"/>CherryPy—Web and Engine Configuration System</h2></div></div></div><p>Since our application is using CherryPy, we will use the CherryPy configuration capabilities for the web server and the engine. CherryPy uses a configuration based on the syntax of the INI format defined by Microsoft.<a id="id319" class="indexterm"/>
</p><p>The format of a CherryPy configuration file is as follows:</p><div><pre class="programlisting">[section]
key = value
</pre></div><p>The main difference between the original INI format and the format used by CherryPy is the fact that values in the latter case are Python data types. For example:</p><div><pre class="programlisting">[global]
server.socket_host = "localhost"
server.socket_port = 8080
</pre></div><p>With the exception of<code class="literal"> [global]</code>, the sections of configuration files match a requested URI path segment, as illustrated in the following example:</p><div><pre class="programlisting">[/css/style.css]
tools.staticfile.on = True
tools.staticfile.file = "app.css"
tools.staticfile.root = "/var/www/photoblog/design/default/css"
</pre></div><p>When CherryPy tries to match the<code class="literal"> /css/style.css</code> request, it will inspect the configuration settings for a matching section. If found, it will use the settings defined for that section.<a id="id320" class="indexterm"/>
</p><p>Before we explain how CherryPy differentiates between the web server and the engine settings, let's see how the configuration settings can be defined in a Python dictionary instead. The following code snippet demonstrates the same settings:</p><div><pre class="programlisting">{'/css/style.css': {'tools.staticfile.on': True,
'tools.staticfilE.file': "app.css" 'tools.staticfile.root':
"/var/www/photoblog/design/default/css"}}
</pre></div><p>Functionally, both methods will provide the same capabilities. Using a Python dictionary offers the advantage of residing within the code itself, and thus allows for more complex data types to be provided as values. Eventually, it is usually a matter of taste between the two options.<a id="id321" class="indexterm"/>
</p><p>Now that we have presented how to declare configuration settings, let's see how to pass them to their components. CherryPy API is quite straight forward in that respect:</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">cherrypy.config.update</code> (file or dictionary) is used to configure the CherryPy web server.</p></li><li class="listitem"><p>
<code class="literal">cherrypy.tree.mount</code> (app, config file, or dictionary) is used to provide the settings for the mounted application.</p></li><li class="listitem"><p>The<code class="literal"> _cp_config</code> attribute is bound to the page handlers, or to the class containing the page handlers and calls a controller defined as a dictionary (in which case, the settings are propagated by CherryPy to all the page handlers of that controller). It is used to pass the settings directly to where they will be needed.</p></li></ul></div><p>We will review an example to understand how to use that API in our context:</p><div><pre class="programlisting">import cherrypy
class Root:
@cherrypy.expose
def echo(self, some):
repeat = cherrypy.request.config.get('repeat', 1)
return some * repeat
echo._cp_config = {'repeat': 3}
if __name__ == '__main__':
http_conf = {'global': {'environment': 'production',
'server.socket_port': 9090,
'log.screen': True,
'log.error_file': 'error.log',
'log.access_file': 'access.log'}}
cherrypy.config.update(http_conf)
app0_conf = {'/echo': {'tools.response_headers.on': True,
'tools.response_headers.headers':
('Content-Type', 'text/plain')]}}
cherrypy.tree.mount(Root(), script_name='/app0',
config=app0_conf)
app1_conf = {'/echo': {'tools.gzip.on': True,
'repeat': 2}}
cherrypy.tree.mount(Root(), script_name='/app1',
config=app1_conf)
cherrypy.server.quickstart()
cherrypy.engine.start()
</pre></div><p>Let's see what we have done in our example:</p><div><ol class="orderedlist"><li class="listitem"><p>1. First we declare an application with a page handler named<code class="literal"> echo</code>. The purpose of this handler is to return the request body and repeat it as many times as defined by the configuration setting key<code class="literal"> repeat</code>. To do so, we use the<code class="literal"> _cp_config</code> attribute bound to the page handler. This value can also be passed from the main configuration dictionary. In that case, the value coming from the main dictionary takes precedence over the<code class="literal"> _cp_config</code> attribute.</p></li><li class="listitem"><p>2. Next we declare the web server settings in a dictionary and then we call<code class="literal"> cherrypy.config.update()</code> with that dictionary. Note that the use of the key, named global, is not compulsory when using a dictionary. CherryPy does interpret it exactly the same way; so the semantic equivalent of the previous example can be written as follows:</p><div><pre class="programlisting">http_conf = {'environment': 'production',
'server.socket_port': 9090,
'log.screen': True,
'log.error_file': 'error.log',
'log.access_file': 'access.log'}
cherrypy.config.update(http_conf)
</pre></div></li><li class="listitem"><p>3. Finally we mount two applications on two distinct prefixes with two different configuration settings. It is important to notice that the key we use is the path to the page handler relatively to where the application is mounted. That is why we use<code class="literal"> /echo</code>, and neither<code class="literal"> /app0/echo</code> nor<code class="literal"> /app1/echo</code>. This also means that configuration settings do not leak across mounted applications. CherryPy makes sure that each application receives only the settings it was declared with.<a id="id322" class="indexterm"/>
</p></li></ol></div><div><h3 class="title"><a id="note28"/>Note</h3><p>It is a common mistake to pass configuration settings associated with the application to the<code class="literal"> cherrypy.config.update()</code> method. This will not propagate the settings to the mounted application. You must use the<code class="literal"> config</code> attribute of<code class="literal"> cherrypy.tree.mount()</code> to get the expected behavior.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec02"/>Photoblog Application Configuration System</h2></div></div></div><p>Configuration settings of an application will not usually be passed through the CherryPy configuration system, which is at a lower level. An application would usually define entities from their domain level, store those values in a back-end storage along with the rest of its data, and ultimately provide a front-end interface to allow the administrator or a user to modify them.<a id="id323" class="indexterm"/>
</p><p>The photoblog application will not go that far but will keep a fairly simple approach to providing configuration settings by using a pure INI file. We make this choice because in the photoblog application case the configuration settings will be simple, defined, and editable by the administrator of the application. We will therefore avoid the burden of developing a more complex solution than an INI file.</p><p>However, in order to simplify access to those settings, we will define a specific class that will turn the INI sections, keys, and values into a Python object:</p><div><pre class="programlisting">from ConfigParser import ConfigParser
class Config(object):
def from_ini(self, filepath, encoding='ISO-8859-1'):
config = ConfigParser()
config.readfp(file(filepath, 'rb'))
for section in config.sections():
section_prop = Config()
section_prop.keys = []
setattr(self, section, section_prop)
for option in config.options(section):
section_prop.keys.append(option)
value = config.get(section, option).decode(encoding)
setattr(section_prop, option, value)
</pre></div><p>This class will simply go through the INI file and add attributes to the instance of the<code class="literal"> Config</code> class on the fly. For instance, imagine you have the following INI file:</p><div><pre class="programlisting">[app]
base_url = http://localhost:8080
copyright = Creative Commons Attribution-ShareAlike2.5 License
[storage]
host = localhost
dbname = photoblog
user = test
password = test
type = postgres
</pre></div><p>Using the above class, we can make the following modifications:</p><div><pre class="programlisting">import config
photoblogconfiguringc = config.Config()
c.from_ini('application.conf')
dir(c)
['__class__', '__delattr__', '__dict__', '__doc__',
'__getattribute__', '__hash__', '__init__', '__module__'
'__new__', '__reduce__', '__reduce_ex__', '__repr__',
'__setattr__', '__str__', '__weakref__', 'app', 'storage']
c.app.copyright
u'Creative Commons Attribution-ShareAlike2.5 License'
</pre></div><p>As you can see, we have now modified the INI file into a tree of attributes bound to the instance of the<code class="literal"> Config</code> class. The photoblog application will have one global instance of that class that will therefore be accessible from everywhere in the application.</p><p>In this section, we have briefly reviewed the ways to parameterize a CherryPy application using its built-in configuration system. We have also introduced a simple configuration system using an INI file format allowing application settings. This approach hence provides an easy way to mock up the passing of parameters, before moving towards a system-based database, which can be more demanding.</p></div></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec02"/>Deployment</h1></div></div></div><p>Deploying a CherryPy-based application can be as easy as dropping the application in an environment, where all the required packages (CherryPy, Kid, simplejson, etc.) are available from the Python system path. However, in a shared web-hosted environment, it is quite likely that the CherryPy web server will reside behind a front-end server such as Apache or lighttpd, allowing the host provider to perform some filtering operations if needed, or for instance let that front end serve the static files in a more efficient fashion than CherryPy.<a id="id325" class="indexterm"/>
</p><p>This section will present a few solutions to run a CherryPy application behind the Apache and lighttpd web servers.</p><p>Before explaining how to use CherryPy behind Apache or lighttpd, let's define a simple application that we will use throughout the example:</p><div><pre class="programlisting">import.cherrypy
def setup_app():
class Root:
@cherrypy.expose
def index(self):
# Will return the hostname used by CherryPy and the remote
# caller IP address
return "Hello there %s from IP: %s " %
(cherrypy.request.base, cherrypy.request.remote.ip)
cherrypy.config.update({'server.socket_port': 9091,
'environment': 'production',
'log.screen': False,
'show_tracebacks': False})
cherrypy.tree.mount(Root())
if __name__ == '__main__':
setup_app()
cherrypy.server.quickstart()
cherrypy.engine.start()
</pre></div><p>As discussed earlier, there are several ways of deploying CherryPy-based applications. Now, we will discuss the different approaches to deployment.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec03"/>Apache with mod_rewrite Module</h2></div></div></div><p>The first solution you can review when running behind the Apache web server is to use the<code class="literal"> mod_rewrite</code> module. This module allows you to define a set of rules that the module will analyze to transform incoming HTTP requests and re-dispatch them towards the back-end server.<a id="id326" class="indexterm"/>
</p><p>In our example, we will make the following assumptions, which are in fact the requirements:</p><div><ul class="itemizedlist"><li class="listitem"><p>You run Apache 2.2.</p></li><li class="listitem"><p>You have access to the Apache configuration that can usually be found in the file named<code class="literal"> httpd.conf</code>. You can also stop and restart the apache process. These requirements imply either that you have administrator rights on the machine or that you have a local installation of Apache to play with.</p></li><li class="listitem"><p>You will use the<code class="literal"> VirtualHost</code> directive that allows encapsulating directives targeting only one particular host. This allows distinct hosts to be handled by one single instance of Apache.</p></li><li class="listitem"><p>We will also assume that you have <a class="ulink" href="http://myapp.com">myapp.com</a> resolvable locally. To do so:</p><p>Under Linux, add the following line to the /etc/hosts file:
</p><p>
<code class="literal">127.0.0.1 myapp.com myapp www.myapp.com</code>
</p></li><li class="listitem"><p>Your operating system should now resolve requests to the <code class="literal">myapp.com</code> host to your local environment.
<a id="id327" class="indexterm"/>
</p></li></ul></div><p>Let's now explain how we must configure Apache:</p><div><ol class="orderedlist"><li class="listitem"><p>1. Load the required Apache modules, as follows:</p></li></ol></div><div><pre class="programlisting"><strong>LoadModule</strong> rewrite_module <strong>modules</strong>/mod_rewrite.so
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>Note that you may need to provide the full path to the module itself in some environments.
</p></li></ul></div><div><ol class="orderedlist"><li class="listitem"><p>2. Next we declare the<code class="literal"> VirtualHost</code>, as follows:</p></li></ol></div><div><pre class="programlisting"># Create a virtual host in your apache configuration
# to handle requests for the myapp.com hostname
&lt;VirtualHost 127.0.0.1:80&gt;
ServerName myapp.com
ServerAlias www.myapp.com
# Where our application files reside
DocumentRoot /home/sylvain/photoblog
# What is our directory index by default
DirectoryIndex index.html
# Message to return when our CherryPy server is down and
# apache could not forward the request.
ErrorDocument 502 "Server down"
# mod_proxy magic
# First enable the mod_rewrite engine
RewriteEngine on
# Now we simply rewrite incoming requests URI so that they
# are proxied to our CherryPy web server
# http://myapp.com/archives/2006/10/12/my-article
# would become
# http://127.0.0.1:9091/archives/2006/10/12/my-article
RewriteRule ^(.*) http://127.0.0.1:9091$1 [P]
# Now define the format of the logs to be used by Apache
LogFormat "%h %l %u %t \"%r\" %&gt;s %b \"%{Referer}i\"
\"%{User-Agent}i\"" combined LogFormat
"%t %a %D %I %O %s %{Content-Type}o %{Host}i
\"%r\" \"%{Referer}i\"" host
CustomLog /home/sylvain/photoblog/access_myapp.log combined
Errorlog /home/sylvain/photoblog/error_myapp.log
&lt;/VirtualHost&gt;
</pre></div><div><ol class="orderedlist"><li class="listitem"><p>3. The next step is to stop and restart your Apache process so that these modifications are taken into account.</p></li><li class="listitem"><p>4. Then start your CherryPy application server.</p></li></ol></div><p>The<code class="literal"> mod_rewrite</code> module documentation explains in detail how to build rewriting rules. In the previous example, we defined the most generic one by mapping the request URI path to a new hostname.<a id="id328" class="indexterm"/>
</p><p>When navigating to the URL <a class="ulink" href="http://myapp.com">http://myapp.com</a>, you should now see the following message:</p><div><pre class="programlisting"><strong>Hello there http://127.0.0.1:9091 from IP: 127.0.0.1</strong>
</pre></div><p>Now that we know how to map a host to our CherryPy application via Apache, we might want to retrieve the actual hostname and remote IP address instead of the local ones. The former is needed when generating links like:</p><div><pre class="programlisting">link = "%s/%s" % (cherrypy.request.base, path)
</pre></div><p>There are two options to achieve this, as they are independent from each other:</p><div><ol class="orderedlist"><li class="listitem"><p>1. Use the<code class="literal"> mod_proxy</code> module of Apache to forward the host.</p><div><ul class="itemizedlist"><li class="listitem"><p>First you need to load the module like this (consult your documentation):</p><pre class="programlisting">
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_http_module modules/mod_proxy_http.so
</pre></li><li class="listitem"><p>Add the following directive to<code class="literal"> VirtualHost:</code>
</p><div><pre class="programlisting">ProxyPreserveHost on
</pre></div></li><li class="listitem"><p>Restart Apache.</p></li></ul></div></li><li class="listitem"><p>2. Use the CherryPy proxy tool as follows:</p><div><ul class="itemizedlist"><li class="listitem"><p>Add the following entry to your global configuration:</p></li></ul></div></li></ol></div><div><pre class="programlisting">'tools.proxy.on': True
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>Restart your CherryPy application.</p></li></ul></div><p>In both cases, you will now see the following message in your browser:</p><p>
<strong>Hello there http://myapp.com from IP: 127.0.0.1</strong>
</p><p>The IP address stays the same because the test is being done from the same machine where the server is being hosted, on the local interface.</p><p>Let's now explain how the previous recipe works. In the first case, by using the<code class="literal"> ProxyPreserveHost</code> directive, we tell Apache to keep the<code class="literal"> HTTP header host</code> field as it is and not to overwrite it with the local IP address. This means that CherryPy will receive the original value of the Host header.</p><p>In the second case, we tell CherryPy to look for specific headers set by Apache when doing proxy with the original hostnames. The default header looked up by CherryPy is<code class="literal"> X-Forwarded-Host.</code>
<a id="id329" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec04"/>Lighttpd with mod_proxy Module</h2></div></div></div><p>Lighttpd is another popular and very efficient HTTP server. The previous section can be translated to lighttpd in a similar fashion using<code class="literal"> mod_proxy</code>. Here is an example on how you can configure lighttpd to proxy incoming requests to a CherryPy server:<a id="id330" class="indexterm"/>
</p><div><pre class="programlisting">$HTTP["host"] == "myapp.com"
{
proxy.server = ( "" =&gt; (("host" =&gt; "127.0.0.1",
"port" =&gt; 8080)))
}
</pre></div><p>Add this to the<code class="literal"> lighttd.conf</code> file and restart the server. When browsing to <a class="ulink" href="http://myapp.com">http://myapp.com</a>, you will see the following message:</p><p>
<strong>Hello there http://myapp.com from IP: 127.0.0.1</strong>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec05"/>Apache with mod_python Module</h2></div></div></div><p>In the year 2000, Gregory Trubetskoy released the first version of<code class="literal"> mod_python</code>. It is a module for Apache allowing the Python interpreter to be embedded within the Apache server providing a bridge between the Apache web server and Python applications. One of the strengths of<code class="literal"> mod_python</code> is that unlike CGI where each request requires a Python process to be launched<code class="literal"> mod_python</code> does not have any such requirement. Therefore, it gives the opportunity to the developer to benefit from the persistence of the Python process started by Apache when running the module (keeping a pool of database connections for instance).<a id="id331" class="indexterm"/>
</p><p>Before seeing how to configure Apache and<code class="literal"> mod_python</code>, let's review what are the requirements:</p><div><ul class="itemizedlist"><li class="listitem"><p>Apache 2.2</p></li><li class="listitem"><p>
<code class="literal">mod_python</code> 3.1.x or superior</p></li></ul></div><p>We will assume that<code class="literal"> mod_python</code> is properly installed in your environment.</p><p>Now let's explain how to configure<code class="literal"> mod_python</code> to run a CherryPy-based application:</p><div><pre class="programlisting">LoadModule python_module modules/mod_python.so
&lt;Location "/"&gt;
PythonPath "sys.path + ['/home/sylvain/app']"
SetHandler python-program
PythonHandler cherrypy._cpmodpy::handler
PythonOption cherrypy.setup my_app::setup_app
PythonDebug On
&lt;/Location&gt;
<a id="id332" class="indexterm"/>
</pre></div><p>We will take you through the process sequentially:</p><div><ol class="orderedlist"><li class="listitem"><p>1. First we load the<code class="literal"> mod_python</code> module.</p></li><li class="listitem"><p>2. We define a location directive specifying what Apache should do to the request starting with "/".</p></li><li class="listitem"><p>3. Then we define several<code class="literal"> mod_python</code> directives:</p><div><ul class="itemizedlist"><li class="listitem"><p>
<code class="literal">PythonPath</code> extends the system path and makes sure that our application modules will be found. For instance, here the<code class="literal"> my_app.py</code> module resides in<code class="literal"> /home/sylvain/app</code>.</p></li><li class="listitem"><p>
<code class="literal">SetHandler</code> indicates that all requests starting with the path provided in the location directive will be handled by<code class="literal"> mod_python</code>.</p></li><li class="listitem"><p>
<code class="literal">PythonHandler</code> sets the generic handler that will be in charge of generating the output to return to the user agent. We use the built-in<code class="literal"> mod_python</code> handler provided by CherryPy.</p></li><li class="listitem"><p>
<code class="literal">PythonOption</code> passes options to the generic handler. Here the option will be named<code class="literal"> cherrypy.setup</code> and we bind it to the function<code class="literal"> setup_app</code> that our application provides. We assume the application is saved in a Python module named<code class="literal"> my_app.py</code>. The<code class="literal"> setup_app</code> method must be the one mounting the application.</p></li><li class="listitem"><p>
<code class="literal">PythonDebug</code> is enabled.</p></li></ul></div></li><li class="listitem"><p>4. Finally, we modify the application as follows:</p></li></ol></div><div><pre class="programlisting">import cherrypy
def setup_app():
class Root:
@cherrypy.expose
def index(self):
return "Hello there %s from IP: %s " % \
(cherrypy.request.base,cherrypy.request.remote.ip)
cherrypy.tree.mount(Root())
cherrypy.engine.start(blocking=False)
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>The difference is that we start the CherryPy engine in a non-blocking mode so that the Python process started via mod_python does not hang.
</p></li></ul></div><p>Now you can stop and restart the Apache process and navigate to the <a class="ulink" href="http://myapp.com">http://myapp.com</a> URL and you should see the following content:<a id="id333" class="indexterm"/>
</p><p>
<strong>Hello there http://myapp.com from IP: 127.0.0.1</strong>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec06"/>mod_python with WSGI Application</h2></div></div></div><p>In the previous approach, we used the built-in<code class="literal"> mod_python</code> handler that works fine on the applications usually hosted by CherryPy. If your application respects the WSGI interface, you may want to use the<code class="literal"> ModPythonGateway</code> handler (<a class="ulink" href="http://projects.amor.org/misc/wiki/ModPythonGateway">http://projects.amor.org/misc/wiki/ModPythonGateway</a>) developed by Robert Brewer.<a id="id334" class="indexterm"/>
</p><p>First let's see the CherryPy application in the<code class="literal"> my_app.py</code> module:</p><div><pre class="programlisting">import cherrypy
class Root:
@cherrypy.expose
def index(self):
return "Hello there %s from IP: %s " % (cherrypy.request.base,
cherrypy.request.remote.ip)
# Create an application respecting the WSGI interface
wsgi_app = cherrypy.Application(Root())
# This will be call on the first request
def setup_app(req):
cherrypy.engine.start(blocking=False)
</pre></div><p>Now, let's review how to configure Apache to use the<code class="literal"> ModPythonGateway</code> handler:</p><div><pre class="programlisting">&lt;Location "/"&gt;
PythonPath "sys.path + ['/home/sylvain/app']"
SetHandler python-program
PythonHandler modpython_gateway::handler
PythonOption wsgi.startup my_app::setup_app
PythonOption wsgi.application my_app::wsgi_app
PythonOption wsgi.cleanup cherrypy::engine.stop
&lt;/Location&gt;
</pre></div><p>Thanks to the<code class="literal"> ModPythonGateway</code> handler, you can use the richness of WSGI-based middlewares within the power of the Apache server.<a id="id335" class="indexterm"/>
</p></div></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec03"/>SSL</h1></div></div></div><p>
<strong>SSL</strong> (<strong>Secure Sockets Layer</strong>) can be supported in CherryPy-based applications natively by CherryPy. To enable SSL support, you must meet the following requirements:<a id="id336" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>Have the<code class="literal"> PyOpenSSL</code> package installed in your environment</p></li><li class="listitem"><p>Have an SSL certificate and private key on the server</p></li></ul></div><p>In the rest of this chapter, we will assume that you have installed<code class="literal"> PyOpenSSL</code> properly. Let us explain how to generate a pair of private key and certificate. To achieve this, we will use OpenSSL, a common open-source implementation of the SSL specification.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec07"/>Creating a Certificate and a Private Key</h2></div></div></div><p>Let's deal with the certificate and the private key:<a id="id337" class="indexterm"/>
</p><div><ol class="orderedlist"><li class="listitem"><p>1. First we need a private key:</p></li></ol></div><div><pre class="programlisting"><strong>openssl genrsa -out server.key 2048
</strong>
</pre></div><div><ol class="orderedlist"><li class="listitem"><p>2. This key is not protected by a passphrase and therefore has a fairly weak protection. If you prefer providing a passphrase, you should issue a command like this:</p></li></ol></div><div><pre class="programlisting"><strong>openssl genrsa -des3 -out server.key 2048
</strong>
</pre></div><div><ul class="itemizedlist"><li class="listitem"><p>The program will require a passphrase. If your version of OpenSSL allows you to provide an empty string, do so. Otherwise, enter a default passphrase and then remove it from the generated key as follows:
</p></li></ul></div><div><pre class="programlisting"><strong>openssl rsa -in server.key -out server.key
</strong>
</pre></div><div><ol class="orderedlist"><li class="listitem"><p>3. Now we create a certificate as follows:</p></li></ol></div><div><pre class="programlisting"><strong>openssl req -new -key server.key -out server.csr
</strong>
</pre></div><div><ol class="orderedlist"><li class="listitem"><p>4. This process will request you to input some details. The previous step has generated a certificate but it is not yet signed by the private key. To do so, you must issue the following command:</p></li></ol></div><div><pre class="programlisting"><strong>openssl x509 -req -days 60 -in server.csr -signkey
server.key -out server.crt
</strong>
</pre></div><p>The newly signed certificate will be valid for 60 days.</p><div><h3 class="title"><a id="note29"/>Note</h3><p>Note that, as the certificate is not signed by a recognized authority such as VeriSign, your browser will display a pop up when accessing the application, so that the user can accept or reject the certificate.</p></div><p>Now, we can have a look at the different approaches for creating the certificate and the key.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec01"/>Using the CherryPy SSL Support</h3></div></div></div><p>Let's see how we can do it:<a id="id338" class="indexterm"/>
</p><div><pre class="programlisting">import cherrypy
import os, os.path
localDir = os.path.abspath(os.path.dirname(__file__))
CA = os.path.join(localDir, 'server.crt')
KEY = os.path.join(localDir, 'server.key')
def setup_server():
class Root:
@cherrypy.expose
def index(self):
return "Hello there!"
cherrypy.tree.mount(Root())
if __name__ == '__main__':
setup_server()
cherrypy.config.update({'server.socket_port': 8443,
'environment': 'production',
'log.screen': True,
'server.ssl_certificate': CA,
'server.ssl_private_key': KEY})
cherrypy.server.quickstart()
cherrypy.engine.start()
</pre></div><p>The key is to provide the<code class="literal"> server.ssl_certificate</code> and<code class="literal"> server.ssl_private_key</code> values to the global CherryPy configuration. The next step is to start the server; if everything went well, you should see the following message on your screen:</p><p>
<strong>HTTP Serving HTTPS on https://localhost:8443/</strong>
</p><p>By navigating to the application URL, you should see a message such as:</p><div><img src="img/1848_10_01.jpg" alt="Using the CherryPy SSL Support"/></div><p>If you accept the certificate, you will be able to continue using the web application via HTTPS.</p><p>One caveat of the previous solution is that now your application cannot be reached via non-secured HTTP. Luckily CherryPy provides a fairly easy way to work around this problem by simply starting two HTTP servers at once. You can see how it is done:</p><div><pre class="programlisting">import cherrypy
from cherrypy import _cpwsgi
from cherrypy import wsgiserver
import os, os.path
localDir = os.path.abspath(os.path.dirname(__file__))
CA = os.path.join(localDir, 'server.crt')
KEY = os.path.join(localDir, 'server.key')
def setup_app():
class Root:
@cherrypy.expose
def index(self):
return "Hello there!"
cherrypy.tree.mount(Root())
if __name__ == '__main__':
setup_app()
# Create a server which will accept HTTP requests
s1 = _cpwsgi.CPWSGIServer()
# Create a server which will accept HTTPS requests
SSLin CherryPys2 = _cpwsgi.CPWSGIServer()
s2.ssl_certificate = CA
s2.ssl_private_key = KEY
# Our first server uses the default CherryPy settings
# localhost, 8080. We thus provide distinct ones
# for the HTTPS server.
s2.bind_addr = ('localhost', 8443)
# Inform CherryPy which servers to start and use
cherrypy.server.httpservers = {s1: ('localhost', 8080),
s2: ('localhost', 8443)}
cherrypy.server.start()
cherrypy.engine.start()
</pre></div><p>Upon starting the application, you should now see the following lines on your screen:</p><p>
<strong>HTTP Serving HTTPS on https://localhost:8443/</strong>
</p><p>
<strong>HTTP Serving HTTP on http://localhost:8080/</strong>
</p><p>Your application will now be reachable via HTTP and HTTPS.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec02"/>Using the lighttpd SSL Support</h3></div></div></div><p>Setting SSL support for lighttpd is as simple as adding the following to the global configuration of lighttpd:<a id="id340" class="indexterm"/>
</p><div><pre class="programlisting">ssl.engine = "enable"
ssl.pemfile = "/home/sylvain/application/server.pem"
</pre></div><p>The<code class="literal"> server.pem</code> file is the concatenation of the<code class="literal"> server.key</code> and<code class="literal"> server.crt</code> files that we have created before. For instance, under a UNIX System we issue the following command:</p><div><pre class="programlisting"><strong>cat server.key server.crt &gt; server.pem
</strong>
</pre></div><p>By using those two lines and the proxy method, we have described in the previous section how to support SSL for the CherryPy application.</p><div><h3 class="title"><a id="note30"/>Note</h3><p>Note, however, that the path between lighttpd and CherryPy will be HTTP not secured. SSL support will stop at the lighttpd level.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec03"/>Using the Apache mod_ssl Support</h3></div></div></div><p>This approach consists of using the<code class="literal"> mod_ssl</code> module of Apache based on OpenSSL to handle the SSL exchange before forwarding the request to the CherryPy server, as we did with lighttpd.<a id="id341" class="indexterm"/>
</p><p>To do so, you need to modify your Apache configuration as follows:</p><div><pre class="programlisting"><strong>LoadModule ssl_module modules/mod_ssl.so
Listen 127.0.0.1:443
</strong>
</pre></div><p>The first line loads the<code class="literal"> mod_ssl</code> module. The second line requests Apache to listen for incoming socket connections on a given IP address on port 443 (which requires administrator rights).</p><p>Then, we modify<code class="literal"> VirtualHost</code>, as follows:</p><div><pre class="programlisting">&lt;VirtualHost 127.0.0.1:443&gt;
SSLEngine On
SSLCertificateFile /home/sylvain/application/server.crt
SSLCertificateKeyFile /home/sylvain/application/server.key
&lt;/VirtualHost&gt;
</pre></div><p>Once you have restarted the Apache process, you should be able to navigate to the URL <a class="ulink" href="http://https://myapp.com">https://myapp.com</a>.</p></div></div></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec04"/>Summary</h1></div></div></div><p>In this chapter, we have reviewed a few possibilities to configure and deploy the CherryPy-based applications using common products such as Apache and lighttpd. We have also dealt with SSL support. These should give you enough to start with and adapt for your own environment and requirements.</p><p>However, deployment goes beyond setting up web servers and this chapter does not cover the discussion of pushing the code into the production environment, neither does it explain how to update the application once in production. This is out of the scope of this chapter and hence not been discussed.</p></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec05"/>Author's View</h1></div></div></div><p>If you have read this book, I can only assume that you are interested in the CherryPy library as a candidate for your personal projects. However, my motive behind writing this book was two-fold. Firstly, I wanted to provide a solid reference for CherryPy 3 that could, well hopefully, fill the curiosity of developers using it and this is what I have tried to achieve in the first four chapters of the book.</p><p>Secondly, I wished to introduce you, my fellow reader to some of the different aspects of the development of web applications. I did not plan this book as a reference for all the subjects it gets onto, since it would have required ten other tomes. Instead, I have tried to provide you with some of the keys to make you understand that writing a web application is not any different from any other type of application in the process.</p><p>With that perspective in mind,<a class="link" href="ch05.html" title="Chapter 5. A Photoblog Application">Chapter 5</a> taught us that the persistent mechanism like relational databases could be abstracted, thanks to object-relational mapping like Dejavu, SQLObject, or SQLAlchemy. This is a fundamental concept that allows you to design your application in a relaxed fashion with regards to the manipulated data. Thereafter,<a class="link" href="ch06.html" title="Chapter 6. Web Services">Chapter 6</a> reminded us that a web application could not only serve HTML pages but also expose an API referred to as a web service. This API is precisely what transforms our web application into an actual provider of valuable services. Does it mean we should forget about the actual user experience and be shallow on the designing of the interface of our application? Obviously not, and<a class="link" href="ch07.html" title="Chapter 7. The Presentation Layer">Chapters 7</a> and<a class="link" href="ch08.html" title="Chapter 8. Ajax">8</a> review the idea behind templating before moving to the additional feature of client-side scripting and Ajax. Eventually,<a class="link" href="ch09.html" title="Chapter 9. Testing">Chapter 9</a> makes sure that we never forget that an application that has not been tested is a broken one, while<a class="link" href="ch10.html" title="Chapter 10. Deployment">Chapter 10</a> provides a few tips to deploy our application in common environments.</p><p>I hope this book will tell you a story of web application development that goes beyond CherryPy itself or any of the products introduced. A story that reminds us that there is no right or wrong but some paths that have already been explored might be good and could be trusted and sometimes they should be pushed even further.</p><p>As I have said before, I have not written this book as a reference but as an introduction. It is quite possible that you think there are alternatives or better ways to achieve some of the topics covered. In such a case, I would be pleased to discuss this with you on the CherryPy mailing-lists. If on the other hand you close this book and think about parts of its content, then I will reach my goal.</p><div><h3 class="title"><a id="note31"/>Note</h3><p>Founded in 2003 by the original CherryPy creator, WebFaction is a reliable and affordable hosting provider for your CherryPy applications.</p><p>You can get an exclusive 20% discount by using the promo code "CHERRYPYBOOK" when you sign up with WebFaction, visit <a class="ulink" href="http://www.webfaction.com">http://www.webfaction.com</a> for more details.</p></div></div></div></div>
</body></html>