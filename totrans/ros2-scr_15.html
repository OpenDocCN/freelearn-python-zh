<html><head></head><body>
		<div id="_idContainer078" class="calibre2">
			<h1 class="chapter-number" id="_idParaDest-275"><a id="_idTextAnchor573" class="pcalibre calibre4 pcalibre1"/>12</h1>
			<h1 id="_idParaDest-276" class="calibre6"><a id="_idTextAnchor574" class="pcalibre calibre4 pcalibre1"/>Publishing TFs and Packaging the URDF</h1>
			<p class="calibre3">So far, in <em class="italic">Part 3</em> of this book, you’ve had an introduction to TFs and have learned how to write a URDF, which will be used to generate the TFs for your robotics application. There are now two things we need to do to <span>go further.</span></p>
			<p class="calibre3">First, to be quicker, we have used the <strong class="source-inline1">urdf_tutorial</strong> package to publish the TFs. This is great to get started and visualize the robot model, but we won’t use this package in a real application. The question is this then: Using the URDF we have created, how do we generate the TFs for our application? What nodes do we need to start? We will first understand, through experimentation, what nodes and parameters we need to start to correctly generate the TFs for our application. From this, we will be able to create our own <span>launch file.</span></p>
			<p class="calibre3">Second, the URDF is now a series of three Xacro files placed inside the home directory. To start a proper ROS 2 application, we will create a package to organize and install the URDF, the launch file, and <span>so on.</span></p>
			<p class="calibre3">By the end of this chapter, you will be able to correctly package your URDF and publish the TFs for a ROS 2 application. This process is the same for any robot, and this package you create here will be the base for any further development, including the Gazebo simulation that we will cover later in <span>this book.</span></p>
			<p class="calibre3">As a starting point for this chapter, we will use the code inside the <strong class="source-inline1">ch11</strong> folder from the book’s GitHub repository (<a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>). You can find the final code in the <span><strong class="source-inline1">ch12</strong></span><span> folder.</span></p>
			<p class="calibre3">In this chapter, we will cover the <span>following topics:</span></p>
			<ul class="calibre9">
				<li class="calibre10">Understanding how to publish TFs with <span>our URDF</span></li>
				<li class="calibre10">Starting all nodes from <span>the terminal</span></li>
				<li class="calibre10">Creating a package to install <span>the URDF</span></li>
				<li class="calibre10">Writing a launch file to publish TFs and visualize <span>the robot</span></li>
			</ul>
			<h1 id="_idParaDest-277" class="calibre6"><a id="_idTextAnchor575" class="pcalibre calibre4 pcalibre1"/>Understanding how to publish TFs with our URDF</h1>
			<p class="calibre3">We will start this chapter by understanding what nodes and parameters we need to start in order <a id="_idIndexMarker774" class="pcalibre calibre4 pcalibre1"/>to publish the TFs for our application. Then, with <a id="_idIndexMarker775" class="pcalibre calibre4 pcalibre1"/>this knowledge, we will be able to start the required nodes, package the application, and write a <span>launch file.</span></p>
			<p class="calibre3">As we often did in this book, we will start with a discovery phase, through experimentation. I recommend that you run all the commands as you read <span>the section.</span><a id="_idTextAnchor576" class="pcalibre calibre4 pcalibre1"/></p>
			<h2 id="_idParaDest-278" class="calibre6"><a id="_idTextAnchor577" class="pcalibre calibre4 pcalibre1"/>The robot_state_publisher node</h2>
			<p class="calibre3">Basically, in this <a id="_idIndexMarker776" class="pcalibre calibre4 pcalibre1"/>chapter, we want to replicate what was done with the <strong class="source-inline1">urdf_tutorial</strong> package so we can publish the TFs by ourselves. Let’s then start the <strong class="source-inline1">display.launch.py</strong> launch file again, using the URDF from the <a id="_idIndexMarker777" class="pcalibre calibre4 pcalibre1"/>previous chapter, and do <span>some introspection:</span></p>
			<pre class="console">
$ ros2 launch urdf_tutorial display.launch.py model:=/home/&lt;user&gt;/my_robot.urdf.xacro</pre>			<p class="calibre3">In a second terminal, start <strong class="source-inline1">rqt_graph</strong> to visualize the nodes that are currently running. Refresh the view if the screen is empty. You will see something <span>like this:</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer074">
					<img alt="Figure 12.1 – Nodes running with urdf_tutorial" src="image/B22403_12_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Nodes running with urdf_tutorial</p>
			<p class="calibre3">We see the <strong class="source-inline1">/tf</strong> topic, which is the most important thing here. This is what’s needed for any ROS application to <span>work properly.</span></p>
			<p class="calibre3">Now, what is publishing on the <strong class="source-inline1">/tf</strong> topic? As you can see, there is a node called <strong class="source-inline1">/robot_state_publisher</strong> (in the text, we will write <strong class="source-inline1">robot_state_publisher</strong>, without the leading slash). Where does this node come from? <strong class="source-inline1">robot_state_publisher</strong> is a core node already available for you to use. It is a part of the <a id="_idIndexMarker778" class="pcalibre calibre4 pcalibre1"/>collection of packages that you installed with ROS 2. This node will publish the TFs for your robot. You will start it in any ROS 2 application <a id="_idIndexMarker779" class="pcalibre calibre4 pcalibre1"/>where you need TFs. Most of the time, you won’t have to publish any TF by yourself, as this will be handled by the <span><strong class="source-inline1">robot_state_publisher</strong></span><span> node.</span></p>
			<p class="calibre3">Now that we know we have to start this node, what inputs <span>are requi<a id="_idTextAnchor578" class="pcalibre calibre4 pcalibre1"/>red?</span></p>
			<h2 id="_idParaDest-279" class="calibre6"><a id="_idTextAnchor579" class="pcalibre calibre4 pcalibre1"/>Inputs for the robot_state_publisher</h2>
			<p class="calibre3">There <a id="_idIndexMarker780" class="pcalibre calibre4 pcalibre1"/>are two things you need to provide for the <strong class="source-inline1">robot_state_publisher</strong> node to work correctly: URDF and joint states. Let’s start with the <span>first<a id="_idTextAnchor580" class="pcalibre calibre4 pcalibre1"/> one.</span></p>
			<h3 class="calibre8">URDF as a parameter</h3>
			<p class="calibre3">At this <a id="_idIndexMarker781" class="pcalibre calibre4 pcalibre1"/>point, you might wonder: Where did the URDF go? We just saw some nodes and topics on <strong class="source-inline1">rqt_graph</strong>, but we didn’t see the use of the URDF <span>we created.</span></p>
			<p class="calibre3">Keep <strong class="source-inline1">display.launch.py</strong> from <strong class="source-inline1">urdf_tutorial</strong> running, and in another terminal, list all parameters for the <span><strong class="source-inline1">robot_state_publisher</strong></span><span> node:</span></p>
			<pre class="console">
$ ros2 param list /robot_state_publisher</pre>			<p class="calibre3">You will see quite a few, but the one that we care about here is named <strong class="source-inline1">robot_description</strong>. Then, you can read the value from <span>this parameter:</span></p>
			<pre class="console">
$ ros2 param get /robot_state_publisher robot_description</pre>			<p class="calibre3">With this, you will see the entire URDF in the terminal (or more precisely, the generated URDF from the Xacro file you <span>have provided).</span></p>
			<p class="calibre3">So, when you start the <strong class="source-inline1">robot_state_publisher</strong> node, you will need to give the URDF inside a parameter <span>named </span><span><strong class="source-inline1">robot_description</strong></span><span>.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">In <strong class="source-inline">rqt_graph</strong>, you can see that the <strong class="source-inline">robot_state_publisher</strong> is publishing on the <strong class="source-inline">/robot_description</strong> topic. The message you get from this topic also contains the URDF content. This can be useful to retrieve the URDF from any other node, using <span>a subscriber.</span></p>
			<p class="calibre3">That’s it for the first input; let’s see the <span>secon<a id="_idTextAnchor581" class="pcalibre calibre4 pcalibre1"/>d one.</span></p>
			<h3 class="calibre8">Joint states topic</h3>
			<p class="calibre3">In order to publish the TFs, the <strong class="source-inline1">robot_state_publisher</strong> node will need the URDF, but <a id="_idIndexMarker782" class="pcalibre calibre4 pcalibre1"/>also the current state for <span>each joint.</span></p>
			<p class="calibre3">You can see the <strong class="source-inline1">/joint_states</strong> topic in <strong class="source-inline1">rqt_graph</strong> in <span><em class="italic">Figure 12</em></span><em class="italic">.1</em>. This topic contains what you would read from encoders or control feedback in a real robot. For example, if you have some wheels, you will get to know the speed and/or position of those wheels. You will feed this into the <strong class="source-inline1">/joint_states</strong> topic. If you have a robotic arm, you usually have encoders on each axis reading the current position for <span>the axis.</span></p>
			<p class="calibre3">When we simulate the robot with Gazebo, we will use a plugin that automatically publishes the joint states. In fact, either in simulation mode or for a real robot, you will usually have nodes doing this for you (to go further on this, check out ros2_control after reading this book—you can find extra resources about that in the last chapter of this book). So, all you need to know is that this <strong class="source-inline1">/joint_states</strong> topic is important, as it’s required by <strong class="source-inline1">robot_state_publisher</strong>. Publishing on this topic is done by existing ROS <span>2 plugins.</span></p>
			<p class="calibre3">For now, as we don’t have any real robot or Gazebo simulation, we will use the <strong class="source-inline1">joint_state_publisher</strong> node (with the <strong class="bold">Joint State Publisher</strong> window), which will publish whatever values we select on the cursors. For example, if you select <strong class="source-inline1">1.0</strong> radian for <strong class="source-inline1">base_right_wheel_joint</strong>, then <strong class="source-inline1">1.0</strong> will be published on the <strong class="source-inline1">/joint_states</strong> topic for that joint and will be received and used <span>by </span><span><strong class="source-inline1">robot_state_publisher</strong></span><span>.</span></p>
			<p class="calibre3">Here, it’s important to <a id="_idIndexMarker783" class="pcalibre calibre4 pcalibre1"/>clarify the difference between joint states and TFs. A joint state is simply the <em class="italic">current state</em> of a joint. For example, for a wheel: what is the current velocity? For an axis in a robotic arm: what is the current angular position of the motor? The state is one data point, at one specific time, for one joint in your robot. It doesn’t specify anything about the relationship between joints, nor where they are located relative to each other—this is what <a id="_idTextAnchor582" class="pcalibre calibre4 pcalibre1"/>a <span>TF is.</span></p>
			<h2 id="_idParaDest-280" class="calibre6"><a id="_idTextAnchor583" class="pcalibre calibre4 pcalibre1"/>Recap – how to publish TFs</h2>
			<p class="calibre3">Let’s do a <a id="_idIndexMarker784" class="pcalibre calibre4 pcalibre1"/>quick recap of what is required to publish TFs. This is what <strong class="source-inline1">urdf_tutorial</strong> was doing for us, and what we will be doing by ourselves from <span>now on.</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer075">
					<img alt="Figure 12.2 – The required node and inputs to publish TFs" src="image/B22403_12_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.2 – The required node and inputs to publish TFs</p>
			<p class="calibre3">Here is what we need <span>to do:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Start the <strong class="source-inline">robot_state_publisher</strong> node. This node is already installed. We give the URDF as the <span><strong class="source-inline">robot_description</strong></span><span> parameter.</span></li>
				<li class="calibre10">Publish the current state for all joints on the <strong class="source-inline">/joint_states</strong> topic. This is usually done automatically for you, either with data from encoders, a simulator such as Gazebo, or <em class="italic">fake</em> data from the <span><strong class="source-inline">joint_state_publisher</strong></span><span> node.</span></li>
			</ol>
			<p class="calibre3">That’s all you have to do to correctly publish the TFs for your application. Those TFs will then be used by other nodes, plugins, and stacks, for example, the Navigation 2 or MoveIt 2 stacks (we won’t cover those in this book, but they would be a good topic to study afterward—more resources will be given in the last chapter of <span>thi<a id="_idTextAnchor584" class="pcalibre calibre4 pcalibre1"/>s book).</span></p>
			<h1 id="_idParaDest-281" class="calibre6"><a id="_idTextAnchor585" class="pcalibre calibre4 pcalibre1"/>Starting all nodes from the terminal</h1>
			<p class="calibre3">Before we package the application and write a launch file, let’s start all the nodes we need in <a id="_idIndexMarker785" class="pcalibre calibre4 pcalibre1"/>the terminal. Doing this is a best practice so that you can make sure your application is working properly. Then, creating the package and the launch file will be easier, as you already know all the elements you need <span>to include.</span></p>
			<p class="calibre3">We will use the result from the previous section and start the <strong class="source-inline1">robot_state_publisher</strong> node, as well as the <strong class="source-inline1">joint_state_publisher</strong> node. In addition to that, we will start RViz (this is optional and only used to visualize the <span>robo<a id="_idTextAnchor586" class="pcalibre calibre4 pcalibre1"/>t model).</span></p>
			<h2 id="_idParaDest-282" class="calibre6"><a id="_idTextAnchor587" class="pcalibre calibre4 pcalibre1"/>Publishing the TFs from the terminal</h2>
			<p class="calibre3">Let’s publish the TFs. For that, we will open <span>two terminals.</span></p>
			<p class="calibre3">In the <a id="_idIndexMarker786" class="pcalibre calibre4 pcalibre1"/>first one, start the <strong class="source-inline1">robot_state_publisher</strong> node. The package and executable names for this node are identical. To provide the <strong class="source-inline1">robot_description</strong> parameter, you will have to use this syntax: <strong class="source-inline1">"$(</strong><span><strong class="source-inline1">xacro &lt;path_to_urdf&gt;)"</strong></span><span>.</span></p>
			<p class="calibre3">In Terminal 1, run the <span>following command:</span></p>
			<pre class="console">
$ ros2 run robot_state_publisher robot_state_publisher --ros-args -p robot_description:="$(xacro /home/&lt;user&gt;/my_robot.urdf.xacro)"
[robot_state_publisher]: got segment base_footprint
[robot_state_publisher]: got segment base_link
[robot_state_publisher]: got segment caster_wheel_link
[robot_state_publisher]: got segment left_wheel_link
[robot_state_publisher]: got segment right_wheel_link</pre>			<p class="calibre3">If you see this, everything is working fine. <strong class="source-inline1">robot_state_publisher</strong> has been started with the URDF, and it’s ready to publish on the <strong class="source-inline1">/tf</strong> topic. Now, we need to add a publisher on the <strong class="source-inline1">/joint_states</strong> topic. We will use the <strong class="source-inline1">joint_state_publisher_gui</strong> executable <a id="_idIndexMarker787" class="pcalibre calibre4 pcalibre1"/>from the same package (note the extra <strong class="source-inline1">_gui</strong> suffix, which means <strong class="bold">graphical </strong><span><strong class="bold">user interface</strong></span><span>).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a reminder, the executable name and node name are two different things. The executable name is the one you define in <strong class="source-inline">setup.py</strong> (for Python) or <strong class="source-inline">CMakeLists.txt</strong> (for C++). The node name is defined in the code and can be different. Here, we start the <strong class="source-inline">joint_state_publisher_gui</strong> executable, but the node name <span>is </span><span><strong class="source-inline">joint_state_publisher</strong></span><span>.</span></p>
			<p class="calibre3">In Terminal 2, run the <span>following command:</span></p>
			<pre class="console">
$ ros2 run joint_state_publisher_gui joint_state_publisher_gui</pre>			<p class="calibre3">This will open the <strong class="bold">Joint State Publisher</strong> window that we previously used when experimenting with TFs and URDF. The values you see on the cursors will be published on the <strong class="source-inline1">/joint_states</strong> topic and will be received <span>by </span><span><strong class="source-inline1">robot_state_publisher</strong></span><span>.</span></p>
			<p class="calibre3">That’s basically <a id="_idIndexMarker788" class="pcalibre calibre4 pcalibre1"/>all we need. This will become the backbone of your ROS 2 application—of course, we will need to package this nicely and start it from a <span>launch file.</span></p>
			<p class="calibre3">If you run <strong class="source-inline1">rqt_graph</strong>, you will see the same nodes and topics as in <span><em class="italic">Figure 12</em></span><em class="italic">.1</em>. You can also print the TF tree (<strong class="source-inline1">ros2 run tf2_tools view_frames</strong>) and listen to the <strong class="source-inline1">/tf</strong> topic in the terminal (<strong class="source-inline1">ros2 topi<a id="_idTextAnchor588" class="pcalibre calibre4 pcalibre1"/>c </strong><span><strong class="source-inline1">echo /tf</strong></span><span>).</span></p>
			<h2 id="_idParaDest-283" class="calibre6"><a id="_idTextAnchor589" class="pcalibre calibre4 pcalibre1"/>Visualizing the robot model in RViz</h2>
			<p class="calibre3">On top <a id="_idIndexMarker789" class="pcalibre calibre4 pcalibre1"/>of what we did, we can visualize the robot <a id="_idIndexMarker790" class="pcalibre calibre4 pcalibre1"/>in RViz. This is optional, and it’s something <a id="_idIndexMarker791" class="pcalibre calibre4 pcalibre1"/>you will do mostly when you develop your application. After everything is working correctly and you switch to production mode, you won’t need<a id="_idTextAnchor590" class="pcalibre calibre4 pcalibre1"/> to <span>start RViz.</span></p>
			<h3 class="calibre8">Starting and configuring RViz</h3>
			<p class="calibre3">Let’s start <a id="_idIndexMarker792" class="pcalibre calibre4 pcalibre1"/>RViz and see how to visualize the robot model as well as <span>the TFs.</span></p>
			<p class="calibre3">Keep the <strong class="source-inline1">robot_state_publisher</strong> and <strong class="source-inline1">joint_state_publisher</strong> nodes running. Then, in Terminal 3, run the <span>following command:</span></p>
			<pre class="console">
$ ros2 run rviz2 rviz2</pre>			<p class="calibre3">This will open RViz, but, as you can see, there is no robot model, and we have some errors on the <span>left menu:</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer076">
					<img alt="Figure 12.3 – Rviz with no robot model and some errors" src="image/B22403_12_3.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.3 – RViz with no robot model and some errors</p>
			<p class="calibre3">We need to do a bit of configuration to correctly visualize the robot model and the TFs. Then, we will be able to save this configuration and reuse it the next time we <span>start RViz.</span></p>
			<p class="calibre3">Follow these steps to <span>configure RViz:</span></p>
			<ol class="calibre11">
				<li class="calibre10">In the left menu, <strong class="bold">Global Options</strong> | <strong class="bold">Fixed Frame</strong>, change from <strong class="source-inline">map</strong> to <strong class="source-inline">base_footprint</strong>. After that, <strong class="source-inline">Global Status: Error</strong> should change to <strong class="source-inline">Global </strong><span><strong class="source-inline">Status: OK</strong></span><span>.</span></li>
				<li class="calibre10">Click on the <strong class="bold">Add</strong> button on the left, scroll down, and double-click on <strong class="bold">RobotModel</strong>. You will have a new menu on the left side <span>of RViz.</span></li>
				<li class="calibre10">Open this new <strong class="bold">RobotModel</strong> menu, find <strong class="bold">Description Topic</strong>, and click on the empty space on the right side of the menu (this one is a bit tricky to find). You should see a drop-down menu; here, select <strong class="source-inline">/robot_description</strong>. After this, the robot model should appear on <span>the screen.</span></li>
				<li class="calibre10">Click on the <strong class="bold">Add</strong> button again, scroll down, and double-click on <strong class="bold">TF</strong>. This will open a new menu, and you will see the TFs appear on <span>the screen.</span></li>
				<li class="calibre10">If you want <a id="_idIndexMarker793" class="pcalibre calibre4 pcalibre1"/>to see through the model, like we did before, open <strong class="bold">RobotModel</strong>, and reduce the <strong class="bold">Alpha</strong> (transparency) value from <strong class="source-inline">1</strong> to <strong class="source-inline">0.8,</strong> <span>for example.</span></li>
				<li class="calibre10">You can remove the extra menus on the right (<strong class="bold">Views</strong>) and at the bottom (<strong class="bold">Time</strong>) to get more space for <span>the robot.</span></li>
			</ol>
			<p class="calibre3">With all those settings, you should see the robot model and TFs the same way we did when we previously visualized the URDF with the <span><strong class="source-inline1">urdf_tutorial</strong></span><span> package:</span></p>
			<div class="calibre2">
				<div class="img---figure" id="_idContainer077">
					<img alt="Figure 12.4 – RViz with the robo﻿t model and TFs" src="image/B22403_12_4.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.4 – RViz with the robo<a id="_idTextAnchor591" class="pcalibre calibre4 pcalibre1"/>t model and TFs</p>
			<h3 class="calibre8">Saving the RViz configuration</h3>
			<p class="calibre3">You will need to repeat those steps every time you start RViz. To avoid doing this, we will save <span>the configuration.</span></p>
			<p class="calibre3">Click on <strong class="bold">File</strong> | <strong class="bold">Save Config As</strong>. Let’s name the file <strong class="source-inline1">urdf_config.rviz</strong> (for these files, use the <strong class="source-inline1">.rviz</strong> extension), and place it inside your home directory <span>for now.</span></p>
			<p class="calibre3">Make sure <a id="_idIndexMarker794" class="pcalibre calibre4 pcalibre1"/>you can see the file, using a file manager or the terminal. If you didn’t save the file correctly, you will need to manually do the full configuration again. Once the file is saved, you can stop RViz (<em class="italic">Ctrl + C</em> in <span>the terminal).</span></p>
			<p class="calibre3">Then, when you start RViz again, you can add an extra <strong class="source-inline1">-d</strong> argument with the path to the <span>configuration file:</span></p>
			<pre class="console">
$ ros2 run rviz2 rviz2 -d /home/&lt;user&gt;/urdf_config.rviz</pre>			<p class="calibre3">This will start RViz exactly like you saved it: same menus, same view, same zoom, and so on. We will reuse this configuration file throughout <span>this chapter.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you wish to change the configuration, all you have to do is modify whichever settings you want in RViz, save a new configuration file, and use this <span>one instead.</span></p>
			<p class="calibre3">We now have everything we need: the URDF files and the RViz config file, and we know what nodes and parameters we have to start, and how to <span>start them.</span></p>
			<p class="calibre3">Let’s now organize everything properly into a ROS 2 package. We will first create the package, and then add a launch file to start all th<a id="_idTextAnchor592" class="pcalibre calibre4 pcalibre1"/>e nodes <span>at once.</span></p>
			<h1 id="_idParaDest-284" class="calibre6"><a id="_idTextAnchor593" class="pcalibre calibre4 pcalibre1"/>Creating a package to install the URDF</h1>
			<p class="calibre3">All the files we have created are now in our home directory. It’s time to create a ROS 2 package <a id="_idIndexMarker795" class="pcalibre calibre4 pcalibre1"/>and move all the files into the right place so that they can be installed and used in our ROS <span>2 workspace.</span></p>
			<p class="calibre3">We will start by creating a package dedicated to the robot model. Then, we will install all the files required for this application. This will allow us to use the URDF and RViz files when we write a launch file, to start all the nodes we have <span>seen previously.</span></p>
			<p class="calibre3">Let’s create a new package, but before we do that, it could be a good idea to create a new<a id="_idTextAnchor594" class="pcalibre calibre4 pcalibre1"/> ROS <span>2 workspace.</span></p>
			<h2 id="_idParaDest-285" class="calibre6"><a id="_idTextAnchor595" class="pcalibre calibre4 pcalibre1"/>Adding a new workspace</h2>
			<p class="calibre3">As of now, our <strong class="source-inline1">ros2_ws</strong> workspace contains all the code used in <em class="italic">Part 2 </em>of this book, including <a id="_idIndexMarker796" class="pcalibre calibre4 pcalibre1"/>various examples to illustrate the core concepts, a robot controller for the Turtlesim, some custom interfaces, and launch files. We don’t need any of those for the <em class="italic">Part 3</em> project; so, instead of continuing to add more things to this workspace, we will create a new one. As a general rule, if you have two different applications, you will have two <span>different workspaces.</span></p>
			<p class="calibre3">Let’s then create a new workspace named <strong class="source-inline1">my_robot_ws</strong>. A good practice is to name the workspace as per your application or robot name. This will help you avoid confusion in the <span>long term.</span></p>
			<p class="calibre3">Create a new workspace in your <span>home directory:</span></p>
			<pre class="console">
$ mkdir ~/my_robot_ws</pre>			<p class="calibre3">Then, inside this workspace, create a <span><strong class="source-inline1">src</strong></span><span> directory:</span></p>
			<pre class="console">
$ mkdir ~/my_robot_ws/src</pre>			<p class="calibre3">Now, and this is super important, you can have as many ROS 2 workspaces as you want, but you should not work with two workspaces for two different applications at the <span>same time.</span></p>
			<p class="calibre3">You are currently sourcing the <strong class="source-inline1">ros2_ws</strong> workspace every time you open a terminal. If you remember, you added an extra line in <strong class="source-inline1">.bashrc</strong> to <span>do that:</span></p>
			<pre class="source-code">
source ~/ros2_ws/install/setup.bash</pre>			<p class="calibre3">Open the <strong class="source-inline1">.bashrc</strong> file again and comment that line (add <strong class="source-inline1">#</strong> in front of the line). Now, close all terminals, open a new one, and let’s build and source our <span>new workspace:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/
$ colcon build</pre>			<p class="calibre3">Open the <strong class="source-inline1">.bashrc</strong> again and add a line to source this new workspace. The end of <strong class="source-inline1">.bashrc</strong> will look <span>like this:</span></p>
			<pre class="source-code">
source /opt/ros/jazzy/setup.bash
#source ~/ros2_ws/install/setup.bash
source ~/my_robot_ws/install/setup.bash</pre>			<p class="calibre3">As <a id="_idIndexMarker797" class="pcalibre calibre4 pcalibre1"/>a reminder, we first source the global ROS 2 installation. Then, we source our workspace. Commenting the workspaces you don’t use is very practical. This way, if you want to switch between two workspaces, you just have to uncomment/comment the two lines, close all terminals, and open a new terminal to source the workspa<a id="_idTextAnchor596" class="pcalibre calibre4 pcalibre1"/>ce you want <span>to use.</span></p>
			<h2 id="_idParaDest-286" class="calibre6"><a id="_idTextAnchor597" class="pcalibre calibre4 pcalibre1"/>Creating a _description package</h2>
			<p class="calibre3">Now that we have this new empty workspace correctly configured and sourced, let’s add a new <span>package inside.</span></p>
			<p class="calibre3">To <a id="_idIndexMarker798" class="pcalibre calibre4 pcalibre1"/>name the package, we use the robot’s name, followed by <strong class="source-inline1">_description</strong>. This is a common convention used by lots of ROS developers. By using this naming format, you make it clear that this package will contain the URDF files for your robot. This will make <span>collaboration easier.</span></p>
			<p class="calibre3">To create this new package, we use the <strong class="source-inline1">ament_cmake</strong> build type, just as if we were creating a C++ package, and we don’t specify any dependencies. Let’s create <span>the package:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/src/
$ ros2 pkg create my_robot_description --build-type ament_cmake</pre>			<p class="calibre3">For now, this package is a standard C++ ROS 2 package. However, we won’t write any nodes inside. We just need the package to install our robot model. Thus, you can remove the <strong class="source-inline1">src</strong> and <span><strong class="source-inline1">include</strong></span><span> directories:</span></p>
			<pre class="console">
$ cd my_robot_description/
$ rm -r include/ src/</pre>			<p class="calibre3">At this point, your package will only contain two files: <strong class="source-inline1">package.xml</strong> <span>and </span><span><strong class="source-inline1">CMakeLists.txt</strong></span><span>.</span></p>
			<p class="calibre3">Open the workspace with an IDE. If you’re using VS code, run <span>the following:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/src/
$ code .</pre>			<p class="calibre3">To <a id="_idIndexMarker799" class="pcalibre calibre4 pcalibre1"/>clean things a bit more, we will simplify the <strong class="source-inline1">CMakeLists.txt</strong> file. Remove the comments after the <strong class="source-inline1">find_package(ament_cmake REQUIRED)</strong> line, and, as we don’t need that now, remove the <strong class="source-inline1">if(BUILD_TESTING)</strong> block. Make sure you keep the <strong class="source-inline1">ament_package()</strong> instruction, which should be the l<a id="_idTextAnchor598" class="pcalibre calibre4 pcalibre1"/>ast line of <span>the file.</span></p>
			<h2 id="_idParaDest-287" class="calibre6"><a id="_idTextAnchor599" class="pcalibre calibre4 pcalibre1"/>Installing the URDF and other files</h2>
			<p class="calibre3">Now <a id="_idIndexMarker800" class="pcalibre calibre4 pcalibre1"/>that we have our <strong class="source-inline1">robot_description</strong> package, let’s install all the files we need. To install a file, we will follow <span>this process:</span></p>
			<ol class="calibre11">
				<li class="calibre10">Create a folder to host <span>the files.</span></li>
				<li class="calibre10">Add an instruction in <strong class="source-inline">CMakeLists.txt</strong> to install <span>the folder.</span></li>
			</ol>
			<p class="calibre3">Here, we will see how to install the URDF files, custom meshes, and t<a id="_idTextAnchor600" class="pcalibre calibre4 pcalibre1"/>he <span>RViz configuration.</span></p>
			<h3 class="calibre8">Installing Xacro and URDF files</h3>
			<p class="calibre3">To install <a id="_idIndexMarker801" class="pcalibre calibre4 pcalibre1"/>our Xacro and URDF <a id="_idIndexMarker802" class="pcalibre calibre4 pcalibre1"/>files, go inside the <strong class="source-inline1">my_robot_description</strong> package and create a new folder <span>named </span><span><strong class="source-inline1">urdf</strong></span><span>:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/src/my_robot_description/
$ mkdir urdf</pre>			<p class="calibre3">You can now move all three Xacro files inside this <strong class="source-inline1">urdf</strong> folder: <strong class="source-inline1">common_properties.xacro, mobile_base.xacro</strong>, <span>and </span><span><strong class="source-inline1">my_robot.urdf.xacro</strong></span><span>.</span></p>
			<p class="calibre3">Everything should work fine, but to make the <strong class="source-inline1">include</strong> paths more robust, let’s modify the <strong class="source-inline1">&lt;xacro:include&gt;</strong> tags <span>inside </span><span><strong class="source-inline1">my_robot.urdf.xacro</strong></span><span>:</span></p>
			<pre class="source-code">
&lt;xacro:include filename="$(find my_robot_description)/urdf/common_properties.xacro" /&gt;
&lt;xacro:include filename="$(find my_robot_description)/urdf/mobile_base.xacro" /&gt;</pre>			<p class="calibre3">Instead of providing only the relative path (which should still work in this case), we provide the absolute path to where the files will be installed, using the <strong class="source-inline1">find</strong> keyword before the <span>package name.</span></p>
			<p class="calibre3">Now, open <strong class="source-inline1">CMakeLists.txt</strong>, and add those instructions to install the <span><strong class="source-inline1">urdf</strong></span><span> folder:</span></p>
			<pre class="source-code">
find_package(ament_cmake REQUIRED)
<strong class="bold1">install(</strong>
<strong class="bold1">  DIRECTORY urdf</strong>
<strong class="bold1">  DESTINATION share/${PROJECT_NAME}/</strong>
<strong class="bold1">)</strong>
ament_package()</pre>			<p class="calibre3">This <a id="_idIndexMarker803" class="pcalibre calibre4 pcalibre1"/>will install the <strong class="source-inline1">urdf</strong> folder inside a <strong class="source-inline1">share</strong> directory when you build the package. It will allow any package <a id="_idIndexMarker804" class="pcalibre calibre4 pcalibre1"/>from the workspace to find the URDF for your robot. This is actually very similar to what we’ve done in <a href="B22403_09.xhtml#_idTextAnchor443" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 9</em></span></a> when installing launch files and <span>param files.</span></p>
			<p class="calibre3">Let’s now co<a id="_idTextAnchor601" class="pcalibre calibre4 pcalibre1"/>ntinue with <span>custom meshes.</span></p>
			<h3 class="calibre8">Installing custom meshes</h3>
			<p class="calibre3">If you are not using any custom mesh for now (which is probably the case if you are learning <a id="_idIndexMarker805" class="pcalibre calibre4 pcalibre1"/>ROS 2 from scratch with this book), you can skip this small section and go to the RViz <span>configuration directly.</span></p>
			<p class="calibre3">I briefly mentioned custom meshes in <a href="B22403_11.xhtml#_idTextAnchor519" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 11</em></span></a>, when we were creating links for the URDF. If you happen to include custom meshes with the <strong class="source-inline1">&lt;mesh&gt;</strong> tag, inside the <strong class="source-inline1">&lt;visual&gt;</strong> tag of a link, you will have to install the corresponding mesh files (with the <strong class="source-inline1">.stl</strong> or <strong class="source-inline1">.</strong><span><strong class="source-inline1">dae</strong></span><span> extension).</span></p>
			<p class="calibre3">In this case, in <strong class="source-inline1">my_robot_description</strong>, you would create a new folder <span>named </span><span><strong class="source-inline1">meshes</strong></span><span>:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/src/my_robot_description/
$ mkdir meshes</pre>			<p class="calibre3">In this folder, you would add all the <strong class="source-inline1">.stl</strong> and <strong class="source-inline1">.dae</strong> files you want to use in your URDF. Then, let’s say you have added a file named <strong class="source-inline1">base.stl</strong>. In the URDF, you will use this syntax to <span>include it:</span></p>
			<pre class="source-code">
&lt;mesh filename="file://$(find my_robot_description)/meshes/base.stl" /&gt;)</pre>			<p class="calibre3">To install the <strong class="source-inline1">meshes</strong> folder, you also have to add an instruction in <strong class="source-inline1">CMakeLists.txt</strong>. As we already added the <strong class="source-inline1">install()</strong> block previously, you just need to <a id="_idIndexMarker806" class="pcalibre calibre4 pcalibre1"/>add the name of the new folder you want <span>to install:</span></p>
			<pre class="source-code">
install(
  DIRECTORY urdf <strong class="bold1">meshes</strong>
  DESTINATION share/${PROJECT_NAME}/
)</pre>			<p class="callout-heading">Note</p>
			<p class="callout">When adding new folder names after <strong class="source-inline">DIRECTORY</strong>, you can either separate them with a space or put them on a new line; it won’t make <span>a difference.</span></p>
			<p class="calibre3">That’s it for custom meshes. Even though we don’t use them now, I wanted to include this, so that you have all the required knowledge to create a compl<a id="_idTextAnchor602" class="pcalibre calibre4 pcalibre1"/>ete URDF with <span>custom shapes.</span></p>
			<h3 class="calibre8">Installing the RViz configuration</h3>
			<p class="calibre3">Let’s finish this section by installing the RViz configuration we previously saved. This way, when we <a id="_idIndexMarker807" class="pcalibre calibre4 pcalibre1"/>start RViz later on from a launch file, we can use this configuration directly from <span>the package.</span></p>
			<p class="calibre3">Create an <strong class="source-inline1">rviz</strong> folder inside <span>the package:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/src/my_robot_description/
$ mkdir rviz</pre>			<p class="calibre3">Move the <strong class="source-inline1">urdf_config.rviz</strong> file into this new <span><strong class="source-inline1">rviz</strong></span><span> folder.</span></p>
			<p class="calibre3">Now, to install the folder, add its name to the <strong class="source-inline1">install()</strong> instruction, <span>inside </span><span><strong class="source-inline1">CMakeLists.txt</strong></span><span>:</span></p>
			<pre class="source-code">
install(
  DIRECTORY urdf meshes <strong class="bold1">rviz</strong>
  DESTINATION share/${PROJECT_NAME}/
)</pre>			<p class="calibre3">We now <a id="_idIndexMarker808" class="pcalibre calibre4 pcalibre1"/>have all the files we need for this package. Before we install them (with <strong class="source-inline1">colcon build</strong>), let’s add a launch file so we can start all the required nodes to publish the TFs as well as visu<a id="_idTextAnchor603" class="pcalibre calibre4 pcalibre1"/>alize the robot model <span>in RViz.</span></p>
			<h1 id="_idParaDest-288" class="calibre6"><a id="_idTextAnchor604" class="pcalibre calibre4 pcalibre1"/>Writing a launch file to publish TFs and visualize the robot</h1>
			<p class="calibre3">The <strong class="source-inline1">my_robot_description</strong> package is finished, but we will add a launch file so we can start <a id="_idIndexMarker809" class="pcalibre calibre4 pcalibre1"/>all the nodes and parameters that we discovered at the beginning of this chapter. This way, we can publish TFs and visualize the robot <a id="_idIndexMarker810" class="pcalibre calibre4 pcalibre1"/>in RViz. This will also be a good practice exercise on launch files, and we will reuse part of the code in the next chapter when we build the Gazebo simulation for <span>the robot.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Usually, we add <a id="_idIndexMarker811" class="pcalibre calibre4 pcalibre1"/>all launch files inside a <strong class="source-inline">_bringup</strong> package (dedicated package used for launch and configuration files). Here, we make an exception, because this launch file will be used only for visualization and development. Any other <a id="_idIndexMarker812" class="pcalibre calibre4 pcalibre1"/>launch file that we write for this application will be placed inside the <strong class="source-inline">my_robot_bringup</strong> package (which we will create in the <span>next chapter).</span></p>
			<p class="calibre3">We will write the launch file first with XML, and then with Python. This will be another example of how XML launch files can be<a id="_idTextAnchor605" class="pcalibre calibre4 pcalibre1"/> easier to write than <span>Python ones.</span></p>
			<h2 id="_idParaDest-289" class="calibre6"><a id="_idTextAnchor606" class="pcalibre calibre4 pcalibre1"/>The XML launch file</h2>
			<p class="calibre3">Before <a id="_idIndexMarker813" class="pcalibre calibre4 pcalibre1"/>writing any launch file, we first need to create a <strong class="source-inline1">launch</strong> folder, where we will put all our launch files fo<a id="_idTextAnchor607" class="pcalibre calibre4 pcalibre1"/>r the <span><strong class="source-inline1">my_robot_description</strong></span><span> package.</span></p>
			<h3 class="calibre8">Creating and installing a launch folder</h3>
			<p class="calibre3">To create <a id="_idIndexMarker814" class="pcalibre calibre4 pcalibre1"/>and install a <strong class="source-inline1">launch</strong> folder, we will <a id="_idIndexMarker815" class="pcalibre calibre4 pcalibre1"/>follow the same process as before. First, create <span>the folder:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/src/my_robot_description/
$ mkdir launch</pre>			<p class="calibre3">Then, to specify the instructions to install this folder, it’s as easy as adding the folder name <span>inside </span><span><strong class="source-inline1">CMakeLists.txt</strong></span><span>:</span></p>
			<pre class="source-code">
install(
  DIRECTORY urdf meshes rviz <strong class="bold1">launch</strong>
  DESTINATION share/${PROJECT_NAME}/
)</pre>			<p class="calibre3">As the <strong class="source-inline1">install()</strong> instruction was already configured, if we want to install a new folder, we just add its name after the other ones. For now, we are installing four folders in <span>this package.</span></p>
			<p class="calibre3">Once this is done, create a new launch file inside the folder. We will name <span>it </span><span><strong class="source-inline1">display.launch.xml</strong></span><span>:</span></p>
			<pre class="console">
$ cd launch/
$ touch display.launch.xml</pre>			<p class="calibre3">Now, let’s wr<a id="_idTextAnchor608" class="pcalibre calibre4 pcalibre1"/>ite the content for this <span>launch file.</span></p>
			<h3 class="calibre8">Writing the launch file</h3>
			<p class="calibre3">In this launch file, we will simply start the nodes and parameters that we discovered and listed at the beginning of <span>this chapter:</span></p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="source-inline">robot_state_publisher</strong> with the URDF as the <strong class="source-inline">robot_description</strong> parameter. This node will publish on the <strong class="source-inline">/</strong><span><strong class="source-inline">tf</strong></span><span> topic.</span></li>
				<li class="calibre10"><strong class="source-inline">joint_state_publisher</strong> to publish on the <strong class="source-inline">/</strong><span><strong class="source-inline">joint_states</strong></span><span> topic.</span></li>
				<li class="calibre10"><strong class="source-inline">rviz2</strong>, as we also want to visualize the <span>robot model.</span></li>
			</ul>
			<p class="calibre3">We already <a id="_idIndexMarker816" class="pcalibre calibre4 pcalibre1"/>know how to start those nodes from the terminal; now, all we have to do is add them inside one <span>launch file.</span></p>
			<p class="calibre3">In the launch file, first open and close a <strong class="source-inline1">&lt;</strong><span><strong class="source-inline1">launch&gt;</strong></span><span> tag:</span></p>
			<pre class="source-code">
&lt;launch&gt;
&lt;/launch&gt;</pre>			<p class="calibre3">Now, make sure to write all the following lines inside this <strong class="source-inline1">&lt;launch&gt;</strong> tag. You can also add an indentation (four spaces) for <span>those lines.</span></p>
			<p class="calibre3">As we will need to find the path of the URDF file and the RViz configuration file, we add two variables at the beginning of the launch file, to make the file cleaner and more readable. Also, if you have to modify those values later, you know that you just have to modify the variables at the top of <span>the file.</span></p>
			<p class="calibre3">We haven’t seen how to add (constant) variables yet in a launch file, but it’s not too complicated. You will use the <strong class="source-inline1">&lt;let&gt;</strong> tag with two arguments: <strong class="source-inline1">name</strong> and <strong class="source-inline1">value</strong>. Let’s add the two variables <span>we need:</span></p>
			<pre class="source-code">
&lt;let name="urdf_path" value="$(find-pkg-share my_robot_description)/urdf/my_robot.urdf.xacro" /&gt;
&lt;let name="rviz_config_path" value="$(find-pkg-share my_robot_description)/rviz/urdf_config.rviz" /&gt;</pre>			<p class="calibre3">Then, to use a variable, you can write <strong class="source-inline1">$(</strong><span><strong class="source-inline1">var name)</strong></span><span>.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Although the XML syntax looks similar between launch files and Xacro files, make sure not to mix things up: <em class="italic">To find a package</em>, you use <strong class="source-inline">find-pkg-share</strong> in a launch file and <strong class="source-inline">find</strong> with Xacro. <em class="italic">To use a variable</em>, you use <strong class="source-inline">$(var name)</strong> in a launch file and <strong class="source-inline">${name}</strong> <span>with Xacro.</span></p>
			<p class="calibre3">Now, let’s start all the nodes we need, one by one. Here is the code for the <span><strong class="source-inline1">robot_state_publisher</strong></span><span> node:</span></p>
			<pre class="source-code">
&lt;node pkg="robot_state_publisher" exec="robot_state_publisher"&gt;
    &lt;param name="robot_description"
           value="$(command 'xacro $(var urdf_path)')" /&gt;
&lt;/node&gt;</pre>			<p class="calibre3">Nothing <a id="_idIndexMarker817" class="pcalibre calibre4 pcalibre1"/>special here; we use the same values as in the command we previously ran in the terminal. To specify a command to run in an XML launch file, you can use <strong class="source-inline1">$(</strong><span><strong class="source-inline1">command '...')</strong></span><span>.</span></p>
			<p class="calibre3">Next, we can start the <strong class="source-inline1">joint_state_publisher</strong> node. Here, we use the executable with the <strong class="source-inline1">_gui</strong> suffix to get a graphical window with cursors to move <span>the joints:</span></p>
			<pre class="source-code">
&lt;node pkg="joint_state_publisher_gui"
      exec="joint_state_publisher_gui" /&gt;</pre>			<p class="calibre3">This node is easy to write, as we don’t need to provide anything else except the package and executable. Let’s finish with the <span>RViz node:</span></p>
			<pre class="source-code">
&lt;node pkg="rviz2" exec="rviz2" args="-d $(var rviz_config_path)" /&gt;</pre>			<p class="calibre3">In this node, we provide the saved RViz c<a id="_idTextAnchor609" class="pcalibre calibre4 pcalibre1"/>onfiguration file, using the <strong class="source-inline1">-</strong><span><strong class="source-inline1">d</strong></span><span> option.</span></p>
			<h3 class="calibre8">Starting the launch file</h3>
			<p class="calibre3">The launch <a id="_idIndexMarker818" class="pcalibre calibre4 pcalibre1"/>file is now complete. We can build the workspace to install all the files and folders that <span>we’ve added:</span></p>
			<pre class="console">
$ cd ~/my_robot_ws/
$ colcon build --packages-select my_robot_description</pre>			<p class="calibre3">Then, don’t forget to source the workspace (<strong class="source-inline1">source install/setup.bash</strong>), and you can start your new <span>launch file:</span></p>
			<pre class="console">
$ ros2 launch my_robot_description display.launch.xml</pre>			<p class="calibre3">After running this command, you should see your robot model in RViz with the TFs. If you list <a id="_idIndexMarker819" class="pcalibre calibre4 pcalibre1"/>nodes and topics on the terminal, you should be able to find everything that we have started. With <strong class="source-inline1">rqt_graph</strong>, you should also get the same result as when we started all three nodes from <span>the terminal.</span></p>
			<p class="calibre3">The <strong class="source-inline1">my_robot_description</strong> package is now complete. We have installed all the files that we need: URDF, custom meshes, RViz configuration, and a launch file to publish TFs and visualize the robot model. Before we wrap things up, let’s talk briefly abo<a id="_idTextAnchor610" class="pcalibre calibre4 pcalibre1"/>ut the Python version of the <span>launch file.</span></p>
			<h2 id="_idParaDest-290" class="calibre6"><a id="_idTextAnchor611" class="pcalibre calibre4 pcalibre1"/>The Python launch file</h2>
			<p class="calibre3">We will finish this chapter with the Python launch file to do the same thing: start the <strong class="source-inline1">robot_state_publisher</strong>, <strong class="source-inline1">joint_state_publisher</strong>, and RViz. The main reason I do <a id="_idIndexMarker820" class="pcalibre calibre4 pcalibre1"/>this here is to provide another example to emphasize the difference between Python and XML launch files. You can see this as an extension of what we discussed during <a href="B22403_09.xhtml#_idTextAnchor443" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 9</em></span></a>, <em class="italic">XML versus Python for </em><span><em class="italic">launch files</em></span><span>.</span></p>
			<p class="calibre3">This is also the last time I use Python for launch files, as in the next chapter on Gazebo, we will focus only on XML (as a reminder: If you ever need to use an existing Python launch file, you can include it inside an XML launch file, so there is no <span>problem here).</span></p>
			<p class="calibre3">Let’s now create the Python launch file. To do that, create a new file inside the <strong class="source-inline1">launch</strong> folder of the <strong class="source-inline1">my_robot_description</strong> package. You can name this file <strong class="source-inline1">display.launch.py</strong>—the same name as for the XML launch file, but with a <span>Python extension.</span></p>
			<p class="calibre3">There is no need to add any extra configuration in the package, as <strong class="source-inline1">CMakeLists.txt</strong> already contains the instructions to install the <span><strong class="source-inline1">launch</strong></span><span> folder.</span></p>
			<p class="calibre3">Let’s start to analyze this Python file (you can find the full code for this file in the book’s GitHub repository) with the <span>import lines:</span></p>
			<pre class="source-code">
from launch import LaunchDescription
from launch_ros.parameter_descriptions import ParameterValue
from launch_ros.actions import Node
from launch.substitutions import Command
import os
from ament_index_python.packages import get_package_share_path</pre>			<p class="calibre3">As you can see, that’s a lot of things to import, and it could be easy to make mistakes here. After the imports, we start the <span><strong class="source-inline1">generate_launch_description</strong></span><span> function:</span></p>
			<pre class="source-code">
def generate_launch_description():</pre>			<p class="calibre3">All the code <a id="_idIndexMarker821" class="pcalibre calibre4 pcalibre1"/>we have from now on will be inside this function (with an indentation). We create the two variables for the URDF and <span>RViz path:</span></p>
			<pre class="source-code">
urdf_path = os.path.join(
    get_package_share_path('my_robot_description'),
    'urdf',
    'my_robot.urdf.xacro'
)
rviz_config_path = os.path.join(
    get_package_share_path('my_robot_description'),
    'rviz',
    'urdf_config.rviz'
)</pre>			<p class="calibre3">To make things a bit more readable, we also create a variable for the <span><strong class="source-inline1">robot_description</strong></span><span> parameter:</span></p>
			<pre class="source-code">
robot_description = ParameterValue(Command(['xacro ', urdf_path]), value_type=str)</pre>			<p class="calibre3">Now, we start the <span>three nodes:</span></p>
			<pre class="source-code">
robot_state_publisher_node = Node(
    package="robot_state_publisher",
    executable="robot_state_publisher",
    parameters=[{'robot_description': robot_description}]
)
joint_state_publisher_gui_node = Node(
    package="joint_state_publisher_gui",
    executable="joint_state_publisher_gui"
)
rviz2_node = Node(
    package="rviz2",
    executable="rviz2",
    arguments=['-d', rviz_config_path]
)</pre>			<p class="calibre3">Finally, we need <a id="_idIndexMarker822" class="pcalibre calibre4 pcalibre1"/>to return a <strong class="source-inline1">LaunchDescription</strong> object with all the nodes we want <span>to start:</span></p>
			<pre class="source-code">
return LaunchDescription([
    robot_state_publisher_node,
    joint_state_publisher_gui_node,
    rviz2_node
])</pre>			<p class="calibre3">As you can see, the code is much longer: 38 lines for Python versus 15 lines for XML. We could optimize the spaces, but even with that, there would still be a factor of two. Also, I personally find the Python syntax more complex and not really intuitive. To be honest with you, the only way I manage to write Python launch files is just by scrapping bits of code from existing projects I find on GitHub and seeing if <span>it works.</span></p>
			<p class="calibre3">I’m not going <a id="_idIndexMarker823" class="pcalibre calibre4 pcalibre1"/>to provide much more details than that, as this code was here mainly so we can have another example of what we discussed back in <a href="B22403_09.xhtml#_idTextAnchor443" class="pcalibre calibre4 pcalibre1"><span><em class="italic">Chapter 9</em></span></a>. We will continue with XML launch fil<a id="_idTextAnchor612" class="pcalibre calibre4 pcalibre1"/>es going forward. </p>
			<h1 id="_idParaDest-291" class="calibre6"><a id="_idTextAnchor613" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you have published the TFs for your robot and properly packaged <span>your application.</span></p>
			<p class="calibre3">You first discovered that the most important node to start is <strong class="source-inline1">robot_state_publisher</strong>, with two inputs: the URDF in the <strong class="source-inline1">robot_description</strong> parameter, and the current states for each joint on the <strong class="source-inline1">/</strong><span><strong class="source-inline1">joint_states</strong></span><span> topic.</span></p>
			<p class="calibre3">From this, you started all the nodes and parameters from the terminal so that you could reproduce the output we previously had with the <span><strong class="source-inline1">urdf_tutorial</strong></span><span> package.</span></p>
			<p class="calibre3">Then, you created your own package to correctly organize your application. Here is the final architecture for this package, with all the files <span>and folders:</span></p>
			<pre class="source-code">
~/my_robot_ws/src/my_robot_description
├── CMakeLists.txt
├── package.xml
├── launch
│   ├── display.launch.py
│   └── display.launch.xml
├── meshes
├── rviz
│   └── urdf_config.rviz
└── urdf
    ├── common_properties.xacro
    ├── mobile_base.xacro
    └── my_robot.urdf.xacro</pre>			<p class="calibre3">This organization is very standard. If you look at the code for almost any robot powered by ROS, you will find this <strong class="source-inline1">_description</strong> package using more or less the same architecture. Thus, creating this package was not only helpful for the process we follow in this book but also for you to easily start working on any other project made by <span>ROS developers.</span></p>
			<p class="calibre3">We will now use this package as the base for the next chapter, where we will learn how to create a simulation for the robot <span>using Gazebo.</span></p>
		</div>
	</body></html>