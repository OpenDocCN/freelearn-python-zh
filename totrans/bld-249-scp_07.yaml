- en: Chapter 7. Creating Custom Shaders and Textures with Pynodes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：使用 Pynodes 创建自定义着色器和纹理
- en: It is sometimes said that although Blender has a powerful and versatile system
    to define materials, it lacks a proper shader language to define completely new
    **shaders**, for example, to create materials that react to light in novel ways.
    This is, however, not entirely true.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时人们说，尽管 Blender 有一个强大而通用的系统来定义材质，但它缺乏一个合适的着色器语言来定义全新的**着色器**，例如创建以新颖方式对光线做出反应的材质。然而，这并不完全正确。
- en: Blender does not have a compiled shader language but it does a have a powerful
    **node** system to combine textures and materials and these nodes can be Python
    scripts. This enables users to define completely new textures and materials.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 没有编译的着色器语言，但它确实有一个强大的**节点**系统来组合纹理和材质，这些节点可以是 Python 脚本。这使得用户能够定义全新的纹理和材质。
- en: 'In this chapter, we will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: How to write Pynodes that create simple color patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写创建简单颜色图案的 Pynodes
- en: How to write Pynodes that produce patterns with normals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写生成具有法线图案的 Pynodes
- en: How to write animated Pynodes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写动画 Pynodes
- en: How to write height-and slope-dependent materials
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写高度和坡度相关的材质
- en: How to create shaders that react to the angle of incident light
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建对入射光角度做出反应的着色器
- en: To illustrate some of its power, we start by looking at a script that creates
    regular color patterns made of triangles, rectangles, or hexagons.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示其部分功能，我们首先来看一个脚本，该脚本创建由三角形、矩形或六边形组成的常规颜色图案。
- en: '![Creating Custom Shaders and Textures with Pynodes](img/0400-07-01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Pynodes 创建自定义着色器和纹理](img/0400-07-01.jpg)'
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Materials**, **shaders**, **and** **textures** are terms that are often used
    as synonyms although there are differences in meaning. For our purposes we try
    to adhere to the following definitions: A **texture** is a basic building block,
    for example, a color or normal pattern or simply some function that returns a
    value depending on the position on a surface. A **shader** will take any number
    of textures or just a basic color and will return a color based on the influence
    of incident light and possibly the view direction. A **material** is a collection
    of textures, shaders, and all sorts of properties that can be applied to an object.
    Pynodes can be textures as well as shaders.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**材质**、**着色器**和**纹理**是经常用作同义词的术语，尽管它们在意义上有所区别。为了我们的目的，我们尽量遵守以下定义：**纹理**是一个基本构建块，例如颜色或法线图案，或者简单地是一个根据表面位置返回值的函数。**着色器**将接受任意数量的纹理或基本颜色，并将根据入射光的影响（以及可能的视图方向）返回一个颜色。**材质**是一组纹理、着色器和可以应用于对象的各类属性。Pynodes
    可以是纹理，也可以是着色器。'
- en: The basics
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: When we design a Pynode we basically design something that provides a function
    that is called for every pixel on the screen that needs to be shaded by that node
    (or even more than once, if **oversampling** is in effect). This function gets
    among other things the x, y, and z coordinates of the point on the object being
    shaded that corresponds to the pixel on the screen we are currently calculating.
    The function is then expected to return something useful such as a color, an intensity
    value, or something a little less intuitive such as a normal.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个 Pynode 时，我们基本上设计的是一种为屏幕上每个需要该节点着色的像素（或者如果启用了**超采样**，则甚至超过一次）提供函数的东西。此函数将获得其他事物，例如对象上被着色的点的
    x、y 和 z 坐标，这些坐标对应于我们当前正在计算的屏幕上的像素。然后，该函数预计将返回一些有用的东西，例如颜色、强度值，或者稍微不那么直观的东西，如法线。
- en: In Blender's Node editor window every material node, including a Pynode, is
    represented by a box which has its inputs on the left and its outputs on the right.
    These inputs and outputs are often called **sockets** and are represented by little
    colored circles (see the next screenshot). These sockets can be used to string
    nodes together; by clicking on an output socket of one node and dragging the mouse
    to the input socket of another node, these nodes will be connected. By combining
    as many different nodes as needed, very complex and powerful shaders can be created.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Blender 的节点编辑器窗口中，每个材质节点，包括 Pynode，都由一个盒子表示，其输入在左侧，输出在右侧。这些输入和输出通常被称为**插座**，并由小彩色圆圈表示（参见下一张截图）。这些插座可以用来连接节点；通过单击一个节点的输出插座并拖动鼠标到另一个节点的输入插座，这些节点将被连接。通过组合所需的不同节点数量，可以创建非常复杂和强大的着色器。
- en: From nodes to Pynodes
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从节点到 Pynodes
- en: The power of Blender's Node system not only stems from its many predefined node
    types and the many ways these nodes may be connected, but also from the fact that
    we can write new nodes in Python that may be connected in the same way as ordinary
    nodes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 的节点系统的强大之处不仅在于其许多预定义的节点类型和这些节点可能连接的许多方式，还在于我们可以用 Python 编写新的节点，这些节点可以以与普通节点相同的方式连接。
- en: 'Pynodes need a way to access the information provided by the input sockets
    and a way to send their calculated results to the output sockets. The concept
    of a node and its sockets is structured along an object-oriented model. Let''s
    first look at some example code to prove that this doesn''t need to be scary (object-oriented
    veterans: look the other way or peek through your fingers to just pick up the
    class definition from the following example):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Pynodes 需要一种方式来访问由输入插座提供的信息，以及一种方式将它们计算出的结果发送到输出插座。节点及其插座的概念是按照面向对象模型结构化的。让我们先看看一些示例代码来证明这并不需要令人害怕（面向对象的老兵：请向另一边看或用手指遮住眼睛，只从下面的示例中获取类定义）：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before we look at this code in detail try it in Blender to see how it actually
    works:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细查看此代码之前，先在 Blender 中尝试它，看看它实际上是如何工作的：
- en: Open a new file in the text editor and give it a distinguishable name.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开一个新文件，并给它一个可区分的名称。
- en: Copy the example code.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制示例代码。
- en: Create a simple scene, for example, a simple UV sphere at the origin with a
    couple of lamps and a camera.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的场景，例如，在原点处的一个简单的 UV 球体，配上一两个灯具和一个摄像机。
- en: Assign a `Node` material to the sphere like you normally would.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像平常一样，将 `Node` 材质分配给球体。
- en: Finally, add in a *dynamic* node in the Node editor (**Add | Dynamic**) and
    select the name of the file that you edited by clicking on the selection button
    of the *dynamic* node and picking the file.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在节点编辑器中添加一个 *动态* 节点（**添加 | 动态**），通过点击 *动态* 节点的选择按钮并选择你编辑的文件来选择文件的名称。
- en: 'The resulting network of nodes (often called a **noodle**) may look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的节点网络（通常称为 **面条**）可能看起来像这样：
- en: '![From nodes to Pynodes](img/0400-07-02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![从节点到 Pynodes](img/0400-07-02.jpg)'
- en: If you render the sphere the result is a colorful ball not unlike a color selection
    widget.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你渲染球体，结果是一个五彩斑斓的球体，与颜色选择小部件不相上下。
- en: Now back to the code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到代码。
- en: In the first line we import the `Node` module from Blender because we will be
    implementing a new type of node, but most of its behavior is already defined in
    the `Node` module.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们从 Blender 导入 `Node` 模块，因为我们将实现一种新的节点类型，但其中大部分行为已经在 `Node` 模块中定义。
- en: Then we define a class `MyNode`, a subclass of `Node.Scripted`, which will behave
    just like a `Scripted` node except for the parts that we will redefine.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义了一个名为 `MyNode` 的类，它是 `Node.Scripted` 的子类，它将表现得就像一个 `Scripted` 节点，除了我们将要重新定义的部分。
- en: 'Next, we define the `__init__()` function that will be called the first time
    we create this type of Pynode in the node editor or any time we click on the **Update**
    button. When this happens Blender will pass two arguments to this function: `self`,
    a pointer to the node we are using, and `sockets`, a reference to an object that
    will point to our lists of input and output sockets. These are the nodes in the
    node editor we will receive input from or send data to.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了 `__init__()` 函数，它将在我们在节点编辑器中第一次创建此类 Pynode 或点击 **更新** 按钮时被调用。当发生这种情况时，Blender
    将向此函数传递两个参数：`self`，指向我们使用的节点的指针，以及 `sockets`，一个指向我们的输入和输出插座列表的对象的引用。这些是我们将在节点编辑器中接收输入或发送数据的节点。
- en: In the highlighted line we define a list of input socket definitions; only one
    in this case and it is called `Coords`. It is a vector input because it is initialized
    with a list of three floats that define the default values, if this input socket
    is not connected to another node. Vector nodes are represented as blue circles
    in the node editor.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在高亮行中，我们定义了一个输入插座定义列表；在这种情况下只有一个，称为 `Coords`。它是一个向量输入，因为它使用一个包含三个浮点数的列表初始化默认值，如果这个输入插座没有连接到另一个节点。在节点编辑器中，向量节点以蓝色圆圈表示。
- en: Other types of input socket are possible as well and the type is determined
    by the value of the `val` argument. Output sockets are defined in the same way.
    A list of three floats will define a vector socket, a list of four floats a color
    socket (with a red, green, blue, and alpha component), and a socket representing
    a simple value such as intensity is initialized by a single float. Note that we
    cannot distinguish between inputs that need to be filled in by the user or ones
    that should be connected to another node. We use input sockets for both and will
    have to document their intended use. Currently, there is no facility to add buttons
    or other widgets to a Pynode.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在其他类型的输入插座，其类型由`val`参数的值确定。输出插座以相同的方式定义。一个包含三个浮点数的列表将定义一个向量插座，一个包含四个浮点数的列表将定义一个颜色插座（具有红色、绿色、蓝色和alpha组件），而表示简单值（如强度）的插座由单个浮点数初始化。请注意，我们无法区分需要用户填写或应连接到另一个节点的输入。我们使用输入插座来完成这两项任务，并将不得不记录它们的预期用途。目前，没有提供添加按钮或其他小部件到Pynode的功能。
- en: Our sample Pynode needs output as well so we define a list consisting of a single
    output socket called `Color`. It has four float values as a default specifying
    the red, green, blue, and alpha values respectively.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例Pynode也需要输出，因此我们定义了一个包含单个输出插座（称为`Color`）的列表。它有四个默认的浮点值，分别指定红色、绿色、蓝色和alpha值。
- en: Next we define a function `__call__()` that is called each time a pixel is shaded.
    It takes no arguments but `self`—a reference to the current node that is used
    in the following lines to access the input and output sockets.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了一个函数`__call__()`，每次对像素进行着色时都会调用它。它不接受任何参数，只有`self`——当前节点的引用，在以下行中用于访问输入和输出插座。
- en: In the body of `__call__()` we retrieve the three components from the input
    socket called `Coords` and assign them to easy-to-remember variables. Finally,
    we create a new four-component list that represents our calculated color and assign
    it to the output socket called `Color`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__call__()`的主体中，我们从名为`Coords`的输入插座检索三个组件，并将它们分配给易于记忆的变量。最后，我们创建了一个新的四分量列表，代表我们计算出的颜色，并将其分配给名为`Color`的输出插座。
- en: This is the basis to define simple textures but there is more information available
    to the node (as we will see in the following sections) so some pretty sophisticated
    effects can be designed. We end this section with a slightly more elaborate node
    that builds on the same principles we saw earlier but creates more useful patterns.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义简单纹理的基础，但节点（正如我们将在以下章节中看到的）还有更多信息可用，因此可以设计一些相当复杂的效果。我们以一个稍微更复杂的节点结束本节，该节点基于我们之前看到的相同原则，但创建了更有用的图案。
- en: Regular tilings
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正规镶嵌
- en: The checkerboard texture is perhaps the simplest texture that you can imagine
    and is therefore often used as an example when programming textures. Because Blender
    already has a built-in checker texture (since version 2.49, in the texture context
    of the nodes window) we go one step further and create a texture node that displays
    not only a checkerboard texture but **tilings** of triangles and hexagons as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 棋盘纹理可能是你可以想象的最简单的纹理，因此在编程纹理时经常用作示例。因为Blender已经内置了棋盘纹理（自2.49版本以来，在节点窗口的纹理上下文中），所以我们更进一步，创建了一个不仅显示棋盘纹理，还显示三角形和六边形**镶嵌**的纹理节点。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first few lines start off by defining our input and output sockets. The
    output will simply be a color in all cases but we have a more varied set of input
    sockets. We define three different input colors because the hexagon pattern needs
    three colors to give each hexagon a color that is distinguishable from its neighbor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行首先定义了我们的输入和输出插座。在所有情况下输出将简单地是一个颜色，但我们有一组更丰富的输入插座。我们定义了三种不同的输入颜色，因为六边形图案需要三种颜色来给每个六边形一个与其相邻六边形可区分的颜色。
- en: We also define a `Coords` input. This input socket may hook up to any output
    of a geometry socket. In this way we have many possibilities to map our color
    texture to the object that we are texturing. A `Scale` socket is defined as well
    to control the size of our texture.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个`Coords`输入插座。这个输入插座可以连接到任何几何插座的输出。这样，我们就有了将我们的颜色纹理映射到纹理对象的各种可能性。还定义了一个`Scale`插座来控制纹理的大小。
- en: 'Finally, we define a `Type` socket to select the pattern that we wish to generate.
    As the Pynode API does not provide a drop-down box or any other simple selection
    widget we make do with a value socket and arbitrarily pick values to represent
    our choice: `1.0` for triangles, `2.0` for checkers, and `3.0` for hexagons.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个 `Type` 插槽来选择我们希望生成的图案。由于 Pynode API 不提供下拉框或其他简单的选择小部件，我们使用值插槽并任意选择值来表示我们的选择：`1.0`
    代表三角形，`2.0` 代表棋盘，`3.0` 代表六边形。
- en: We end our `__init__()` function with the definition of a number of constants
    and a dictionary of color mappings that we will use when generating a hexagonal
    texture.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `__init__()` 函数的末尾定义了一系列常量和颜色映射的字典，我们将在生成六角纹理时使用这些。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to define the `__call__()` function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义 `__call__()` 函数：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `__call__()` function starts off by defining some shorthands for input
    values and multiplying the input coordinates by the chosen scale to stretch or
    shrink the generated pattern. The next step is to establish the kind of pattern
    that is desired and call the appropriate function to calculate the output color
    for the given coordinates. The resulting color is assigned to our only output
    socket:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__()` 函数首先定义了一些输入值的缩写，并将输入坐标乘以所选的缩放比例以拉伸或缩小生成的图案。下一步是确定所需的图案类型，并调用适当的函数来计算给定坐标的输出颜色。结果颜色被分配给我们的唯一输出插槽：'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The various pattern-generating functions are all very similar; they take x and
    y coordinates and two or three colors as arguments and return a single color.
    As these are member functions of a class, they take an additional first argument
    of `self` as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 各种图案生成函数都非常相似；它们接受 x 和 y 坐标以及两种或三种颜色作为参数，并返回一种颜色。作为类的成员函数，它们还接受一个额外的 `self`
    参数。
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `checker` function checks in which row and column we are and if the row
    number and the column number are both odd or even (that is what the exclusive
    `or` operator establishes) it returns one color, if not it returns the other color.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`checker` 函数检查我们在哪一行和哪一列，如果行号和列号都是奇数或偶数（这就是排他性“或”操作符所建立的），它返回一种颜色；如果不是，它返回另一种颜色。'
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `triangle` function first rotates both x and y coordinates together by
    a 45 degree angle (changing squares into upright lozenges). It then determines
    the color based on row and column numbers just like in the `checker` function
    but with a twist: the third term (highlighted) checks whether we are on the left
    of the diagonal crossing a square and because we have rotated our grid, we really
    check whether or not the coordinates are above the horizontal line dividing our
    lozenge. This may sound a bit complicated but you can check the following screenshot
    to get the idea:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`triangle` 函数首先将 x 和 y 坐标一起旋转 45 度角（将正方形变为直立的长方形）。然后根据行和列的数字确定颜色，就像在 `checker`
    函数中一样，但有一个转折：第三个条件（突出显示）检查我们是否位于对角线交叉的正方形左侧，因为我们已经旋转了我们的网格，所以我们实际上检查坐标是否在分割长方形的水平线上方。这可能听起来有点复杂，但你可以查看以下屏幕截图来获得概念：'
- en: '![Regular tilings](img/0400-07-03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![正六边形镶嵌](img/0400-07-03.jpg)'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `hexagon` function is like the `triangle` function in many respects (after
    all a hexagon is six triangles glued together). Therefore, it performs the same
    rotation trick but instead of picking the color by using a straightforward formula,
    things are a bit more involved and hence we use a color map here (highlighted
    in the previous code snippet). Basically, we divide the screen into horizontal
    and vertical strips and pick the color based on the strips we are in.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，`hexagon` 函数类似于 `triangle` 函数（毕竟六边形是由六个三角形粘合而成的）。因此，它执行相同的旋转技巧，但不是通过简单的公式来选择颜色，事情变得更为复杂，所以我们在这里使用颜色图（在之前的代码片段中突出显示）。基本上，我们将屏幕分为水平和垂直的条带，并根据我们所在的条带来选择颜色。
- en: 'The final piece of magic is in the last line of our script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的魔法在于我们脚本的最后一行：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The way Pynodes are currently implemented, Blender needs this assignment to
    identify a class as a node. Our node will show up in the pop-up menu of a script
    node as **Tilings**. The full code is available as `tilings.py` in `tilings.blend`
    together with a sample node setup. Some of the possible patterns are shown in
    the next screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 目前 Pynodes 的实现方式下，Blender 需要这个赋值来识别一个类为节点。我们的节点将出现在脚本节点的弹出菜单中，标记为 **Tilings**。完整的代码作为
    `tilings.py` 包含在 `tilings.blend` 文件中，并附有示例节点设置。一些可能的图案在下一张屏幕截图中展示：
- en: '![Regular tilings](img/0400-07-04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![正六边形镶嵌](img/0400-07-04.jpg)'
- en: The corresponding node setup is shown in the next screenshot. Note that we have
    not connected any node to the color inputs but even more elaborate patterns can
    be created if we do.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的节点设置在下一张截图中显示。请注意，我们没有将任何节点连接到颜色输入，但如果这样做，可以创建更复杂的图案。
- en: '![Regular tilings](img/0400-07-05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![常规镶嵌](img/0400-07-05.jpg)'
- en: Anti-aliasing
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抗锯齿
- en: If you would look closely at the diagonal boundaries of the hexagonal or triangular
    tilings you would notice some staircase-like artifacts even if oversampling was
    set to a high value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察六边形或三角形镶嵌的对角边界，即使过采样设置为高值，你也会注意到一些类似楼梯的伪影。
- en: Blender itself is smart enough to apply the chosen **anti-aliasing** level to
    things such as object boundaries, but in most cases textures on a surface will
    have to take care of anti-aliasing themselves. Blender's built-in textures are
    designed that way of course, but our own textures produced with Pynodes should
    address this explicitly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Blender本身足够智能，可以将选择的**抗锯齿**级别应用于诸如对象边界之类的事物，但在大多数情况下，表面上的纹理将必须自行处理抗锯齿。Blender的内置纹理当然是这样设计的，但用Pynodes生成的我们自己的纹理应该明确处理这一点。
- en: There are numerous mathematical techniques available to reduce aliasing in generated
    textures but most are not easy to implement or require specific knowledge about
    the way a pattern is generated. Fortunately, Blender provides us with the **Full
    OSA** option (**Buttons windows | Shading context | Material buttons | Links and
    pipeline tab**). If we enable this option, Blender is forced to oversample each
    pixel in our texture by the amount selected in the render buttons. This is an
    expensive option but will get rid of aliasing effects without the need to implement
    specific filtering options in our Pynode texture.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数学技术可用于减少生成纹理中的混叠，但大多数都不容易实现或需要特定于图案生成方式的知识。幸运的是，Blender为我们提供了**全OSA**选项（**按钮窗口
    | 着色上下文 | 材质按钮 | 链接和管道选项卡**）。如果我们启用此选项，Blender将被迫通过渲染按钮中选择的量对纹理中的每个像素进行过采样。这是一个昂贵的选项，但可以消除混叠效果，而无需在我们的Pynode纹理中实现特定的过滤选项。
- en: Indexing a texture by vector
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过向量索引纹理
- en: In our tiling patterns we have limited the colors to the minimum number needed
    to distinguish each neighboring tile. But would it be possible to assign random
    colors based on some noise texture? This way we might color fish scales in a way
    that follows an overall random pattern yet colors each individual scale uniformly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的镶嵌图案中，我们将颜色限制为区分每个相邻瓦片所需的最小数量。但根据某些噪声纹理随机分配颜色是否可能？这样我们可能会以遵循整体随机模式的方式着色鱼鳞，同时使每个单独的鳞片均匀着色。
- en: We cannot simply connect a colored texture to the color inputs as this leads
    to interesting patterns, perhaps, but each tile would not have a uniform color.
    The solution is to modify our Pynode to produce a unique vector that is uniform
    within any given tile. This vector may then be connected to any noise texture
    that takes a vector as input as all Blender textures do. This vector is used by
    the noise texture node to point to a single point in the random texture and this
    way we can produce randomly colored but uniform tiles.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将彩色纹理连接到颜色输入，因为这可能会产生有趣的图案，但每个瓦片可能不会有均匀的颜色。解决方案是修改我们的Pynode以生成一个在给定瓦片内均匀的唯一向量。这个向量可以连接到任何以向量为输入的噪声纹理，因为所有Blender纹理都可以这样做。这个向量由噪声纹理节点用来指向随机纹理中的单个点，这样我们就可以产生随机着色但均匀的瓦片。
- en: 'To provide this functionality we modify our code by removing the color inputs
    and replacing the color output by a vector output (not shown). The code inside
    the `__call__()` function will now have to produce a vector instead of a color.
    Here we show the modified `triangle` function (full code available as `tilingsv.py`
    in `tilingsv.blend`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这种功能，我们通过删除颜色输入并替换颜色输出为向量输出（未显示）来修改我们的代码。现在`__call__()`函数内部的代码将必须生成一个向量而不是颜色。这里我们展示了修改后的`triangle`函数（完整代码作为`tilingsv.py`在`tilingsv.blend`中提供）：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The logic is largely the same but, as shown in the highlighted line, we return
    a vector that is dependent on the position. However, due to the `floor()` operation
    it is constant within a triangle. Note that for the alternate triangle we add
    a slight offset; it doesn't matter which offset we choose as long as it is constant
    and produces a vector distinct from the other triangle.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑基本上相同，但如图中高亮行所示，我们返回一个依赖于位置的向量。然而，由于`floor()`操作，它在三角形内是恒定的。请注意，对于交替的三角形，我们添加了一个轻微的偏移；只要它是恒定的并且产生与其他三角形不同的向量，我们选择的偏移量无关紧要。
- en: 'The results show a random pattern of triangles that follows the large correlations
    in the noise yet leaves each individual triangle with a uniform color. The sample
    on the right has a larger noise size for the cloud texture used:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示了一个随机的三角形模式，它遵循噪声中的大相关性，但每个三角形都保持统一的颜色。右侧的样本使用了更大的噪声尺寸的云纹理：
- en: '![Indexing a texture by vector](img/0400-07-06(2).jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![通过向量索引纹理](img/0400-07-06(2).jpg)'
- en: 'A possible node setup is shown in the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了可能的节点设置：
- en: '![Indexing a texture by vector](img/0400-07-07(2).jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![通过向量索引纹理](img/0400-07-07(2).jpg)'
- en: A fresh breeze—textures with normals
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新鲜微风——带有法线的纹理
- en: A texture can have more than just a geometric input. If you need a texture to
    change its behavior based on another texture in a way that cannot be achieved
    by a simple node setup you may provide it with extra input sockets. We will develop
    a Pynode that generates a normal map that simulates the little patches of **wavelets**
    on a pond on an almost windless day.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个纹理可以不仅仅有几何输入。如果你需要一个纹理根据另一个纹理改变其行为，而这种行为不能通过简单的节点设置实现，你可以为它提供额外的输入插座。我们将开发一个Pynode，它生成一个模拟几乎无风的一天池塘上小**波**的碎片法线图。
- en: Where those patches appear is controlled by an extra input socket that may be
    linked to almost any noise texture. We will give this input socket the name `amplitude`
    because we use it to multiply it with our calculated **normal**. This way our
    wavelets will disappear wherever our noisy texture is zero.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那些补丁出现的位置由一个额外的输入插座控制，它可以连接到几乎任何噪声纹理。我们将把这个输入插座命名为`amplitude`，因为我们用它来乘以我们计算出的**法线**。这样，我们的小波将在噪声纹理为零的地方消失。
- en: The wavelength of the ripples is controlled by yet another input called `wavelength`
    and our `Ripples` node will have an input socket for the coordinates as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 波纹的波长由另一个名为`wavelength`的输入控制，我们的`Ripples`节点还将有一个用于坐标的输入插座。
- en: The fourth and final input is called `direction`—a vector that controls the
    orientation of our wavelets. It may be set by hand by the user but if desired,
    may be linked up to a normal node that provides an easy way to manipulate the
    direction with the mouse.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个和最后一个输入称为`direction`——一个控制我们小波方向的向量。用户可以手动设置它，但如果需要，也可以连接到一个提供通过鼠标轻松操纵方向的简单方法的法线节点。
- en: 'The resulting node setup that combines all of this is shown in the screenshot
    of the node editor:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的这些组合在一起的节点设置在节点编辑器的截图中显示：
- en: '![A fresh breeze—textures with normals](img/0400-07-08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![新鲜微风——带有法线的纹理](img/0400-07-08.jpg)'
- en: 'The script for the node is straightforward; after importing some necessary
    definitions we then define the numerous input sockets and our single output socket:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的脚本很简单；在导入一些必要的定义之后，我们定义了众多的输入插座和我们的单个输出插座：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, all real work is done in the `__call__()` function (highlighted in the
    preceding code snippet). We first define the shorthands `p` and `d` for the coordinates
    and the direction vectors respectively. Our wavelets are sinus functions and the
    location on this sinus curve is determined by the projection of the position on
    the direction vector. This projection is calculated by taking the "in product"
    or "dot product"—an operation provided by the `dot()` method of a `Vector` object.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有真正的操作都是在`__call__()`函数中完成的（在前面的代码片段中突出显示）。我们首先为坐标和方向向量分别定义了缩写`p`和`d`。我们的小波是正弦函数，而这个正弦曲线上的位置是由位置在方向向量上的投影确定的。这个投影是通过计算“内积”或“点积”——这是由`Vector`对象的`dot()`方法提供的一个操作来计算的。
- en: '![A fresh breeze—textures with normals](img/0400-07-09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![新鲜微风——带有法线的纹理](img/0400-07-09.jpg)'
- en: The projection is then multiplied by the wavelength. If we would calculate the
    sinus we would have the height of our wave. We are, however, not interested in
    the height but in the normal. The normal always points upward and moves along
    with our sine wave (see the next diagram). It can be shown that this normal is
    a vector with a z-component of 1.0 and an x-component equal to the negative derivative
    of the sine function, that is, minus cosine. The script (`ripples.py`) and an
    example node setup are available as `ripples.blend`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将这个投影乘以波长。如果我们计算正弦波，我们会得到我们波的高度。然而，我们感兴趣的并不是高度，而是法线。法线始终向上指，并随着我们的正弦波移动（参见下一张图）。可以证明这个法线是一个具有1.0的z分量和与正弦函数的负导数相等的x分量的向量，即负余弦。脚本（`ripples.py`）和示例节点设置作为`ripples.blend`提供。
- en: '![A fresh breeze—textures with normals](img/0400-07-10.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![新鲜微风——带有法线的纹理](img/0400-07-10.jpg)'
- en: 'In the node setup that we showed earlier you might have noticed that instead
    of linking up the geometry node directly to our ripples node, we added a second
    texture node and combined this node with the geometry input by adding and scaling
    the normal output of the texture node. We could have mixed in some noise in the
    ripples node itself but this way we give the user far more control over the type
    and amount of noise he wants to add (if any). This is a general pattern: nodes
    should be designed as simple as possible to facilitate reuse in different settings.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前展示的节点设置中，你可能已经注意到，我们没有直接将几何节点链接到我们的涟漪节点，而是添加了一个第二个纹理节点，并通过添加和缩放纹理节点的法线输出与几何输入相结合。我们本来可以在涟漪节点中混合一些噪声，但这样我们可以给用户更多的控制权，让他能够添加（如果需要）类型和数量的噪声。这是一个通用模式：节点应该尽可能简单，以便在不同的设置中重复使用。
- en: These ripples were not designed to be animated but in the following section
    we will design a node that can.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些涟漪并不是为了动画设计的，但在下一节中，我们将设计一个可以动画化的节点。
- en: '![A fresh breeze—textures with normals](img/0400-07-11.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![一阵清新的微风——带有法线的纹理](img/0400-07-11.jpg)'
- en: Raindrops—animated Pynodes
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 雨滴——动画Pynodes
- en: Many patterns are not static but change in time. One example is the ripples
    formed by **raindrops** falling in a pond. Blender exposes render-time parameters
    such as start frame, frame rate, and current frame so we have plenty of hooks
    to make our Pynodes time dependent. We will see how to use those hooks in a script
    that generates a raindrop pattern. A pattern that changes realistically resembling
    the outward expanding ripples caused by drops falling in a pond. On the way we
    also pick up some useful tricks to speed up calculations by storing the results
    of expensive calculations in the Pynode itself for later reuse.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模式不是静态的，而是随时间变化。一个例子是雨滴落在池塘中形成的涟漪。Blender提供了渲染时间参数，如起始帧、帧率和当前帧，这样我们就有很多钩子来使我们的Pynodes具有时间依赖性。我们将看到如何在生成雨滴图案的脚本中使用这些钩子。这种模式会以逼真的方式改变，类似于水滴落在池塘中产生的向外扩展的涟漪。在这个过程中，我们也会学到一些有用的技巧，通过在Pynode中存储昂贵计算的结果来加速计算。
- en: Render-time parameters
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染时间参数
- en: 'The most relevant render parameters when dealing with time-dependent things
    are the current frame number and the frame rate (the number of frames per second).
    These parameters are provided grouped together as a rendering context by the `Scene`
    module, most via function calls, some as variables:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 处理与时间相关的事物时，最相关的渲染参数是当前帧数和帧率（每秒的帧数）。这些参数由`Scene`模块以渲染上下文的形式提供，大多数通过函数调用，一些作为变量：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this information we can now calculate the time, either absolute or relative
    to the start frame:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个信息，我们现在可以计算时间，无论是绝对时间还是相对于起始帧的时间：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note the conversion to float in the denominator (highlighted). That way we ensure
    that the division is treated as a floating point operation. This is not strictly
    necessary since `fps` is returned as a float but many people assume the frame
    rate to be some integer value such as 25 or 30\. This is, however, not always
    the case (for example, NTSC encoding uses a fractional frame rate) so we better
    make this explicit. Also note that we cannot do away with this division, otherwise
    when people would change their mind about their chosen frame rate the speed of
    the animation would change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意分母中的浮点数转换（突出显示）。这样我们确保除法被视为浮点运算。这并不是绝对必要的，因为`fps`作为浮点数返回，但许多人假设帧率是一个整数值，如25或30。然而，这并不总是情况（例如，NTSC编码使用分数帧率），所以我们最好明确这一点。此外，请注意，我们不能去掉这个除法，否则当人们改变他们选择的帧率时，动画的速度会改变。
- en: What looks good, is good
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 看起来好的就是好的
- en: Accurately simulating the look of ripples caused by falling droplets may seem
    difficult but is straightforward, albeit a bit involved. Readers interested in
    the underlying mathematics might want to check some reference (for example [http://en.wikipedia.org/wiki/Wave](http://en.wikipedia.org/wiki/Wave)).
    Our goal, however, is not to simulate the real world as accurately as possible
    but to provide the artist with a texture that looks good and is controllable so
    that the texture may even be applied in situations which are not realistic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 准确模拟由落水滴引起的涟漪的外观可能看起来很困难，但却是直截了当的，尽管有些复杂。对底层数学感兴趣的读者可能想查看一些参考资料（例如[http://en.wikipedia.org/wiki/Wave](http://en.wikipedia.org/wiki/Wave)）。然而，我们的目标并不是尽可能准确地模拟现实世界，而是为艺术家提供一个看起来好且可控的纹理，这样纹理甚至可以应用于不现实的情况。
- en: 'So instead of making the speed at which the ripple travels dependent on things,
    such as the viscosity of the water, we provide speed as a tunable input to our
    Pynode. Likewise for the height and width of the ripple and the rate at which
    the height of the ripple diminishes as it expands. Basically, we approximate our
    little packet of ripples as it radiates outward from the point of impact of a
    droplet by a cosine function multiplied by an exponential function and a damping
    factor. This may sound dangerously like mathematics again, but it can be easily
    visualized:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是让涟漪传播的速度依赖于诸如水的粘度等因素，而是将速度作为一个可调输入提供给我们的 Pynode。同样，对于涟漪的高度和宽度以及涟漪高度随其扩展而减小的速率也是如此。基本上，我们通过一个余弦函数乘以一个指数函数和一个阻尼因子来近似我们的涟漪小包，它从水滴的撞击点向外辐射。这听起来可能又像是数学，但它可以很容易地被可视化：
- en: '![What looks good, is good](img/0400-07-12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![看起来好的就是好的](img/0400-07-12.jpg)'
- en: 'To calculate the height at any position x, y in our texture the above can be
    implemented as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算纹理中任何位置 x, y 的高度，可以按照以下方式实现：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `dropx` and `dropy` are the positions of impact of a drop and `a` is our
    tunable height parameter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dropx` 和 `dropy` 是水滴的撞击位置，而 `a` 是我们可调的高度参数。
- en: The effects of more drops dropped at different times and at different locations
    may simply be calculated by summing the resulting heights.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同时间、不同位置滴下更多水滴的效果，可以通过简单地将结果高度相加来计算。
- en: Storing expensive results for reuse
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储昂贵的计算结果以供重用
- en: A single drop is not rain of course, so we would like to see the effects of
    many random drops added together. Therefore, we have to choose random impact locations
    and times for as many droplets as we'd like to simulate.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单个水滴当然不是雨，因此我们希望看到许多随机水滴叠加的效果。因此，我们必须为想要模拟的水滴选择随机的撞击位置和时间。
- en: We would have to do this every time a call to the `__call__()` method is made
    (this is, for every visible pixel in our texture). However, this would be a tremendous
    waste of processing power because calculating many random numbers and allocating
    and releasing memory for possibly a large number of drops is expensive.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在每次调用 `__call__()` 方法时（即，在我们的纹理中的每个可见像素）都这样做。然而，这将是一种巨大的处理能力浪费，因为计算许多随机数以及为可能的大量水滴分配和释放内存是昂贵的。
- en: 'Fortunately, we can store these results as instance variables of our Pynode.
    Of course, we should be careful to check that no input parameters have changed
    between invocations of `__call__()` and take appropriate action if they have changed.
    The general pattern would look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以将这些结果存储为 Pynode 的实例变量。当然，我们应该小心检查在 `__call__()` 调用之间是否有任何输入参数发生了变化，如果发生了变化，则采取适当的行动。一般模式如下：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This pattern works only if the input parameter changes infrequently, for example,
    only if the user changes it. If the input changes every pixel because the input
    socket is connected to the output of another node—the suggested scheme only costs
    time instead of saving some.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式仅在输入参数不经常变化的情况下有效，例如，只有当用户更改它时。如果输入每像素都发生变化，因为输入插口连接到另一个节点的输出——建议的方案只会浪费时间而不是节省时间。
- en: Calculating normals
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算法线
- en: Our goal is to generate a ripple pattern that can be used as a normal. so we
    need some way to derive the normal from the calculated heights. Blender does not
    provide us with such a conversion node for materials so we have to devise a scheme
    ourselves.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是生成一个可以作为法线的涟漪图案，因此我们需要一种方法从计算的高度中导出法线。Blender 没有为我们提供用于材质的此类转换节点，因此我们必须自己设计方案。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Contrary to materials nodes, Blender's texture nodes do provide a conversion
    function called 'Value to Normal' that is available in the texture node editor
    from the menu **Add|Convertor|Value** to Normal.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与材质节点不同，Blender 的纹理节点确实提供了一个名为“值到法线”的转换函数，该函数在纹理节点编辑器中可用，从菜单 **添加|转换器|值** 到法线。
- en: Now, as in the case of ripples, we could, in principle, calculate an exact normal
    for our rain drops as well, but instead of going the mathematical way again we
    adapt a method used by many built-in noise textures to calculate the normal that
    works irrespective of the underlying function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如在涟漪的情况下，原则上我们可以计算雨滴的确切法线，但为了避免再次走数学路线，我们采用许多内置噪声纹理中使用的计算法线的方法，这种方法不依赖于底层函数。
- en: 'As long as we can evaluate a function at three points: `f(x,y),f(x+nabla,y)`,
    and `f(x,y+nabla)` we can estimate the direction of the normal at x,y by looking
    at the slopes of our function in the x and y direction. The surface normal will
    be the unit vector perpendicular to the plane defined by these two slopes. We
    can take any small value for `nabla` to start and if it doesn''t look good, we
    can make it smaller.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们能在三个点上评估一个函数：`f(x,y),f(x+nabla,y)` 和 `f(x,y+nabla)`，我们就可以通过观察函数在 x 和 y 方向上的斜率来估计
    x,y 处的法线方向。表面法线将是垂直于由这两个斜率定义的平面的单位向量。我们可以从任何小的 `nabla` 值开始，如果看起来不好，我们可以将其减小。
- en: Putting it all together
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: 'Taking all of these ideas from the preceding paragraphs, we can cook up the
    following code for our raindrops Pynode (with `import` statements omitted):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的段落中汲取所有这些想法，我们可以为我们的雨滴 Pynode 编写以下代码（省略了 `import` 语句）：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initialization code defines a number of input sockets besides the coordinates.
    `Drops_per_second` should be self explanatory. `a` and `c` are the overall height
    and width of the ripples traveling outward from the point of impact. `speed` and
    `freq` determine how fast our ripples travel and how close ripples are together.
    How fast the height of the ripples diminishes as they travel outward is determined
    by `dampf`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化代码定义了除坐标之外的一些输入插座。`Drops_per_second` 应该是显而易见的。`a` 和 `c` 是从撞击点向外传播的波纹的整体高度和宽度。`speed`
    和 `freq` 决定了我们的波纹传播速度以及波纹之间的距离。波纹向外传播时高度减小的速度由 `dampf` 确定。
- en: 'We also define two output sockets: `Height` will contain the calculated height
    and `Normal` will contain the corresponding normal at that same point. The `Normal`
    is what you would normally use to obtain the rippling surface effect, but the
    calculated height might be useful for example to attenuate the reflectance value
    of the surface.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了两个输出插座：`Height` 将包含计算出的高度，而 `Normal` 将包含在同一位置的相应法线。`Normal` 是你通常用来获得波纹表面效果的东西，但计算出的高度可能对例如衰减表面的反射率值很有用。
- en: The initialization ends with the definition of some instance variables that
    will be used to determine if we need to calculate the position of the drop impacts
    again as we will see in the definition of the `__call__()` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化以定义一些实例变量结束，这些变量将用于确定我们是否需要再次计算水滴撞击的位置，正如我们在 `__call__()` 函数的定义中将会看到的。
- en: 'The definition of the `__call__()` function starts off with the initialization
    of a number of local variables. One notable point is that we set the random seed
    used by the functions of the `Noise` module (highlighted in the following code).
    In this way, we make sure that each time we recalculate the points of impact we
    get repeatable results, that is if we set the number of drops per second first
    to ten, later to twenty, and then back to ten, the generated pattern will be the
    same. If you would like to change this you could add an extra input socket to
    be used as input for the `setRandomSeed()` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__()` 函数的定义从初始化多个局部变量开始。一个值得注意的点是，我们设置了 `Noise` 模块函数使用的随机种子（以下代码中突出显示）。这样，我们确保每次重新计算撞击点时都会得到可重复的结果，也就是说，如果我们首先将每秒水滴数设置为十，然后设置为二十，最后再回到十，生成的图案将是相同的。如果你想要更改这一点，你可以添加一个额外的输入插座，用作
    `setRandomSeed()` 函数的输入：'
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step is to determine whether we have to calculate the positions of
    the points of impact of the drops anew. This is necessary only when the value
    of the input socket `Drops_per_second` is changed by the user (you could hook
    up this input to some other node that changes this value at every pixel, but that
    wouldn''t be a good idea) or when the start or stop frame of the animation changes,
    as this influences the number of drops we have to calculate. This test is performed
    in the highlighted line of the following code by comparing the newly obtained
    values to the ones stored in the instance variables:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定我们是否需要重新计算水滴撞击点的位置。这只有在用户更改输入插座 `Drops_per_second` 的值时才是必要的（你可以将这个输入连接到一些其他节点，该节点在每个像素处更改此值，但这不是一个好主意）或者当动画的开始或结束帧发生变化时，因为这会影响我们需要计算的水滴数量。这个测试通过比较新获得的值与存储在实例变量中的值来在以下代码的突出行中执行：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we do have to calculate the position of the drops anew we assign a list of
    tuples to the `self.drop` instance variable, each consisting of the x and y position
    of the drop and a random drop size that will attenuate the height of the ripples.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须重新计算水滴的位置，我们将一个由元组组成的列表分配给`self.drop`实例变量，每个元组包含水滴的x和y位置以及一个随机的水滴大小，这将衰减波纹的高度。
- en: 'The rest of the lines are all executed each time `__call__()` is called but
    the highlighted line does show a significant optimization. Because drops that
    have not yet fallen in the current frame do not contribute to the height, we exclude
    those from the calculation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的行每次调用`__call__()`时都会执行，但突出显示的行确实显示了显著的优化。因为当前帧中尚未落下的水滴不会对高度产生影响，所以我们排除了这些水滴的计算：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code we actually calculate the height at three different positions
    to be able to approximate the normal (as explained previously). These values are
    used in the following lines to determine the x and y components of the normal
    (the z component is set to one). The calculated height itself is divided by the
    number of drops (so the average height will not change when the number of drops
    is changed) and by the overall scaling factor `a`, which may be set by the user
    before it is assigned to the output socket (highlighted):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实际上在三个不同的位置计算高度，以便能够近似法线（如前所述）。这些值在下面的行中用于确定法线的x和y分量（z分量设置为1）。计算出的高度本身被除以滴落次数（因此当滴落次数改变时，平均高度不会改变）以及整体缩放因子`a`，用户可以在将其分配给输出端口之前设置它（突出显示）：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The calculated normal is then added to the surface normal at the pixel where
    we are calculating so the ripples will still look good on a curved surface and
    normalized before assigning it to the output socket. The final line as usual defines
    a meaningful name for this Pynode. The full code and a sample node setup are available
    as `raindrops.py` in `raindrops.blend`. A sample frame from an animation is shown
    in the next screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将计算出的法线添加到我们在计算像素处的表面法线，这样波纹在曲面上看起来仍然很好，并且在分配到输出端口之前进行归一化。通常，最后一行定义了这个Pynode的有意义名称。完整的代码和示例节点设置作为`raindrops.py`在`raindrops.blend`中可用。下一个屏幕截图显示了动画的一个样本帧：
- en: '![Putting it all together](img/0400-07-13.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容组合在一起](img/0400-07-13.jpg)'
- en: 'A sample node setup is shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了示例节点设置：
- en: '![Putting it all together](img/0400-07-14.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![将所有内容组合在一起](img/0400-07-14.jpg)'
- en: Wuthering heights—a slope-dependent material
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威瑟林高地——一个坡度相关的材质
- en: In Blender it is quite simple to generate a fractal terrain (just add a plane,
    go to *edit* mode, select all, and then subdivide fractal a few times *W → 3*).
    If you want something more elaborate a few excellent scripts exist to help you
    (see for example [http://sites.google.com/site/androcto/Home/python-scripts/ANTLandscape_104b_249.py](http://sites.google.com/site/androcto/Home/python-scripts/ANTLandscape_104b_249.py)).
    But how would you apply textures to such a terrain? In this example, we will examine
    a method to choose between different material inputs based on the slope of the
    surface that we're shading. This will allow us to create the effect that very
    steep slopes are generally devoid of greenery even though they might be well below
    the tree line. Combined with a height-dependent material we should be able to
    shade a mountainous terrain in a pretty convincing way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中生成分形地形相当简单（只需添加一个平面，进入*编辑*模式，选择所有，然后多次细分分形 *W → 3*)。如果你想要更复杂的东西，有一些优秀的脚本可以帮助你（例如，参见[http://sites.google.com/site/androcto/Home/python-scripts/ANTLandscape_104b_249.py](http://sites.google.com/site/androcto/Home/python-scripts/ANTLandscape_104b_249.py)）。但是，你将如何将这些纹理应用到这样的地形上呢？在这个例子中，我们将研究一种根据我们要着色的表面的坡度来选择不同材质输入的方法。这将使我们能够以相当令人信服的方式着色山岳地形。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Reducing computation time:**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少计算时间：**'
- en: Pynodes are computationally intensive as they are called for every visible pixel.
    Clever coding can sometimes reduce the amount of computation needed but if a further
    speedup is required a just-in-time compiler might help. **psyco** is such a compiler
    and we will encounter it in the last chapter where we will apply it on Pynodes
    and see whether it has any appreciable effect.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Pynodes计算密集，因为它们对每个可见像素都会被调用。巧妙的编码有时可以减少所需的计算量，但如果需要进一步加速，即时编译器可能会有帮助。**psyco**就是这样一种编译器，我们将在最后一章中遇到它，我们将将其应用于Pynodes并看看它是否有任何可感知的影响。
- en: Determining the slope
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定斜率
- en: The **slope** can be defined as the angle between the floor plane and a line
    tangent to the surface at the point of interest.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**斜率**可以定义为地板平面与在感兴趣点处与表面相切的线之间的角度。'
- en: '![Determining the slope](img/0400-07-15.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![确定斜率](img/0400-07-15.jpg)'
- en: 'Because we assume our (imaginary) floor plane to stretch horizontally along
    the x and y axis this angle is completely determined by the z-component of the
    surface normal at the same point. Now we can calculate this angle exactly (it
    is ![Determining the slope](img/0400-07-16.jpg)), but as artists we may want to
    have some extra control anyway so we simply take the normalized z-component of
    the surface normal and modify this output intensity with any color ramp node that
    we like. Within a Pynode a surface normal is a readily available vector entity:
    `self.input.shi.surfaceNormal`. There is a snag however...'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们假设我们的（想象中的）地板平面沿着x和y轴水平延伸，所以这个角度完全由同一点的表面法线的z分量决定。现在我们可以精确地计算出这个角度（它就是![确定斜率](img/0400-07-16.jpg)），但作为艺术家，我们可能仍然希望有一些额外的控制，所以我们简单地取表面法线的归一化z分量，并用我们喜欢的任何颜色渐变节点修改这个输出强度。在一个Pynode中，表面法线是一个现成的矢量实体：`self.input.shi.surfaceNormal`。然而，有一个问题...
- en: World space versus camera space
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界空间与相机空间
- en: 'The surface normal that we have available happens to be defined in camera space.
    This means that, for example, when the surface normal is pointing straight at
    the camera it is defined as (0, 0,-1). Now we want our surface normals to be defined
    in world space. A normal that is pointing straight up for instance should have
    a value of (0,0,1) irrespective of the position or tilt of the camera (after all,
    mountainside vegetation does not normally change with the camera angle). Fortunately,
    we can convert from **camera space** to **world space** by taking the camera''s
    world space matrix and multiplying the surface normal with the rotation part of
    this matrix. The resulting code looks like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可用的表面法线恰好是在相机空间中定义的。这意味着，例如，当表面法线直接指向相机时，它被定义为（0，0，-1）。现在我们希望我们的表面法线在世界空间中定义。例如，一个直指上方的法线应该有一个值为（0，0，1），无论相机的位置或倾斜角度如何（毕竟，山腰的植被通常不会随着相机角度的变化而变化）。幸运的是，我们可以通过取相机的世界空间矩阵并将其与矩阵的旋转部分相乘来从**相机空间**转换为**世界空间**。生成的代码看起来像这样：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the initialization code does not define an input socket. We will get
    the surface normal at the position of the pixel that we are shading from the shader
    input (highlighted in the next piece of code). We do define three separate output
    sockets for the x, y, and z components of the slope for ease of use in a node
    setup. As we mostly will be using just the z-component of the slope, having it
    available in a separate socket saves use from extracting it from a vector with
    an additional vector manipulation node.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，初始化代码没有定义输入插座。我们将从着色器输入（在下一部分代码中突出显示）获取我们着色像素位置的表面法线。我们确实定义了三个单独的输出插座，用于斜率的x、y和z分量，以便在节点设置中易于使用。因为我们主要将使用斜率的z分量，所以将其放在单独的插座中可以节省我们使用额外的矢量操作节点从矢量中提取它的麻烦。
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The transformation from camera space to world space is done in the line that
    references the surface normal (highlighted). The orientation is dependent only
    on the rotation, therefore we extract only the rotation part of the camera's transformation
    matrix before we multiply the surface normal with it. As the normalized result
    may point downward we force the z-component to lie in the range [0, 1] by adding
    1 and multiplying by 0.5\. The full code is available as `slope.py` in `slope.blend`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 从相机空间到世界空间的转换是在引用表面法线的行中完成的（突出显示）。方向仅取决于旋转，因此我们在将表面法线与之相乘之前，只提取相机的变换矩阵的旋转部分。由于归一化结果可能指向下方，我们通过加1并乘以0.5来强制z分量位于[0,
    1]的范围内。完整的代码作为`slope.py`在`slope.blend`中可用。
- en: 'There is one important thing to be aware of: the surface normal that we use
    here is not interpolated and hence equal everywhere along the surface of a single
    face, even if the `smooth` attribute of a face is set. This shouldn''t be a problem
    in a finely subdivided landscape where the slope input is not used directly, However,
    this is different from what you might expect. In the present implementation of
    Pynodes, this limitation is difficult if not impossible to overcome.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的事情需要注意：我们这里使用的表面法线没有插值，因此在一个单一面的表面上处处相等，即使面的`smooth`属性被设置。在一个细分得很细的景观中，这不应该是一个问题，因为斜率输入没有直接使用。然而，这与你预期的不同。在当前Pynodes的实现中，这个限制是很难克服的，如果不是不可能的话。
- en: The following illustration shows an example of what is possible.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的插图展示了一个可能的例子。
- en: '![World space versus camera space](img/0400-07-17.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![世界空间与相机空间](img/0400-07-17.jpg)'
- en: The effects shown above were realized by combining different materials in the
    node setup shown in the next screenshot. This setup is available in `slope.blend`
    as well. The lower two materials were mixed using our slope-dependent node and
    the resulting material was mixed with the upper material based on a Pynode that
    calculates the height.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的效果是通过在下一张截图所示的节点设置中组合不同的材料实现的。这个设置在`slope.blend`中也是可用的。下面两种材料是用我们的斜率相关节点混合的，然后根据一个计算高度的Pynode将得到的材料与上层材料混合。
- en: '![World space versus camera space](img/0400-07-18.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![世界空间与相机空间](img/0400-07-18.jpg)'
- en: Soap bubbles—a view-dependent shader
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 肥皂泡——视图相关的着色器
- en: Some materials change the way they look depending on the angle at which we look
    at them. Bird feathers, some fancy car paints, oil spills on water, and **soap
    bubbles** are some examples. This phenomenon of changing colors is known as **iridescence**.
    If we want to implement something like that we need access to the view vector
    and the surface normal. In our soap bubble shader we see one way of doing this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一些材料会根据我们观察的角度改变它们的外观。鸟的羽毛、一些豪华汽车的油漆、水上的油污，以及**肥皂泡**就是一些例子。这种改变颜色的现象被称为**彩虹色**。如果我们想实现类似的效果，我们需要访问视图向量和表面法线。在我们的肥皂泡着色器中，我们看到实现这一点的其中一种方法。
- en: '*First* *some* *mathematics*: Why is it that soap bubbles show all those different
    colors? Soap bubbles are basically curved sheets of water (with a little soap),
    and at the interface between air and water, light is reflected. An incident ray
    will therefore be partially reflected when it hits the outer surface of the bubble
    and be reflected again when it reaches the inner surface. The reflected light
    that reaches the eye is therefore a mixture of light that has traveled different
    distances; part of it has traveled the extra distance of twice the thickness of
    the soap bubble.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先**是一些**数学**：为什么肥皂泡会显示出所有那些不同的颜色？肥皂泡基本上是带有少量肥皂的弯曲水片，在空气和水之间的界面处，光会被反射。因此，入射光线在击中气泡的外表面时会被部分反射，当它达到内表面时又会再次反射。因此，达到眼睛的反射光是一种混合了走过不同距离的光；其中一部分走过肥皂泡厚度的两倍额外距离。'
- en: 'Now, light behaves like a wave and waves that interfere can either dampen or
    amplify each other depending on their phase, and two light rays that have traveled
    distances whose difference is not an exact multiple of their wavelength will cancel
    each other. The result is that white light (a continuum of colors) reflecting
    off a soap bubble with a thickness equal to half the wavelength of some specific
    color will show only that single color because all of the other colors are dampened
    as they do not "fit" properly between the inner and outer surface. (There is much
    more to soap bubbles. For more and more accurate information refer to: [http://www.exploratorium.edu/ronh/bubbles/bubble_colors.html](http://www.exploratorium.edu/ronh/bubbles/bubble_colors.html).)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，光的行为就像波一样，相互干涉的波可以根据它们的相位相互减弱或增强。两条光线如果它们走过的距离之差不是它们波长的整数倍，就会相互抵消。结果是，白光（一系列颜色的连续体）从厚度等于某些特定颜色波长一半的肥皂泡上反射回来时，只会显示出那种单一的颜色，因为所有其他颜色都被减弱了，因为它们在内外表面之间“不合适”。（关于肥皂泡还有很多更多。更多和更准确的信息请参考：[http://www.exploratorium.edu/ronh/bubbles/bubble_colors.html](http://www.exploratorium.edu/ronh/bubbles/bubble_colors.html)。）
- en: '![Soap bubbles—a view-dependent shader](img/0400-07-19.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![肥皂泡——视图相关的着色器](img/0400-07-19.jpg)'
- en: 'Now we know that the distance traveled between the two reflecting surfaces
    determines the color we perceive, we can also understand why there will be color
    variations in a soap bubble. The first factor is the curvature of the bubble.
    The distance traveled will be dependent on the angle between the incident light
    and the surface: the shallower this angle, the longer the distance the light has
    to travel between the surfaces will be. As the angle of incidence changes as the
    surface curves so will the distance and, hence the color. The second source of
    color variation is the unevenness of the surface; slight variations due to gravity
    or swirls caused by air currents or temperature differences also cause different
    colors.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，两个反射表面之间的传播距离决定了我们感知到的颜色，我们也可以理解为什么肥皂泡中会有颜色变化。第一个因素是气泡的曲率。传播的距离将取决于入射光和表面之间的角度：这个角度越浅，光线在表面之间传播的距离就越长。由于表面曲率的变化，入射角也会变化，因此距离和颜色也会变化。颜色变化的第二个来源是表面的不均匀性；由于重力或气流或温度差异引起的轻微变化也会导致不同的颜色。
- en: All this information translates to a surprisingly short piece of code (the full
    code is available as `irridescence.py` in `irridescence.blend` together with a
    sample node setup).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都转化为一段令人惊讶的简短代码（完整代码作为 `irridescence.py` 在 `irridescence.blend` 中提供，并附有示例节点设置）。
- en: 'Beside the coordinates, we have two input sockets—one for the thickness of
    the water film and one for the variation. The variation will get added to the
    thickness and can be hooked up to a texture node to generate swirls and the like.
    We have a single output socket for the calculated distance:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了坐标外，我们有两个输入插槽——一个用于水膜的厚度，一个用于变化。变化将添加到厚度上，可以连接到纹理节点以生成漩涡等。我们有一个用于计算距离的单个输出插槽：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The calculations of the reflected color start off with getting a list of all
    lamps in the scene as we will want to calculate the angle of the incident light
    rays. For now, we take into account only the contribution of the first lamp that
    we find. However, a more complete implementation would consider all lamps and
    maybe even their color. For our calculations we have to make certain that the
    surface normal `N` and the incidence vector of the light `L` are in the same space.
    As the surface normal provided will be in camera space we will have to transform
    this vector by the transformation matrix of the camera as we did for our slope-dependent
    shader (highlighted in the following code snippet):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 反射颜色的计算从获取场景中所有灯具的列表开始，因为我们希望计算入射光线的角度。目前，我们只考虑我们找到的第一个灯具的贡献。然而，一个更完整的实现将考虑所有灯具，甚至它们的颜色。在我们的计算中，我们必须确保表面法线
    `N` 和光线的入射向量 `L` 在同一空间中。由于提供的表面法线将在相机空间中，我们将不得不通过相机的变换矩阵来转换这个向量，就像我们在斜率相关的着色器中做的那样（以下代码片段中突出显示）：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we calculate the angle between the surface normal and the incidence vector
    (`VecT` is an alias for `Mathutils.angleBetweenVecs()`) and use this incidence
    angle to calculate the angle between the surface normal *inside* the water film
    as this will determine the distance the light travels. We use **Snell''s law**
    to calculate this and use `1.31` as the index of refraction of the water film.
    Calculating the distance is then a matter of simple trigonometry (highlighted
    below):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算表面法线和入射向量之间的角度（`VecT` 是 `Mathutils.angleBetweenVecs()` 的别名），并使用这个入射角度来计算水膜内部表面法线之间的角度，因为这将确定光线的传播距离。我们使用
    **斯涅尔定律** 来计算这个值，并使用 `1.31` 作为水膜的折射率。计算距离然后只是一个简单的三角学问题（以下突出显示）：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The calculated distance is equal to the wavelength of the color that we will
    perceive. However, Blender does not work with wavelengths but with RGB colors
    so we still need to convert this wavelength to a (R, G, B) tuple that represents
    the same color. This might be done by applying some spectral formula (see for
    example [http://www.philiplaven.com/p19.html](http://www.philiplaven.com/p19.html))
    but it might even be more versatile to scale this calculated distance and use
    it as an input for a color band. In this way we might produce non-physically accurate
    iridescence (if desired):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出的距离等于我们将感知到的颜色的波长。然而，Blender 不使用波长，而是使用 RGB 颜色，因此我们仍然需要将这个波长转换为表示相同颜色的 (R,
    G, B) 元组。这可能通过应用某些光谱公式来完成（例如，参见 [http://www.philiplaven.com/p19.html](http://www.philiplaven.com/p19.html)），但这甚至可能更灵活，通过缩放计算出的距离并将其用作颜色带的输入。这样我们可能会产生非物理准确的彩虹效果（如果需要的话）：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To use this Pynode there are some things to keep in mind. First, make sure that
    the calculated color only affects the specular color of the soap bubble material
    otherwise everything will show up washed out.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此Pynode，有一些事情需要注意。首先，确保计算出的颜色只影响肥皂泡材料的镜面颜色，否则一切都会显得淡化。
- en: Furthermore, it is important to add some variation to the thickness of the layer
    as no real soap bubble has an exactly uniform thickness. The choice of noise texture
    can make quite a difference to the appearance. In the next node setup example,
    we have added the contribution of a slightly noisy wood texture to obtain the
    swirly bands often seen on soap films.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，添加一些厚度变化是很重要的，因为没有任何真实的肥皂泡具有完全均匀的厚度。噪声纹理的选择可以显著影响外观。在下一个节点设置示例中，我们添加了略微噪动的木纹纹理的贡献，以获得肥皂膜上常见的螺旋带。
- en: Finally, make the material of the soap film very transparent but with a high
    specular reflectance. Experiment with the values to get the exact effect desired
    and do take into account the lighting setup. The example shown in the illustration
    has been tweaked to get some of the issues across in a black and white rendition
    and is therefore not realistic, but the setup in the example file `iridescence.blend`
    is tweaked to produce a pleasingly colorful result when rendered.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使肥皂膜的材料非常透明但具有高镜面反射率。实验不同的值以获得所需的确切效果，并且确实要考虑照明设置。图示中的示例经过调整，以便在黑白呈现中传达一些问题，因此并不真实，但示例文件`iridescence.blend`中的设置经过调整，以便在渲染时产生令人愉悦的色彩效果。
- en: '![Soap bubbles—a view-dependent shader](img/0400-07-20.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![肥皂泡——视图相关的着色器](img/0400-07-20.jpg)'
- en: 'The use of a color ramp and a noise texture is shown in the previous screenshot
    where we added some division nodes to scale our distance to a range within [0,1]
    that can be used as input for the color ramp:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的屏幕截图显示了使用颜色渐变和噪声纹理的使用，其中我们添加了一些除法节点来缩放我们的距离到一个范围在[0,1]内，这可以用作颜色渐变的输入：
- en: '![Soap bubbles—a view-dependent shader](img/0400-07-21.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![肥皂泡——视图相关的着色器](img/0400-07-21.jpg)'
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw that Blender''s lack of a compiled shader language
    does not prevent its use from designing custom patterns and shaders. Pynodes are
    an integrated part of Blender''s node system and we saw how to use them to create
    effects from simple color patterns to fairly-complex animated ripples. Specifically,
    we learned:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Blender缺乏编译着色器语言并不会阻止其用于设计自定义图案和着色器。Pynodes是Blender节点系统的一个集成部分，我们看到了如何使用它们从简单的颜色图案到相当复杂的动画涟漪来创建效果。具体来说，我们学习了：
- en: How to write Pynodes that create simple color patterns
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写生成简单颜色图案的Pynodes
- en: How to write Pynodes that produce patterns with normals
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写生成具有法线图案的Pynodes
- en: How to write animated Pynodes
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写动画Pynodes
- en: How to write height and slope dependent materials
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写高度和坡度相关的材质
- en: How to create shaders that react to the angle of incident light
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建对入射光角度做出反应的着色器
- en: In the next chapter, we will look into the automation of the rendering process
    as a whole.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨整个渲染过程的自动化。
