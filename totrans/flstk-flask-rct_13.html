<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-237"><a id="_idTextAnchor273"/>13</h1>
<h1 id="_idParaDest-238"><a id="_idTextAnchor274"/>Error Handling</h1>
<p><strong class="bold">Error handling</strong> is a <a id="_idIndexMarker942"/>critical component in the user experience of any web application. <strong class="bold">Flask</strong> provides <a id="_idIndexMarker943"/>several built-in tools and options for handling errors in a clean and efficient manner. The goal of error handling is to catch and respond to errors that may occur during the execution of your application such as runtime errors, exceptions, and invalid user inputs.</p>
<p>Flask provides a built-in debugger that can be used to catch and diagnose errors during development. So, why is the concept of error handling so important in any web application? An error-handling mechanism provides meaningful error messages to users when things go south when expected to go north, helping to maintain the overall quality of the user experience. Also, proactive error handling makes debugging easy.</p>
<p>If error-handling implementation is well thought out, then debugging issues and identifying the root causes of problems in the application becomes easier. As a developer, you would also want to increase the reliability of your application by anticipating and handling potential errors. This invariably makes your application more reliable and less likely to break under unexpected conditions.</p>
<p>In this chapter, we will explore the different strategies and techniques for handling errors in Flask web <a id="_idIndexMarker944"/>applications. You will<a id="_idIndexMarker945"/> understand and learn how to use the built-in <strong class="bold">Flask debugger</strong>, implement <strong class="bold">error handlers</strong>, and create <a id="_idIndexMarker946"/>custom <strong class="bold">error pages</strong> in order to provide meaningful feedback to the user.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Using the Flask debugger</li>
<li>Creating error handlers</li>
<li>Creating custom error pages</li>
<li>Tracking events in your application</li>
<li>Sending error emails to administrators</li>
</ul>
<h1 id="_idParaDest-239"><a id="_idTextAnchor275"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter13">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter13</a>.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor276"/>Using the Flask debugger</h1>
<p>Flask<a id="_idIndexMarker947"/> as a lightweight Python web framework is widely used for building web applications. One of the out-of-the-box benefits of using Flask is its built-in debugger, which provides a powerful tool for identifying and fixing errors in your application.</p>
<p>When an error occurs in your Flask application, the debugger will automatically be activated. The debugger will provide detailed information about the error, including a stack trace, source code context, and any variables that were in scope at the time the error occurred. This information is golden for determining the root cause of the error and possible ideas for fixing it.</p>
<p>The Flask debugger<a id="_idIndexMarker948"/> also provides some interactive tools that can be used to inspect the state of your application and understand what is happening. For instance, you can evaluate expressions and examine the values of variables. You can also set breakpoints in your code, and step through your code line by line to see how it is executed.</p>
<p>Let’s examine this code snippet for illustration:</p>
<pre class="source-code">import pdb@app.route("/api/v1/debugging")
def debug():
    a = 10
    b = 20
    pdb.set_trace()
    c = a + b
    return f"The result <a id="_idTextAnchor277"/>is: {c}"</pre>
<p>In this instance, you can set a breakpoint at the line before <code>c = a + b</code>, as done in the preceding code, and run the application. When the breakpoint is hit, you can enter the debugger and inspect the values of <code>a</code>, <code>b</code>, and <code>c</code>. You can also evaluate expressions and see their results. For instance, to evaluate the expression <code>a + b</code>, you can type <code>a + b</code> in the debugger’s command prompt and hit <em class="italic">Enter</em>. The result, <code>30</code>, will be displayed. You can also step through your code line by line by using the <code>n</code> command to go to the next line, and the <code>c</code> command to continue execution until the next breakpoint.</p>
<p>In this way, you can use the Flask debugger’s interactive tools to understand what is happening in your application and debug it more effectively. This can be especially useful when dealing with large or complex code bases. The Flask debugger’s interactive tools are useful when it is difficult to understand what is causing an error without additional tools and information.</p>
<p>Aside from interactive tools, Flask also provides a debug mode that can be enabled to provide more detailed error messages. When the debug mode is enabled, Flask will display detailed error pages with information about the error including a stack trace and the source code context. This information can be extremely helpful for debugging complex issues.</p>
<p>To enable the<a id="_idIndexMarker949"/> Flask debugger, simply set the <code>debug</code> configuration value to <code>True</code> in your Flask application. In this book project, we set this parameter in the <code>.env</code> file. You should only use this in development, as it can reveal sensitive information about your application to anyone who has access to it.</p>
<p>Additionally, Flask allows third-party extensions that can be used to enhance the debugging experience. For instance, <code>Flask-DebugToolbar</code> provides a toolbar that can be added to your application to display information about the current request and its context.</p>
<p>Flask’s built-in debugger is a <a id="_idIndexMarker950"/>powerful tool that can help you quickly identify and fix errors in your application. Whether you are working on a small project or an enterprise-grade application, the debugger provides valuable information that can help you resolve issues and improve the reliability and performance of your application.</p>
<p>Next, we will discuss and implement error handlers in Flask web applications.</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor278"/>Creating error handlers</h1>
<p>Flask also<a id="_idIndexMarker951"/> provides a mechanism for handling errors called error handlers. Error handlers are functions that are invoked when a specific error occurs in your application. These functions can be used to return custom error pages, log information about the error, or perform any other action that is appropriate for the error. To define an error handler in the Flask web application, you need to use the <code>errorhandler</code> decorator.</p>
<p>The decorator takes the error code as its argument, and the function that it decorates is the error handler that will be invoked when that error occurs. The error handler function takes an error object as its argument, which provides information about the error that occurred. This information can be used to provide a more detailed error response to the client or to log additional information about the error for debugging purposes.</p>
<p>In Flask backend and <strong class="bold">React</strong> frontend applications, error handling is a crucial step in ensuring a smooth user experience. As mentioned earlier, the goal of error handlers is to provide meaningful feedback to the user when something goes wrong, rather than simply returning a generic error message.</p>
<p>For instance, you can define error handlers for errors <code>400</code>, <code>404</code>, and <code>500</code>.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor279"/>Flask backend</h2>
<p>The following <a id="_idIndexMarker952"/>code shows error handlers that are created for the HTTP <a id="_idIndexMarker953"/>error codes <code>404</code> (not found), <code>400</code> (bad request), and <code>500</code> (internal server error):</p>
<pre class="source-code">from flask import jsonify@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Not found'}), 404
@app.errorhandler(400)
def bad_request(error):
    return jsonify({'error': 'Bad request'}), 400
@app.errorhandler(500)
def internal_server_error(error):
    return jsonify({'error': 'internal server error'}), 500</pre>
<p>The <code>not_found</code>, <code>bad_request</code>, and <code>internal_server_error</code> functions return a <code>JSON</code> response <a id="_idIndexMarker954"/>containing an error message, along with the <a id="_idIndexMarker955"/>corresponding HTTP error codes.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor280"/>React frontend</h2>
<p>In the React frontend, you can <a id="_idIndexMarker956"/>handle these errors by making an HTTP request to the<a id="_idIndexMarker957"/> Flask backend and checking the response for errors. For example, you can <a id="_idIndexMarker958"/>use <strong class="bold">Axios</strong> in React:</p>
<pre class="source-code">import React, { useState, useEffect } from 'react';import axios from 'axios';
const Speakers = () =&gt; {
    const [error, setError] = useState(null);
    useEffect(() =&gt; {
        axios.get('/api/v1/speakers')
        .then(response =&gt; {
            // handle success
        })
        .catch(error =&gt; {
            switch (error.response.status) {
                case 404:
                    setError('Resource not found.');
                    break;
                case 400:
                    setError('Bad request');
                    break;
                case 500:
                    setError('An internal server error
                        occurred.');
                    break;
                default:
                    setError('An unexpected error
                        occurred.');
                    break;
            }
        });
    }, []);
    return (
        &lt;div&gt;
            {error ? &lt;p&gt;{error}&lt;/p&gt; : &lt;p&gt;No error&lt;/p&gt;}
        &lt;/div&gt;
    );
};
export default Speakers;</pre>
<p>The preceding<a id="_idIndexMarker959"/> error-handling code illustrates a React frontend communicating with <a id="_idIndexMarker960"/>a Flask backend API. The code imports <code>React</code>, <code>useState</code>, and <code>useEffect</code> hooks, as well as the <code>axios</code> library for making API requests. The code then defines a functional <code>Speakers</code> component that makes an API <code>GET</code> request to the <code>/api/v1/speakers</code> endpoint at the backend.</p>
<p>The <code>useEffect</code> hook is used to manage the API call, and the response is handled in a <code>.then()</code> block for success or a <code>.catch()</code> block for errors. In the <code>.catch()</code> block, the error response status is checked and a specific error message is set based on the status code. For instance, if the status code is <code>404</code>, <code>Resource not found</code> will be set as the error.</p>
<p>The error<a id="_idIndexMarker961"/> message is then displayed in the UI using conditional rendering, with the <code>No error</code> text being displayed if there is no error. The error message is stored<a id="_idIndexMarker962"/> in the state using the <code>useState</code> hook, with the initial value being <code>null</code>.</p>
<p>Next, we will discuss and implement custom error pages in Flask web applications.</p>
<h1 id="_idParaDest-244"><a id="_idTextAnchor281"/>Creating custom error pages</h1>
<p>In addition to error <a id="_idIndexMarker963"/>handlers in Flask, you can also create custom error pages that provide a better user experience. When an error occurs in your application, the error handler can return a custom error page with information about the error, instructions for resolving the issue, or any other content that may be appropriate.</p>
<p>To create a custom error page in Flask, simply create an error handler as described in the preceding section and return a <code>JSON</code> response that contains the content for the error page.</p>
<p>For instance, let’s take a look at the <code>JSON</code> response containing a custom error message in the following code:</p>
<pre class="source-code">@app.errorhandler(404)def not_found(error):
    return jsonify({'error': 'Not found'}), 404</pre>
<p>The preceding code returns a <code>JSON</code> response containing an error message, along with the corresponding HTTP error codes, when a <code>404</code> error occurs. Let’s define the React frontend to handle the UI with an <code>ErrorPage</code> component:</p>
<pre class="source-code">import React from 'react';const ErrorPage = ({ error }) =&gt; (
    &lt;div&gt;
        &lt;h1&gt;An error has occurred&lt;/h1&gt;
        &lt;p&gt;{error}&lt;/p&gt;
    &lt;/div&gt;
);
export default ErrorPage;</pre>
<p>The preceding code shows the <code>ErrorPage</code> component that takes an error prop and displays it in the error message. You can use this component in your application to display the custom error page whenever an error occurs.</p>
<p>You can <a id="_idIndexMarker964"/>simply add the <code>ErrorPage</code> component to the rest of the application. For instance, use the following code to add the <code>ErrorPage</code> component to the <code>Speaker</code> component:</p>
<pre class="source-code">import React, { useState, useEffect } from 'react';import axios from 'axios';
import ErrorPage from './ErrorPage';
const Speakers = () =&gt; {
    const [error, setError] = useState(null);
    useEffect(() =&gt; {
        axios.get('/api/v1/speakers')
            .then(response =&gt; {
                // handle success
            })
            .catch(error =&gt; {
                setError(error.response.data.error);
            });
    }, []);
    if (error) {
        return &lt;ErrorPage error={error} /&gt;;
    }
    return (
        // rest of your application
    );
};
export default Speakers;</pre>
<p>Next, we will discuss how to track and log events in Flask web applications.</p>
<h1 id="_idParaDest-245"><a id="_idTextAnchor282"/>Tracking events in your application</h1>
<p>Flask allows you to track events in your <a id="_idIndexMarker965"/>application in an elegant way. This is <a id="_idIndexMarker966"/>critical to identifying potential issues. By tracking events, you can get a better understanding of what is happening in your application and make informed decisions about how to improve the situation.</p>
<p>There are several ways to track events in Flask, including using built-in logging functionality, third-party logging services, or custom code tracking. For instance, you can use the Python <code>logging</code> module to log information about your application activities to a file or to the console.</p>
<p>Using the logging module is easy; simply import <code>logging</code> into your Flask application and configure it to log information at the appropriate level. For instance, the following code configures the <a id="_idIndexMarker967"/>logging module to log information to a file<a id="_idIndexMarker968"/> named <code>error.log</code>:</p>
<pre class="source-code">import loggingfrom flask import Flask
app = Flask(__name__)
# Set up a logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
# Specify the log file
file_handler = logging.FileHandler('error.log')
file_handler.setLevel(logging.DEBUG)
# Add the handler to the logger
logger.addHandler(file_handler)
@app.route('/logger')
def logger():
    logger.debug('This is a debug message')
    logger.info('This is an info message')
    logger.warning('This is a warning message')
    logger.error('This is an error message')
    return 'Log messages have been written to the log file'
if __name__ == '__main__':
    app.run()</pre>
<p>The preceding code demonstrates the implementation of the logging module in a Flask web application. The code sets up a logger object using the <code>logging.getLogger(__name__)</code> method. The logger is set to the debug level with <code>logger.setLevel(logging.DEBUG)</code>. A <code>FileHandler</code> object is created with <code>file_handler = logging.FileHandler('error.log')</code>, and the handler is set to the debug level as well with <code>file_handler.setLevel(logging.DEBUG)</code>.</p>
<p>The handler is added to the logger object with <code>logger.addHandler(file_handler)</code>. In the <code>logger()</code> function, there are four logging methods called <code>debug()</code>, <code>info()</code>, <code>warning()</code>, and <code>error()</code>. These methods log messages to the log file with the respective log levels (debug, info, warning, and error). The messages logged are simple string messages.</p>
<p>Furthermore, when<a id="_idIndexMarker969"/> tracking events in Flask applications, you can use<a id="_idIndexMarker970"/> a third-party logging service. Using third-party logging services with Flask can provide more advanced logging features such as centralized log management, real-time log searching, and alerting.</p>
<p>For <a id="_idIndexMarker971"/>instance, you can<a id="_idIndexMarker972"/> use <a id="_idIndexMarker973"/>cloud-based log management services such as <strong class="bold">AWS CloudWatch</strong>, <strong class="bold">Loggly</strong>, and <strong class="bold">Papertrail</strong>.</p>
<p>Let’s examine briefly the implementation of AWS CloudWatch. AWS CloudWatch is a logging service that provides log management and monitoring for AWS resources. To use AWS CloudWatch with Flask, you can use <a id="_idIndexMarker974"/>the <strong class="bold">CloudWatch Logs</strong> API to send log data directly to AWS CloudWatch.</p>
<p>The <a id="_idIndexMarker975"/>following steps implement logging in Flask applications using AWS CloudWatch:</p>
<ol>
<li>Set up an AWS account and create a <strong class="bold">CloudWatch </strong><strong class="bold">Log Group</strong>.</li>
<li>Install the <code>boto3</code> library, which provides a Python interface to the AWS CloudWatch API. Install <code>Boto2</code> with <code>pip install boto3</code> and ensure your virtual environment is activated.</li>
<li>In your Flask application, import the <code>boto3</code> library and configure it with your AWS credentials.</li>
<li>Create a logger and set its log level to the desired level of verbosity.</li>
<li>In your application code, use the logger to log messages at various levels such as info, warning, error, and so on.</li>
<li>Configure the logger to send logs to AWS CloudWatch. This can be done by creating a custom handler that sends log messages to CloudWatch using the <code>boto3</code> library.</li>
<li>Deploy your<a id="_idIndexMarker976"/> Flask application and monitor your logs in AWS CloudWatch.</li>
</ol>
<p>Let’s explore<a id="_idIndexMarker977"/> the code <a id="_idIndexMarker978"/>implementation:</p>
<pre class="source-code">import boto3import logging
from flask import Flask
app = Flask(__name__)
boto3.setup_default_session(
    aws_access_key_id='&lt;your-access-key-id&gt;',
    aws_secret_access_key='&lt;your-secret-access-key&gt;',
    region_name='&lt;your-region&gt;')
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
cloudwatch = boto3.client('logs')
log_group_name = '&lt;your-log-group-name&gt;'
class CloudWatchHandler(logging.Handler):
    def emit(self, record):
        log_message = self.format(record)
        cloudwatch.put_log_events(
            logGroupName=log_group_name,
            logStreamName='&lt;your-log-stream-name&gt;',)
if __name__ == '__main__':
    app.run()</pre>
<p>The <a id="_idIndexMarker979"/>full source code can be found on GitHub.</p>
<p>The preceding code shows<a id="_idIndexMarker980"/> the implementation of how to use the <code>boto3</code> library to send logs from a Flask application to AWS CloudWatch. It works as follows:</p>
<ol>
<li>The <code>boto3</code> library is imported and a default session is set up with the specified <code>AWS access key ID</code>, <code>secret access key</code>, and <code>region name</code>.</li>
<li>A logger object is created using the <code>logging</code> module and the logging level is set to <code>DEBUG</code>.</li>
<li>A <code>CloudWatch</code> client object is created using the <code>boto3</code> library.</li>
<li>A custom handler class named <code>CloudWatchHandler</code> is created that inherits from the <code>logging.Handler</code> class and overrides its <code>emit</code> method. In the <code>emit</code> method, the log message is formatted and sent to <code>AWS CloudWatch</code> using the <code>put_log_events</code> method of the <code>CloudWatch</code> client.</li>
<li>An instance of the <code>CloudWatchHandler</code> class is created and its logging level is set to <code>DEBUG</code>. This handler is then added to the logger object.</li>
<li>A route named <code>/logging_with_aws_cloudwatch</code> is created that generates log messages of different levels (<code>debug</code>, <code>info</code>, <code>warning</code>, and <code>error</code>) using the logger object.</li>
</ol>
<p>Handling errors and tracking events in your Flask application is crucial to ensuring its reliability and robustness. With Flask’s built-in debugger, error handlers, custom error pages, logging, and third-party logging libraries, you can easily diagnose and resolve problems as they show up in Flask application development.</p>
<p>Now that<a id="_idIndexMarker981"/> you are able to implement Flask’s built-in debugger, error <a id="_idIndexMarker982"/>handlers, custom error pages, logging, and third-party logging libraries, wouldn’t it be nice if you had the means for the admins to receive email messages about errors in your application logs in real time?</p>
<p>Let’s work through how this can be implemented in Flask.</p>
<h1 id="_idParaDest-246"><a id="_idTextAnchor283"/>Sending error emails to administrators</h1>
<p>Sending error <a id="_idIndexMarker983"/>emails to administrators provides an<a id="_idIndexMarker984"/> efficient way to notify them about errors and issues in your Flask application. This allows you to quickly identify and resolve problems before they escalate into bigger issues and negatively impact the user experience. The benefits include timely identification and resolution of errors, improved system reliability, and reduced downtime.</p>
<p>Let’s delve into an example of sending error emails to administrators:</p>
<pre class="source-code">import smtplibfrom email.mime.text import MIMEText
from flask import Flask, request
app = Flask(__name__)
def send_email(error):
    try:
        msg = MIMEText(error)
        msg['Subject'] = 'Error in Flask Application'
        msg['From'] = 'from@example.com'
        msg['To'] = 'to@example.com'
        s = smtplib.SMTP('localhost')
        s.send_message(msg)
        s.quit()
    except Exception as e:
        print(f'Error sending email: {e}')
@app.errorhandler(500)
def internal_server_error(error):
    send_email(str(error))
    return 'An error occurred and an email was sent to the
        administrator.', 500
if __name__ == '__main__':
    app.run()</pre>
<p>The preceding <a id="_idIndexMarker985"/>code demonstrates the implementation of <a id="_idIndexMarker986"/>sending error emails to notify administrators about errors in a Flask application. It works as follows:</p>
<ol>
<li>The code uses the <code>smtplib</code> and <code>email.mime.text</code> libraries to create and send an email message.</li>
<li>The <code>send_email(error)</code> function takes an error message as a parameter and creates an email message using the <code>MIMEText</code> object. The <code>subject</code>, <code>sender email address</code>, <code>recipient email address</code>, and <code>error message</code> are set for the email. The email is then sent using the <code>smtplib</code> library through the local email server.</li>
</ol>
<p>Flask’s <code>errorhandler</code> decorator<a id="_idIndexMarker987"/> is used to catch any <code>500</code> internal <a id="_idIndexMarker988"/>server errors that occur in the application. The <code>internal_server_error</code> function is called when an error <code>500</code> occurs, and it calls the <code>send_email</code> function with the error message passed as a parameter. The function returns a response to the user indicating that an error occurred and an email was sent to the administrator.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor284"/>Summary</h1>
<p>Error handling has been an essential aspect of software development from time immemorial. It is crucial to ensure that your Flask web application can handle errors effectively. We discussed the Flask debugger, error handlers, and custom error pages. With these, you can provide meaningful feedback to users and help maintain the stability and reliability of your application.</p>
<p>As full stack developers, we reinforced the importance of keeping in mind that error handling is a continuous process. You should regularly review and update your error-handling strategies to ensure that your application remains robust and resilient. We also considered logging errors and sending notifications to administrators so that you can quickly identify and resolve any issues that may arise.</p>
<p>In short, a bug-free development experience remains a mirage for any professional developer. You should be prepared to effectively handle expected and unexpected errors in your web applications. By doing so, your application will continue to deliver value to your users, even in the face of unexpected errors and failures.</p>
<p>Next, we will explore modular development in Flask using <strong class="bold">Blueprints</strong>. With Blueprints and modular architecture, you can easily maintain and scale your React-Flask web applications.</p>
</div>
</body></html>