- en: Chapter 1. Developing RESTful APIs with Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：使用 Django 开发 RESTful API
- en: In this chapter, we will start our journey towards RESTful Web APIs with Python
    and four different Web frameworks. Python is one of the most popular and versatile
    programming languages. There are thousands of Python packages, which allow you
    to extend Python capabilities to any kind of domain you can imagine. We can work
    with many different Web frameworks and packages to easily build simple and complex
    RESTful Web APIs with Python, and we can also combine these frameworks with other
    Python packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Python 和四个不同的 Web 框架开始我们的 RESTful Web API 之旅。Python 是最受欢迎和最灵活的编程语言之一。有成千上万的
    Python 包，允许你扩展 Python 的能力到任何你能想象的领域。我们可以使用许多不同的 Web 框架和包，轻松地用 Python 构建 simple
    和 complex 的 RESTful Web API，我们还可以将这些框架与其他 Python 包结合使用。
- en: We can leverage our existing knowledge of Python and its packages to code the
    different pieces of our RESTful Web APIs and their ecosystem. We can use the object-oriented
    features to create code that is easier to maintain, understand, and reuse. We
    can use all the packages that we already know to interact with databases, Web
    services, and different APIs. Python makes it easy for us to create RESTful Web
    APIs. We don't need to learn another programming language; we can use the one
    we already know and love.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用我们对 Python 及其包的现有知识来编写我们 RESTful Web API 的不同部分及其生态系统。我们可以使用面向对象的功能来创建易于维护、理解和重用的代码。我们可以使用我们已知的所有包来与数据库、Web
    服务和不同的 API 交互。Python 使我们能够轻松创建 RESTful Web API。我们不需要学习另一种编程语言；我们可以使用我们已知的并喜爱的语言。
- en: 'In this chapter, we will start working with Django and Django REST Framework,
    and we will create a RESTful Web API that performs **CRUD** (**Create, Read, Update,
    and Delete**) operations on a simple SQLite database. We will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用 Django 和 Django REST 框架，并创建一个 RESTful Web API，该 API 在一个简单的 SQLite
    数据库上执行 **CRUD**（**创建、读取、更新和删除**）操作。我们将：
- en: Design a RESTful API to interact with a simple SQLite database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个与简单 SQLite 数据库交互的 RESTful API
- en: Understand the tasks performed by each HTTP method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个 HTTP 方法执行的任务
- en: Set up the virtual environment with Django REST framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Django REST 框架设置虚拟环境
- en: Create the database models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据库模型
- en: Manage serialization and deserialization of data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据的序列化和反序列化
- en: Write API views
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 API 视图
- en: Make HTTP requests to the API with command-line tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具向 API 发送 HTTP 请求
- en: Work with GUI tools to compose and send HTTP requests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GUI 工具来组合和发送 HTTP 请求
- en: Designing a RESTful API to interact with a simple SQLite database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与简单 SQLite 数据库交互的 RESTful API
- en: Imagine that we have to start working on a mobile App that has to interact with
    a RESTful API to perform CRUD operations with games. We don't want to spend time
    choosing and configuring the most appropriate **ORM** ( **Object-Relational Mapping**);
    we just want to finish the RESTful API as soon as possible to start interacting
    with it via our mobile App. We really want the games to persist in a database
    but we don't need it to be production-ready, and therefore, we can use the simplest
    possible relational database, as long as we don't have to spend time making complex
    installations or configurations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须开始开发一个需要与 RESTful API 交互以执行 CRUD 操作的游戏移动应用。我们不希望花费时间选择和配置最合适的 **ORM**（**对象关系映射**）；我们只想尽快完成
    RESTful API，以便通过我们的移动应用与之交互。我们确实希望游戏持久保存在数据库中，但我们不需要它具备生产就绪状态，因此，我们可以使用最简单的可能的关系数据库，只要我们不需要花费时间进行复杂的安装或配置。
- en: Django REST framework, also known as DRF, will allow us to easily accomplish
    this task and start making HTTP requests to our first version of our RESTful Web
    Service. In this case, we will work with a very simple SQLite database, the default
    database for a new Django REST framework project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架，也称为 DRF，将使我们能够轻松地完成这项任务，并开始向我们的第一个 RESTful Web 服务发送 HTTP 请求。在这种情况下，我们将使用一个非常简单的
    SQLite 数据库，它是新 Django REST 框架项目的默认数据库。
- en: 'First, we must specify the requirements for our main resource: a game. We need
    the following attributes or fields for a game:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须指定我们主要资源：游戏的要求。对于一个游戏，我们需要以下属性或字段：
- en: An integer identifier
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数标识符
- en: A name or title
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名称或标题
- en: A release date
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个发布日期
- en: A game category description, such as *3D RPG* and *2D mobile arcade*.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个游戏类别描述，例如 *3D RPG* 和 *2D 移动街机*。
- en: A `bool` value indicating whether the game was played at least once by a player
    or not
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `bool` 值，表示玩家是否至少玩过一次游戏
- en: In addition, we want our database to save a timestamp with the date and time
    in which the game was inserted in the database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望我们的数据库保存一个时间戳，记录游戏被插入数据库的日期和时间。
- en: The following table shows the HTTP verbs, the scope, and the semantics for the
    methods that our first version of the API must support. Each method is composed
    by an HTTP verb and a scope and all the methods have a well defined meaning for
    all games and collections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了我们的 API 第一版必须支持的 HTTP 动词、作用域和方法语义。每个方法由一个 HTTP 动词和一个作用域组成，并且所有方法对所有游戏和集合都有一个明确定义的意义。
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 动词** | **作用域** | **语义** |'
- en: '| `GET` | Collection of games | Retrieve all the stored games in the collection,
    sorted by their name in ascending order |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏集合 | 获取集合中存储的所有游戏，按名称升序排序 |'
- en: '| `GET` | Game | Retrieve a single game |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 游戏 | 获取单个游戏 |'
- en: '| `POST` | Collection of games | Create a new game in the collection |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 游戏集合 | 在集合中创建新游戏 |'
- en: '| `PUT` | Game | Update an existing game |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 游戏 | 更新现有游戏 |'
- en: '| `DELETE` | Game | Delete an existing game |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 游戏 | 删除现有游戏 |'
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In a RESTful API, each resource has its own unique URL. In our API, each game
    has its own unique URL.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 中，每个资源都有自己的唯一 URL。在我们的 API 中，每个游戏都有自己的唯一 URL。
- en: Understanding the tasks performed by each HTTP method
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个 HTTP 方法执行的任务
- en: In the preceding table, the `GET` HTTP verb appears twice but with two different
    scopes. The first row shows a `GET` HTTP verb applied to a collection of games
    (collection of resources) and the second row shows a `GET` HTTP verb applied to
    a game (a single resource).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个表中，`GET` HTTP 动词出现了两次，但作用域不同。第一行显示了一个应用于游戏集合（资源集合）的 `GET` HTTP 动词，而第二行显示了一个应用于单个游戏（单一资源）的
    `GET` HTTP 动词。
- en: Let's consider that `http://localhost:8000/games/` is the URL for the collection
    of games. If we add a number and a slash (`/`) to the preceding URL, we identify
    a specific game whose id or primary key is equal to the specified numeric value.
    For example, `http://localhost:8000/games/12/` identifies the game whose id or
    primary key is equal to `12`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 `http://localhost:8000/games/` 是游戏集合的 URL。如果我们向该 URL 添加一个数字和一个斜杠（`/`），我们就可以识别一个特定的游戏，其
    id 或主键等于指定的数值。例如，`http://localhost:8000/games/12/` 识别 id 或主键等于 `12` 的游戏。
- en: We have to compose and send an HTTP request with the following HTTP verb (`POST`)
    and request URL (`http://localhost:8000/games/`) to create a new game. In addition,
    we have to provide the **JSON** (**JavaScript Object Notation**) key-value pairs
    with the field names and the values to create the new game. As a result of the
    request, the server will validate the provided values for the fields, make sure
    that it is a valid game and persist it in the database.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下 HTTP 动词（`POST`）和请求 URL（`http://localhost:8000/games/`）来创建一个新的游戏。此外，我们必须提供
    **JSON**（**JavaScript 对象表示法**）键值对，包括字段名称和值以创建新游戏。作为请求的结果，服务器将验证提供的字段值，确保它是一个有效的游戏并将其持久化到数据库中。
- en: The server will insert a new row with the new game in the appropriate table
    and it will return a `201 Created` status code and a JSON body with the recently
    added game serialized to JSON, including the assigned id or primary key that was
    automatically generated by the database and assigned to the game object.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将在适当的表中插入一行新游戏，并返回一个 `201 已创建` 状态码，以及一个包含最近添加的游戏序列化为 JSON 的 JSON 主体，包括由数据库自动生成并分配给游戏对象的分配
    id 或主键。
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have to compose and send an HTTP request with the following HTTP verb (`GET`)
    and request URL (`http://localhost:8000/games/{id}/`) to retrieve the game whose
    id or primary key matches the specified numeric value in the place where `{id}`
    is written.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下 HTTP 动词（`GET`）和请求 URL（`http://localhost:8000/games/{id}/`）来检索 id 或主键与
    `{id}` 处指定的数值匹配的游戏。
- en: For example, if we use the request URL `http://localhost:8000/games/50/`, the
    server will retrieve the game whose id or primary key matches `50`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用请求 URL `http://localhost:8000/games/50/`，服务器将检索 id 或主键匹配 `50` 的游戏。
- en: 'As a result of the request, the server will retrieve a game with the specified
    id or primary key from the database and create the appropriate game object in
    Python. If a game is found, the server will serialize the game object into JSON
    and return a `200 OK` status code and a JSON body with the serialized game object.
    If no game matches the specified id or primary key, the server will return just
    a `404 Not Found` status:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为请求的结果，服务器将从数据库中检索具有指定ID或主键的游戏，并在Python中创建相应的游戏对象。如果找到游戏，服务器将游戏对象序列化为JSON，并返回`200
    OK`状态码和一个包含序列化游戏对象的JSON体。如果没有找到与指定ID或主键匹配的游戏，服务器将仅返回`404 Not Found`状态：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have to compose and send an HTTP request with the following HTTP verb (`PUT`)
    and request URL (`http://localhost:8000/games/{id}/`) to retrieve the game whose
    id or primary key matches the specified numeric value in the place where `{id}`
    is written and replace it with a game created with the provided data. In addition,
    we have to provide the JSON key-value pairs with the field names and the values
    to create the new game that will replace the existing one. As a result of the
    request, the server will validate the provided values for the fields, make sure
    that it is a valid game and replace the one that matches the specified id or primary
    key with the new one in the database. The id or primary key for the game will
    be the same after the update operation. The server will update the existing row
    in the appropriate table and it will return a `200 OK` status code and a JSON
    body with the recently updated game serialized to JSON. If we don't provide all
    the necessary data for the new game, the server will return a `400 Bad Request`
    status code. If the server doesn't find a game with the specified id, the server
    will return just a `404 Not Found` status.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下HTTP动词（`PUT`）和请求URL（`http://localhost:8000/games/{id}/`）来发送一个HTTP请求，以检索在`{id}`位置指定的数值匹配的游戏ID或主键，并用提供的数据创建的游戏替换它。此外，我们必须提供带有字段名称和值的JSON键值对，以创建将替换现有游戏的新游戏。作为请求的结果，服务器将验证提供的字段值，确保它是一个有效的游戏，并在数据库中将与指定ID或主键匹配的现有游戏替换为新游戏。更新操作后，游戏的ID或主键将保持不变。服务器将在适当的表中更新现有行，并返回一个`200
    OK`状态码和一个包含序列化到JSON的最近更新的游戏的JSON体。如果我们没有提供新游戏所需的所有必要数据，服务器将返回`400 Bad Request`状态码。如果服务器找不到指定ID的游戏，服务器将仅返回`404
    Not Found`状态。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have to compose and send an HTTP request with the following HTTP verb (`DELETE`)
    and request URL (`http://localhost:8000/games/{id}/`) to remove the game whose
    id or primary key matches the specified numeric value in the place where `{id}`
    is written. For example, if we use the request URL `http://localhost:8000/games/20/`,
    the server will delete the game whose id or primary key matches `20`. As a result
    of the request, the server will retrieve a game with the specified id or primary
    key from the database and create the appropriate game object in Python. If a game
    is found, the server will request the ORM to delete the game row associated with
    this game object and the server will return a `204 No Content` status code. If
    no game matches the specified id or primary key, the server will return just a
    `404 Not Found` status.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下HTTP动词（`DELETE`）和请求URL（`http://localhost:8000/games/{id}/`）来发送一个HTTP请求，以删除ID或主键与在`{id}`位置指定的数值相匹配的游戏。例如，如果我们使用请求URL
    `http://localhost:8000/games/20/`，服务器将删除ID或主键与`20`相匹配的游戏。作为请求的结果，服务器将从数据库中检索具有指定ID或主键的游戏，并在Python中创建相应的游戏对象。如果找到游戏，服务器将请求ORM删除与该游戏对象关联的游戏行，并返回`204
    No Content`状态码。如果没有找到与指定ID或主键匹配的游戏，服务器将仅返回`404 Not Found`状态。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Working with lightweight virtual environments
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用轻量级虚拟环境
- en: Throughout this book, we will be working with different frameworks and libraries,
    and therefore, it is convenient to work with virtual environments. We will work
    with the lightweight virtual environments introduced in Python 3.3 and improved
    in Python 3.4\. However, you can also choose to use the popular `virtualenv` ([https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv))
    third-party virtual environment builder or the virtual environment options provided
    by your Python IDE.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用不同的框架和库，因此，使用虚拟环境是很方便的。我们将使用Python 3.3中引入并Python 3.4中改进的轻量级虚拟环境。然而，你也可以选择使用流行的`virtualenv`
    ([https://pypi.python.org/pypi/virtualenv](https://pypi.python.org/pypi/virtualenv))
    第三方虚拟环境构建器或你的Python IDE提供的虚拟环境选项。
- en: You just have to make sure that you activate your virtual environment with the
    appropriate mechanism when it is necessary to do so, instead of following the
    step explained to activate the virtual environment generated with the `venv` module
    integrated in Python. You can read more information about PEP 405 Python Virtual
    Environment that introduced the `venv` module at [https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需确保在需要时使用适当的机制激活你的虚拟环境，而不是遵循使用Python中集成的`venv`模块生成的虚拟环境的步骤。你可以在[https://www.python.org/dev/peps/pep-0405](https://www.python.org/dev/peps/pep-0405)上阅读更多关于引入`venv`模块的PEP
    405 Python虚拟环境的信息。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Each virtual environment we create with `venv` is an isolated environment and
    it will have its own independent set of installed Python packages in its site
    directories. When we create a virtual environment with `venv` in Python 3.4 and
    greater, pip is included in the new virtual environment. In Python 3.3, it was
    necessary to manually install pip after creating the virtual environment. Notice
    that the instructions provided are compatible with Python 3.4 or greater, including
    Python 3.5.x. The following commands assume that you have Python 3.5.x installed
    on macOS, Linux, or Windows.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`venv`创建的每个虚拟环境都是一个隔离的环境，并且它将在其site目录中拥有自己独立的一组已安装的Python包。当我们使用Python 3.4及更高版本中的`venv`创建虚拟环境时，pip将包含在新的虚拟环境中。在Python
    3.3中，创建虚拟环境后需要手动安装pip。请注意，提供的说明与Python 3.4或更高版本兼容，包括Python 3.5.x。以下命令假设你在macOS、Linux或Windows上安装了Python
    3.5.x。
- en: First, we have to select the target folder or directory for our virtual environment.
    The following is the path we will use in the example for macOS and Linux. The
    target folder for the virtual environment will be the `PythonREST/Django` folder
    within our home directory. For example, if our home directory in macOS or Linux
    is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/PythonREST/Django`.
    You can replace the specified path with your desired path in each command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须选择我们的虚拟环境的目标文件夹或目录。以下是在示例中我们将使用的路径，用于macOS和Linux。虚拟环境的目标文件夹将是我们主目录中的`PythonREST/Django`文件夹。例如，如果我们的macOS或Linux中的主目录是`/Users/gaston`，虚拟环境将在`/Users/gaston/PythonREST/Django`中创建。你可以在每个命令中将指定的路径替换为你想要的路径。
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following is the path we will use in the example for Windows. The target
    folder for the virtual environment will be the `PythonREST/Django` folder within
    our user profile folder. For example, if our user profile folder is `C:\Users\Gaston`,
    the virtual environment will be created within `C:\Users\gaston\PythonREST\Django`.
    You can replace the specified path with your desired path in each command.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在示例中我们将使用的路径。虚拟环境的目标文件夹将是我们用户配置文件中的`PythonREST/Django`文件夹。例如，如果我们的用户配置文件是`C:\Users\Gaston`，虚拟环境将在`C:\Users\gaston\PythonREST\Django`中创建。你可以在每个命令中将指定的路径替换为你想要的路径。
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we have to use the `-m` option followed by the `venv` module name and the
    desired path to make Python run this module as a script and create a virtual environment
    in the specified path. The instructions are different depending on the platform
    in which we are creating the virtual environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须使用`-m`选项后跟`venv`模块名称和所需的路径，以便Python将此模块作为脚本运行并创建指定路径中的虚拟环境。根据我们创建虚拟环境的平台，说明可能会有所不同。
- en: 'Open a Terminal in macOS or Linux and execute the following command to create
    a virtual environment:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中打开一个终端并执行以下命令以创建虚拟环境：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Windows, execute the following command to create a virtual environment:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，执行以下命令以创建虚拟环境：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding command doesn't produce any output. The script created the specified
    target folder and installed pip by invoking `ensurepip` because we didn't specify
    the `--without-pip` option. The specified target folder has a new directory tree
    that contains Python executable files and other files that indicate that it is
    a virtual environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个命令不会产生任何输出。脚本创建了指定的目标文件夹，并通过调用`ensurepip`安装了pip，因为我们没有指定`--without-pip`选项。指定的目标文件夹包含一个新的目录树，其中包含Python可执行文件和其他表明它是一个虚拟环境的文件。
- en: 'The `pyenv.cfg` configuration file specifies different options for the virtual
    environment and its existence is an indicator that we are in the root folder for
    a virtual environment. In OS and Linux, the folder will have the following main
    sub-folders—`bin`, `include`, `lib`, `lib/python3.5` and `lib/python3.5/site-packages`.
    In Windows, the folder will have the following main sub-folders—`Include`, `Lib`,
    `Lib\site-packages`, and `Scripts`. The directory trees for the virtual environment
    in each platform are the same as the layout of the Python installation in these
    platforms. The following screenshot shows the folders and files in the directory
    trees generated for the `Django01` virtual environment in macOS:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyenv.cfg`配置文件指定了虚拟环境的不同选项，其存在表明我们处于虚拟环境的根目录。在 OS 和 Linux 中，该文件夹将包含以下主要子文件夹—`bin`、`include`、`lib`、`lib/python3.5`和`lib/python3.5/site-packages`。在
    Windows 中，该文件夹将包含以下主要子文件夹—`Include`、`Lib`、`Lib\site-packages`和`Scripts`。每个平台中虚拟环境的目录树与这些平台中
    Python 安装的布局相同。以下截图显示了在 macOS 中为`Django01`虚拟环境生成的目录树中的文件夹和文件：'
- en: '![Working with lightweight virtual environments](img/image_01_001.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用轻量级虚拟环境](img/image_01_001.jpg)'
- en: 'The following screenshot shows the main folders in the directory trees generated
    for the virtual environments in Windows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了为 Windows 中的虚拟环境生成的目录树中的主要文件夹：
- en: '![Working with lightweight virtual environments](img/image_01_002.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![使用轻量级虚拟环境](img/image_01_002.jpg)'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: After we activate the virtual environment, we will install third-party packages
    into the virtual environment and the modules will be located within the `lib/python3.5/site-packages`
    or `Lib\site-packages` folder, based on the platform. The executables will be
    copied in the `bin` or `Scripts` folder, based on the platform. The packages we
    install won't make changes to other virtual environments or our base Python environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境后，我们将安装第三方软件包到虚拟环境中，模块将位于`lib/python3.5/site-packages`或`Lib\site-packages`文件夹中，具体取决于平台。可执行文件将被复制到`bin`或`Scripts`文件夹中，具体取决于平台。我们安装的软件包不会更改其他虚拟环境或我们的基础
    Python 环境。
- en: Now that we have created a virtual environment, we will run a platform-specific
    script to activate it. After we activate the virtual environment, we will install
    packages that will only be available in this virtual environment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个虚拟环境，我们将运行一个特定平台的脚本以激活它。激活虚拟环境后，我们将安装仅在此虚拟环境中可用的软件包。
- en: Run the following command in the terminal in macOS or Linux. Note that the results
    of this command will be accurate if you don't start a different shell than the
    default shell in the terminal session. In case you have doubts, check your terminal
    configuration and preferences.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 或 Linux 的终端中运行以下命令。请注意，如果您在终端会话中没有启动除默认 shell 之外的其他 shell，则此命令的结果将准确无误。如果您有疑问，请检查您的终端配置和首选项。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command will display the name of the shell you are using in the Terminal.
    In macOS, the default is `/bin/bash` and this means you are working with the bash
    shell. Depending on the shell, you must run a different command to activate the
    virtual environment in OS or Linux.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将显示您在终端中使用的 shell 名称。在 macOS 中，默认为`/bin/bash`，这意味着您正在使用 bash shell。根据 shell
    的不同，您必须在 OS 或 Linux 中运行不同的命令来激活虚拟环境。
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为在 macOS 或 Linux 中使用`bash` shell，请运行以下命令以激活虚拟环境。该命令也适用于`zsh` shell：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用`csh`或`tcsh` shell，请运行以下命令以激活虚拟环境：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If your Terminal is configured to use either the `fish` shell, run the following
    command to activate the virtual environment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用`fish` shell，请运行以下命令以激活虚拟环境：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Windows, you can run either a batch file in the command prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the command
    prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，您可以在命令提示符中运行批处理文件或在 Windows PowerShell 中运行脚本以激活虚拟环境。如果您更喜欢命令提示符，请在
    Windows 命令行中运行以下命令以激活虚拟环境：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you prefer the Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, notice that you should have scripts
    execution enabled in Windows PowerShell to be able to run the script:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢 Windows PowerShell，请启动它并运行以下命令来激活虚拟环境。然而，请注意，你需要在 Windows PowerShell
    中启用脚本执行才能运行脚本：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After you activate the virtual environment, the command prompt will display
    the virtual environment root folder name enclosed in parenthesis as a prefix of
    the default prompt to remind us that we are working in the virtual environment.
    In this case, we will see (`Django01`) as a prefix for the command prompt because
    the root folder for the activated virtual environment is `Django01`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活虚拟环境后，命令提示符将显示括号内的虚拟环境根文件夹名称作为默认提示的前缀，以提醒我们我们正在虚拟环境中工作。在这种情况下，我们将看到 (`Django01`)
    作为命令提示符的前缀，因为激活的虚拟环境的根文件夹是 `Django01`。
- en: 'The following screenshot shows the virtual environment activated in a macOS
    El Capitan terminal with a `bash` shell, after executing the previously shown
    commands:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在 macOS El Capitan 终端中执行之前显示的命令后激活的虚拟环境：
- en: '![Working with lightweight virtual environments](img/image_01_003.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用轻量级虚拟环境](img/image_01_003.jpg)'
- en: As we can see in the preceding screenshot, the prompt changed from `Gastons-MacBook-Pro:~
    gaston$` to `(Django01) Gastons-MacBook-Pro:~ gaston$` after the activation of
    the virtual environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中所见，在激活虚拟环境后，提示符从 `Gastons-MacBook-Pro:~ gaston$` 变成了 `(Django01)
    Gastons-MacBook-Pro:~ gaston$`。
- en: 'The following screenshot shows the virtual environment activated in a Windows
    10 Command Prompt, after executing the previously shown commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在执行之前显示的命令后，在 Windows 10 命令提示符中激活的虚拟环境：
- en: '![Working with lightweight virtual environments](img/image_01_004.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![使用轻量级虚拟环境](img/image_01_004.jpg)'
- en: As we can notice from the preceding screenshot, the prompt changed from `C:\Users\gaston\AppData\Local\Programs\Python\Python35`
    to `(Django01) C:\Users\gaston\AppData\Local\Programs\Python\Python35` after the
    activation of the virtual environment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的截图中所注意到的，在激活虚拟环境后，提示符从 `C:\Users\gaston\AppData\Local\Programs\Python\Python35`
    变成了 `(Django01) C:\Users\gaston\AppData\Local\Programs\Python\Python35`。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is extremely easy to deactivate a virtual environment generated with the
    previously explained process. In macOS or Linux, just type `deactivate` and press
    Enter. In a Windows command prompt, you have to run the `deactivate.bat` batch
    file included in the Scripts folder `(%USERPROFILE%\PythonREST\Django01\Scripts\deactivate.bat`
    in our example). In Windows PowerShell, you have to run the `Deactivate.ps1` script
    in the `Scripts` folder. The deactivation will remove all the changes made in
    the environment variables.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前解释的过程生成的虚拟环境非常容易取消激活。在 macOS 或 Linux 中，只需键入 `deactivate` 并按 Enter 键。在 Windows
    命令提示符中，你必须运行包含在 Scripts 文件夹中的 `deactivate.bat` 批处理文件（在我们的例子中是 `%USERPROFILE%\PythonREST\Django01\Scripts\deactivate.bat`）。在
    Windows PowerShell 中，你必须运行 `Scripts` 文件夹中的 `Deactivate.ps1` 脚本。取消激活将删除在环境变量中做出的所有更改。
- en: Setting up the virtual environment with Django REST framework
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Django REST 框架的虚拟环境
- en: 'We have created and activated a virtual environment. It is time to run many
    commands that will be the same for either macOS, Linux or Windows. Now, we must
    run the following command to install the Django Web framework:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建并激活了一个虚拟环境。现在是时候运行许多在 macOS、Linux 或 Windows 上都相同的命令了。现在，我们必须运行以下命令来安装
    Django Web 框架：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The last lines of the output will indicate that the `django` package has been
    successfully installed. Take into account that you may also see a notice to upgrade
    `pip`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `django` 包已成功安装。请注意，你也可能看到升级 `pip` 的通知。
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that we have installed Django Web framework, we can install Django REST
    framework. We just need to run the following command to install this package:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Django Web 框架，我们可以安装 Django REST 框架。我们只需运行以下命令来安装此包：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last lines for the output will indicate that the `djangorestframework`
    package has been successfully installed:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示 `djangorestframework` 包已成功安装：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Go to the root folder for the virtual environment-`Django01`. In macOS or Linux,
    enter the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 进入虚拟环境的根文件夹 `Django01`。在 macOS 或 Linux 中，输入以下命令：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In Windows, enter the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，输入以下命令：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the following command to create a new Django project named `gamesapi`.
    The command won''t produce any output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令以创建一个名为 `gamesapi` 的新 Django 项目。该命令不会产生任何输出：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The previous command created a `gamesapi` folder with other sub-folders and
    Python files. Now, go to the recently created `gamesapi` folder. Just execute
    the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令创建了一个包含其他子文件夹和 Python 文件的 `gamesapi` 文件夹。现在，前往最近创建的 `gamesapi` 文件夹。只需执行以下命令：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, run the following command to create a new Django app named `games` within
    the `gamesapi` Django project. The command won''t produce any output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令以在 `gamesapi` Django 项目中创建一个名为 `games` 的新 Django 应用。该命令不会产生任何输出：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The previous command created a new `gamesapi/games` sub-folder, with the following
    files:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令创建了一个新的 `gamesapi/games` 子文件夹，包含以下文件：
- en: '`__init__.py`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`admin.py`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin.py`'
- en: '`apps.py`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apps.py`'
- en: '`models.py`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.py`'
- en: '`tests.py`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests.py`'
- en: '`views.py`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py`'
- en: 'In addition, the `gamesapi/games` folder will have a `migrations` sub-folder
    with an `__init__.py` Python script. The following diagram shows the folders and
    files in the directory trees starting at the `gamesapi` folder:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`gamesapi/games` 文件夹将有一个 `migrations` 子文件夹，其中包含一个 `__init__.py` Python 脚本。以下图显示了以
    `gamesapi` 文件夹为起点的目录树中的文件夹和文件：
- en: '![Setting up the virtual environment with Django REST framework](img/image_01_005.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Django REST 框架设置虚拟环境](img/image_01_005.jpg)'
- en: 'Let''s check the Python code in the `apps.py` file within the `gamesapi/games`
    folder. The following lines shows the code for this file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `gamesapi/games` 文件夹内 `apps.py` 文件中的 Python 代码。以下行显示了该文件的代码：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code declares the `GamesConfig` class as a subclass of the `django.apps.AppConfig`
    class that represents a Django application and its configuration. The `GamesConfig`
    class just defines the `name` class attribute and sets its value to `'games'`.
    We have to add `games.apps.GamesConfig` as one of the installed apps in the `gamesapi/settings.py`
    file that configures settings for the `gamesapi` Django project. We built the
    preceding string as follows-app name + `.apps.` + class name, which is, `games`
    + `.apps.` + `GamesConfig`. In addition, we have to add the `rest_framework` app
    to make it possible for us to use Django REST Framework.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明 `GamesConfig` 类作为 `django.apps.AppConfig` 类的子类，该类代表 Django 应用及其配置。`GamesConfig`
    类仅定义了 `name` 类属性，并将其值设置为 `'games'`。我们必须将 `games.apps.GamesConfig` 添加到配置 `gamesapi`
    Django 项目的 `gamesapi/settings.py` 文件中的已安装应用之一。我们构建前面的字符串如下 - 应用名称 + `.apps.` +
    类名称，即 `games` + `.apps.` + `GamesConfig`。此外，我们还需要添加 `rest_framework` 应用，以便我们能够使用
    Django REST 框架。
- en: 'The `gamesapi/settings.py` file is a Python module with module-level variables
    that define the configuration of Django for the `gamesapi` project. We will make
    some changes to this Django settings file. Open the `gamesapi/settings.py` file
    and locate the following lines that specify the strings list that declares the
    installed apps:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`gamesapi/settings.py` 文件是一个 Python 模块，其中包含模块级别的变量，用于定义 `gamesapi` 项目的 Django
    配置。我们将对此 Django 设置文件进行一些修改。打开 `gamesapi/settings.py` 文件，找到以下指定已安装应用字符串列表的行：'
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following two strings to the `INSTALLED_APPS` strings list and save
    the changes to the `gamesapi/settings.py` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下两个字符串添加到 `INSTALLED_APPS` 字符串列表中，并将更改保存到 `gamesapi/settings.py` 文件中：
- en: '`''rest_framework''`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''rest_framework''`'
- en: '`''games.apps.GamesConfig''`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''games.apps.GamesConfig''`'
- en: 'The following lines show the new code that declares the `INSTALLED_APPS` strings
    list with the added lines highlighted. The code file for the sample is included
    in the `restful_python_chapter_01_01` folder:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了带有突出显示的新代码，该代码声明了带有添加行的 `INSTALLED_APPS` 字符串列表。示例代码文件包含在 `restful_python_chapter_01_01`
    文件夹中：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This way, we have added Django REST Framework and the `games` application to
    our initial Django project named `gamesapi`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就将 Django REST 框架和 `games` 应用添加到了我们的初始 Django 项目 `gamesapi` 中。
- en: Creating the models
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Now, we will create a simple `Game` model that we will use to represent and
    persist games. Open the `games/models.py` file. The following lines show the initial
    code for this file, with just one import statement and a comment that indicates
    we should create the models:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个简单的 `Game` 模型，我们将使用它来表示和持久化游戏。打开 `games/models.py` 文件。以下行显示了该文件的初始代码，仅包含一个导入语句和一个注释，指示我们应该创建模型：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following lines show the new code that creates a `Game` class, specifically,
    a `Game` model in the `games/models.py` file. The code file for the sample is
    included in the `restful_python_chapter_01_01` folder:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了在 `games/models.py` 文件中创建 `Game` 类的新代码，特别是创建 `Game` 模型。示例的代码文件包含在 `restful_python_chapter_01_01`
    文件夹中：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Game` class is a subclass of the `django.db.models.Model` class. Each defined
    attribute represents a database column or field. Django automatically adds an
    auto-increment integer primary key column named `id` when it creates the database
    table related to the model. However, the model maps the underlying `id` column
    in an attribute named `pk` for the model. We specified the field types, maximum
    lengths and defaults for many attributes. The class declares a Meta inner class
    that declares a ordering attribute and sets its value to a tuple of string whose
    first value is the `'name'` string, indicating that, by default, we want the results
    ordered by the `name` attribute in ascending order.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game` 类是 `django.db.models.Model` 类的子类。每个定义的属性代表一个数据库列或字段。当 Django 创建与模型相关的数据库表时，它会自动添加一个名为
    `id` 的自增整数主键列。然而，模型将底层的 `id` 列映射到名为 `pk` 的属性上。我们指定了许多属性的字段类型、最大长度和默认值。该类声明了一个名为
    Meta 的内部类，该类声明了一个排序属性并将其值设置为字符串的元组，其中第一个值是 `''name''` 字符串，表示我们默认希望按 `name` 属性的升序排序结果。'
- en: 'Then, it is necessary to create the initial migration for the new `Game` model
    we recently coded. We just need to run the following Python scripts and we will
    also synchronize the database for the first time. By default, Django uses an SQLite
    database. In this example, we will be working with this default configuration:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要为新近编写的 `Game` 模型创建初始迁移。我们只需运行以下 Python 脚本，我们还将首次同步数据库。默认情况下，Django 使用
    SQLite 数据库。在这个例子中，我们将使用这个默认配置：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The following lines show the output generated after running the preceding command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上述命令后生成的输出。
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output indicates that the `gamesapi/games/migrations/0001_initial.py` file
    includes the code to create the `Game` model. The following lines show the code
    for this file that was automatically generated by Django. The code file for the
    sample is included in the `restful_python_chapter_01_01` folder:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 输出表明 `gamesapi/games/migrations/0001_initial.py` 文件包含了创建 `Game` 模型的代码。以下行显示了由
    Django 自动生成的此文件的代码。示例的代码文件包含在 `restful_python_chapter_01_01` 文件夹中：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code defines a subclass of the `django.db.migrations.Migration` class named
    `Migration` that defines an operation that creates the `Game` model''s table.
    Now, run the following python script to apply all the generated migrations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个名为 `Migration` 的 `django.db.migrations.Migration` 类的子类，该类定义了一个创建 `Game`
    模型表的操作。现在，运行以下 Python 脚本来应用所有生成的迁移：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following lines show the output generated after running the preceding command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了运行上述命令后生成的输出：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After we run the preceding command, we will notice that the root folder for
    our `gamesapi` project now has a `db.sqlite3` file. We can use the SQLite command
    line or any other application that allows us to easily check the contents of the
    SQLite database to check the tables that Django generated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令后，我们会注意到我们的 `gamesapi` 项目根目录现在有一个 `db.sqlite3` 文件。我们可以使用 SQLite 命令行或任何其他允许我们轻松检查
    SQLite 数据库内容的程序来检查 Django 生成的表。
- en: In macOS and most modern Linux distributions, SQLite is already installed, and
    therefore, you can run the `sqlite3` command-line utility. However, in Windows,
    if you want to work with the `sqlite3.exe` command-line utility, you will have
    to download and install SQLite from its Web page-[http://www.sqlite.org](http://www.sqlite.org).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和大多数现代 Linux 发行版中，SQLite 已经安装，因此你可以运行 `sqlite3` 命令行工具。然而，在 Windows 上，如果你想要使用
    `sqlite3.exe` 命令行工具，你必须从其网页下载并安装 SQLite - [http://www.sqlite.org](http://www.sqlite.org)。
- en: 'Run the following command to list the generated tables:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以列出生成的表：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the following command to retrieve the SQL used to create the `games_game`
    table:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检索创建 `games_game` 表所用的 SQL：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following command will allow you to check the contents of the `games_game`
    table after we compose and send HTTP requests to the RESTful API and make CRUD
    operations to the `games_game` table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令允许你在向 RESTful API 发送 HTTP 请求并执行对 `games_game` 表的 CRUD 操作后，检查 `games_game`
    表的内容：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Instead of working with the SQLite command-line utility, you can use a GUI tool
    to check the contents of the SQLite database. DB Browser for SQLite is a useful
    multiplatform and free GUI tool that allows us to easily check the database contents
    of an SQLite database in macOS, Linux and Windows. You can read more information
    about this tool and download its different versions from [http://sqlitebrowser.org](http://sqlitebrowser.org).
    Once you installed the tool, you just need to open the `db.sqlite3` file and you
    can check the database structure and browse the data for the different tables.
    You can use also the database tools included in your favorite IDE to check the
    contents for the SQLite database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使用图形界面工具来检查SQLite数据库的内容，而不是使用SQLite命令行工具。DB Browser for SQLite是一个多平台且免费的图形界面工具，它允许我们在macOS、Linux和Windows上轻松检查SQLite数据库的内容。你可以从[http://sqlitebrowser.org](http://sqlitebrowser.org)了解更多关于这个工具的信息，并下载其不同版本。一旦安装了该工具，你只需打开`db.sqlite3`文件，就可以检查数据库结构并浏览不同表的数据。你也可以使用你喜欢的IDE中包含的数据库工具来检查SQLite数据库的内容。
- en: 'The SQLite database engine and the database file name are specified in the
    `gamesapi/settings.py` Python file. The following lines show the declaration of
    the `DATABASES` dictionary that contains the settings for all the database that
    Django uses. The nested dictionary maps the database named `default` with the
    `django.db.backends.sqlite3` database engine and the `db.sqlite3` database file
    located in the `BASE_DIR` folder (`gamesapi`):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库引擎和数据库文件名在`gamesapi/settings.py`Python文件中指定。以下行显示了包含Django使用的所有数据库设置的`DATABASES`字典的声明。嵌套字典将名为`default`的数据库映射到`django.db.backends.sqlite3`数据库引擎和位于`BASE_DIR`文件夹（`gamesapi`）中的`db.sqlite3`数据库文件：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After we executed the migrations, the SQLite database will have the following
    tables:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行迁移后，SQLite数据库将包含以下表：
- en: '`auth_group`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_group`'
- en: '`auth_group_permissions`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_group_permissions`'
- en: '`auth_permission`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_permission`'
- en: '`auth_user`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_user`'
- en: '`auth_user_groups`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_user_groups`'
- en: '`auth_user_groups_permissions`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`auth_user_groups_permissions`'
- en: '`django_admin_log`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_admin_log`'
- en: '`django_content_type`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_content_type`'
- en: '`django_migrations`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_migrations`'
- en: '`django_session`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django_session`'
- en: '`games_game`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`games_game`'
- en: '`sqlite_sequence`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite_sequence`'
- en: 'The `games_game` table persists in the database the `Game` class we recently
    created, specifically, the `Game` model. Django''s integrated ORM generated the
    `games_game` table based on our `Game` model. The `games_game` table has the following
    rows (also known as fields) with their SQLite types and all of them are not nullable:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`games_game`表在数据库中持久化了我们最近创建的`Game`类，具体来说是`Game`模型。Django的集成ORM根据我们的`Game`模型生成了`games_game`表。`games_game`表有以下行（也称为字段），以及它们的SQLite类型，所有这些字段都不是可空的：'
- en: '`id`: The integer primary key, an `autoincrement` row'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`: 整数主键，一个`autoincrement`行'
- en: '`created`: `datetime`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`: `datetime`'
- en: '`name`: `varchar(200)`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: `varchar(200)`'
- en: '`release_date`: `datetime`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release_date`: `datetime`'
- en: '`game_category`: `varchar(200)`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game_category`: `varchar(200)`'
- en: '`played`: `bool`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`played`: `bool`'
- en: 'The following lines show the SQL creation script that Django generated when
    we executed the migrations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了Django在执行迁移时生成的SQL创建脚本：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Django generated additional tables that it requires to support the Web framework
    and the authentication features that we will use later.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Django生成了额外的表，这些表是它支持Web框架和我们将要使用的认证功能所必需的。
- en: Managing serialization and deserialization
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理序列化和反序列化
- en: Our RESTful Web API has to be able to serialize and deserialize the game instances
    into JSON representations. With Django REST Framework, we just need to create
    a serializer class for the game instances to manage serialization to JSON and
    deserialization from JSON.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的RESTful Web API必须能够将游戏实例序列化为JSON表示，并从JSON反序列化。使用Django REST Framework，我们只需为游戏实例创建一个序列化器类来管理序列化为JSON和从JSON反序列化。
- en: Django REST Framework uses a two-phase process for serialization. The serializers
    are mediators between the model instances and Python primitives. Parser and renderers
    handle as mediators between Python primitives and HTTP requests and responses.
    We will configure our mediator between the `Game` model instances and Python primitives
    by creating a subclass of the `rest_framework.serializers.Serializer` class to
    declare the fields and the necessary methods to manage serialization and deserialization.
    We will repeat some of the information about the fields that we have included
    in the `Game` model so that we understand all the things that we can configure
    in a subclass of the Serializer class. However, we will work with shortcuts that
    will reduce boilerplate code later in the next examples. We will write less code
    in the next examples by using the `ModelSerializer` class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST 框架使用两阶段过程进行序列化。序列化器是模型实例和 Python 基本类型之间的中介。解析器和渲染器处理 Python 基本类型和
    HTTP 请求及响应之间的中介。我们将通过创建 `rest_framework.serializers.Serializer` 类的子类来配置我们的中介，以声明字段和必要的序列化和反序列化管理方法。我们将重复一些关于字段的信息，这些信息我们已经包含在
    `Game` 模型中，以便我们理解在序列化器类的子类中可以配置的所有内容。然而，我们将使用快捷方式，这将在下一个示例中减少样板代码。我们将通过使用 `ModelSerializer`
    类来在下一个示例中编写更少的代码。
- en: Now, go to the `gamesapi/games` folder folder and create a new Python code file
    named `serializers.py`. The following lines show the code that declares the new
    `GameSerializer` class. The code file for the sample is included in the `restful_python_chapter_01_01`
    folder.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `gamesapi/games` 文件夹，并创建一个名为 `serializers.py` 的新 Python 代码文件。以下行显示了声明新
    `GameSerializer` 类的代码。示例的代码文件包含在 `restful_python_chapter_01_01` 文件夹中。
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `GameSerializer` class declares the attributes that represent the fields
    that we want to be serialized. Notice that they have omitted the `created` attribute
    that was present in the `Game` model. When there is a call to the inherited `save`
    method for this class, the overridden `create` and `update` methods define how
    to create or modify an instance. In fact, these methods must be implemented in
    our class because they just raise a `NotImplementedError` exception in their base
    declaration.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameSerializer` 类声明了代表我们想要序列化的字段的属性。注意，它们省略了在 `Game` 模型中存在的 `created` 属性。当对这个类的继承
    `save` 方法进行调用时，重写的 `create` 和 `update` 方法定义了如何创建或修改实例。实际上，这些方法必须在我们的类中实现，因为它们在其基本声明中只是抛出一个
    `NotImplementedError` 异常。'
- en: The `create` method receives the validated data in the `validated_data` argument.
    The code creates and returns a new `Game` instance based on the received validated
    data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 方法接收 `validated_data` 参数中的验证数据。代码根据接收到的验证数据创建并返回一个新的 `Game` 实例。'
- en: The `update` method receives an existing `Game` instance that is being updated
    and the new validated data in the `instance` and `validated_data` arguments. The
    code updates the values for the attributes of the instance with the updated attribute
    values retrieved from the validated data, calls the save method for the updated
    `Game` instance and returns the updated and saved instance.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`update` 方法接收一个正在更新的现有 `Game` 实例和包含在 `instance` 和 `validated_data` 参数中的新验证数据。代码使用从验证数据中检索的更新属性值更新实例的属性值，调用更新
    `Game` 实例的保存方法，并返回更新和保存的实例。'
- en: 'We can launch our default Python interactive shell and make all the Django
    project modules available before it starts. This way, we can check that the serializer
    works as expected. In addition, it will help us understanding how serialization
    works in Django. Run the following command to launch the interactive shell. Make
    sure you are within the `gamesapi` folder in the Terminal or command prompt:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在启动之前启动默认的 Python 交互式 shell 并使所有 Django 项目模块可用。这样，我们可以检查序列化器是否按预期工作。此外，它将帮助我们理解
    Django 中的序列化工作方式。运行以下命令以启动交互式 shell。确保你在终端或命令提示符中的 `gamesapi` 文件夹内：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You will notice that a line that says (`InteractiveConsole`) is displayed after
    the usual lines that introduce your default Python interactive shell. Enter the
    following code in the Python interactive shell to import all the things we will
    need to test the `Game` model and its serializer. The code file for the sample
    is included in the `restful_python_chapter_01_01` folder, in the `serializers_test_01.py`
    file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在通常介绍你的默认Python交互式shell的行之后，会显示一行说（`InteractiveConsole`）。在Python交互式shell中输入以下代码以导入我们将需要测试`Game`模型及其序列化器的所有内容。示例的代码文件包含在`restful_python_chapter_01_01`文件夹中的`serializers_test_01.py`文件里：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Enter the following code to create two instances of the Game model and save
    them. The code file for the sample is included in the `restful_python_chapter_01_01`
    folder, in the `serializers_test_01.py` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码以创建两个`Game`模型的实例并将它们保存。示例的代码文件包含在`restful_python_chapter_01_01`文件夹中的`serializers_test_01.py`文件里：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: After we execute the preceding code, we can check the SQLite database with the
    previously introduce command-line or GUI tool to check the contents of the `games_game`
    table. We will notice the table has two rows and the columns have the values we
    have provided to the different attributes of the `Game` instances.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完前面的代码后，我们可以使用之前介绍的命令行或GUI工具来检查SQLite数据库的内容，即`games_game`表的内容。我们会注意到该表有两行，列的值是我们提供给`Game`实例不同属性的值。
- en: 'Enter the following commands in the interactive shell to check the values for
    the primary keys or identifiers for the saved `Game` instances and the value of
    the `created` attribute includes the date and time in which we saved the instance
    to the database. The code file for the sample is included in the `restful_python_chapter_01_01`
    folder, in the `serializers_test_01.py` file:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式shell中输入以下命令以检查已保存的`Game`实例的主键或标识符的值以及`created`属性值，该值包括我们将实例保存到数据库中的日期和时间。示例的代码文件包含在`restful_python_chapter_01_01`文件夹中的`serializers_test_01.py`文件里：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s write the following code to serialize the first game instance (`game1`).
    The code file for the sample is included in the `restful_python_chapter_01_01`
    folder, in the `serializers_test_01.py` file:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写以下代码来序列化第一个游戏实例（`game1`）。示例的代码文件包含在`restful_python_chapter_01_01`文件夹中的`serializers_test_01.py`文件里：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following line shows the generated dictionary, specifically, a `rest_framework.utils.serializer_helpers.ReturnDict`
    instance:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了生成的字典，具体来说，是一个`rest_framework.utils.serializer_helpers.ReturnDict`实例：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let''s serialize the second game instance (`game2`). The code file for
    the sample is included in the `restful_python_chapter_01_01` folder, in the `serializers_test_01.py`
    file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们序列化第二个游戏实例（`game2`）。示例的代码文件包含在`restful_python_chapter_01_01`文件夹中的`serializers_test_01.py`文件里：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following line shows the generated dictionary:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了生成的字典：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can easily render the dictionaries hold in the `data` attribute into JSON
    with the help of the `rest_framework.renderers.JSONRenderer` class. The following
    lines create an instance of this class and then calls the `render` method to render
    the dictionaries hold in the data attribute into JSON. The code file for the sample
    is included in the `restful_python_chapter_01_01` folder, in the `serializers_test_01.py`
    file:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rest_framework.renderers.JSONRenderer`类轻松地将存储在`data`属性中的字典渲染成JSON。以下行创建了这个类的实例，然后调用`render`方法将存储在`data`属性中的字典渲染成JSON。示例的代码文件包含在`restful_python_chapter_01_01`文件夹中的`serializers_test_01.py`文件里：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following lines show the output generated from the two calls to the `render`
    method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了两次调用`render`方法生成的输出：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, we will work in the opposite direction: from serialized data to the population
    of a `Game` instance. The following lines generate a new `Game` instance from
    a JSON string (serialized data), that is, they will deserialize. The code file
    for the sample is included in the `restful_python_chapter_01_01` folder, in the
    `serializers_test_01.py` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将反向操作：从序列化数据到填充一个`Game`实例。以下行从JSON字符串（序列化数据）生成一个新的`Game`实例，即它们将进行反序列化。示例的代码文件包含在`restful_python_chapter_01_01`文件夹中的`serializers_test_01.py`文件里：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The first line creates a new string with the JSON that defines a new game (`json_string_for_new_game`).
    Then, the code converts the string to `bytes` and saves the results of the conversion
    in the `json_bytes_for_new_game` variable. The `django.utils.six.BytesIO` class
    provides a buffered I/O implementation using an in-memory bytes buffer. The code
    uses this class to create a stream from the previously generated JSON bytes with
    the serialized data, `json_bytes_for_new_game`, and saves the generated instance
    in the `stream_for_new_game` variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个新的字符串，其中包含定义新游戏的 JSON（`json_string_for_new_game`）。然后，代码将字符串转换为 `bytes`
    并将转换的结果保存在 `json_bytes_for_new_game` 变量中。`django.utils.six.BytesIO` 类提供了一个使用内存字节数组的缓冲
    I/O 实现。代码使用这个类从之前生成的包含序列化数据的 JSON 字节（`json_bytes_for_new_game`）创建一个流，并将生成的实例保存在
    `stream_for_new_game` 变量中。
- en: We can easily deserialize and parse a stream into the Python models with the
    help of the `rest_framework.parsers.JSONParser` class. The next line creates an
    instance of this class and then calls the `parse` method with `stream_for_new_game`
    as an argument, parses the stream into Python native datatypes and saves the results
    in the `parsed_new_game` variable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `rest_framework.parsers.JSONParser` 类轻松地将流反序列化和解析到 Python 模型中。下一行创建了这个类的实例，然后使用
    `stream_for_new_game` 作为参数调用 `parse` 方法，将流解析为 Python 原生数据类型，并将结果保存在 `parsed_new_game`
    变量中。
- en: 'After executing the preceding lines, `parsed_new_game` holds a Python dictionary,
    parsed from the stream. The following lines show the output generated after executing
    the preceding code snippet:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的行后，`parsed_new_game` 包含一个从流中解析的 Python 字典。以下行显示了执行前面的代码片段后的输出：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The following lines use the `GameSerializer` class to generate a fully populated
    `Game` instance named `new_game` from the Python dictionary, parsed from the stream.
    The code file for the sample is included in the `restful_python_chapter_01_01`
    folder, in the `serializers_test_01.py` file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行使用 `GameSerializer` 类从流中解析的 Python 字典生成一个完全填充的 `Game` 实例，名为 `new_game`。示例代码文件包含在
    `restful_python_chapter_01_01` 文件夹中的 `serializers_test_01.py` 文件中。
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, the code creates an instance of the `GameSerializer` class with the Python
    dictionary that we previously parsed from the stream (`parsed_new_game`) passed
    as the `data` keyword argument. Then, the code calls the `is_valid` method to
    determine whether the data is valid. Notice that we must always call `is_valid`
    before we attempt to access the serialized data representation when we pass a
    `data` keyword argument in the creation of a serializer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码创建了一个 `GameSerializer` 类的实例，该实例使用我们从流中之前解析的 Python 字典（`parsed_new_game`）作为
    `data` 关键字参数传递。然后，代码调用 `is_valid` 方法以确定数据是否有效。请注意，我们必须始终在尝试访问序列化数据表示之前调用 `is_valid`，当我们传递
    `data` 关键字参数创建序列化器时。
- en: 'If the method returns `true`, we can access the serialized representation in
    the `data` attribute, and therefore, the code calls the `save` method that inserts
    the corresponding row in the database and returns a fully populated `Game` instance,
    saved in the `new_game` local variable. Then, the code prints one of the attributes
    from the fully populated `Game` instance. After executing the preceding code,
    we fully populated two Game instances: `new_game1_instance` and `new_game2_instance`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该方法返回 `true`，则我们可以访问 `data` 属性中的序列化表示，因此代码调用 `save` 方法将相应的行插入数据库，并返回一个完全填充的
    `Game` 实例，保存在 `new_game` 本地变量中。然后，代码打印完全填充的 `Game` 实例的一个属性。在执行前面的代码后，我们完全填充了两个
    `Game` 实例：`new_game1_instance` 和 `new_game2_instance`。
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As we can learn from the preceding code, Django REST Framework makes it easy
    to serialize from objects to JSON and deserialize from JSON to objects, which
    are core requirements for our RESTful Web API that has to perform CRUD operations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从前面的代码中可以学到的，Django REST 框架使得从对象序列化为 JSON 以及从 JSON 反序列化为对象变得容易，这是我们的必须执行
    CRUD 操作的 RESTful Web API 的核心要求。
- en: 'Enter the following command to leave the shell with the Django project modules
    that we started to test serialization and deserialization:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以退出包含我们开始测试序列化和反序列化的 Django 项目模块的 shell：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Writing API views
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 API 视图
- en: Now, we will create Django views that will use the previously created `GameSerializer`
    class to return JSON representations for each HTTP request that our API will handle.
    Open the `games/views.py` file. The following lines show the initial code for
    this file, with just one import statement and a comment that indicates we should
    create the views.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建Django视图，这些视图将使用之前创建的`GameSerializer`类来为API处理的每个HTTP请求返回JSON表示。打开`games/views.py`文件。以下行显示了该文件的初始代码，只有一个导入语句和一个注释，表明我们应该创建视图。
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following lines show the new code that creates a `JSONResponse` class and
    declares two functions: `game_list` and `game_detail`, in the `games/views.py`
    file. We are creating our first version of the API, and we use functions to keep
    the code as simple as possible. We will work with classes and more complex code
    in the next examples. The highlighted lines show the expressions that evaluate
    the value of the `request.method` attribute to determine the actions to be performed
    based on the HTTP verb. The code file for the sample is included in the `restful_python_chapter_01_01`
    folder:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了创建`JSONResponse`类并声明两个函数`game_list`和`game_detail`的新代码，这些函数位于`games/views.py`文件中。我们正在创建API的第一个版本，我们使用函数来尽可能简化代码。我们将在下一个示例中使用类和更复杂的代码。高亮行显示了评估`request.method`属性值的表达式，以确定基于HTTP动词要执行的操作。示例代码文件包含在`restful_python_chapter_01_01`文件夹中：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `JSONResponse` class is a subclass of the `django.http.HttpResponse` class.
    The superclass represents an HTTP response with a string as content. The `JSONResponse`
    class renders its content into JSON. The class defines just declare the `__init__`
    method that created a `rest_framework.renderers.JSONRenderer` instance and calls
    its `render` method to render the received data into JSON save the returned bytestring
    in the `content` local variable. Then, the code adds the `'content_type'` key
    to the response header with `'application/json'` as its value. Finally, the code
    calls the initializer for the base class with the JSON `bytestring` and the key-value
    pair added to the header. This way, the class represents a JSON response that
    we use in the two functions to easily return a JSON response.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONResponse`类是`django.http.HttpResponse`类的子类。超类表示一个以字符串为内容的HTTP响应。`JSONResponse`类将其内容渲染为JSON。该类仅声明了`__init__`方法，该方法创建一个`rest_framework.renderers.JSONRenderer`实例并调用其`render`方法将接收到的数据渲染为JSON，并将返回的字节串保存到`content`局部变量中。然后，代码将`''content_type''`键添加到响应头中，其值为`''application/json''`。最后，代码调用基类的初始化器，传递JSON字节串和添加到头部的键值对。这样，该类代表了一个我们用于两个函数的JSON响应，以便轻松返回JSON响应。'
- en: The code uses the `@csrf_exempt` decorator in the two functions to ensure that
    the view sets a **Cross-Site Request Forgery** (**CSRF**) cookie. We do this to
    make it simple to test this example that doesn't represent a production-ready
    Web Service. We will add security features to our RESTful API later.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在两个函数中使用`@csrf_exempt`装饰器来确保视图设置一个**跨站请求伪造**（**CSRF**）cookie。我们这样做是为了简化测试这个示例，因为这个示例不代表一个生产就绪的Web服务。我们将在稍后的RESTful
    API中添加安全功能。
- en: When the Django server receives an HTTP request, Django creates an `HttpRequest`
    instance, specifically a `django.http.HttpRequest` object. This instance contains
    metadata about the request, including the HTTP verb. The `method` attribute provides
    a string representing the HTTP verb or method used in the request.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django服务器接收到HTTP请求时，Django创建一个`HttpRequest`实例，具体是`django.http.HttpRequest`对象。此实例包含有关请求的元数据，包括HTTP动词。`method`属性提供了一个表示请求中使用的HTTP动词或方法的字符串。
- en: When Django loads the appropriate view that will process the requests, it passes
    the `HttpRequest` instance as the first argument to the view function. The view
    function has to return an `HttpResponse` instance, specifically a `django.http.HttpResponse`
    instance.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django加载将处理请求的适当视图时，它将`HttpRequest`实例作为第一个参数传递给视图函数。视图函数必须返回一个`HttpResponse`实例，具体是`django.http.HttpResponse`实例。
- en: 'The `game_list` function lists all the games or creates a new game. The function
    receives an `HttpRequest` instance in the `request` argument. The function is
    capable of processing two HTTP verbs: `GET` and `POST`. The code checks the value
    of the `request.method` attribute to determine the code to be executed based on
    the HTTP verb. If the HTTP verb is `GET`, the expression `request.method == ''GET''`
    will evaluate to `True` and the code has to list all the games. The code will
    retrieve all the `Game` objects from the database, use the `GameSerializer` to
    serialize all of them, and return a `JSONResponse` instance built with the data
    generated by the `GameSerializer`. The code creates the `GameSerializer` instance
    with the `many=True` argument to specify that multiple instances have to be serialized
    and not just one. Under the hoods, Django uses a `ListSerializer` when the `many`
    argument value is set to `True`.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_list` 函数列出所有游戏或创建一个新的游戏。该函数接收一个 `HttpRequest` 实例作为 `request` 参数。该函数能够处理两种
    HTTP 动词：`GET` 和 `POST`。代码会检查 `request.method` 属性的值，以确定根据 HTTP 动词要执行哪个代码。如果 HTTP
    动词是 `GET`，则表达式 `request.method == ''GET''` 将评估为 `True`，代码必须列出所有游戏。代码将从数据库检索所有
    `Game` 对象，使用 `GameSerializer` 将它们全部序列化，并返回一个使用 `GameSerializer` 生成数据的 `JSONResponse`
    实例。代码使用 `many=True` 参数创建 `GameSerializer` 实例，以指定必须序列化多个实例，而不仅仅是单个实例。在底层，当 `many`
    参数值设置为 `True` 时，Django 使用 `ListSerializer`。'
- en: If the HTTP verb is `POST`, the code has to create a new game based on the JSON
    data that is included in the HTTP request. First, the code uses a `JSONParser`
    instance and calls its parse method with request as an argument to parse the game
    data provided as `JSON` data in the request and saves the results in the `game_data`
    local variable. Then, the code creates a `GameSerializer` instance with the previously
    retrieved data and calls the `is_valid` method to determine whether the `Game`
    instance is valid or not. If the instance is valid, the code calls the `save`
    method to persist the instance in the database and returns a JSONResponse with
    the saved data in its body and a status equal to `status.HTTP_201_CREATED`, that
    is, `201 Created`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `POST`，则代码必须根据包含在 HTTP 请求中的 JSON 数据创建一个新的游戏。首先，代码使用一个 `JSONParser`
    实例，并使用请求作为参数调用其 `parse` 方法，以解析请求中提供的作为 `JSON` 数据的游戏数据，并将结果保存在 `game_data` 本地变量中。然后，代码使用之前检索到的数据创建一个
    `GameSerializer` 实例，并调用 `is_valid` 方法以确定 `Game` 实例是否有效。如果实例有效，代码将调用 `save` 方法将实例持久化到数据库中，并返回一个包含保存数据的
    JSONResponse 实例和状态等于 `status.HTTP_201_CREATED` 的状态，即 `201 Created`。
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Whenever we have to return a specific status different from the default `200
    OK` status, it is a good practice to use the module variables defined in the `rest_framework.status`
    module and to avoid using hardcoded numeric values.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们需要返回与默认 `200 OK` 状态不同的特定状态，使用 `rest_framework.status` 模块中定义的模块变量都是一个好习惯，并避免使用硬编码的数值。
- en: 'The `game_detail` function retrieves, updates or deletes an existing game.
    The function receives an `HttpRequest` instance in the `request` argument and
    the primary key or identifier for the game to be retrieved, updated or deleted
    in the `pk` argument. The function is capable of processing three HTTP verbs:
    `GET`, `PUT` and `DELETE`. The code checks the value of the `request.method` attribute
    to determine the code to be executed based on the HTTP verb. No matter which is
    the HTTP verb, the function calls the `Game.objects.get` method with the received
    `pk` as the `pk` argument to retrieve a Game instance from the database based
    on the specified primary key or identifier, and saves it in the `game` local variable.
    In case a game with the specified primary key or identifier doesn''t exist in
    the database, the code returns an `HttpResponse` with its status equal to `status.HTTP_404_NOT_FOUND`,
    that is, `404 Not Found`.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`game_detail` 函数检索、更新或删除现有的游戏。该函数接收一个 `HttpRequest` 实例作为 `request` 参数，以及要检索、更新或删除的游戏的主键或标识符作为
    `pk` 参数。该函数能够处理三种 HTTP 动词：`GET`、`PUT` 和 `DELETE`。代码会检查 `request.method` 属性的值，以确定根据
    HTTP 动词要执行哪个代码。无论 HTTP 动词是什么，该函数都会调用 `Game.objects.get` 方法，将接收到的 `pk` 作为 `pk`
    参数，从数据库中根据指定的主键或标识符检索一个 `Game` 实例，并将其保存在 `game` 本地变量中。如果数据库中不存在具有指定主键或标识符的游戏，代码将返回一个状态等于
    `status.HTTP_404_NOT_FOUND` 的 `HttpResponse`，即 `404 Not Found`。'
- en: If the HTTP verb is `GET`, the code creates a `GameSerializer` instance with
    `game` as an argument and returns the data for the serialized game in a `JSONResponse`
    that will include the default `200 OK` status. The code returns the retrieved
    game serialized as JSON.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `GET`，代码会创建一个带有 `game` 参数的 `GameSerializer` 实例，并在一个包含默认 `200 OK`
    状态的 `JSONResponse` 中返回序列化游戏的 数据。代码返回检索到的游戏序列化为 JSON 格式的数据。
- en: If the HTTP verb is `PUT`, the code has to create a new game based on the JSON
    data that is included in the HTTP request and use it to replace an existing game.
    First, the code uses a `JSONParser` instance and calls its parse method with request
    as an argument to parse the game data provided as `JSON` data in the request and
    saves the results in the `game_data` local variable. Then, the code creates a
    `GameSerializer` instance with the `Game` instance previously retrieved from the
    database (`game`) and the retrieved data that will replace the existing data (`game_data`).
    Then, the code calls the `is_valid` method to determine whether the `Game` instance
    is valid or not. If the instance is valid, the code calls the `save` method to
    persist the instance with the replaced values in the database and returns a `JSONResponse`
    with the saved data in its body and the default `200 OK` status. If the parsed
    data doesn't generate a valid Game instance, the code returns a `JSONResponse`
    with a status equal to `status.HTTP_400_BAD_REQUEST`, that is, `400 Bad Request`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `PUT`，代码必须根据包含在 HTTP 请求中的 JSON 数据创建一个新的游戏，并使用它来替换现有的游戏。首先，代码使用一个
    `JSONParser` 实例，并调用其 parse 方法，将请求作为参数来解析请求中提供的 `JSON` 数据，并将结果保存到 `game_data` 本地变量中。然后，代码创建一个带有从数据库中先前检索到的
    `Game` 实例（`game`）和将替换现有数据（`game_data`）的检索数据的 `GameSerializer` 实例。然后，代码调用 `is_valid`
    方法来确定 `Game` 实例是否有效。如果实例有效，代码会调用 `save` 方法以替换的值在数据库中持久化实例，并返回一个包含保存数据的 `JSONResponse`
    和默认的 `200 OK` 状态。如果解析的数据没有生成有效的 `Game` 实例，代码会返回一个状态等于 `status.HTTP_400_BAD_REQUEST`
    的 `JSONResponse`，即 `400 Bad Request`。
- en: If the HTTP verb is `DELETE`, the code calls the `delete` method for the `Game`
    instance previously retrieved from the database (`game`). The call to the `delete`
    method erases the underlying row in the `games_game` table, and therefore, the
    game won't be available anymore. Then, the code returns a `JSONResponse` with
    a status equal to `status.HTTP_204_NO_CONTENT` that is, `204 No Content`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HTTP 动词是 `DELETE`，代码会调用之前从数据库中检索到的 `Game` 实例（`game`）的 `delete` 方法。调用 `delete`
    方法会删除 `games_game` 表中的底层行，因此游戏将不再可用。然后，代码返回一个状态等于 `status.HTTP_204_NO_CONTENT`
    的 `JSONResponse`，即 `204 No Content`。
- en: 'Now, we have to create a new Python file named `urls.py` in the `games` folder,
    specifically, the `games/urls.py` file. The following lines show the code for
    this file that defines the URL patterns that specifies the regular expressions
    that have to be matched in the request to run a specific function defines in the
    `views.py` file. The code file for the sample is included in the `restful_python_chapter_01_01`
    folder:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须在 `games` 文件夹中创建一个名为 `urls.py` 的新 Python 文件，具体是 `games/urls.py` 文件。以下行显示了该文件的代码，该代码定义了
    URL 模式，指定了请求中必须匹配的正则表达式，以运行在 `views.py` 文件中定义的特定函数。示例的代码文件包含在 `restful_python_chapter_01_01`
    文件夹中：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `urlpatterns` list makes it possible to route URLs to views. The code calls
    the `django.conf.urls.url` function with the regular expression that has to be
    matched and the view function defined in the views module as arguments to create
    a `RegexURLPattern` instance for each entry in the `urlpatterns` list.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlpatterns` 列表使得将 URL 路由到视图成为可能。代码通过调用 `django.conf.urls.url` 函数，并传入需要匹配的正则表达式和定义在视图模块中的视图函数作为参数，为
    `urlpatterns` 列表中的每个条目创建一个 `RegexURLPattern` 实例。'
- en: 'We have to replace the code in the `urls.py` file in the `gamesapi` folder,
    specifically, the `gamesapi/urls.py` file. The file defines the root URL configurations,
    and therefore, we must include the URL patterns declared in the previously coded
    `games/urls.py` file. The following lines show the new code for the `gamesapi/urls.py`
    file. The code file for the sample is included in the `restful_python_chapter_01_01`
    folder:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须替换 `gamesapi` 文件夹中的 `urls.py` 文件中的代码，具体来说，是 `gamesapi/urls.py` 文件。该文件定义了根
    URL 配置，因此我们必须包含在先前编写的 `games/urls.py` 文件中声明的 URL 模式。以下行显示了 `gamesapi/urls.py`
    文件的新代码。示例的代码文件包含在 `restful_python_chapter_01_01` 文件夹中：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can launch Django''s development server to compose and send HTTP requests
    to our unsecure Web API (we will definitely add security later). Execute the following
    command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动 Django 的开发服务器，以编写并发送 HTTP 请求到我们的不安全 Web API（我们肯定会稍后添加安全性）。执行以下命令：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The following lines show the output after we execute the preceding command.
    The development server is listening at port `8000 `.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行前面的命令后的输出。开发服务器正在监听端口 `8000`。
- en: '[PRE58]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With the preceding command, we will start Django development server and we will
    only be able to access it in our development computer. The preceding command starts
    the development server in the default IP address, that is, `127.0.0.1` (`localhost`).
    It is not possible to access this IP address from other computers or devices connected
    on our LAN. Thus, if we want to make HTTP requests to our API from other computers
    or devices connected to our LAN, we should use the development computer IP address,
    `0.0.0.0` (for IPv4 configurations), or `::` (for IPv6 configurations) as the
    desired IP address for our development server.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，我们将启动 Django 开发服务器，并且我们只能在我们的开发计算机上访问它。前面的命令在默认 IP 地址上启动开发服务器，即 `127.0.0.1`
    (`localhost`)。从我们局域网上的其他计算机或设备无法访问此 IP 地址。因此，如果我们想从连接到我们局域网的其他计算机或设备向我们的 API 发送
    HTTP 请求，我们应该使用开发计算机的 IP 地址，`0.0.0.0`（对于 IPv4 配置），或 `::`（对于 IPv6 配置）作为开发服务器的期望
    IP 地址。
- en: 'If we specify `0.0.0.0` as the desired IP address for IPv4 configurations,
    the development server will listen on every interface on port 8000\. When we specify
    `::` for IPv6 configurations, it will have the same effect. In addition, it is
    necessary to open the default port `8000` in our firewalls (software and/or hardware)
    and configure port-forwarding to the computer that is running the development
    server. The following command launches Django''s development server in an IPv4
    configuration and allows requests to be made from other computers and devices
    connected to our LAN:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为 IPv4 配置指定 `0.0.0.0` 作为期望的 IP 地址，开发服务器将在端口 8000 上监听所有接口。当我们为 IPv6 配置指定
    `::` 时，它将产生相同的效果。此外，有必要在我们的防火墙（软件和/或硬件）中打开默认端口 `8000` 并配置端口转发到运行开发服务器的计算机。以下命令以
    IPv4 配置启动 Django 的开发服务器，并允许来自我们局域网上的其他计算机和设备的请求：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Tip
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you decide to compose and send HTTP requests from other computers or devices
    connected to the LAN, remember that you have to use the development computer's
    assigned IP address instead of `localhost`. For example, if the computer's assigned
    IPv4 IP address is `192.168.1.106`, instead of `localhost:8000`, you should use
    `192.168.1.106:8000`. Of course, you can also use the host name instead of the
    IP address. The previously explained configurations are very important because
    mobile devices might be the consumers of our RESTful APIs and we will always want
    to test the apps that make use of our APIs in our development environments.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定从连接到局域网的其他计算机或设备编写并发送 HTTP 请求，请记住，您必须使用分配给开发计算机的 IP 地址而不是 `localhost`。例如，如果计算机的分配
    IPv4 IP 地址是 `192.168.1.106`，则应使用 `192.168.1.106:8000` 而不是 `localhost:8000`。当然，您也可以使用主机名而不是
    IP 地址。之前解释的配置非常重要，因为移动设备可能是我们 RESTful API 的消费者，我们总是希望在开发环境中测试使用我们 API 的应用程序。
- en: Making HTTP requests to the API
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 API 发送 HTTP 请求
- en: The Django development server is running on localhost (`127.0.0.1`), listening
    on port `8000`, and waiting for our HTTP requests. Now, we will compose and send
    HTTP requests locally in our development computer or from other computer or devices
    connected to our LAN. We will use the following different kind of tools to compose
    and send HTTP requests throughout our book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Django 开发服务器正在本地主机 (`127.0.0.1`) 上运行，监听端口 `8000`，等待我们的 HTTP 请求。现在，我们将在我们开发计算机本地或从连接到局域网的其他计算机或设备上编写并发送
    HTTP 请求。我们将使用本书中介绍的不同类型的工具来编写并发送 HTTP 请求。
- en: Command-line tools
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行工具
- en: GUI tools
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形界面工具
- en: Python code
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 代码
- en: JavaScript code
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 代码
- en: Tip
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that you can use any other application that allows you to compose and
    send HTTP requests. There are many apps that run on tablets and smartphones that
    allow you to accomplish this task. However, we will focus our attention on the
    most useful tools when building RESTful Web APIs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以使用任何其他允许您编写并发送 HTTP 请求的应用程序。有许多在平板电脑和智能手机上运行的应用程序允许您完成此任务。然而，我们将关注构建 RESTful
    Web API 时最有用的工具。
- en: Working with command-line tools - curl and httpie
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行工具 - curl 和 httpie
- en: We will start with command-line tools. One of the key advantages of command-line
    tools is that we can easily run again the HTTP requests after we built them for
    the first time, and we don't need to use the mouse or tap the screen to run requests.
    We can also easily build a script with batch requests and run them. As happens
    with any command-line tool, it can take more time to perform the first requests
    compared with GUI tools, but it becomes easier once we performed many requests
    and we can easily reuse the commands we have written in the past to compose new
    requests.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从命令行工具开始。命令行工具的一个关键优势是，我们可以在第一次构建HTTP请求后轻松地再次运行它们，而无需使用鼠标或触摸屏幕来运行请求。我们还可以轻松地构建一个包含批量请求的脚本并运行它们。与任何命令行工具一样，与GUI工具相比，执行第一次请求可能需要更多时间，但一旦我们执行了许多请求，我们就可以轻松地重用我们以前编写的命令来组合新的请求。
- en: Curl, also known as cURL, is a very popular open source command-line tool and
    library that allow us to easily transfer data. We can use the curl command-line
    tool to easily compose and send HTTP requests and check their responses.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Curl，也称为cURL，是一个非常流行的开源命令行工具和库，它使我们能够轻松地传输数据。我们可以使用cURL命令行工具轻松地组合和发送HTTP请求，并检查它们的响应。
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are working on either macOS or Linux, you can open a Terminal and start
    using curl from the command line. If you are working on any Windows version, you
    can easily install curl from the `Cygwin` package installation option, and execute
    it from the Cygwin terminal. You can read more about the curl utility at [http://curl.haxx.se](http://curl.haxx.se).
    You can read more about the Cygwin terminal and its installation procedure at
    [http://cygwin.com/install.html](http://cygwin.com/install.html).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在macOS或Linux上工作，你可以打开终端并从命令行开始使用cURL。如果你正在Windows的任何版本上工作，你可以轻松地从`Cygwin`包安装选项中安装cURL，并在Cygwin终端中执行它。你可以在[http://curl.haxx.se](http://curl.haxx.se)上了解更多关于cURL实用程序的信息。你可以在[http://cygwin.com/install.html](http://cygwin.com/install.html)上了解更多关于Cygwin终端及其安装过程的信息。
- en: 'Open a Cygwin terminal in Windows or a terminal in macOS or Linux, and run
    the following command. It is very important that you enter the ending slash (`/`)
    because `/games` won''t match any of the patterns specified in `urlpatterns` in
    the `games/urls.py` file. We are using the default configuration for Django that
    doesn''t redirect URLs that don''t match any of the patterns to the same URLs
    with a slash appended. Thus, we must enter `/games/`, including the ending slash
    (`/`):'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中打开Cygwin终端或在macOS或Linux中打开终端，并运行以下命令。非常重要的一点是，你必须输入结束斜杠（`/`），因为`/games`不会匹配`games/urls.py`文件中指定的任何模式。我们正在使用Django的默认配置，该配置不会将不匹配任何模式的URL重定向到带有附加斜杠的相同URL。因此，我们必须输入`/games/`，包括结束斜杠（`/`）：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding command will compose and send the following HTTP request-`GET
    http://localhost:8000/games/`. The request is the simplest case in our RESTful
    API because it will match and run the `views.game_list` function, that is, the
    `game_list` function declared within the `games/views.py` file. The function just
    receives `request` as a parameter because the URL pattern doesn't include any
    parameters. As the HTTP verb for the request is `GET`, the `request.method` property
    is equal to `'GET'`, and therefore, the function will execute the code that retrieves
    all the `Game` objects and generates a JSON response with all of these `Game`
    objects serialized.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组合并发送以下HTTP请求-`GET http://localhost:8000/games/`。这个请求是我们RESTful API中最简单的情况，因为它将匹配并运行`views.game_list`函数，即`games/views.py`文件中声明的`game_list`函数。该函数仅接收`request`作为参数，因为URL模式不包含任何参数。由于请求的HTTP动词是`GET`，因此`request.method`属性等于`'GET'`，因此该函数将执行检索所有`Game`对象的代码，并生成包含所有这些序列化`Game`对象的JSON响应。
- en: 'The following lines show an example response for the HTTP request, with three
    `Game` objects in the JSON response:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了HTTP请求的一个示例响应，其中JSON响应中有三个`Game`对象：
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we might notice from the previous response, the curl utility displays the
    JSON response in a single line, and therefore, it is a bit difficult to read it.
    In this case, we know that the `Content-Type` of the response is `application/json`.
    However, in case we want to have more details about the response, we can use the
    `-i` option to request curl to print the HTTP response headers. We can combine
    the `-i` and `-X` options by using `-iX`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从之前的响应中注意到的，curl实用程序将JSON响应显示为单行，因此它有点难以阅读。在这种情况下，我们知道响应的`Content-Type`是`application/json`。然而，如果我们想了解更多关于响应的详细信息，我们可以使用`-i`选项请求curl打印HTTP响应头。我们可以通过使用`-iX`将`-i`和`-X`选项组合起来。
- en: 'Go back to the Cygwin terminal in Windows or the Terminal in macOS or Linux,
    and run the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到Windows中的Cygwin终端或macOS或Linux中的终端，并运行以下命令：
- en: '[PRE62]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK`) and the
    `Content-type` (`application/json`). After the HTTP response headers, we can see
    the details for the three `Game` objects in the JSON response:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了HTTP请求的一个示例响应。前几行显示了HTTP响应头，包括状态（`200 OK`）和`Content-type`（`application/json`）。在HTTP响应头之后，我们可以看到JSON响应中三个`Game`对象的详细信息：
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After we run the two requests, we will see the following lines in the window
    that is running the Django development server. The output indicates that the server
    received two HTTP requests with the `GET` verb and `/games/` as the URI. The server
    processed both HTTP requests, returned status code 200 and the response length
    was equal to 379 characters. The response length can be different because the
    value for the primary key assigned to each game will have an incidence in the
    response length. The first number after `HTTP/1.1."` indicates the returned status
    code (`200`) and the second number the response length (`379`).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行两个请求之后，我们将在运行Django开发服务器的窗口中看到以下几行。输出表明服务器接收了两个带有`GET`动词和`/games/`作为URI的HTTP请求。服务器处理了这两个HTTP请求，返回状态码200，响应长度等于379个字符。响应长度可能不同，因为分配给每个游戏的每个主键的值将对响应长度产生影响。`HTTP/1.1."`之后的第一个数字表示返回的状态码（`200`），第二个数字表示响应长度（`379`）。
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The following image shows two terminal windows side-by-side on macOS. The Terminal
    window at the left-hand side is running the Django development server and displays
    the received and processed HTTP requests. The Terminal window at the right-hand
    side is running `curl` commands to generate the HTTP requests.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了macOS上并排的两个终端窗口。左侧的终端窗口正在运行Django开发服务器，并显示接收和处理的HTTP请求。右侧的终端窗口正在运行`curl`命令来生成HTTP请求。
- en: 'It is a good idea to use a similar configuration to check the output while
    we compose and send the HTTP requests. Notice that the JSON outputs are a bit
    difficult to read because they don''t use syntax highlighting:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写和发送HTTP请求时，使用类似的配置来检查输出是个好主意。请注意，JSON输出有点难以阅读，因为它们没有使用语法高亮：
- en: '![Working with command-line tools - curl and httpie](img/image_01_006.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![使用命令行工具 - curl和httpie](img/image_01_006.jpg)'
- en: 'Now, we will install HTTPie, a command-line HTTP client written in Python that
    makes it easy to send HTTP requests and uses a syntax that is easier than curl
    (also known as cURL). One of the great advantages of HTTPie is that it displays
    colorized output and uses multiple lines to display the response details. Thus,
    HTTPie makes it easier to understand the responses than the curl utility. We just
    need to activate the virtual environment and then run the following command in
    the terminal or command prompt to install the HTTPie package:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装HTTPie，这是一个用Python编写的命令行HTTP客户端，它使得发送HTTP请求变得简单，并且使用的语法比curl（也称为cURL）更容易。HTTPie的一个巨大优点是它显示彩色输出，并使用多行来显示响应细节。因此，HTTPie比curl实用程序更容易理解响应。我们只需要激活虚拟环境，然后在终端或命令提示符中运行以下命令来安装HTTPie包：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The last lines for the output will indicate that the `django` package has been
    successfully installed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`django`包已成功安装。
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you don't remember how to activate the virtual environment that we created
    for this example, read the following section in this chapter-*Setting up the virtual
    environment with Django REST framework*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不记得如何激活为我们这个示例创建的虚拟环境，请阅读本章以下部分-*使用Django REST框架设置虚拟环境*。
- en: 'Now, we can use an `http` command to easily compose and send HTTP requests
    to `localhost:8000` and test the RESTful API built with Django REST framework.
    HTTPie supports curl-like shorthands for localhost, and therefore, we can use
    `:8000` as a shorthand that expands to `http://localhost:8000`. Run the following
    command and remember to enter the ending slash (`/`):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `http` 命令轻松地编写并发送 HTTP 请求到 `localhost:8000` 并测试使用 Django REST 框架构建的
    RESTful API。HTTPie 支持类似于 `curl` 的本地主机缩写，因此我们可以使用 `:8000` 作为缩写，它展开为 `http://localhost:8000`。运行以下命令并记得输入结束斜杠（`/`）：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding command will compose and send the following HTTP request: `GET
    http://localhost:8000/games/`. The request is the same one we have previously
    composed with the curl command. However, in this case, the HTTPie utility will
    display a colorized output and it will use multiple lines to display the JSON
    response. The preceding command is equivalent to the following command that specifies
    the GET method after `http`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将编写并发送以下 HTTP 请求：`GET http://localhost:8000/games/`。请求与之前使用 `curl` 命令编写的请求相同。然而，在这种情况下，HTTPie
    工具将显示彩色输出，并使用多行来显示 JSON 响应。前面的命令等同于以下命令，该命令在 `http` 后指定 GET 方法：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following lines show an example response for the HTTP request, with the
    headers and the three `Game` objects in the JSON response. It is indeed easier
    to understand the response compared with the results generated when we composed
    the HTTP request with curl. HTTPie automatically formats the JSON data received
    as a response and applies syntax highlighting, specifically, both colors and formatting:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了对 HTTP 请求的示例响应，包括头部信息和 JSON 响应中的三个 `Game` 对象。与使用 `curl` 编写 HTTP 请求时生成的结果相比，理解响应确实更容易。HTTPie
    自动格式化接收到的 JSON 数据作为响应，并应用语法高亮，具体来说，包括颜色和格式：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Tip
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can achieve the same results by combining the output generated with the curl
    command with other utilities. However, HTTPie provides us exactly what we need
    to work with RESTful APIs. We will use HTTPie to compose and send HTTP request,
    but we will always provide the equivalent curl command.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将 `curl` 命令生成的输出与其他工具结合来达到相同的结果。然而，HTTPie 提供了我们与 RESTful API 一起工作所需的一切。我们将使用
    HTTPie 来编写并发送 HTTP 请求，但我们将始终提供等效的 `curl` 命令。
- en: 'The following image shows two Terminal windows side-by-side on macOS. The terminal
    window at the left-hand side is running the Django development server and displays
    the received and processed HTTP requests. The Terminal window at the right-hand
    side is running HTTPie commands to generate the HTTP requests. Notice that the
    JSON output is easier to read compared to the output generated by the curl command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了 macOS 上并排的两个终端窗口。左侧的终端窗口正在运行 Django 开发服务器，并显示接收和处理的 HTTP 请求。右侧的终端窗口正在运行
    HTTPie 命令以生成 HTTP 请求。请注意，与 `curl` 命令生成的输出相比，JSON 输出更容易阅读：
- en: '![Working with command-line tools - curl and httpie](img/image_01_007.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![使用命令行工具 - curl 和 httpie](img/image_01_007.jpg)'
- en: 'We can execute HTTPie with the `-b` option in case we don''t want to include
    the header in the response. For example, the following line performs the same
    HTTP request but doesn''t display the header in the response output, and therefore,
    the output will just display the JSON response:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望在响应中包含头部信息，可以使用 `-b` 选项执行 HTTPie。例如，以下行执行了相同的 HTTP 请求，但不会在响应输出中显示头部信息，因此输出将仅显示
    JSON 响应：
- en: '[PRE70]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we will select one of the games from the preceding list and we will compose
    an HTTP request to retrieve just the chosen game. For example, in the previous
    list, the first game has a `pk` value equal to `3`. Run the following command
    to retrieve this game. Use the `pk` value you have retrieved in the previous command
    for the first game, as the pk number might be different:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从前面的列表中选择一个游戏，并编写一个 HTTP 请求来检索所选的游戏。例如，在前面的列表中，第一个游戏的 `pk` 值等于 `3`。运行以下命令来检索此游戏。使用您在先前的命令中检索到的第一个游戏的
    `pk` 值，因为 `pk` 数字可能不同：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/3/`. The request has a number after `/games/`, and
    therefore, it will match `''^games/(?P<pk>[0-9]+)/$''` and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games/views.py`
    file. The function receives `request` and `pk` as parameters because the URL pattern
    passes the number specified after `/games/` in the `pk` parameter. As the HTTP
    verb for the request is `GET`, the `request.method` property is equal to `''GET''`,
    and therefore, the function will execute the code that retrieves the `Game` object
    whose primary key matches the `pk` value received as an argument and, if found,
    generates a JSON response with this `Game` object serialized. The following lines
    show an example response for the HTTP request, with the `Game` object that matches
    the `pk` value in the JSON response:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将构建并发送以下HTTP请求：`GET http://localhost:8000/games/3/`。请求在`/games/`之后有一个数字，因此，它将匹配`'^games/(?P<pk>[0-9]+)/$'`并运行`views.game_detail`函数，即`games/views.py`文件中声明的`game_detail`函数。该函数接收`request`和`pk`作为参数，因为URL模式将`/games/`之后指定的数字作为`pk`参数传递。由于请求的HTTP动词是`GET`，所以`request.method`属性等于`'GET'`，因此，该函数将执行检索与作为参数接收的`pk`值匹配的`Game`对象的代码，如果找到，则生成一个包含此`Game`对象的序列化JSON响应。以下行显示了HTTP请求的示例响应，其中JSON响应中匹配`pk`值的`Game`对象：
- en: '[PRE73]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, we will compose and send an HTTP request to retrieve a game that doesn''t
    exist. For example, in the preceding list, there is no game with a `pk` value
    equal to `99999`. Run the following command to try to retrieve this game. Make
    sure you use a `pk` value that doesn''t exist. We must make sure that the utilities
    display the headers as part of the response because the response won''t have a
    body:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建并发送一个HTTP请求来检索一个不存在的游戏。例如，在前面列表中，没有`pk`值等于`99999`的游戏。运行以下命令尝试检索此游戏。确保您使用一个不存在的`pk`值。我们必须确保工具将头信息作为响应的一部分显示，因为响应不会有主体部分：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following is the equivalent curl command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的curl命令：
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The preceding commands will compose and send the following HTTP request: `GET
    http://localhost:8000/games/99999/`. The request is the same than the previous
    one we have analyzed, with a different number for the `pk` parameter. The server
    will run the `views.game_detail` function, that is, the `game_detail` function
    declared within the `games/views.py` file. The function will execute the code
    that retrieves the `Game` object whose primary key matches the `pk` value received
    as an argument and a `Game.DoesNotExist` exception will be thrown and captured
    because there is no game with the specified `pk` value. Thus, the code will return
    an HTTP 404 Not Found status code. The following lines show an example header
    response for the HTTP request:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将构建并发送以下HTTP请求：`GET http://localhost:8000/games/99999/`。该请求与之前分析过的请求相同，只是`pk`参数的数字不同。服务器将运行`views.game_detail`函数，即`games/views.py`文件中声明的`game_detail`函数。该函数将执行检索与作为参数接收的`pk`值匹配的`Game`对象的代码，并抛出并捕获`Game.DoesNotExist`异常，因为没有与指定的`pk`值匹配的游戏。因此，代码将返回HTTP
    404 Not Found状态码。以下行显示了HTTP请求的示例响应头：
- en: '[PRE76]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We will compose and send an HTTP request to create a new game.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建并发送一个HTTP请求来创建一个新的游戏。
- en: '[PRE77]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following is the equivalent curl command. It is very important to use the
    `-H "Content-Type: application/json"` option to indicate curl to send the data
    specified after the -d option as `application/json` instead of the default `application/x-www-form-urlencoded`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是对应的curl命令。非常重要的一点是使用`-H "Content-Type: application/json"`选项来指示curl将-d选项之后指定的数据作为`application/json`发送，而不是默认的`application/x-www-form-urlencoded`：'
- en: '[PRE78]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The previous commands will compose and send the following HTTP request: `POST
    http://localhost:8000/games/` with the following JSON key-value pairs:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将构建并发送以下HTTP请求：`POST http://localhost:8000/games/`，带有以下JSON键值对：
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The request specifies `/games/`, and therefore, it will match `''^games/$''`
    and run the `views.game_list` function, that is, the `game_detail` function declared
    within the `games/views.py` file. The function just receives `request` as a parameter
    because the URL pattern doesn''t include any parameters. As the HTTP verb for
    the request is `POST`, the `request.method` property is equal to `''POST''`, and
    therefore, the function will execute the code that parses the JSON data received
    in the request, creates a new `Game` and, if the data is valid, it saves the new
    `Game`. If the new Game was successfully persisted in the database, the function
    returns an `HTTP 201 Created` status code and the recently persisted `Game` serialized
    serialized to JSON in the response body. The following lines show an example response
    for the HTTP request, with the new `Game` object in the JSON response:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定了 `/games/`，因此，它将匹配 `'^games/$'` 并运行 `views.game_list` 函数，即 `games/views.py`
    文件中声明的 `game_detail` 函数。该函数仅接收 `request` 作为参数，因为 URL 模式不包含任何参数。由于请求的 HTTP 方法为
    `POST`，`request.method` 属性等于 `'POST'`，因此，该函数将执行解析请求中接收到的 JSON 数据的代码，创建一个新的 `Game`
    对象，如果数据有效，则保存新的 `Game`。如果新的 `Game` 成功持久化到数据库中，该函数将返回一个 `HTTP 201 Created` 状态码，并将最近持久化的
    `Game` 对象序列化为 JSON 格式放在响应体中。以下行显示了 HTTP 请求的示例响应，其中包含 JSON 响应中的新 `Game` 对象：
- en: '[PRE80]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now, we will compose and send an HTTP request to update an existing game, specifically,
    the previously added game. We have to check the value assigned to `pk` in the
    previous response and replace `15` in the command with the returned value. For
    example, in case the value for `pk` was `5`, you should use `:8000/games/5/` instead
    of `:8000/games/15/`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个 HTTP 请求来更新一个现有的游戏，具体来说，是之前添加的游戏。我们必须检查之前响应中分配给 `pk` 的值，并将命令中的
    `15` 替换为返回的值。例如，如果 `pk` 的值为 `5`，则应使用 `:8000/games/5/` 而不是 `:8000/games/15/`。
- en: '[PRE81]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following is the equivalent curl command. As happened with the previous
    curl example, it is very important to use the `-H "Content-Type: application/json"`
    option to indicate curl to send the data specified after the `-d` option as `application/json`
    instead of the default `application/x-www-form-urlencoded`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是与之前 curl 示例等效的 curl 命令。与之前的 curl 示例一样，非常重要的一点是使用 `-H "Content-Type: application/json"`
    选项来指示 curl 将 `-d` 选项之后指定的数据作为 `application/json` 发送，而不是默认的 `application/x-www-form-urlencoded`：'
- en: '[PRE82]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The previous commands will compose and send the following HTTP request: `PUT
    http://localhost:8000/games/15/` with the following JSON key-value pairs:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将编写并发送以下 HTTP 请求：`PUT http://localhost:8000/games/15/`，并带有以下 JSON 键值对：
- en: '[PRE83]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The request has a number after `/games/`, and therefore, it will match `''^games/(?P<pk>[0-9]+)/$''`
    and run the `views.game_detail` function, that is, the `game_detail` function
    declared within the `games/views.py` file. The function receives `request` and
    `pk` as parameters because the URL pattern passes the number specified after `/games/`
    in the `pk` parameter. As the HTTP verb for the request is `PUT`, the `request.method`
    property is equal to `''PUT''`, and therefore, the function will execute the code
    that parses the JSON data received in the request, creates a `Game` instance from
    this data and updates the existing game in the database. If the game was successfully
    updated in the database, the function returns an `HTTP 200 OK` status code and
    the recently updated `Game` serialized serialized to JSON in the response body.
    The following lines show an example response for the `HTTP` request, with the
    updated `Game` object in the JSON response:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 请求在 `/games/` 后面有一个数字，因此，它将匹配 `'^games/(?P<pk>[0-9]+)/$'` 并运行 `views.game_detail`
    函数，即 `games/views.py` 文件中声明的 `game_detail` 函数。该函数接收 `request` 和 `pk` 作为参数，因为 URL
    模式将 `/games/` 后面指定的数字传递给 `pk` 参数。由于请求的 HTTP 方法为 `PUT`，`request.method` 属性等于 `'PUT'`，因此，该函数将执行解析请求中接收到的
    JSON 数据的代码，从这些数据创建一个 `Game` 实例，并更新数据库中的现有游戏。如果游戏在数据库中成功更新，该函数将返回一个 `HTTP 200 OK`
    状态码，并将最近更新的 `Game` 对象序列化为 JSON 格式放在响应体中。以下行显示了 `HTTP` 请求的示例响应，其中包含 JSON 响应中的更新后的
    `Game` 对象：
- en: '[PRE84]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In order to successfully process a PUT HTTP request that updates an existing
    game, we must provide values for all the required fields. We will compose and
    send an HTTP request to try update an existing game, and we will fail to do so
    because we will just provide a value for the name. As happened in the previous
    request, we will use the value assigned to `pk` in the last game we added:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功处理更新现有游戏的 `PUT` HTTP 请求，我们必须为所有必需的字段提供值。我们将组合并发送一个 HTTP 请求来尝试更新一个现有游戏，我们将无法做到这一点，因为我们只为名称提供了一个值。正如在先前的请求中所发生的那样，我们将使用我们在最后添加的游戏中分配给
    `pk` 的值：
- en: '[PRE85]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The following is the equivalent curl command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE86]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The previous commands will compose and send the following `HTTP` request: `PUT
    http://localhost:8000/games/15/` with the following JSON key-value pair:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 `HTTP` 请求：`PUT http://localhost:8000/games/15/`，并带有以下 JSON 键值对：
- en: '[PRE87]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The request will execute the same code we explained for the previous request.
    Because we didn''t provide all the required values for a `Game` instance, the
    `game_serializer.is_valid()` method will return `False` and the function will
    return an `HTTP 400 Bad Request` status code and the details generated in the
    `game_serializer.errors` attribute serialized to JSON in the response body. The
    following lines show an example response for the HTTP request, with the required
    fields that our request didn''t include values in the JSON response:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将执行我们之前解释的相同代码。因为我们没有为 `Game` 实例提供所有必需的值，所以 `game_serializer.is_valid()` 方法将返回
    `False`，函数将返回 `HTTP 400 Bad Request` 状态码，并将 `game_serializer.errors` 属性中生成的详细信息序列化为
    JSON 放在响应体中。以下行显示了缺少 JSON 响应中必需字段的 HTTP 请求的示例响应：
- en: '[PRE88]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When we want our API to be able to update a single field for an existing resource,
    in this case, an existing game, we should provide an implementation for the `PATCH`
    method. The `PUT` method is meant to replace an entire resource and the `PATCH`
    method is meant to apply a delta to an existing resource. We can write code in
    the handler for the `PUT` method apply a delta to an existing resource, but it
    is a better practice to use the `PATCH` method for this specific task. We will
    work with the `PATCH` method later.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望我们的 API 能够更新现有资源的单个字段，在这种情况下，一个现有的游戏，我们应该提供一个 `PATCH` 方法的实现。`PUT` 方法旨在替换整个资源，而
    `PATCH` 方法旨在对现有资源应用一个增量。我们可以在 `PUT` 方法的处理程序中编写代码来对现有资源应用增量，但使用 `PATCH` 方法执行此特定任务是一种更好的做法。我们将在稍后使用
    `PATCH` 方法。
- en: 'Now, we will compose and send an HTTP request to delete an existing game, specifically,
    the last game we added. As happened in our last HTTP requests, we have to check
    the value assigned to `pk` in the previous response and replace `12` in the command
    with the returned value:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合并发送一个 HTTP 请求来删除一个现有的游戏，具体来说，是我们最后添加的游戏。正如我们在上一个 HTTP 请求中所做的那样，我们必须检查上一个响应中分配给
    `pk` 的值，并将命令中的 `12` 替换为返回的值：
- en: '[PRE89]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE90]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The preceding commands will compose and send the following HTTP request: `DELETE
    http://localhost:8000/games/15/`. The request has a number after `/games/`, and
    therefore, it will match `''^games/(?P<pk>[0-9]+)/$''` and run the `views.game_detail`
    function, that is, the `game_detail` function declared within the `games/views.py`
    file. The function receives `request` and `pk` as parameters because the URL pattern
    passes the number specified after `/games/` in the `pk` parameter. As the HTTP
    verb for the request is `DELETE`, the `request.method` property is equal to `''DELETE''`,
    and therefore, the function will execute the code that parses the JSON data received
    in the request, creates a `Game` instance from this data and deletes the existing
    game in the database. If the game was successfully deleted in the database, the
    function returns an `HTTP 204 No Content` status code. The following lines show
    an example response for the HTTP request after successfully deleting an existing
    game:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将组合并发送以下 HTTP 请求：`DELETE http://localhost:8000/games/15/`。请求在 `/games/`
    后有一个数字，因此它将匹配 `'^games/(?P<pk>[0-9]+)/$'` 并运行 `views.game_detail` 函数，即 `games/views.py`
    文件中声明的 `game_detail` 函数。该函数接收 `request` 和 `pk` 作为参数，因为 URL 模式将 `/games/` 后指定的数字传递给
    `pk` 参数。由于请求的 HTTP 动词是 `DELETE`，因此 `request.method` 属性等于 `'DELETE'`，因此该函数将执行解析请求中接收到的
    JSON 数据的代码，从这些数据创建一个 `Game` 实例，并删除数据库中的现有游戏。如果游戏在数据库中成功删除，则函数返回 `HTTP 204 No Content`
    状态码。以下行显示了成功删除现有游戏后的 HTTP 请求的示例响应：
- en: '[PRE91]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Working with GUI tools - Postman and others
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GUI工具 - Postman和其他工具
- en: So far, we have been working with two terminal-based or command-line tools to
    compose and send HTTP requests to our Django development server-cURL and HTTPie.
    Now, we will work with **GUI** (**Graphical User Interface**) tools.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用两个基于终端或命令行的工具来编写和发送HTTP请求到我们的Django开发服务器——cURL和HTTPie。现在，我们将使用**GUI**（**图形用户界面**）工具。
- en: Postman is a very popular API testing suite GUI tool that allows us to easily
    compose and send HTTP requests, among other features. Postman is available as
    a Chrome App and as a Mac App. We can execute it in Windows, Linux and macOS as
    a Chrome App, that is, an application running on top of Google Chrome. In case
    we work with macOS, we can use the Mac App instead of the Chrome App. You can
    download the versions of the Postman App from the following URL-[https://www.getpostman.com](https://www.getpostman.com).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Postman是一个非常流行的API测试套件GUI工具，它允许我们轻松地编写和发送HTTP请求，以及其他功能。Postman可以作为Chrome应用和Mac应用使用。我们可以在Windows、Linux和macOS上作为Chrome应用执行它，即运行在Google
    Chrome之上的应用程序。如果我们使用macOS，我们可以使用Mac应用而不是Chrome应用。您可以从以下URL下载Postman应用的版本-[https://www.getpostman.com](https://www.getpostman.com)。
- en: Tip
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can download and install Postman for free to compose and send HTTP requests
    to our RESTful APIs. You just need to sign up to Postman and we won't be using
    any of the paid features provided by Postman cloud in our examples. All the instructions
    work with Postman 4.2.2 or greater.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以免费下载并安装Postman来编写和发送HTTP请求到我们的RESTful API。您只需在Postman上注册，我们不会在我们的示例中使用Postman云提供的任何付费功能。所有说明都适用于Postman
    4.2.2或更高版本。
- en: Now, we will use the **Builder** tab in Postman to easily compose and send HTTP
    requests to `localhost:8000` and test the RESTful API with this GUI tool. Postman
    doesn't support curl-like shorthands for localhost, and therefore, we cannot use
    the same shorthands we have been using when composing requests with HTTPie.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Postman中的**构建器**选项卡轻松地编写和发送HTTP请求到`localhost:8000`，并使用此GUI工具测试RESTful
    API。Postman不支持curl-like的本地主机缩写，因此我们无法在编写HTTPie请求时使用相同的缩写。
- en: Select **GET** in the dropdown menu at the left-hand side of the **Enter request
    URL** textbox, and enter `localhost:8000/games/` in this textbox at the right-hand
    side of the dropdown. Then, click **Send** and Postman will display the Status
    (**200 OK**), the time it took for the request to be processed and the response
    body with all the games formatted as JSON with syntax highlighting (**Pretty**
    view).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在**“输入请求URL”**文本框左侧的下拉菜单中选择**GET**，然后在下拉菜单右侧的文本框中输入`localhost:8000/games/`。然后点击**发送**，Postman将显示状态（**200
    OK**）、请求处理所需的时间和响应体，其中所有游戏都格式化为带有语法高亮的JSON（**美化**视图）。
- en: 'The following screenshot shows the JSON response body in Postman for the HTTP
    GET request:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Postman中HTTP GET请求的JSON响应体：
- en: '![Working with GUI tools - Postman and others](img/image_01_008.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他工具](img/image_01_008.jpg)'
- en: 'Click on **Headers** at the right-hand side of **Body** and **Cookies** to
    read the response headers. The following screenshot shows the layout for the response
    headers that Postman displays for the preceding response. Notice that Postman
    displays the **Status** at the right-hand side of the response and doesn''t include
    it as the first line of the Headers, as happened when we worked with both the
    cURL and HTTPie utilities:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Body**和**Cookies**右侧的**头部**，以读取响应头部。以下截图显示了Postman为前面的响应显示的响应头部布局。注意，Postman在响应右侧显示**状态**，并且不将其作为头部的第一行，就像我们在使用cURL和HTTPie工具时发生的那样：
- en: '![Working with GUI tools - Postman and others](img/image_01_009.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他工具](img/image_01_009.jpg)'
- en: 'Now, we will use the **Builder** tab in Postman to compose and send an HTTP
    request to create a new game, specifically, a POST request. Follow the next steps:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Postman中的**构建器**选项卡来编写和发送一个HTTP请求以创建一个新的游戏，具体来说，是一个POST请求。按照以下步骤操作：
- en: Select **POST** in the drop-down menu at the left-hand side of the **Enter request
    URL** textbox, and enter `localhost:8000/games/` in this textbox at the right-hand
    side of the dropdown.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**“输入请求URL”**文本框左侧的下拉菜单中选择**POST**，然后在下拉菜单右侧的文本框中输入`localhost:8000/games/`。
- en: Click **Body** at the right-hand side of **Authorization** and **Headers**,
    within the panel that composes the request.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写请求的面板中，点击**Body**右侧的**授权**和**头部**。
- en: Activate the **raw** radio button and select **JSON (application/json)** in
    the dropdown at the right-hand side of the **binary** radio button. Postman will
    automatically add a **Content-type** as **application/json** header, and therefore,
    you will notice the **Headers** tab will be renamed to **Headers (1)**, indicating
    us that there is one key-value pair specified for the request headers.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活 **raw** 单选按钮，并在 **binary** 单选按钮右侧的下拉菜单中选择 **JSON (application/json)**。Postman
    将自动添加一个 **Content-type** 为 **application/json** 的头部，因此，您会注意到 **Headers** 选项卡将被重命名为
    **Headers (1)**，这表示我们已指定了一个请求头部的键值对。
- en: 'Enter the following lines in the textbox below the radio buttons, within the
    **Body** tab:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单选按钮下方的文本框中输入以下行，位于 **Body** 选项卡内：
- en: '[PRE92]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The following screenshot shows the request body in Postman:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 Postman 中的请求体：
- en: '![Working with GUI tools - Postman and others](img/image_01_010.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GUI 工具 - Postman 和其他](img/image_01_010.jpg)'
- en: We followed the necessary steps to create an HTTP POST request with a JSON body
    that specifies the necessary key-value pairs to create a new game. Click on **Send**
    and Postman will display the Status (`201 Created`), the time it took for the
    request to be processed and the response body with the recently added game formatted
    as JSON with syntax highlighting (**Pretty** view). The following screenshot shows
    the JSON response body in Postman for the HTTP POST request.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了创建具有 JSON 体的 HTTP POST 请求的必要步骤，该请求指定了创建新游戏所需的关键值对。点击 **Send**，Postman 将显示状态（`201
    Created`）、请求处理所需的时间以及以语法高亮（**Pretty** 视图）格式化的响应体。以下截图显示了 Postman 中 HTTP POST 请求的
    JSON 响应体。
- en: Tip
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we want to compose and send an HTTP PUT request with Postman, it is necessary
    to follow the previously explained steps to provide JSON data within the request
    body.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 Postman 编写和发送一个 HTTP PUT 请求，必须遵循之前解释的步骤，在请求体中提供 JSON 数据。
- en: One of the nice features included in Postman is that we can easily review and
    again run the HTTP requests we have made by browsing the saved **History** shown
    at the left-hand side of the Postman window. The History pane displays a list
    with the HTTP verb followed by the URL for each HTTP request we have composed
    and sent. We just need to click on the desired HTTP request and click **Send**
    to run it again. The following screenshot shows the many HTTP requests in the
    **History** pane and the first one selected to send it again.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 包含的一个不错的特点是，我们可以通过浏览 Postman 窗口左侧显示的已保存 **History** 来轻松地回顾和再次运行我们已发送的
    HTTP 请求。历史记录面板显示了一个列表，其中包含我们已编写和发送的每个 HTTP 请求的 HTTP 动词和 URL。我们只需点击所需的 HTTP 请求，然后点击
    **Send** 再次运行它。以下截图显示了 **History** 面板中的许多 HTTP 请求以及第一个被选中以再次发送的请求。
- en: '**JetBrains PyCharm** is a very popular multiplatform Python IDE (short for
    Integrated Development Environment) available on macOS, Linux and Windows. Its
    paid Professional version includes a REST Client that allows us to test RESTful
    Web services. In case we work with this version of the IDE, we can compose and
    send HTTP requests without leaving the IDE. You don''t need a JetBrains PyCharm
    Professional version license to run the examples included in this book. However,
    as the IDE is very popular, we will learn the necessary steps to compose and send
    an HTTP request for our API using the REST Client included in this IDE.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**JetBrains PyCharm** 是一个非常流行的多平台 Python 集成开发环境（简称 IDE），可在 macOS、Linux 和 Windows
    上使用。其付费专业版包含一个 REST 客户端，允许我们测试 RESTful Web 服务。如果我们使用这个版本的 IDE，我们可以在不离开 IDE 的情况下编写并发送
    HTTP 请求。您不需要 JetBrains PyCharm 专业版许可证来运行本书中包含的示例。然而，由于 IDE 非常受欢迎，我们将学习使用该 IDE
    中包含的 REST 客户端来编写和发送 HTTP 请求的必要步骤。'
- en: 'Now, we will use the **REST Client** included in PyCharm professional to compose
    and send an HTTP request to create a new game, specifically, a POST request. Follow
    the next steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 PyCharm 专业版中包含的 **REST 客户端**来编写并发送一个 HTTP 请求以创建一个新的游戏，具体来说，是一个 POST
    请求。按照以下步骤操作：
- en: Select **Tools** | **Test** RESTful Web Service in the main menu to display
    the REST Client panel.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中选择 **Tools** | **Test** RESTful Web Service 以显示 REST 客户端面板。
- en: Select **POST** in the HTTP method dropdown menu in the REST Client pane.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REST 客户端面板中的 HTTP 方法下拉菜单中选择 **POST**。
- en: Enter `localhost:8000` in the **Host/port** textbox, at the right-hand side
    of the dropdown.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Host/port** 文本框中输入 `localhost:8000`，位于下拉菜单的右侧。
- en: Enter `/games/` in the **Path** textbox, at the right-hand side of the **Host/port**
    textbox.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Path** 文本框中输入 `/games/`，位于 **Host/port** 文本框的右侧。
- en: Make sure that the **Request** tab is activated and click on the add (**+**)
    button at the bottom of the **Headers** list. The IDE will display a textbox for
    the name and a dropdown for the value. Enter `Content-Type` in **Name**, enter
    `application/json` in **Value** and press Enter.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保激活 **请求** 选项卡，然后点击 **Headers** 列表底部的添加 (**+**) 按钮。IDE 将显示一个用于名称的文本框和一个用于值的下拉菜单。在
    **名称** 中输入 `Content-Type`，在 **值** 中输入 `application/json` 并按 Enter 键。
- en: Activate the **Text:** radio button in **Request Body** and click the **...**
    button, on the right-hand side of the **Text** textbox, to specify the text to
    send. Enter the following lines in textbox included in the **Specify the text
    to send** dialog box and then click on **OK**.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **请求体** 中激活 **文本** 单选按钮，并点击位于 **文本** 文本框右侧的 **...** 按钮，以指定要发送的文本。在 **指定要发送的文本**
    对话框中的文本框中输入以下行，然后点击 **确定**。
- en: '[PRE93]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following screenshot shows the request built in PyCharm Professional **REST
    Client**:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了 PyCharm Professional **REST 客户端** 中构建的请求。
- en: '![Working with GUI tools - Postman and others](img/image_01_011.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GUI 工具 - Postman 及其他](img/image_01_011.jpg)'
- en: We followed the necessary steps to create an HTTP POST request with a JSON body
    that specifies the necessary key-value pairs to create a new game. Click on the
    submit request button, that is, the first button with the play icon at the upper-left
    corner of the **REST Client** pane. The REST client will compose and send the
    HTTP POST request, will activate the **Response** tab, and display the response
    code **201 (Created)**, the time it took for the request to be processed, and
    the content length at the bottom of the pane.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了必要的步骤来创建一个具有 JSON 体的 HTTP POST 请求，该体指定了创建新游戏所需的关键值对。点击提交请求按钮，即位于 **REST
    客户端** 窗口右上角的带有播放图标的第一个按钮。REST 客户端将编写并发送 HTTP POST 请求，激活 **响应** 选项卡，并在窗口底部显示响应代码
    **201 (已创建**)、请求处理所需的时间以及内容长度。
- en: 'By default, the REST client will automatically apply JSON syntax highlighting
    to the response. However, sometimes, the JSON content is displayed without line
    breaks and it is necessary to click on the reformat response button, that is,
    the first button in the **Response** tab. The REST client displays the response
    headers in another tab, and therefore, it just displays the response body in the
    **Response** tab. The following screenshot shows the JSON response body in the
    REST client for the HTTP POST request:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，REST 客户端将自动应用 JSON 语法高亮显示到响应中。但是，有时 JSON 内容会显示为没有换行，此时需要点击重格式化响应按钮，即位于
    **响应** 选项卡中的第一个按钮。REST 客户端在另一个选项卡中显示响应头，因此它仅在 **响应** 选项卡中显示响应体。以下截图显示了 REST 客户端中
    HTTP POST 请求的 JSON 响应体。
- en: '![Working with GUI tools - Postman and others](img/image_01_012.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GUI 工具 - Postman 及其他](img/image_01_012.jpg)'
- en: Tip
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If we want to compose and send an HTTP PUT request with the REST Client included
    in PyCharm Professional, it is necessary to follow the previously explained steps
    to provide JSON data within the request body.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 PyCharm Professional 中使用 REST 客户端编写和发送 HTTP PUT 请求，则需要遵循之前解释的步骤，在请求体中提供
    JSON 数据。
- en: 'In case you don''t work with PyCharm Professional, run any of the following
    commands to compose and send the HTTP POST request to create the new game:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用 PyCharm Professional，运行以下任何命令来编写和发送创建新游戏的 HTTP POST 请求：
- en: '[PRE94]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE95]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Telerik Fiddler is a popular tool for Windows developers. Telerik Fiddler is
    a free Web debugging proxy with a GUI but it only runs on Windows. Its main Web
    page promotes it as a multi-platform tool, but at the time this book was published,
    the macOS and Linux versions were completely unstable and their development abandoned.
    We can use Telerik Fiddler in Windows to compose and send HTTP requests, among
    other features. You can download Fiddler for Windows from the following URL-[https://www.telerik.com/download/fiddler](https://www.telerik.com/download/fiddler).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: Telerik Fiddler 是 Windows 开发者常用的工具。Telerik Fiddler 是一款免费的 Web 调试代理工具，具有图形用户界面，但只能在
    Windows 上运行。它的主要网页将其宣传为多平台工具，但在本书出版时，macOS 和 Linux 版本完全不稳定，并且其开发已被放弃。我们可以使用 Windows
    上的 Telerik Fiddler 来编写和发送 HTTP 请求，以及其他功能。您可以从以下网址下载 Fiddler for Windows -[https://www.telerik.com/download/fiddler](https://www.telerik.com/download/fiddler)。
- en: Stoplight is a popular powerful API modeling tool that allows us to easily test
    our APIs. Its HTTP request maker allows us to compose and send requests and generate
    the necessary code to make them in different programming languages, such as JavaScript,
    Swift, C#, PHP, Node, and Go, among others. You can sign up to work with Stoplight
    at the following URL-[http://stoplight.io](http://stoplight.io).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Stoplight 是一个流行的强大 API 模型工具，它允许我们轻松测试我们的 API。其 HTTP 请求生成器允许我们编写和发送请求，并生成在不同编程语言中（如
    JavaScript、Swift、C#、PHP、Node 和 Go 等）执行这些请求的必要代码。您可以在以下网址注册使用 Stoplight - [http://stoplight.io](http://stoplight.io)。
- en: We can also use apps that can compose and send HTTP requests from mobile devices
    to work with the RESTful API. For example, we can work with the iCurlHTTP App
    on iOS devices such as iPad and iPhone-[https://itunes.apple.com/us/app/icurlhttp/id611943891?mt=8](https://itunes.apple.com/us/app/icurlhttp/id611943891?mt=8).
    In Android devices, we can work with the HTTP Request App-[https://play.google.com/store/apps/details?id=air.http.request&hl=en](https://play.google.com/store/apps/details?id=air.http.request&hl=en).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用能够从移动设备编写和发送 HTTP 请求的应用程序来与 RESTful API 一起工作。例如，我们可以在 iOS 设备（如 iPad 和
    iPhone）上使用 iCurlHTTP 应用程序 - [https://itunes.apple.com/us/app/icurlhttp/id611943891?mt=8](https://itunes.apple.com/us/app/icurlhttp/id611943891?mt=8)。在
    Android 设备上，我们可以使用 HTTP Request 应用程序 - [https://play.google.com/store/apps/details?id=air.http.request&hl=en](https://play.google.com/store/apps/details?id=air.http.request&hl=en)。
- en: 'The following screenshot shows the results of composing and sending the following
    HTTP request with the iCurlHTTP App: `GET http://192.168.1.106:8000/games/`. Remember
    that you have to perform the previously explained configurations in your LAN and
    router to be able to access the Django development server from other devices connected
    to your LAN. In this case, the IP assigned to the computer running the Django
    Web server is `192.168.1.106`, and therefore, you must replace this IP with the
    IP assigned to your development computer.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用 iCurlHTTP 应用程序编写和发送以下 HTTP 请求的结果：`GET http://192.168.1.106:8000/games/`。请记住，您必须在您的局域网和路由器中执行之前解释的配置，才能从连接到您的局域网的其它设备访问
    Django 开发服务器。在这种情况下，运行 Django Web 服务器的计算机分配的 IP 地址是 `192.168.1.106`，因此，您必须将此 IP
    地址替换为您开发计算机分配的 IP 地址。
- en: At the time this book was published, the mobile apps that allow you to compose
    and send HTTP requests do not provide all the features you can find in Postman
    or command-line utilities.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书出版时，允许您编写和发送 HTTP 请求的移动应用程序并不提供您在 Postman 或命令行工具中可以找到的所有功能。
- en: '![Working with GUI tools - Postman and others](img/image_01_013.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![使用 GUI 工具 - Postman 及其他](img/image_01_013.jpg)'
- en: Test your knowledge
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的知识
- en: 'If we want to create a simple `Player` model that we will use to represent
    and persist players in Django REST framework, we can create:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想创建一个简单的 `Player` 模型，我们将使用它来表示和持久化 Django REST 框架中的玩家，我们可以创建：
- en: A `Player` class as a subclass of the `djangorestframework.models.Model class`.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个作为 `djangorestframework.models.Model` 类子类的 `Player` 类。
- en: A `Player` class as a subclass of the `django.db.models.Model class`.
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个作为 `django.db.models.Model` 类子类的 `Player` 类。
- en: A Player function in the `restframeworkmodels.py` file.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`restframeworkmodels.py` 文件中的一个 `Player` 函数。'
- en: 'In the Django REST Framework, serializers are:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Django REST 框架中，序列化器是：
- en: Mediators between the model instances and Python primitives.
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型实例和 Python 原语之间的调解者。
- en: Mediators between the view functions and Python primitives.
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数和 Python 原语之间的调解者。
- en: Mediators between the URLs and view functions.
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: URL 和视图函数之间的调解者。
- en: 'In the Django REST Framework, parsers and renderers:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Django REST 框架中，解析器和渲染器：
- en: Handle as mediators between model instances and Python primitives.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为模型实例和 Python 原语之间的调解者。
- en: Reset the board.
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重置棋盘。
- en: Handle as mediators between Python primitives and HTTP requests and responses.
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为 Python 原语和 HTTP 请求与响应之间的调解者。
- en: 'The `urlpatterns` list declared in the urls.py file makes it possible to:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `urls.py` 文件中声明的 `urlpatterns` 列使得：
- en: Route URLs to views.
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由 URL 映射到视图。
- en: Route URLs to models.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由 URL 映射到模型。
- en: Route URLs to Python primitives.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将路由 URL 映射到 Python 原语。
- en: 'HTTPie is a:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTPie 是一个：
- en: Command-line HTTP server written in Python that makes it easy to create a RESTful
    Web Server.
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 Python 编写的命令行 HTTP 服务器，它使得创建 RESTful Web 服务器变得容易。
- en: Command-line utility that allows us to run queries against an SQLite database.
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令行实用程序，允许我们对 SQLite 数据库运行查询。
- en: Command-line HTTP client written in Python that makes it easy to compose and
    send HTTP requests.
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用 Python 编写的命令行 HTTP 客户端，它使得编写和发送 HTTP 请求变得容易。
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed a RESTful API to interact with a simple SQLite
    database and perform CRUD operations with games. We defined the requirements for
    our API and we understood the tasks performed by each HTTP method. We learned
    the advantages of working with lightweight virtual environments in Python and
    we set up a virtual environment with Django REST Framework.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计了一个 RESTful API 来与简单的 SQLite 数据库交互，并使用游戏执行 CRUD 操作。我们定义了 API 的需求，并理解了每个
    HTTP 方法执行的任务。我们学习了在 Python 中使用轻量级虚拟环境的优势，并使用 Django REST 框架设置了一个虚拟环境。
- en: We created a model to represent and persist games and we executed migrations
    in Django. We learned to manage serialization and serialization of game instances
    into JSON representations with Django REST Framework. We wrote API views to process
    the different HTTP requests and we configured the URL patterns list to route URLs
    to views.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个模型来表示和持久化游戏，并在 Django 中执行了迁移。我们学习了如何使用 Django REST 框架管理游戏实例的序列化和反序列化到
    JSON 表示。我们编写了 API 视图来处理不同的 HTTP 请求，并配置了 URL 模式列表以将 URL 路由到视图。
- en: Finally, we started the Django development server and we used command-line tools
    to compose and send HTTP requests to our RESTful API and analyzed how each HTTP
    request was processed in our code. We also worked with GUI tools to compose and
    send HTTP requests.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动了 Django 开发服务器，并使用命令行工具向我们的 RESTful API 组合并发送 HTTP 请求，分析了我们的代码中每个 HTTP
    请求的处理方式。我们还使用图形用户界面工具来组合和发送 HTTP 请求。
- en: Now that we understand the basics of Django REST Framework, we will expand the
    capabilities of the RESTful Web API by taking advantage of the advanced features
    included in the Django REST Framework, which is what we are going to discuss in
    the next chapter.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Django REST 框架的基础知识，我们将通过利用 Django REST 框架中包含的先进功能来扩展 RESTful Web
    API 的功能，这是我们将在下一章中讨论的内容。
