<html><head></head><body>
		<div><h1 id="_idParaDest-204" class="chapter-number"><a id="_idTextAnchor218"/>11</h1>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor219"/>Effective UI Testing for React Components</h1>
			<p>We have already been introduced to testing with Python and Django in <a href="B18221_05.xhtml#_idTextAnchor091"><em class="italic">Chapter 5</em></a><em class="italic">, Testing the REST API</em>. In this chapter, the context is different as we will work with JavaScript and React to test the frontend components we have designed and implemented. This chapter will show you what to test in a frontend application and how to write tests for React UI components.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Component testing in React</li>
				<li>Jest and the <strong class="bold">React Testing </strong><strong class="bold">Library</strong> (<strong class="bold">RTL</strong>)</li>
				<li>Testing form components</li>
				<li>Testing <code>post</code> components</li>
				<li>Snapshot testing</li>
			</ul>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor220"/>Technical requirements</h1>
			<p>Make sure to have VS Code and an updated browser installed and configured on your machine. You can find the code from this chapter at <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11</a>.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor221"/>Component testing in React</h1>
			<p>We already<a id="_idIndexMarker636"/> understand that the frontend is the client-side section of an application. Concerning the tests we wrote in <a href="B18221_05.xhtml#_idTextAnchor091"><em class="italic">Chapter 5</em></a><em class="italic">, Testing the REST API</em>, in our Django applications, we <a id="_idIndexMarker637"/>mostly tested whether the database stored the right data passed to the viewsets, serializers, and models. However, we didn’t test the user interface.</p>
			<p>As a React developer, you might be thinking: what do I test in my frontend application? Well, let’s respond to this question by understanding why a frontend test is needed and what needs to be tested.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor222"/>The necessity of testing your frontend</h2>
			<p>When developing an<a id="_idIndexMarker638"/> application, it’s important to ensure that your application works as expected in a production environment.</p>
			<p>The frontend also represents the interface the user will use to interact with your backend. For a good user experience, it’s crucial to write tests that ensure that your components are behaving as expected.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor223"/>What to test in your React application</h2>
			<p>If you are coming from a backend viewpoint, you might be a little bit confused about what to test in your frontend<a id="_idIndexMarker639"/> application. From a basic aspect, it’s not different from testing your backend. If you have classes or methods in your application, you can write tests. Frontend testing includes testing different aspects of the UI such as formatting, visible text, graphics, and the functional parts of the applications such as buttons, forms, or clickable links.</p>
			<p>Now, the difference is that your React frontend is made of UI components, taking props for displaying data to the user. The React ecosystem provides testing tools that easily help you write tests for your components.</p>
			<p>In the next section, we will start with a small introduction to Jest and the RTL and then we will write tests for our authentication forms.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor224"/>Jest, the RTL, and fixtures</h1>
			<p><strong class="bold">Jest</strong> is a JavaScript framework for <a id="_idIndexMarker640"/>writing, running, and structuring tests. It comes with all the tools needed to check code coverage, easily mock functions, and imported functions, and write simple and great exceptions. The RTL is a library for actually testing React applications. It focuses on testing components from a user experience point of view rather than testing the implementation and logic of the React components themselves.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When writing tests, you will often need to ensure that some values or variables meet certain conditions. This was done in <a href="B18221_05.xhtml#_idTextAnchor091"><em class="italic">Chapter 5</em></a><em class="italic">, Testing the REST API</em>, of this book, using <code>assert</code> when writing tests for the Django application using pytest. Working with Jest, the term changes from assertion to exceptions. When doing frontend testing with Jest, we are expecting the value to meet a condition. For example, if the user enters and clicks on a button that will reset a form, we expect the form to be reset after the click action is made on the button.</p>
			<p>The RTL is not separated <a id="_idIndexMarker641"/>from Jest as you need both to write tests for your frontend application. Jest will help you write the testing blocks while the RTL will provide tools to select components, render the components, and trigger common user events such as clicking and typing. These tools are already installed by default when creating a React project, so there is no need to add other packages.</p>
			<p>The only packages we will need are <code>faker.js</code> and the JavaScript <code>uuid</code> package to generate UUID4 identifiers. Faker is a JavaScript package used to generate fake, but realistic, data. In the React project, use the following command to install the package as a development dependency:</p>
			<pre class="console">
yarn add @faker-js/faker uuid –dev</pre>
			<p>With the packages installed, we can now add some important fixtures for the components we are going to test in the next lines.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor225"/>Writing testing fixtures</h2>
			<p>In the <code>src/helpers</code> directory, create a new directory called <code>fixtures</code>. This directory will contain JavaScript files<a id="_idIndexMarker642"/> containing functions that return fixtures that can be used for testing.</p>
			<p>We’ll start by writing fixtures for a user. So, in the <code>fixtures</code> directory, create a new file called <code>user.js</code>. This file will contain code for a function that returns realistic data for a user object. Let’s start with the imports of functions from the <code>faker.js</code> and <code>uuid</code> packages to create a fixture:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/user.js</p>
			<pre class="source-code">
import { faker } from "@faker-js/faker";
import { v4 as uuid4 } from "uuid";
function userFixtures() {
...
}
export default userFixtures;</pre>
			<p>With the imports and the <a id="_idIndexMarker643"/>structure of the <code>userFixtures</code> function written, we can now return the object fixture:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/user.js</p>
			<pre class="source-code">
...
function userFixtures() {
 const firstName = faker.name.firstName();
 const lastName = faker.name.lastName();
 return {
   id: uuid4(),
   first_name: firstName,
   last_name: lastName,
   name: firstName + " " + lastName,
   post_count: Math.floor(Math.random() * 10),
   email: `${firstName}@yopmail.com`,
   bio: faker.lorem.sentence(20),
   username: firstName + lastName,
   avatar: null,
   created: faker.date.recent(),
   updated: faker.date.recent(),
 };
}
...</pre>
			<p>Faker provides a lot of modules with methods to return data. In the previous code block, we are working with <code>faker.name</code> to generate random names, <code>faker.lorem</code> to generate random lorem texts, and <code>faker.date</code> to generate a recent date. The object returned by <code>userFixtures</code> now <a id="_idIndexMarker644"/>has the closest structure to a user object returned by the Django API we have created, and this is exactly what we want.</p>
			<p>Before diving into component testing, let’s make sure our testing environment is well configured.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor226"/>Running the first test</h2>
			<p>When a React application is <a id="_idIndexMarker645"/>created, the <code>App.js</code> file comes with a test file called <code>App.test.js</code>, which you can see here:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/App.test.js</p>
			<pre class="source-code">
import { render, screen } from "@testing-library/react";
import App from "./App";
test("renders learn react link", () =&gt; {
 render(&lt;App /&gt;);
<strong class="bold"> const linkElement = screen.getByText(/learn react/i);</strong>
 expect(linkElement).toBeInTheDocument();
});</pre>
			<p>Let me explain the code. Here, we are importing the <code>render</code> and <code>screen</code> methods from the RTL. These modules will be used to render a component and make interactions with the components easier by providing methods to select DOM elements, respectively.</p>
			<p>Next, we have the <code>test</code> method. It’s simply a Jest keyword used to write tests. It takes two parameters: a string describing the test, and the callback function where you write the testing logic. Inside the callback function, the <code>App</code> component is rendered first. Then, <code>linkElement</code> is retrieved from the screen by using the <code>learn react</code> text. Once it’s retrieved, we can<a id="_idIndexMarker646"/> then check whether the <code>linkElement</code> exists in the rendered document.</p>
			<p>Let’s run this test with the following command:</p>
			<pre class="source-code">
yarn test</pre>
			<p>You should have a similar output in the terminal.</p>
			<div><div><img src="img/Figure_11.01_B18221.jpg" alt="Figure 11.1 – Running the yarn test command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Running the yarn test command</p>
			<p>The test has failed. But why? You can somewhat see why in the preceding output.</p>
			<div><div><img src="img/Figure_11.02_B18221.jpg" alt="Figure 11.2 – Reason for failing the App.js test"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Reason for failing the App.js test</p>
			<p>The <code>App</code> component in our project uses <code>react-router-dom</code> components, such as <code>Routes</code>, that in turn use the <code>useRoutes</code> Hook. This Hook makes use of the context that a router component provides, so we need to wrap it inside a Router, in this case, the <code>BrowserRouter</code> component. Let’s correct this, but let’s also change the text from which we will retrieve the link element:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/App.test.js</p>
			<pre class="source-code">
import { render, screen } from "@testing-library/react";
import App from "./App";
import { BrowserRouter } from "react-router-dom";
test("renders Welcome to Postagram text", () =&gt; {
 render(
   &lt;BrowserRouter&gt;
     &lt;App /&gt;
   &lt;/BrowserRouter&gt;
 );
 const textElement =
   screen.getByText(/Welcome to Postagram!/i);
 expect(textElement).toBeInTheDocument();
});</pre>
			<p>Now, run the tests again and<a id="_idIndexMarker647"/> everything should work correctly:</p>
			<div><div><img src="img/Figure_11.03_B18221.jpg" alt="Figure 11.3 – Passing tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Passing tests</p>
			<p>But we still have a problem. A lot of components in the React application use Hooks from the <code>react-router-dom</code> library. That means that for each test, we will need to wrap the component inside <code>BrowserRouter</code>. Following the DRY principle, let’s rewrite the render method from<a id="_idIndexMarker648"/> the RTL to automatically wrap our components inside the <code>BrowserRouter</code>.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor227"/>Extending the RTL render method</h2>
			<p>Inside the <code>src/helpers</code> directory, create a file called <code>test-utils.jsx</code>. Once the file is created, add the following<a id="_idIndexMarker649"/> lines of code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/test-utils.jsx</p>
			<pre class="source-code">
import React from "react";
import { render as rtlRender } from "@testing-library/react";
import { BrowserRouter } from "react-router-dom";
function render(ui, { ...renderOptions } = {}) {
 const Wrapper = ({ children }) =&gt;
   &lt;BrowserRouter&gt;{children}&lt;/BrowserRouter&gt;;
 return rtlRender(ui, { wrapper: Wrapper, ...renderOptions
   });
}
export * from "@testing-library/react";
export { render };</pre>
			<p>In the code, we first import the needed tools. Notice the import of the render method as <code>rtlRender</code>? It’s for the purpose of avoiding a naming collision as we are also writing a render function. Next, we create a function called <code>Wrapper</code>, where we pass the children’s argument, then wrap it inside a <code>BrowserRouter</code> component. Then, we return a render object with the UI, <code>wrapper</code>, and other render options if specified.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The render method from the RTL provides render options other than the wrapper. You can also pass a container, queries, and a lot more. You can check more rendering options in the official documentation at <a href="https://testing-library.com/docs/react-testing-library/api/#render-options">https://testing-library.com/docs/react-testing-library/api/#render-options</a>.</p>
			<p>Now, let’s use this <a id="_idIndexMarker650"/>method in <code>App.test.js</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/App.test.js</p>
			<pre class="source-code">
import { render, screen } from "@testing-library/react";
import App from "./App";
test("renders Welcome to Postagram text", () =&gt; {
 render(&lt;App /&gt;);
...
});</pre>
			<p>Run the testing command again and everything should be green. With the testing environment ready and set up to quickly write tests, we can now move on to testing the components of the React project.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">While running tests, you might encounter an error coming from the <code>axios</code> package. At the time of writing of this book, we are using the 0.26.0 version of <code>axios</code> to avoid bugs when running tests. You can also modify the test command in the <code>package.json</code> file to the following: <code>"test": "react-scripts test --transformIgnorePatterns "node_modules/(?!axios)/""</code>. Learn more about this issue at <a href="https://github.com/axios/axios/issues/5101">https://github.com/axios/axios/issues/5101</a>.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor228"/>Testing authentication components</h1>
			<p>Testing forms in React<a id="_idIndexMarker651"/> might seem complicated but it is quite simple when using Jest and the RTL. We will begin writing tests in the React project, starting with the authentication components. I’ll show you how you can write a test for the <strong class="bold">Login</strong> form, and after that, you should be able to write the registration form test suite.</p>
			<p>For a better structured code base, create a new directory called <code>__tests__</code> in the <code>src/components/authentication</code> directory. This directory will contain tests for the components in the <code>components/authentication</code> directory. Inside the newly created directory, create a<a id="_idIndexMarker652"/> file called <code>LoginForm.test.js</code> and add the following code:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/__tests__/LoginForm.test.js</p>
			<pre class="source-code">
import { render, screen } from "../../../helpers/test-utils";
import userEvent from "@testing-library/user-event";
import LoginForm from "../LoginForm";
import { faker } from "@faker-js/faker";
import userFixtures from "../../../helpers/fixtures/user";
const userData = userFixtures();
test("renders Login form", async () =&gt; {
...
});</pre>
			<p>In the preceding code, we have added the required imports to write the test and defined the structure of the testing function. We will first render the <code>LoginForm</code> component and set up the user object to trigger user behavior events using <code>userEvent</code> <code>method:src/components/authentication/__tests__/LoginForm.test.js</code>:</p>
			<pre class="source-code">
...
test("renders Login form", async () =&gt; {
 const user = userEvent.setup();
 render(&lt;LoginForm /&gt;);
...</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout"><code>userEvent</code> and <code>fireEvent</code> are both methods used for simulating user interactions with a website in the context of testing. They can be used to test the behavior of a website when a user performs certain actions, such as clicking a button or filling out a form.</p>
			<p class="callout"><code>userEvent</code> is a method provided by the <code>@testing-library/user-event</code> library, which is designed to make it easier to test user interactions with a website. It is a utility function that simulates user events by using the <code>fireEvent</code> method provided by the <code>@testing-library/react</code> library. <code>userEvent</code> allows you to specify the type of event you want to simulate, such as a click or a keypress, and it will automatically dispatch the appropriate event for you.</p>
			<p class="callout"><code>fireEvent</code> is a method provided by the <code>@testing-library/react</code> library, which can be used to dispatch events to a DOM element. It allows you to specify the type of event you want to dispatch, as well as any additional event data that you want to include. <code>fireEvent</code> is a more low-level method than <code>userEvent</code>, and it requires you to manually specify the details of the event you want to dispatch.</p>
			<p>After that, we can start<a id="_idIndexMarker653"/> by testing that the form and the inputs are rendered in the document:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/__tests__/LoginForm.test.js</p>
			<pre class="source-code">
test("renders Login form", async () =&gt; {
...
 const loginForm = screen.getByTestId("login-form");
 expect(loginForm).toBeInTheDocument();
const usernameField = screen.getByTestId("username-field");
expect(usernameField).toBeInTheDocument();
const passwordField = screen.getByTestId("password-field");
expect(passwordField).toBeInTheDocument();
...</pre>
			<p>Then, we can ensure that the inputs can receive texts and values as we have already selected the username and <a id="_idIndexMarker654"/>password fields:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/__tests__/LoginForm.test.js</p>
			<pre class="source-code">
test("renders Login form", async () =&gt; {
...
 const password = faker.lorem.slug(2);
 await user.type(usernameField, userData.username);
 await user.type(passwordField, password);
 expect(usernameField.value).toBe(userData.username);
 expect(passwordField.value).toBe(password);
});</pre>
			<p>If you run the test command again, it will fail. That’s normal, as here we are retrieving elements using the <code>getByTestId</code> method. The RTL looks in the rendered DOM for an element with a <code>data-testid</code> attribute with the value passed to the <code>screen.getByTestId</code> function. We need to add the attribute to the elements we want to select and test.</p>
			<p>To do so, in <code>src/components/authentication/LoginForm.js</code>, add the following <code>data-testid</code> attributes:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/LoginForm.js</p>
			<pre class="source-code">
function LoginForm() {
...
 return (
   &lt;Form
     id="registration-form"
     className="border p-4 rounded"
     noValidate
     validated={validated}
     onSubmit={handleSubmit}
<strong class="bold">     data-testid="login-form"</strong>
   &gt;
...
       &lt;Form.Label&gt;Username&lt;/Form.Label&gt;
       &lt;Form.Control
         value={form.username}
<strong class="bold">         data-testid="username-field"</strong>
...
     &lt;Form.Group className="mb-3"&gt;
       &lt;Form.Label&gt;Password&lt;/Form.Label&gt;
       &lt;Form.Control
         value={form.password}
<code>         data-testid="password-field"</code>
...</pre>
			<p>Once done, re-run the testing <a id="_idIndexMarker655"/>command. Everything should work.</p>
			<p>The next step is to write tests for the registration form component. It’ll be similar to the tests on the<a id="_idIndexMarker656"/> login form component, so you can handle this small exercise. You can find the solution at <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js">https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js</a>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">JavaScript also possesses default naming conventions for the testing files. The naming conventions for test files in a JavaScript project are as follows:</p>
			<p class="callout">- <code>&lt;</code><code>TestFileName&gt;.test.js</code></p>
			<p class="callout">- <code>&lt;</code><code>TestFileName&gt;.spec.js</code></p>
			<p>Now that we have had a solid introduction to testing in React, let’s continue with writing tests for the Post components.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor229"/>Testing Post components</h1>
			<p>The functionalities to create, read, update, and delete<a id="_idIndexMarker657"/> posts are core features of the Postagram application, so it’s important to make sure that they work as expected. Let’s start with a simple test for the <code>Post</code> component.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor230"/>Mocking the localStorage object</h2>
			<p>Before writing a test for the <code>Post</code> <a id="_idIndexMarker658"/>component, it’s important to understand how the Post components work. Basically, it takes a prop called <code>post</code> and makes a call to <code>localStorage</code> to retrieve information about the user. Unfortunately, <code>localStorage</code> can’t be mocked by Jest. There are a lot of workarounds to allow your tests to work with <code>localStorage</code> and to make it simple and have less boilerplate, we’ll use the <code>jest-localstorage-mock</code> JavaScript package. The package can be used with Jest to run frontend tests that rely on <code>localStorage</code>. To add the package, add the following line to the file:</p>
			<pre class="source-code">
yarn add --dev jest-localstorage-mock</pre>
			<p>Once the package is installed, we need to do some configurations. In the <code>src/setupTests.js</code> file, add this line to load the <code>jest-localstorage-mock</code> package:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/setupTests.js</p>
			<pre class="source-code">
...
require('jest-localstorage-mock');</pre>
			<p>After that, override the <a id="_idIndexMarker659"/>default Jest configuration in the <code>package.json</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
			<pre class="source-code">
...
{
  "jest": {
    "resetMocks": false
  }
}
...</pre>
			<p>With the configuration ready, we can move to add a function to generate post fixtures.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor231"/>Writing post fixtures</h2>
			<p>In the <code>src/helpers/fixtures</code> directory, create a new file called <code>post.js</code>. This file will contain a function that<a id="_idIndexMarker660"/> returns fake data from a post object.</p>
			<p>We will start writing the code in this file by adding the imports and defining the <code>postFixtures</code> function that will return a generated post object:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/post.js</p>
			<pre class="source-code">
import { faker } from "@faker-js/faker";
import { v4 as uuid4 } from "uuid";
import userFixtures from "./user";
function postFixtures(isLiked = true, isEdited = false, user = undefined) {
...
}
export default postFixtures;</pre>
			<p>Let’s add the body<a id="_idIndexMarker661"/> of the <code>postFixtures</code> function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/post.js</p>
			<pre class="source-code">
...
function postFixtures(isLiked = true, isEdited = false, user = undefined) {
 return {
   id: uuid4(),
   author: user || userFixtures(),
   body: faker.lorem.sentence(20),
   edited: isEdited,
   liked: isLiked,
   likes_count: Math.floor(Math.random() * 10),
   comments_count: Math.floor(Math.random() * 10),
   created: faker.date.recent(),
   updated: faker.date.recent(),
 };
}</pre>
			<p>Here, we are passing<a id="_idIndexMarker662"/> either a generated <code>userFixtures</code> or a user object if it’s defined. This is important if we want to make sure that the author of the post is the same user registered in <code>localStorage</code>.</p>
			<p>With the post fixtures written, we can write the test suite for the <code>Post</code> component.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor232"/>Writing tests for the Post component</h2>
			<p>To write the test suite in the <code>src/components/posts</code> directory, create a new folder called <code>__tests__</code>. Inside the<a id="_idIndexMarker663"/> newly created folder, add a new file called <code>Post.test.js</code>. Inside, add the imports, create the data we need, and set user data returned by the <code>userFixtures</code> function in the local storage using the <code>setUserData</code> function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/Post.test.js</p>
			<pre class="source-code">
import { render, screen } from "../../../helpers/test-utils";
import Post from "../Post";
import { setUserData } from "../../../hooks/user.actions";
import userFixtures from "../../../helpers/fixtures/user";
import postFixtures from "../../../helpers/fixtures/post";
const userData = userFixtures();
const postData = postFixtures(true, false, userData);
beforeEach(() =&gt; {
 // to fully reset the state between __tests__, clear the
 // storage
 localStorage.clear();
 // and reset all mocks
 jest.clearAllMocks();
 setUserData({
   user: userData,
   access: null,
   refresh: null,
 });
});</pre>
			<p>The <code>beforeEach</code> method is a Jest method that runs before every test. It takes a callback function as a parameter, where <a id="_idIndexMarker664"/>you can execute lines of code that should run before the tests. Here, we are clearing the local storage first to avoid memory leaking (with <code>localStorage.clear</code>) and finally, we set user data retrieved from the <code>userFixtures</code> function in the local storage.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A memory leak occurs when a program creates a memory in heap and forgets to delete it. In a worst-case scenario, if too much memory is allocated and not used correctly, this can reduce the computer’s performance.</p>
			<p>Let’s write the test for the <code>Post</code> component now:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/Post.test.js</p>
			<pre class="source-code">
...
test("render Post component", () =&gt; {
 render(&lt;Post post={postData} /&gt;);
 const postElement = screen.getByTestId("post-test");
 expect(postElement).toBeInTheDocument();
});</pre>
			<p>If you run the test<a id="_idIndexMarker665"/> command, it’ll fail. This is normal because there is no <code>data-testid</code> attribute with the value <code>post-test</code> set in the JSX of the <code>Post</code> component. Let’s fix this by adding a <code>data-testid</code> attribute in the <code>Post</code> component :</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/Post.jsx</p>
			<pre class="source-code">
...
function Post(props) {
...
 return (
   &lt;&gt;
<strong class="bold">     &lt;Card className="rounded-3 my-4"</strong>
<strong class="bold">       data-testid="post-test"&gt;</strong>
...
   &lt;/&gt;
 );
}
export default Post;</pre>
			<p>Run the testing command again and everything should be green. Let’s move on to actually writing a test for the <code>CreatePost</code> component.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor233"/>Testing the CreatePost component</h2>
			<p>In the <code>src/components/posts/__tests__</code> directory, create a new file called <code>CreatePost.test.js</code>. We’ll start with the <a id="_idIndexMarker666"/>necessary imports and the definition of the <code>test</code> function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
import { render, screen, fireEvent } from "../../../helpers/test-utils";
import userEvent from "@testing-library/user-event";
import CreatePost from "../CreatePost";
import { faker } from "@faker-js/faker";
test("Renders CreatePost component", async () =&gt; {
...
});</pre>
			<p>You can notice the introduction of the <code>async</code> keyword before the callback function. To create a post, the user performs typing operations on text inputs and finally a button click to submit the post. These actions are asynchronous. The functions, such as <code>fireEvent</code>, that we will use to simulate user interactions should be used in an asynchronous scope.</p>
			<p>Before writing the test logic, let’s remember how the <code>CreatePost</code> component works:</p>
			<ol>
				<li>The user clicks on the input to add a new post.</li>
				<li>A modal is shown containing a form where the user can enter the text of the post. Meanwhile, the submit button is disabled.</li>
				<li>Once there is enough text in the field, the submit button is enabled and the user can click to send the post.</li>
			</ol>
			<p>We must ensure that we respect this logic when writing the tests. Now, let’s start writing the tests.</p>
			<p>First, we render the form that displays the form modal to create a post:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
test("Renders CreatePost component", async () =&gt; {
 const user = userEvent.setup();
 render(&lt;CreatePost /&gt;);
 const showModalForm =
   screen.getByTestId("show-modal-form");
 expect(showModalForm).toBeInTheDocument();
});</pre>
			<p>We can now simulate a<a id="_idIndexMarker667"/> click event using <code>fireEvent.click</code> on <code>showModalForm</code> to display the form for creating a post:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
...
 // Clicking to show the modal
 fireEvent.click(showModalForm);
 const createFormElement =
   screen.getByTestId("create-post-form");
 expect(createFormElement).toBeInTheDocument();
...</pre>
			<p>We then make sure that the body field is rendered and the submit button is disabled:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
...
 const postBodyField =
   screen.getByTestId("post-body-field");
 expect(postBodyField).toBeInTheDocument();
 const submitButton =
   screen.getByTestId("create-post-submit");
 expect(submitButton).toBeInTheDocument();
 expect(submitButton.disabled).toBeTruthy();
 ...</pre>
			<p>After that, we can<a id="_idIndexMarker668"/> then type some text in the body field, test whether the text typed is what we expect, and ensure that the button is enabled after that:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
 ...
 const postBody = faker.lorem.sentence(10);
 await user.type(postBodyField, postBody);
 // Checking if field has the text and button is not
 // disabled
 expect(postBodyField.value).toBe(postBody);
 expect(submitButton.disabled).toBeFalsy();
});</pre>
			<p>Great! We have a solid testing suite and we can now add the <code>data-testid</code> attributes to the <code>CreatePost</code> component<a id="_idIndexMarker669"/> to make the tests pass:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/CreatePost.jsx</p>
			<pre class="source-code">
function CreatePost() {
...
 return (
   &lt;&gt;
     &lt;Form.Group className="my-3 w-75"&gt;
       &lt;Form.Control
         className="py-2 rounded-pill border-primary
                    text-primary"
<strong class="bold">         data-testid="show-modal-form"</strong>
...
       &lt;Modal.Body className="border-0"&gt;
         &lt;Form
           noValidate
           validated={validated}
           onSubmit={handleSubmit}
<strong class="bold">           data-testid="create-post-form"</strong>
         &gt;
           &lt;Form.Group className="mb-3"&gt;
             &lt;Form.Control
               name="body"
<strong class="bold">               data-testid="post-body-field"</strong>
...
       &lt;/Modal.Body&gt;
       &lt;Modal.Footer&gt;
         &lt;Button
           variant="primary"
           onClick={handleSubmit}
           disabled={!form.body}
<strong class="bold">           data-testid="create-post-submit"</strong>
...
   &lt;/&gt;
 );
}</pre>
			<p>Run the test command again and<a id="_idIndexMarker670"/> everything should work. The next step is to write unit tests for the <code>UpdatePost</code> component.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor234"/>Testing the UpdatePost component</h2>
			<p>In the <code>src/components/posts/__tests__</code> directory, create a new file called <code>UpdatePost.test.js</code>. Let’s start <a id="_idIndexMarker671"/>with the necessary imports and the definition of the <code>test</code> function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
import { render, screen, fireEvent } from "../../../helpers/test-utils";
import userEvent from "@testing-library/user-event";
import UpdatePost from "../UpdatePost";
import userFixtures from "../../../helpers/fixtures/user";
import postFixtures from "../../../helpers/fixtures/post";
import { faker } from "@faker-js/faker";
const userData = userFixtures();
const postData = postFixtures(true, false, userData);
test("Render UpdatePost component", async () =&gt; {
...
});</pre>
			<p>Before writing the test logic, let’s remember how the <code>UpdatePost</code> component works from a user’s perspective:</p>
			<ol>
				<li value="1">The user clicks on the drop-down item to modify a post.</li>
				<li>A modal is shown containing a form where the user can modify the text of the post.</li>
				<li>After the modification, the user can submit the form with the updated post.</li>
			</ol>
			<p>We must ensure that we <a id="_idIndexMarker672"/>respect that logic when writing the tests.</p>
			<p>So, first, we render the form that displays the form modal to update a post:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
test("Render UpdatePost component", async () =&gt; {
 const user = userEvent.setup();
 render(&lt;UpdatePost post={postData} /&gt;);
 const showModalForm =
   screen.getByTestId("show-modal-form");
 expect(showModalForm).toBeInTheDocument();
...</pre>
			<p>We then want to trigger a<a id="_idIndexMarker673"/> click event to display the modal with the form to update the post:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
...
 fireEvent.click(showModalForm);
 const updateFormElement =
   screen.getByTestId("update-post-form");
 expect(updateFormElement).toBeInTheDocument();
...</pre>
			<p>We then select the post body field and the submit button to ensure that they are rendered:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
...
 const postBodyField =
   screen.getByTestId("post-body-field");
 expect(postBodyField).toBeInTheDocument();
 const submitButton =
   screen.getByTestId("update-post-submit");
 expect(submitButton).toBeInTheDocument();
...</pre>
			<p>After that, we can now trigger a typing event in the post body field and ensure that the user is submitting the right data:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
...
 const postBody = faker.lorem.sentence(10);
 await user.type(postBodyField, postBody);
 // Checking if field has the text and button is not
 // disabled
 expect(postBodyField.value).toBe(postData.body +
   postBody);
 expect(submitButton.disabled).toBeFalsy();
});</pre>
			<p>The next step is now<a id="_idIndexMarker674"/> to add the <code>data-testid</code> attributes on the post form, the post body input, and the submit button in the <code>UpdatePost</code> component to make the tests pass:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/UpdatePost.jsx</p>
			<pre class="source-code">
...
function UpdatePost(props) {
...
 return (
   &lt;&gt;
     &lt;Dropdown.Item data-testid="show-modal-form"
       onClick={handleShow}&gt;
...
       &lt;Modal.Body className="border-0"&gt;
         &lt;Form
          noValidate
          validated={validated}
          onSubmit={handleSubmit}
<strong class="bold">    data-testid="update-post-form"</strong>
   &gt;
           &lt;Form.Group className="mb-3"&gt;
             &lt;Form.Control
               name="body"
               value={form.body}
<strong class="bold">               data-testid="post-body-field"</strong>
...
       &lt;/Modal.Body&gt;
       &lt;Modal.Footer&gt;
         &lt;Button
<strong class="bold">           data-testid="update-post-submit"</strong>
...</pre>
			<p>Run the test command again and everything should work.</p>
			<p>With this introduction<a id="_idIndexMarker675"/> to complex tests with Jest and the RTL, you can easily write the tests for the comment’s components. You can find the solution for these tests at <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__</a>. Good luck!</p>
			<p>In the next section, we will <a id="_idIndexMarker676"/>discover what snapshot testing is.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor235"/>Snapshot testing</h1>
			<p>Snapshot tests are a very useful tool <a id="_idIndexMarker677"/>when you want to make sure that your UI does not change unexpectedly. A snapshot test case follows these steps:</p>
			<ul>
				<li>It renders the UI<a id="_idIndexMarker678"/> component.</li>
				<li>It then takes a snapshot and compares it to a reference snapshot file stored alongside the test file.</li>
				<li>If both states are the same, the snapshot test is successful. Otherwise, you will get errors and need to decide whether you need to update the snapshot tests or fix your components.</li>
			</ul>
			<p>Snapshot tests are great to prevent UI regression and ensure that the application adheres to the code quality and values of your development team.</p>
			<p>There is a minor setback with snapshot tests, however. Snapshot testing doesn’t work best with dynamic components. For example, the <code>Post</code> component uses <code>timeago</code> to display a human-readable time. This means that a snapshot of this component at time <code>t</code> will be different from a snapshot of the same component at time <code>t + 1</code>. However, there are some static components in the React application such as <code>LoginForm</code>, <code>RegistrationForm</code>, <code>ProfileDetails</code>, <code>ProfileCard</code>, <code>CreatePost</code>, and much more.</p>
			<p>For the sake of simplicity, we will write a snapshot test for the <code>ProfileCard</code> components, which are straightforward and can be replicated easily.</p>
			<p>In the <code>src/components/profile</code> directory, create a new directory called <code>__tests__</code>. Then, create a new file called <code>ProfileCard.test.js</code>. For a snapshot test, we don’t want the data to change so we will use a static user fixture because using <code>userFixtures</code> to generate a fixture will create random data every time a snapshot test is run. In the newly created file, let’s add the imports needed to create a snapshot test and define a fixture <a id="_idIndexMarker679"/>object called <code>userData</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/profile/__tests__/ProfileCard.test.js</p>
			<pre class="source-code">
import { render, screen } from "../../../helpers/test-utils";
import TestRenderer from "react-test-renderer";
import ProfileCard from "../ProfileCard";
import { BrowserRouter } from "react-router-dom";
const userData = {
 id: "0590cd67-eacd-4299-8413-605bd547ea17",
 first_name: "Mossie",
 last_name: "Murphy",
 name: "Mossie Murphy",
 post_count: 3,
 email: "Mossie@yopmail.com",
 bio: "Omnis necessitatibus facere vel in est provident
       sunt tempora earum accusantium debitis vel est
       architecto minima quis sint et asperiores.",
 username: "MossieMurphy",
 avatar: null,
 created: "2022-08-19T17:31:03.310Z",
 updated: "2022-08-20T07:38:47.631Z",
};</pre>
			<p>With the needed imports added and the <code>userData</code> fixtures written, we can now write the testing function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/profile/__tests__/ProfileCard.test.js</p>
			<pre class="source-code">
...
test("Profile Card snapshot", () =&gt; {
 const profileCardDomTree = TestRenderer.create(
   &lt;BrowserRouter&gt;
     &lt;ProfileCard user={userData} /&gt;
   &lt;/BrowserRouter&gt;
 ).toJSON();
 expect(profileCardDomTree).toMatchSnapshot();
});</pre>
			<p>If you run the test command, you’ll <a id="_idIndexMarker680"/>notice that a snapshot directory is created in the <code>__tests__</code> directory:</p>
			<div><div><img src="img/Figure_11.04_B18221.jpg" alt="Figure 11.4 – Snapshots directory created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Snapshots directory created</p>
			<p>If you check the content of <code>ProfileCard.test.js.snap</code>, it is basically the rendered code of the <code>ProfileCard</code> component. The content of this file will be compared each time the test function for the snapshot test runs.</p>
			<p>Now have covered the essential unit tests for a React application, we are mostly done adding features to the application. Our full stack application is now ready for production! Yay, but don’t celebrate too soon. We still need to prepare our application for production in terms of the security, quality, and performance aspects and this is what we’ll be doing in <em class="italic">Part 3</em> of this book.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor236"/>Summary</h1>
			<p>In this chapter, you have learned about frontend unit testing. We discovered why it is important to write unit tests in the frontend application and what to test exactly. We have also written tests for components in the Postagram application, seen how we can extend testing tools modules and methods, how to write generate fixtures for the tests, and how to make the tests <a id="_idIndexMarker681"/>closer to user interactions by triggering user events. We have also made some introductions to snapshot testing.</p>
			<p>The next chapters in <em class="italic">Part 3</em> of this book will focus on deploying the backend and the frontend on the cloud using AWS services, GitHub, and GitHub Actions. Lastly, we will see how to improve the full stack application in terms of performance, security, and quality.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor237"/>Questions</h1>
			<ol>
				<li value="1">What is the render method of the RTL?</li>
				<li>What is Jest?</li>
				<li>What is the role of the <code>data-tested</code> attribute?</li>
				<li>What are the drawbacks of snapshot testing?</li>
				<li>What are the modules used to trigger user events on a React test suite?</li>
			</ol>
		</div>
	

		<div><h1 id="_idParaDest-224"><a id="_idTextAnchor238"/>Part 3: Deploying Django and React on AWS</h1>
			<p>Deployment is one of the last important steps in software development. Your application is running locally and everything is working fine. But how do you get your code on a public server? How do you host your frontend? How do you make changes to your code and make deployment and testing automatic? In this part of the book, we’ll explore topics such as CI/CD, GitHub, Docker, and the best deployment practices while deploying the Django application on AWS EC2 and the React application on AWS S3. We’ll also talk about security and performance.</p>
			<p>This section comprises the following chapters:</p>
			<ul>
				<li><a href="B18221_12.xhtml#_idTextAnchor239"><em class="italic">Chapter 12</em></a>, <em class="italic">Deployment Basics – Git, GitHub, and AWS</em></li>
				<li><a href="B18221_13.xhtml#_idTextAnchor252"><em class="italic">Chapter 13</em></a>, <em class="italic">Dockerizing the Django Project</em></li>
				<li><a href="B18221_14.xhtml#_idTextAnchor286"><em class="italic">Chapter 14</em></a>, <em class="italic">Automating Deployment on AWS</em></li>
				<li><a href="B18221_15.xhtml#_idTextAnchor330"><em class="italic">Chapter 15</em></a>, <em class="italic">Deploying Our React App on AWS</em></li>
				<li><a href="B18221_16.xhtml#_idTextAnchor352"><em class="italic">Chapter 16</em></a>, <em class="italic">Performance, Optimization, and Security</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>