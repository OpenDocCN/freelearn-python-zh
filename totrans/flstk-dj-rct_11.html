<html><head></head><body>
		<div id="_idContainer126">
			<h1 id="_idParaDest-204" class="chapter-number"><a id="_idTextAnchor218"/>11</h1>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor219"/>Effective UI Testing for React Components</h1>
			<p>We have already been introduced to testing with Python and Django in <a href="B18221_05.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Testing the REST API</em>. In this chapter, the context is different as we will work with JavaScript and React to test the frontend components we have designed and implemented. This chapter will show you what to test in a frontend application and how to write tests for React <span class="No-Break">UI components.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Component testing <span class="No-Break">in React</span></li>
				<li>Jest and the <strong class="bold">React Testing </strong><span class="No-Break"><strong class="bold">Library</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">RTL</strong></span><span class="No-Break">)</span></li>
				<li>Testing <span class="No-Break">form components</span></li>
				<li>Testing <span class="No-Break"><strong class="source-inline">post</strong></span><span class="No-Break"> components</span></li>
				<li><span class="No-Break">Snapshot testing</span></li>
			</ul>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor220"/>Technical requirements</h1>
			<p>Make sure to have VS Code and an updated browser installed and configured on your machine. You can find the code from this chapter <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap11</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor221"/>Component testing in React</h1>
			<p>We already<a id="_idIndexMarker636"/> understand that the frontend is the client-side section of an application. Concerning the tests we wrote in <a href="B18221_05.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Testing the REST API</em>, in our Django applications, we <a id="_idIndexMarker637"/>mostly tested whether the database stored the right data passed to the viewsets, serializers, and models. However, we didn’t test the <span class="No-Break">user interface.</span></p>
			<p>As a React developer, you might be thinking: what do I test in my frontend application? Well, let’s respond to this question by understanding why a frontend test is needed and what needs to <span class="No-Break">be tested.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor222"/>The necessity of testing your frontend</h2>
			<p>When developing an<a id="_idIndexMarker638"/> application, it’s important to ensure that your application works as expected in a <span class="No-Break">production environment.</span></p>
			<p>The frontend also represents the interface the user will use to interact with your backend. For a good user experience, it’s crucial to write tests that ensure that your components are behaving <span class="No-Break">as expected.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor223"/>What to test in your React application</h2>
			<p>If you are coming from a backend viewpoint, you might be a little bit confused about what to test in your frontend<a id="_idIndexMarker639"/> application. From a basic aspect, it’s not different from testing your backend. If you have classes or methods in your application, you can write tests. Frontend testing includes testing different aspects of the UI such as formatting, visible text, graphics, and the functional parts of the applications such as buttons, forms, or <span class="No-Break">clickable links.</span></p>
			<p>Now, the difference is that your React frontend is made of UI components, taking props for displaying data to the user. The React ecosystem provides testing tools that easily help you write tests for <span class="No-Break">your components.</span></p>
			<p>In the next section, we will start with a small introduction to Jest and the RTL and then we will write tests for our <span class="No-Break">authentication forms.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor224"/>Jest, the RTL, and fixtures</h1>
			<p><strong class="bold">Jest</strong> is a JavaScript framework for <a id="_idIndexMarker640"/>writing, running, and structuring tests. It comes with all the tools needed to check code coverage, easily mock functions, and imported functions, and write simple and great exceptions. The RTL is a library for actually testing React applications. It focuses on testing components from a user experience point of view rather than testing the implementation and logic of the React <span class="No-Break">components themselves.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">When writing tests, you will often need to ensure that some values or variables meet certain conditions. This was done in <a href="B18221_05.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><em class="italic">, Testing the REST API</em>, of this book, using <strong class="source-inline">assert</strong> when writing tests for the Django application using pytest. Working with Jest, the term changes from assertion to exceptions. When doing frontend testing with Jest, we are expecting the value to meet a condition. For example, if the user enters and clicks on a button that will reset a form, we expect the form to be reset after the click action is made on <span class="No-Break">the button.</span></p>
			<p>The RTL is not separated <a id="_idIndexMarker641"/>from Jest as you need both to write tests for your frontend application. Jest will help you write the testing blocks while the RTL will provide tools to select components, render the components, and trigger common user events such as clicking and typing. These tools are already installed by default when creating a React project, so there is no need to add <span class="No-Break">other packages.</span></p>
			<p>The only packages we will need are <strong class="source-inline">faker.js</strong> and the JavaScript <strong class="source-inline">uuid</strong> package to generate UUID4 identifiers. Faker is a JavaScript package used to generate fake, but realistic, data. In the React project, use the following command to install the package as a <span class="No-Break">development dependency:</span></p>
			<pre class="console">
yarn add @faker-js/faker uuid –dev</pre>
			<p>With the packages installed, we can now add some important fixtures for the components we are going to test in the <span class="No-Break">next lines.</span></p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor225"/>Writing testing fixtures</h2>
			<p>In the <strong class="source-inline">src/helpers</strong> directory, create a new directory called <strong class="source-inline">fixtures</strong>. This directory will contain JavaScript files<a id="_idIndexMarker642"/> containing functions that return fixtures that can be used <span class="No-Break">for testing.</span></p>
			<p>We’ll start by writing fixtures for a user. So, in the <strong class="source-inline">fixtures</strong> directory, create a new file called <strong class="source-inline">user.js</strong>. This file will contain code for a function that returns realistic data for a user object. Let’s start with the imports of functions from the <strong class="source-inline">faker.js</strong> and <strong class="source-inline">uuid</strong> packages to create <span class="No-Break">a fixture:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/user.js</p>
			<pre class="source-code">
import { faker } from "@faker-js/faker";
import { v4 as uuid4 } from "uuid";
function userFixtures() {
...
}
export default userFixtures;</pre>
			<p>With the imports and the <a id="_idIndexMarker643"/>structure of the <strong class="source-inline">userFixtures</strong> function written, we can now return the <span class="No-Break">object fixture:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/user.js</p>
			<pre class="source-code">
...
function userFixtures() {
 const firstName = faker.name.firstName();
 const lastName = faker.name.lastName();
 return {
   id: uuid4(),
   first_name: firstName,
   last_name: lastName,
   name: firstName + " " + lastName,
   post_count: Math.floor(Math.random() * 10),
   email: `${firstName}@yopmail.com`,
   bio: faker.lorem.sentence(20),
   username: firstName + lastName,
   avatar: null,
   created: faker.date.recent(),
   updated: faker.date.recent(),
 };
}
...</pre>
			<p>Faker provides a lot of modules with methods to return data. In the previous code block, we are working with <strong class="source-inline">faker.name</strong> to generate random names, <strong class="source-inline">faker.lorem</strong> to generate random lorem texts, and <strong class="source-inline">faker.date</strong> to generate a recent date. The object returned by <strong class="source-inline">userFixtures</strong> now <a id="_idIndexMarker644"/>has the closest structure to a user object returned by the Django API we have created, and this is exactly what <span class="No-Break">we want.</span></p>
			<p>Before diving into component testing, let’s make sure our testing environment is <span class="No-Break">well configured.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor226"/>Running the first test</h2>
			<p>When a React application is <a id="_idIndexMarker645"/>created, the <strong class="source-inline">App.js</strong> file comes with a test file called <strong class="source-inline">App.test.js</strong>, which you can <span class="No-Break">see here:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/App.test.js</p>
			<pre class="source-code">
import { render, screen } from "@testing-library/react";
import App from "./App";
test("renders learn react link", () =&gt; {
 render(&lt;App /&gt;);
<strong class="bold"> const linkElement = screen.getByText(/learn react/i);</strong>
 expect(linkElement).toBeInTheDocument();
});</pre>
			<p>Let me explain the code. Here, we are importing the <strong class="source-inline">render</strong> and <strong class="source-inline">screen</strong> methods from the RTL. These modules will be used to render a component and make interactions with the components easier by providing methods to select DOM <span class="No-Break">elements, respectively.</span></p>
			<p>Next, we have the <strong class="source-inline">test</strong> method. It’s simply a Jest keyword used to write tests. It takes two parameters: a string describing the test, and the callback function where you write the testing logic. Inside the callback function, the <strong class="source-inline">App</strong> component is rendered first. Then, <strong class="source-inline">linkElement</strong> is retrieved from the screen by using the <strong class="source-inline">learn react</strong> text. Once it’s retrieved, we can<a id="_idIndexMarker646"/> then check whether the <strong class="source-inline">linkElement</strong> exists in the <span class="No-Break">rendered document.</span></p>
			<p>Let’s run this test with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
yarn test</pre>
			<p>You should have a similar output in <span class="No-Break">the terminal.</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_11.01_B18221.jpg" alt="Figure 11.1 – Running the yarn test command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Running the yarn test command</p>
			<p>The test has failed. But why? You can somewhat see why in the <span class="No-Break">preceding output.</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_11.02_B18221.jpg" alt="Figure 11.2 – Reason for failing the App.js test"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Reason for failing the App.js test</p>
			<p>The <strong class="source-inline">App</strong> component in our project uses <strong class="source-inline">react-router-dom</strong> components, such as <strong class="source-inline">Routes</strong>, that in turn use the <strong class="source-inline">useRoutes</strong> Hook. This Hook makes use of the context that a router component provides, so we need to wrap it inside a Router, in this case, the <strong class="source-inline">BrowserRouter</strong> component. Let’s correct this, but let’s also change the text from which we will retrieve the <span class="No-Break">link element:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/App.test.js</p>
			<pre class="source-code">
import { render, screen } from "@testing-library/react";
import App from "./App";
import { BrowserRouter } from "react-router-dom";
test("renders Welcome to Postagram text", () =&gt; {
 render(
   &lt;BrowserRouter&gt;
     &lt;App /&gt;
   &lt;/BrowserRouter&gt;
 );
 const textElement =
   screen.getByText(/Welcome to Postagram!/i);
 expect(textElement).toBeInTheDocument();
});</pre>
			<p>Now, run the tests again and<a id="_idIndexMarker647"/> everything should <span class="No-Break">work correctly:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_11.03_B18221.jpg" alt="Figure 11.3 – Passing tests"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Passing tests</p>
			<p>But we still have a problem. A lot of components in the React application use Hooks from the <strong class="source-inline">react-router-dom</strong> library. That means that for each test, we will need to wrap the component inside <strong class="source-inline">BrowserRouter</strong>. Following the DRY principle, let’s rewrite the render method from<a id="_idIndexMarker648"/> the RTL to automatically wrap our components inside <span class="No-Break">the </span><span class="No-Break"><strong class="source-inline">BrowserRouter</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor227"/>Extending the RTL render method</h2>
			<p>Inside the <strong class="source-inline">src/helpers</strong> directory, create a file called <strong class="source-inline">test-utils.jsx</strong>. Once the file is created, add the following<a id="_idIndexMarker649"/> lines <span class="No-Break">of code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/test-utils.jsx</p>
			<pre class="source-code">
import React from "react";
import { render as rtlRender } from "@testing-library/react";
import { BrowserRouter } from "react-router-dom";
function render(ui, { ...renderOptions } = {}) {
 const Wrapper = ({ children }) =&gt;
   &lt;BrowserRouter&gt;{children}&lt;/BrowserRouter&gt;;
 return rtlRender(ui, { wrapper: Wrapper, ...renderOptions
   });
}
export * from "@testing-library/react";
export { render };</pre>
			<p>In the code, we first import the needed tools. Notice the import of the render method as <strong class="source-inline">rtlRender</strong>? It’s for the purpose of avoiding a naming collision as we are also writing a render function. Next, we create a function called <strong class="source-inline">Wrapper</strong>, where we pass the children’s argument, then wrap it inside a <strong class="source-inline">BrowserRouter</strong> component. Then, we return a render object with the UI, <strong class="source-inline">wrapper</strong>, and other render options <span class="No-Break">if specified.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The render method from the RTL provides render options other than the wrapper. You can also pass a container, queries, and a lot more. You can check more rendering options in the official documentation <span class="No-Break">at </span><a href="https://testing-library.com/docs/react-testing-library/api/#render-options"><span class="No-Break">https://testing-library.com/docs/react-testing-library/api/#render-options</span></a><span class="No-Break">.</span></p>
			<p>Now, let’s use this <a id="_idIndexMarker650"/>method <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">App.test.js</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/App.test.js</p>
			<pre class="source-code">
import { render, screen } from "@testing-library/react";
import App from "./App";
test("renders Welcome to Postagram text", () =&gt; {
 render(&lt;App /&gt;);
...
});</pre>
			<p>Run the testing command again and everything should be green. With the testing environment ready and set up to quickly write tests, we can now move on to testing the components of the <span class="No-Break">React project.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">While running tests, you might encounter an error coming from the <strong class="source-inline">axios</strong> package. At the time of writing of this book, we are using the 0.26.0 version of <strong class="source-inline">axios</strong> to avoid bugs when running tests. You can also modify the test command in the <strong class="source-inline">package.json</strong> file to the following: <strong class="source-inline">"test": "react-scripts test --transformIgnorePatterns "node_modules/(?!axios)/""</strong>. Learn more about this issue <span class="No-Break">at </span><a href="https://github.com/axios/axios/issues/5101"><span class="No-Break">https://github.com/axios/axios/issues/5101</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor228"/>Testing authentication components</h1>
			<p>Testing forms in React<a id="_idIndexMarker651"/> might seem complicated but it is quite simple when using Jest and the RTL. We will begin writing tests in the React project, starting with the authentication components. I’ll show you how you can write a test for the <strong class="bold">Login</strong> form, and after that, you should be able to write the registration form <span class="No-Break">test suite.</span></p>
			<p>For a better structured code base, create a new directory called <strong class="source-inline">__tests__</strong> in the <strong class="source-inline">src/components/authentication</strong> directory. This directory will contain tests for the components in the <strong class="source-inline">components/authentication</strong> directory. Inside the newly created directory, create a<a id="_idIndexMarker652"/> file called <strong class="source-inline">LoginForm.test.js</strong> and add the <span class="No-Break">following code:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/__tests__/LoginForm.test.js</p>
			<pre class="source-code">
import { render, screen } from "../../../helpers/test-utils";
import userEvent from "@testing-library/user-event";
import LoginForm from "../LoginForm";
import { faker } from "@faker-js/faker";
import userFixtures from "../../../helpers/fixtures/user";
const userData = userFixtures();
test("renders Login form", async () =&gt; {
...
});</pre>
			<p>In the preceding code, we have added the required imports to write the test and defined the structure of the testing function. We will first render the <strong class="source-inline">LoginForm</strong> component and set up the user object to trigger user behavior events using <span class="No-Break"><strong class="source-inline">userEvent</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">method:src/components/authentication/__tests__/LoginForm.test.js</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
...
test("renders Login form", async () =&gt; {
 const user = userEvent.setup();
 render(&lt;LoginForm /&gt;);
...</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="source-inline">userEvent</strong> and <strong class="source-inline">fireEvent</strong> are both methods used for simulating user interactions with a website in the context of testing. They can be used to test the behavior of a website when a user performs certain actions, such as clicking a button or filling out <span class="No-Break">a form.</span></p>
			<p class="callout"><strong class="source-inline">userEvent</strong> is a method provided by the <strong class="source-inline">@testing-library/user-event</strong> library, which is designed to make it easier to test user interactions with a website. It is a utility function that simulates user events by using the <strong class="source-inline">fireEvent</strong> method provided by the <strong class="source-inline">@testing-library/react</strong> library. <strong class="source-inline">userEvent</strong> allows you to specify the type of event you want to simulate, such as a click or a keypress, and it will automatically dispatch the appropriate event <span class="No-Break">for you.</span></p>
			<p class="callout"><strong class="source-inline">fireEvent</strong> is a method provided by the <strong class="source-inline">@testing-library/react</strong> library, which can be used to dispatch events to a DOM element. It allows you to specify the type of event you want to dispatch, as well as any additional event data that you want to include. <strong class="source-inline">fireEvent</strong> is a more low-level method than <strong class="source-inline">userEvent</strong>, and it requires you to manually specify the details of the event you want <span class="No-Break">to dispatch.</span></p>
			<p>After that, we can start<a id="_idIndexMarker653"/> by testing that the form and the inputs are rendered in <span class="No-Break">the document:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/__tests__/LoginForm.test.js</p>
			<pre class="source-code">
test("renders Login form", async () =&gt; {
...
 const loginForm = screen.getByTestId("login-form");
 expect(loginForm).toBeInTheDocument();
const usernameField = screen.getByTestId("username-field");
expect(usernameField).toBeInTheDocument();
const passwordField = screen.getByTestId("password-field");
expect(passwordField).toBeInTheDocument();
...</pre>
			<p>Then, we can ensure that the inputs can receive texts and values as we have already selected the username and <a id="_idIndexMarker654"/><span class="No-Break">password fields:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/__tests__/LoginForm.test.js</p>
			<pre class="source-code">
test("renders Login form", async () =&gt; {
...
 const password = faker.lorem.slug(2);
 await user.type(usernameField, userData.username);
 await user.type(passwordField, password);
 expect(usernameField.value).toBe(userData.username);
 expect(passwordField.value).toBe(password);
});</pre>
			<p>If you run the test command again, it will fail. That’s normal, as here we are retrieving elements using the <strong class="source-inline">getByTestId</strong> method. The RTL looks in the rendered DOM for an element with a <strong class="source-inline">data-testid</strong> attribute with the value passed to the <strong class="source-inline">screen.getByTestId</strong> function. We need to add the attribute to the elements we want to select <span class="No-Break">and test.</span></p>
			<p>To do so, in <strong class="source-inline">src/components/authentication/LoginForm.js</strong>, add the following <span class="No-Break"><strong class="source-inline">data-testid</strong></span><span class="No-Break"> attributes:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/authentication/LoginForm.js</p>
			<pre class="source-code">
function LoginForm() {
...
 return (
   &lt;Form
     id="registration-form"
     className="border p-4 rounded"
     noValidate
     validated={validated}
     onSubmit={handleSubmit}
<strong class="bold">     data-testid="login-form"</strong>
   &gt;
...
       &lt;Form.Label&gt;Username&lt;/Form.Label&gt;
       &lt;Form.Control
         value={form.username}
<strong class="bold">         data-testid="username-field"</strong>
...
     &lt;Form.Group className="mb-3"&gt;
       &lt;Form.Label&gt;Password&lt;/Form.Label&gt;
       &lt;Form.Control
         value={form.password}
<strong class="source-inline">         data-testid="password-field"</strong>
...</pre>
			<p>Once done, re-run the testing <a id="_idIndexMarker655"/>command. Everything <span class="No-Break">should work.</span></p>
			<p>The next step is to write tests for the registration form component. It’ll be similar to the tests on the<a id="_idIndexMarker656"/> login form component, so you can handle this small exercise. You can find the solution <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js"><span class="No-Break">https://github.com/PacktPublishing/Full-stack-Django-and-React/blob/main/social-media-react/src/components/authentication/__tests__/RegistrationForm.test.js</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">JavaScript also possesses default naming conventions for the testing files. The naming conventions for test files in a JavaScript project are <span class="No-Break">as follows:</span></p>
			<p class="callout">- <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">TestFileName&gt;.test.js</strong></span></p>
			<p class="callout">- <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">TestFileName&gt;.spec.js</strong></span></p>
			<p>Now that we have had a solid introduction to testing in React, let’s continue with writing tests for the <span class="No-Break">Post components.</span></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor229"/>Testing Post components</h1>
			<p>The functionalities to create, read, update, and delete<a id="_idIndexMarker657"/> posts are core features of the Postagram application, so it’s important to make sure that they work as expected. Let’s start with a simple test for the <span class="No-Break"><strong class="source-inline">Post</strong></span><span class="No-Break"> component.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor230"/>Mocking the localStorage object</h2>
			<p>Before writing a test for the <strong class="source-inline">Post</strong> <a id="_idIndexMarker658"/>component, it’s important to understand how the Post components work. Basically, it takes a prop called <strong class="source-inline">post</strong> and makes a call to <strong class="source-inline">localStorage</strong> to retrieve information about the user. Unfortunately, <strong class="source-inline">localStorage</strong> can’t be mocked by Jest. There are a lot of workarounds to allow your tests to work with <strong class="source-inline">localStorage</strong> and to make it simple and have less boilerplate, we’ll use the <strong class="source-inline">jest-localstorage-mock</strong> JavaScript package. The package can be used with Jest to run frontend tests that rely on <strong class="source-inline">localStorage</strong>. To add the package, add the following line to <span class="No-Break">the file:</span></p>
			<pre class="source-code">
yarn add --dev jest-localstorage-mock</pre>
			<p>Once the package is installed, we need to do some configurations. In the <strong class="source-inline">src/setupTests.js</strong> file, add this line to load the <span class="No-Break"><strong class="source-inline">jest-localstorage-mock</strong></span><span class="No-Break"> package:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/setupTests.js</p>
			<pre class="source-code">
...
require('jest-localstorage-mock');</pre>
			<p>After that, override the <a id="_idIndexMarker659"/>default Jest configuration in the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
			<pre class="source-code">
...
{
  "jest": {
    "resetMocks": false
  }
}
...</pre>
			<p>With the configuration ready, we can move to add a function to generate <span class="No-Break">post fixtures.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor231"/>Writing post fixtures</h2>
			<p>In the <strong class="source-inline">src/helpers/fixtures</strong> directory, create a new file called <strong class="source-inline">post.js</strong>. This file will contain a function that<a id="_idIndexMarker660"/> returns fake data from a <span class="No-Break">post object.</span></p>
			<p>We will start writing the code in this file by adding the imports and defining the <strong class="source-inline">postFixtures</strong> function that will return a generated <span class="No-Break">post object:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/post.js</p>
			<pre class="source-code">
import { faker } from "@faker-js/faker";
import { v4 as uuid4 } from "uuid";
import userFixtures from "./user";
function postFixtures(isLiked = true, isEdited = false, user = undefined) {
...
}
export default postFixtures;</pre>
			<p>Let’s add the body<a id="_idIndexMarker661"/> of the <span class="No-Break"><strong class="source-inline">postFixtures</strong></span><span class="No-Break"> function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/helpers/fixtures/post.js</p>
			<pre class="source-code">
...
function postFixtures(isLiked = true, isEdited = false, user = undefined) {
 return {
   id: uuid4(),
   author: user || userFixtures(),
   body: faker.lorem.sentence(20),
   edited: isEdited,
   liked: isLiked,
   likes_count: Math.floor(Math.random() * 10),
   comments_count: Math.floor(Math.random() * 10),
   created: faker.date.recent(),
   updated: faker.date.recent(),
 };
}</pre>
			<p>Here, we are passing<a id="_idIndexMarker662"/> either a generated <strong class="source-inline">userFixtures</strong> or a user object if it’s defined. This is important if we want to make sure that the author of the post is the same user registered <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">localStorage</strong></span><span class="No-Break">.</span></p>
			<p>With the post fixtures written, we can write the test suite for the <span class="No-Break"><strong class="source-inline">Post</strong></span><span class="No-Break"> component.</span></p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor232"/>Writing tests for the Post component</h2>
			<p>To write the test suite in the <strong class="source-inline">src/components/posts</strong> directory, create a new folder called <strong class="source-inline">__tests__</strong>. Inside the<a id="_idIndexMarker663"/> newly created folder, add a new file called <strong class="source-inline">Post.test.js</strong>. Inside, add the imports, create the data we need, and set user data returned by the <strong class="source-inline">userFixtures</strong> function in the local storage using the <span class="No-Break"><strong class="source-inline">setUserData</strong></span><span class="No-Break"> function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/Post.test.js</p>
			<pre class="source-code">
import { render, screen } from "../../../helpers/test-utils";
import Post from "../Post";
import { setUserData } from "../../../hooks/user.actions";
import userFixtures from "../../../helpers/fixtures/user";
import postFixtures from "../../../helpers/fixtures/post";
const userData = userFixtures();
const postData = postFixtures(true, false, userData);
beforeEach(() =&gt; {
 // to fully reset the state between __tests__, clear the
 // storage
 localStorage.clear();
 // and reset all mocks
 jest.clearAllMocks();
 setUserData({
   user: userData,
   access: null,
   refresh: null,
 });
});</pre>
			<p>The <strong class="source-inline">beforeEach</strong> method is a Jest method that runs before every test. It takes a callback function as a parameter, where <a id="_idIndexMarker664"/>you can execute lines of code that should run before the tests. Here, we are clearing the local storage first to avoid memory leaking (with <strong class="source-inline">localStorage.clear</strong>) and finally, we set user data retrieved from the <strong class="source-inline">userFixtures</strong> function in the <span class="No-Break">local storage.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">A memory leak occurs when a program creates a memory in heap and forgets to delete it. In a worst-case scenario, if too much memory is allocated and not used correctly, this can reduce the <span class="No-Break">computer’s performance.</span></p>
			<p>Let’s write the test for the <strong class="source-inline">Post</strong> <span class="No-Break">component now:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/Post.test.js</p>
			<pre class="source-code">
...
test("render Post component", () =&gt; {
 render(&lt;Post post={postData} /&gt;);
 const postElement = screen.getByTestId("post-test");
 expect(postElement).toBeInTheDocument();
});</pre>
			<p>If you run the test<a id="_idIndexMarker665"/> command, it’ll fail. This is normal because there is no <strong class="source-inline">data-testid</strong> attribute with the value <strong class="source-inline">post-test</strong> set in the JSX of the <strong class="source-inline">Post</strong> component. Let’s fix this by adding a <strong class="source-inline">data-testid</strong> attribute in the <strong class="source-inline">Post</strong> <span class="No-Break">component :</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/Post.jsx</p>
			<pre class="source-code">
...
function Post(props) {
...
 return (
   &lt;&gt;
<strong class="bold">     &lt;Card className="rounded-3 my-4"</strong>
<strong class="bold">       data-testid="post-test"&gt;</strong>
...
   &lt;/&gt;
 );
}
export default Post;</pre>
			<p>Run the testing command again and everything should be green. Let’s move on to actually writing a test for the <span class="No-Break"><strong class="source-inline">CreatePost</strong></span><span class="No-Break"> component.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor233"/>Testing the CreatePost component</h2>
			<p>In the <strong class="source-inline">src/components/posts/__tests__</strong> directory, create a new file called <strong class="source-inline">CreatePost.test.js</strong>. We’ll start with the <a id="_idIndexMarker666"/>necessary imports and the definition of the <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
import { render, screen, fireEvent } from "../../../helpers/test-utils";
import userEvent from "@testing-library/user-event";
import CreatePost from "../CreatePost";
import { faker } from "@faker-js/faker";
test("Renders CreatePost component", async () =&gt; {
...
});</pre>
			<p>You can notice the introduction of the <strong class="source-inline">async</strong> keyword before the callback function. To create a post, the user performs typing operations on text inputs and finally a button click to submit the post. These actions are asynchronous. The functions, such as <strong class="source-inline">fireEvent</strong>, that we will use to simulate user interactions should be used in an <span class="No-Break">asynchronous scope.</span></p>
			<p>Before writing the test logic, let’s remember how the <strong class="source-inline">CreatePost</strong> <span class="No-Break">component works:</span></p>
			<ol>
				<li>The user clicks on the input to add a <span class="No-Break">new post.</span></li>
				<li>A modal is shown containing a form where the user can enter the text of the post. Meanwhile, the submit button <span class="No-Break">is disabled.</span></li>
				<li>Once there is enough text in the field, the submit button is enabled and the user can click to send <span class="No-Break">the post.</span></li>
			</ol>
			<p>We must ensure that we respect this logic when writing the tests. Now, let’s start writing <span class="No-Break">the tests.</span></p>
			<p>First, we render the form that displays the form modal to create <span class="No-Break">a post:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
test("Renders CreatePost component", async () =&gt; {
 const user = userEvent.setup();
 render(&lt;CreatePost /&gt;);
 const showModalForm =
   screen.getByTestId("show-modal-form");
 expect(showModalForm).toBeInTheDocument();
});</pre>
			<p>We can now simulate a<a id="_idIndexMarker667"/> click event using <strong class="source-inline">fireEvent.click</strong> on <strong class="source-inline">showModalForm</strong> to display the form for creating <span class="No-Break">a post:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
...
 // Clicking to show the modal
 fireEvent.click(showModalForm);
 const createFormElement =
   screen.getByTestId("create-post-form");
 expect(createFormElement).toBeInTheDocument();
...</pre>
			<p>We then make sure that the body field is rendered and the submit button <span class="No-Break">is disabled:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
...
 const postBodyField =
   screen.getByTestId("post-body-field");
 expect(postBodyField).toBeInTheDocument();
 const submitButton =
   screen.getByTestId("create-post-submit");
 expect(submitButton).toBeInTheDocument();
 expect(submitButton.disabled).toBeTruthy();
 ...</pre>
			<p>After that, we can<a id="_idIndexMarker668"/> then type some text in the body field, test whether the text typed is what we expect, and ensure that the button is enabled <span class="No-Break">after that:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/CreatePost.test.js</p>
			<pre class="source-code">
 ...
 const postBody = faker.lorem.sentence(10);
 await user.type(postBodyField, postBody);
 // Checking if field has the text and button is not
 // disabled
 expect(postBodyField.value).toBe(postBody);
 expect(submitButton.disabled).toBeFalsy();
});</pre>
			<p>Great! We have a solid testing suite and we can now add the <strong class="source-inline">data-testid</strong> attributes to the <strong class="source-inline">CreatePost</strong> component<a id="_idIndexMarker669"/> to make the <span class="No-Break">tests pass:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/CreatePost.jsx</p>
			<pre class="source-code">
function CreatePost() {
...
 return (
   &lt;&gt;
     &lt;Form.Group className="my-3 w-75"&gt;
       &lt;Form.Control
         className="py-2 rounded-pill border-primary
                    text-primary"
<strong class="bold">         data-testid="show-modal-form"</strong>
...
       &lt;Modal.Body className="border-0"&gt;
         &lt;Form
           noValidate
           validated={validated}
           onSubmit={handleSubmit}
<strong class="bold">           data-testid="create-post-form"</strong>
         &gt;
           &lt;Form.Group className="mb-3"&gt;
             &lt;Form.Control
               name="body"
<strong class="bold">               data-testid="post-body-field"</strong>
...
       &lt;/Modal.Body&gt;
       &lt;Modal.Footer&gt;
         &lt;Button
           variant="primary"
           onClick={handleSubmit}
           disabled={!form.body}
<strong class="bold">           data-testid="create-post-submit"</strong>
...
   &lt;/&gt;
 );
}</pre>
			<p>Run the test command again and<a id="_idIndexMarker670"/> everything should work. The next step is to write unit tests for the <span class="No-Break"><strong class="source-inline">UpdatePost</strong></span><span class="No-Break"> component.</span></p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor234"/>Testing the UpdatePost component</h2>
			<p>In the <strong class="source-inline">src/components/posts/__tests__</strong> directory, create a new file called <strong class="source-inline">UpdatePost.test.js</strong>. Let’s start <a id="_idIndexMarker671"/>with the necessary imports and the definition of the <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
import { render, screen, fireEvent } from "../../../helpers/test-utils";
import userEvent from "@testing-library/user-event";
import UpdatePost from "../UpdatePost";
import userFixtures from "../../../helpers/fixtures/user";
import postFixtures from "../../../helpers/fixtures/post";
import { faker } from "@faker-js/faker";
const userData = userFixtures();
const postData = postFixtures(true, false, userData);
test("Render UpdatePost component", async () =&gt; {
...
});</pre>
			<p>Before writing the test logic, let’s remember how the <strong class="source-inline">UpdatePost</strong> component works from a <span class="No-Break">user’s perspective:</span></p>
			<ol>
				<li value="1">The user clicks on the drop-down item to modify <span class="No-Break">a post.</span></li>
				<li>A modal is shown containing a form where the user can modify the text of <span class="No-Break">the post.</span></li>
				<li>After the modification, the user can submit the form with the <span class="No-Break">updated post.</span></li>
			</ol>
			<p>We must ensure that we <a id="_idIndexMarker672"/>respect that logic when writing <span class="No-Break">the tests.</span></p>
			<p>So, first, we render the form that displays the form modal to update <span class="No-Break">a post:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
test("Render UpdatePost component", async () =&gt; {
 const user = userEvent.setup();
 render(&lt;UpdatePost post={postData} /&gt;);
 const showModalForm =
   screen.getByTestId("show-modal-form");
 expect(showModalForm).toBeInTheDocument();
...</pre>
			<p>We then want to trigger a<a id="_idIndexMarker673"/> click event to display the modal with the form to update <span class="No-Break">the post:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
...
 fireEvent.click(showModalForm);
 const updateFormElement =
   screen.getByTestId("update-post-form");
 expect(updateFormElement).toBeInTheDocument();
...</pre>
			<p>We then select the post body field and the submit button to ensure that they <span class="No-Break">are rendered:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
...
 const postBodyField =
   screen.getByTestId("post-body-field");
 expect(postBodyField).toBeInTheDocument();
 const submitButton =
   screen.getByTestId("update-post-submit");
 expect(submitButton).toBeInTheDocument();
...</pre>
			<p>After that, we can now trigger a typing event in the post body field and ensure that the user is submitting the <span class="No-Break">right data:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/__tests__/UpdatePost.test.js</p>
			<pre class="source-code">
...
 const postBody = faker.lorem.sentence(10);
 await user.type(postBodyField, postBody);
 // Checking if field has the text and button is not
 // disabled
 expect(postBodyField.value).toBe(postData.body +
   postBody);
 expect(submitButton.disabled).toBeFalsy();
});</pre>
			<p>The next step is now<a id="_idIndexMarker674"/> to add the <strong class="source-inline">data-testid</strong> attributes on the post form, the post body input, and the submit button in the <strong class="source-inline">UpdatePost</strong> component to make the <span class="No-Break">tests pass:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/posts/UpdatePost.jsx</p>
			<pre class="source-code">
...
function UpdatePost(props) {
...
 return (
   &lt;&gt;
     &lt;Dropdown.Item data-testid="show-modal-form"
       onClick={handleShow}&gt;
...
       &lt;Modal.Body className="border-0"&gt;
         &lt;Form
          noValidate
          validated={validated}
          onSubmit={handleSubmit}
<strong class="bold">    data-testid="update-post-form"</strong>
   &gt;
           &lt;Form.Group className="mb-3"&gt;
             &lt;Form.Control
               name="body"
               value={form.body}
<strong class="bold">               data-testid="post-body-field"</strong>
...
       &lt;/Modal.Body&gt;
       &lt;Modal.Footer&gt;
         &lt;Button
<strong class="bold">           data-testid="update-post-submit"</strong>
...</pre>
			<p>Run the test command again and everything <span class="No-Break">should work.</span></p>
			<p>With this introduction<a id="_idIndexMarker675"/> to complex tests with Jest and the RTL, you can easily write the tests for the comment’s components. You can find the solution for these tests at <a href="https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__">https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/main/social-media-react/src/components/comments/__tests__</a>. <span class="No-Break">Good luck!</span></p>
			<p>In the next section, we will <a id="_idIndexMarker676"/>discover what snapshot <span class="No-Break">testing is.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor235"/>Snapshot testing</h1>
			<p>Snapshot tests are a very useful tool <a id="_idIndexMarker677"/>when you want to make sure that your UI does not change unexpectedly. A snapshot test case follows <span class="No-Break">these steps:</span></p>
			<ul>
				<li>It renders the <span class="No-Break">UI</span><span class="No-Break"><a id="_idIndexMarker678"/></span><span class="No-Break"> component.</span></li>
				<li>It then takes a snapshot and compares it to a reference snapshot file stored alongside the <span class="No-Break">test file.</span></li>
				<li>If both states are the same, the snapshot test is successful. Otherwise, you will get errors and need to decide whether you need to update the snapshot tests or fix <span class="No-Break">your components.</span></li>
			</ul>
			<p>Snapshot tests are great to prevent UI regression and ensure that the application adheres to the code quality and values of your <span class="No-Break">development team.</span></p>
			<p>There is a minor setback with snapshot tests, however. Snapshot testing doesn’t work best with dynamic components. For example, the <strong class="source-inline">Post</strong> component uses <strong class="source-inline">timeago</strong> to display a human-readable time. This means that a snapshot of this component at time <strong class="source-inline">t</strong> will be different from a snapshot of the same component at time <strong class="source-inline">t + 1</strong>. However, there are some static components in the React application such as <strong class="source-inline">LoginForm</strong>, <strong class="source-inline">RegistrationForm</strong>, <strong class="source-inline">ProfileDetails</strong>, <strong class="source-inline">ProfileCard</strong>, <strong class="source-inline">CreatePost</strong>, and <span class="No-Break">much more.</span></p>
			<p>For the sake of simplicity, we will write a snapshot test for the <strong class="source-inline">ProfileCard</strong> components, which are straightforward and can be <span class="No-Break">replicated easily.</span></p>
			<p>In the <strong class="source-inline">src/components/profile</strong> directory, create a new directory called <strong class="source-inline">__tests__</strong>. Then, create a new file called <strong class="source-inline">ProfileCard.test.js</strong>. For a snapshot test, we don’t want the data to change so we will use a static user fixture because using <strong class="source-inline">userFixtures</strong> to generate a fixture will create random data every time a snapshot test is run. In the newly created file, let’s add the imports needed to create a snapshot test and define a fixture <a id="_idIndexMarker679"/>object <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">userData</strong></span><span class="No-Break">:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/profile/__tests__/ProfileCard.test.js</p>
			<pre class="source-code">
import { render, screen } from "../../../helpers/test-utils";
import TestRenderer from "react-test-renderer";
import ProfileCard from "../ProfileCard";
import { BrowserRouter } from "react-router-dom";
const userData = {
 id: "0590cd67-eacd-4299-8413-605bd547ea17",
 first_name: "Mossie",
 last_name: "Murphy",
 name: "Mossie Murphy",
 post_count: 3,
 email: "Mossie@yopmail.com",
 bio: "Omnis necessitatibus facere vel in est provident
       sunt tempora earum accusantium debitis vel est
       architecto minima quis sint et asperiores.",
 username: "MossieMurphy",
 avatar: null,
 created: "2022-08-19T17:31:03.310Z",
 updated: "2022-08-20T07:38:47.631Z",
};</pre>
			<p>With the needed imports added and the <strong class="source-inline">userData</strong> fixtures written, we can now write the <span class="No-Break">testing function:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/components/profile/__tests__/ProfileCard.test.js</p>
			<pre class="source-code">
...
test("Profile Card snapshot", () =&gt; {
 const profileCardDomTree = TestRenderer.create(
   &lt;BrowserRouter&gt;
     &lt;ProfileCard user={userData} /&gt;
   &lt;/BrowserRouter&gt;
 ).toJSON();
 expect(profileCardDomTree).toMatchSnapshot();
});</pre>
			<p>If you run the test command, you’ll <a id="_idIndexMarker680"/>notice that a snapshot directory is created in the <span class="No-Break"><strong class="source-inline">__tests__</strong></span><span class="No-Break"> directory:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_11.04_B18221.jpg" alt="Figure 11.4 – Snapshots directory created"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Snapshots directory created</p>
			<p>If you check the content of <strong class="source-inline">ProfileCard.test.js.snap</strong>, it is basically the rendered code of the <strong class="source-inline">ProfileCard</strong> component. The content of this file will be compared each time the test function for the snapshot <span class="No-Break">test runs.</span></p>
			<p>Now have covered the essential unit tests for a React application, we are mostly done adding features to the application. Our full stack application is now ready for production! Yay, but don’t celebrate too soon. We still need to prepare our application for production in terms of the security, quality, and performance aspects and this is what we’ll be doing in <em class="italic">Part 3</em> of <span class="No-Break">this book.</span></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor236"/>Summary</h1>
			<p>In this chapter, you have learned about frontend unit testing. We discovered why it is important to write unit tests in the frontend application and what to test exactly. We have also written tests for components in the Postagram application, seen how we can extend testing tools modules and methods, how to write generate fixtures for the tests, and how to make the tests <a id="_idIndexMarker681"/>closer to user interactions by triggering user events. We have also made some introductions to <span class="No-Break">snapshot testing.</span></p>
			<p>The next chapters in <em class="italic">Part 3</em> of this book will focus on deploying the backend and the frontend on the cloud using AWS services, GitHub, and GitHub Actions. Lastly, we will see how to improve the full stack application in terms of performance, security, <span class="No-Break">and quality.</span></p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor237"/>Questions</h1>
			<ol>
				<li value="1">What is the render method of <span class="No-Break">the RTL?</span></li>
				<li>What <span class="No-Break">is Jest?</span></li>
				<li>What is the role of the <span class="No-Break"><strong class="source-inline">data-tested</strong></span><span class="No-Break"> attribute?</span></li>
				<li>What are the drawbacks of <span class="No-Break">snapshot testing?</span></li>
				<li>What are the modules used to trigger user events on a React <span class="No-Break">test suite?</span></li>
			</ol>
		</div>
	

		<div id="_idContainer127" class="Content">
			<h1 id="_idParaDest-224"><a id="_idTextAnchor238"/>Part 3: Deploying Django and React on AWS</h1>
			<p>Deployment is one of the last important steps in software development. Your application is running locally and everything is working fine. But how do you get your code on a public server? How do you host your frontend? How do you make changes to your code and make deployment and testing automatic? In this part of the book, we’ll explore topics such as CI/CD, GitHub, Docker, and the best deployment practices while deploying the Django application on AWS EC2 and the React application on AWS S3. We’ll also talk about security <span class="No-Break">and performance.</span></p>
			<p>This section comprises the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18221_12.xhtml#_idTextAnchor239"><em class="italic">Chapter 12</em></a>, <em class="italic">Deployment Basics – Git, GitHub, and AWS</em></li>
				<li><a href="B18221_13.xhtml#_idTextAnchor252"><em class="italic">Chapter 13</em></a>, <em class="italic">Dockerizing the Django Project</em></li>
				<li><a href="B18221_14.xhtml#_idTextAnchor286"><em class="italic">Chapter 14</em></a>, <em class="italic">Automating Deployment on AWS</em></li>
				<li><a href="B18221_15.xhtml#_idTextAnchor330"><em class="italic">Chapter 15</em></a>, <em class="italic">Deploying Our React App on AWS</em></li>
				<li><a href="B18221_16.xhtml#_idTextAnchor352"><em class="italic">Chapter 16</em></a>, <em class="italic">Performance, Optimization, and Security</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer128">
			</div>
		</div>
		<div>
			<div id="_idContainer129">
			</div>
		</div>
	</body></html>