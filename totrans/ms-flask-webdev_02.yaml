- en: Creating Models with SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the last chapter, models are a means of abstracting and providing
    a common interface to access data. In most web applications, data is stored and
    retrieved from a **relational database management system** (**RDBMS**), which
    is a database that holds data in a tabular format with rows and columns and is
    able to implement a relational model with data across tables. Some examples include
    MySQL, Postgres, Oracle, and MSSQL.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create models on top of our database, we will use a Python package
    named **SQLAlchemy**. SQLAlchemy is a database API at its lowest level, and performs
    **object relational mapping** at its highest level. An **ORM** (**object relational
    mapper**) is a tool that allows developers to store and retrieve data using object-oriented
    approaches and solve object-relational mismatches—a set of conceptual and technical
    difficulties that are often encountered when a relational database management
    system is being used by a program that is written in an object-oriented programming
    language. Relational and object-oriented models are so different that additional
    code and functionalities are required to make them work together efficiently. This
    creates a virtual object database and converts data between the large number of
    types in databases into the mix of types and objects in Python. Also, a programming
    language, such as Python, allows you to have different objects that hold references
    to each other, and to get and set their attributes. An ORM, such as SQLAlchemy,
    helps translate these when inserting them into a traditional database.
  prefs: []
  type: TYPE_NORMAL
- en: In order to tie SQLAlchemy into our application context, we will use **Flask
    SQLAlchemy**. Flask SQLAlchemy is a convenience layer on top of SQLAlchemy that
    provides useful defaults and Flask-specific functions. If you are already familiar
    with SQLAlchemy, then you are free to use it without Flask SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we will have a full database schema of our blogging
    application, as well as models that interact with that schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing database tables and relationships using SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, reading, updating, and deleting models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to define model relationships, constraints, and indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating automatic database migrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to go through the exercises in this chapter, you will need a running
    database, if you do not already have one. If you have never installed a database,
    or you do not have a preference, then **SQLite** is the best option for beginners,
    or if you want to quickly bootstrap a proof of concept.
  prefs: []
  type: TYPE_NORMAL
- en: '**SQLite** is an SQL-embedded database engine that is fast, works without a
    server, and is entirely contained in one file. SQLite is also natively supported
    in Python, so if you choose to go with SQLite, an SQLite database will be automatically created
    for you during the exercise in the *Our first model* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Python packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask SQLAlchemy can be used with multiple database engines, such as ORACLE,
    MSSQL, MySQL, PostgreSQL, SQLite, and Sybase, but we need to install additional
    specific packages for these engines. Now it is time to bootstrap our project by
    creating a new virtual environment for all our application''s dependencies. This
    virtual environment will be used for our blogging application. Enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `requirements.txt`, add the following code to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to install specific packages for your chosen database that
    will act as the connector for SQLAlchemy, so add the specific packages for your
    engine in `requirements.txt`, as shown in the following code. SQLite users can
    skip this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, activate and install the dependencies using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Flask SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can abstract our data, we need to set up Flask SQLAlchemy. SQLAlchemy
    creates its database connection through a special database URI. This is a string
    that looks like a URL that contains all the information that SQLAlchemy needs
    to connect. It takes the general form of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For each driver that you installed previously, the URI would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `config.py` file, add the URI to the `DevConfig` file with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our first model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that we did not actually create any tables in our database
    to abstract from. This is because SQLAlchemy allows us to create either models
    from tables or tables from our models. We will look at this after we have created
    the first model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `main.py` file, SQLAlchemy must first be initialized with our app as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy will read our app''s configuration and automatically connect to
    our database. Let''s create a `User` model to interact with a user table in the
    `main.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What have we accomplished? We now have a model that is based on a user table
    with three columns. When we inherit from `db.Model`, the entire connection and
    communication with the database will already be handled for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each class variable that is the `db.Column` instance represents a column in
    the database. There is an optional first argument in the `db.Column` instance
    that allows us to specify the name of the column in the database. Without it,
    SQLAlchemy will assume that the name of the variable is the same as the name of
    the column. Using this, optional variable would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument to `db.Column` tells SQLAlchemy what type the column should
    be treated as. The main types that we will work with in this book are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.String`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `db.Integer` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `db.Boolean` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.DateTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`db.Time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What each type represents is rather simple, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `String` and `Text` types take Python strings and translate them to the
    `varchar` and `text` type columns, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Integer` and `Float` types take any Python number and translates it into
    the correct type before inserting it into the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean takes Python `True` or `False` statements and, if the database has a
    `boolean` type, inserts a Boolean into the database. If there is no `boolean`
    type in the database, SQLAlchemy automatically translates between Python Booleans
    and a 0 or a 1 in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Date`, `DateTime`, and `Time` types use the Python types of the same names
    from the `datetime` native library and translates them into the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `String`, `Integer`, and `Float` types take an extra argument that tells
    SQLAlchemy the length limit of our column.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to truly understand how SQLAlchemy translates your code into SQL
    queries, add the following to the `DevConfig` file, `SQLALCHEMY_ECHO = True`.
  prefs: []
  type: TYPE_NORMAL
- en: This will print out the created queries to the Terminal. You may wish to turn
    this feature off as you get further along in the book, as dozens of queries could
    be printed to the terminal with every page load.
  prefs: []
  type: TYPE_NORMAL
- en: The `primary_key` argument tells SQLAlchemy that this column has the **primary
    key index** on it. Each SQLAlchemy model requires a primary key to function. All
    object-relationally mapped objects are linked to their database rows within the
    session via an identity map, a pattern central to the unit of work mechanism implemented
    in SQLAlchemy. That's why we need primary keys to be declared in the model.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy will assume that the name of your table is the lowercase version
    of your model class name. However, what if we want our table to be called something
    other than `user`? To tell SQLAlchemy what name to use, add the `__tablename__`
    class variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also how you connect to tables that already exist in your database.
    Just place the name of the table in the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to include the `__init__` or `__repr__` functions. If we don't,
    then SQLAlchemy will automatically create an `__init__` function that accepts
    the names and values of your columns as keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Naming a table `user` using an ORM may lead to problems, since in MySQL, `user`
    is a reserved word. One of the advantages of using an ORM is that you can easily
    migrate your engine from SQLite to MySQL and then to ORACLE, for example. One
    very easy fix would be to prefix your schema and use.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using SQLAlchemy to do the heavy lifting, we will now create the user table
    in our database. Update `manage.py` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From now on, whenever we create a new model, we will import it and add it to
    the returned `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will allow us to work with our models in the Flask shell, because we are
    injecting. Run the shell now and use `db.create_all()` to create all of the tables,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In your database, you should now see a table called `users` with the columns
    specified. Also, if you are using SQLite, you should now see a file named `database.db`
    in your file structure, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In every storage mechanism for data, there are four basic types of functions:
    **create**, **read**, **update**, and **delete** (**CRUD**). These allow us to
    perform all the basic ways of manipulating and viewing the data that is needed
    for our web apps. To use these functions, we will use an object in the database
    named a **session**. Sessions will be explained later in the chapter, but for
    now, think of them as a storage location for all of our changes to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new row in your database using our models, add the model to the
    `session` and `commit` objects. Adding an object to the session marks its changes
    for saving. Committing is when the session is saved to the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, adding a new row to our table is simple.
  prefs: []
  type: TYPE_NORMAL
- en: Reading models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we have added data to our database, data can be queried using `Model.query`.
    For those who use SQLAlchemy, this is shorthand for `db.session.query(Model)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first example, use `all()` to get all rows from the user table as a
    list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When the number of items in the database increases, this query process becomes
    slower. In SQLAlchemy, as in SQL, we have the `limit` function to specify the
    total number of rows we wish to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, SQLAlchemy returns the records ordered by their primary keys. To
    control this, we have the `order_by` function, which is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To return just one record, we use `first()` instead of `all()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To return one model by its primary key, use `query.get()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'All these functions are chainable, which means that they can be appended onto
    each other to modify the returned result. Those of you who are fluent in JavaScript
    will find the following syntax familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `first()` and `all()` methods return a value, and therefore end the chain.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a Flask-SQLAlchemy-specific method, called **pagination**, that
    can be used rather than `first()` or `all()`. This is a convenient method that
    is designed to enable the pagination feature that most websites use while displaying
    a long list of items. The first parameter defines which page the query should
    return to and the second parameter defines the number of items per page. So, if
    we passed `1` and `10` as the parameters, the first 10 objects would be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we instead passed `2` and `10`, then objects 11–20 would be returned, and
    so on. The pagination method is different from the `first()` and `all()` methods
    because it returns a pagination object rather than a list of models. For example,
    if we want to get the first 10 items of a fictional `Post` object for the first
    page in our blog, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This object has several useful properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Filtering queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we get to the actual power of SQL—that is, filtering results by a set of
    rules. To get a list of models that satisfy a set of qualities, we use the `query.filter_by`
    filter. The `query.filter_by` filter takes named arguments that represent the
    values we are looking for in each column in the database. To get a list of all
    users with a username of `fake_name`, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is filtering on one value, but multiple values can be passed to
    the `filter_by` filter. Just like our previous functions, `filter_by` is chainable,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `query.filter_by` phrase only works if you know the exact values that you
    are looking for. This is avoided by passing Python comparison statements to the
    query with `query.filter`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple example, but `query.filter` accepts any Python comparison.
    With common Python types, such as `integers`, `strings`, and `dates`, the `==`
    operator can be used for equality comparisons. If you had an `integer`, `float`,
    or `date` column, an inequality statement could also be passed with the `>`, `<`,
    `<=`, and `>=` operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also translate complex SQL queries with SQLAlchemy functions. For example,
    to use `IN`, `OR`, or `NOT` SQL comparisons, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In SQLAlchemy, comparisons to `None` are translated to comparisons to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To update the values of models that already exist, apply the `update` method
    to a query object—that is, before you return the models with a method such as
    `first()` or `all()`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Deleting models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we wish to remove a model from the database, we would use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Relationships between models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relationships between models in SQLAlchemy are links between two or more models
    that allow models to reference each other automatically. This allows naturally
    related data, such as comments on posts, to be easily retrieved from the database
    with its related data. This is where the R in RDBMS comes from, and it gives this
    type of database a large amount of power.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first relation. Our blogging website is going to need some
    blog posts. Each blog post is going to be written by one user, so it makes sense
    to link posts back to the user who wrote them so that we can easily get all the
    posts by a user. This is an example of a **one-to-many** relationship, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite and MySQL/MyISAM engines do not enforce relationship constraints. This
    might cause problems if you are using SQLite on your development environment and
    a different engine on production (MySQL with innodb), but you can tell SQLite
    to enforce foreign key constraints (with a performance penalty).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: One-to-many relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add a model to represent the blog posts on our website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note the `user_id `column. Those who are familiar with RDBMSes will know that
    this represents a **foreign key constraint**. A foreign key constraint is a rule
    in the database that forces the value of `user_id` to exist in the `id` column
    in the user table. This is a check in the database to make sure that `Post` will
    always refer to an existing user. The parameter to `db.ForeignKey` is a string
    representation of the user ID field. If you have decided to call your user table
    with `__table_name__`, then you must change this string. This string is used instead
    of a direct reference with `User.id` because during initialization of SQLAlchemy,
    the `User` object might not exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `user_id` column itself is not enough to tell SQLAlchemy that we have a
    relationship. We must modify our `User` model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `db.relationship` function creates an attribute in SQLAlchemy that connects
    with `db.ForeignKey` in our `Post` model. The first parameter is the name of the
    class that we are referencing. We will cover what `backref` does soon, but what
    is the `lazy` parameter? The `lazy` parameter controls how SQLAlchemy will load
    our related objects. The `subquery` phrase would load our relations as soon as
    our `Post` object is loaded. This cuts down the number of queries, but will slow
    down when the number of returned items grows larger. In contrast, with the `dynamic`
    option, the related objects will be loaded upon access and can be filtered down
    before returning. This is best if the number of returned objects is or will become
    large.
  prefs: []
  type: TYPE_NORMAL
- en: 'We may now access the `User.posts` variable that will return a list of all
    the posts whose `user_id` field equals our `User.id`. Let''s try this now in our
    shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that we were not able to access our post from our relationship without
    committing our changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `backref` parameter gives us the ability to access and set our `User` class
    via `Post.user`. This is given by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `user.posts` is a list, we could have also added our `Post` model to
    the list to save it automatically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `backref` option as dynamic, we can treat our relation column as a
    query as well as a list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on to our next relationship type, let''s add another model for
    user comments with a one-to-many relationship, which will be used in the book
    later on. We can do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `__repr__` method signature in the preceding code. This is a built-in
    function in Python that is used to return the string representation of the object.
    Next is the `Comment` model, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Many-to-many relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we have two models that can reference each other, but each model needs
    to reference more than one of each type? In our example, our blog posts will need
    tags in order for our users to easily group similar posts. Each tag can refer
    to many posts, but each post can have multiple tags. This type of relationship
    is called a **many-to-many** relationship. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `db.Table` object is a lower-level access to the database than the abstraction
    of `db.Model`. The `db.Model` object rests on top of `db.Table` and provides a
    representation of specific rows in the table. The `db.Table` object is used because
    there is no need to access the individual rows of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tags` variable is used to represent the `post_tags` table, which contains
    two rows: one that represents an ID of a post, and another that represents the
    ID of a tag. To illustrate how this works, let''s look at an example. Say that
    the table had the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy would translate this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A post with an ID of `1` has the tags with the IDs of `1` and `3`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post with an ID of `2` has the tags with the IDs of `3`, `4`, and `5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post with an ID of `3` has the tags with the IDs of `1` and `2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may describe this data as easily as tags being related to posts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `db.relationship` function sets up our relationship, this time it
    has the secondary parameter. The secondary parameter tells SQLAlchemy that this
    relationship is stored in the `tags` table, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As given in the one-to-many relationship, the main relationship column is just
    a list, the main difference being that the `backref` option is now also a list.
    Because it''s a list, we may add posts to tags from the `tag` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Constraints and indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using constraints is considered a good practice. This way, you can restrict
    the domain of a certain model attribute and ensure data integrity and quality.
    There are many types of constraints that you can use; primary key and foreign
    key constraintswere already covered in the previous sections. The other kinds
    of constraints that are supported by SQLAlchemy are shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Not NULL (ensures that a certain attribute contains data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UNIQUE (ensures that a certain attribute value is always unique in the database
    table, which contains the model data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DEFAULT (sets a default value for the attribute when no values were provided)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CHECK (used to specify range of values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SQLAlchemy, you can ensure that your data's domain restrictions are explicit
    and all in the same place, not spread across your application code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve our models by setting some constraints on the data. First, we
    should not accept NULL values for usernames on the user model, and ensure that
    a username is always unique. We do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The same principle applies to the rest of our models: A `Post` must always
    have a title, a `Comment` is always made by someone, and a `Tag` always has a
    title, and this title value is unique. We put these constraints in place using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Default values are really nice; they ensure data quality, and make your code
    shorter. We can let SQLAlchemy handle the date timestamp of when a comment or
    post was made using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note how SQLAlchemy handles the default definitions. This is a powerful feature.
    We are passing a reference to a Python function, so we can use any Python function
    we want as long as no parameters are required (except for partials). This function
    will be called upon the creation of a record or an update, and its return value
    is used for the column's value. Of course, SQLAlchemy also supports simple scalar
    values on default definitions.
  prefs: []
  type: TYPE_NORMAL
- en: RDBMS indexes are used to improve query performance, yet you should be careful
    about using them as this comes at a cost of additional writes on `INSERT`, `UPDATE`,
    and `DELETE` functions, as well as an increase in storage. Careful index choice
    and configuration is out of the scope of this book, but take into account the
    fact that an index is used to reduce the O(N) lookup on certain table columns
    that may be frequently used, or that are in tables with a huge number of rows
    where a linear lookup is simply not possible in production. Index query performance
    can go from logarithmic to O(1). This is possible at a cost of additional writes
    and checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of creating an index using Flask SQLAlchemy, can be seen in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows an example of using an index for multiple columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The convenience of SQLAlchemy sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you understand the power of SQLAlchemy and what the SQLAlchemy session object
    is, and why web apps should never be made without them. As stated before, the
    session can be simply described as an object that tracks the changes in our models
    and commits them to the database when we tell it to. However, there is a bit more
    to it than this.
  prefs: []
  type: TYPE_NORMAL
- en: First, the session is also the handler for **transactions**. Transactions are
    sets of changes that are flushed to the database on commit. Transactions provide
    a lot of hidden functionality. For example, transactions automatically determine
    which objects are to be saved first when objects have relations. You might have
    noted this when we were saving tags in the previous section. When we added tags
    to the posts, the session automatically knew to save the tags first despite the
    fact that we did not add them to be committed. If we are working with raw SQL
    queries and a database connection, we will have to keep track of which rows are
    related to which other rows to avoid saving a foreign key reference to an object
    that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions also automatically mark data as stale when changes to an object
    are saved to the database. The next time we access the object, a query is made
    to the database to update the data, but all of this happens behind the scenes.
    If we are not using SQLAlchemy, we will also need to manually track which rows
    need to be updated. If we want to be resource efficient, we only need to query
    and update those rows.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the session makes it impossible for there to be two different references
    to the same row in the database. This is accomplished by ensuring that all queries
    go through the session (`Model.query` is actually `db.session.query(Model)`),
    and if the row has already been queried in this transaction, that the pointer
    to that object will be returned and not a new object. If this check did not exist,
    two objects that represent the same row could be saved to the database with different
    changes. This creates subtle bugs that might not be caught instantly.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that Flask SQLAlchemy creates a new session for every request and
    discards any changes that were not committed at the end of the request, so always
    remember to save your work.
  prefs: []
  type: TYPE_NORMAL
- en: For an in-depth look at sessions, the creator of SQLAlchemy, Mike Bayer, gave
    a talk at PyCon Canada 2012\. Refer to *The SQLAlchemy Session - In Depth*, at [https://www.youtube.com/watch?v=PKAdehPHOMo](https://www.youtube.com/watch?v=PKAdehPHOMo).
  prefs: []
  type: TYPE_NORMAL
- en: Database migrations with Alembic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functionality of web apps changes all the time, and with every new functionality,
    we need to change the structure of our database. Whether it's adding or dropping
    new columns or creating new tables, our models will change throughout the life
    cycle of our app. However, problems quickly arise when the database changes often.
    When moving our changes from development to production, how can you be sure that
    you carried over every change without manually comparing each model and its corresponding
    table? Let's say that you want to go back into your Git history to see whether
    an earlier version of your app had the same bug that you are now encountering
    in production. How will you change your database back to the correct schema without
    a lot of extra work?
  prefs: []
  type: TYPE_NORMAL
- en: As programmers, we hate extra work. Thankfully, there is a tool called **Alembic**,
    which automatically creates and tracks database migrations from the changes in
    our SQLAlchemy models. **Database migrations** are records of all the changes
    of our schema. Alembic allows us to upgrade or downgrade our database to a specific
    saved version. Upgrading or downgrading by several versions will execute all the
    files between the two selected versions. The best thing about Alembic is that
    its history files are only Python files. When we create our first migration, we
    can see how simple the Alembic syntax is.
  prefs: []
  type: TYPE_NORMAL
- en: Alembic does not capture every possible change—for example, it does not record
    changes on the SQL indexes. After every migration, the reader is encouraged to
    review the migration file and make any necessary corrections.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t work directly with Alembic. Instead, we will use **Flask-Migrate**,
    which is an extension created specifically for SQLAlchemy, and which works with
    the Flask CLI. You will find it in the `requirements.txt` file, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To get started, we don''t need to add anything to our `manage.py` file since
    Flask-Migrate already extends the Flask CLI with its own CLI options, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And on our `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the `Migrate` object with our app and our SQLAlchemy instance,
    run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To start tracking our changes, we use the `init` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new folder in our directory named `migrations` that will
    hold all of our history. Now we start with our first migration, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This command will cause Alembic to scan our SQLAlchemy object and find all the
    tables and columns that did not exist before this commit. As this is our first
    commit, the migration file will be rather long. Be sure to specify the migration
    message with `-m`, as it's the easiest way to identify what each migration is
    doing. Each migration file is stored in the `migrations/versions/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the migration to your database and change your schema, run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to check out all the SQLAlchemy generated DDL code, then we use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To return to the previous version, find the version number with the `history`
    command and pass it to the `downgrade` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Like Git, a hash marks each migration. This is the main functionality of Alembic,
    but it is only surface level. Try to align your migrations with your Git commits
    in order to make it easier to downgrade or upgrade when reverting commits.
  prefs: []
  type: TYPE_NORMAL
- en: In the code for this book, you will find in each chapter an initialization script
    that will create a Python virtual environment, install all declared dependencies,
    and initialize the database. Take a look at the `init.sh` Bash script.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have mastered data control, we may move on to displaying our data
    in our application. The next chapter, `Chapter 3`, *Creating Views with Templates*,
    will dynamically cover creating HTML based on our models and adding models from
    our web interface.
  prefs: []
  type: TYPE_NORMAL
