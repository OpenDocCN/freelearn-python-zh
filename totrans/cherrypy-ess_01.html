<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Introduction to CherryPy</h1></div></div></div><p>The use of the World Wide Web has grown exponentially, and has become a key component of the way we live today. From the developer's point of view, the Web offers great opportunities and good fun. However, the growing number of technologies oriented towards the Web is overwhelming, and it can be difficult to decide which one to use. The goal of this book is to present one of these, CherryPy, a Python web-application library.<a id="id0" class="indexterm"/>
</p><p>This chapter will introduce CherryPy's features and strengths, beginning with a summary of CherryPy's history, then looking at its friendly community, which has long been an important piece of the project's success, and finally reviewing key principles behind the evolution of CherryPy.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec01"/>Overview</h1></div></div></div><p>CherryPy is a Python library providing a friendly interface to the HTTP protocol for Python developers. HTTP is the backbone of the World Wide Web. Web applications have grown exponentially in the last few years. This explosion was followed by a large number of toolkits, libraries, and frameworks released in various programming languages to help web developers in their task. Ultimately all of these aim at making a web developer's life much easier. In this context CherryPy has started using Python's strengths as a dynamic language to model and bind the HTTP protocol into a API that follows Python idioms.<a id="id1" class="indexterm"/>
</p><p>The Python community has grown a large number of web libraries and frameworks over the years to the point where it has become some kind of a joke as much as a worry. Even though only a handful of them have attracted most of the community, (TurboGears, Django, or Zope) each existing library or framework has kept its niche influence by providing its own view on how to interface Python with HTTP and the Web in general. CherryPy was born because at that time Remi Delon, its creator, could not find what he wanted in the existing choices. Over the years, the design of CherryPy has been tuned by new developers who liked its strengths and joined in. Today the project has a strong community base that uses it on a daily basis in many different contexts.<a id="id2" class="indexterm"/>
</p></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec02"/>History of CherryPy</h1></div></div></div><p>Remi Delon released the first version of CherryPy in late June 2002. This was the starting point of a successful Python web library. Remi is a French hacker who has trusted Python for being ultimately one of the greatest alternatives for web application development.<a id="id3" class="indexterm"/>
</p><p>The project attracted a number of developers who were interested in the approach taken by Remi:<a id="id4" class="indexterm"/>
</p><div><ul class="itemizedlist"><li class="listitem"><p>CherryPy classes were an extension to Python to support the separation of concern between the data and the presentation. It was close to the model-view-controller pattern.</p></li><li class="listitem"><p>A CherryPy class has to be processed and compiled by the CherryPy engine to produce a self-contained Python module embedding the complete application as well as its own built-in web server.</p></li></ul></div><p>CherryPy would map a URL and its query string into a Python method call, for example: <a class="ulink" href="http://somehost.net/echo?message=hello">http://somehost.net/echo?message=hello</a> would map to<code class="literal"> echo(message='hello')</code>.</p><p>During the following two years, the project was supported by the community and Remi released several improved versions.</p><p>In June 2004, a discussion started about the future of the project and whether it should continue with the same architecture. One of the main concerns was the compilation step, which did not feel natural to Python developers. Brainstorming and discussion by several project regulars then led to the concept of object-publishing engine and filters, which soon became a core ingredient of CherryPy 2.</p><p>Eventually, in October 2004, the first version of CherryPy 2 alpha was released as a proof of concept of these core ideas. Then followed six months of intense work to release a stable version (late April 2005). Soon other developers joined the project to improve it. CherryPy 2.0 was a real success; however, it was recognized that its design could still be improved, and needed refactoring.</p><p>After further community feedback/discussions, CherryPy's API was further modified to improve its elegance, leading to the release of CherryPy 2.1.0 in October 2005. This version was shipped by the popular TurboGears project—itself a stack of projects to produce a web mega-framework. The team released CherryPy 2.2.0 in April 2006.</p><p>CherryPy's presence as a core ingredient in the increasingly widely adopted TurboGears stack naturally meant that more and more issues were raised about some aspects of CherryPy. For example, its WSGI support, the lack of up-to-date documentation, or its only-average performance. It was clear that to meet these real and important requirements, it would be extremely difficult to extend CherryPy 2 without breaking backward-compatibility constraints. As a result, the decision was finally made to move towards CherryPy 3, which was released at the end of 2006.<a id="id5" class="indexterm"/>
</p><div><img src="img/1848_01_01.jpg" alt="History of CherryPy"/></div></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec03"/>The Community</h1></div></div></div><p>CherryPy would not be where it stands without the community built over the last few years. Remi has always been clear about the fact that he does not want CherryPy to be his pet project, but rather to be a community one.<a id="id6" class="indexterm"/>
</p><p>CherryPy has always had its followers, but the CherryPy community actually started with version 2.0 of the product. In November 2004, an IRC channel was registered on the<strong> Open</strong> and<strong> Free Technology Community</strong> (<strong>OFTC</strong>) network to allow developers and users to quickly exchange ideas or to report defects. The channel gradually attracted more and more regulars and was generally recognized to be a very friendly place. In addition to the IRC channel, mailing-lists were created for developers and users. Eventually a feed aggregation of blog entries of regular CherryPy users was published and has been available since then at <a class="ulink" href="http://planet.cherrypy.org">http://planet.cherrypy.org</a>.<a id="id7" class="indexterm"/>
</p><div><img src="img/1848_01_02.jpg" alt="The Community"/></div></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec04"/>CherryPy Project Strengths</h1></div></div></div><div><ul class="itemizedlist"><li class="listitem"><p>Simplicity: One of the main goals has always been to keep CherryPy as simple as possible with the aim of avoiding the library to over engineering the project. Thanks to the narrow scope covered by the library, the developers have been able to concentrate on the API and community feedback.<a id="id8" class="indexterm"/>
</p></li><li class="listitem"><p>Self-contained: From the very beginning, Remi decided that the core of CherryPy would not require any third-party Python packages to work and would rely purely on the Python standard library.</p></li><li class="listitem"><p>Not intrusive: Another critical aspect of the library the developers have long cared about was to make sure that CherryPy would stay as much as possible out of the way of its users. The idea was to provide a set of tools to any developer making no assumptions about the way in which he or she may choose to use them.</p></li><li class="listitem"><p>Open to discussion: The developer team has always listened to the feedback given by the community. This does not mean that every request has been adopted, but almost all have been discussed and reviewed.</p></li><li class="listitem"><p>Fun: When working on an open-source project, contributors should not be made to feel it is just their day-to-day job; on the contrary there is great value in them really enjoying what they do. Likewise, for a CherryPy user, the fun element is also an important part, and we observe that it makes each of us better and more creative developers.</p></li></ul></div></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec05"/>Beyond CherryPy</h1></div></div></div><p>In its early days, CherryPy attracted a small group of users but its design prevented it from growing into something larger or from being used more widely. Moreover, at that time the Python web-development field was mainly occupied by the Zope platform. When CherryPy 2 was released, its conception was more warmly welcomed by the community and eventually attracted more users who started to use it for applications as well as for building their own packages based on top of it.</p><p>Indeed in late September 2005, Kevin Dangoor released TurboGears—a framework for web development built as a stack of existing open-source products. Kevin chose CherryPy to handle the HTTP layer of his framework, SQLObject to map objects to the database, Kid for XHTML templating, and MochiKit for client-side handling. This release took place just a couple of months after another Python web framework, Django, was opened to the community. Both projects quickly gained a lot of popularity among the Python community and thanks to a little competition between them, they grew in a very quick fashion. The boom of TurboGears boosted CherryPy's fame and attracted an important volume of new users.</p><p>These waves of new developers increased CherryPy's number of requested features as well as defects being fixed, leading eventually to CherryPy 3, the most stable version of the library, and to the writing of this book.</p><p>CherryPy's future is clear and bright; the fantastic work done by Robert Brewer has allowed the library to reach its cruising speed. TurboGears' future version will certainly move to CherryPy 3, which will lead to a whole new set of questions to be brought up to the development team and will push CherryPy to its next big step.</p></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Through the Book</h1></div></div></div><p>This book aims at introducing the CherryPy library at a level that should make you confident that you can use it best in your own web application. Additionally we will try to open the discussion on the design of web applications and a perspective of the domain at the time of writing the book. In a nutshell the book will explain how to get and install CherryPy in a number of common ways in the Python community, such as using setup tools and easy_install. It will also give an overview of the main and most common aspects of CherryPy. This will gently bring you into an understanding of what the library can do. It then drills down into the library features such as its HTTP capabilities, alternative URI dispatchers, and extending the library as well as its WSGI support.</p><p>This will give you a solid understanding of CherryPy, its design, and how to make the best use of it from within your own applications. The book then breaks down the layers of web development by introducing techniques and tools such as object-relational mappers, web services, and Ajax through the development of a simple blog application.</p><p>It presents the blog application objectives and boundaries, reviews the status of database handling in Python, and then explains Object-Relational Mapping. It extensively presents one of the Python ORMs called Dejavu. It also talks about REST and the Atom Publishing Protocol, both of which offer a way to design web services that can extend your web applications beyond the simple capacity of serving HTML pages. Then it introduces you to the presentation layer of the blog application, which encompasses the review of the templating engine called Kid as well as the JavaScript library called MochiKit. The book discusses Ajax and how your applications can benefit from the principles behind it. We will also see how your application can call the web services. Then, the book extensively inspects the field of testing a web application. This goes from unit testing to load testing via the functional testing aspect of it. The book finally ends by presenting different ways to deploy a web application as a stand-alone application or via well known web servers such as Apache and lighttpd.</p><p>Although some chapters do not extensively include discussion about CherryPy itself, all of them will converge towards bringing an understanding of some aspects of web application development. Hopefully this book will teach you about CherryPy and will also give you the knowledge and the desire to learn more about the topics it covers</p></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Summary</h1></div></div></div><p>After reading this introduction you should have the necessary background understanding of where this book is going to lead you. CherryPy is a simple and yet powerful Python library that will be a great companion to web developers who wish to find a package that hides the difficulties of the HTTP protocol while keeping its strengths. The CherryPy community has been working hard for the last few years to make such a product possible; hopefully this book will give you the right directions to make the most of it.</p></div></div></div>
</body></html>