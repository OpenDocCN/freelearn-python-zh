<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Using Python to Drive Hardware</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Controlling an LED</li><li class="listitem" style="list-style-type: disc">Responding to a button</li><li class="listitem" style="list-style-type: disc">A controlled shutdown button</li><li class="listitem" style="list-style-type: disc">The GPIO keypad input</li><li class="listitem" style="list-style-type: disc">Multiplexed color LEDs</li><li class="listitem" style="list-style-type: disc">Writing messages using Persistence of Vision</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Introduction</h1></div></div></div><p>One of the key features of a Raspberry Pi computer that sets it apart from most other home/office computers is that it has the ability to directly interface with other hardware. The hardware <strong>General Purpose Input/Output</strong> (<strong>GPIO</strong>) pins on the Raspberry Pi can control a wide range of low-level electronics, from <strong>Light Emitting Diodes</strong> (<strong>LEDs</strong>) to switches, sensors, motors, servos, and even extra displays.</p><p>This chapter will focus on connecting the Raspberry Pi with some simple circuits and getting to grips with using Python to control and respond to the connected components.</p><p>The Raspberry Pi hardware interface consists of 40 pins located along one side of the board.</p><div><div><h3 class="title"><a id="note50"/>Note</h3><p>The GPIO pins and their layout will vary slightly according to the particular model you have.</p><p>The Raspberry Pi 2 and the Raspberry Pi 1 Model A Plus and B Plus all have the same 40-pin layout.</p><p>The older Raspberry Pi 1 models (non-plus types) have a 26-pin header, which is the same as the 1-26 pins of the newer models.</p></div></div><div><img alt="Introduction" src="img/6623OT_06_001.jpg"/><div><p>Raspberry Pi 2 and Raspberry Pi Model Plus GPIO header pins (pin functions)</p></div></div><p>The layout of the connector is shown in the previous diagram; the pin numbers are shown as seen from pin 1 of the GPIO header.</p><p>
<strong>Pin 1</strong> is at the end that is nearest to the SD card, as shown in the following image:</p><div><img alt="Introduction" src="img/6623OT_06_002.jpg"/><div><p>The Raspberry Pi GPIO header location</p></div></div><p>Care should be taken when using the GPIO header, since it also includes power pins (3V3 and 5V) as well as ground pins (GND). All of the GPIO pins can be used as standard GPIO, but several also have special functions; these are labeled and highlighted with different colors.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>It is common for engineers to use a 3V3 notation to specify values in schematics to avoid using decimal places that could easily be missed (using 33V rather than 3.3V would cause severe damage). The same can applied to other values such as resistors, so for example, 1.2k ohms can be written as 1k2 ohms.</p></div></div><p>There are <strong>TX</strong> and <strong>RX</strong> pins that are used for serial RS232 communications, and with the aid of a voltage level convertor, information can be transferred via a serial cable to another computer or device.</p><p>We have <strong>SDA</strong> and <strong>SCL</strong> pins that are able to support a two-wire bus communication protocol called <strong>I<sup>2</sup>C</strong> (on Model Plus and Raspberry Pi 2 boards there are two I<sup>2</sup>C channels: <strong>channel 1 ARM</strong> is for general use while <strong>channel 0 VC</strong> is typically used for identifying Hardware Attached on Top (HAT) modules). There are also the <strong>SPI MOSI</strong>, <strong>SPI MISO</strong>, <strong>SPI SCLK</strong>, <strong>SPI CE0</strong>, and <strong>SPI CE1</strong> pins, which support another type of bus protocol called <strong>SPI</strong> for high-speed data. Finally, we have <strong>PWM0/1</strong>, which allows a <strong>pulse width modulation</strong> signal to be generated, which is useful for servos and generating analog signals.</p><p>However, we will focus on using just the standard GPIO functions in this chapter. The GPIO pin layout is shown in the following diagram:</p><div><img alt="Introduction" src="img/6623OT_06_003.jpg"/><div><p>Raspberry Pi GPIO header pins (GPIO.BOARD and GPIO.BCM)</p></div></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>The Raspberry Pi Rev 2 (pre-July 2014) has the following differences to the Raspberry Pi 2 GPIO layout:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">26 GPIO pins header (matching the first 26 pins)</li><li class="listitem" style="list-style-type: disc">An additional secondary set of eight holes (P5) located next to the pin header. The details are as follows:</li></ul></div><div><img alt="Introduction" src="img/6623OT_06_004.jpg"/><div><p>Raspberry Pi Rev 2 P5 GPIO header pins</p></div></div><p>The original Raspberry Pi Rev 1 (pre-Oct 2012) has only 26 GPIO pins in total (matching the first 26 pins of the current Raspberry Pi, except for the following details):</p><div><img alt="Introduction" src="img/6623OT_06_005.jpg"/></div></div></div><p>Raspberry Pi Rev 1 GPIO header differencesThe <strong>RPi.GPIO</strong> library can reference the pins on the Raspberry Pi using one of two systems. The numbers shown in the center are the physical position of the pins and are also the numbers referenced by RPi.GPIO when in the <strong>GPIO.BOARD</strong> mode. The numbers on the outside (<strong>GPIO.BCM</strong>) are the actual references for the physical ports of the processor to which the pins are wired (which is why they are not in any specific order). They are used when the mode is set to <strong>GPIO.BCM</strong> and allow control of the GPIO header pins and also any peripherals connected to other GPIO lines. This includes the LED on the add-on camera on BCM GPIO 4 and the status LED on the board. However, this can also include the GPIO lines used for reading/writing to the SD card, which would cause serious errors if interfered with.</p><p>If you use other programming languages to access the GPIO pins, the numbering scheme may be different, so it will be helpful if you are aware of the BCM GPIO references, which refer to the physical GPIO port of the processor.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>Be sure to check out the <a class="link" href="apa.html" title="Appendix A. Hardware and Software List">Appendix</a>, <em>Hardware and Software List</em>, which lists all the items used in this chapter and the places you can obtain them from.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Controlling an LED</h1></div></div></div><p>The hardware equivalent of <code class="literal">hello world</code> is an LED flash, which is a great test to ensure that everything is working and that you have wired it correctly. To make it a little more interesting, I've suggested using an RGB LED (it has red, green, and blue LEDs combined into a single unit), but feel free to use separate LEDs if that is all you have available.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec104"/>Getting ready</h2></div></div></div><p>You will need the following equipment:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">4 x DuPont female to male patch wires</li><li class="listitem" style="list-style-type: disc">Mini breadboard (170 tie points) or a larger one</li><li class="listitem" style="list-style-type: disc">RGB LED (common cathode)/3 standard LEDs (ideally red/green/blue)</li><li class="listitem" style="list-style-type: disc">Breadboarding wire (solid core)</li><li class="listitem" style="list-style-type: disc">3 x 470 ohm resistors</li></ul></div><p>Each of the previous components should only cost a few dollars and can be reused for other projects afterwards. The breadboard is a particularly useful item that allows you to try out your own circuits without needing to solder them.</p><div><img alt="Getting ready" src="img/6623OT_06_006.jpg"/><div><p>The diagrams of an RGB LED, standard LED, and RGB circuit</p></div></div><p>The following diagram shows the breadboard circuitry:</p><div><img alt="Getting ready" src="img/6623OT_06_007.jpg"/><div><p>The wiring of an RGB LED/standard LEDs connected to the GPIO header</p></div></div><div><div><h3 class="title"><a id="note51"/>Note</h3><p>There are several variations of RGB LEDs available, so check the datasheet of your component to confirm the pin order and type you have. Some are Red, Blue, and Green (RBG), so ensure that you wire accordingly or adjust the <code class="literal">RGB_</code> pin settings in the code. You can also get common anode variants, which will require the anode to be connected to 3V3 (GPIO-Pin1) for it to light up (and require <code class="literal">RGB_ENABLE</code> and <code class="literal">RGB_DISABLE</code> to be set to <code class="literal">0</code> and <code class="literal">1</code>).</p></div></div><p>The breadboard and component diagrams of this book have been created using a free tool called <strong>Fritzing</strong> (<a class="ulink" href="http://www.fritzing.org">www.fritzing.org</a>); it is great for planning your own Raspberry Pi projects.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec105"/>How to do it…</h2></div></div></div><p>Create the <code class="literal">ledtest.py</code> script as follows:</p><div><pre class="programlisting">#!/usr/bin/python3
#ledtest.py
import time
import RPi.GPIO as GPIO
# RGB LED module
#HARDWARE SETUP
# GPIO
# 2[======XRG=B==]26[=======]40
# 1[=============]25[=======]39
# X=GND R=Red G=Green B=Blue 
#Setup Active States
#Common Cathode RGB-LED (Cathode=Active Low)
RGB_ENABLE = 1; RGB_DISABLE = 0

#LED CONFIG - Set GPIO Ports
RGB_RED = 16; RGB_GREEN = 18; RGB_BLUE = 22
RGB = [RGB_RED,RGB_GREEN,RGB_BLUE]

def led_setup():
  #Setup the wiring
  GPIO.setmode(GPIO.BOARD)
  #Setup Ports
  for val in RGB:
    GPIO.setup(val,GPIO.OUT)

def main():
  led_setup()
  for val in RGB:
    GPIO.output(val,RGB_ENABLE)
    print("LED ON")
    time.sleep(5)
    GPIO.output(val,RGB_DISABLE)
    print("LED OFF")

try:
  main()
finally:
  GPIO.cleanup()
  print("Closed Everything. END")
#End</pre></div><p>The <code class="literal">RPi.GPIO</code> library will require <code class="literal">sudo</code> permissions to access the GPIO pin hardware, so you will need to run the script using the following command:</p><div><pre class="programlisting">
<strong>sudo python3 ledtest.py</strong>
</pre></div><p>When you run the script, you should see the red, green, and blue parts of the LED (or each LED, if using separate ones) light up in turn. If not, double-check your wiring or confirm the LED is working by temporarily connecting the red, green, or blue wire to the 3V3 pin (pin 1 of the GPIO header).</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>The <code class="literal">sudo</code> command is required for most hardware-related scripts because it isn't normal for users to directly control hardware at such a low level. For example, setting or clearing a control pin that is part of the SD card controller could corrupt data being written to it. Therefore, for security purposes, super user permissions are required to stop programs from using hardware by accident (or with malicious intent).</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec106"/>How it works…</h2></div></div></div><p>To access the GPIO pins using Python, we import <code class="literal">RPi.GPIO</code>, which allows direct control of the pins through the module functions. We also require the <code class="literal">time</code> module to pause the program for a set number of seconds.</p><p>We define values for the LED wiring and active states (see <em>Controlling the GPIO current</em> in the <em>There's more…</em> section of this recipe).</p><p>Before the GPIO pins are used by the program, we need to set them up by specifying the numbering method (<code class="literal">GPIO.BOARD</code>) and the direction—<code class="literal">GPIO.OUT</code> or <code class="literal">GPIO.IN</code> (in this case, we set all the RGB pins to outputs). If a pin is configured as an output, we will be able to set the pin state; similarly, if it is configured as an input, we will be able to read the pin state.</p><p>Next, we control the pins using <code class="literal">GPIO.ouput()</code> by stating the number of the GPIO pin and the state we want it to be in (<code class="literal">1</code> = high/on and <code class="literal">0</code> = low/off). We switch each LED on, wait 5 seconds, and then switch it back off.</p><p>Finally, we use <code class="literal">GPIO.cleanup()</code> to return the GPIO pins back to their original default state and release control of the pins for use by other programs.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec107"/>There's more…</h2></div></div></div><p>Using the GPIO pins on the Raspberry Pi must be done with care since these pins are directly connected to the main processor of the Raspberry Pi without any additional protection. Caution must be used, as any incorrect wiring will probably damage the Raspberry Pi processor and cause it to stop functioning altogether.</p><p>Alternatively, you could use one of the many modules available that plug directly into the GPIO header pins (reducing the chance of wiring mistakes).</p><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>For example, the Pi-Stop is a simple pre-built LED board that simulates a set of traffic lights, designed to be a stepping stone for those interested in controlling hardware but want to avoid the risk of damaging their Raspberry Pi. After the basics have been mastered, it also makes an excellent indicator to aid debugging.</p><p>Just ensure you update the <code class="literal">LED CONFIG</code> pin references in the <code class="literal">ledtest.py</code> script to reference the pin layout and location used for the hardware you are using.</p></div></div><div><img alt="There's more…" src="img/6623OT_06_008.jpg"/></div><p>See the <a class="link" href="apa.html" title="Appendix A. Hardware and Software List">Appendix</a>, <em>Hardware and Software List</em>, for a list of Raspberry Pi hardware retailers.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec33"/>Controlling the GPIO current</h3></div></div></div><p>Each GPIO pin is only able to handle a certain current before it will burn out (not greater than 16 mA from a single pin or 30 mA in total), and similarly, the RGB LED should be limited to no more than 100 mA. By adding a resistor before or after an LED, we will be able to limit the current that will be passed through it and also control how bright it is (more current will equal a brighter LED).</p><p>Since we may wish to drive more than one LED at a time, we typically aim to set the current as low as we can get away with while still providing enough power to light up the LED.</p><p>We can use Ohm's law to tell us how much resistance to use to provide a particular current. The law is as shown in the following diagram:</p><div><img alt="Controlling the GPIO current" src="img/6623OT_06_009.jpg"/><div><p>Ohm's law describes the relationship between the current, resistance, and voltage in electrical circuits</p></div></div><p>We will aim for a minimum current (3 mA) and maximum current (16 mA), while still producing a reasonably bright light from each of the LEDs. To get a balanced output for the RGB LEDs, I tested different resistors until they provided a near white light (when viewed through a card). A 470 ohm resistor was selected for each one (your LEDs may differ slightly).</p><div><img alt="Controlling the GPIO current" src="img/6623OT_06_010.jpg"/><div><p>Resistors are needed to limit the current that passes through the LEDs</p></div></div><p>The voltage across the resistor is equal to the GPIO voltage (Vgpio = 3.3V) minus the voltage drop on the particular LED (<code class="literal">Vfwd</code>); we can then use this resistance to calculate the current used by each of the LEDs, as shown in the following diagram:</p><div><img alt="Controlling the GPIO current" src="img/6623OT_06_011.jpg"/><div><p>We can calculate the current drawn by each of the LEDs</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Responding to a button</h1></div></div></div><p>Many applications using the Raspberry Pi require that actions are activated without a keyboard and screen attached to it. The GPIO pins provide an excellent way for the Raspberry Pi to be controlled by your own buttons and switches without a mouse/keyboard and screen.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec108"/>Getting ready</h2></div></div></div><p>You will need the following equipment:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">2 x DuPont female to male patch wires</li><li class="listitem" style="list-style-type: disc">Mini breadboard (170 tie points) or a larger one</li><li class="listitem" style="list-style-type: disc">Push button switch (momentary close) or a wire connection to make/break the circuit</li><li class="listitem" style="list-style-type: disc">Breadboarding wire (solid core)</li><li class="listitem" style="list-style-type: disc">1k ohm resistor</li></ul></div><p>The switches are as seen in the following diagram:</p><div><img alt="Getting ready" src="img/6623OT_06_012.jpg"/><div><p>The push button switch and other types of switch</p></div></div><div><div><h3 class="title"><a id="note52"/>Note</h3><p>The switches used in the following examples are <strong>single pole single throw</strong> (<strong>SPST</strong>) momentary close push button switches. <strong>Single pole</strong> (<strong>SP</strong>) means that there is one set of contacts that makes a connection. In the case of the push switch used here, the legs on each side are connected together with a single pole switch in the middle. A <strong>double pole</strong> (<strong>DP</strong>) switch acts just like a single pole switch, except that the two sides are separated electrically, allowing you to switch two separate components on/off at the same time.</p><p>
<strong>Single throw</strong> (<strong>ST</strong>) means the switch will make a connection with just one position; the other side will be left open. <strong>Double throw</strong> (<strong>DT</strong>) means both positions of the switch will connect to different parts.</p><p>
<strong>Momentary close</strong> means that the button will close the switch when pressed and automatically open it when released. A <strong>latched</strong> push button switch will remain closed until it is pressed again.</p></div></div><div><img alt="Getting ready" src="img/6623OT_06_013.jpg"/><div><p>The layout of the button circuit</p></div></div><p>We will use sound in this example, so you will also need speakers or headphones attached to the audio socket of the Raspberry Pi.</p><p>You will need to install a program called <code class="literal">flite</code> using the following command, which will let us make the Raspberry Pi talk:</p><div><pre class="programlisting">
<strong>sudo apt-get install flite</strong>
</pre></div><p>After it has been installed, you can test it with the following command:</p><div><pre class="programlisting">
<strong>sudo flite -t "hello I can talk"</strong>
</pre></div><p>If it is a little too quiet (or too loud), you can adjust the volume (0-100 percent) using the following command:</p><div><pre class="programlisting">
<strong>amixer set PCM 100%</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec109"/>How to do it…</h2></div></div></div><p>Create the <code class="literal">btntest.py</code> script as follows:</p><div><pre class="programlisting">#!/usr/bin/python3
#btntest.py
import time
import os
import RPi.GPIO as GPIO
#HARDWARE SETUP
# GPIO
# 2[==X==1=======]26[=======]40
# 1[=============]25[=======]39
#Button Config
BTN = 12

def gpio_setup():
  #Setup the wiring
  GPIO.setmode(GPIO.BOARD)
  #Setup Ports
  GPIO.setup(BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP)
  

def main():
  gpio_setup()
  count=0
  btn_closed = True
  while True:
    btn_val = GPIO.input(BTN)
    if btn_val and btn_closed:
       print("OPEN")
       btn_closed=False
    elif btn_val==False and btn_closed==False:
       count+=1
       print("CLOSE %s" % count)
       os.system("flite -t '%s'" % count)
       btn_closed=True
    time.sleep(0.1)


try:
  main()
finally:
  GPIO.cleanup()
  print("Closed Everything. END")
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec110"/>How it works…</h2></div></div></div><p>As in the previous recipe, we set up the GPIO pin as required, but this time as an input, and we also enable the internal pull-up resistor (see <em>Pull-up and pull-down resistor circuits</em> in the <em>There's more…</em> section of this recipe for more information) using the following code:</p><div><pre class="programlisting">GPIO.setup(BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP)</pre></div><p>After the GPIO pin is set up, we create a loop that will continuously check the state of <code class="literal">BTN</code> using <code class="literal">GPIO.input()</code>. If the value returned is <code class="literal">false</code>, the pin has been connected to 0V (ground) through the switch, and we will use <code class="literal">flite</code> to count out loud for us each time the button is pressed.</p><p>Since we have called the main function from within a <code class="literal">try</code>/<code class="literal">finally</code> condition, it will still call <code class="literal">GPIO.cleanup()</code> even if we close the program using <em>Ctrl</em> + <em>Z</em>.</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>We use a short delay in the loop; this ensures that any noise from the contacts on the switch is ignored. This is because when we press the button, there isn't always perfect contact as we press or release it, and it may produce several triggers if we press it again too quickly. This is known as <strong>software debouncing</strong>; we ignore the bounce in the signal here.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec111"/>There's more…</h2></div></div></div><p>The Raspberry Pi GPIO pins must be used with care; voltages used for inputs should be within specific ranges, and any current drawn from them should be minimized using protective resistors.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec34"/>Safe voltages</h3></div></div></div><p>We must ensure that we only connect inputs that are between 0 (Ground) and 3.3V. Some processors use voltages between 0 and 5V, so extra components are required to interface safely with them. Never connect an input or component that uses 5V unless you are certain it is safe, or you will damage the GPIO ports of the Raspberry Pi.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec35"/>Pull-up and pull-down resistor circuits</h3></div></div></div><p>The previous code sets the GPIO pins to use an internal pull-up resistor. Without a pull-up resistor (or pull-down resistor) on the GPIO pin, the voltage is free to float somewhere between 3.3V and 0V, and the actual logical state remains undetermined (sometimes 1 and sometimes 0).</p><p>Raspberry Pi's internal pull-up resistors are 50k ohm-65k ohm and the pull-down resistors are 50k ohm-65k ohm. External pull-up/pull-down resistors are often used in GPIO circuits (as shown in the following diagram), typically using 10k ohm or larger for similar reasons (giving a very small current draw when not active).</p><p>A pull-up resistor allows a small amount of current to flow through the GPIO pin and will provide a high voltage when the switch isn't pressed. When the switch is pressed, the small current is replaced by the larger one flowing to 0V, so we get a low voltage on the GPIO pin instead. The switch is active low and logic 0 when pressed. It works as shown in the following diagram:</p><div><img alt="Pull-up and pull-down resistor circuits" src="img/6623OT_06_014.jpg"/><div><p>A pull-up resistor circuit</p></div></div><p>Pull-down resistors work in the same way, except the switch is active high (the GPIO pin is logic 1 when pressed). It works as shown in the following diagram:</p><div><img alt="Pull-up and pull-down resistor circuits" src="img/6623OT_06_015.jpg"/><div><p>A pull-down resistor circuit</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec36"/>Protection resistors</h3></div></div></div><p>In addition to the switch, the circuit includes a resistor in series with the switch to protect the GPIO pin, as shown in the following diagram:</p><div><img alt="Protection resistors" src="img/6623OT_06_016.jpg"/><div><p>A GPIO protective current-limiting resistor</p></div></div><p>The purpose of the protection resistor is to protect the GPIO pin if it is accidentally set as an output rather than an input. Imagine, for instance, that we have our switch connected between the GPIO and ground. Now the GPIO pin is set as an output and switched on (driving it to 3.3V) as soon as we press the switch; without a resistor present, the GPIO pin will directly be connected to 0V. The GPIO will still try to drive it to 3.3V; this would cause the GPIO pin to burn out (since it would use too much current to drive the pin to the high state). If we use a 1k ohm resistor here, the pin is able to be driven high using an acceptable amount of current (I = V/R = 3.3/1k = 3.3mA).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>A controlled shutdown button</h1></div></div></div><p>The Raspberry Pi should always be shut down correctly to avoid the SD card being corrupted (by losing power while performing a write operation to the card). This can pose a problem if you don't have a keyboard or screen connected (if you are running an automated program or controlling it remotely over a network and forget to turn it off) as you can't type the command or see what you are doing. By adding our own buttons and LED indicator, we can easily command a shutdown, reset, and startup again to indicate when the system is active.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec112"/>Getting ready</h2></div></div></div><p>You will need the following equipment:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">3 x Dupont female to male patch wires</li><li class="listitem" style="list-style-type: disc">Mini breadboard (170 tie points) or a larger one</li><li class="listitem" style="list-style-type: disc">Push button switch (momentary close)</li><li class="listitem" style="list-style-type: disc">General purpose LED</li><li class="listitem" style="list-style-type: disc">2 x 470-ohm resistors</li><li class="listitem" style="list-style-type: disc">Breadboarding wire (solid core)</li></ul></div><p>The entire layout of the shutdown circuit will look as shown in the following figure:</p><div><img alt="Getting ready" src="img/6623OT_06_017.jpg"/><div><p>The controlled shutdown circuit layout</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec113"/>How to do it…</h2></div></div></div><p>Create the <code class="literal">shtdwn.py</code> script as follows:</p><div><pre class="programlisting">#!/usr/bin/python3
#shtdwn.py
import time
import RPi.GPIO as GPIO
import os

# Shutdown Script
DEBUG=True #Simulate Only
SNDON=True
#HARDWARE SETUP
# GPIO
# 2[==X==L=======]26[=======]40
# 1[===1=========]25[=======]39

#BTN CONFIG - Set GPIO Ports
GPIO_MODE=GPIO.BOARD
SHTDWN_BTN = 7 #1
LED = 12       #L

def gpio_setup():
  #Setup the wiring
  GPIO.setmode(GPIO_MODE)
  #Setup Ports
  GPIO.setup(SHTDWN_BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP)
  GPIO.setup(LED,GPIO.OUT)

def doShutdown():
  if(DEBUG):print("Press detected")
  time.sleep(3)
  if GPIO.input(SHTDWN_BTN):
    if(DEBUG):print("Ignore the shutdown (&lt;3sec)")
  else:
    if(DEBUG):print ("Would shutdown the RPi Now")
    GPIO.output(LED,0)
    time.sleep(0.5)
    GPIO.output(LED,1)
    if(SNDON):os.system("flite -t 'Warning commencing power down 3 2 1'")
    if(DEBUG==False):os.system("sudo shutdown -h now")
    if(DEBUG):GPIO.cleanup()
    if(DEBUG):exit()

def main():
  gpio_setup()
  GPIO.output(LED,1)
  while True:
    if(DEBUG):print("Waiting for &gt;3sec button press")
    if GPIO.input(SHTDWN_BTN)==False:
       doShutdown()
    time.sleep(1)

try:
  main()
finally:
  GPIO.cleanup()
  print("Closed Everything. END")
#End</pre></div><p>To get this script to run automatically (once we have tested it), we can place the script in <code class="literal">~/bin</code> (we can use <code class="literal">cp</code> instead of <code class="literal">mv</code> if we just want to copy it) and add it to <code class="literal">crontab</code> with the following code:</p><div><pre class="programlisting">mkdir ~/bin
mv shtdwn.py ~/bin/shtdwn.py 
crontab –e</pre></div><p>At the end of the file, we add the following code:</p><div><pre class="programlisting">@reboot sudo python3 ~/bin/shtdwn.py</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec114"/>How it works…</h2></div></div></div><p>This time, when we set up the GPIO pin, we define the pin connected to the shutdown button as an input and the pin connected to the LED as an output. We turn the LED on to indicate that the system is running.</p><p>By setting the <code class="literal">DEBUG</code> flag to <code class="literal">True</code>, we can test the functionality of our script without causing an actual shutdown (by reading the terminal messages); we just need to ensure to set <code class="literal">DEBUG</code> to <code class="literal">False</code> when using the script for real.</p><p>We enter a <code class="literal">while</code> loop and check every second to see whether the GPIO pin is set to <code class="literal">LOW</code> (the switch has been pressed); if so, we enter the <code class="literal">doShutdown()</code> function.</p><p>The program will wait for 3 seconds and then test again to see whether the button is still being pressed. If the button is no longer being pressed, we return to the previous <code class="literal">while</code> loop. However, if it is still being pressed after 3 seconds, the program will flash the LED and trigger the shutdown (also providing an audio warning using <code class="literal">flite</code>).</p><p>When we are happy with how the script is operating, we can disable the <code class="literal">DEBUG</code> flag (by setting it to <code class="literal">False</code>) and add the script to <code class="literal">crontab</code>. Crontab is a special program that runs in the background and allows us to schedule (at specific times, dates, or periodically) programs and actions when the system is started (<code class="literal">@reboot</code>). This allows the script to be started automatically every time the Raspberry Pi is powered up. When we press and hold the shutdown button for more than 3 seconds, it safely shuts down the system and enters a low power state (the LED switches off just before this, indicating it is safe to remove the power shortly after). To restart the Raspberry Pi, we briefly remove the power; this will restart the system, and the LED will light up when the Raspberry Pi has loaded.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec115"/>There's more…</h2></div></div></div><p>We can extend this example further using the reset header by adding extra functionality and making use of additional GPIO connections (if available).</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec37"/>Resetting and rebooting Raspberry Pi</h3></div></div></div><p>The Raspberry Pi has holes for mounting a reset header (marked <strong>RUN</strong> on the Raspberry Pi 2 / 3 and <strong>P6</strong> on the Raspberry Pi 1 Model B Rev 2 and Model As). The reset pin allows the device to be reset using a button rather than removing the micro USB connector each time to cycle the power:</p><div><img alt="Resetting and rebooting Raspberry Pi" src="img/6623OT_06_018.jpg"/><div><p>Raspberry Pi reset headers – on the left, Raspberry Pi Model A/B (Rev2), and on the right, Raspberry Pi 2 </p></div></div><p>To make use of it, you will need to solder a wire or pin header to the Raspberry Pi and connect a button to it (or briefly touch a wire between the two holes each time). Alternatively, we can extend our previous circuit, as shown in the following diagram:</p><div><img alt="Resetting and rebooting Raspberry Pi" src="img/6623OT_06_019.jpg"/><div><p>The controlled shutdown circuit layout and reset button</p></div></div><p>We can add this extra button to our circuit, which can be connected to the reset header (this is the hole nearest the middle on the Raspberry Pi 2 or closest to the edge on other models). This pin, when temporarily pulled low by connecting to ground (such as the hole next to it or by another ground point such as pin 6 of the GPIO header), will reset the Raspberry Pi and allow it to boot up again following a shutdown.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec38"/>Adding extra functions</h3></div></div></div><p>Since we now have the script monitoring the shutdown button all the time, we can add extra buttons/switches/jumpers to be monitored at the same time. This will allow us to trigger specific programs or set up particular states just by changing the inputs. The following example allows us to easily switch between automatic DHCP networking (the default networking setup) and using a direct IP address, as used in the <em>Networking directly to a laptop or computer</em> recipe of <a class="link" href="ch01.html" title="Chapter 1. Getting Started with a Raspberry Pi Computer">Chapter 1</a>, <em>Getting Started with a Raspberry Pi Computer</em>, for direct LAN connections.</p><p>Add the following components to the previous circuit:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A 470-ohm resistor</li><li class="listitem" style="list-style-type: disc">Two pin headers with a jumper connector (or optionally a switch)</li><li class="listitem" style="list-style-type: disc">Breadboarding wire (solid core)</li></ul></div><p>After adding the previous components, our controlled shutdown circuit now looks as follows:</p><div><img alt="Adding extra functions" src="img/6623OT_06_020.jpg"/><div><p>The controlled shutdown circuit layout, reset button, and jumper pins</p></div></div><p>In the previous <a class="indexterm" id="id360"/>script, we add an additional input to detect the status of the <code class="literal">LAN_SWA</code> pin (the jumper pins we added to the circuit) using the following code:</p><div><pre class="programlisting">LAN_SWA = 11    #2</pre></div><p>Ensure that it is set up as an input (with a pull-up resistor) in the <code class="literal">gpio_setup()</code> function using the following code:</p><div><pre class="programlisting">  GPIO.setup(LAN_SWA,GPIO.IN,pull_up_down=GPIO.PUD_UP)</pre></div><p>Add a new function to switch between the LAN modes, and read out the new IP address. The <code class="literal">doChangeLAN()</code> function checks if the status of the <code class="literal">LAN_SWA</code> pin has changed since the last call, and if so, it sets the network adaptor to DHCP or sets the direct LAN settings accordingly (and uses <code class="literal">flite</code> to speak the new IP setting if available). Finally, the LAN being set for direct <a class="indexterm" id="id361"/>connection causes the LED to flash slowly while that mode is active. Use the following code to do so:</p><div><pre class="programlisting">def doChangeLAN(direct):
  if(DEBUG):print("Direct LAN: %s" % direct)
  if GPIO.input(LAN_SWA) and direct==True:
    if(DEBUG):print("LAN Switch OFF")
    cmd="sudo dhclient eth0"
    direct=False
    GPIO.output(LED,1)
  elif GPIO.input(LAN_SWA)==False and direct==False:
    if(DEBUG):print("LAN Switch ON")
    cmd="sudo ifconfig eth0 169.254.69.69"
    direct=True
  else:
    return direct
  if(DEBUG==False):os.system(cmd)
  if(SNDON):os.system("hostname -I | flite")
  return direct</pre></div><p>Add another function, <code class="literal">flashled()</code>, which will just toggle the state of the LED each time it is called. The code for this function is as follows:</p><div><pre class="programlisting">def flashled(ledon):
  if ledon:
    ledon=False
  else:
    ledon=True
  GPIO.output(LED,ledon)
  return ledon</pre></div><p>Finally, we adjust the main loop to also call <code class="literal">doChangeLAN()</code> and use the result to decide whether we call <code class="literal">flashled()</code> using <code class="literal">ledon</code> to keep track of the LED's previous state each time. The <code class="literal">main()</code> function should now be updated as follows:</p><div><pre class="programlisting">def main():
  gpio_setup()
  GPIO.output(LED,1)
  directlan=False
  ledon=True
  while True:
    if(DEBUG):print("Waiting for &gt;3sec button press")
    if GPIO.input(SHTDWN_BTN)==False:
       doShutdown()
    directlan= doChangeLAN(directlan)
    if directlan:
      flashled(ledon)
    time.sleep(1)</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>The GPIO keypad input</h1></div></div></div><p>We have seen how we can monitor inputs on the GPIO to launch applications and control the Raspberry Pi; however, sometimes we need to control third-party programs. Using the <code class="literal">uInput</code> library, we<a class="indexterm" id="id362"/> can emulate key<a class="indexterm" id="id363"/> presses from a keyboard (or even mouse movement) to control any program, using our own custom hardware.</p><p>For more<a class="indexterm" id="id364"/> information about using <code class="literal">uInput</code>, visit <a class="ulink" href="http://tjjr.fi/sw/python-uinput/">http://tjjr.fi/sw/python-uinput/</a>.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec116"/>Getting ready</h2></div></div></div><p>Perform the following steps to install <code class="literal">uInput</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">First, we need to download <code class="literal">uInput</code>.<p>You will need to download the <code class="literal">uInput</code> Python library from Github (~50 KB) using the following commands:</p><div><pre class="programlisting">
<strong>wget https://github.com/tuomasjjrasanen/python-uinput/archive/master.zip</strong>
<strong>unzip master.zip</strong>
</pre></div><p>The library will unzip to a directory called <code class="literal">python-uinput-master</code>.</p><p>Once completed, you can remove the ZIP file using the following command:</p><div><pre class="programlisting">
<strong>rm master.zip</strong>
</pre></div></li><li class="listitem">Install the required packages (if you have installed them already, the <code class="literal">apt-get</code> command will ignore them) using the following commands:<div><pre class="programlisting">
<strong>sudo apt-get install python3-setuptools python3-dev</strong>
<strong>sudo apt-get install libudev-dev</strong>
</pre></div></li><li class="listitem">Compile and install <code class="literal">uInput</code> using the following commands:<div><pre class="programlisting">
<strong>cd python-uinput-master</strong>
<strong>sudo python3 setup.py install</strong>
</pre></div></li><li class="listitem">Finally, we load the new <code class="literal">uinput</code> kernel module using the following command:<div><pre class="programlisting">
<strong>sudo modprobe uinput</strong>
</pre></div><p>To ensure it is loaded on startup, we can add <code class="literal">uinput</code> to the <code class="literal">modules</code> file using the following command:</p><div><pre class="programlisting">
<strong>sudo nano /etc/modules</strong>
</pre></div><p>Put <code class="literal">uinput</code> on a new line in the file and save it (<em>Ctrl</em> + <em>X</em>,<em>Y</em>).</p></li><li class="listitem">Create<a class="indexterm" id="id365"/> the following <a class="indexterm" id="id366"/>circuit using the following equipment:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Breadboard (half-sized or larger)</li><li class="listitem" style="list-style-type: disc">7 x Dupont female to male patch wires</li><li class="listitem" style="list-style-type: disc">Six push buttons</li><li class="listitem" style="list-style-type: disc">6 x 470-ohm resistors</li><li class="listitem" style="list-style-type: disc">Breadboarding wire (solid core)</li></ul></div><div><img alt="Getting ready" src="img/6623OT_06_021.jpg"/><div><p>GPIO keypad circuit layout</p></div></div><p>The keypad circuit can also be built into a permanent circuit by soldering the components into a Vero prototype board (also known as a stripboard), as shown in the following image:</p><div><img alt="Getting ready" src="img/6623OT_06_022.jpg"/><div><p>GPIO keypad Pi hardware module</p></div></div><div><div><h3 class="title"><a id="note54"/>Note</h3><p>This circuit is available as a solder-yourself kit from <a class="ulink" href="http://PiHardware.com">PiHardware.com</a>.</p></div></div></li><li class="listitem">Connect<a class="indexterm" id="id367"/> the circuit to <a class="indexterm" id="id368"/>the Raspberry Pi GPIO pins as follows:<div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>Button</p>
</th><th style="text-align: left" valign="bottom">
<p>GPIO pin</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>GND</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>6</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>v</p>
</td><td style="text-align: left" valign="top">
<p>B_DOWN</p>
</td><td style="text-align: left" valign="top">
<p>22</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>&lt;</p>
</td><td style="text-align: left" valign="top">
<p>B_LEFT</p>
</td><td style="text-align: left" valign="top">
<p>18</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>^</p>
</td><td style="text-align: left" valign="top">
<p>B_UP</p>
</td><td style="text-align: left" valign="top">
<p>15</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>&gt;</p>
</td><td style="text-align: left" valign="top">
<p>B_RIGHT</p>
</td><td style="text-align: left" valign="top">
<p>13</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>B_1</p>
</td><td style="text-align: left" valign="top">
<p>11</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>B_2</p>
</td><td style="text-align: left" valign="top">
<p>7</p>
</td></tr></tbody></table></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec117"/>How to do it…</h2></div></div></div><p>Create<a class="indexterm" id="id369"/> a <code class="literal">gpiokeys.py</code> script as<a class="indexterm" id="id370"/> follows:</p><div><pre class="programlisting">#!/usr/bin/python3
#gpiokeys.py
import time
import RPi.GPIO as GPIO
import uinput

#HARDWARE SETUP
# GPIO
# 2[==G=====&lt;=V==]26[=======]40
# 1[===2=1&gt;^=====]25[=======]39
B_DOWN  = 22    #V
B_LEFT  = 18   #&lt;
B_UP    = 15   #^
B_RIGHT = 13   #&gt;
B_1  = 11   #1
B_2  = 7   #2

DEBUG=True
BTN = [B_UP,B_DOWN,B_LEFT,B_RIGHT,B_1,B_2]
MSG = ["UP","DOWN","LEFT","RIGHT","1","2"]

#Setup the DPad module pins and pull-ups
def dpad_setup():
  #Set up the wiring
  GPIO.setmode(GPIO.BOARD)
  # Setup BTN Ports as INPUTS
  for val in BTN:
    # set up GPIO input with pull-up control
    #(pull_up_down can be:
    #    PUD_OFF, PUD_UP or PUD_DOWN, default PUD_OFF)
    GPIO.setup(val, GPIO.IN, pull_up_down=GPIO.PUD_UP)

def main():
  #Setup uinput
  events = (uinput.KEY_UP,uinput.KEY_DOWN,uinput.KEY_LEFT,
           uinput.KEY_RIGHT,uinput.KEY_ENTER,uinput.KEY_ENTER)
  device = uinput.Device(events)
  time.sleep(2) # seconds
  dpad_setup()
  print("DPad Ready!")

  btn_state=[False,False,False,False,False,False]
  key_state=[False,False,False,False,False,False]
  while True:
    #Catch all the buttons pressed before pressing the related keys
    for idx, val in enumerate(BTN):
      if GPIO.input(val) == False:
        btn_state[idx]=True
      else:
        btn_state[idx]=False

    #Perform the button presses/releases (but only change state once)
    for idx, val in enumerate(btn_state):
      if val == True and key_state[idx] == False:
        if DEBUG:print (str(val) + ":" + MSG[idx])
        device.emit(events[idx], 1) # Press.
        key_state[idx]=True
      elif val == False and key_state[idx] == True:
        if DEBUG:print (str(val) + ":!" + MSG[idx])
        device.emit(events[idx], 0) # Release.
        key_state[idx]=False

    time.sleep(.1)
    
try:
  main()
finally:
  GPIO.cleanup()
#End</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec118"/>How it works…</h2></div></div></div><p>First, we<a class="indexterm" id="id371"/> import <code class="literal">uinput</code> and define the <a class="indexterm" id="id372"/>wiring of the keypad buttons. For each of the buttons in <code class="literal">BTN</code>, we enable them as inputs with internal pull-ups enabled.</p><p>Next, we set up <code class="literal">uinput</code>, defining the keys we want to emulate and adding them to the <code class="literal">uinput.Device()</code> function. We wait a few seconds to allow <code class="literal">uinput</code> to initialize, set the initial button and key states, and start our <code class="literal">main</code> loop.</p><p>The <code class="literal">main</code> loop is split into two sections: the first part checks through the buttons and records the states in <code class="literal">btn_state</code>, and the second part compares the <code class="literal">btn_state</code> with the current <code class="literal">key_state</code> array. This way, we can detect a change in <code class="literal">btn_state</code> and call <code class="literal">device.emit()</code> to toggle the state of the key.</p><p>To allow us to run this script in the background, we can run it with <code class="literal">&amp;</code> as shown in the following command:</p><div><pre class="programlisting">
<strong>sudo python3 gpiokeys.py &amp;</strong>
</pre></div><div><div><h3 class="title"><a id="note55"/>Note</h3><p>The <code class="literal">&amp;</code> character allows the command to run in the background, so we can continue with the command line to run other programs. You can use <code class="literal">fg</code> to bring it back to the foreground, or <code class="literal">%1</code>, <code class="literal">%2</code>, and so on if you have several commands running. Use <code class="literal">jobs</code> to get a list.</p><p>You can even put a process/program on hold to get to the command prompt by pressing <em>Ctrl</em> + <em>Z</em> and then resume it with <code class="literal">bg</code> (which will let it run in the background).</p><p>You can test the keys using the game created in the <em>Creating an overhead scrolling game</em> recipe in <a class="link" href="ch04.html" title="Chapter 4. Creating Games and Graphics">Chapter 4</a>, <em>Creating Games and Graphics</em>, which you can now control using your GPIO directional pad. Don't forget that if you are connecting to the Raspberry Pi remotely, any key presses will only be active on the locally connected screen.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec119"/>There's more…</h2></div></div></div><p>We can do<a class="indexterm" id="id373"/> more using <code class="literal">uinput</code> to<a class="indexterm" id="id374"/> provide hardware control for other programs, including those that require mouse input.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec39"/>Generating other key combinations</h3></div></div></div><p>You can create <a class="indexterm" id="id375"/>several different key mappings in your file to support different programs. For instance, the <code class="literal">events_z80</code> key mapping would be useful for a Spectrum Emulator such as <a class="indexterm" id="id376"/>
<strong>fuze</strong> (browse to <a class="ulink" href="http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi">http://raspi.tv/2012/how-to-install-fuse-zx-spectrum-emulator-on-raspberry-pi</a> for details). The <code class="literal">events_omx</code> key mappings are suitable for controlling video played through the OMX Player using the following command:</p><div><pre class="programlisting">
<strong>omxplayer filename.mp4</strong>
</pre></div><p>You can get a list of keys supported by <code class="literal">omxplayer</code> by using the <code class="literal">-k</code> parameter.</p><p>Replace the line that defines the <code class="literal">events</code> list with a new key mapping, and select different ones by assigning them to events using the following code:</p><div><pre class="programlisting">events_dpad = (uinput.KEY_UP,uinput.KEY_DOWN,uinput.KEY_LEFT,
              uinput.KEY_RIGHT,uinput.KEY_ENTER,uinput.KEY_ENTER)
events_z80 = (uinput.KEY_Q,uinput.KEY_A,uinput.KEY_O,
             uinput.KEY_P,uinput.KEY_M,uinput.KEY_ENTER)
events_omx = (uinput.KEY_EQUAL,uinput.KEY_MINUS,uinput.KEY_LEFT,
             uinput.KEY_RIGHT,uinput.KEY_P,uinput.KEY_Q)</pre></div><p>You can find <a class="indexterm" id="id377"/>all the <code class="literal">KEY</code> definitions in the <code class="literal">input.h</code> file; you can view it using the <code class="literal">less</code> command (press <em>Q</em> to exit) as shown in the following command:</p><div><pre class="programlisting">
<strong>less /usr/include/linux/input.h</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec40"/>Emulating mouse events</h3></div></div></div><p>The <code class="literal">uinput</code> library <a class="indexterm" id="id378"/>can emulate mouse and joystick events as well as keyboard presses. To use the buttons to simulate a mouse, we can adjust the script to use mouse events (as well as defining <code class="literal">mousemove</code> to set the step size of the movement) using the following code:</p><div><pre class="programlisting">MSG = ["M_UP","M_DOWN","M_LEFT","M_RIGHT","1","Enter"]
events_mouse=(uinput.REL_Y,uinput.REL_Y, uinput.REL_X,
             uinput.REL_X,uinput.BTN_LEFT,uinput.BTN_RIGHT)
mousemove=1</pre></div><p>We also need to modify the button handling to provide continuous movement, as we don't need to keep track of the state of the keys for the mouse. To do so, use the following code:</p><div><pre class="programlisting">    #Perform the button presses/releases
    #(but only change state once)
    for idx, val in enumerate(btn_state):
      if MSG[idx] == "M_UP" or MSG[idx] == "M_LEFT":
        state = -mousemove
      else:
        state = mousemove
      if val == True:
        device.emit(events[idx], state) # Press.
      elif val == False:
        device.emit(events[idx], 0) # Release.

    time.sleep(0.01)</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Multiplexed color LEDs</h1></div></div></div><p>The next<a class="indexterm" id="id379"/> example in this chapter demonstrates that some seemingly simple hardware can produce some impressive results if controlled with software. We return to using some RGB LEDs that are wired so that we only need to use eight GPIO pins to control the red, green, and blue elements of five RGB LEDs using a method called <strong>hardware multiplexing</strong> (see the <em>Hardware multiplexing</em> subsection<a class="indexterm" id="id380"/> in the <em>There's more…</em> section of this recipe).</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec120"/>Getting ready</h2></div></div></div><p>You will<a class="indexterm" id="id381"/> need the RGB LED module shown in the following image:</p><div><img alt="Getting ready" src="img/6623OT_06_023.jpg"/><div><p>The RGB LED module from PiHardware.com</p></div></div><p>As you can see in the preceding image, the RGB LED module from <a class="ulink" href="http://PiHardware.com">PiHardware.com</a> comes with GPIO pins and a Dupont female to female cable for connecting it. Although there are two sets of pins labelled 1 to 5, only one side needs to be connected.</p><p>Alternatively, you can recreate your own with the following circuit using five common cathode RGB LEDs, 3 x 470-ohm resistors, and a Vero prototype board (or large breadboard). The circuit will look as shown in the following diagram:</p><div><img alt="Getting ready" src="img/6623OT_06_024.jpg"/><div><p>Circuit diagram for the RGB LED module</p></div></div><div><div><h3 class="title"><a id="note56"/>Note</h3><p>Strictly speaking, we should use 15 resistors in this circuit (one for each RGB LED element), which will avoid interference from LEDs sharing the same resistor and would also prolong the life of the LEDs themselves if switched on together. However, there is only a slight advantage, particularly since we intend to drive each RGB LED independently of the other four to achieve multicolor effects.</p></div></div><p>You will <a class="indexterm" id="id382"/>need to connect the circuit to the Raspberry Pi GPIO header as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>RGB LED</p>
</th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>1</p>
</th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>2</p>
</th><th style="text-align: left" valign="bottom">
<p>3</p>
</th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom">
<p>4</p>
</th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th><th style="text-align: left" valign="bottom"> </th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<strong>Rpi GPIO Pin</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>4</p>
</td><td style="text-align: left" valign="top">
<p>6</p>
</td><td style="text-align: left" valign="top">
<p>8</p>
</td><td style="text-align: left" valign="top">
<p>10</p>
</td><td style="text-align: left" valign="top">
<p>12</p>
</td><td style="text-align: left" valign="top">
<p>14</p>
</td><td style="text-align: left" valign="top">
<p>16</p>
</td><td style="text-align: left" valign="top">
<p>18</p>
</td><td style="text-align: left" valign="top">
<p>20</p>
</td><td style="text-align: left" valign="top">
<p>22</p>
</td><td style="text-align: left" valign="top">
<p>24</p>
</td><td style="text-align: left" valign="top">
<p>26</p>
</td><td style="text-align: left" valign="top">
<p>28</p>
</td><td style="text-align: left" valign="top">
<p>30</p>
</td><td style="text-align: left" valign="top">
<p>32</p>
</td><td style="text-align: left" valign="top">
<p>34</p>
</td><td style="text-align: left" valign="top">
<p>36</p>
</td><td style="text-align: left" valign="top">
<p>38</p>
</td><td style="text-align: left" valign="top">
<p>40</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>Rpi GPIO Pin</strong>
</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top">
<p>7</p>
</td><td style="text-align: left" valign="top">
<p>9</p>
</td><td style="text-align: left" valign="top">
<p>11</p>
</td><td style="text-align: left" valign="top">
<p>13</p>
</td><td style="text-align: left" valign="top">
<p>15</p>
</td><td style="text-align: left" valign="top">
<p>17</p>
</td><td style="text-align: left" valign="top">
<p>19</p>
</td><td style="text-align: left" valign="top">
<p>21</p>
</td><td style="text-align: left" valign="top">
<p>23</p>
</td><td style="text-align: left" valign="top">
<p>25</p>
</td><td style="text-align: left" valign="top">
<p>27</p>
</td><td style="text-align: left" valign="top">
<p>29</p>
</td><td style="text-align: left" valign="top">
<p>31</p>
</td><td style="text-align: left" valign="top">
<p>33</p>
</td><td style="text-align: left" valign="top">
<p>35</p>
</td><td style="text-align: left" valign="top">
<p>37</p>
</td><td style="text-align: left" valign="top">
<p>39</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<strong>RGB LED</strong>
</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>5</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top">
<p>R</p>
</td><td style="text-align: left" valign="top">
<p>G</p>
</td><td style="text-align: left" valign="top">
<p>B</p>
</td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec121"/>How to do it…</h2></div></div></div><p>Create the <code class="literal">rgbled.py</code> script and perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Import all the required modules and define values to be used with the help of the following code:<div><pre class="programlisting">#!/usr/bin/python3
#rgbled.py
import time
import RPi.GPIO as GPIO

#Setup Active states
#Common Cathode RGB-LEDs (Cathode=Active Low)
LED_ENABLE = 0; LED_DISABLE = 1
RGB_ENABLE = 1; RGB_DISABLE = 0
#HARDWARE SETUP
# GPIO
# 2[=====1=23=4==]26[=======]40
# 1[===5=RGB=====]25[=======]39
#LED CONFIG - Set GPIO Ports
LED1 = 12; LED2 = 16; LED3 = 18; LED4 = 22; LED5 = 7
LED = [LED1,LED2,LED3,LED4,LED5]
RGB_RED = 11; RGB_GREEN = 13; RGB_BLUE = 15
RGB = [RGB_RED,RGB_GREEN,RGB_BLUE]
#Mixed Colors
RGB_CYAN = [RGB_GREEN,RGB_BLUE]
RGB_MAGENTA = [RGB_RED,RGB_BLUE]
RGB_YELLOW = [RGB_RED,RGB_GREEN]
RGB_WHITE = [RGB_RED,RGB_GREEN,RGB_BLUE]
RGB_LIST = [RGB_RED,RGB_GREEN,RGB_BLUE,RGB_CYAN,
            RGB_MAGENTA,RGB_YELLOW,RGB_WHITE]</pre></div></li><li class="listitem">Define <a class="indexterm" id="id383"/>functions to set up the GPIO pins using the following code:<div><pre class="programlisting">def led_setup():
  '''Setup the RGB-LED module pins and state.'''
  #Set up the wiring
  GPIO.setmode(GPIO.BOARD)
  # Setup Ports
  for val in LED:
    GPIO.setup(val, GPIO.OUT)
  for val in RGB:
    GPIO.setup(val, GPIO.OUT)
  led_clear()</pre></div></li><li class="listitem">Define our utility functions to help control the LEDs using the following code:<div><pre class="programlisting">def led_gpiocontrol(pins,state):
  '''This function will control the state of
  a single or multiple pins in a list.'''
  #determine if "pins" is a single integer or not
  if isinstance(pins,int):
    #Single integer - reference directly
    GPIO.output(pins,state)
  else:
    #if not, then cycle through the "pins" list
    for i in pins:
      GPIO.output(i,state)

def led_activate(led,color):
  '''Enable the selected led(s) and set the required color(s)
  Will accept single or multiple values'''
  #Enable led
  led_gpiocontrol(led,LED_ENABLE)
  #Enable color
  led_gpiocontrol(color,RGB_ENABLE)

def led_deactivate(led,color):
  '''Deactivate the selected led(s) and set the required
  color(s) will accept single or multiple values'''
  #Disable led
  led_gpiocontrol(led,LED_DISABLE)
  #Disable color
  led_gpiocontrol(color,RGB_DISABLE)
  
def led_time(led, color, timeon):
  '''Switch on the led and color for the timeon period'''
  led_activate(led,color)
  time.sleep(timeon)
  led_deactivate(led,color)

def led_clear():
  '''Set the pins to default state.'''
  for val in LED:
    GPIO.output(val, LED_DISABLE)
  for val in RGB:
    GPIO.output(val, RGB_DISABLE)

def led_cleanup():
  '''Reset pins to default state and release GPIO'''
  led_clear()
  GPIO.cleanup()</pre></div></li><li class="listitem">Create a test function to demonstrate the functionality of the module:<div><pre class="programlisting">def main():
  '''Directly run test function.
  This function will run if the file is executed directly'''
  led_setup()
  led_time(LED1,RGB_RED,5)
  led_time(LED2,RGB_GREEN,5)
  led_time(LED3,RGB_BLUE,5)
  led_time(LED,RGB_MAGENTA,2)
  led_time(LED,RGB_YELLOW,2)
  led_time(LED,RGB_CYAN,2) 

if __name__=='__main__':
  try:
    main()
  finally:
    led_cleanup()
#End</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec122"/>How it works…</h2></div></div></div><p>To start with, we<a class="indexterm" id="id384"/> define the hardware setup by defining the states required to <strong>Enable</strong> and <strong>Disable</strong> the LED depending on the type of RGB LED (common cathode) used. If you are using a common anode device, just reverse the <strong>Enable</strong>/<strong>Disable</strong> states.</p><p>Next, we define the GPIO mapping to the pins to match the wiring we did previously.</p><p>We also define some basic color combinations by combining red, green, and/or blue together, as shown in the following diagram:</p><div><img alt="How it works…" src="img/6623OT_06_025.jpg"/><div><p>LED color combinations</p></div></div><p>We define a series of useful functions, the first being <code class="literal">led_setup()</code>, which will set the GPIO numbering to <code class="literal">GPIO.BOARD</code> and define all the pins used to be outputs. We also call a function named <code class="literal">led_clear()</code>, which will set the pins to the default state with all the pins disabled.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>This means the LED pins, 1-5 (the common cathode on each LED), are set to <code class="literal">HIGH</code>, while the RGB pins (the separate anodes for each color) are set to <code class="literal">LOW</code>.</p></div></div><p>We create a function called <code class="literal">led_gpiocontrol()</code> that will allow us to set the state of one or more pins. The <code class="literal">isinstance()</code> function allows us to test a value to see whether it matches a particular type (in this case, a single integer); then we can either set the state of that single pin or iterate through the list of pins and set each one.</p><p>Next, we define<a class="indexterm" id="id385"/> two functions, <code class="literal">led_activate()</code> and <code class="literal">led_deactivate()</code>, which will enable and disable the specified LED and color. Finally, we define <code class="literal">led_time()</code>, which will allow us to specify an LED, color, and time to switch it on for.</p><p>We also create <code class="literal">led_cleanup()</code> to reset the pins (and LEDs) to the default values and call <code class="literal">GPIO.cleanup()</code> to release the GPIO pins in use.</p><p>This script is intended to become a library file, so we will use the <code class="literal">if __name__=='__main__'</code> check to only run our test code when running the file directly:</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>By checking the value of <code class="literal">__name__</code>, we can determine whether the file was run directly (it will equal <code class="literal">__main__</code>) or whether it was imported by another Python script.</p><p>This allows us to define special test code that is only executed when we directly load and run the file. If we include this file as a module in another script, then this code will not be executed.</p><p>We have used this technique previously in the <em>There's more…</em> section in the <em>Working with text and strings</em> recipe of <a class="link" href="ch02.html" title="Chapter 2. Starting with Python Strings, Files, and Menus">Chapter 2</a>, <em>Starting with Python Strings, Files, and Menus</em>.</p><p>As before, we will use <code class="literal">try</code>/<code class="literal">finally</code> to allow us to always perform cleanup actions, even if we exit early.</p></div></div><p>To test the script, we will set the LEDs to light up in various colors one after another.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec123"/>There's more…</h2></div></div></div><p>We can create a few different colors by switching on one or more parts of the RGB LED at a time. However, with some clever programming, we can create a whole spectrum of colors. Also, we can display different colors on each LED, seemingly at the same time.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec41"/>Hardware multiplexing</h3></div></div></div><p>An LED requires <a class="indexterm" id="id386"/>a high voltage on the anode side and a lower voltage on the cathode side to light up. The RGB LEDs used in the circuit are common cathode, so we must apply a high voltage (3.3V) on the RGB pins and a low voltage (0V) on the cathode pin (wired to pins 1 to 5 for each of the LEDs).</p><p>The cathode and<a class="indexterm" id="id387"/> RGB pin states are as follows:</p><div><img alt="Hardware multiplexing" src="img/6623OT_06_026.jpg"/><div><p>Cathode and RGB pin states</p></div></div><p>Therefore, we can enable one or more of the RGB pins but still control which of the LEDs are lit. We enable the pins of the LEDs we want to light up and disable the ones we don't. This allows us to use far fewer pins than we would need to control each of the 15 RGB lines separately.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec42"/>Displaying random patterns</h3></div></div></div><p>We can add <a class="indexterm" id="id388"/>new functions to our library to produce different effects, such as generating random colors. The following function uses <code class="literal">randint()</code> to get a value between 1 and the number of colors. We ignore any values that are over the number of the available colors so that we can control how often the LEDs may be switched off. Perform the following steps to add the required functions:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">randint()</code> function from the <code class="literal">random</code> module to the <code class="literal">rgbled.py</code> script using the following code:<div><pre class="programlisting">from random import randint</pre></div></li><li class="listitem">Now add <code class="literal">led_rgbrandom()</code> using the following code:<div><pre class="programlisting">def led_rgbrandom(led,period,colors):
   ''' Light up the selected led, for period in seconds,
   in one of the possible colors. The colors can be
   1 to 3 for RGB, or 1-6 for RGB plus combinations,
   1-7 includes white. Anything over 7 will be set as
   OFF (larger the number more chance of OFF).''' 
  value = randint(1,colors)
  if value &lt; len(RGB_LIST):
    led_time(led,RGB_LIST[value-1],period)</pre></div></li><li class="listitem">Use the <a class="indexterm" id="id389"/>following commands in the <code class="literal">main()</code> function to create a series of flashing LEDs:<div><pre class="programlisting">  for i in range(20):
    for j in LED:
      #Select from all, plus OFF
      led_rgbrandom(j,0.1,20)</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec43"/>Mixing multiple colors</h3></div></div></div><p>Until now, we<a class="indexterm" id="id390"/> have only displayed a single color at a time on one or more of the LEDs. If you consider how the circuit is wired up, you might wonder how can we get one LED to display one color and another a different one at the same time? The simple answer is that we don't need to—we just do it quickly!</p><p>All we need to do is display one color at a time but change it very quickly back and forth, so fast the color looks like a mix of the two (or even a combination of the three red/green/blue LEDs). Fortunately, this is something that computers such as the Raspberry Pi can do very easily, even allowing us to combine the RGB elements to make multiple shades of colors across all five LEDs. Perform the following steps to mix the colors:</p><div><ol class="orderedlist arabic"><li class="listitem">Add combo color definitions to the top of the <code class="literal">rgbled.py</code> script, after the definition of the mixed colors, using the following code:<div><pre class="programlisting">#Combo Colors
RGB_AQUA = [RGB_CYAN,RGB_GREEN]
RGB_LBLUE = [RGB_CYAN,RGB_BLUE]
RGB_PINK = [RGB_MAGENTA,RGB_RED]
RGB_PURPLE = [RGB_MAGENTA,RGB_BLUE]
RGB_ORANGE = [RGB_YELLOW,RGB_RED]
RGB_LIME = [RGB_YELLOW,RGB_GREEN]
RGB_COLORS = [RGB_LIME,RGB_YELLOW,RGB_ORANGE,RGB_RED,
              RGB_PINK,RGB_MAGENTA,RGB_PURPLE,RGB_BLUE,
              RGB_LBLUE,RGB_CYAN,RGB_AQUA,RGB_GREEN]</pre></div><p>The preceding code will provide the combination of colors to create our shades, with <code class="literal">RGB_COLORS</code> providing a smooth progression through the shades.</p></li><li class="listitem">Next, we need to create a function called <code class="literal">led_combo()</code> to handle single or multiple colors. The code for the function will be as follows:<div><pre class="programlisting">def led_combo(pins,colors,period):
  #determine if "colors" is a single integer or not
  if isinstance(colors,int):
    #Single integer - reference directly
    led_time(pins,colors,period)
  else:
    #if not, then cycle through the "colors" list
    for i in colors:
      led_time(pins,i,period)</pre></div></li><li class="listitem">Now we<a class="indexterm" id="id391"/> can create a new script, <code class="literal">rgbledrainbow.py</code>, to make use of the new functions in our <code class="literal">rgbled.py</code> module. The <code class="literal">rgbledrainbow.py</code> script will be as follows:<div><pre class="programlisting">#!/usr/bin/python3
#rgbledrainbow.py
import time
import rgbled as RGBLED

def next_value(number,max):
  number = number % max
  return number

def main():
  print ("Setup the RGB module")
  RGBLED.led_setup()

  # Multiple LEDs with different Colors
  print ("Switch on Rainbow")
  led_num = 0
  col_num = 0
  for l in range(5):
    print ("Cycle LEDs")
    for k in range(100):
      #Set the starting point for the next set of colors
      col_num = next_value(col_num+1,len(RGBLED.RGB_COLORS))
      for i in range(20):  #cycle time
        for j in range(5): #led cycle
          led_num = next_value(j,len(RGBLED.LED))
          led_color = next_value(col_num+led_num,
                                 len(RGBLED.RGB_COLORS))
          RGBLED.led_combo(RGBLED.LED[led_num],
                           RGBLED.RGB_COLORS[led_color],0.001)

    print ("Cycle COLORs")        
    for k in range(100):
      #Set the next color
      col_num = next_value(col_num+1,len(RGBLED.RGB_COLORS))
      for i in range(20): #cycle time
        for j in range(5): #led cycle
          led_num = next_value(j,len(RGBLED.LED))
          RGBLED.led_combo(RGBLED.LED[led_num],
                           RGBLED.RGB_COLORS[col_num],0.001)
  print ("Finished")

if __name__=='__main__':
  try:
    main()
  finally:
    RGBLED.led_cleanup()
#End</pre></div></li></ol></div><p>The <code class="literal">main()</code> function <a class="indexterm" id="id392"/>will first cycle through the LEDs, setting each color from the <code class="literal">RGB_COLORS</code> array on all the LEDs. Then, it will cycle through the colors, creating a rainbow effect over the LEDs:</p><div><img alt="Mixing multiple colors" src="img/6623OT_06_027.jpg"/><div><p>Cycle through multiple colors on the five RGB LEDs</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Writing messages using Persistence of Vision</h1></div></div></div><p>
<strong>Persistence of Vision (POV)</strong> displays can produce an almost magical effect, displaying images in the<a class="indexterm" id="id393"/> air by moving a line of LEDs back and <a class="indexterm" id="id394"/>forth very quickly or around in <a class="indexterm" id="id395"/>circles. The effect works because your eyes are unable to adjust fast enough to separate out the individual flashes of light, and so you observe a merged image (the message or picture being displayed).</p><div><img alt="Writing messages using Persistence of Vision" src="img/6623OT_06_028.jpg"/><div><p>Persistence of vision using RGB LEDs</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec124"/>Getting ready</h2></div></div></div><p>This recipe also uses the RGB LED kit used in the previous recipe; you will also need the following additional items:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Breadboard (half-sized or larger)</li><li class="listitem" style="list-style-type: disc">2 x Dupont female to male patch wires</li><li class="listitem" style="list-style-type: disc">Tilt switch (ball-bearing type is suitable)</li><li class="listitem" style="list-style-type: disc">1 x 470 ohm resistor (R_Protect)</li><li class="listitem" style="list-style-type: disc">Breadboarding wire (solid core)</li></ul></div><p>The tilt switch should be added to the RGB LED (as described in the <em>Getting ready</em> section of the <em>Multiplexed color LEDs</em> recipe). The tilt switch is wired as follows:</p><div><img alt="Getting ready" src="img/6623OT_06_029.jpg"/><div><p>Tilt switch is connected to GPIO Input (GPIO pin 24) and Gnd (GPIO pin 6)</p></div></div><p>To<a class="indexterm" id="id396"/> reproduce the POV image, you will<a class="indexterm" id="id397"/> need to be able to quickly move the LEDs and tilt switch back and forth. Note how the tilt switch is mounted angled to the side, so the switch will open when moved to the left. It is recommended that the hardware is mounted onto a length of wood or similar. You can even use a portable USB battery pack along with a Wi-Fi dongle to power and control the Raspberry Pi through a remote connection (see <a class="link" href="ch01.html" title="Chapter 1. Getting Started with a Raspberry Pi Computer">Chapter 1</a>, <em>Getting Started with a Raspberry Pi – Connecting Remotely to the Raspberry Pi over the Network using SSH (and X11 Forwarding)</em>, for details):</p><div><img alt="Getting ready" src="img/6623OT_06_030.jpg"/><div><p>Persistence of Vision hardware setup</p></div></div><p>You <a class="indexterm" id="id398"/>will also need the completed <code class="literal">rgbled.py</code> file, which we will extend further in the <em>How to do it</em>… section.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec125"/>How to do it…</h2></div></div></div><p>Create a<a class="indexterm" id="id399"/> script called <code class="literal">tilt.py</code> to report the state of the tilt switch:</p><div><pre class="programlisting">#!/usr/bin/python3
#tilt.py
import RPi.GPIO as GPIO
#HARDWARE SETUP
# GPIO
# 2[===========T=]26[=======]40
# 1[=============]25[=======]39
#Tilt Config
TILT_SW = 24

def tilt_setup():
  #Setup the wiring
  GPIO.setmode(GPIO.BOARD)
  #Setup Ports
  GPIO.setup(TILT_SW,GPIO.IN,pull_up_down=GPIO.PUD_UP)

def tilt_moving():
  #Report the state of the Tilt Switch
  return GPIO.input(TILT_SW)

def main():
  import time
  tilt_setup()
  while True:
    print("TILT %s"% (GPIO.input(TILT_SW)))
    time.sleep(0.1)

if __name__=='__main__':
  try:
    main()
  finally:
    GPIO.cleanup()
    print("Closed Everything. END")
#End</pre></div><p>You can<a class="indexterm" id="id400"/> test the script by running it <a class="indexterm" id="id401"/>directly with the following command:</p><div><pre class="programlisting">
<strong>sudo python3 tilt.py</strong>
</pre></div><p>Add the following <code class="literal">rgbled_pov()</code> function to the <code class="literal">rgbled.py</code> script we created previously; this will allow us to display a single line of our image:</p><div><pre class="programlisting">def rgbled_pov(led_pattern,color,ontime):
  '''Disable all the LEDs and re-enable the LED pattern in the required color'''
  led_deactivate(LED,RGB)
  for led_num,col_num in enumerate(led_pattern):
    if col_num &gt;= 1:
      led_activate(LED[led_num],color)
  time.sleep(ontime)</pre></div><p>We will now create the following file, called <code class="literal">rgbledmessage.py</code>, to perform the required actions to display our message. First we will import the modules used, the updated <code class="literal">rgbled</code> module, the new <code class="literal">tilt</code> module, and the python <code class="literal">os</code> module. Initially, we set <code class="literal">DEBUG</code> to <code class="literal">True</code> so the Python terminal will display additional information while the script is running:</p><div><pre class="programlisting">#!/usr/bin/python3
# rgbledmessage.py
import rgbled as RGBLED
import tilt as TILT
import os

DEBUG = True</pre></div><p>Add a <code class="literal">readMessageFile()</code> function to read the content of the <code class="literal">letters.txt</code> file and then add <code class="literal">processFileContent()</code> to <a class="indexterm" id="id402"/>generate a <strong>Python dictionary</strong> of the LED patterns for each letter:</p><div><pre class="programlisting">def readMessageFile(filename):
  assert os.path.exists(filename), 'Cannot find the message file: %s' % (filename)
  try:
    with open(filename, 'r') as theFile:
    fileContent = theFile.readlines()
  except IOError:
    print("Unable to open %s" % (filename))
  if DEBUG:print ("File Content START:")
  if DEBUG:print (fileContent)
  if DEBUG:print ("File Content END")
  dictionary = processFileContent(fileContent)
  return dictionary 

def processFileContent(content):
  letterIndex = [] #Will contain a list of letters stored in the file
  letterList = []  #Will contain a list of letter formats
  letterFormat = [] #Will contain the format of each letter
  firstLetter = True
  nextLetter = False
  LETTERDIC={}
  #Process each line that was in the file
  for line in content:
    # Ignore the # as comments
    if '#' in line:
      if DEBUG:print ("Comment: %s"%line)
    #Check for " in the line = index name  
    elif '"' in line:
      nextLetter = True
      line = line.replace('"','') #Remove " characters
      LETTER=line.rstrip()
      if DEBUG:print ("Index: %s"%line)
    #Remaining lines are formatting codes
    else:
      #Skip firstLetter until complete
      if firstLetter:
        firstLetter = False
        nextLetter = False
        lastLetter = LETTER
      #Move to next letter if needed
      if nextLetter:
        nextLetter = False
        LETTERDIC[lastLetter]=letterFormat[:]
        letterFormat[:] = []
        lastLetter = LETTER
      #Save the format data
      values = line.rstrip().split(' ')
      row = []
      for val in values:
        row.append(int(val))
      letterFormat.append(row)
  LETTERDIC[lastLetter]=letterFormat[:]
  #Show letter patterns for debugging
  if DEBUG:print ("LETTERDIC: %s" %LETTERDIC)
  if DEBUG:print ("C: %s"%LETTERDIC['C'])
  if DEBUG:print ("O: %s"%LETTERDIC['O'])
  return LETTERDIC</pre></div><p>Add a <code class="literal">createBuffer()</code> function, which will convert a message into a series of LED patterns for <a class="indexterm" id="id403"/>each letter (assuming the letter is <a class="indexterm" id="id404"/>defined by the <code class="literal">letters.txt</code> file):</p><div><pre class="programlisting">def createBuffer(message,dictionary):
  buffer=[]
  for letter in message:
    try:
      letterPattern=dictionary[letter]
    except KeyError:
      if DEBUG:print("Unknown letter %s: use _"%letter)
      letterPattern=dictionary['_']
    buffer=addLetter(letterPattern,buffer)
  if DEBUG:print("Buffer: %s"%buffer)
  return buffer

def addLetter(letter,buffer):
  for row in letter:
    buffer.append(row)
  buffer.append([0,0,0,0,0])
  buffer.append([0,0,0,0,0])
  return buffer</pre></div><p>Next, we define <code class="literal">displayBuffer()</code> to display the LED patterns using the <code class="literal">rgbled_pov()</code> function in the <code class="literal">rgbled</code> module:</p><div><pre class="programlisting">def displayBuffer(buffer):
  position=0
  while(1):
    if(TILT.tilt_moving()==False):
      position=0
    elif (position+1)&lt;len(buffer):
      position+=1
      if DEBUG:print("Pos:%s ROW:%s"%(position,buffer[position]))
    RGBLED.rgbled_pov(buffer[position],RGBLED.RGB_GREEN,0.001)
    RGBLED.rgbled_pov(buffer[position],RGBLED.RGB_BLUE,0.001)</pre></div><p>Finally, we create a <code class="literal">main()</code> function to perform each of the required steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Set up <a class="indexterm" id="id405"/>the hardware components (RGB LEDs and the tilt switch).</li><li class="listitem">Read the<a class="indexterm" id="id406"/> <code class="literal">letters.txt</code> file.</li><li class="listitem">Define the dictionary of LED letter patterns.</li><li class="listitem">Generate a buffer to represent the required message.</li><li class="listitem">Display the buffer using the <code class="literal">rgbled</code> module and control it with the <code class="literal">tilt</code> module:<div><pre class="programlisting">def main():
  RGBLED.led_setup()
  TILT.tilt_setup()
  dict=readMessageFile('letters.txt')
  buffer=createBuffer('_COOKBOOK_',dict)
  displayBuffer(buffer)
  
if __name__=='__main__':
  try:
    main()
  finally:
    RGBLED.led_cleanup()
    print("Closed Everything. END")
#End</pre></div></li></ol></div><p>Create the following file, called <code class="literal">letters.txt</code>, to define the LED patterns needed to display the example <code class="literal">'_COOKBOOK_'</code> message. Note, this file only needs to define a pattern for each unique letter or symbol in the message:</p><div><pre class="programlisting">#COOKBOOK
"C"
0 1 1 1 0
1 0 0 0 1
1 0 0 0 1
"O"
0 1 1 1 0
1 0 0 0 1
1 0 0 0 1
0 1 1 1 0
"K"
1 1 1 1 1
0 1 0 1 0
1 0 0 0 1
"B"
1 1 1 1 1
1 0 1 0 1
0 1 0 1 0
"_"
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec126"/>How it works…</h2></div></div></div><p>The first<a class="indexterm" id="id407"/> function, <code class="literal">readMessageFile()</code>, will open and read the contents of a given file (as we did previously<a class="indexterm" id="id408"/> in <a class="link" href="ch02.html" title="Chapter 2. Starting with Python Strings, Files, and Menus">Chapter 2</a>, <em>Starting with Python Strings, Files, and Menus</em>; see the <em>Using files and handling errors</em> recipe for more details). This will then use <code class="literal">processFileContent()</code> to return a Python <strong>dictionary</strong> containing corresponding patterns for the letters <a class="indexterm" id="id409"/>defined in the file provided. Each line in the file is processed, ignoring any line with a <code class="literal">#</code> character in and checking for <code class="literal">"</code> characters to indicate the name for the LED pattern that follows after. After the file has been processed, we end up with a Python dictionary that contains LED patterns for the <code class="literal">'_'</code>, <code class="literal">'C'</code>, <code class="literal">'B'</code>, <code class="literal">'K'</code> and <code class="literal">'O'</code> characters:</p><div><pre class="programlisting">'_': [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
'C': [[0, 1, 1, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]]
'B': [[1, 1, 1, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0]]
'K': [[1, 1, 1, 1, 1], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]
'O': [[0, 1, 1, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0]]</pre></div><p>Now that we have a selection of letters to choose from, we can create a sequence of LED patterns using the <code class="literal">createBuffer()</code> function. As the name suggests, the function will build up a buffer of LED patterns by looking up each letter in the message and adding the related pattern row by row. If a letter isn't found in the dictionary, then a space will be used instead.</p><p>Finally, we now have a list of LED patterns ready to display. To control when we start the sequence, we will use the TILT module and check the status of the tilt switch:</p><div><img alt="How it works…" src="img/6623OT_06_031.jpg"/><div><p>The tilt switch position when not moving (left) and moving (right)</p></div></div><p>The tilt <a class="indexterm" id="id410"/>switch consists of a small ball bearing<a class="indexterm" id="id411"/> enclosed in a hollow insulated cylinder; the connection between the two pins is closed when the ball is resting at the bottom of the cylinder. The tilt switch is open when the ball is moved to the other end of the cylinder, out of contact of the pins:</p><div><img alt="How it works…" src="img/6623OT_06_032.jpg"/><div><p>The tilt switch circuit, switch closed and switch open</p></div></div><p>The tilt switch circuit shown previously will allow GPIO pin 24 to be connected to the ground when the switch is closed, then if we read the pin it will return <code class="literal">False</code> when it is at rest. By setting the GPIO pin as an input and enabling the internal pull-up resistor, when the tilt switch is open it will report <code class="literal">True</code>.</p><p>If the tilt switch is open (reporting <code class="literal">True</code>) then we will assume the unit is being moved and begin displaying the LED sequences, incrementing the current position each time we display a row of the LED pattern. Just to make the pattern a little more colorful (just because we can!) we repeat each row in another color. As soon as the <code class="literal">TILT.tilt_moving()</code> function reports we have stopped moving or we are moving in the opposite direction, we will reset the current position, ready to start the whole pattern over again:</p><div><img alt="How it works…" src="img/6623OT_06_033.jpg"/><div><p>The message is displayed by the RGB LEDs – here using Green and Blue together</p></div></div><p>When the <a class="indexterm" id="id412"/>RGB LED module and tilt switch <a class="indexterm" id="id413"/>are moved back and forth, we should see the message displayed in the air!</p><p>Try experimenting with different color combinations, speeds, and arm waviness to see what effects you can produce. You could even create a similar setup mounted on a wheel to produce a continuous POV effect.</p></div></div></body></html>