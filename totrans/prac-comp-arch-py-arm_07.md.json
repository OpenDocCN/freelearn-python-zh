["```py\n\n        LDRL R0,60              @ Load R0 with the time factor, 60\n        .\n        CMP  R3,R5              @ Compare R3 and R5\n        BEQ  1                  @ If equal, jump to next-but-one instruction\n        ADD  R2,R2,4\n        SUB  R7,R1,R2\n```", "```py\n\nMinutes EQU  60                 @ Set up a constant\nTest    EQU  4\n.       LDRL R0,Minutes         @ Load R0 with the time factor\n.       CMP  R3,R5\n        BEQ  Next\n        ADD  R2,R2,Test\nNext    SUB  R7,R1,R2\n```", "```py\n\nsFile2 = [i.upper() for i in sFile1]          # Convert in to uppercase\nsFile3 = [i.split('@')[0] for i in sFile2]    # Remove comments\n```", "```py\n\nsFile = [i.upper() for i in sFile]            #\nsFile = [i.split('@')[0] for i in sFile]      #\n```", "```py\n\nsFile3 = [i.split('@')[0] for i in sFile2]    # Remove comments\n```", "```py\n\ntestCode = 'E://testCode.txt'\naltCode  = ['nop', 'NOP 5', 'add R1,R2','', 'LDR r1,[r2]', \\\n            'ldr r1,[R2]','\\n', 'BEQ test @www','\\n']\nx = input('For disk enter d, else any character ')\nif x == 'd':\n    with open(testCode, 'r') as source0:\n         source = source0.readlines()\n    source = [i.replace('\\n','') for i in source]\nelse:    source = altCode\nprint('Source code to test is',source)\nsFile0 = []\nfor i in range(0,len(source)):                # Process the source file in list sFile\n    t1 =  source[i].replace(',',' ')          # Replace comma with space\n    t2 =  t1.replace('[',' ')                 # Remove [ brackets\n    t3 =  t2.replace(']',' ')                 # Remove ] brackets\n    t4 =  t3.replace('  ',' ')                # Remove any double spaces\n    sFile0.append(t4)                         # Add result to source file\nsFile1= [i for i in sFile0 if i[-1:]!='\\n']   # Remove end-of-lines\nsFile2= [i.upper() for i in sFile1]           # All uppercase\nsFile3= [i.split('@')[0] for i in sFile2]     # Remove comments with @\nsFile4= [i.rstrip(' ') for i in sFile3 ]      # Remove trailing spaces\nsFile5= [i.lstrip(' ') for i in sFile4 ]      # Remove leading spaces\nsFile6=[i for i in sFile5 if i != '']         # Remove blank lines\nprint ('Post-processed output',  sFile6)\n```", "```py\n\nFor disk enter d, else any character d\nSource code to test is ['diskCode', 'b', 'add r1,r2,[r3]', '', 'ADD r3 @test', ' ', 'r2,,r3', ' ', 'gg']\nPost-processed output ['DISKCODE', 'B', 'ADD R1 R2 R3', 'ADD R3', 'R2 R3', 'GG']\n```", "```py\n\nFor disk enter d, else any character x\nSource code to test is ['nop', 'NOP 5', 'add R1,R2', '', 'LDR r1,[r2]', 'ldr r1,[R2]', '\\n', 'BEQ test @www', '\\n']\nPost-processed output ['NOP', 'NOP 5', 'ADD R1 R2', 'LDR R1 R2', 'LDR R1 R2', 'BEQ TEST']\n```", "```py\n\nADD  R1,R3,R7        @ Three operands (three registers)\nNOP                  @ No operands\nLDRL R4,27           @ Two operands (register and a literal value)\n```", "```py\n\ncodes = {'STOP':P, 'ADD':Q, 'LDRL':R}               # P, Q, R are variables\n```", "```py\n\n    if 'ADD' in codes:  # Test whether 'ADD' is a valid mnemonic in the dictionary\n```", "```py\n\n 'ADD': [3, 0b1101001, 'Addition', '07/05/2021', timesUsed]\n```", "```py\n\nP,Q,R,N = 1,2,3,4                                   # Set up dummy opcodes\nvalidCd = {'STOP':P, 'ADD':Q, 'LDRL':R, 'NOP':N}    # Dictionary of codes\nx = input('Please enter a code  ')                  # Request an opcode\nif x not in validCd:                                # Check dictionary for errors\n    print('Error! This is not valid')\nif x in validCd:                                    # Check for valid opcode\n    print('Valid op ', validCd.get(x))              # If found, read its value\n```", "```py\n\nsymbolTab = {'START':0}                              # Symbol table for labels\nfor i in range (0,len(sFile)):                       # Deal with equates\n    if len(sFile[i]) > 2 and sFile[i][1] == 'EQU':   # Is token 'EQU'?\n        symbolTab[sFile[i][0]] = sFile[i][2]         # If so, update table\nsFile = [i for i in sFile if i.count('EQU') == 0]    # Delete EQU from source\n```", "```py\n\nsFile = [i for i in sFile if i.count('EQU') == 0]\n```", "```py\n\nsFile=[['test','EQU','5'],['not','a','thing'],['xxx','EQU','88'], \\\n       ['ADD','r1','r2','r3']]\nprint('Source: ', sFile)\nsymbolTab = {}                                    # Creates empty symbol table\nfor i in range (0,len(sFile)):                    # Deal with equates e.g., PQR EQU 25\n    print('sFile[i]', sFile[i])\n    if len(sFile[i]) > 2 and sFile[i][1] == 'EQU':  # Is the second token 'EQU'?\n        print('key/val', sFile[i][0], sFile[i][2])  # Display key-value pair\n        symbolTab[sFile[i][0]] = sFile[i][2]        # Now update symbol table\nsFile = [i for i in sFile if i.count('EQU') == 0]   # Delete equates from source file\nprint('Symbol table: ', symbolTab)\nprint('Processed input: ',sFile)\n```", "```py\n\nSource [['test','EQU','5'],['not','a','thing'],['xxx','EQU','88'], ['ADD','r1','r2','r3']]\nsFile[i] ['test', 'EQU', '5']\nkey/val test 5\nsFile[i] ['not', 'a', 'thing']\nsFile[i] ['xxx', 'EQU', '88']\nkey/val xxx 88\nsFile[i] ['ADD', 'r1', 'r2', 'r3']\nSymbol table {'test': '5', 'xxx': '88'}\nProcessed input [['not', 'a', 'thing'], ['ADD', 'r1', 'r2', 'r3']]\n```", "```py\n\nsymbolTab.update({[sFile[i][0]]:sFile[i][2]})\n```", "```py\n\n      DEC  r1                                   @ Decrement r1\n      BEQ  NEXT1                                @ If result in r1 is 0, then jump to line NEXT1\n      INC  r2                                   @ If result not 0, increment r2\n      .\nNEXT1 .\n```", "```py\n\n1. for i in range(0,len(sFile)):                  # Add branch addresses to symbol tab\n2.     if sFile[i][0] not in codes:               # If first token not an opcode, it's a label\n3.        symbolTab.update({sFile[i][0]:str(i)})  # Add pc value, i to sym tab as string\n4. print('\\nEquate and branch table\\n')           # Display symbol table\n5. for x,y in symbolTab.items():                  # Step through symbol table\n6.     print('{:<8}'.format(x),y)\n```", "```py\n\n2\\. if sFile[i][0] not in codes:\n```", "```py\n\n3\\. symbolTab.update({sFile[i][0]:str(i)})                  # i is the pc value\n```", "```py\n\n4\\. print('\\nEquate and branch table\\n')                    # Display symbol table\n5\\. for x,y in symbolTab.items(): print('{:<8}'.format(x),y) # Step through symbol table\n```", "```py\n\n5\\. for x,y in symbolTab.items():\n```", "```py\n\nLDRL r0,24                   @ Decimal numeric value\nLDRL r0,0xF2C3               @ Hexadecimal numeric value\nLDRL r0,$F2C3                @ Hexadecimal numeric value (alternative representation)\nLDRL r0,%00110101            @ Binary numeric value\nLDRL r0,0b00110101           @ Binary numeric value (alternative representation)\nLDRL r0,-234                 @ Negative decimal numeric value\nLDRL r0,ALAN2                @ Symbolic value requiring symbol table look-up\n```", "```py\n\nfor i in range(0,len(sFile)):                     # Assembly loop reads instruction\n    opCode,label,literal,predicate = [],[],[],[]  # Initialize opcode, label, literal, predicate\n    rD, rS1, rS2  = 0, 0, 0                       # Clear register-select fields to zeros\n    if sFile[i][0] in codes: opCode = sFile[i][0]   # If first token is a valid opcode, get it\n    else:                    opCode = sFile[i][1]   # If not, then opcode is second token\n    if (sFile[i][0] in codes) and (len(sFile[i]) > 1): # If opcode valid and length > 1\n        predicate = sFile[i][1:]\n    else:\n        if len(sFile[i]) > 2: predicate = sFile[i][2:] \\\n                                              # Lines with a label longer than 2 tokens\n    form = codes.get(opCode)                  # Use mnemonic to read instruction format\n    if form[0] & 0b1000 == 0b1000:            # Bit 4 of format selects destination register rD\n    if predicate[0] in symbolTab:                 # If first token in symbol tab, it's a label\n            rD = int(symbolTab[predicate[0]][1:]) # If it is a label, then get its value\n```", "```py\n\n4.    if sFile[i][0] in codes: opcode = sFile[i][0] # If first token is a valid opcode, get it\n5.    else:                    opCode = sFile[i][1] # If not, then it's the second token\n```", "```py\n\n    if sFile[i][0] in symbolTab: label = sFile[i][0] # Get label\n```", "```py\n\n6\\. if (sFile[i][0] in codes) and (len(sFile[i])>1): # Get everything after opcode\n7.                        predicate = sFile[i][1:]  # Line with opcode\n8\\. else:\n9.    if len(sFile[i])>2: predicate = sFile[i][2:]  # If label and len > 2 tokens\n```", "```py\n\n7.          predicate = sFile[i][1:]     # The predicate is the second and following tokens\n9.          predicate = sFile[i][2:]     # The predicate is the third and following tokens\n```", "```py\n\n10\\. form = codes.get(opCode)                    # Use opcode to read instruction format\n11\\. if form[0] & 0b1000 == 0b1000:              # Bit 3 of format selects destination reg rD\n12.     if predicate[0] in symbolTab:           # Check whether first token is symbol table\n13.        rD =int(symbolTab[predicate[0]][1:]) # If it's a label, then get its value\n```", "```py\n\nbinaryCode  = format[0]\nformatStyle = format[1]\n```", "```py\n\nform = codes.get(opCode)                      # Use opcode to read type of instruction\nif form[0] & 0b1000 == 0b1000:                # Bit 4 of format selects destination register rD\n    if predicate[0] in symbolTab:             # Check whether first token is sym tab\n          rD = int(symbolTab[predicate[0]][1:])  # If it is, then get its value\n    else: rD = int(predicate[0][1:])          # If it's not a label, get from the predicate\nif form[0] & 0b0100 == 0b0100:                # Bit 3 selects register source register 1, rS1\n    if predicate[1] in symbolTab:\n          rS1 = int(symbolTab[predicate[1]][1:])\n    else: rS1 = int(predicate[1][1:])\nif form[0] & 0b0010 == 0b0010:                # Bit 2 of format selects register rS1\n    if predicate[2] in symbolTab:\n          rS2 = int(symbolTab[predicate[2]][1:])\n    else: rS2 = int(predicate[2][1:])\nif form[0] & 0b0001 == 0b0001:                # Bit 1 of format indicates a literal\n    if predicate[-1] in symbolTab:            # If literal in symbol table, get it\n        predicate[-1] = symbolTab[predicate[-1]]\n    elif type(predicate[-1]) == 'int':                                # Integer\n        literal = str(literal)\n    elif predicate[-1][0]    == '%':                                  # Binary\n        literal=int(predicate[-1][1:],2) \n    elif predicate[-1][0:2]  == '0B':                                 # Binary \n        literal=int(predicate[-1][2:],2)\n    elif predicate[-1][0:1]  == '$':                                  # Hex\n        literal=int(predicate[-1][1:],16)\n    elif predicate[-1][0:2]  == '0X':                                 # Hex\n        literal=int(predicate[-1][2:],16)\n    elif predicate[-1].isnumeric():                                   # Decimal\n        literal=int(predicate[-1])\n    elif predicate[-1][0]    == '-':                                  # Negative\n        literal=(-int(predicate[-1][1:]))&0xFFFF\n    else:  literal = 0                                                # Default\n```", "```py\n\nif predicate[-1] in symbolTab:                 # If literal is in symbol table, look up value\n   predicate[-1] = symbolTab[predicate[-1]]    # Get its value from the symbol table\n```", "```py\n\nif type(predicate[-1])=='int': literal=str(literal) # Integer to string\n```", "```py\n\nif   predicate[-1][0]   == '%':  literal = int(predicate[-1][1:],2)\nelif predicate[-1][0:2  == '0B': literal = int(predicate[-1][2:],2)\nelif predicate[-1][0:1] == '$':  literal = int(predicate[-1][1:],16)\nelif predicate[-1][0:2] == '0X': literal = int(predicate[-1][2:],16)\nelif predicate[-1].isnumeric():  literal = int(predicate[-1])\n```", "```py\n\nlastToken = predicate[-1]              # Get the last token from the predicate\nprefix = lastToken[0:2]                # Get the first two characters of this token to test for '0X'\n```", "```py\n\ns2      = s2      << 16                # Shift source 2 16 places left\ns1      = s1      << 19                # Shift source 1 19 places left\ndestReg = destReg << 22                # Shift destination register 22 places left\nop      = op      << 25                # Shift opcode 25 places left\nbinCode = lit | s2 | s1 | destReg | op # Logical OR the fields\n```", "```py\n\nbinCode = lit | (s2 << 16) | (s1 << 19) | (destReg << 22)| (op << 25)\n```", "```py\n\ncodes = {'STOP':[0], 'LDRL':[3], 'STRL':[7]}\n```", "```py\n\nsFile = ['LDRL r2,1','LDRL r0,4','NOP','STRI r0,[r2]','LDRI r3,[r2]',   \\\n         'INC r3','ADDL r3,r3,2','NOP','DEC r3', 'BNE -2','DEC r3','STOP']\n                                            # Source program for testing\n# Simple CPU instruction interpreter. Direct instruction interpretation. 30 September 2022\\. V1.0\n# Class 0: no operand                   NOP\n# Class 1: literal                      BEQ  3\n# Class 2: register                     INC  r1\n# Class 3: register,literal             LDRL r1,5\n# Class 4: register,register,           MOV  r1,r2\n# Class 5: register,register,literal    ADDL r1,r2,5\n# Class 6: register,register,register   ADD  r1,r2,r3\n# Class 7: register,[register]          LDRI r1,[r2]\ncodes = {'NOP':[0],'STOP':[0],'BEQ':[1],'BNE':[1],'BRA':[1],  \\\n         'INC':[2],'DEC':[2],'CMPL':[3],'LDRL':[3],'MOV':[4],  \\\n         'CMP':[4],'SUBL':[5],'ADDL':[5],'ANDL':[5],'ADD':[6], \\\n         'SUB':[6], 'AND':[6],'LDRI':[7],'STRI':[7]}\nreg1  = {'r0':0,'r1':1,'r2':2,'r3':3}       # Legal registers\nreg2  = {'[r0]':0,'[r1]':1,'[r2]':2,'[r3]':3} # Legal pointer registers\nr = [0] * 4                                 # Four registers\nr[0],r[1],r[2],r[3] = 1,2,3,4               # Preset registers for testing\nm  = [0] * 8                                # Eight memory locations\npc = 0                                      # Program counter initialize to 0\ngo = 1                                      # go is the run control (1 to run)\nz  = 0                                      # z is the zero flag. Set/cleared by SUB, DEC, CMP\nwhile go == 1:                              # Repeat execute fetch and execute loop\n    thisLine = sFile[pc]                    # Get current instruction\n    pc = pc + 1                             # Increment pc\n    pcOld = pc                              # Remember pc value for this cycle\n    temp = thisLine.replace(',',' ')        # Remove commas: ADD r1,r2,r3 to ADD r1 r2 r3\n```", "```py\n    tokens = temp.split(' ')                # Tokenize:  ADD r1 r2 r3 to ['ADD','r1','r2','r3']\n```", "```py\n\n    mnemonic = tokens[0]                  # Extract first token, the mnemonic\n    opClass = codes[mnemonic][0]          # Extract instruction class\n                                          # Process the current instruction and analyze it\n    rD,rDval,rS1,rS1val,rS2,rS2val,lit, rPnt,rPntV = 0,0,0,0,0,0,0,0,0 \n                                          # Clear all parameters\n    if opClass in [0]: pass               # If class 0, nothing to be done (simple opcode only)\n    if opClass in [2,3,4,5,6,7,8]:        # Look for ops with destination register rD\n        rD     = reg1[tokens[1]]          # Get token 1 and use it to get register number as rD\n        rDval  = r[rD]                    # Get contents of register rD\n    if opClass in [4,5,6]:                # Look at instructions with first source register rS1\n        rS1    = reg1[tokens[2]]          # Get rS1 register number and then contents\n        rS1val = r[rS1]\n    if opClass in [6]:                    # If class 6, it's got three registers. Extract rS2\n        rS2    = reg1[tokens[3]]          # Get rS2 and rS2val\n        rS2val = r[rS2]\n    if opClass in [1,3,5,8]:              # The literal is the last element in instructions\n        lit    = int(tokens[-1])          # Get the literal\n    if opClass in [7]:                    # Class 7 involves register indirect addressing\n        rPnt   = reg2[tokens[2]]          # Get the pointer (register) and value of the pointer\n        rPntV  = r[rPnt]                  # Get the register number\n    if mnemonic == 'STOP':                # Now execute instructions. If STOP, clear go and exit\n        go = 0\n        print('Program terminated')\n```", "```py\n\n    elif mnemonic == 'NOP':  pass         # NOP does nothing. Just drop to end of loop\n    elif mnemonic == 'INC': r[rD] = rDval + 1  # Increment: add 1 to destination register\n    elif mnemonic == 'DEC':               # Decrement: subtract 1 from register and update z bit\n        z = 0\n        r[rD] = rDval - 1\n        if r[rD] == 0: z = 1\n    elif mnemonic == 'BRA':               # Unconditional branch\n        pc = pc + lit - 1\n    elif mnemonic == 'BEQ':               # Conditional branch on zero\n        if z == 1: pc = pc + lit - 1\n    elif mnemonic == 'BNE':               # Conditional branch on not zero\n        if z == 0: pc = pc + lit - 1\n    elif mnemonic == 'ADD': r[rD]=rS1val+rS2val # Add\n    elif mnemonic == 'ADDL': r[rD] = rS1val+lit # Add literal\n    elif mnemonic == 'SUB':                     # Subtract and set/clear z\n        r[rD] = rS1val - rS2val\n        z = 0\n        if r[rD] == 0: z = 1\n    elif mnemonic == 'SUBL':                    # Subtract literal\n        r[rD] = rS1val - lit\n        z = 0\n        if r[rD] == 0: z = 1\n    elif mnemonic == 'CMPL':                    # Compare literal\n        diff = rDval - lit\n        z = 0\n        if diff == 0 : z = 1\n    elif mnemonic == 'CMP':                     # Compare\n        diff = rDval - rS1val\n        z = 0\n        if diff == 0: z = 1\n    elif mnemonic == 'MOV':  r[rD] = rS1val     # Move, load, and store operations\n    elif mnemonic == 'LDRL': r[rD] = lit\n    elif mnemonic == 'LDRI': r[rD] = m[rPntV]\n    elif mnemonic == 'STRI': m[rPntV] = rDval\n    regs = ' '.join('%02x' % b for b in r)      # Format memory locations hex\n    mem  = ' '.join('%02x' % b for b in m)      # Format registers hex\n    print('pc =','{:<3}'.format(pcOld), '{:<14}'.format(thisLine), \\\n          'Regs =',regs, 'Mem =',mem, 'z =', z)\n    x = input('>>> ')               # Request keyboard input before dealing with next instruction\n```", "```py\n\npc = 1   LDRL r2,1     Regs = 01 02 01 04 Mem = 00 00 00 00 00 00 00 00 z = 0\npc = 2   LDRL r0,4     Regs = 04 02 01 04 Mem = 00 00 00 00 00 00 00 00 z = 0\npc = 3   NOP           Regs = 04 02 01 04 Mem = 00 00 00 00 00 00 00 00 z = 0\npc = 4   STRI r0,[r2]  Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 5   LDRI r3,[r2]  Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 6   INC r3        Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 7   ADDL r3,r3,2  Regs = 04 02 01 07 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 8   NOP           Regs = 04 02 01 07 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 9   DEC r3        Regs = 04 02 01 06 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 10  BNE -2        Regs = 04 02 01 06 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 8   NOP           Regs = 04 02 01 06 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 9   DEC r3        Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 10  BNE -2        Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 8   NOP           Regs = 04 02 01 05 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 9   DEC r3        Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 10  BNE -2        Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 8   NOP           Regs = 04 02 01 04 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 9   DEC r3        Regs = 04 02 01 03 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 10  BNE -2        Regs = 04 02 01 03 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 8   NOP           Regs = 04 02 01 03 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 9   DEC r3        Regs = 04 02 01 02 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 10  BNE -2        Regs = 04 02 01 02 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 8   NOP           Regs = 04 02 01 02 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 9   DEC r3        Regs = 04 02 01 01 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 10  BNE -2        Regs = 04 02 01 01 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 8   NOP           Regs = 04 02 01 01 Mem = 00 04 00 00 00 00 00 00 z = 0\npc = 9   DEC r3        Regs = 04 02 01 00 Mem = 00 04 00 00 00 00 00 00 z = 1\npc = 10  BNE -2        Regs = 04 02 01 00 Mem = 00 04 00 00 00 00 00 00 z = 1\npc = 11  DEC r3        Regs = 04 02 01 -1 Mem = 00 04 00 00 00 00 00 00 z = 0\nProgram terminated\npc = 12  STOP          Regs = 04 02 01 -1 Mem = 00 04 00 00 00 00 00 00 z = 0\n```", "```py\n\n@ test trace modes\n    nop\n    nop\n    inc r1\n    NOP\n    dec r2\n    ldrl r6,0b10101010\n    bra abc\n    nop\n    inc R7\n    nop\nabc ldrl r3,$ABCD\n    nop\n    inc r3\n    INC r4\n    nop\n    nop\n    inc r5\n    END!\n```", "```py\n\n  >>>  trace\n0      NOP           PC= 0 z=0 n=0 c=0 R 0000 0000 0000 0000 0000 0000 0000 0000\n>>>3 jump 3 instructions (silent trace)\n4      DEC R2        PC= 4 z=0 n=1 c=1 R 0000 0001 ffff 0000 0000 0000 0000 0000\n>>>b jump to branch (silent mode up to next branch/rts/jsr)\n6      BRA ABC       PC= 6 z=0 n=1 c=1 R 0000 0001 ffff 0000 0000 0000 00aa 0000\n>>>  trace Here's the sample run\n10 ABC LDRL R3 $ABCD PC=10 z=0 n=1 c=1 R 0000 0001 ffff abcd 0000 0000 00aa 0000\n>>>  trace\n11     NOP           PC=11 z=0 n=1 c=1 R 0000 0001 ffff abcd 0000 0000 00aa 0000\n>>>4 jump 4\n16     INC R5        PC=16 z=0 n=0 c=1 R 0000 0001 ffff abce 0001 0001 00aa 0000\n>>>  trace\n17     END!          PC=17 z=0 n=0 c=1 R 0000 0001 ffff abce 0001 0001 00aa 0000\n```", "```py\n\nmyProg = 'testException1.txt'                      # Name of default program\ntry:                                               # Check whether this file exists\n    with open(myProg,'r') as prgN:                 # If it's there, open it and read it\n        myFile = prgN.readlines()\nexcept:                                            # Call exception if file not there\n    altProg = input('Enter source file name: ')    # Request a filename\n    with open(altProg,'r') as prgN:                # Open the user file\n        myFile = prgN.readlines()\nprint('File loaded: ', myFile)\n```", "```py\n\n>>> %Run testTry.py\nFile loaded:  ['   @ Test exception file\\n', ' nop\\n', ' nop\\n', ' inc\\n', ' end!']\n```", "```py\n\n>>> %Run testTry.py\nEnter source file name: testException2.txt\nFile loaded:  ['   @ Test exception file TWO\\n', ' dec r1\\n', ' nop\\n', ' inc r2\\n', ' end!']\n```", "```py\n\nprgN = 'E://ArchitectureWithPython//' + prgN + '.txt'\n```", "```py\n\n### TC1 computer simulator and assembler. Version of 11 September 2022\n''' This is the table of instructions for reference and is not part of the program code\n00 00000  stop operation            STOP             00 00000 000 000 000 0  0000\n00 00001  no operation              NOP              00 00001 000 000 000 0  0000\n00 00010  get character from keyboard  GET  r0         00 00010 rrr 000 000 0  1000\n00 00011  get character from keyboard  RND  r0         00 00011 rrr 000 000 L  1001\n00 00100  swap bytes in register        SWAP r0         00 00100 rrr 000 000 0  1000\n00 01000  print hex value in register     PRT r0          00 01000 rrr 000 000 0  1000\n00 11111  terminate program         END!            00 11111 000 000 000 0  0000\n01 00000  load register from register     MOVE r0,r1      01 00000 rrr aaa 000 0  1100\n01 00001  load register from memory   LDRM r0,L       01 00001 rrr 000 000 L  1001\n01 00010  load register with literal       LDRL r0,L       01 00010 rrr 000 000 L  1001\n01 00011  load register indirect        LDRI r0,[r1,L]  01 00011 rrr aaa 000 L  1101\n01 00100  store register in memory      STRM r0,L       01 00100 rrr 000 000 L  1001\n01 00101  store register indirect       STRI r0,[r1,L]  01 00101 rrr aaa 000 L  1101\n10 00000  add register to register      ADD  r0,r1,r2   10 00000 rrr aaa bbb 0  1110\n10 00001  add literal to register        ADDL r0,r1,L    10 00001 rrr aaa 000 L  1101\n10 00010  subtract register from register SUB  r0,r1,r2   10 00010 rrr aaa bbb 0  1110\n10 00011  subtract literal from register    SUBL r0,r1,L    10 00011 rrr aaa 000 L  1101\n10 00100  multiply register by register   MUL  r0,r1,r2   10 00100 rrr aaa bbb 0  1110\n10 00101  multiply literal by register     MULL r0,r1,L    10 00101 rrr aaa 000 L  1101\n10 00110  divide register by register     DIV  r0,r1,r2   10 00110 rrr aaa bbb 0  1110\n10 00111  divide register by literal       DIVL r0,r1,L    10 00111 rrr aaa 000 L  1101\n10 01000  mod register by register      MOD  r0,r1,r2   10 01000 rrr aaa bbb 0  1110\n10 01001  mod register by literal        MODL r0,r1,L    10 01001 rrr aaa 000 L  1101\n10 01010  AND register to register      AND  r0,r1,r2   10 01000 rrr aaa bbb 0  1110\n10 01011  AND register to literal         ANDL r0,r1,L    10 01001 rrr aaa 000 L  1101\n10 01100  OR register to register        OR   r0,r1,r2   10 01010 rrr aaa bbb 0  1110\n10 01101  NOR register to literal        ORL  r0,r1,L    10 01011 rrr aaa 000 L  1101\n10 01110  EOR register to register       OR   r0,r1,r2   10 01010 rrr aaa bbb 0  1110\n10 01111  EOR register to literal       ORL  r0,r1,L    10 01011 rrr aaa 000 L  1101\n10 10000  NOT register              NOT  r0         10 10000 rrr 000 000 0  1000\n10 10010  increment register          INC  r0          10 10010 rrr 000 000 0  1000\n10 10011  decrement register         DEC  r0         10 10011 rrr 000 000 0  1000\n10 10100  compare register with register CMP  r0,r1      10 10100 rrr aaa 000 0  1100\n10 10101  compare register with literal   CMPL r0,L       10 10101 rrr 000 000 L  1001\n10 10110  add with carry            ADC              10 10110 rrr aaa bbb 0  1110\n10 10111  subtract with borrow        SBC             10 10111 rrr aaa bbb 0  1110\n10 11000  logical shift left           LSL  r0,L       10 10000 rrr 000 000 0  1001\n10 11001  logical shift left literal       LSLL r0,L       10 10000 rrr 000 000 L  1001\n10 11010  logical shift right          LSR  r0,L       10 10001 rrr 000 000 0  1001\n10 11011  logical shift right literal      LSRL r0,L       10 10001 rrr 000 000 L  1001\n10 11100  rotate left               ROL  r0,L        10 10010 rrr 000 000 0  1001\n10 11101  rotate left literal           ROLL r0,L        10 10010 rrr 000 000 L  1001\n10 11110  rotate right              ROR  r0,L        10 10010 rrr 000 000 0  1001\n10 11111  rotate right literal          RORL r0,L        10 10010 rrr 000 000 L  1001\n11 00000  branch unconditionally       BRA  L           11 00000 000 000 000 L  0001\n11 00001  branch on zero           BEQ  L           11 00001 000 000 000 L  0001\n11 00010  branch on not zero         BNE  L           11 00010 000 000 000 L  0001\n11 00011  branch on minus           BMI  L           11 00011 000 000 000 L  0001\n11 00100  branch to subroutine       BSR  L           11 00100 000 000 000 L  0001\n11 00101  return from subroutine       RTS              11 00101 000 000 000 0  0000\n11 00110  decrement & branch on not zero DBNE r0,L       11 00110 rrr 000 000 L  1001\n11 00111  decrement & branch on zero  DBEQ r0,L        11 00111 rrr 000 000 L  1001\n11 01000  push register on stack       PUSH r0           11 01000 rrr 000 000 0  1000\n11 01001  pull register off stack       PULL r0           11 01001 rrr 000 000 0  1000\n'''\nimport random                       # Get library for random number generator\ndef alu(fun,a,b):                   # Alu defines operation and a and b are inputs\n   global c,n,z                     # Status flags are global and are set up here\n    if   fun == 'ADD': s = a + b\n    elif fun == 'SUB': s = a - b\n    elif fun == 'MUL': s = a * b\n    elif fun == 'DIV': s = a // b   # Floor division returns an integer result\n    elif fun == 'MOD': s = a % b    # Modulus operation gives remainder: 12 % 5 = 2\n    elif fun == 'AND': s = a & b    # Logic functions\n    elif fun == 'OR':  s = a | b\n    elif fun == 'EOR': s = a & b\n    elif fun == 'NOT': s = ~a\n    elif fun == 'ADC': s = a + b + c # Add with carry\n    elif fun == 'SBC': s = a - b – c # Subtract with borrow\n    c,n,z = 0,0,0                    # Clear flags before recalculating them\n    if s & 0xFFFF == 0: z = 1        # Calculate the c, n, and z flags\n    if s & 0x8000 != 0: n = 1        # Negative if most sig bit 15 is 1\n    if s & 0xFFFF != 0: c = 1        # Carry set if bit 16 is 1\n    return (s & 0xFFFF)              # Return the result constrained to 16 bits\n```", "```py\n\ndef shift(dir,mode,p,q):   # Shifter: performs shifts and rotates. dir = left/right, mode = logical/rotate\n    global z,n,c                    # Make flag bits global. Note v-bit not implemented\n    if dir == 0:                    # dir = 0 for left shift, 1 for right shift\n        for i in range (0,q):       # Perform q left shifts on p\n            sign = (0x8000 & p) >> 15            # Sign bit\n            p = (p << 1) & 0xFFFF                # Shift p left one place\n            if mode == 1:p = (p & 0xFFFE) | sign # For rotate left, add in bit shifted out\n    else:                                        # dir = 1 for right shift\n        for i in range (0,q):                    # Perform q right shifts\n            bitOut = 0x0001 & p                  # Save lsb shifted out\n            sign = (0x8000 & p) >> 15            # Get sign-bit for ASR\n            p = p >> 1                           # Shift p one place right\n            if mode == 1:p = (p&0x7FFF)|(bitOut<<15) # If mode = 1, insert bit rotated out\n            if mode == 2:p = (p&0x7FFF)|(sign << 15) # If mode = 2, propagate sign bit\n    z,c,n = 0,0,0                                # Clear all flags\n    if p == 0:          z = 1                    # Set z if p is zero\n    if p & 0x8000 != 0: n = 1                    # Set n-bit if p = 1\n    if (dir == 0) and (sign == 1):   c = 1       # Set carry if left shift and sign 1\n    if (dir == 1) and (bitOut == 1): c = 1  # Set carry bit if right shift and bit moved out = 1\n    return(0xFFFF & p)               # Ensure output is 16 bits wide\ndef listingP():                      # Function to perform listing and formatting of source code\n    global listing                   # Listing contains the formatted source code\n    listing = [0]*128                # Create formatted listing file for display\n    if debugLevel > 1: print('Source assembly code listing ')\n    for i in range (0,len(sFile)):        # Step through the program\n        if sFile[i][0] in codes:          # Is first token in opcodes (no label)?\n            i2 =  (' ').join(sFile[i])    # Convert tokens into string for printing\n            i1 = ''                       # Dummy string i1 represents missing label\n        else:\n            i2 = (' ').join(sFile[i][1:]) # If first token not opcode, it's a label\n            i1 = sFile[i][0]              # i1 is the label (first token)\n        listing[i] = '{:<3}'.format(i) + '{:<7}'.format(i1) + \\\n                     '{:<10}'.format(i2)  # Create listing table entry\n        if debugLevel  > 1:               # If debug  = 1, don't print source program\n            print('{:<3}'.format(i),'{:<7}'.format(i1),'{:<10}'.format(i2)) \\\n                                          # print: pc, label, opcode\n    return()\n```", "```py\n\ndef getLit(litV):                                  # Extract a literal\n    if  litV[0]    == '#': litV = litV[1:]         # Some systems prefix literal with '#\n    if  litV in symbolTab:                         # Look in sym tab and get value if there\n        literal = symbolTab[litV]                  # Read the symbol value as a string\n        literal = int(literal)                     # Convert string into integer\n    elif  litV[0]   == '%': literal = int(litV[1:],2)\n                                                   # If first char is %, convert to integer\n    elif  litV[0:2] == '0B':literal = int(litV[2:],2)\n                                                   # If prefix 0B, convert binary to integer\n    elif  litV[0:2] == '0X':literal = int(litV[2:],16)\n                                                   # If 0x, convert hex string to integer\n    elif  litV[0:1] == '$': literal = int(litV[1:],16)\n                                                   # If $, convert hex string to integer\n    elif  litV[0]   == '-': literal = (-int(litV[1:]))&0xFFFF \n                                                   # Convert 2's complement to int\n    elif  litV.isnumeric():  literal = int(litV)\n                                                   # If decimal string, convert to integer\n    else:                    literal = 0           # Default value 0 (default value)\n```", "```py\n    return(literal)\n```", "```py\n\ndef printStatus():                             # Display machine status (registers, memory)\n    text = '{:<27}'.format(listing[pcOld])     # Format instruction for listing\n    m = mem[0:8]                               # Get the first 8 memory locations\n    m1 = ' '.join('%04x' % b for b in m)       # Format memory location's hex\n    m2 = ' '.join('%04x' % b for b in r)       # Format register's hex\n    print(text, 'PC =', '{:>2}'.format(pcOld) , 'z =',z,'n =',n,'c =',c, m1,\\\n    'Registers ', m2)\n    if debugLevel == 5:\n        print('Stack =', ' '.join('%04x' % b for b in stack), \\\n        'Stack pointer =', sp)\n    return()\nprint('TC1 CPU simulator 11 September 2022 ')  # Print the opening banner\ndebugLevel = input('Input debug level 1 - 5: ') # Ask for debugging level\nif debugLevel.isnumeric():                     # If debug level is an integer, get it\n    debugLevel = int(debugLevel)               # Convert text to integer\nelse: debugLevel = 1                           # Else, set default value to level 1\nif debugLevel not in range (1,6): debugLevel = 1 # Ensure range 1 to 5\nprint()                                        # New line\n```", "```py\n\nglobal c,n,z                                   # Processor flags (global variables)\nsymbolTab = {'START':0}             # Create symbol table for labels + equates with dummy entry\nc,n,z = 0,0,0                                  # Initialize flags: carry, negative, zero\nsFile = ['']* 128                              # sFile holds the source text\nmemP  = [0] * 128                              # Create program memory of 128 locations\nmem   = [0] * 128                              # Create data memory of 128 locations\nstack = [0] * 16                               # Create a stack for return addresses\n# codes is a dictionary of instructions {'mnemonic':(x.y)} where x is the instruction operand format, and y the opcode\ncodes = {                                                            \\\n        'STOP':(0,0),  'NOP' :(0,1),  'GET' :(8,2),  'RND' : (9,3),  \\\n        'SWAP':(8,4),  'SEC' :(0,5),  'PRT' :(8,8),  'END!':(0,31),  \\\n        'MOVE':(12,32),'LDRM':(9,33), 'LDRL':(9,34), 'LDRI':(13,35), \\\n        'STRM':(9,36), 'STRI':(13,37),'ADD' :(14,64),'ADDL':(13,65), \\\n        'SUB' :(14,66),'SUBL':(13,67),'MUL' :(14,68),'MULL':(13,69), \\\n        'DIV' :(14,70),'DIVL':(13,71),'MOD' :(14,72),'MODL':(13,73), \\\n        'AND' :(14,74),'ANDL':(13,75),'OR'  :(14,76),'ORL' :(13,77), \\\n        'EOR' :(14,78),'EORL':(13,79),'NOT' :(8,80), 'INC' :(8,82),  \\\n        'DEC' :(8,83), 'CMP' :(12,84),'CMPL':(9,85), 'LSL' :(12,88), \\\n        'LSLL':(9,89), 'LSR' :(12,90),'LSRL':(9,91), 'ROL' :(12,92), \\\n        'ROLL':(9,93), 'ROR' :(12,94),'RORL':(9,95), 'ADC':(14,102), \\\n        'SBC':(14,103),'BRA' :(1,96), 'BEQ' :(1,97), 'BNE' :(1,98),  \\\n        'BMI' :(1,99), 'BSR' :(1,100),'RTS' :(0,101),'DBNE':(9,102), \\\n        'DBEQ':(9,103),'PUSH':(8,104),'PULL':(8,105) }\nbranchGroup = ['BRA', 'BEQ', 'BNE', 'BSR', 'RTS'] # Operations responsible for flow control\n```", "```py\n\n# Read the input source code text file and format it. This uses a default file and a user file if default is absent\nprgN = 'E://ArchitectureWithPython//C_2_test.txt' # prgN = program name: default test file\ntry:                                              # Check whether this file exists\n    with open(prgN,'r') as prgN:                  # If it's there, open it and read it\n        prgN = prgN.readlines()\nexcept:                                           # Call exception program if not there\n    prgN = input('Enter source file name: ')    # Request a filename (no extension needed)\n    prgN = 'E://ArchitectureWithPython//' + prgN + '.txt' # Build filename\n    with open(prgN,'r') as prgN:                  # Open user file\n        prgN = prgN.readlines()                   # Read it\nfor i in range (0,len(prgN)):                     # Scan source prgN and copy it to sFile\n    sFile[i] = prgN[i]                            # Copy prgN line to sFile line\n    if 'END!' in prgN[i]: break                   # If END! found, then stop copying\n             # Format source code\nsFile = [i.split('@')[0] for i in sFile]          # But first, remove comments     ###\nfor i in range(0,len(sFile)):                     # Repeat: scan input file line by line\n    sFile[i] = sFile[i].strip()                   # Remove leading/trailing spaces and eol\n    sFile[i] = sFile[i].replace(',',' ')          # Allow use of commas or spaces\n    sFile[i] = sFile[i].replace('[','')           # Remove left bracket\n    sFile[i] = sFile[i].replace(']','')       # Remove right bracket and convert [R4] to R4\n    while '  ' in sFile[i]:                       # Remove multiple spaces\n        sFile[i] = sFile[i].replace('  ', ' ')\nsFile = [i.upper() for i in sFile]                # Convert to uppercase\n```", "```py\nsFile = [i.split(' ') for i in sFile if i != '']  # Split the tokens into list items\n```", "```py\n\n                                    # Remove assembler directives from source code\nfor i in range (0,len(sFile)):      # Deal with equates of the form PQR EQU 25\n    if len(sFile[i]) > 2 and sFile[i][1] == 'EQU': # If line is > 2 tokens and second is EQU\n        symbolTab[sFile[i][0]] = sFile[i][2]       # Put third token EQU in symbol table\nsFile = [i for i in sFile if i.count('EQU') == 0]  # Remove all lines with 'EQU'\n                                    # Debug: 1 none, 2 source, 3 symbol tab, 4 Decode i, 5 stack\nlistingP()                          # List the source code if debug level is 1\n```", "```py\n\n                                    # Look for labels and add to symbol table\nfor i in range(0,len(sFile)):       # Add branch addresses to symbol table\n    if sFile[i][0] not in codes:    # If first token not opcode, then it is a label\n        symbolTab.update({sFile[i][0]:str(i)})     # Add it to the symbol table\nif debugLevel > 2:                  # Display symbol table if debug level 2\n    print('\\nEquate and branch table\\n')           # Display the symbol table\n    for x,y in symbolTab.items(): print('{:<8}'.format(x),y) \\\n                                             # Step through the symbol table dictionary\n    print('\\n')\n            # Assemble source code in sFile\nif debugLevel > 3: print('Decoded instructions')   # If debug level 4/5, print decoded ops\nfor pcA in range(0,len(sFile)):              # ASSEMBLY: pcA = prog counter in assembly\n    opCode, label, literal, predicate = [], [], 0, []   # Initialize variables\n                                             # Instruction = label + opcode + predicate\n    rD, rS1, rS2  = 0, 0, 0                  # Clear all register-select fields\n    thisOp = sFile[pcA]                      # Get current instruction, thisOPp, in text form\n                                             # Instruction: label + opcode or opcode\n    if thisOp[0] in codes: opCode = thisOp[0]      # If token opcode, then get token\n    else:                                    # Otherwise, opcode is second token\n        opCode = thisOp[1]                   # Read the second token to get opcode\n        label = sFile[i][0]                  # Read the first token to get the label\n    if (thisOp[0] in codes) and (len(thisOp) > 1): # If first token opcode, rest is predicate\n        predicate = thisOp[1:]               # Now get the predicate\n    else:                                    # Get predicate if the line has a label\n        if len(thisOp) > 2: predicate = thisOp[2:]\n    form = codes.get(opCode)                 # Use opcode to read type (format)\n                                             # Now check the bits of the format code\n    if form[0] & 0b1000 == 0b1000:           # Bit 4 selects destination register rD\n        if predicate[0] in symbolTab:        # Check if first token in symbol table\n            rD = int(symbolTab[predicate[0]][1:]) # If it is, then get its value\n        else: rD = int(predicate[0][1:])     # If not label, get register from the predicate\n    if form[0] & 0b0100 == 0b0100:           # Bit 3 selects source register 1, rS1\n        if predicate[1] in symbolTab:\n            rS1 = int(symbolTab[predicate[1]][1:])\n        else: rS1 = int(predicate[1][1:])\n    if form[0] & 0b0010 == 0b0010:           # Bit 2 of format selects register rS1\n        if predicate[2] in symbolTab:\n            rS2 = int(symbolTab[predicate[2]][1:])\n        else: rS2 = int(predicate[2][1:])\n    if form[0] & 0b0001 == 0b0001:           # Bit 1 of format selects the literal field\n        litV = predicate[-1]\n        literal = getLit(litV)\n```", "```py\n\n    if debugLevel > 3:                       # If debug level > 3, print decoded fields\n        t0 = '%02d' % pcA                    # Format instruction counter\n        t1 = '{:<23}'.format(' '.join(thisOp)) # Format operation to 23 spaces\n        t3 = '%04x' % literal                # Format literal to 4-character hex\n        t4 = '{:04b}'.format(form[0])        # Format the 4-bit opcode format field\n        print('pc =',t0,'Op =',t1,'literal',t3,'Dest reg =',rD,'rS1 =', \\\n              'rS1,'rS2 =',rS2,'format =',t4)  # Concatenate fields to create 32-bit opcode\n    binCode = form[1]<<25|(rD)<<22|(rS1)<<19|(rS2)<<16|literal # Binary pattern\n    memP[pcA] = binCode                      # Store instruction in program memory\n                                             # End of the assembly portion of the program\n```", "```py\n\n                                           # The code is executed here\nr = [0] * 8                                # Define registers r[0] to r[7]\npc = 0                                     # Set program counter to 0\nrun = 1                                    # run = 1 during execution\nsp = 16                                    # Initialize the stack pointer (BSR/RTS)\ngoCount = 0                                # goCount executes n operations with no display\ntraceMode    = 0                           # Set to 1 to execute n instructions without display\nskipToBranch = 0                           # Used when turning off tracing until a branch\n```", "```py\nsilent = 0                                 # silent = 1 to turn off single stepping\n```", "```py\n\n                                           # Executes instructions when run is 1\nwhile run == 1:                            # Step through instructions: first, decode them!\n    binCode = memP[pc]                     # Read binary code of instruction\n    pcOld = pc                             # pc in pcOld (for display purposes)\n    pc = pc + 1                            # Increment the pc\n    binOp = binCode >> 25                  # Extract the 7-bit opcode as binOp\n    rD    = (binCode >> 22) & 7            # Extract the destination register, rD\n    rS1   = (binCode >> 19) & 7            # Extract source register 1, rS1\n    rS2   = (binCode >> 16) & 7            # Extract source register 2, rS2\n    lit   = binCode & 0xFFFF               # Extract the 16-bit literal\n    op0 = r[rD]                            # Get contents of destination register\n    op1 = r[rS1]                           # Get contents of source register 1\n    op2 = r[rS2]                           # Get contents of source register 2\n```", "```py\n\n# Instead of using the binary opcode to determine the instruction, I use the text opcode\n# It makes the code more readable if I use 'ADD' rather than its opcode\n    mnemonic=next(key for key,value in codes.items() if value[1]==binOp\n                                           # Get mnemonic from dictionary\n### INTERPRET INSTRUCTIONS                    # Examine the opcode and execute it\n    if   mnemonic == 'STOP': run = 0       # STOP ends the simulation\n    elif mnemonic == 'END!': run = 0       # END! terminates reading source code and stops\n    elif mnemonic == 'NOP':  pass          # NOP is a dummy instruction that does nothing\n    elif mnemonic == 'GET':                # Reads integer from the keyboard\n        printStatus()\n        kbd = (input('Type integer '))     # Get input\n        kbd = getLit(kbd)                  # Convert string to integer\n        r[rD] = kbd                        # Store in register\n        continue\n    elif mnemonic == 'RND':  r[rD] = random.randint(0,lit)\n                                           # Generate random number\n    elif mnemonic == 'SWAP': r[rD] = shift(0,1,r[rD],8)\n                                           # Swap bytes in a 16-bit word\n    elif mnemonic == 'SEC':  c = 1         # Set carry flag\n    elif mnemonic == 'LDRL': r[rD] = lit   # LDRL R0,20 loads R0 with literal 20\n    elif mnemonic == 'LDRM': r[rD] = mem[lit]\n                                           # Load register with memory location (LDRM)\n    elif mnemonic == 'LDRI': r[rD] = mem[op1 + lit]\n                                                   # LDRI r1,[r2,4] memory location [r2]+4\n    elif mnemonic == 'STRM': mem[lit] = r[rD]      # STRM stores register in memory\n    elif mnemonic == 'STRI': mem[op1 + lit] = r[rD] # STRI stores rD at location [rS1]+L\n    elif mnemonic == 'MOVE': r[rD] = op1           # MOVE copies register rS1 to rD\n    elif mnemonic == 'ADD':  r[rD] = alu('ADD',op1, op2)\n                                                   # Adds [r2] to [r3] and puts result in r1\n    elif mnemonic == 'ADDL': r[rD] = alu('ADD',op1,lit) # Adds 12 to [r2] and puts result in r1\n    elif mnemonic == 'SUB':  r[rD] = alu('SUB',op1,op2) #\n    elif mnemonic == 'SUBL': r[rD] = alu('SUB',op1,lit)\n    elif mnemonic == 'MUL':  r[rD] = alu('MUL',op1,op2)\n    elif mnemonic == 'MULL': r[rD] = alu('MUL',op1,lit)\n    elif mnemonic == 'DIV':  r[rD] = alu('DIV',op1,op2) # Logical OR\n    elif mnemonic == 'DIVL': r[rD] = alu('DIV',op1,lit)\n    elif mnemonic == 'MOD':  r[rD] = alu('MOD',op1,op2) # Modulus\n    elif mnemonic == 'MODL': r[rD] = alu('MOD',op1,lit)\n    elif mnemonic == 'AND':  r[rD] = alu('AND',op1,op2) # Logical AND\n    elif mnemonic == 'ANDL': r[rD] = alu('AND',op1,lit)\n    elif mnemonic == 'OR':   r[rD] = alu('OR', op1,op2) # Logical OR\n    elif mnemonic == 'ORL':  r[rD] = alu('OR', op1,lit)\n    elif mnemonic == 'EOR':  r[rD] = alu('EOR',op1,op2) # Exclusive OR\n    elif mnemonic == 'EORL': r[rD] = alu('EOR',op1,lit)\n    elif mnemonic == 'NOT':  r[rD] = alu('NOT',op0,1)   # NOT r1 uses only one operand\n    elif mnemonic == 'INC':  r[rD] = alu('ADD',op0,1)\n    elif mnemonic == 'DEC':  r[rD] = alu('SUB',op0,1)\n    elif mnemonic == 'CMP':  rr    = alu('SUB',op0,op1) # rr is a dummy variable\n    elif mnemonic == 'CMPL': rr    = alu('SUB',op0,lit)\n    elif mnemonic == 'ADC':  r[rD] = alu('ADC',op1,op2)\n    elif mnemonic == 'SBC':  r[rD] = alu('SBC',op1,op2)\n    elif mnemonic == 'LSL':  r[rD] = shift(0,0,op0,op1)\n    elif mnemonic == 'LSLL': r[rD] = shift(0,0,op0,lit)\n    elif mnemonic == 'LSR':  r[rD] = shift(1,0,op0,op1)\n    elif mnemonic == 'LSRL': r[rD] = shift(1,0,op0,lit)\n    elif mnemonic == 'ROL':  r[rD] = shift(1,1,op0,op2)\n    elif mnemonic == 'ROLL': r[rD] = shift(1,1,op0,lit)\n    elif mnemonic == 'ROR':  r[rD] = shift(0,1,op0,op2)\n    elif mnemonic == 'RORL': r[rD] = shift(0,1,op0,lit)\n    elif mnemonic == 'PRT':  print('Reg',rD,'=', '%04x' % r[rD])\n    elif mnemonic == 'BRA':             pc = lit\n    elif mnemonic == 'BEQ' and  z == 1: pc = lit\n    elif mnemonic == 'BNE' and  z == 0: pc = lit\n    elif mnemonic == 'BMI' and  n == 1: pc = lit\n    elif mnemonic == 'DBEQ':                     # Decrement register and branch on zero\n        r[rD] = r[rD] - 1\n        if r[rD] != 0: pc = lit\n    elif mnemonic == 'DBNE':            # Decrement register and branch on not zero\n        r[rD] = alu('SUB',op0,1)        # Note the use of the alu function\n        if z == 0: pc = lit\n    elif mnemonic == 'BSR':             # Stack-based operations. Branch to subroutine\n        sp = sp - 1                     # Pre-decrement stack pointer\n        stack[sp] = pc                  # Push the pc (return address)\n        pc = lit                        # Jump to target address\n    elif mnemonic == 'RTS':             # Return from subroutine\n        pc = stack[sp]                  # Pull pc address of the stack\n        sp = sp + 1                     # Increment stack pointer\n    elif mnemonic == 'PUSH':            # Push register to stack\n        sp = sp - 1                     # Move stack pointer up to make space\n        stack[sp] = op0                 # Push register in op on the stack\n    elif mnemonic == 'PULL':            # Pull register off the stack\n        r[rD] = stack[sp]               # Transfer stack value to register\n        sp = sp + 1                     # Move stack down\n```", "```py\n\n                                        # Instruction interpretation complete. Deal with display\n    if silent == 0:                     # Read keyboard ONLY if not in silent mode\n       x = input('>>>')                 # Get keyboard input to continue\n       if x == 'b': skipToBranch = 1    # Set flag to execute to branch with no display\n       if x.isnumeric():                # Is this a trace mode with a number of steps to skip?\n           traceMode = 1                # If so, set traceMode\n           goCount   = getLit(x) + 1    # Record the number of lines to skip printing\n    if skipToBranch == 1:               # Are we in skip-to-branch mode?\n        silent = 1                      # If so, turn off printing status\n        if mnemonic in branchGroup:     # Have we reached a branch?\n            silent = 0                  # If branch, turn off silent mode and allow tracing\n            skipToBranch = 0            # Turn off skip-to-branch mode\n    if traceMode == 1:                  # If in silent mode (no display of data)\n        silent = 1                      # Set silent flag\n        goCount = goCount – 1           # Decrement silent mode count\n        if goCount == 0:                # If we've reached zero, turn display on\n            traceMode = 0               # Leave trace mode\n            silent = 0                  # Set silent flag back to zero (off)\n```", "```py\n    if silent == 0: printStatus()\n```", "```py\n\nSet a pointer to the first memory location (i.e.,0)\nSet a counter to 5 (we are going to access five locations 0 to 4)\nRepeat\n  Generate a random number\n  Store this number at the pointer address\n  Point to next number (i.e., add 1 to the pointer)\n  Decrement the counter (i.e., counter 5,4,3,2,1,0)\n  Until counter = 0\n```", "```py\n\n        LDRL r0,0             @ Use r0 as a memory pointer and set it to 0\n        LDRL r1,5             @ Use r1 as the loop counter\n  Loop1 RND  r2               @ Loop: Generate a random number in r2\n        STRI r2,[r0],0        @ Store the random number in memory using pointer r0\n        INC  r0               @ Point to the next location (add 1 to the pointer)\n        DEC  r1               @ Decrement the loop counter (subtract 1 from the counter)\n        BNE  Loop1            @ Repeat until 0 (branch back to Loop1 if the last result was not 0)\n```", "```py\n\nSet upper pointer to top\nSet lower pointer to bottom\nRepeat\n   Get value at upper pointer\n   Get value at lower pointer\n   Swap values and store\nUntil upper pointer and lower pointer are equal\n```", "```py\n\n      LDRL r0,0                @ Lower pointer points at first entry in table\n      LDRL r1,4                @ Upper pointer points at last entry in table\nLoop2 LDRI r2,[r0],0           @ REPEAT: Get lower value pointed at by r0\n      LDRI r3,[r1],0           @ Get upper value pointed at by r1\n      MOVE r2,r4               @ Save lower value in r4 temporarily\n      STRI r3,[r0],0           @ Store upper value in lower entry position\n      STRI r4,[r1],0           @ Store saved lower value in upper entry position\n      INC  r0                  @ Increase lower pointer\n      DEC  r1                  @ Decrease upper pointer\n      CMP  r0,r1               @ Compare pointers\n      BNE  Loop2               @ UNTIL all characters moved\n```", "```py\n\nTC1 CPU simulator 11 September 2022\nInput debug level 1 - 5: 4\nSource assembly code listing\n0           LDRL R0 0\n1           LDRL R1 5\n2   LOOP1   RND  R2\n3           STRI R2 R0 0\n4           INC  R0\n5           DEC  R1\n6           BNE  LOOP1\n7           NOP\n8           LDRL R0 0\n9           LDRL R1 4\n10  LOOP2   LDRI R2 R0 0\n11          LDRI R3 R1 0\n12          MOVE R4 R2\n13          STRI R3 R0 0\n14          STRI R4 R1 0\n15          INC  R0\n16          DEC  R1\n17          CMP  R0 R1\n18          BNE  LOOP2\n19          NOP\n20          STOP\n21          END!\nEquate and branch table\nSTART    0\nLOOP1    2\nLOOP2    10\n```", "```py\n\nDecoded instructions\npc=00 Op =       LDRL R0 0        literal 0000 RD=0 rS1=0 rS2=0 format=1001\npc=01 Op =       LDRL R1 5        literal 0005 RD=1 rS1=0 rS2=0 format=1001\npc=02 Op=  LOOP1 RND R2 0XFFFF    literal ffff RD=2 rS1=0 rS2=0 format=1001\npc=03 Op =       STRI R2 R0 0     literal 0000 RD=2 rS1=0 rS2=0 format=1101\npc=04 Op =       INC  R0          literal 0000 RD=0 rS1=0 rS2=0 format=1000\npc=05 Op =       DEC  R1          literal 0000 RD=1 rS1=0 rS2=0 format=1000\npc=06 Op =       BNE  LOOP1       literal 0002 RD=0 rS1=0 rS2=0 format=0001\npc=07 Op =       NOP              literal 0000 RD=0 rS1=0 rS2=0 format=0000\npc=08 Op =       LDRL R0 0        literal 0000 RD=0 rS1=0 rS2=0 format=1001\npc=09 Op =       LDRL R1 4        literal 0004 RD=1 rS1=0 rS2=0 format=1001\npc=10 Op=  LOOP2 LDRI R2 R0 0     literal 0000 RD=2 rS1=0 rS2=0 format=1101\npc=11 Op =       LDRI R3 R1 0     literal 0000 RD=3 rS1=1 rS2=0 format=1101\npc=12 Op =       MOVE R4 R2       literal 0000 RD=4 rS1=2 rS2=0 format=1100\npc=13 Op =       STRI R3 R0 0     literal 0000 RD=3 rS1=0 rS2=0 format=1101\npc=14 Op =       STRI R4 R1 0     literal 0000 RD=4 rS1=1 rS2=0 format=1101\npc=15 Op =       INC  R0          literal 0000 RD=0 rS1=0 rS2=0 format=1000\npc=16 Op =       DEC  R1          literal 0000 RD=1 rS1=0 rS2=0 format=1000\npc=17 Op =       CMP  R0 R1       literal 0000 RD=0 rS1=1 rS2=0 format=1100\npc=18 Op =       BNE  LOOP2       literal 000a RD=0 rS1=0 rS2=0 format=0001\npc=19 Op =       NOP              literal 0000 RD=0 rS1=0 rS2=0 format=0000\npc=20 Op =       STOP             literal 0000 RD=0 rS1=0 rS2=0 format=0000\npc=21 Op =       END!             literal 0000 RD=0 rS1=0 rS2=0 format=0000\n```", "```py\n\n0         LDRL R0 0         PC =  0 z = 0 0000 0000 0000 0000 0000\n                            R  0000 0000 0000 0000 0000\n1         LDRL R1 5         PC =  1 z = 0 0000 0000 0000 0000 0000\n                            R  0000 0005 0000 0000 0000\n2  LOOP1  RND  R2           PC =  2 z = 0 0000 0000 0000 0000 0000\n                            R  0000 0005 9eff 0000 0000\n3         STRI R2 R0 0      PC =  3 z = 0 9eff 0000 0000 0000 0000\n                            R  0000 0005 9eff 0000 0000\n4         INC  R0           PC =  4 z = 0 9eff 0000 0000 0000 0000\n                            R  0001 0005 9eff 0000 0000\n5         DEC  R1           PC =  5 z = 0 9eff 0000 0000 0000 0000\n                            R  0001 0004 9eff 0000 0000\n6         BNE  LOOP1        PC =  6 z = 0 9eff 0000 0000 0000 0000\n                            R  0001 0004 9eff 0000 0000\n2  LOOP1  RND  R2           PC =  2 z = 0 9eff 0000 0000 0000 0000\n                            R  0001 0004 6d4a 0000 0000\n3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a 0000 0000 0000\n                            R  0001 0004 6d4a 0000 0000\n4         INC  R0           PC =  4 z = 0 9eff 6d4a 0000 0000 0000\n                            R  0002 0004 6d4a 0000 0000\n5         DEC  R1           PC =  5 z = 0 9eff 6d4a 0000 0000 0000\n                            R  0002 0003 6d4a 0000 0000\n6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a 0000 0000 0000\n                            R  0002 0003 6d4a 0000 0000\n2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a 0000 0000 0000\n                            R  0002 0003 a387 0000 0000\n3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 0000 0000\n                            R  0002 0003 a387 0000 0000\n4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 0000 0000\n                            R  0003 0003 a387 0000 0000\n5         DEC  R1           PC =  5 z = 0 9eff 6d4a a387 0000 0000\n                            R  0003 0002 a387 0000 0000\n6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a a387 0000 0000\n                            R  0003 0002 a387 0000 0000\n2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a a387 0000 0000\n                            R  0003 0002 2937 0000 0000\n3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 2937 0000\n                            R  0003 0002 2937 0000 0000\n4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 2937 0000\n                            R  0004 0002 2937 0000 0000\n5         DEC  R1           PC =  5 z = 0 9eff 6d4a a387 2937 0000\n                            R  0004 0001 2937 0000 0000\n6         BNE  LOOP1        PC =  6 z = 0 9eff 6d4a a387 2937 0000\n                            R  0004 0001 2937 0000 0000\n2  LOOP1  RND  R2           PC =  2 z = 0 9eff 6d4a a387 2937 0000\n                            R  0004 0001 db95 0000 0000\n3         STRI R2 R0 0      PC =  3 z = 0 9eff 6d4a a387 2937 db95\n                            R  0004 0001 db95 0000 0000\n4         INC  R0           PC =  4 z = 0 9eff 6d4a a387 2937 db95\n                            R  0005 0001 db95 0000 0000\n5         DEC  R1           PC =  5 z = 1 9eff 6d4a a387 2937 db95\n                            R  0005 0000 db95 0000 0000\n6         BNE LOOP1         PC =  6 z = 1 9eff 6d4a a387 2937 db95\n                            R  0005 0000 db95 0000 0000\n7         NOP               PC =  7 z = 1 9eff 6d4a a387 2937 db95\n                            R  0005 0000 db95 0000 0000\n8         LDRL R0 0         PC =  8 z = 1 9eff 6d4a a387 2937 db95\n                            R  0000 0000 db95 0000 0000\n9         LDRL R1 4         PC =  9 z = 1 9eff 6d4a a387 2937 db95\n                            R  0000 0004 db95 0000 0000\n10 LOOP2  LDRI R2 R0 0      PC = 10 z = 1 9eff 6d4a a387 2937 db95\n                            R  0000 0004 9eff 0000 0000\n11        LDRI R3 R1 0      PC = 11 z = 1 9eff 6d4a a387 2937 db95\n                            R  0000 0004 9eff db95 0000\n12        MOVE R4 R2        PC = 12 z = 1 9eff 6d4a a387 2937 db95\n                            R  0000 0004 9eff db95 9eff\n13        STRI R3 R0 0      PC = 13 z = 1 db95 6d4a a387 2937 db95\n                            R  0000 0004 9eff db95 9eff\n14        STRI R4 R1 0      PC = 14 z = 1 db95 6d4a a387 2937 9eff\n                            R  0000 0004 9eff db95 9eff\n15        INC  R0           PC = 15 z = 0 db95 6d4a a387 2937 9eff\n                            R  0001 0004 9eff db95 9eff\n16        DEC  R1           PC = 16 z = 0 db95 6d4a a387 2937 9eff\n                            R  0001 0003 9eff db95 9eff\n17        CMP  R0 R1        PC = 17 z = 0 db95 6d4a a387 2937 9eff\n                            R  0001 0003 9eff db95 9eff\n18        BNE  LOOP2        PC = 18 z = 0 db95 6d4a a387 2937 9eff\n                            R  0001 0003 9eff db95 9eff\n10 LOOP2  LDRI R2 R0 0      PC = 10 z = 0 db95 6d4a a387 2937 9eff\n                            R  0001 0003 6d4a db95 9eff\n11        LDRI R3 R1 0      PC = 11 z = 0 db95 6d4a a387 2937 9eff\n                            R  0001 0003 6d4a 2937 9eff\n12        MOVE R4 R2        PC = 12 z = 0 db95 6d4a a387 2937 9eff\n                            R  0001 0003 6d4a 2937 6d4a\n13        STRI R3 R0 0      PC = 13 z = 0 db95 2937 a387 2937 9eff\n                            R  0001 0003 6d4a 2937 6d4a\n14        STRI R4 R1 0      PC = 14 z = 0 db95 2937 a387 6d4a 9eff\n                            R  0001 0003 6d4a 2937 6d4a\n15        INC  R0           PC = 15 z = 0 db95 2937 a387 6d4a 9eff\n                            R  0002 0003 6d4a 2937 6d4a\n16        DEC  R1           PC = 16 z = 0 db95 2937 a387 6d4a 9eff\n                            R  0002 0002 6d4a 2937 6d4a\n17        CMP  R0 R1        PC = 17 z = 1 db95 2937 a387 6d4a 9eff\n                            R  0002 0002 6d4a 2937 6d4a\n18        BNE  LOOP2        PC = 18 z = 1 db95 2937 a387 6d4a 9eff\n                            R  0002 0002 6d4a 2937 6d4a\n19        NOP               PC = 19 z = 1 db95 2937 a387 6d4a 9eff\n                            R  0002 0002 6d4a 2937 6d4a\n20        STOP              PC = 20 z = 1 db95 2937 a387 6d4a 9eff\n                            R  0002 0002 6d4a 2937 6d4a\n```", "```py\n\n     NOP\n BRA eee\n      INC r4\nalan inc r5\neee    STOP\naa NOP @comment2\nbb NOP     1\n      LDRL      r0,   12\n      LDRL r3,0x123 @ comment1\n      LDRL r7,     0xFF\n      INC R2\n  BRA last\ntest1     EQU    999\n  @comment3\n@comment4\n  @ qqq EQU 7\nwww STRI r1,r2,1\nabc   equ 25\nqwerty  equ   888\nlast LDRL r5,0xFAAF\n  beQ Aa\n      STOP 2\n```", "```py\n\nTC1 CPU simulator 11 September 2022\nInput debug level 1 - 5: 4\nSource assembly code listing\n0           NOP\n1           BRA EEE\n2           INC R4\n3   ALAN    INC R5\n4   EEE     STOP\n5   AA      NOP\n6   BB      NOP 1\n7           LDRL R0 12\n8           LDRL R3 0X123\n9           LDRL R7 0XFF\n10          INC R2\n11          BRA LAST\n12  WWW     STRI R1 R2 1\n13  LAST    LDRL R5 0XFAAF\n14          BEQ AA\n15          STOP 2\n```", "```py\n\nEquate and branch table\nSTART    0\nTEST1    999\nABC      25\nQWERTY   888\nALAN     3\nEEE      4\nAA       5\nBB       6\nWWW      12\nLAST     13\nLOOP1    18\nLOOP2    26\n```", "```py\n\nDecoded instructions\npc=0  op=NOP                  literal 000 Dest reg=0 rS1-0 rS2=0 format=0000\npc=00 Op=NOP                  literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000\npc=01 Op=BRA EEE              literal 0004 Dest reg=0 rS1=0 rS2=0 format=0001\npc=02 Op=INC R4               literal 0000 Dest reg=4 rS1=0 rS2=0 format=1000\npc=03 Op=ALAN INC R5          literal 0000 Dest reg=5 rS1=0 rS2=0 format=1000\npc=04 Op=EEE STOP             literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000\npc=05 Op=AA NOP               literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000\npc=06 Op=BB NOP 1             literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000\npc=07 Op=LDRL R0 12           literal 000c Dest reg=0 rS1=0 rS2=0 format=1001\npc=08 Op=LDRL R3 0X123        literal 0123 Dest reg=3 rS1=0 rS2=0 format=1001\npc=09 Op=LDRL R7 0XFF         literal 00ff Dest reg=7 rS1=0 rS2=0 format=1001\npc=10 Op=INC R2               literal 0000 Dest reg=2 rS1=0 rS2=0 format=1000\npc=11 Op=BRA LAST             literal 000d Dest reg=0 rS1=0 rS2=0 format=0001\npc=12 Op=WWW STRI R1 R2 1     literal 0001 Dest reg=1 rS1=2 rS2=0 format=1101\npc=13 Op=LAST LDRL R5 0XFAAF   literal faaf Dest reg=5 rS1=0 rS2=0 format=1001\npc=14 Op=BEQ AA               literal 0005 Dest reg=0 rS1=0 rS2=0 format=0001\npc=15 Op=STOP 2               literal 0000 Dest reg=0 rS1=0 rS2=0 format=0000\n>>>\n```", "```py\n\n>>> %Run TC1_FinalForBook_V1.2_20220911.py\nTC1 CPU simulator 11 September 2022\nInput debug level 1 - 5: 4\nSource assembly code listing\n0           NOP\n1           BRA LAB1\n2           INC R0\n3   LAB1    INC R2\n4           NOP\n5           BRA LAB6\n6           NOP\n7   LAB2    LDRL R2 3\n8   LAB4    DEC R2\n9           NOP\n10          BNE LAB4\n11          NOP\n12          BSR LAB7\n13          NOP\n14          LDRL R3 4\n15  LAB5    NOP\n16          INC R7\n17          DBNE R3 LAB5\n18          NOP\n19          STOP\n20  LAB6    BRA LAB2\n21          NOP\n22  LAB7    DEC R7\n23          DEC R7\n24          RTS\n25          END!\nEquate and branch table\nSTART    0\nLAB1     3\nLAB2     7\nLAB4     8\nLAB5     15\nLAB6     20\nLAB7     22\n```", "```py\n\n0         NOP               PC= 0 z=0 n=0 c=0 \n                            R  0000 0000 0000 0000 0000 0000 0000 0000\n1         BRA LAB1          PC= 1 z=0 n=0 c=0\n                            R  0000 0000 0000 0000 0000 0000 0000 0000\n3  LAB1   INC R2            PC= 3 z=0 n=0 c=1 \n                            R  0000 0000 0001 0000 0000 0000 0000 0000\n4         NOP               PC= 4 z=0 n=0 c=1 \n                            R  0000 0000 0001 0000 0000 0000 0000 0000\n5         BRA LAB6          PC= 5 z=0 n=0 c=1 \n                            R  0000 0000 0001 0000 0000 0000 0000 0000\n20 LAB6   BRA LAB2          PC=20 z=0 n=0 c=1 \n                            R  0000 0000 0001 0000 0000 0000 0000 0000\n7  LAB2   LDRL R2 3         PC= 7 z=0 n=0 c=1 \n                            R  0000 0000 0003 0000 0000 0000 0000 0000\n8  LAB4   DEC R2            PC= 8 z=0 n=0 c=1 \n                            R  0000 0000 0002 0000 0000 0000 0000 0000\n9         NOP               PC= 9 z=0 n=0 c=1 \n                            R  0000 0000 0002 0000 0000 0000 0000 0000\n10        BNE LAB4          PC=10 z=0 n=0 c=1 \n                            R  0000 0000 0002 0000 0000 0000 0000 0000\n8  LAB4   DEC R2            PC= 8 z=0 n=0 c=1 \n                            R  0000 0000 0001 0000 0000 0000 0000 0000\n9         NOP               PC= 9 z=0 n=0 c=1 \n                            R  0000 0000 0001 0000 0000 0000 0000 0000\n10        BNE LAB4          PC=10 z=0 n=0 c=1 \n                            R  0000 0000 0001 0000 0000 0000 0000 0000\n8  LAB4   DEC R2            PC= 8 z=1 n=0 c=0 \n                            R  0000 0000 0000 0000 0000 0000 0000 0000\n9         NOP               PC= 9 z=1 n=0 c=0 \n                            R  0000 0000 0000 0000 0000 0000 0000 0000\n10        BNE LAB4          PC=10 z=1 n=0 c=0 \n                            R  0000 0000 0000 0000 0000 0000 0000 0000\n11        NOP               PC=11 z=1 n=0 c=0 \n                            R  0000 0000 0000 0000 0000 0000 0000 0000\n12        BSR LAB7          PC=12 z=1 n=0 c=0 \n                            R  0000 0000 0000 0000 0000 0000 0000 0000\n22 LAB7   DEC R7            PC=22 z=0 n=1 c=1 \n                            R  0000 0000 0000 0000 0000 0000 0000 ffff\n23        DEC R7            PC=23 z=0 n=1 c=1 \n                            R  0000 0000 0000 0000 0000 0000 0000 fffe\n24        RTS               PC=24 z=0 n=1 c=1 \n                            R  0000 0000 0000 0000 0000 0000 0000 fffe\n13        NOP               PC=13 z=0 n=1 c=1 \n                            R  0000 0000 0000 0000 0000 0000 0000 fffe\n14        LDRL R3 4         PC=14 z=0 n=1 c=1 \n                            R  0000 0000 0000 0004 0000 0000 0000 fffe\n15 LAB5   NOP               PC=15 z=0 n=1 c=1 \n                            R  0000 0000 0000 0004 0000 0000 0000 fffe\n16        INC R7            PC=16 z=0 n=1 c=1 \n                            R  0000 0000 0000 0004 0000 0000 0000 ffff\n17        DBNE R3 LAB5      PC=17 z=0 n=1 c=1 \n                            R  0000 0000 0000 0003 0000 0000 0000 ffff\n15 LAB5   NOP               PC=15 z=0 n=1 c=1 \n                            R  0000 0000 0000 0003 0000 0000 0000 ffff\n16        INC R7            PC=16 z=1 n=0 c=0 \n                            R  0000 0000 0000 0003 0000 0000 0000 0000\n17        DBNE R3 LAB5      PC=17 z=1 n=0 c=0 \n                            R  0000 0000 0000 0002 0000 0000 0000 0000\n15 LAB5   NOP               PC=15 z=1 n=0 c=0 \n                            R  0000 0000 0000 0002 0000 0000 0000 0000\n16        INC R7            PC=16 z=0 n=0 c=1 \n                            R  0000 0000 0000 0002 0000 0000 0000 0001\n17        DBNE R3 LAB5      PC=17 z=0 n=0 c=1 \n                            R  0000 0000 0000 0001 0000 0000 0000 0001\n15 LAB5   NOP               PC=15 z=0 n=0 c=1 \n                            R  0000 0000 0000 0001 0000 0000 0000 0001\n16        INC R7            PC=16 z=0 n=0 c=1 \n                            R  0000 0000 0000 0001 0000 0000 0000 0002\n17        DBNE R3 LAB5      PC=17 z=0 n=0 c=1 \n                            R  0000 0000 0000 0000 0000 0000 0000 0002\n18        NOP               PC=18 z=0 n=0 c=1 \n                            R  0000 0000 0000 0000 0000 0000 0000 0002\n19        STOP              PC=19 z=0 n=0 c=1 \n                            R  0000 0000 0000 0000 0000 0000 0000 0002\n```", "```py\n\nLDRL r1,%1000000110000001\nLSLL r0,r1,1\nLSLL r0,r1,2\nLSRL r0,r1,1\nLSRL r0,r1,1\nLDRL r1,%1000000110000001\nLDRL r2,1\nLDRL r3,2\nLSLL r0,r1,r2\nLSLL r0,r1,r3\nLSRL r0,r1,r2\nLSRL r0,r1,r2\n```", "```py\n\n1  LDRL R1 %1000000110000001 z = 0 n = 0 c = 0 \n   Regs 0 - 3  0000 8181 0000 0000  R0 =  0000000000000000\n2  LSLL R0 R1 1              z = 0 n = 0 c = 1 \n   Regs 0 – 3  0302 8181 0000 0000  R0 =  0000001100000010\n3  LSLL R0 R1 2              z = 0 n = 0 c = 0 \n   Regs 0 - 3  0604 8181 0000 0000  R0 =  0000011000000100\n4  LSRL R0 R1 1              z = 0 n = 0 c = 1 \n   Regs 0 - 3  40c0 8181 0000 0000  R0 =  0100000011000000\n5  LSRL R0 R1 1              z = 0 n = 0 c = 1 \n   Regs 0 - 3  40c0 8181 0000 0000  R0 =  0100000011000000\n6  LDRL R1 %1000000110000001 z = 0 n = 0 c = 1 \n   Regs 0 - 3  40c0 8181 0000 0000  R0 =  0100000011000000\n7  LDRL R2 1                 z = 0 n = 0 c = 1 \n   Regs 0 - 3  40c0 8181 0001 0000  R0 =  0100000011000000\n8  LDRL R3 2                 z = 0 n = 0 c = 1 \n   Regs 0 - 3  40c0 8181 0001 0002  R0 =  0100000011000000\n9  LSL  R0 R1 R2             z = 0 n = 0 c = 1 \n   Regs 0 - 3  0302 8181 0001 0002  R0 =  0000001100000010\n10 LSL  R0 R1 R3             z = 0 n = 0 c = 0 \n   Regs 0 - 3  0604 8181 0001 0002  R0 =  0000011000000100\n11 LSR  R0 R1 R2             z = 0 n = 0 c = 1 \n   Regs 0 - 3  40c0 8181 0001 0002  R0 =  0100000011000000\n12 LSR  R0 R1 R2             z = 0 n = 0 c = 1 \n```", "```py\n   Regs 0 – 3  40c0 8181 0001 0002  R0 =  0100000011000000\n```", "```py\n\nif thisThing in [2, 4, 5, 9]:                         # Test for membership of the set\ndef classDecode(predicate):\n    lit,rD,rS1,rS2 = '',0,0,0                         # The literal is a null string initially\n    if opClass in [1]:      lit = predicate           # Class 1 is mnemonic plus a literal\n    if opClass in [2]:      rD  = reg1[predicate]     # Class 2 is mnemonic plus a literal\n    if opClass in [3,4,5,6,7]:                   # Classes 3 to 7 have multiple parameters\n        predicate = predicate.split(',')              # So, split predicate into tokens\n        rD = reg1[predicate[0]]                       # Get first token (register number)\n```", "```py\n\ndef testLine(tokens):                    # Check whether there's a valid instruction in this line\n    error = 1                            # error flag = 1 for no error and 0 for an error state\n    if len(tokens) == 1:                 # If the line is a single token, it must be a mnemonic\n        if tokens[0] in codes: error = 0 # If the token is in codes, there's no error\n    else:                                # Otherwise, we have a multi-token line\n        if (tokens[0] in codes) or (tokens[1] in codes): error = 0:\n    return(error)                        # Return the error code\n```", "```py\n\nif (tokens[0] in codes) or (tokens[1] in codes): error = 0:\n```", "```py\n\ndef testIndex():                        # Test for register or memory index out of range\n    if (rD > 7) or (rS1 > 7) or (rS2 > 7): # Ensure register numbers are in the range 0 to 7\n        print('Register number error')\n        sys.exit()                      # Call operating system to leave the Python program\n    if mnemonic in ['LDRI', 'STRI']:    # Memory index testing only for memory load and store\n        if r[rS1] > len(m) - 1:         # Test rS1 contents are less than memory size\n            print(' Memory index error')\n            sys.exit()\n    return()\n```", "```py\n\nopClass = codes.get(mnemonic)[0]     # Use mnemonic to read opClass from the codes dictionary\n```", "```py\n\nthisLine = list((i,label,mnemonic,predicate,opClass))\n                                        # Combine the component parts in a list\nprog.append(thisLine)                   # Add the new line to the existing program\n```", "```py\n\n# Simple CPU instruction interpreter. Direct instruction interpretation. 30 September 2022\\. V1.0\n# Class 0: no operand                   NOP\n# Class 1: literal                      BEQ  3\n# Class 2: register                     INC  r1\n# Class 3: register,literal             LDRL r1,5\n# Class 4: register,register,           MOV  r1,r2\n# Class 5: register,register,literal    ADDL r1,r2,5\n# Class 6: register,register,register   ADD  r1,r2,r3\n# Class 7: register,[register]          LDRI r1,[r2]\nimport sys                              #NEW\ncodes = {'NOP':[0],'STOP':[0],'END':[0],'ERR':[0], 'BEQ':[1],'BNE':[1], \\\n         'BRA':[1],'INC':[2],'DEC':[2],'NOT':[2],'CMPL':[3],'LDRL':[3], \\\n         'DBNE':[3],'MOV':[4],'CMP':[4],'SUBL':[5],'ADDL':[5],'ANDL':[5], \\\n         'ADD':[6],'SUB':[6],'AND':[6],'OR':[6],'LDRI':[7],'STRI':[7]}\nreg1  = {'r0':0,   'r1':1,   'r2':2,  'r3':3,   'r4':4,   'r5':5, \\\n         'r6':6,  'r7':7}               # Registers\nreg2  = {'[r0]':0, '[r1]':1, '[r2]':2,'[r3]':3, '[r4]':4, \\\n         '[r5]':5, '[r6]':6,'[r7]':7}   # Pointer registers\nsymTab = {}                             # Symbol table\nr = [0] * 8                             # Register set\nm = [0] * 8\nprog = [] * 32                          # Program memory\ndef equates():                          # Process directives and delete from source\n    global symTab, sFile\n    for i in range (0,len(sFile)):      # Deal with equates\n        tempLine = sFile[i].split()\n        if len(tempLine) > 2 and tempLine[1] == 'EQU':\n                                        # If line > 2 tokens and second EQU\n            print('SYMB' , sFile[i])\n            symTab[tempLine[0]] = tempLine[2] # Put third token EQU in symbol table\n    sFile = [ i for i in sFile if i.count('EQU') == 0] # Remove all lines with 'EQU'\n    print('Symbol table ', symTab, '\\n')\n    return()\n```", "```py\n\ndef classDecode(predicate):\n    lit,rD,rS1,rS2 = '',0,0,0                         # Initialize variables\n    if opClass in [1]:      lit =  predicate\n    if opClass in [2]:      rD  = reg1[predicate]\n    if opClass in [3,4,5,6,7]:\n        predicate = predicate.split(',')\n        rD = reg1[predicate[0]]\n    if opClass in [4,5,6]:  rS1 = reg1[predicate[1]] \\\n                                                # Get source reg 1 for classes 4, 5, and 6\n    if opClass in [3,5]:    lit = (predicate[-1])     # Get literal for classes 3 and 5\n    if opClass in [6]:      rS2 = reg1[predicate[2]]  # Get source reg 2 for class 6\n    if opClass in [7]:      rS1 = reg2[predicate[1]]  # Get source pointer reg for class 7\n    return(lit,rD,rS1,rS2)\n```", "```py\n\ndef testLine(tokens):   # Check there's a valid instruction in this line\n    error = 1\n    if len(tokens) == 1:\n        if tokens[0] in codes: error = 0\n    else:\n        if (tokens[0] in codes) or (tokens[1] in codes): error = 0\n    return(error)\n    def testIndex():                    # Test for reg or memory index out of range\n    print('rD,rS1 =', rD,rS1, 'r[rS1] =', r[rS1], 'len(m)', len(m),\\\n    'mnemonic =', mnemonic)\n    if rD > 7 or rS1 > 7 or rS2 > 7:\n        print('Register number error')\n        sys.exit()                                  # Exit program on register error\n    if mnemonic in ['LDRI', 'STRI']:\n        if r[rS1] > len(m) - 1:\n            print(' Memory index error')\n            sys.exit()                              # Exit program on pointer error\n    return()\ndef getLit(litV):                                   # Extract a literal (convert formats)\n    if litV == '': return(0)                        # Return 0 if literal field empty\n    if  litV in symTab:                    # Look in symbol table and get value if there\n        litV = symTab[litV]                         # Read the symbol value as a string\n        lit = int(litV)                             # Convert string to integer\n    elif  litV[0]    == '%': lit = int(litV[1:],2)  # If % convert binary to int\n    elif  litV[0:1]  == '$': lit = int(litV[1:],16) # If first symbol $, convert hex to int\n    elif  litV[0]    == '-':\n        lit = (-int(litV[1:]))&0xFFFF               # Deal with negative values\n    elif  litV.isnumeric():  lit = int(litV)        # Convert decimal string to integer\n    else:                    lit = 0                # Default value 0 (if all else fails)\n    return(lit)\nprgN = 'E://ArchitectureWithPython//NewIdeas_1.txt' # prgN = program name:  test file\nsFile = [ ]                                         # sFile source data\nwith open(prgN,'r') as prgN:                        # Open it and read it\n    prgN = prgN.readlines()\nfor i in range(0,len(prgN)):                        # First level of text-processing\n    prgN[i] = prgN[i].replace('\\n','')              # Remove newline code in source\n    prgN[i] = ' '.join(prgN[i].split())             # Remove multiple spaces\n    prgN[i] = prgN[i].strip()                       # First strip spaces\nprgN = [i.split('@')[0] for i in prgN]              # Remove comment fields\nwhile '' in prgN: prgN.remove('')                   # Remove blank lines\nfor i in range(0,len(prgN)):                        # Copy source to sFile: stop on END\n    sFile.append(prgN[i])                           # Build new source text file sFile\n    if 'END' in sFile[i]: break            # Leave on 'END' and ignore any more source text\nfor i in range(0,len(sFile)): print(sFile[i])\nprint()\nequates()                                           # Deal with equates\nfor i in range(0,len(sFile)): print(sFile[i])\nprint()\nfor i in range(0,len(sFile)):         # We need to compile a list of labels\n    label = ''                        # Give each line a default empty label\n    predicate = ''                    # Create default predicate (label + mnemonic + predicate)\n    tokens = sFile[i].split(' ')      # Split into separate groups\n    error = testLine(tokens)          # Test for an invalid instruction\n    if error == 1:                    # If error found\n        print('Illegal instruction', tokens, 'at',i)\n        sys.exit()                    # Exit program\n    numTokens = len(tokens)           # Process this line\n    if numTokens == 1: mnemonic = tokens[0]\n    if numTokens > 1:\n        if tokens[0][-1] == ':':\n            symTab.update({tokens[0][0:-1]:i})    # Insert new value and line number\n            label = tokens[0][0:-1]\n            mnemonic = tokens[1]\n        else: mnemonic = tokens[0]\n        predicate = tokens[-1]\n    opClass = codes.get(mnemonic)[0] # Use the mnemonic to read opClass from codes dictionary\n    thisLine = list((i,label,mnemonic,predicate,opClass))\n    prog.append(thisLine)            # Program line + label + mnemonic + predicate + opClass\nprint('Symbol table ', symTab, '\\n') # Display symbol table for equates and line labels\n```", "```py\n\n                                             # Instruction execution\nrun = 1\nz = 0\npc = 0\nwhile run == 1:\n    thisOp = prog[pc]\n    if thisOp[2] in ['STOP', 'END']: run = 0 # Terminate on STOP or END (comment on this)\n    pcOld = pc\n    pc = pc + 1\n    mnemonic  = thisOp[2]\n    predicate = thisOp[3]\n    opClass   = thisOp[4]\n    lit,rD,rS1,rS2 = classDecode(predicate)\n    lit = getLit(lit)\n    if   mnemonic == 'NOP': pass\n    elif mnemonic == 'BRA': pc = lit\n    elif mnemonic == 'BEQ':\n        if z == 1: pc = lit\n    elif mnemonic == 'BNE':\n        if z == 0: pc = lit\n    elif mnemonic == 'INC': r[rD] = r[rD] + 1\n    elif mnemonic == 'DEC':\n        z = 0\n        r[rD] = r[rD] - 1\n        if r[rD] == 0: z = 1\n    elif mnemonic == 'NOT': r[rD] = (~r[rD])&0xFFFF  # Logical NOT\n    elif mnemonic == 'CMPL':\n        z = 0\n        diff = r[rD] - lit\n        if diff == 0: z = 1\n    elif mnemonic == 'LDRL': r[rD] = lit\n    elif mnemonic == 'DBNE':\n        r[rD] = r[rD] - 1\n        if r[rD] != 0: pc = lit\n    elif mnemonic == 'MOV':  r[rD] = r[rS1]\n    elif mnemonic == 'CMP':\n        z = 0\n        diff = r[rD] - r[rS1]\n        if diff == 0: z = 1\n    elif mnemonic == 'ADDL': r[rD] = r[rS1] + lit\n    elif mnemonic == 'SUBL': r[rD] = r[rS1] - lit\n    elif mnemonic == 'ADD':  r[rD] = r[rS1] + r[rS2]\n    elif mnemonic == 'SUB':  r[rD] = r[rS1] - r[rS2]\n    elif mnemonic == 'AND':  r[rD] = r[rS1] & r[rS2]\n    elif mnemonic == 'OR':   r[rD] = r[rS1] | r[rS2]\n    elif mnemonic == 'LDRI':\n        testIndex()\n        r[rD] = m[r[rS1]]\n    elif mnemonic == 'STRI':\n        testIndex()\n        m[r[rS1]] = r[rD]\n    regs = ' '.join('%04x' % b for b in r)           # Format memory location's hex\n    mem  = ' '.join('%04x' % b for b in m)           # Format register's hex\n    print('pc =','{:<3}'.format(pcOld),'{:<18}'.format(sFile[pcOld]),\\\n          'regs =',regs,'Mem =',mem,'z =',z)\n```", "```py\n\nif (mnemonic in class3) and (predLen == 2) and (predicate[1] not in regList)\n```", "```py\n\n# Instruction formats\n# NOP             # class 0\n# BRA 4           # Class 1\n# INC r1          # class 2\n# LDR r1,#4       # class 3\n# MOV r1,r2       # class 4\n# ADD r1,r2,5     # class 5\n# ADD r1,r2,r3    # class 6\n# LDR r1,[r2]     # class 7\n# LDR r1,[r2],4   # class 8\n# MLA r1,r2,r3,r4 # class 9 [r1] = [r2] + [r3] * [r3]\ndef getLit(lit):                        # Extract a literal\n    if    lit in symTab:    literal = symTab[lit] \\\n                                        # Look in symbol table and get if there\n    elif  lit       == '%': literal = iint(lit[1:],2) \\\n                                        # If first symbol is %, convert binary to integer\n    elif  lit[0:1]  == '$': literal = int(lit[1:],16) \\\n                                        # If first symbol is $, convert hex to integer\n    elif  lit[0]    == '-': literal = i(-int(lit[1:]))&0xFFFF \\\n                                        # Deal with negative values\n    elif  lit.isnumeric():  literal = iint(lit) \\\n                                        # If number is a decimal string, then convert to integer\n    else:                   literal = 0 # Default value 0 if all else fails\n    return(literal)\nregList = {'r0':0,'r1':1,'r2':2,'r3':3,'r4':4,'r5':5,'r6':6,'r7':7}\niRegList = {'[r0]':0,'[r1]':1,'[r2]':2,'[r3]':3,'[r4]':4,'[r5]':5, \\\n            '[r6]':6,'[r7]':7}\nclass0 = ['NOP','STOP','RTS']           # none\nclass1 = ['BRA','BEQ', 'BSR']           # register\nclass2 = ['INC', 'DEC']                 # register\nclass3 = ['LDR', 'STR','CMP','DBNE','LSL','LSR','ROR']  # register, literal\nclass4 = ['MOV','CMP','ADD']            # register, register Note ADD r1,r2\nclass5 = ['ADD','SUB']                  # register, register, literal\nclass6 = ['ADD','SUB']                  # register, register, register\nclass7 = ['LDR','STR']                  # register, pointer\nclass8 = ['LDR','STR']                  # register, pointer, literal\nclass9 = ['MLA']                        # register, register, register, register\ninputSource = 0                         # Manual (keyboard) input if 0; file input if 1\nsingleStep  = 0                         # Select single-step mode or execute all-to-end mode\nx = input('file input? type y or n ')   # Ask for file input (y) or keyboard input (any key)\nif x == 'y':\n    inputSource = 1\n    x = input('Single step type y ')    # Type 'y' for single-step mode\n    if x == 'y': singleStep = 1\n    with open('C:/Users/AlanClements/Desktop/c.txt','r') as fileData:\n        fileData = fileData.readlines()\n    for i in range (0,len(fileData)):   # Remove leading and trailing spaces\n        fileData[i] = fileData[i].strip()\nr =     [0] * 8                         # Eight registers\nm =     [0] * 16                        # 16 memory locations\nstack = [0] * 8                         # Stack for return addresses (BSR/RTS)\nprog =  []  * 64                        # Program memory\nprogDisp = [] * 64                      # Program for display\nsymTab = {}                             # Symbol table for symbolic name to value binding\nrun = True\npc = 0                                  # Clear program counter\nsp = 7                                  # Set stack pointer to bottom of stack\nwhile run == True:                      # Program processing loop\n    predicate = []                      # Dummy\n    if inputSource == 1:                # Get instruction from file\n        line = fileData[pc]\n    else: line = input('>> > ')         # Or input instruction from keyboard\n    if line == '':\n        run = False\n        break\n    line = ' '.join(line.split())       # Remove multiple spaces. Uses join and split\n    progDisp.append(line)               # Make a copy of this line for later display\n    line = line.replace(',',' ')\n    line = line.split(' ')              # Split instruction into tokens\n    if (len(line) > 1) and (line[0][-1] == ':'): # Look for a label (token 0 ending in :)\n        label = line[0]\n        symTab[line[0]] = pc            # Put a label in symTab alongside the pc\n    else:\n        line.insert(0,'    :')          # If no label+, insert a dummy one (for pretty printing)\n    mnemonic  = line[1]                 # Get the mnemonic, second token\n    predicate = line[2:]                # What's left is the predicate (registers and literal)\n    prog.append(line)                   # Append the line to the program\n    pc = pc + 1                         # And bump up the program counter\n    progLength = pc – 1                 # Record the total number of instructions\nfor i in range (0,pc-1):\n    print('pc =', f'{i:3}', (' ').join(prog[i])) # Print the program\nprint('Symbol table =', symTab, '\\n')   # Display the symbol table\npc = 0\nrun = True\nz = 0\nc = 0\nclassNim = 10\nwhile run == True:                      # Program execution loop\n    instruction = prog[pc]\n    pcOld = pc\n    pc = pc + 1\n    if instruction[1] == 'STOP':        # Halt on STOP instruction\n        print('End of program exit')\n        break\n    mnemonic  = instruction[1]\n    predicate = instruction[2:]\n    predLen   = len(predicate)\n    if (predLen > 0) and (mnemonic not in class1): rD = regList[predicate[0]]\n                                        # Get rD for classes 2 to 8\n```", "```py\n\n    if mnemonic in class0:              # Deal with instructions by their group (class)\n        classNum = 0\n        if mnemonic == 'NOP': pass\n        if mnemonic == 'RTS':           # Return from subroutine pull address off the stack\n            pc = stack[sp]\n            sp = sp + 1\n    if mnemonic in class1:              # Class deals with branch operations so get literal\n        classNum = 1\n        literal = getLit(predicate[0])\n        if   mnemonic == 'BRA': pc = literal\n        elif mnemonic == 'BEQ':\n            if z == 1: pc = literal\n        elif mnemonic == 'BSR':         # Deal with subroutine call\n            sp = sp - 1                 # Push return address on the stack\n            stack[sp] = pc\n            pc = literal\n    if mnemonic in class2:                 # Class 2 increment and decrement so get register\n        classNum = 2\n        if mnemonic == 'INC': r[rD] = r[rD] + 1\n        if mnemonic == 'DEC':\n            r[rD] = r[rD] - 1\n            if r[rD] == 0: z = 1           # Decrement sets z flag\n            else: z = 0\n    if (mnemonic in class3) and (predLen == 2) and \\\n    (predicate[1] not in regList):         \n        classNum = 3\n        literal = getLit(predicate[-1])\n        if mnemonic == 'CMP':\n            diff = r[rD] - literal\n            if diff == 0: z = 1\n            else:         z = 0\n        elif mnemonic == 'LDR': r[rD] = literal\n        elif mnemonic == 'STR': m[literal] = r[rD]\n        elif mnemonic == 'DBNE':\n            r[rD] = r[rD] - 1\n            if r[rD] != 0: pc = literal        # Note we don't use z flag\n        elif mnemonic == 'LSL':\n            for i in range(0,literal):\n                c = ((0x8000) & r[rD]) >> 16\n                r[rD] = (r[rD] << 1) & 0xFFFF  # Shift left and constrain to 16 bits\n        elif mnemonic == 'LSR':\n            for i in range(0,literal):\n                c = ((0x0001) & r[rD])\n                r[rD] = r[rD] >> 1\n        elif mnemonic == 'ROR':\n            for i in range(0,literal):\n                c = ((0x0001) & r[rD])\n                r[rD] = r[rD] >> 1\n                r[rD] = r[rD] | (c << 15)\n    if (mnemonic in class4) and (predLen == 2) and (predicate[1]\\\n    in regList):                           #\n        classNum = 4\n        rS1 = regList[predicate[1]]        # Get second register\n        if mnemonic == 'MOV':              # Move source register to destination register\n           r[rD] = r[rS1]\n        elif mnemonic == 'CMP':\n            diff = r[rD] -  r[rS1]\n            if diff == 0: z = 1\n            else:         z = 0\n        elif mnemonic == 'ADD':            # Add source to destination register\n            r[rD] = r[rD] + r[rS1]\n    if (mnemonic in class5) and (predLen == 3) and (predicate[2] not\\\n    in regList):\n        classNum = 5                       # Class 5 is register with literal operand\n        literal = getLit(predicate[2])\n        rS1 = regList[predicate[1]]\n        if   mnemonic == 'ADD': r[rD] = r[rS1] + literal\n        elif mnemonic == 'SUB': r[rD] = r[rS1] - literal\n    if (mnemonic in class6) and (predLen == 3) and (predicate[-1]\\\n    in regList):\n        classNum = 6                       # Class 6 uses three registers\n        rS1 = regList[predicate[1]]\n        rS2 = regList[predicate[2]]\n        if   mnemonic == 'ADD': r[rD] = r[rS1] + r[rS2]\n        elif mnemonic == 'SUB': r[rD] = r[rS1] - r[rS2]\n    if (mnemonic in class7) and (predLen == 2) and (predicate[1]\\\n    in iRegList):\n        classNum = 7                       # Class 7 uses a pointer register with load and store\n        pReg  = predicate[1]\n        pReg1 = iRegList[pReg]\n        pReg2 = r[pReg1]\n        if   mnemonic == 'LDR': r[rD] = m[pReg2]\n        elif mnemonic == 'STR': m[pReg2] = r[rD]\n    if (mnemonic in class8) and (predLen == 3):\n        classNum = 8                       # Class 8 uses a pointer register and a literal offset\n        pReg  = predicate[1]\n        pReg1 = iRegList[pReg]\n        pReg2 = r[pReg1]\n        literal = getLit(predicate[2])\n        if   mnemonic == 'LDR': r[rD] = m[pReg2 + literal]\n        elif mnemonic == 'STR': m[pReg2 + literal] = r[rD]\n    if mnemonic in class9:                 # Class 9 demonstrates a 4-operand instruction\n        classNum = 9\n        if mnemonic == 'MLA':\n            rS1 = regList[predicate[1]]\n            rS2 = regList[predicate[2]]\n            rS3 = regList[predicate[3]]\n            r[rD] = r[rS1] * r[rS2] + r[rS3]\n    pInst = ' '.join(instruction)          ##############\n    Regs = ' '.join('%04x' % i for i in r)\n    print('pc {:<2}'.format(pcOld),'Class =', classNum,      \\\n          '{:<20}'.format(pInst),'Regs: ', regs, 'Mem', m,   \\\n          'r[0] =', '{:016b}'.format(r[0]),                  \\\n          'c =', c, 'z =', z, '\\n')\n    print(progDisp[pcOld])\n    if singleStep == 1: input(' >>> ')\n```"]