<html><head></head><body>
<div><div><div><h1 id="_idParaDest-295"><em class="italic"><a id="_idTextAnchor276"/>Chapter 16</em>: The Factory Pattern</h1>
			<p><strong class="bold">Design patterns</strong> are reusable programming solutions that have been used in various real-world contexts and have proved to produce the expected results. In this chapter, we will learn about one of the most common design patterns: the factory design pattern. As we will see later, this pattern makes it easier to track which objects are created within a program, thus separating the code that creates an object from the code that uses it. We will study the factory design pattern's two forms: the <strong class="bold">factory method</strong> and the <strong class="bold">abstract method</strong>.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding design patterns</li>
				<li>Implementing the factory method</li>
				<li>Applying the abstract factory</li>
			</ul>
			<p>By the end of this chapter, we will have gained a deep understanding of the factory design pattern and its benefits via a hands-on example.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor277"/>Technical requirements</h1>
			<p>The code files for this chapter can be found at <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16</a>.</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor278"/>Understanding design patterns</h1>
			<p>Design patterns are shared among programmers<a id="_idIndexMarker1123"/> and continue to be improved over time. This topic is popular thanks to the book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, titled <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p>
			<p class="callout-heading">Gang of Four</p>
			<p class="callout">The book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides is also called the <em class="italic">Gang of Four</em> book for short (or the <em class="italic">GOF</em> book for an even shorter name).</p>
			<p>Generally, a design pattern helps the programmer create<a id="_idIndexMarker1124"/> a commonly used implementation pattern, especially in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). The benefits of viewing<a id="_idIndexMarker1125"/> applications from the design pattern's perspective are plenty. First, it narrows down the most effective ways of building a given application and the necessary steps to do it. Second, you could consult existing examples of the same design pattern to improve your application. Overall, design patterns are highly useful guidelines in software engineering.</p>
			<p>There are several categories of design patterns that are used in OOP, depending on the type of problem they address and/or the types of solutions they help us build. In their book, the <em class="italic">Gang of Four</em> presents 23 design<a id="_idIndexMarker1126"/> patterns, split<a id="_idIndexMarker1127"/> into three categories: <strong class="bold">creational</strong>, <strong class="bold">structural</strong>, and <strong class="bold">behavioral</strong>.</p>
			<p><code>__init__()</code> function, is not convenient.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">See <a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a> for a quick overview of object classes<a id="_idIndexMarker1129"/> and the special <code>__init__()</code> method that Python uses to initialize a new class instance.</p>
			<p>We will start with the first creational design<a id="_idIndexMarker1130"/> pattern from the <em class="italic">Gang of Four</em> book: the <strong class="bold">factory design pattern</strong>. In the factory design pattern, a <strong class="bold">client</strong> (meaning client code) asks for an object without knowing where the object is coming from (that is, which class is used to generate it). The idea behind a factory is to simplify the object creation process. It is easier to track which objects are created if this is done through a central function, compared to letting a client create objects using a direct class instantiation. A factory reduces the complexity of maintaining an application by decoupling the code that creates an object from the code that uses it.</p>
			<p>Factories typically come<a id="_idIndexMarker1131"/> in two forms: the <strong class="bold">factory method</strong>, which is a method (or simply a function for a Python developer) that returns a different object<a id="_idIndexMarker1132"/> per input parameter, and the <strong class="bold">abstract factory</strong>, which is a group of factory methods that are used to create a family<a id="_idIndexMarker1133"/> of related objects.</p>
			<p>That is all the theory we need to get started. In the next section, we will discuss the factory method.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor279"/>Implementing the factory method</h1>
			<p>The factory method<a id="_idIndexMarker1134"/> is based on a single function that's written to handle our object creation task. We execute it, passing a parameter that provides information about what we want. As a result, the object we wanted is created.</p>
			<p>Interestingly, when we use the factory method, we don't need to know any details about how the resulting object is implemented and where it is coming from. First, we will discuss some real-life applications that use the factory method and then implement an example application that processes XML and JSON files.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor280"/>Real-world examples </h2>
			<p>An example of the factory<a id="_idIndexMarker1135"/> method pattern that's used in real life is in the context of a plastic toy construction kit. The molding material that's used to construct plastic toys is the same, but different toys (different figures or shapes) can be produced using the right plastic molds. This is like having a factory method in which the input is the name of the toy that we want (for example, <code>duck</code> or <code>car</code>) and the output (after the molding) is the plastic toy that was requested.</p>
			<p>In the software world, the <em class="italic">Django</em> web framework uses the factory method pattern to create the fields of a web form. The <code>forms</code> module, which is included in Django, supports the ability to create different kinds of fields (for example, <code>CharField</code>, <code>EmailField</code>, and so on). Parts of their behavior can be customized using attributes such as <code>max_length</code> or <code>required</code> (<a href="http://j.mp/djangofac">j.mp/djangofac</a>).</p>
			<p>Consider the following example:</p>
			<pre>from django import forms
class PersonForm(forms.Form):
    name = forms.CharField(max_length=100)
    birth_date = forms.DateField(required=False)</pre>
			<p>The preceding code could be written by a developer for a form (the <code>PersonForm</code> form, which<a id="_idIndexMarker1136"/> contains the <code>name</code> and <code>birth_date</code> fields) as part of a Django application's UI code.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor281"/>Use cases</h2>
			<p>If you realize that you cannot track<a id="_idIndexMarker1137"/> the objects that are created by your application because the code that creates them is in many different places instead of in a single function/method, you should consider using the factory method pattern. The factory method centralizes object creation and tracking your objects becomes much easier. Note that it is absolutely fine to create more than one factory method, and this is how it is typically done in practice. Each factory method logically groups objects that have similarities. For example, one factory method might be responsible for connecting you to different databases (MySQL and SQLite), another factory method might be responsible for creating the geometrical object that you've requested (circle and triangle), and so on.</p>
			<p>The factory method is also useful when you want to decouple object creation from object usage. We are not coupled/bound to a specific class when creating an object; we just provide partial information about what we want by calling a function. This means that introducing changes to the function is easy and does not require any changes to be made to the code that uses it.</p>
			<p>Another use case worth mentioning is related to improving the performance and memory usage of an application. A factory method can improve performance and memory usage by creating new objects only if it is necessary. When we create objects using a direct class instantiation, extra memory is allocated every time a new object is created (unless the class uses caching internally, which is usually not the case). We can see that, in practice, in the following code (in the <code>id.py</code> file), it creates two instances of the same class, <code>A</code>, and uses<a id="_idIndexMarker1138"/> the <code>id()</code> function to compare their <strong class="bold">memory addresses</strong>. These addresses are also printed in the output so that we can inspect them. The fact that the memory addresses are different means that two distinct objects are created, as follows:</p>
			<pre>class A:
    pass
if __name__ == '__main__':
    a = A()
    b = A()    
    print(id(a) == id(b))
    print(a, b)</pre>
			<p>Executing the <code>python id.py</code> command on my computer results in the following output:</p>
			<pre>False
&lt;__main__.A object at 0x7f5771de8f60&gt; &lt;__main__.A object at 
0x7f5771df2208&gt;</pre>
			<p>Note that the addresses that you see if you execute the file are not the same as the ones I can see because they depend on the current memory layout and allocation. But the result must be the same: the two addresses should be different. There's one exception that happens if you write<a id="_idIndexMarker1139"/> and execute the code in the Python <strong class="bold">Read-Eval-Print Loop</strong> (<strong class="bold">REPL</strong>) – or, simply put, the interactive<a id="_idIndexMarker1140"/> prompt – but that's a REPL-specific optimization that does not happen normally.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor282"/>Implementing the factory method</h2>
			<p>Data comes in many forms. There are two main<a id="_idIndexMarker1141"/> file categories for storing/retrieving data: human-readable files and binary files. Examples of human-readable files include XML, RSS/Atom, YAML, and JSON. Examples of binary files include the <code>.sq3</code> file format that's used by SQLite and the <code>.mp3</code> audio file format, which is used to listen to music.</p>
			<p>In this example, we will focus on two popular human-readable formats: <strong class="bold">XML</strong> and <strong class="bold">JSON</strong>. Although human-readable files<a id="_idIndexMarker1142"/> are generally slower to parse than binary<a id="_idIndexMarker1143"/> files, they make data exchange, inspection, and modification much easier. For this reason, it is advised that you work with human-readable files<a id="_idIndexMarker1144"/> unless other restrictions do not allow it (mainly unacceptable performance and proprietary binary formats).</p>
			<p>In this case, we have some input data stored in an XML file and a JSON file, and we want to parse them and retrieve some information. At the same time, we want to centralize the client's connection to those (and all future) external services. We will use the factory method to solve this problem. This example focuses only on XML and JSON but adding support for more services should be straightforward.</p>
			<p>First, let's take a look at the data files.</p>
			<p>The JSON file, <code>movies.json</code>, which can be found in the <code>data</code> subfolder of this chapter's code folder, is an example of a dataset containing information about American movies (title, year, director name, genre, and so on). This is a big file but here is a portion of its content to illustrate how its content is organized:</p>
			<pre>[
 {"title":"After Dark in Central Park",
  "year":1900, 
  "director":null, "cast":null, "genre":null},
 {"title":"Boarding School Girls' Pajama Parade",
  "year":1900, 
  "director":null, "cast":null, "genre":null},
 {"title":"Buffalo Bill's Wild West Parad",
  "year":1900, 
  "director":null, "cast":null, "genre":null},
 {"title":"Caught",
  "year":1900, 
  "director":null, "cast":null, "genre":null},
 {"title":"Clowns Spinning Hats",
  "year":1900, 
  "director":null, "cast":null, "genre":null},
 ...
  ]</pre>
			<p>The XML file, <code>person.xml</code>, is based on a Wikipedia example (<a href="http://j.mp/wikijson">j.mp/wikijson</a>) and contains information<a id="_idIndexMarker1145"/> about individuals (<code>firstName</code>, <code>lastName</code>, <code>gender</code>, and so on), as follows:</p>
			<ol>
				<li>We start with the enclosing tag of the <code>persons</code> XML container:<pre>&lt;persons&gt; </pre></li>
				<li>Then, an XML element representing a person's data code is presented, as follows:<pre>&lt;person&gt; 
  &lt;firstName&gt;John&lt;/firstName&gt; 
  &lt;lastName&gt;Smith&lt;/lastName&gt; 
  &lt;age&gt;25&lt;/age&gt; 
  &lt;address&gt; 
    &lt;streetAddress&gt;21 2nd Street&lt;/streetAddress&gt; 
    &lt;city&gt;New York&lt;/city&gt; 
    &lt;state&gt;NY&lt;/state&gt; 
    &lt;postalCode&gt;10021&lt;/postalCode&gt; 
  &lt;/address&gt; 
  &lt;phoneNumbers&gt; 
    &lt;phoneNumber type="home"&gt;
      212 555-1234&lt;/phoneNumber&gt; 
    &lt;phoneNumber type="fax"&gt;646 555-4567&lt;/phoneNumber&gt; 
  &lt;/phoneNumbers&gt; 
  &lt;gender&gt; 
    &lt;type&gt;male&lt;/type&gt; 
  &lt;/gender&gt; 
&lt;/person&gt; </pre></li>
				<li>An XML element representing<a id="_idIndexMarker1146"/> another person's data must then be provided:<pre>&lt;person&gt; 
  &lt;firstName&gt;Jimy&lt;/firstName&gt; 
  &lt;lastName&gt;Liar&lt;/lastName&gt; 
  &lt;age&gt;19&lt;/age&gt; 
  &lt;address&gt; 
    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt; 
    &lt;city&gt;New York&lt;/city&gt; 
    &lt;state&gt;NY&lt;/state&gt; 
    &lt;postalCode&gt;10021&lt;/postalCode&gt; 
  &lt;/address&gt; 
  &lt;phoneNumbers&gt; 
  &lt;phoneNumber type="home"&gt;212 555-1234&lt;/phoneNumber&gt; 
  &lt;/phoneNumbers&gt; 
  &lt;gender&gt; 
    &lt;type&gt;male&lt;/type&gt; 
  &lt;/gender&gt; 
&lt;/person&gt; </pre></li>
				<li>An XML element representing a third person's data is then shown:<pre>&lt;person&gt; 
  &lt;firstName&gt;Patty&lt;/firstName&gt; 
  &lt;lastName&gt;Liar&lt;/lastName&gt; 
  &lt;age&gt;20&lt;/age&gt; 
  &lt;address&gt; 
    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt; 
    &lt;city&gt;New York&lt;/city&gt; 
    &lt;state&gt;NY&lt;/state&gt; 
    &lt;postalCode&gt;10021&lt;/postalCode&gt; 
  &lt;/address&gt; 
  &lt;phoneNumbers&gt; 
    &lt;phoneNumber type="home"&gt;
      212 555-1234&lt;/phoneNumber&gt; 
    &lt;phoneNumber type="mobile"&gt;
      001 452-8819&lt;/phoneNumber&gt; 
  &lt;/phoneNumbers&gt; 
  &lt;gender&gt; 
    &lt;type&gt;female&lt;/type&gt; 
  &lt;/gender&gt; 
&lt;/person&gt; </pre></li>
				<li>Finally, we must close<a id="_idIndexMarker1147"/> the XML container:<pre>&lt;/persons&gt;</pre></li>
				<li>We will use two libraries that are part of the Python distribution for working with JSON and XML, <code>json</code> and <code>xml.etree.ElementTree</code>, as follows:<pre>import json
import xml.etree.ElementTree as etree</pre></li>
				<li>The <code>JSONDataExtractor</code> class parses the JSON file and has a <code>parsed_data()</code> method that returns<a id="_idIndexMarker1148"/> all the data as a dictionary (<code>dict</code>). The property decorator is used to make <code>parsed_data()</code> appear as a normal attribute instead of a method, as follows:<pre>class JSONDataExtractor:
  def __init__(self, filepath):
    self.data = dict()
    with open(filepath, mode='r', encoding='utf-8') as 
    f:self.data = json.load(f)
    @property
    def parsed_data(self):
        return self.data</pre></li>
				<li>The <code>XMLDataExtractor</code> class parses the XML file and has a <code>parsed_data()</code> method that returns all the data as a list of <code>xml.etree.Element</code>, as follows:<pre>class XMLDataExtractor:
  def __init__(self, filepath):
    self.tree =  etree.parse(filepath)
  @property
  def parsed_data(self):
  return self.tree</pre></li>
				<li>The <code>dataextraction_factory()</code> function is a factory method. It returns an instance of <code>JSONDataExtractor</code> or <code>XMLDataExtractor</code>, depending on the extension of the input file path, as follows:<pre>def dataextraction_factory(filepath):
    if filepath.endswith('json'):
        extractor = JSONDataExtractor
    elif filepath.endswith('xml'):
        extractor = XMLDataExtractor
    else:
        raise ValueError('Cannot extract data from 
          {}'.format(filepath))
    return extractor(filepath)</pre></li>
				<li>The <code>extract_data_from()</code> function is a wrapper of <code>dataextraction_factory()</code>. It adds exception<a id="_idIndexMarker1149"/> handling, as follows:<pre>def extract_data_from(filepath):
    factory_obj = None
    try:
        factory_obj = dataextraction_factory(filepath)
    except ValueError as e:
        print(e)
    return factory_obj</pre></li>
				<li>The <code>main()</code> function demonstrates how the factory method design pattern can be used. The first part makes sure that exception handling is effective, as follows:<pre>def main():
    sqlite_factory = 
      extract_data_from('data/person.sq3')
    print()</pre></li>
				<li>The next part shows how to work with the JSON files using the factory method. Based<a id="_idIndexMarker1150"/> on the parsing, the title, year, director name, and genre of the movie can be shown (when the value is not empty), as follows:<pre>json_factory = extract_data_from('data/movies.json')
json_data = json_factory.parsed_data
print(f'Found: {len(json_data)} movies')
for movie in json_data:
  print(f"Title: {movie['title']}")
  year = movie['year']
  if year:
  print(f"Year: {year}")
  director = movie['director']
  if director:
  print(f"Director: {director}")
  genre = movie['genre']
  if genre:
  print(f"Genre: {genre}")
  print()</pre></li>
				<li>The final part shows you how to work with the XML files using the factory method. XPath is used to find all the person elements that have <code>Liar</code> as the last name (using <code>liars = xml_data.findall(f".//person[lastName='Liar']")</code>). For each matched person, their basic name and phone number information is shown, as follows:<pre>xml_factory = extract_data_from('data/person.xml')
xml_data = xml_factory.parsed_data
liars = 
  xml_data.findall(f".//person[lastName='Liar']")
print(f'found: {len(liars)} persons')
for liar in liars:
    firstname = liar.find('firstName').text
    print(f'first name: {firstname}')
    lastname = liar.find('lastName').text
    print(f'last name: {lastname}')
    [print(f"phone number ({p.attrib['type']}):", 
      p.text) 
    for p in liar.find('phoneNumbers')]
    print()</pre></li>
			</ol>
			<p>Here is the summary of the<a id="_idIndexMarker1151"/> implementation (you can find the code in the <code>factory_method.py</code> file):</p>
			<ol>
				<li value="1">We start by importing the modules we need (<code>json</code> and <code>ElementTree</code>).</li>
				<li>We define the JSON data extractor class (<code>JSONDataExtractor</code>).</li>
				<li>We define the XML data extractor class (<code>XMLDataExtractor</code>).</li>
				<li>We add the factory function, <code>dataextraction_factory()</code>, to get the right data extractor class.</li>
				<li>We also add our wrapper for handling exceptions – the <code>extract_data_from()</code> function.</li>
				<li>Finally, we have the <code>main()</code> function, followed by Python's conventional trick for calling it when invoking this file from the command line. The following are the aspects of the <code>main</code> function:<ul><li>We try to extract data from a SQL file (<code>data/person.sq3</code>) to show how the exception is handled.</li><li>We extract data from a JSON file and parse the result.</li><li>We extract data from an XML file and parse the result.</li></ul></li>
			</ol>
			<p>The following<a id="_idIndexMarker1152"/> is the type of output (for the different cases) you will get by calling the <code>python factory_method.py</code> command.</p>
			<p>First, there is an exception message that you'll see when you try to access a SQLite (<code>.sq3</code>) file:</p>
			<pre>Cannot extract data from data/person.sq3</pre>
			<p>Then, we get the following result from processing the <code>movies</code> file (JSON):</p>
			<pre>Found: 9 movies
Title: After Dark in Central Park
Year: 1900
Title: Boarding School Girls' Pajama Parade
Year: 1900
Title: Buffalo Bill's Wild West Parad
Year: 1900
Title: Caught
Year: 1900
Title: Clowns Spinning Hats
Year: 1900
Title: Capture of Boer Battery by British
Year: 1900
Director: James H. White
Genre: Short documentary
Title: The Enchanted Drawing
Year: 1900
Director: J. Stuart Blackton
Title: Family Troubles
Year: 1900
Title: Feeding Sea Lions
Year: 1900</pre>
			<p>Finally, we get this result<a id="_idIndexMarker1153"/> from processing the <code>person</code> XML file to find the people whose last name is <code>Liar</code>:</p>
			<pre>found: 2 persons
first name: Jimy
last name: Liar
phone number (home): 212 555-1234
first name: Patty
last name: Liar
phone number (home): 212 555-1234
phone number (mobile): 001 452-8819</pre>
			<p>Notice that although <code>JSONDataExtractor</code> and <code>XMLDataExtractor</code> have the same interfaces, what is returned by <code>parsed_data()</code> is not handled uniformly. Different Python<a id="_idIndexMarker1154"/> code must be used to work with each <strong class="bold">data extractor</strong>. Although it would be nice to be able to use the same code for all extractors, this is not realistic for the most part, unless we use some kind of common mapping for the data, which is often provided by external data providers. A useful exercise would be to assume that you can use the same code to handle the XML and JSON files and see what changes are required to support a third format, such as SQLite. Find a SQLite file or create your own and try it.</p>
			<p>At this point, we have learned<a id="_idIndexMarker1155"/> about the factory method, which, again, is the first form of the factory design pattern. In the next section, we will talk about the second: the abstract factory design pattern.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor283"/>Applying the abstract factory</h1>
			<p>The abstract factory design<a id="_idIndexMarker1156"/> pattern is a generalization of the factory method. An abstract factory is a (logical) group of factory methods, where each factory method is responsible for generating a different kind of object.</p>
			<p>In this section, we are going to discuss some examples, use cases, and a possible implementation of this pattern.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor284"/>Real-world examples</h2>
			<p>The abstract factory<a id="_idIndexMarker1157"/> is used in car manufacturing. The same machinery is used for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different car models. The model that is assembled by the machinery is configurable and easy to change at any time.</p>
			<p>In the software category, the <code>factory_boy</code> (<a href="https://github.com/FactoryBoy/factory_boy">https://github.com/FactoryBoy/factory_boy</a>) package provides an abstract factory implementation for creating Django models in tests. It is used to create instances of models that support <strong class="bold">test-specific attributes</strong>. This is important because, this<a id="_idIndexMarker1158"/> way, your tests become readable, and you avoid sharing unnecessary code.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Django models are special<a id="_idIndexMarker1159"/> classes that are used by the framework to help store and interact with data in the database (tables). See the Django<a id="_idIndexMarker1160"/> documentation (<a href="https://docs.djangoproject.com">https://docs.djangoproject.com</a>) for more details.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor285"/>Use cases</h2>
			<p>Since the abstract factory pattern<a id="_idIndexMarker1161"/> is a generalization of the factory method pattern, it offers the same benefits, it makes tracking an object creation easier, it decouples object creation from object usage, and it gives us the potential to improve the memory usage and performance of our application.</p>
			<p>But a question is raised: <em class="italic">How do we know when to use the factory method versus using an abstract factory?</em> The answer is that we usually start with the factory method, which is simpler. If we find out that our application requires many factory methods, which it makes sense to combine to create a family of objects, we end up with an abstract factory.</p>
			<p>A benefit of the abstract factory that is usually not very visible from a user's point of view when they're using the factory method is that we can modify the behavior of our application dynamically (at runtime) by changing the active factory method. The classic example is the ability to change the look and feel of an application (for example, Apple-like, Windows-like, and so on) for the user while the application is in use, without the need to terminate it and start it again.</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor286"/>Implementing the abstract factory pattern</h2>
			<p>To demonstrate the abstract factory<a id="_idIndexMarker1162"/> pattern, I will reuse one of my favorite examples, which is included in the book <em class="italic">Python 3 Patterns, Recipes, and Idioms</em>, by Bruce Eckel. Imagine that we are creating a game, or we want to include a mini-game as part of our application to entertain our users. We want to include at least two games – one for children and one for adults. We will decide which game to create and launch at runtime, based on user input. An abstract factory takes care of the game creation part.</p>
			<p>Let's start with the kid's game. It is called <em class="italic">FrogWorld</em>. The main hero is a frog who enjoys eating bugs. Every hero needs a good name, and in our case, the name is given by the user at runtime. The <code>interact_with()</code> method is used to describe how the frog interacts with an obstacle (for example, a bug, a puzzle, and other frogs), as follows:</p>
			<pre>class Frog:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def interact_with(self, obstacle):
        act = obstacle.action()
        msg = f'{self} the Frog encounters {obstacle} 
          and {act}!'
        print(msg)</pre>
			<p>There can be many different kinds of obstacles<a id="_idIndexMarker1163"/> but for our example, an obstacle can only be a bug. When the frog encounters a bug, only one action is supported. It eats it:</p>
			<pre>class Bug:
    def __str__(self):
        return 'a bug'
    def action(self):
        return 'eats it'</pre>
			<p>The <code>FrogWorld</code> class is an abstract factory. Its main responsibilities are creating the main character and the obstacle(s) in the game. Keeping the creation methods separate and their names generic (for example, <code>make_character()</code> and <code>make_obstacle()</code>) allows us to change the active factory (and therefore the active game) dynamically without making any code changes. In a statically typed language, the abstract factory would be an abstract class/interface with empty methods, but in Python, this is not required because the types<a id="_idIndexMarker1164"/> are checked at runtime (<a href="http://j.mp/ginstromdp">j.mp/ginstromdp</a>). The code is as follows:</p>
			<pre>class FrogWorld:
    def __init__(self, name):
        print(self)
        self.player_name = name
    def __str__(self):
        return '\n\n\t------ Frog World -------'
    def make_character(self):
        return Frog(self.player_name)
    def make_obstacle(self):
        return Bug()</pre>
			<p>The <em class="italic">WizardWorld</em> game is similar. The only difference is that the wizard battles against monsters such as orcs instead of eating bugs!</p>
			<p>Here is the definition of the <code>Wizard</code> class, which is similar to the <code>Frog</code> one:</p>
			<pre>class Wizard:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return self.name
    def interact_with(self, obstacle):
        act = obstacle.action()
        msg = f'{self} the Wizard battles against 
          {obstacle} and {act}!'
        print(msg)</pre>
			<p>Then, the definition<a id="_idIndexMarker1165"/> of the <code>Ork</code> class is as follows:</p>
			<pre>class Ork: 
    def __str__(self): 
        return 'an evil ork' 
 
    def action(self): 
        return 'kills it'</pre>
			<p>We also need to define the <code>WizardWorld</code> class, similar to the <code>FrogWorld</code> one that we have discussed; the obstacle, in this case, is an <code>Ork</code> instance:</p>
			<pre>class WizardWorld: 
    def __init__(self, name): 
        print(self) 
        self.player_name = name 
 
    def __str__(self): 
        return '\n\n\t------ Wizard World -------' 
 
    def make_character(self): 
        return Wizard(self.player_name) 
 
    def make_obstacle(self): 
        return Ork()</pre>
			<p>The <code>GameEnvironment</code> class is the main entry point of our game. It accepts the factory as input<a id="_idIndexMarker1166"/> and uses it to create the world of the game. The <code>play()</code> method initiates the interaction between the created hero and the obstacle, as follows:</p>
			<pre>class GameEnvironment:
    def __init__(self, factory):
        self.hero = factory.make_character()
        self.obstacle = factory.make_obstacle()
    def play(self):
        self.hero.interact_with(self.obstacle)</pre>
			<p>The <code>validate_age()</code> function prompts the user to give a valid age. If the age is not valid, it returns a tuple with the first element set to <code>False</code>. If the age is fine, the first element of the tuple is set to <code>True</code>. This is where we care about the second element of the tuple, which is the age given by the user, as follows:</p>
			<pre>def validate_age(name):
    try:
        age = input(f'Welcome {name}. How old are you? ')
        age = int(age)
    except ValueError as err:
        print(f"Age {age} is invalid, please try again...")
        return (False, age)
    return (True, age)</pre>
			<p>Last but not least comes the <code>main()</code> function. It asks for the user's name and age, and decides which game should be played, given the age of the user, as follows:</p>
			<pre>def main():
    name = input("Hello. What's your name? ")
    valid_input = False
    while not valid_input:
        valid_input, age = validate_age(name)
    game = FrogWorld if age &lt; 18 else WizardWorld
    environment = GameEnvironment(game(name))
    environment.play()</pre>
			<p>The following is a summary of the implementation<a id="_idIndexMarker1167"/> we just discussed (see the complete code in the <code>abstract_factory.py</code> file):</p>
			<ol>
				<li value="1">First, we define the <code>Frog</code> and <code>Bug</code> classes for the FrogWorld game.</li>
				<li>We add the <code>FrogWorld</code> class, where we use our <code>Frog</code> and <code>Bug</code> classes.</li>
				<li>We define the <code>Wizard</code> and <code>Ork</code> classes for the WizardWorld game.</li>
				<li>We add the <code>WizardWorld</code> class, where we use our <code>Wizard</code> and <code>Ork</code> classes.</li>
				<li>We define the <code>GameEnvironment</code> class.</li>
				<li>We add the <code>validate_age()</code> function.</li>
				<li>Finally, we have the <code>main()</code> function, followed by the conventional trick for calling it. The following are the aspects of this function:<ul><li>We get the user's input for their name and age.</li><li>We decide which game class to use based on the user's age.</li><li>We instantiate the right game class, and then the <code>GameEnvironment</code> class.</li><li>We call <code>play()</code> on the environment object to play the game.</li></ul></li>
			</ol>
			<p>Let's call this program using the <code>python abstract_factory.py</code> command and see some sample output.</p>
			<p>The sample output for a teenager is as follows:</p>
			<pre>Hello. What's your name? Billy
Welcome Billy. How old are you? 12
     ------ Frog World -------
Billy the Frog encounters a bug and eats it!</pre>
			<p>The sample output for an adult is as follows:</p>
			<pre>Hello. What's your name? Charles
Welcome Charles. How old are you? 25
     ------ Wizard World -------
Charles the Wizard battles against an evil ork and kills 
it!</pre>
			<p>Try extending the game<a id="_idIndexMarker1168"/> to make it more complete. You can go as far as you want; create many obstacles, many enemies, and whatever else you like.</p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor287"/>Summary</h1>
			<p>In this chapter, we learned how to use the factory method and the abstract factory design patterns. Both patterns are used when we want to track object creation, decouple object creation from object usage, or even improve the performance and resource usage of an application. Improving performance was not demonstrated in this chapter. You may consider trying it as a good exercise.</p>
			<p>The factory method design pattern is implemented as a single function that doesn't belong to any class and is responsible for creating a single kind of object (a shape, a connection point, and so on). We saw how the factory method relates to toy construction, mentioned how it is used by Django to create different form fields, and discussed other possible use cases for it. As an example, we implemented a factory method that provided access to XML and JSON files.</p>
			<p>The abstract factory design pattern is implemented as several factory methods that belong to a single class and are used to create a family of related objects (the parts of a car, the environment of a game, and so forth). We mentioned how the abstract factory is related to car manufacturing, how the <code>django_factory</code> package for Django makes use of it to create clean tests, and then we covered its common use cases. Our implementation example of the abstract factory was a mini-game that shows how we can use many related factories in a single class.</p>
			<p>In the next chapter, we will discuss the builder pattern, which is another creational pattern that can be used for fine-tuning the creation of complex objects.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor288"/>Questions</h1>
			<ol>
				<li value="1">What are the high-level benefits of using the factory pattern?</li>
				<li>What are the two forms of the factory pattern and their main differences?</li>
				<li>How should we decide which form of the factory pattern we should use when building an application?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>