<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer181">
			<h1 id="_idParaDest-295"><em class="italic"><a id="_idTextAnchor276"/>Chapter 16</em>: The Factory Pattern</h1>
			<p><strong class="bold">Design patterns</strong> are reusable programming solutions that have been used in various real-world contexts and have proved to produce the expected results. In this chapter, we will learn about one of the most common design patterns: the factory design pattern. As we will see later, this pattern makes it easier to track which objects are created within a program, thus separating the code that creates an object from the code that uses it. We will study the factory design pattern's two forms: the <strong class="bold">factory method</strong> and the <strong class="bold">abstract method</strong>.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding design patterns</li>
				<li>Implementing the factory method</li>
				<li>Applying the abstract factory</li>
			</ul>
			<p>By the end of this chapter, we will have gained a deep understanding of the factory design pattern and its benefits via a hands-on example.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor277"/>Technical requirements</h1>
			<p>The code files for this chapter can be found at <a href="https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16">https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter16</a>.</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor278"/>Understanding design patterns</h1>
			<p>Design patterns are shared among programmers<a id="_idIndexMarker1123"/> and continue to be improved over time. This topic is popular thanks to the book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, titled <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>.</p>
			<p class="callout-heading">Gang of Four</p>
			<p class="callout">The book by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides is also called the <em class="italic">Gang of Four</em> book for short (or the <em class="italic">GOF</em> book for an even shorter name).</p>
			<p>Generally, a design pattern helps the programmer create<a id="_idIndexMarker1124"/> a commonly used implementation pattern, especially in <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>). The benefits of viewing<a id="_idIndexMarker1125"/> applications from the design pattern's perspective are plenty. First, it narrows down the most effective ways of building a given application and the necessary steps to do it. Second, you could consult existing examples of the same design pattern to improve your application. Overall, design patterns are highly useful guidelines in software engineering.</p>
			<p>There are several categories of design patterns that are used in OOP, depending on the type of problem they address and/or the types of solutions they help us build. In their book, the <em class="italic">Gang of Four</em> presents 23 design<a id="_idIndexMarker1126"/> patterns, split<a id="_idIndexMarker1127"/> into three categories: <strong class="bold">creational</strong>, <strong class="bold">structural</strong>, and <strong class="bold">behavioral</strong>.</p>
			<p><strong class="bold">Creational design patterns</strong> are the first category we will cover<a id="_idIndexMarker1128"/> in this chapter; <a href="B17499_17_Final_SS_ePub.xhtml#_idTextAnchor289"><em class="italic">Chapter 17</em></a>, <em class="italic">The Builder Pattern</em>, and <a href="B17499_18_Final_SS_ePub.xhtml#_idTextAnchor297"><em class="italic">Chapter 18</em></a>, <em class="italic">Other Creational Patterns</em>, will cover the latter. These patterns deal with different aspects of object creation. Their goal is to provide better alternatives for situations where direct object creation, which in Python happens within the <strong class="source-inline">__init__()</strong> function, is not convenient.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">See <a href="https://docs.python.org/3/tutorial/classes.html">https://docs.python.org/3/tutorial/classes.html</a> for a quick overview of object classes<a id="_idIndexMarker1129"/> and the special <strong class="source-inline">__init__()</strong> method that Python uses to initialize a new class instance.</p>
			<p>We will start with the first creational design<a id="_idIndexMarker1130"/> pattern from the <em class="italic">Gang of Four</em> book: the <strong class="bold">factory design pattern</strong>. In the factory design pattern, a <strong class="bold">client</strong> (meaning client code) asks for an object without knowing where the object is coming from (that is, which class is used to generate it). The idea behind a factory is to simplify the object creation process. It is easier to track which objects are created if this is done through a central function, compared to letting a client create objects using a direct class instantiation. A factory reduces the complexity of maintaining an application by decoupling the code that creates an object from the code that uses it.</p>
			<p>Factories typically come<a id="_idIndexMarker1131"/> in two forms: the <strong class="bold">factory method</strong>, which is a method (or simply a function for a Python developer) that returns a different object<a id="_idIndexMarker1132"/> per input parameter, and the <strong class="bold">abstract factory</strong>, which is a group of factory methods that are used to create a family<a id="_idIndexMarker1133"/> of related objects.</p>
			<p>That is all the theory we need to get started. In the next section, we will discuss the factory method.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor279"/>Implementing the factory method</h1>
			<p>The factory method<a id="_idIndexMarker1134"/> is based on a single function that's written to handle our object creation task. We execute it, passing a parameter that provides information about what we want. As a result, the object we wanted is created.</p>
			<p>Interestingly, when we use the factory method, we don't need to know any details about how the resulting object is implemented and where it is coming from. First, we will discuss some real-life applications that use the factory method and then implement an example application that processes XML and JSON files.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor280"/>Real-world examples </h2>
			<p>An example of the factory<a id="_idIndexMarker1135"/> method pattern that's used in real life is in the context of a plastic toy construction kit. The molding material that's used to construct plastic toys is the same, but different toys (different figures or shapes) can be produced using the right plastic molds. This is like having a factory method in which the input is the name of the toy that we want (for example, <strong class="source-inline">duck</strong> or <strong class="source-inline">car</strong>) and the output (after the molding) is the plastic toy that was requested.</p>
			<p>In the software world, the <em class="italic">Django</em> web framework uses the factory method pattern to create the fields of a web form. The <strong class="source-inline">forms</strong> module, which is included in Django, supports the ability to create different kinds of fields (for example, <strong class="source-inline">CharField</strong>, <strong class="source-inline">EmailField</strong>, and so on). Parts of their behavior can be customized using attributes such as <strong class="source-inline">max_length</strong> or <strong class="source-inline">required</strong> (<a href="http://j.mp/djangofac">j.mp/djangofac</a>).</p>
			<p>Consider the following example:</p>
			<p class="source-code">from django import forms</p>
			<p class="source-code">class PersonForm(forms.Form):</p>
			<p class="source-code">    name = forms.CharField(max_length=100)</p>
			<p class="source-code">    birth_date = forms.DateField(required=False)</p>
			<p>The preceding code could be written by a developer for a form (the <strong class="source-inline">PersonForm</strong> form, which<a id="_idIndexMarker1136"/> contains the <strong class="source-inline">name</strong> and <strong class="source-inline">birth_date</strong> fields) as part of a Django application's UI code.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor281"/>Use cases</h2>
			<p>If you realize that you cannot track<a id="_idIndexMarker1137"/> the objects that are created by your application because the code that creates them is in many different places instead of in a single function/method, you should consider using the factory method pattern. The factory method centralizes object creation and tracking your objects becomes much easier. Note that it is absolutely fine to create more than one factory method, and this is how it is typically done in practice. Each factory method logically groups objects that have similarities. For example, one factory method might be responsible for connecting you to different databases (MySQL and SQLite), another factory method might be responsible for creating the geometrical object that you've requested (circle and triangle), and so on.</p>
			<p>The factory method is also useful when you want to decouple object creation from object usage. We are not coupled/bound to a specific class when creating an object; we just provide partial information about what we want by calling a function. This means that introducing changes to the function is easy and does not require any changes to be made to the code that uses it.</p>
			<p>Another use case worth mentioning is related to improving the performance and memory usage of an application. A factory method can improve performance and memory usage by creating new objects only if it is necessary. When we create objects using a direct class instantiation, extra memory is allocated every time a new object is created (unless the class uses caching internally, which is usually not the case). We can see that, in practice, in the following code (in the <strong class="source-inline">id.py</strong> file), it creates two instances of the same class, <strong class="source-inline">A</strong>, and uses<a id="_idIndexMarker1138"/> the <strong class="source-inline">id()</strong> function to compare their <strong class="bold">memory addresses</strong>. These addresses are also printed in the output so that we can inspect them. The fact that the memory addresses are different means that two distinct objects are created, as follows:</p>
			<p class="source-code">class A:</p>
			<p class="source-code">    pass</p>
			<p class="source-code">if __name__ == '__main__':</p>
			<p class="source-code">    a = A()</p>
			<p class="source-code">    b = A()    </p>
			<p class="source-code">    print(id(a) == id(b))</p>
			<p class="source-code">    print(a, b)</p>
			<p>Executing the <strong class="source-inline">python id.py</strong> command on my computer results in the following output:</p>
			<p class="source-code">False</p>
			<p class="source-code">&lt;__main__.A object at 0x7f5771de8f60&gt; &lt;__main__.A object at </p>
			<p class="source-code">0x7f5771df2208&gt;</p>
			<p>Note that the addresses that you see if you execute the file are not the same as the ones I can see because they depend on the current memory layout and allocation. But the result must be the same: the two addresses should be different. There's one exception that happens if you write<a id="_idIndexMarker1139"/> and execute the code in the Python <strong class="bold">Read-Eval-Print Loop</strong> (<strong class="bold">REPL</strong>) – or, simply put, the interactive<a id="_idIndexMarker1140"/> prompt – but that's a REPL-specific optimization that does not happen normally.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor282"/>Implementing the factory method</h2>
			<p>Data comes in many forms. There are two main<a id="_idIndexMarker1141"/> file categories for storing/retrieving data: human-readable files and binary files. Examples of human-readable files include XML, RSS/Atom, YAML, and JSON. Examples of binary files include the <strong class="source-inline">.sq3</strong> file format that's used by SQLite and the <strong class="source-inline">.mp3</strong> audio file format, which is used to listen to music.</p>
			<p>In this example, we will focus on two popular human-readable formats: <strong class="bold">XML</strong> and <strong class="bold">JSON</strong>. Although human-readable files<a id="_idIndexMarker1142"/> are generally slower to parse than binary<a id="_idIndexMarker1143"/> files, they make data exchange, inspection, and modification much easier. For this reason, it is advised that you work with human-readable files<a id="_idIndexMarker1144"/> unless other restrictions do not allow it (mainly unacceptable performance and proprietary binary formats).</p>
			<p>In this case, we have some input data stored in an XML file and a JSON file, and we want to parse them and retrieve some information. At the same time, we want to centralize the client's connection to those (and all future) external services. We will use the factory method to solve this problem. This example focuses only on XML and JSON but adding support for more services should be straightforward.</p>
			<p>First, let's take a look at the data files.</p>
			<p>The JSON file, <strong class="source-inline">movies.json</strong>, which can be found in the <strong class="source-inline">data</strong> subfolder of this chapter's code folder, is an example of a dataset containing information about American movies (title, year, director name, genre, and so on). This is a big file but here is a portion of its content to illustrate how its content is organized:</p>
			<p class="source-code">[</p>
			<p class="source-code"> {"title":"After Dark in Central Park",</p>
			<p class="source-code">  "year":1900, </p>
			<p class="source-code">  "director":null, "cast":null, "genre":null},</p>
			<p class="source-code"> {"title":"Boarding School Girls' Pajama Parade",</p>
			<p class="source-code">  "year":1900, </p>
			<p class="source-code">  "director":null, "cast":null, "genre":null},</p>
			<p class="source-code"> {"title":"Buffalo Bill's Wild West Parad",</p>
			<p class="source-code">  "year":1900, </p>
			<p class="source-code">  "director":null, "cast":null, "genre":null},</p>
			<p class="source-code"> {"title":"Caught",</p>
			<p class="source-code">  "year":1900, </p>
			<p class="source-code">  "director":null, "cast":null, "genre":null},</p>
			<p class="source-code"> {"title":"Clowns Spinning Hats",</p>
			<p class="source-code">  "year":1900, </p>
			<p class="source-code">  "director":null, "cast":null, "genre":null},</p>
			<p class="source-code"> ...</p>
			<p class="source-code">  ]</p>
			<p>The XML file, <strong class="source-inline">person.xml</strong>, is based on a Wikipedia example (<a href="http://j.mp/wikijson">j.mp/wikijson</a>) and contains information<a id="_idIndexMarker1145"/> about individuals (<strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName</strong>, <strong class="source-inline">gender</strong>, and so on), as follows:</p>
			<ol>
				<li>We start with the enclosing tag of the <strong class="source-inline">persons</strong> XML container:<p class="source-code">&lt;persons&gt; </p></li>
				<li>Then, an XML element representing a person's data code is presented, as follows:<p class="source-code">&lt;person&gt; </p><p class="source-code">  &lt;firstName&gt;John&lt;/firstName&gt; </p><p class="source-code">  &lt;lastName&gt;Smith&lt;/lastName&gt; </p><p class="source-code">  &lt;age&gt;25&lt;/age&gt; </p><p class="source-code">  &lt;address&gt; </p><p class="source-code">    &lt;streetAddress&gt;21 2nd Street&lt;/streetAddress&gt; </p><p class="source-code">    &lt;city&gt;New York&lt;/city&gt; </p><p class="source-code">    &lt;state&gt;NY&lt;/state&gt; </p><p class="source-code">    &lt;postalCode&gt;10021&lt;/postalCode&gt; </p><p class="source-code">  &lt;/address&gt; </p><p class="source-code">  &lt;phoneNumbers&gt; </p><p class="source-code">    &lt;phoneNumber type="home"&gt;</p><p class="source-code">      212 555-1234&lt;/phoneNumber&gt; </p><p class="source-code">    &lt;phoneNumber type="fax"&gt;646 555-4567&lt;/phoneNumber&gt; </p><p class="source-code">  &lt;/phoneNumbers&gt; </p><p class="source-code">  &lt;gender&gt; </p><p class="source-code">    &lt;type&gt;male&lt;/type&gt; </p><p class="source-code">  &lt;/gender&gt; </p><p class="source-code">&lt;/person&gt; </p></li>
				<li>An XML element representing<a id="_idIndexMarker1146"/> another person's data must then be provided:<p class="source-code">&lt;person&gt; </p><p class="source-code">  &lt;firstName&gt;Jimy&lt;/firstName&gt; </p><p class="source-code">  &lt;lastName&gt;Liar&lt;/lastName&gt; </p><p class="source-code">  &lt;age&gt;19&lt;/age&gt; </p><p class="source-code">  &lt;address&gt; </p><p class="source-code">    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt; </p><p class="source-code">    &lt;city&gt;New York&lt;/city&gt; </p><p class="source-code">    &lt;state&gt;NY&lt;/state&gt; </p><p class="source-code">    &lt;postalCode&gt;10021&lt;/postalCode&gt; </p><p class="source-code">  &lt;/address&gt; </p><p class="source-code">  &lt;phoneNumbers&gt; </p><p class="source-code">  &lt;phoneNumber type="home"&gt;212 555-1234&lt;/phoneNumber&gt; </p><p class="source-code">  &lt;/phoneNumbers&gt; </p><p class="source-code">  &lt;gender&gt; </p><p class="source-code">    &lt;type&gt;male&lt;/type&gt; </p><p class="source-code">  &lt;/gender&gt; </p><p class="source-code">&lt;/person&gt; </p></li>
				<li>An XML element representing a third person's data is then shown:<p class="source-code">&lt;person&gt; </p><p class="source-code">  &lt;firstName&gt;Patty&lt;/firstName&gt; </p><p class="source-code">  &lt;lastName&gt;Liar&lt;/lastName&gt; </p><p class="source-code">  &lt;age&gt;20&lt;/age&gt; </p><p class="source-code">  &lt;address&gt; </p><p class="source-code">    &lt;streetAddress&gt;18 2nd Street&lt;/streetAddress&gt; </p><p class="source-code">    &lt;city&gt;New York&lt;/city&gt; </p><p class="source-code">    &lt;state&gt;NY&lt;/state&gt; </p><p class="source-code">    &lt;postalCode&gt;10021&lt;/postalCode&gt; </p><p class="source-code">  &lt;/address&gt; </p><p class="source-code">  &lt;phoneNumbers&gt; </p><p class="source-code">    &lt;phoneNumber type="home"&gt;</p><p class="source-code">      212 555-1234&lt;/phoneNumber&gt; </p><p class="source-code">    &lt;phoneNumber type="mobile"&gt;</p><p class="source-code">      001 452-8819&lt;/phoneNumber&gt; </p><p class="source-code">  &lt;/phoneNumbers&gt; </p><p class="source-code">  &lt;gender&gt; </p><p class="source-code">    &lt;type&gt;female&lt;/type&gt; </p><p class="source-code">  &lt;/gender&gt; </p><p class="source-code">&lt;/person&gt; </p></li>
				<li>Finally, we must close<a id="_idIndexMarker1147"/> the XML container:<p class="source-code">&lt;/persons&gt;</p></li>
				<li>We will use two libraries that are part of the Python distribution for working with JSON and XML, <strong class="source-inline">json</strong> and <strong class="source-inline">xml.etree.ElementTree</strong>, as follows:<p class="source-code">import json</p><p class="source-code">import xml.etree.ElementTree as etree</p></li>
				<li>The <strong class="source-inline">JSONDataExtractor</strong> class parses the JSON file and has a <strong class="source-inline">parsed_data()</strong> method that returns<a id="_idIndexMarker1148"/> all the data as a dictionary (<strong class="source-inline">dict</strong>). The property decorator is used to make <strong class="source-inline">parsed_data()</strong> appear as a normal attribute instead of a method, as follows:<p class="source-code">class JSONDataExtractor:</p><p class="source-code">  def __init__(self, filepath):</p><p class="source-code">    self.data = dict()</p><p class="source-code">    with open(filepath, mode='r', encoding='utf-8') as </p><p class="source-code">    f:self.data = json.load(f)</p><p class="source-code">    @property</p><p class="source-code">    def parsed_data(self):</p><p class="source-code">        return self.data</p></li>
				<li>The <strong class="source-inline">XMLDataExtractor</strong> class parses the XML file and has a <strong class="source-inline">parsed_data()</strong> method that returns all the data as a list of <strong class="source-inline">xml.etree.Element</strong>, as follows:<p class="source-code">class XMLDataExtractor:</p><p class="source-code">  def __init__(self, filepath):</p><p class="source-code">    self.tree =  etree.parse(filepath)</p><p class="source-code">  @property</p><p class="source-code">  def parsed_data(self):</p><p class="source-code">  return self.tree</p></li>
				<li>The <strong class="source-inline">dataextraction_factory()</strong> function is a factory method. It returns an instance of <strong class="source-inline">JSONDataExtractor</strong> or <strong class="source-inline">XMLDataExtractor</strong>, depending on the extension of the input file path, as follows:<p class="source-code">def dataextraction_factory(filepath):</p><p class="source-code">    if filepath.endswith('json'):</p><p class="source-code">        extractor = JSONDataExtractor</p><p class="source-code">    elif filepath.endswith('xml'):</p><p class="source-code">        extractor = XMLDataExtractor</p><p class="source-code">    else:</p><p class="source-code">        raise ValueError('Cannot extract data from </p><p class="source-code">          {}'.format(filepath))</p><p class="source-code">    return extractor(filepath)</p></li>
				<li>The <strong class="source-inline">extract_data_from()</strong> function is a wrapper of <strong class="source-inline">dataextraction_factory()</strong>. It adds exception<a id="_idIndexMarker1149"/> handling, as follows:<p class="source-code">def extract_data_from(filepath):</p><p class="source-code">    factory_obj = None</p><p class="source-code">    try:</p><p class="source-code">        factory_obj = dataextraction_factory(filepath)</p><p class="source-code">    except ValueError as e:</p><p class="source-code">        print(e)</p><p class="source-code">    return factory_obj</p></li>
				<li>The <strong class="source-inline">main()</strong> function demonstrates how the factory method design pattern can be used. The first part makes sure that exception handling is effective, as follows:<p class="source-code">def main():</p><p class="source-code">    sqlite_factory = </p><p class="source-code">      extract_data_from('data/person.sq3')</p><p class="source-code">    print()</p></li>
				<li>The next part shows how to work with the JSON files using the factory method. Based<a id="_idIndexMarker1150"/> on the parsing, the title, year, director name, and genre of the movie can be shown (when the value is not empty), as follows:<p class="source-code">json_factory = extract_data_from('data/movies.json')</p><p class="source-code">json_data = json_factory.parsed_data</p><p class="source-code">print(f'Found: {len(json_data)} movies')</p><p class="source-code">for movie in json_data:</p><p class="source-code">  print(f"Title: {movie['title']}")</p><p class="source-code">  year = movie['year']</p><p class="source-code">  if year:</p><p class="source-code">  print(f"Year: {year}")</p><p class="source-code">  director = movie['director']</p><p class="source-code">  if director:</p><p class="source-code">  print(f"Director: {director}")</p><p class="source-code">  genre = movie['genre']</p><p class="source-code">  if genre:</p><p class="source-code">  print(f"Genre: {genre}")</p><p class="source-code">  print()</p></li>
				<li>The final part shows you how to work with the XML files using the factory method. XPath is used to find all the person elements that have <strong class="source-inline">Liar</strong> as the last name (using <strong class="source-inline">liars = xml_data.findall(f".//person[lastName='Liar']")</strong>). For each matched person, their basic name and phone number information is shown, as follows:<p class="source-code">xml_factory = extract_data_from('data/person.xml')</p><p class="source-code">xml_data = xml_factory.parsed_data</p><p class="source-code">liars = </p><p class="source-code">  xml_data.findall(f".//person[lastName='Liar']")</p><p class="source-code">print(f'found: {len(liars)} persons')</p><p class="source-code">for liar in liars:</p><p class="source-code">    firstname = liar.find('firstName').text</p><p class="source-code">    print(f'first name: {firstname}')</p><p class="source-code">    lastname = liar.find('lastName').text</p><p class="source-code">    print(f'last name: {lastname}')</p><p class="source-code">    [print(f"phone number ({p.attrib['type']}):", </p><p class="source-code">      p.text) </p><p class="source-code">    for p in liar.find('phoneNumbers')]</p><p class="source-code">    print()</p></li>
			</ol>
			<p>Here is the summary of the<a id="_idIndexMarker1151"/> implementation (you can find the code in the <strong class="source-inline">factory_method.py</strong> file):</p>
			<ol>
				<li value="1">We start by importing the modules we need (<strong class="source-inline">json</strong> and <strong class="source-inline">ElementTree</strong>).</li>
				<li>We define the JSON data extractor class (<strong class="source-inline">JSONDataExtractor</strong>).</li>
				<li>We define the XML data extractor class (<strong class="source-inline">XMLDataExtractor</strong>).</li>
				<li>We add the factory function, <strong class="source-inline">dataextraction_factory()</strong>, to get the right data extractor class.</li>
				<li>We also add our wrapper for handling exceptions – the <strong class="source-inline">extract_data_from()</strong> function.</li>
				<li>Finally, we have the <strong class="source-inline">main()</strong> function, followed by Python's conventional trick for calling it when invoking this file from the command line. The following are the aspects of the <strong class="source-inline">main</strong> function:<ul><li>We try to extract data from a SQL file (<strong class="source-inline">data/person.sq3</strong>) to show how the exception is handled.</li><li>We extract data from a JSON file and parse the result.</li><li>We extract data from an XML file and parse the result.</li></ul></li>
			</ol>
			<p>The following<a id="_idIndexMarker1152"/> is the type of output (for the different cases) you will get by calling the <strong class="source-inline">python factory_method.py</strong> command.</p>
			<p>First, there is an exception message that you'll see when you try to access a SQLite (<strong class="source-inline">.sq3</strong>) file:</p>
			<p class="source-code">Cannot extract data from data/person.sq3</p>
			<p>Then, we get the following result from processing the <strong class="source-inline">movies</strong> file (JSON):</p>
			<p class="source-code">Found: 9 movies</p>
			<p class="source-code">Title: After Dark in Central Park</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Title: Boarding School Girls' Pajama Parade</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Title: Buffalo Bill's Wild West Parad</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Title: Caught</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Title: Clowns Spinning Hats</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Title: Capture of Boer Battery by British</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Director: James H. White</p>
			<p class="source-code">Genre: Short documentary</p>
			<p class="source-code">Title: The Enchanted Drawing</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Director: J. Stuart Blackton</p>
			<p class="source-code">Title: Family Troubles</p>
			<p class="source-code">Year: 1900</p>
			<p class="source-code">Title: Feeding Sea Lions</p>
			<p class="source-code">Year: 1900</p>
			<p>Finally, we get this result<a id="_idIndexMarker1153"/> from processing the <strong class="source-inline">person</strong> XML file to find the people whose last name is <strong class="source-inline">Liar</strong>:</p>
			<p class="source-code">found: 2 persons</p>
			<p class="source-code">first name: Jimy</p>
			<p class="source-code">last name: Liar</p>
			<p class="source-code">phone number (home): 212 555-1234</p>
			<p class="source-code">first name: Patty</p>
			<p class="source-code">last name: Liar</p>
			<p class="source-code">phone number (home): 212 555-1234</p>
			<p class="source-code">phone number (mobile): 001 452-8819</p>
			<p>Notice that although <strong class="source-inline">JSONDataExtractor</strong> and <strong class="source-inline">XMLDataExtractor</strong> have the same interfaces, what is returned by <strong class="source-inline">parsed_data()</strong> is not handled uniformly. Different Python<a id="_idIndexMarker1154"/> code must be used to work with each <strong class="bold">data extractor</strong>. Although it would be nice to be able to use the same code for all extractors, this is not realistic for the most part, unless we use some kind of common mapping for the data, which is often provided by external data providers. A useful exercise would be to assume that you can use the same code to handle the XML and JSON files and see what changes are required to support a third format, such as SQLite. Find a SQLite file or create your own and try it.</p>
			<p>At this point, we have learned<a id="_idIndexMarker1155"/> about the factory method, which, again, is the first form of the factory design pattern. In the next section, we will talk about the second: the abstract factory design pattern.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor283"/>Applying the abstract factory</h1>
			<p>The abstract factory design<a id="_idIndexMarker1156"/> pattern is a generalization of the factory method. An abstract factory is a (logical) group of factory methods, where each factory method is responsible for generating a different kind of object.</p>
			<p>In this section, we are going to discuss some examples, use cases, and a possible implementation of this pattern.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor284"/>Real-world examples</h2>
			<p>The abstract factory<a id="_idIndexMarker1157"/> is used in car manufacturing. The same machinery is used for stamping the parts (doors, panels, hoods, fenders, and mirrors) of different car models. The model that is assembled by the machinery is configurable and easy to change at any time.</p>
			<p>In the software category, the <strong class="source-inline">factory_boy</strong> (<a href="https://github.com/FactoryBoy/factory_boy">https://github.com/FactoryBoy/factory_boy</a>) package provides an abstract factory implementation for creating Django models in tests. It is used to create instances of models that support <strong class="bold">test-specific attributes</strong>. This is important because, this<a id="_idIndexMarker1158"/> way, your tests become readable, and you avoid sharing unnecessary code.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Django models are special<a id="_idIndexMarker1159"/> classes that are used by the framework to help store and interact with data in the database (tables). See the Django<a id="_idIndexMarker1160"/> documentation (<a href="https://docs.djangoproject.com">https://docs.djangoproject.com</a>) for more details.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor285"/>Use cases</h2>
			<p>Since the abstract factory pattern<a id="_idIndexMarker1161"/> is a generalization of the factory method pattern, it offers the same benefits, it makes tracking an object creation easier, it decouples object creation from object usage, and it gives us the potential to improve the memory usage and performance of our application.</p>
			<p>But a question is raised: <em class="italic">How do we know when to use the factory method versus using an abstract factory?</em> The answer is that we usually start with the factory method, which is simpler. If we find out that our application requires many factory methods, which it makes sense to combine to create a family of objects, we end up with an abstract factory.</p>
			<p>A benefit of the abstract factory that is usually not very visible from a user's point of view when they're using the factory method is that we can modify the behavior of our application dynamically (at runtime) by changing the active factory method. The classic example is the ability to change the look and feel of an application (for example, Apple-like, Windows-like, and so on) for the user while the application is in use, without the need to terminate it and start it again.</p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor286"/>Implementing the abstract factory pattern</h2>
			<p>To demonstrate the abstract factory<a id="_idIndexMarker1162"/> pattern, I will reuse one of my favorite examples, which is included in the book <em class="italic">Python 3 Patterns, Recipes, and Idioms</em>, by Bruce Eckel. Imagine that we are creating a game, or we want to include a mini-game as part of our application to entertain our users. We want to include at least two games – one for children and one for adults. We will decide which game to create and launch at runtime, based on user input. An abstract factory takes care of the game creation part.</p>
			<p>Let's start with the kid's game. It is called <em class="italic">FrogWorld</em>. The main hero is a frog who enjoys eating bugs. Every hero needs a good name, and in our case, the name is given by the user at runtime. The <strong class="source-inline">interact_with()</strong> method is used to describe how the frog interacts with an obstacle (for example, a bug, a puzzle, and other frogs), as follows:</p>
			<p class="source-code">class Frog:</p>
			<p class="source-code">    def __init__(self, name):</p>
			<p class="source-code">        self.name = name</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return self.name</p>
			<p class="source-code">    def interact_with(self, obstacle):</p>
			<p class="source-code">        act = obstacle.action()</p>
			<p class="source-code">        msg = f'{self} the Frog encounters {obstacle} </p>
			<p class="source-code">          and {act}!'</p>
			<p class="source-code">        print(msg)</p>
			<p>There can be many different kinds of obstacles<a id="_idIndexMarker1163"/> but for our example, an obstacle can only be a bug. When the frog encounters a bug, only one action is supported. It eats it:</p>
			<p class="source-code">class Bug:</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return 'a bug'</p>
			<p class="source-code">    def action(self):</p>
			<p class="source-code">        return 'eats it'</p>
			<p>The <strong class="source-inline">FrogWorld</strong> class is an abstract factory. Its main responsibilities are creating the main character and the obstacle(s) in the game. Keeping the creation methods separate and their names generic (for example, <strong class="source-inline">make_character()</strong> and <strong class="source-inline">make_obstacle()</strong>) allows us to change the active factory (and therefore the active game) dynamically without making any code changes. In a statically typed language, the abstract factory would be an abstract class/interface with empty methods, but in Python, this is not required because the types<a id="_idIndexMarker1164"/> are checked at runtime (<a href="http://j.mp/ginstromdp">j.mp/ginstromdp</a>). The code is as follows:</p>
			<p class="source-code">class FrogWorld:</p>
			<p class="source-code">    def __init__(self, name):</p>
			<p class="source-code">        print(self)</p>
			<p class="source-code">        self.player_name = name</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return '\n\n\t------ Frog World -------'</p>
			<p class="source-code">    def make_character(self):</p>
			<p class="source-code">        return Frog(self.player_name)</p>
			<p class="source-code">    def make_obstacle(self):</p>
			<p class="source-code">        return Bug()</p>
			<p>The <em class="italic">WizardWorld</em> game is similar. The only difference is that the wizard battles against monsters such as orcs instead of eating bugs!</p>
			<p>Here is the definition of the <strong class="source-inline">Wizard</strong> class, which is similar to the <strong class="source-inline">Frog</strong> one:</p>
			<p class="source-code">class Wizard:</p>
			<p class="source-code">    def __init__(self, name):</p>
			<p class="source-code">        self.name = name</p>
			<p class="source-code">    def __str__(self):</p>
			<p class="source-code">        return self.name</p>
			<p class="source-code">    def interact_with(self, obstacle):</p>
			<p class="source-code">        act = obstacle.action()</p>
			<p class="source-code">        msg = f'{self} the Wizard battles against </p>
			<p class="source-code">          {obstacle} and {act}!'</p>
			<p class="source-code">        print(msg)</p>
			<p>Then, the definition<a id="_idIndexMarker1165"/> of the <strong class="source-inline">Ork</strong> class is as follows:</p>
			<p class="source-code">class Ork: </p>
			<p class="source-code">    def __str__(self): </p>
			<p class="source-code">        return 'an evil ork' </p>
			<p class="source-code"> </p>
			<p class="source-code">    def action(self): </p>
			<p class="source-code">        return 'kills it'</p>
			<p>We also need to define the <strong class="source-inline">WizardWorld</strong> class, similar to the <strong class="source-inline">FrogWorld</strong> one that we have discussed; the obstacle, in this case, is an <strong class="source-inline">Ork</strong> instance:</p>
			<p class="source-code">class WizardWorld: </p>
			<p class="source-code">    def __init__(self, name): </p>
			<p class="source-code">        print(self) </p>
			<p class="source-code">        self.player_name = name </p>
			<p class="source-code"> </p>
			<p class="source-code">    def __str__(self): </p>
			<p class="source-code">        return '\n\n\t------ Wizard World -------' </p>
			<p class="source-code"> </p>
			<p class="source-code">    def make_character(self): </p>
			<p class="source-code">        return Wizard(self.player_name) </p>
			<p class="source-code"> </p>
			<p class="source-code">    def make_obstacle(self): </p>
			<p class="source-code">        return Ork()</p>
			<p>The <strong class="source-inline">GameEnvironment</strong> class is the main entry point of our game. It accepts the factory as input<a id="_idIndexMarker1166"/> and uses it to create the world of the game. The <strong class="source-inline">play()</strong> method initiates the interaction between the created hero and the obstacle, as follows:</p>
			<p class="source-code">class GameEnvironment:</p>
			<p class="source-code">    def __init__(self, factory):</p>
			<p class="source-code">        self.hero = factory.make_character()</p>
			<p class="source-code">        self.obstacle = factory.make_obstacle()</p>
			<p class="source-code">    def play(self):</p>
			<p class="source-code">        self.hero.interact_with(self.obstacle)</p>
			<p>The <strong class="source-inline">validate_age()</strong> function prompts the user to give a valid age. If the age is not valid, it returns a tuple with the first element set to <strong class="source-inline">False</strong>. If the age is fine, the first element of the tuple is set to <strong class="source-inline">True</strong>. This is where we care about the second element of the tuple, which is the age given by the user, as follows:</p>
			<p class="source-code">def validate_age(name):</p>
			<p class="source-code">    try:</p>
			<p class="source-code">        age = input(f'Welcome {name}. How old are you? ')</p>
			<p class="source-code">        age = int(age)</p>
			<p class="source-code">    except ValueError as err:</p>
			<p class="source-code">        print(f"Age {age} is invalid, please try again...")</p>
			<p class="source-code">        return (False, age)</p>
			<p class="source-code">    return (True, age)</p>
			<p>Last but not least comes the <strong class="source-inline">main()</strong> function. It asks for the user's name and age, and decides which game should be played, given the age of the user, as follows:</p>
			<p class="source-code">def main():</p>
			<p class="source-code">    name = input("Hello. What's your name? ")</p>
			<p class="source-code">    valid_input = False</p>
			<p class="source-code">    while not valid_input:</p>
			<p class="source-code">        valid_input, age = validate_age(name)</p>
			<p class="source-code">    game = FrogWorld if age &lt; 18 else WizardWorld</p>
			<p class="source-code">    environment = GameEnvironment(game(name))</p>
			<p class="source-code">    environment.play()</p>
			<p>The following is a summary of the implementation<a id="_idIndexMarker1167"/> we just discussed (see the complete code in the <strong class="source-inline">abstract_factory.py</strong> file):</p>
			<ol>
				<li value="1">First, we define the <strong class="source-inline">Frog</strong> and <strong class="source-inline">Bug</strong> classes for the FrogWorld game.</li>
				<li>We add the <strong class="source-inline">FrogWorld</strong> class, where we use our <strong class="source-inline">Frog</strong> and <strong class="source-inline">Bug</strong> classes.</li>
				<li>We define the <strong class="source-inline">Wizard</strong> and <strong class="source-inline">Ork</strong> classes for the WizardWorld game.</li>
				<li>We add the <strong class="source-inline">WizardWorld</strong> class, where we use our <strong class="source-inline">Wizard</strong> and <strong class="source-inline">Ork</strong> classes.</li>
				<li>We define the <strong class="source-inline">GameEnvironment</strong> class.</li>
				<li>We add the <strong class="source-inline">validate_age()</strong> function.</li>
				<li>Finally, we have the <strong class="source-inline">main()</strong> function, followed by the conventional trick for calling it. The following are the aspects of this function:<ul><li>We get the user's input for their name and age.</li><li>We decide which game class to use based on the user's age.</li><li>We instantiate the right game class, and then the <strong class="source-inline">GameEnvironment</strong> class.</li><li>We call <strong class="source-inline">play()</strong> on the environment object to play the game.</li></ul></li>
			</ol>
			<p>Let's call this program using the <strong class="source-inline">python abstract_factory.py</strong> command and see some sample output.</p>
			<p>The sample output for a teenager is as follows:</p>
			<p class="source-code">Hello. What's your name? Billy</p>
			<p class="source-code">Welcome Billy. How old are you? 12</p>
			<p class="source-code">     ------ Frog World -------</p>
			<p class="source-code">Billy the Frog encounters a bug and eats it!</p>
			<p>The sample output for an adult is as follows:</p>
			<p class="source-code">Hello. What's your name? Charles</p>
			<p class="source-code">Welcome Charles. How old are you? 25</p>
			<p class="source-code">     ------ Wizard World -------</p>
			<p class="source-code">Charles the Wizard battles against an evil ork and kills </p>
			<p class="source-code">it!</p>
			<p>Try extending the game<a id="_idIndexMarker1168"/> to make it more complete. You can go as far as you want; create many obstacles, many enemies, and whatever else you like.</p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor287"/>Summary</h1>
			<p>In this chapter, we learned how to use the factory method and the abstract factory design patterns. Both patterns are used when we want to track object creation, decouple object creation from object usage, or even improve the performance and resource usage of an application. Improving performance was not demonstrated in this chapter. You may consider trying it as a good exercise.</p>
			<p>The factory method design pattern is implemented as a single function that doesn't belong to any class and is responsible for creating a single kind of object (a shape, a connection point, and so on). We saw how the factory method relates to toy construction, mentioned how it is used by Django to create different form fields, and discussed other possible use cases for it. As an example, we implemented a factory method that provided access to XML and JSON files.</p>
			<p>The abstract factory design pattern is implemented as several factory methods that belong to a single class and are used to create a family of related objects (the parts of a car, the environment of a game, and so forth). We mentioned how the abstract factory is related to car manufacturing, how the <strong class="source-inline">django_factory</strong> package for Django makes use of it to create clean tests, and then we covered its common use cases. Our implementation example of the abstract factory was a mini-game that shows how we can use many related factories in a single class.</p>
			<p>In the next chapter, we will discuss the builder pattern, which is another creational pattern that can be used for fine-tuning the creation of complex objects.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor288"/>Questions</h1>
			<ol>
				<li value="1">What are the high-level benefits of using the factory pattern?</li>
				<li>What are the two forms of the factory pattern and their main differences?</li>
				<li>How should we decide which form of the factory pattern we should use when building an application?</li>
			</ol>
		</div>
	</div>
</div>
</body></html>