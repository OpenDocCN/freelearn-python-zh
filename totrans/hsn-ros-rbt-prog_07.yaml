- en: Simulating Robot Behavior with Gazebo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter deals with the dynamic simulation of a robot, which, conceptually,
    is a better approach to examining the actual behavior of the robot rather than
    just using software. Rigid body mechanics, including mass and inertia, friction,
    damping, motor controllers, sensor detection properties, noise signals, and every
    aspect of the robot and the environment that can be retained in a model with reasonable
    accuracy is much less expensive when replicated in a simulator than if you tried
    to do this with physical hardware.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this chapter, you will learn how to plug the digital definition of
    your robot (the URDF file) into the simulation environment of **Gazebo**, which
    is powered with a physics engine that's able to emulate realistic behaviors. You
    will also extend your training by checking and testing the digital robot so that
    its behavior represents what should happen in the physical world.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve ROS integration with Gazebo, a set of ROS packages grouped under
    `gazebo_ros_pkgs` ([http://wiki.ros.org/gazebo_ros_pkgs](http://wiki.ros.org/gazebo_ros_pkgs))
    provides the required wrappers. These packages provide the interfaces that are
    used to simulate a robot in Gazebo using ROS messages, services, and reconfigurable
    ROS parameters.
  prefs: []
  type: TYPE_NORMAL
- en: By following a guided path, you will become familiar with the ROS simulation
    environment of Gazebo. Specifically, you will learn how to prepare the model of
    a robot in order to simulate realistic behavior with the Gazebo physics engine.
    Finally, you will simulate the maximum weight that GoPiGo3 can carry and compare
    this with the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Gazebo simulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making modifications to the robot URDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying a Gazebo model and viewing the URDF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving your model around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter5_Gazebo_basics](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter5_Gazebo_basics).
  prefs: []
  type: TYPE_NORMAL
- en: 'By completing the previous chapter, you should have cloned this book''s code
    repository into the home folder of your laptop. In case you didn''t, we''ll go
    over this now. From a Terminal on your laptop, clone the repository into your
    home folder, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we copy the code for this chapter to the ROS workspace. This way, you
    will have a cleaner ROS environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This chapter contains a new ROS package called `gazebo_basics`, so rebuild
    the workspace so that it is known to your ROS environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the package is correctly installed by selecting it and listing its
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output of the `pwd` command shows the location, as expected. Now, you are
    ready to complete this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with the Gazebo simulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through a quick tour so that you have a clear understanding of what
    you can expect when implementing a dynamic simulation for GoPiGo3. Gazebo is an
    open source 3D robotics simulator and includes an ODE physics engine and OpenGL rendering,
    and supports code integration for closed-loop control in robot drives—that is,
    sensor simulation and actuator control. There are two new concepts within this
    definition. Let''s explain each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open Dynamics Engine** (**ODE**), a physics engine written in C/C++ that
    includes two main components: rigid-body dynamics simulation and collision detection
    ([https://www.ode.org/](https://www.ode.org/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open Graphics Library** (**OpenGL**), which is both a cross-language and cross-platform
    API for rendering 2D and 3D vector graphics. This API is typically used to interact
    with a GPU in order to achieve hardware-accelerated rendering. It is a specification
    that sets a standard for how the GPU of a PC has to display graphics on the screen
    by rendering 2D and 3D vector graphics. Being a specification, it is cross-platform
    by nature, and every manufacturer can make a different implementation with it
    (GPU driver). The point of this is that the functionality it provides has to be
    as it''s specified in the standard so that we can say that the driver is OpenGL
    compliant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps to get started with Gazebo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the Gazebo installation by launching it with a premade environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `gazebo_ros` package is a ROS package that resides in the `/opt/ros/kinetic/share/` system
    folder. It comes with the installation of `ros-kinetic-desktop-full` (or `ros-melodic-desktop-full`,
    if you are in Ubuntu 18.04) that was detailed in [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting
    Started with ROS*.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to run a full installation of ROS, you can install the packages
    individually. In the case of Gazebo, the installation command is `$ sudo apt-get
    install ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control` if you're
    on Ubuntu 16.04 or `$ sudo apt-get install ros-melodic-gazebo-ros-pkgs ros-melodic-gazebo-ros-control` if
    you're on Ubuntu 18.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from `empty_world.launch`, you have additional world launch files available
    whose names can be found by using the following command, which lists the files
    inside the launch folder of the `gazebo_ros` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `&&` symbol is commonly used in bash to run two commands in the same line.
    They are executed in the same order that they''re written in. The output is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch `mud_world.launch` and be patient; it will take a few seconds to render
    since it contains mobile parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31387efb-cd6c-46ae-820f-7383ac6498a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the mouse, you can move and rotate the world to change the perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: Hold down the left button of the mouse when the Gazebo window is active. Moving
    the mouse will cause the world to move on the screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hold down the central wheel button and move the mouse to turn the world. The
    point of rotation will be the one that the mouse pointer was in when you first
    pressed the wheel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hold down the right button of the mouse. By moving the mouse forward and backward,
    you will get to zoom in and zoom out, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To stop Gazebo, you have to press *Ctrl* + *C* in the Terminal where you executed
    the command. It can take several seconds to stop this process. Be aware that closing
    the Gazebo window is not enough to end the simulation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complex version is `willowgarage_world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/84ecfade-282a-4c06-a53d-6e1fcff9c75f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a brief insight into Gazebo, we are going to identify the panels in the
    user GUI—as depicted in the following screenshot—that you can reproduce with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, you need to have copied the files in this chapter''s repository,
    as we explained in the *Technical requirements* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b075bd5b-6ff3-4f40-b725-9d05f0581ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the different fields that are available on the panel
    in the preceding screenshot in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Environment toolbar**: There are icons that you can use to change between
    different modes: selection, translation of an object/robot, rotation of the object,
    and scale (limited to simple shapes). There are also icons that you can use to
    create simple shapes, provide lighting characteristics, and change the perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**World panel**: This provides us with access to all of the environment elements:
    Scene, Physics, Models, and Lights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Joints panel**: This provides us with access to the locations that you can
    pick models up from. The first is `/home/<username>/.gazebo/models`, which is
    the user''s repository of Gazebo models that have been selected from the main
    Gazebo repository. This repository is the second option and is available at [http://models.gazebosim.org](http://models.gazebosim.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Main window menu bar**: This provides options under the basic File, Edit,
    View, Window, and Help headings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simulation panel**: Located at the bottom of the environment display, it
    is a handy tool that''s used to run simulation scripts and provide real-time information
    when recording or playing back a simulation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have understood how the Gazebo simulator works, let's make some
    modifications to the robot URDF.
  prefs: []
  type: TYPE_NORMAL
- en: Making modifications to the robot URDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'URDF, as we explained in the previous chapter, stands for Unified Robot Description
    Format and has an XML-compliant syntax to simulate the visual properties of a
    robot. This format, fitting the scope it was conceived for, does not model some
    of the characteristics that are needed for a dynamic simulation. More precisely,
    it cannot specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The pose of the robot itself within a world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joint loops (parallel linkages).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Friction and other properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things that are not robots, such as lights, height maps, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For such reasons, an evolved XML format called **Simulation Description Format** (**SDF**)
    started its development as part of the Gazebo robot simulator. SDF allows us to
    describe objects to the environments for robot simulators, visualization, and
    control. Over the years, SDF has become a stable, robust, and extensible format
    that's capable of describing all aspects of robots.
  prefs: []
  type: TYPE_NORMAL
- en: Extending URDF to produce an SDF robot definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way to arrive at an SDF specification for your robot is quite straightforward
    if you start from the URDF definition we saw in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Always have the SDF format specification at hand ([http://sdformat.org/spec](http://sdformat.org/spec))
    since it offers an interactive tree so that you can navigate through all the tags,
    allowing you to understand the purpose of each one and how it relates to others.
    The open source code repository is located at [https://bitbucket.org/osrf/sdformat](https://bitbucket.org/osrf/sdformat).
  prefs: []
  type: TYPE_NORMAL
- en: 'To show that SDF extends and does not break URDF specification, here are some
    simple guidelines that allow you to convert your URDF model into a Gazebo-ready
    SDF description:'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum required adaptation is to include an `<inertia>` element within
    each `<link>` element. The goal of this new element is to include the mass and
    moment of inertia properties of all of the robot links, which is essential to
    carrying out a dynamic simulation. The rest of the adaptations that we'll list
    here are optional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a `<gazebo>` element for every `<link>` provides the functionality of
    converting visual colors into Gazebo format and translating STL files into DAE
    files for better textures. Sensor plugins are placed inside this tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a `<gazebo>` element for every `<joint>` allows us to specify damping,
    friction, and spring stiffness, and also allows us to add actuator control plugins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `<gazebo>` element for the `<robot>` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `<link name="world"/>` link if the robot should be rigidly attached to
    the `world`/`base_link`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about this conversion by following the tutorial *Using
    a URDF in Gazebo* ([http://gazebosim.org/tutorials?tut=ros_urdf](http://gazebosim.org/tutorials?tut=ros_urdf)),
    along with the applied examples.
  prefs: []
  type: TYPE_NORMAL
- en: The `<gazebo>` tag sets some default values that will be automatically included
    with your SDF description. This tag allows us to identify any elements that are
    found in SDF format that can't be found in URDF format. If a `<gazebo>` tag is
    used without a `reference=" "` property, it is assumed that the description inside
    refers to the whole robot model. The reference parameter usually refers to a specific
    robot link—that is, it defines its material.
  prefs: []
  type: TYPE_NORMAL
- en: Collisions and physical properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Collision** tags specify the volumes that need to be taken into account by
    the physics engine to detect interference/clearance between bodies. The visual
    tag from URDF is ignored for the purpose of this computation since it''s only
    used for visualization purposes. This means that, in general, you can decouple
    visible aspects of the robot (more detailed) from the envelope shapes that are
    used for computing interference (simpler shapes).'
  prefs: []
  type: TYPE_NORMAL
- en: The **inertia** tag of a part specifies its mass and tensor of inertia (3 x
    3), along with all of its components (only six components are needed since the
    matrix is symmetrical).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `gopigo.urdf` file under the `urdf` folder, you can find the blocks
    of XML for the `base_link` and caster (remember that the latter has been modeled
    as part of `base_link` as an acceptable simplification of the model). This first
    snippet corresponds to the `base_link` itself and specifies the collision and
    mass properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This includes the frame origin and orientation (`<origin>` tag), the geometry
    of the element (`<geometry>`), the mass (`<mass`>), and the inertia tensor (`<inertia>`).
    The second part models the caster and closes the block with the `</link>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These properties use the same tags we explained previously. For the right wheel,
    the following is the corresponding piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For the left wheel, the specification is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Gazebo tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned previously, `<gazebo>` tags are used to specify the additional
    elements to URDF that are needed within the native Gazebo format, SDF. In the
    `gopigo.gazebo` file under the `URDF` folder, you can find the following blocks
    of code, which specify the material for each link:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is the robot body (`base_link`). This block specifies the color of
    the part, as well as its initial pose:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is the wheels. These blocks are only needed to specify the colors since
    the pose was defined in `base_link`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you plan to reuse this code or share it, it is recommended that you add
    the dependency to your `package.xml` file for the `gazebo_basics` package. The
    following statement should be added under the dependencies section of such a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This way, when building the ROS workspace, the requested dependencies will be
    taken into account, providing an output that permits the package to be executed
    when called from the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a Gazebo model and viewing the URDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the SDF definition has been completed in the `gopigo.urdf` file, you should
    perform some checks to ensure that the file can be read by Gazebo. To do so, navigate to
    the folder where the model resides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `roscd` command is a very useful ROS command that's equivalent to the Linux
    `cd` command, but specifies the paths that are relative to a given package. It's
    also easier to use because all you have to do is provide the name of the package
    that you want to move to the Terminal. The first part, `gazebo_basics`, retrieves
    the absolute path of the package, as well as the second part of the folder or
    subfolder path you want to show. This ROS command, as well as other useful ones,
    will be covered in detail in the next chapter, under the *Shell commands* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following two commands to print and check the model, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command prints the XML file in the Terminal window so that you can
    inspect it. The second checks the syntax of such a file. Alternatively, you can
    do this with a single command, respectively (without needing the initial `roscd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are using another ROS command, `rospack find`, to write the
    path of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$` symbol before the opening bracket in bash is telling us this: `return
    me the path of the gazebo_basics package`.'
  prefs: []
  type: TYPE_NORMAL
- en: After the closing bracket, there is the route inside the package—that is, `/urdf`—which
    is where `gopigo.gazebo` is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes well in the checking process, you will obtain a successful
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you intentionally remove the closing `>` of a tag or a complete `<tag>`,
    the check command will throw the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remove the opening `<link>` and closing `</link>`, you''ll obtain the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Remove any incorrect syntax from the file and make sure it passes the check
    procedure. When you're ready, proceed to the next section, where we will see the
    model in action.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the GoPiGo model in Gazebo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The single-launch file of this chapter can be found under the launch folder
    of the package and is called `gopigo_gazebo.launch`. We''ve divided its code into
    the following two snippets for explanation purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see two new tags, `<include>` and `<arg>`. The former allows us
    to include launch files from other ROS packages, while the latter allows us to
    make the launch file configurable using local arguments. The `<arg>` tag will
    be explained in the *Explaining configurable launch files using the <arg> tag*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<include>` block calls external files and defines the default values for
    the parameters. Its syntax can be clearly understood if we bear its equivalent
    command in mind when using the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you might have guessed, the `<include>` tag specifies the `empty_world.launch`
    file belonging to the `gazebo_ros` ROS package (which ships with the ROS installation,
    and is, therefore, a system package).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the file path, it is worth mentioning the mechanism that ROS uses
    to abstract the physical location of any package in the disk by using the `find`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the purpose of the `$` symbol in bash—that is, accessing the value
    of an environment variable—the preceding snippet provides us with a message stating `return
    me the path of the gazebo_basics package`. After the closing bracket, we can see
    the route inside the package—that is, `/launch`—which is where `empty_world.launch`
    is located.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore its contents by listing the file, as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the available worlds (that the line in bold letters refers to)
    are loaded from the Gazebo installation directory—`/usr/share/gazebo-7/worlds` if
    you are in Ubuntu 16.04 or `/usr/share/gazebo-9/worlds` if you are in Ubuntu 18.04\.
    In the case of our launch file, we are using `worlds/empty.world`. It''s marked
    in bold in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<include>` tag is followed by the second snippet, which describes the
    Gazebo node to be launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This node spawns the GoPiGo3 model into Gazebo using the `spawn_model` script
    of the `gazebo_ros` package. So why aren't we using the `<include>` tag here?
    Because we are including an external single node. We reserve `<include>` for launch
    files, where there are more nodes and configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, issue the `roslaunch` command to start the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output (be patient; depending on your graphics
    card, the 3D scene can take several seconds to be launched in a Gazebo window):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6408f731-fee9-4e0c-a798-82da29fcfd5f.png)'
  prefs: []
  type: TYPE_IMG
- en: We will conclude this section by explaining the `<arg>` tag that we skipped
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining configurable launch files using the <arg> tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arguments are a way to use variables in the scope of a launch file. Let''s
    take the example of the `world_name` argument inside the `include` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This tag tells us which Gazebo world to use—referenced by the `name` attribute—and
    specifies the path where the file for the world can be found—that is, `value="$(find
    gazebo_basics)/worlds/gopigo.world"`. Be aware that how you specify the file path
    is done in exactly the same way in which we tell it the launch file to include.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for the `<arg>` tag is neatly explained in the official documentation
    at [http://wiki.ros.org/roslaunch/XML/arg](http://wiki.ros.org/roslaunch/XML/arg).
    Remember that, in the *Controlling GoPiGo3 wheels from RViz* section of the previous
    chapter, we explained how to specify the argument values when issuing the `roslaunch`
    command while providing default values in the launch file.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you are ready to understand how the model simulates the dynamics
    of your robot.
  prefs: []
  type: TYPE_NORMAL
- en: Moving your model around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the simulation has been launched, you can use the interaction icons in
    the Gazebo window. For example, you can play with the rotation tool of the environment
    toolbar to see how gravity affects the cone when you move it from its point of
    equilibrium:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6ba0155-324f-4808-ada4-464f055ee187.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can access the Joints panel (drag from the right border of the Gazebo
    window if it is not visible), select the GoPiGo model from the left pane, and
    under the Force tab in the Joints panel, apply 1 N.m torque to the left wheel.
    You will see how the robot starts to rotate around the right wheel, where no external
    force is acting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6598f45d-8ad2-4c26-9261-fdf129332ff8.png)'
  prefs: []
  type: TYPE_IMG
- en: These interactions are quite simple, and at this point, they should give you
    a good taste of what simulation can support your work as a robotics engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines for tuning the Gazebo model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general goal in simulation is to reproduce reality to some extent with minimal
    effort, and this approximation should serve to be your concrete goal of designing
    a robot or evaluating the performance of existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Digital models are an abstraction of reality. You don't need to reproduce every
    detail of the physical robot in its Gazebo model. If you tried to do so, the required
    workload would be so high that the benefits of simulation would not compensate
    for the effort. Instead, what you do is reproduce those characteristics to verify
    the robot. You should start by defining the concrete goals and then build the
    simplest model that will allow us to comply with them.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through an example to understand these concepts. In this chapter, you've
    seen that the GoPiGo3 model is just a box (robot body), a semisphere (caster),
    and two cylinders (left and right wheels). The real GoPiGo3 contains many more
    parts, including bolts, washers, and nuts, as you know from experience when you
    put the hardware together in [Chapter 1](9bb411d1-934c-4497-aad4-7ad770d3783c.xhtml), *Assembling
    the Robot*. If you try to reproduce all these elements in URDF, we are sure you
    would be discouraged from continuing to work on such a hard task. Instead of following
    that dead end, ask yourself what you want the model for. From now on, we will
    refer to the simulated model as the **digital twin**, which is the technical name
    we will use to refer to the digital replica of the physical robot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two of the possible goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Measure the actual maximum torque that servomotors can exert
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the weight of the heaviest object that GoPiGo3 can transport as a
    function of the slope of a ramp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s think about the characteristics that the digital twin should have:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are trying to measure dynamic features, we just have to reproduce the total
    mass of GoPiGo3 and the torque actuating on the wheels. Moments of inertia are
    not strictly necessary if the robot is going to follow a smooth path. For example,
    in the case of a spinning motion, the inertia tensor would need to be considered
    to simulate the maximum turning speed when the robot goes around without moving
    from its position. This would be accomplished by rotating the left and right wheels
    at maximum speed with opposite signs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will need `<visual>` tagged elements to see the digital model on the screen,
    but will not need `<collision>` elements since there is no need to include obstacles
    for our purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With just those characteristics, you will have the minimum digital twin. The
    procedure to achieve these goals would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, take a ramp that you can manually change the slope of. Then,
    get GoPiGo3 to climb the ramp and determine the maximum slope it can deal with.
    You will reach a point where the robot stays almost still, without climbing or
    going backward. Let's say that this angle is *a*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The force that the two motors are exerting is given by the formula ![](img/6fb8fee3-c112-4836-bd6b-409f857e7aca.png),
    where *m* is the robot's mass and *g* is the acceleration of gravity (9.8 m/s²).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The torque that's applied by each motor to produce such traction is given by
    the formula  ![](img/3d77e374-cb39-4dd7-b1b4-bbe4d3899fc4.png), where *r* is the
    radius of the wheels and the factor 2 means that we produce this force using two
    motors (one per wheel).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've determined the maximum torque, *T*, you can go to the simulation
    environment, apply it to each of the motors, and see the robot rolling on a ramp
    of a slope, α < *a*. By progressively increasing the mass of the robot body (concentrated
    in the `base_link` URDF element), you will find the total weight that makes the
    robot stop moving forward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bear in mind that if the ramp had slope *a*, the force that the wheels have
    to exert to make the robot climb will correspond to the maximum motor torque,
    so it won't have the capacity to transport more weight. Therefore, you should
    always consider a slope, α, lower than *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, you will obtain a good estimation of the maximum weight that
    GoPiGo3 can carry for a given maximum ramp slope, α. You can introduce this modification
    in Gazebo very easily by modifying the mass value of the `base_link` in the URDF
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `m + dm` represents the sum of two terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`m` is the mass of the unloaded robot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dm` is the mass of the object to be transported. The value of `dm` (in kilograms)
    that makes sure the robot does not climb the ramp will be the maximum load for
    the slope, α. For a ramp slope equal to *a*, we have *dm = dm*= 0.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll cover how we can specify the maximum motor torque in Gazebo in [Chapter
    7](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml), *Robot Control and Simulation*,
    in the *Simulating GoPiGo3 with Gazebo* section. Here, you will see that there
    is a plugin element that can be used to simulate the motor controller that mobile
    robots such as GoPiGo3 have.
  prefs: []
  type: TYPE_NORMAL
- en: With these modifications to the URDF file, as well as the check we made in Gazebo
    regarding *dm*= 0* for a ramp slope equal to *a*, you have tuned the digital twin
    so that it can simulate freight transport and has the transport capability of
    *dm* kilograms for a maximum slope of α.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the simulation environment of ROS called Gazebo,
    a standalone simulator that also provides full integration with ROS.
  prefs: []
  type: TYPE_NORMAL
- en: First, you learned about SDF, the standard XML format for robot simulation driven
    by Gazebo. SDF extends URDF and allows us to describe objects and environments
    for robot simulators, visualization, and control.
  prefs: []
  type: TYPE_NORMAL
- en: Following a parallel process to that of [Chapter 4](742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml),
    *Creating the Virtual Two-Wheeled ROS Robot*, we produced a robot description
    within the `./urdf/gopigo.gazebo` file. The simulation was then started by running
    `./launch/gopigo_gazebo.launch`.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you were provided with an overview of how the Gazebo interface
    GUI is organized and performed some simple interactions with the GoPiGo3 model
    to see how it is affected by the gravity or the application of torque in the joint
    of one of its wheels.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you should have started to develop a feeling of how to simulate realistic
    behavior with the robot with the physics engine of Gazebo. This will provide you
    with a powerful and cost-effective tool that you can use to troubleshoot the differences
    between the physical robot and its digital twin.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the physical robot and explain how to interface
    with it. What you have done so far with the virtual robot will help you anticipate
    how the actual GoPiGo3 behaves when you run a ROS program in its CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the format of the SDF?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) It is a text file
  prefs: []
  type: TYPE_NORMAL
- en: B) JSON
  prefs: []
  type: TYPE_NORMAL
- en: C) XML
  prefs: []
  type: TYPE_NORMAL
- en: Why can't the UDRF format be directly used by simulation for robots?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) Because URDF cannot specify the pose of the robot within a world
  prefs: []
  type: TYPE_NORMAL
- en: B) Because it cannot specify the dynamic properties of joints, such as stiffness,
    damping, and/or friction
  prefs: []
  type: TYPE_NORMAL
- en: C) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: What is the `<collision>` tag used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) For defining the physical obstacles the robot has to avoid
  prefs: []
  type: TYPE_NORMAL
- en: B) It is an optional tag for performing the interference checking of robot joints
  prefs: []
  type: TYPE_NORMAL
- en: C) To define the volume to be considered for the interference checking of robot
    links
  prefs: []
  type: TYPE_NORMAL
- en: What is the ROS `find` command used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) It is used to refer to other ROS nodes with the same name
  prefs: []
  type: TYPE_NORMAL
- en: B) It returns the absolute path of the ROS package that is specified as its
    argumentC) It allows you to easily find any file within the ROS environment
  prefs: []
  type: TYPE_NORMAL
- en: What is a robot simulation in Gazebo used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) To find out more about a robot before purchasing it
  prefs: []
  type: TYPE_NORMAL
- en: B) To develop functionality prior to applying it to the real robotC) To check
    the visual aspect of a robot before manufacturing it
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gazebo tutorials: [http://gazebosim.org/tutorials](http://gazebosim.org/tutorials)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulator Gazebo tutorials (ROS-specific): [http://wiki.ros.org/simulator_gazebo/Tutorials](http://wiki.ros.org/simulator_gazebo/Tutorials)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ROS Robot Programming: A handbook Written by TurtleBot3 Developers*, YoonSeok
    Pyo, HanCheol Cho, RyuWoon Jung, TaeHoon Lim (2017), ROBOTIS Co. Ltd, first edition: [http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf](http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf),
    Chapter: *ROS Tools: RViz and rqt *and 10.9 *TurtleBot3 Simulation using Gazebo*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
