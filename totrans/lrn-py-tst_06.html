<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 6. Running Your Tests with Nose"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Running Your Tests with Nose</h1></div></div></div><p>In the last chapter, we saw the <code class="literal">unittest</code> discover tool find our tests without being told explicitly where they were. That was pretty handy, compared to the way <code class="literal">doctest</code> had been making us tell it exactly where to find the tests it should run, particularly, when we're talking about a large source tree that has tests in many locations.</p><p>Nose is a tool that expands on this idea. It's capable of finding <code class="literal">unittest</code> tests, <code class="literal">doctest</code> tests, and ad hoc tests throughout a source tree, and running them all. It then presents you with a unified report of test successes and failures. In other words, Nose lets you pick the right testing tool for any given test, integrating them simply and conveniently.</p><p>Nose also provides a few new testing features, such as module-level fixtures and some new assert functions.</p><div class="section" title="Installing Nose"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Installing Nose</h1></div></div></div><p>Nose is not a <a id="id268" class="indexterm"/>part of the Python standard library, which means that you'll need to install it yourself. You can install Nose with a single command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python3 -m pip install --user nose</strong></span></pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>If the command reports that no module named <code class="literal">pip</code> was found, you need to run the following command to install the <code class="literal">pip</code> module:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python3 -m ensurepip --user</strong></span></pre></div><p>The <a id="id269" class="indexterm"/>
<code class="literal">ensurepip</code> module is part of the standard library as of Python 3.4, so you can count on it being available. You probably won't need this, though, because, even though <code class="literal">pip</code> isn't part of the standard library, it is bundled with Python releases.</p></div></div><p>The <code class="literal">--user</code> command-line switch in the previous command tells the tool to install into your personal Python package folder. If you leave that out of the command, it will try to install Nose for all users.</p><p>That's it. Nose is ready to go.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Organizing tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Organizing tests</h1></div></div></div><p>All right, we've got <a id="id270" class="indexterm"/>Nose installed, so what's it good for? Nose looks through a directory structure, finds the test files, sorts out the tests that they contain, runs the tests, and reports the results back to you. That's a lot of work that you don't have to do each time you want to run your tests—which should be often.</p><p>Nose recognizes the <a id="id271" class="indexterm"/>test files based on their names. Any file or directory whose name contains <code class="literal">test</code> or <code class="literal">Test</code> either at the beginning or following any of the characters <code class="literal">_</code> (underscore), <code class="literal">.</code> (dot), or <code class="literal">–</code> (dash) is recognized as a place where the tests might be found. So are Python source files and package directories. Any file that might contain tests is checked for <code class="literal">unittest</code> <code class="literal">TestCases</code> as well as any functions whose names indicate that they're tests. Nose can find and execute the <code class="literal">doctest</code> tests, as well, that are either embedded in docstrings or written in separate test files. By default, it won't look for the <code class="literal">doctest</code> tests unless we tell it to. We'll see how to change the default settings shortly.</p><p>Since Nose is so willing to go looking for our tests, we have a lot of freedom with respect to how we can organize them. It often turns out to be a good idea to separate all of the tests into their own directory, or larger projects into a whole tree of directories. A big project can end up having many thousands of tests, so organizing them for easy navigation is a big benefit. If doctests are being used as documentation as well as testing, it's probably a good idea to store them in yet another separate directory with a name that communicates that they are documentary. For a moderately-sized project, this recommended structure might look like the following:</p><div class="mediaobject"><img src="images/3211OS_06_01.jpg" alt="Organizing tests"/></div><p>This structure is only a <a id="id272" class="indexterm"/>recommendation... it's for your benefit, not for Nose. If <a id="id273" class="indexterm"/>you feel that a different structure will make things easier for you, go ahead and use it.</p><div class="section" title="An example of organizing tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec59"/>An example of organizing tests</h2></div></div></div><p>We're going to <a id="id274" class="indexterm"/>take some of our tests from the previous chapters and organize them into a tree of directories. Then, we're going to use Nose to run them all.</p><p>The first step is to create a <a id="id275" class="indexterm"/>directory that will hold our code and tests. You can call it whatever you like, but I'll refer to is as <code class="literal">project</code> here.</p><p>Copy the <code class="literal">pid.py</code>, <code class="literal">avl_tree.py</code>, and <code class="literal">employees.py</code> files from the previous chapters into the <code class="literal">project</code> directory. Also place <code class="literal">test.py</code> from <a class="link" href="ch02.html" title="Chapter 2. Working with doctest">Chapter 2</a>, <span class="emphasis"><em>Working with doctest</em></span>, here, but rename it to <code class="literal">inline_doctest.py</code>. We want it to be treated as a source file, not as a test file, so you can see how Nose handles source files with doctests in their docstrings. Modules and packages placed in the <code class="literal">project</code> directory will be available for tests no matter where the test is placed in the tree.</p><p>Create a subdirectory of <code class="literal">project</code> called <code class="literal">test_chapter2</code>, and place the <code class="literal">AVL.txt</code> and <code class="literal">test.txt</code> files from <a class="link" href="ch02.html" title="Chapter 2. Working with doctest">Chapter 2</a>, <span class="emphasis"><em>Working with doctest</em></span>, into it.</p><p>Create a subdirectory of <code class="literal">project</code> called <code class="literal">test_chapter3</code>, and place <code class="literal">PID.txt</code> into it.</p><p>Create a subdirectory of <code class="literal">project</code> called <code class="literal">test_chapter5</code>, and place all of the <code class="literal">test_*</code> modules from <a class="link" href="ch05.html" title="Chapter 5. Structured Testing with unittest">Chapter 5</a>, <span class="emphasis"><em>Structured Testing with unittest</em></span>, into it.</p><p>Now, we're ready to run our tests using the following code:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python3 -m nose --with-doctest --doctest-extension=txt -v</strong></span></pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>You can leave off the <code class="literal">-v</code> if you want. It just tells Nose to provide a more detailed report.</p></div></div><p>All of the tests should <a id="id276" class="indexterm"/>run. We expect to see a few failures, since some of the tests from the previous chapters were intended to fail, for illustrative purposes. There's <a id="id277" class="indexterm"/>one failure, as shown in the following screenshot, though, that we need to consider:</p><div class="mediaobject"><img src="images/3211OS_06_02.jpg" alt="An example of organizing tests"/></div><p>The first part of this error report can be safely ignored: it just means that the whole <code class="literal">doctest</code> file is being treated as a failing test by Nose. The useful information comes in the second part of the report. It tells us that where we were expecting to get a previous time of <code class="literal">1.0</code>, instead we're getting a very large number (this will be different, and larger, when you run the test for yourself, as it represents the time in seconds since a point several decades in the past). What's going on? Didn't we replace <code class="literal">time.time</code> for that test with a mock? Let's take a look at the relevant part of <code class="literal">pid.txt</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in range(1, 1000)).__next__
&gt;&gt;&gt; import pid
&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,
...                      initial = 12)
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time
1.0</pre></div><p>We mocked <code class="literal">time.time</code>, sure enough (although it would be better to use the <code class="literal">unittest.mock</code> <code class="literal">patch</code> function). How is it that <code class="literal">from time import time</code> in <code class="literal">pid.py</code> is getting the wrong (which is to say, real) time function? What if <code class="literal">pid.py</code> had already been imported before this <a id="id278" class="indexterm"/>test ran? Then <code class="literal">from time import time</code> would already have been run before our mock was put in place, and it would never know about the mock. So, was <code class="literal">pid.py</code> imported by some thing else, before <code class="literal">pid.txt</code> imported it? As it <a id="id279" class="indexterm"/>happens, it was: Nose itself imported it, when it was scanning for tests to be executed. If we're using Nose, we can't count on our <code class="literal">import</code> statements actually being the first to import any given module. We can fix the problem easily, though, by using patch to replace the <code class="literal">time</code> function where our test code finds it:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from unittest.mock import Mock, patch</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import pid</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; with patch('pid.time', Mock(side_effect = [1.0, 2.0, 3.0])):</strong></span>
...    controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,
...                         initial = 12)
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time
1.0</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>Note that we're only looking at the first test in the file here. There is another test that would be better written in the same way, although it does pass. Can you spot that test and improve it?</p></div></div><p>Don't get confused: we switched to using <code class="literal">unittest.mock</code> for this test because it's a better tool for mocking objects, not because it solves the problem. The real solution is that we switched <a id="id280" class="indexterm"/>from replacing <code class="literal">time.time</code> to replacing <code class="literal">pid.time</code>. Nothing <a id="id281" class="indexterm"/>in <code class="literal">pid.py</code> refers to <code class="literal">time.time</code>, except for the <code class="literal">import</code> line. Every other place in the code that references <code class="literal">time</code> looks it up in the module's own global scope. That means it's <code class="literal">pid.time</code> that we really need to mock, and it always was. The fact that <code class="literal">pid.time</code> is another name for <code class="literal">time.time</code> is irrelevant; we should mock the object where it's found, not where it came from.</p><p>Now, when we run the <a id="id282" class="indexterm"/>tests again, the only failures are the expected ones. Your summary report (that we get because we passed <code class="literal">-v</code> to Nose on the command line) <a id="id283" class="indexterm"/>should look like this:</p><div class="mediaobject"><img src="images/3211OS_06_03.jpg" alt="An example of organizing tests"/></div><p>We just saw how hidden assumptions can break tests, just as they can break the code being tested. Until now, we've been assuming that, when one of our tests imports a module, that's the first time the module has been imported. Some of our tests relied on this assumption to replace library objects with mocks. Now that we're dealing with running many tests aggregated together, with no guaranteed order of execution, this assumption isn't reliable. On top of that, the module that we had trouble with actually had to be imported to search it for tests, before any of our tests were run. A quick switch of the affected tests to use a better approach, and we were good to go.</p><p>So, we just ran all of these tests with a single command, and we can spread our tests across as many directories, source files, and documents as we need to keep everything organized. That's pretty nice. We're getting to the point where testing is useful in the real world.</p><p>We can store our tests in a separate and well-organized directory structure, and run them all with a single, quick, and <a id="id284" class="indexterm"/>simple command. We can also easily run a subset <a id="id285" class="indexterm"/>of our tests by passing the filenames, module names, or directories containing the tests we want to run as command-line parameters.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Simplifying the Nose command line"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Simplifying the Nose command line</h1></div></div></div><p>The <code class="literal">python3 -m nose</code> command that we used earlier was not hard to understand, but it's longer than <a id="id286" class="indexterm"/>we'd like if we're going to be typing it all <a id="id287" class="indexterm"/>the time. Instead of the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python3 -m nose --with-doctest --doctest-extension=txt -v</strong></span></pre></div><p>We'd really prefer just the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python3 -m nose</strong></span></pre></div><p>or, even more simply:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nosetests</strong></span></pre></div><p>Fortunately, it's simple to tell Nose that we want it to use different defaults for the values of these command-line switches. To do this, just create a configuration file called <code class="literal">nose.cfg</code> or <code class="literal">.noserc</code> (either name will work) in your home directory, and place the following inside it:</p><div class="informalexample"><pre class="programlisting">[nosetests]
with-doctest=1
doctest-extension=txtIf you're a Windows user, you might not be sure what the phrase "home directory" is supposed to denote in this context. As far as Python is concerned, your home directory is defined by your environment variables. If HOME is defined, that's your home directory. Otherwise, if USERPROFILE is defined (it usually is, pointing at C:\Documents and Settings\USERNAME) then that is considered to be your home directory. Otherwise, the directory described by HOMEDRIVE and HOMEPATH (often C:\)is your home directory.</pre></div><p>Setting the options in the configuration file takes care of all the extraneous command-line arguments. From now on, whenever you run Nose, it will assume these options, unless you tell it otherwise. You don't have to type them on the command line any more. You can use the same trick for any option that Nose can accept on the command line.</p><p>For the second refinement, Nose installs a script called <code class="literal">nosetests</code> when it's installed. Typing <code class="literal">nosetests</code> is exactly the same as typing <code class="literal">python3 -m nose</code>, except that you might have to add the <a id="id288" class="indexterm"/>directory that contains <code class="literal">nosetests</code> to your <code class="literal">PATH</code> <a id="id289" class="indexterm"/>environment variable before it will work. We'll continue using <code class="literal">python3 -m nose</code> in the examples.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Customizing Nose's test search"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Customizing Nose's test search</h1></div></div></div><p>We've said before <a id="id290" class="indexterm"/>that Nose uses names of directories, modules, and functions to inform its search for tests. Directories and modules whose names <a id="id291" class="indexterm"/>start with <code class="literal">test</code> or <code class="literal">Test</code>, or contain a <code class="literal">_</code>, <code class="literal">.</code>, or <code class="literal">–</code> followed by <code class="literal">test</code> or <code class="literal">Test</code> will be included in the search, in addition to any other places that Nose decides it should search. This is by default, but it's not actually the whole story.</p><p>If you know about regular expressions, you can customize the pattern that Nose uses to look for tests. You can do this by passing the <code class="literal">--include=REGEX</code> command line option, or by putting <code class="literal">include=REGEX</code> in your <code class="literal">nose.cfg</code> or <code class="literal">.noserc</code>.</p><p>For example, run the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>python3 -m nose --include="(?:^[Dd]oc)"</strong></span></pre></div><p>Now Nose will, in addition to looking for names using the word <code class="literal">test</code>, also look for names that start with <code class="literal">doc</code> or <code class="literal">Doc</code>. This means that you can call the directory containing your <code class="literal">doctest</code> files as <code class="literal">docs</code>, <code class="literal">Documentation</code>, <code class="literal">doctests</code>, and so on, and Nose will still find and run those tests. If you use this option often, you'll almost certainly want to add it to your configuration file, as described under the previous heading.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>The full syntax and use of regular expressions is a subject itself, and has been the topic of many books; but you can find everything that you need to do in the Python <a id="id292" class="indexterm"/>documentation at <a class="ulink" href="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</a>.</p></div></div><div class="section" title="Check your understanding"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Check your understanding</h2></div></div></div><p>By running <code class="literal">python3 -m nose --processes=4</code>, Nose can be made to launch four testing processes simultaneously, which can be a big gain, if you're running the tests on a quad-core system. How would you make Nose always launch four testing processes, without being told on the <a id="id293" class="indexterm"/>command line? The answer is just put <code class="literal">processes=4</code> in your Nose configuration file.</p><p>If some of your tests were <a id="id294" class="indexterm"/>stored in a directory called <code class="literal">specs</code>, how would you tell Nose that it should search that directory for tests? You need to add <code class="literal">--include="specs"</code> to the Nose command line.</p><p>Which of the following will be recognized by Nose as possibly containing the <code class="literal">UnitTests</code>, <code class="literal">unit_tests</code>, <code class="literal">TestFiles</code>, <code class="literal">test_files</code>, and <code class="literal">doctests</code> tests by default? The answer is that <code class="literal">unit_tests</code>, <code class="literal">TestFiles</code>, and <code class="literal">test_files</code> will be recognized by Nose's default configuration.</p></div><div class="section" title="Practicing Nose"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Practicing Nose</h2></div></div></div><p>Write some <code class="literal">doctest</code> and <code class="literal">unittest</code> tests for the following specification, and create a directory tree to <a id="id295" class="indexterm"/>contain them and the code that they describe. Write the <a id="id296" class="indexterm"/>code using the test-driven methodology, and use Nose to run the tests:</p><div class="informalexample"><pre class="programlisting">The graph module contains two classes: Node and Arc. An Arc is a connection between two Nodes. Each Node is an intersection of an arbitrary number of Arcs.

Arc objects contain references to the Node objects that the Arc connects, a textual identification label, and a "cost" or "weight", which is a real number.

Node objects contain references to all of the connected Arcs, and a textual identification label.

Node objects have a find_cycle(self, length) method which returns a list of Arcs making up the lowest cost complete path from the Node back to itself, if such a path exists with a length greater than 2 Arcs and less than or equal to the length parameter.

Node and Arc objects have a __repr__(self) method which returns a representation involving the identification labels assigned to the objects.</pre></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Nose and doctest tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Nose and doctest tests</h1></div></div></div><p>Nose doesn't <a id="id297" class="indexterm"/>just support <code class="literal">doctest</code>, it actually enhances it. When you're using Nose, you can write test fixtures for your <code class="literal">doctest</code> files.</p><p>If you pass <code class="literal">--doctest-fixtures=_fixture</code> on the command line, Nose will go looking for a <a id="id298" class="indexterm"/>fixture file whenever it finds a <code class="literal">doctest</code> file. The name of the fixture file is based on the name of the <code class="literal">doctest</code> file, and is calculated by appending the <code class="literal">doctest</code> fixture suffix (in other words, the value of <code class="literal">doctest-fixtures</code>) to the main part of the <code class="literal">doctest</code> filename, and then adding <code class="literal">.py</code> to the end. For example, if Nose found a <code class="literal">doctest</code> file called <code class="literal">PID.txt</code>, and had been told to find <code class="literal">doctest‑fixtures=_fixture</code>, it would try to find the test fixture in a file called <code class="literal">PID_fixture.py</code>.</p><p>The test fixture file for a <code class="literal">doctest</code> is very simple: it's just a Python module that contains a <code class="literal">setup()</code> or <code class="literal">setUp()</code> function, and a <code class="literal">teardown()</code> or <code class="literal">tearDown()</code> function. The <code class="literal">setup</code> function is executed before the <code class="literal">doctest</code> file, and the <code class="literal">teardown</code> function is executed after the <code class="literal">doctest</code> file.</p><p>The fixture operates in a different namespace from the <code class="literal">doctest</code> file, so none of the variables that get defined in the fixture module are visible in the actual tests. If you want to share the variables between the fixture and the test, you'll probably want to do it by making a simple little module to hold the variables, which you can import into both the fixture and the test.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Nose and unittest tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Nose and unittest tests</h1></div></div></div><p>Nose enhances <a id="id299" class="indexterm"/>
<code class="literal">unittest</code> by providing test fixtures at the package and module levels. The package <code class="literal">setup</code> function is run before any of the tests in any of the modules in <a id="id300" class="indexterm"/>a package, while the <code class="literal">teardown</code> function is run after all of the tests in all of the modules in the package have completed. Similarly, the module <code class="literal">setup</code> function is run before any of the tests in a given module have been executed, and the module <code class="literal">teardown</code> function is executed after all of the tests in the module have been executed.</p><div class="section" title="Module fixture practice"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Module fixture practice</h2></div></div></div><p>We're going <a id="id301" class="indexterm"/>to build a test module with a module-level fixture. In the fixture, we'll replace the <code class="literal">datetime.date.today</code> function, which normally returns an object representing the current date. We want <a id="id302" class="indexterm"/>it to return a specific value, so that our tests can know what to expect. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a directory called <code class="literal">tests</code>.</li><li class="listitem">Within the <code class="literal">tests</code> directory, create a file called <code class="literal">module_fixture_tests.py</code> containing the following code:<div class="informalexample"><pre class="programlisting">from unittest import TestCase
from unittest.mock import patch, Mock
from datetime import date

fake_date = Mock()
fake_date.today = Mock(return_value = date(year = 2014,
                                           month = 6,
                                           day = 12))

patch_date = patch('module_fixture_tests.date', fake_date)


def setup():
    patch_date.start()

def teardown():
    patch_date.stop()

class first_tests(TestCase):
    def test_year(self):
        self.assertEqual(date.today().year, 2014)

    def test_month(self):
        self.assertEqual(date.today().month, 6)

    def test_day(self):
        self.assertEqual(date.today().day, 12)

class second_tests(TestCase):
    def test_isoformat(self):
        self.assertEqual(date.today().isoformat(), '2014-06-12')</pre></div></li><li class="listitem">Notice that there are two <code class="literal">TestCase</code> classes in this module. Using pure <code class="literal">unittest</code>, we'd have to duplicate the fixture code in each of these classes. Nose lets us write it once and use it in both the places.</li><li class="listitem">Go ahead and run the tests by moving to the directory that contains the tests directory and type <code class="literal">python -m nose</code>.</li><li class="listitem">Nose will recognize <code class="literal">tests</code> as a directory that might contain tests (because of the directory name), find the <code class="literal">module_fixtures_tests.py</code> file, run the <code class="literal">setup</code> function, run all of the tests, and then run the <code class="literal">teardown</code> function. There won't be much to see, though, aside from a simple report of how many tests passed.</li></ol></div><p>You might have noticed yet another way of using <code class="literal">unittest.mock.patch</code> in the previous example. In addition to being usable as a decorator or a context manager, you can also use the <code class="literal">patch</code> function as a constructor, and call <code class="literal">start</code> and <code class="literal">stop</code> on the object it returns. Of all the ways you can use the <code class="literal">patch</code> function, this is the one to avoid in most cases, because this requires you to be careful to remember to call the <code class="literal">stop</code> function. The preceding code would have been better using <code class="literal">patch_date</code> as a class decorator on each of the <code class="literal">TestCase</code> classes, except that the point here was to demonstrate what module-level fixtures look like.</p><p>Normally, rather <a id="id303" class="indexterm"/>than creating mock objects, <code class="literal">setup</code> and <code class="literal">teardown</code> will do things such as handle, create, and destroy temporary files, or so on.</p><p>We can save ourselves some time and effort by using a second layer of test fixtures that wrap around the entire test modules instead of single test methods. By doing this, we save ourselves from duplicating the fixture code inside every test class in the module; but this comes with a cost. The <code class="literal">setup</code> and <code class="literal">teardown</code> functions aren't run before and after each test, as <a id="id304" class="indexterm"/>normal test fixtures are. Instead, all of the tests in the module happen between a single module-level setup/teardown pair, which means that, if a test does something that affects the environment created by the <code class="literal">setup</code> function, it won't be undone before the next test runs. In other words, the isolation of tests is not guaranteed with respect to the environment created by a module-level fixture.</p></div><div class="section" title="Package fixture practice"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Package fixture practice</h2></div></div></div><p>Now, we're <a id="id305" class="indexterm"/>going to create a fixture that wraps <a id="id306" class="indexterm"/>around all the test modules in an entire package. Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new file called <code class="literal">__init__.py</code> to the <code class="literal">tests</code> directory that we created in the last practice section. (That's two underscores, the word <code class="literal">init</code> and two more underscores). The presence of this file tells Python that the directory is a package.</li><li class="listitem">In <code class="literal">module_fixture_tests.py</code>, change:<div class="informalexample"><pre class="programlisting">patch_date = patch('module_fixture_tests.date', fake_date)</pre></div><p>with the following:</p><div class="informalexample"><pre class="programlisting">patch_date = patch('tests.module_fixture_tests.date', fake_date)</pre></div></li><li class="listitem">Place the following code inside <code class="literal">__init__.py</code> in the <code class="literal">tests</code> directory:<div class="informalexample"><pre class="programlisting">from os import unlink

def setup():
    with open('test.tmp', 'w') as f:
        f.write('This is a test file.')

def teardown():
    unlink('test.tmp')</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>It's fairly common that the <code class="literal">__init__.py</code> files are completely empty, but they're the canonical source for the package object; so that's where Nose looks for a package-level fixture.</p></div></div></li><li class="listitem">Add a new file called <code class="literal">package_fixtures_tests.py</code> to the <code class="literal">tests</code> directory, with the following contents:<div class="informalexample"><pre class="programlisting">from unittest import TestCase
from glob import glob

class check_file_exists(TestCase):
    def test_glob(self):
        self.assertIn('test.tmp', glob('*.tmp'))</pre></div></li><li class="listitem">Go ahead and run the tests again. You won't see much output, but that just means the tests passed. Notice that the <code class="literal">test_glob</code> function can't succeed unless <code class="literal">test.tmp</code> exists. Since this file is created in the package setup and destroyed in the package teardown (and it no longer exists), we know that the setup was run before the test, and teardown was run after the test. If we added a test to <code class="literal">module_fixture_tests.py</code> that depended on <code class="literal">test.tmp</code>, they too would pass, because the <code class="literal">setup</code> function is called before any test in the package, and <code class="literal">teardown</code> is called after every test in the package has run.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>The <code class="literal">glob</code> module provides the ability to expand command-line - style wildcards into a list of filenames. The <code class="literal">glob.glob</code> function is one of several globbing functions available.</p></div></div></li></ol></div><p>We worked with yet another layer of test fixture, this time wrapping around all of the test modules in the <code class="literal">tests</code> directory. As you can see from looking at the code we just wrote, the environment created by the package-level test fixture is available in every test in every module in the package.</p><p>Like module-level <a id="id307" class="indexterm"/>test fixtures, package-level test fixtures can be a big labor-saving shortcut, but they don't provide you with the <a id="id308" class="indexterm"/>protection against communication between tests that real test-level fixtures do.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>Why did we change <code class="literal">'module_fixture_tests.date'</code> into <code class="literal">'tests.module_fixture_tests.date'</code> when we added the package-level fixture? Well, when we added <code class="literal">__init__.py</code> to the <code class="literal">tests</code> directory, in Python's view, we changed that directory into a Python package. As a Python package, its name is part of the absolute name of any variable inside it, which indirectly includes our imported <code class="literal">date</code> class. We have to pass an absolute variable name to patch, so we have to start with the containing package name.</p></div></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Nose and ad hoc tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Nose and ad hoc tests</h1></div></div></div><p>Nose supports <a id="id309" class="indexterm"/>two new kinds of tests: standalone test functions, and non-<code class="literal">TestCase</code> test classes. It finds these tests by using the same pattern matching that it <a id="id310" class="indexterm"/>uses to find test modules. When looking through a module whose name matches the pattern, any functions or classes whose names also match the pattern are assumed to be tests.</p><p>We're going to write a few tests that demonstrate Nose's support for test functions and non-<code class="literal">TestCase</code> test classes.</p><p>Let's create a new test <a id="id311" class="indexterm"/>file in the <code class="literal">tests</code> directory, called <code class="literal">nose_specific_tests.py</code>. Inside the file, put the following code:</p><div class="informalexample"><pre class="programlisting">import sys
from sqlite3 import connect
from imp import reload

class grouped_tests:
    def setup(self):
        self.connection = connect(':memory:')
        cursor = self.connection.cursor()
        cursor.execute('create table test (a, b, c)')
        cursor.execute('''insert into test (a, b, c)
                          values (1, 2, 3)''')
        self.connection.commit()

    def teardown(self):
        self.connection.close()

    def test_update(self):
        cursor = self.connection.cursor()
        cursor.execute('update test set b = 7 where a = 1')

    def test_select(self):
        cursor = self.connection.cursor()
        cursor.execute('select * from test limit 1')
        assert cursor.fetchone() == (1, 2, 3)

def platform_setup():
    sys.platform = 'test platform'

def platform_teardown():
    global sys
    sys = reload(sys)

def standalone_test():
    assert sys.platform == 'test platform'

standalone_test.setup = platform_setup
standalone_test.teardown = platform_teardown</pre></div><p>Running Nose now doesn't print out very much, but the fact that the tests were run and didn't fail tells us a lot.</p><p>The <code class="literal">grouped_tests</code> class contains a test fixture (the <code class="literal">setup</code> and <code class="literal">teardown</code> methods) and two tests; but it's <a id="id312" class="indexterm"/>not a <code class="literal">unittest</code> <code class="literal">TestCase</code> class. Nose recognized it as a test class because its name follows the same pattern that Nose looks for when it checks module names to find test modules. It then looks through the class for a test fixture and any test methods, and runs them appropriately.</p><p>Since the class isn't a <code class="literal">TestCase</code> class, the tests don't have access to any of the <code class="literal">unittest</code> <code class="literal">assert</code> methods; Nose considers such a test to pass unless it raises an exception. Python has an <code class="literal">assert</code> statement that raises an exception if its expression is false, which is helpful for just this sort of thing. It's not as nice as <code class="literal">assertEqual</code>, but it does the job in many cases.</p><p>We wrote another test in the <code class="literal">standalone_test</code> function. Like <code class="literal">grouped_tests</code>, <code class="literal">standalone_test</code> is recognized as a test by Nose because its name matches the same pattern that Nose uses to search for test modules. Nose runs <code class="literal">standalone_test</code> as a test, and reports a failure if it raises an exception.</p><p>We were able to attach a <a id="id313" class="indexterm"/>test fixture to <code class="literal">standalone_test</code> by setting its <code class="literal">setup</code> and <code class="literal">teardown</code> attributes to a pair of functions that we defined for that purpose. As usual, the <code class="literal">setup</code> function runs before the test function and the <code class="literal">teardown</code> function runs after the test function.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about the Nose testing meta-framework. Specifically, we covered how Nose finds files that contain tests, and how you can adapt the process to fit into your organization scheme; how to run all of your tests with Nose, whether they are <code class="literal">doctest</code>, <code class="literal">unittest</code>, or ad hoc; how Nose enhances the other frameworks with additional support for test fixtures; and how to use Nose's support for standalone test functions and non-<code class="literal">TestCase</code> test classes.</p><p>Now that we've learned about Nose and running all of our tests easily, we're ready to tackle a complete test-driven project, which is the topic of the next chapter.</p></div></div>
</body></html>