- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Comments to Social Media Posts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A social media application is more fun if your users can comment on other posts
    or even like them. In this chapter, we’ll first learn how to add comments to posts.
    We’ll see how we can use database relationships again to create a comment section
    for each post and ensure the code quality is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Comment model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the comment serializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting routes for the comment resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the CommentViewSet class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a comment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a comment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create Django models, write
    Django serializers and validation, and write nested viewsets and routes, and will
    have a better understanding of authorization permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you need to have Insomnia installed and some knowledge about
    models, database relationships, and permissions. You’ll also need to have the
    Insomnia API client installed on your machine. The code for this chapter can be
    found here: [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Comment model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A comment in the context of this project will represent a small text that can
    be viewed by anyone but only be created or updated by authenticated users. Here’s
    what the requirements for this feature look like:'
  prefs: []
  type: TYPE_NORMAL
- en: Any user can read comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticated users can create comments under posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comment author and post author can delete comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comment author can update posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking at these requirements, we can definitely start with writing the model
    first. But first of all, let’s quickly talk about the structure of the **Comment**
    table in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The Comment table structure](img/Figure_4.01_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The Comment table structure
  prefs: []
  type: TYPE_NORMAL
- en: 'A comment will mostly have four important fields: the author of the comment,
    the post on which the comment has been made, the body of the comment, and the
    edited field to track whether the comment has been edited or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As per *Figure 4**.1*, we have two database relationships in the table: author
    and post. So, how does this schematize in the database?'
  prefs: []
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 4.2 – Comment, Post, and User relationships](img/Figure_4.02_B18221.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Comment, Post, and User relationships
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in *Figure 4**.2*, the author (`User`) and post (`Post`) fields
    are **ForeignKey** types. This relates to some rules for the comment feature:'
  prefs: []
  type: TYPE_NORMAL
- en: A user can have many comments, but a comment is created by one user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A post can have many comments, but a comment is linked to only one post
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have a structure for the table and a better understanding of the
    requirements, let’s write the model and test it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Comment model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In `core/comment/models.py`, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we are declaring a class called `CommentManager`
    which is a subclass of the `AbstractManager` class. Then, we are declaring the
    `Comment` model class with fields such as the `post` and `author` that are respectively
    `ForeignKey` fields in relation to the `Post` model and the `User` model. Finally,
    we are declaring the body and the edited field. The rest of the code is basic
    formality such as telling Django with Manager class to use to manage the `Comment`
    model and finally a default `__str__` method to return the name of the author
    when checking a comment object in the Django shell.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `Comment` model is written, let’s play with the model in the Django
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a comment in the Django shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Launch the Django shell with the following comment:'
  prefs: []
  type: TYPE_NORMAL
- en: python manage.py shell
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, we are importing the needed models to retrieve and create a comment.
    Next, we’ll retrieve a user and a post and then write the data needed in a Python
    dictionary to create a comment like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create the comment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Great, now that we are sure that the comment is working, we can write the serializer
    for the comment feature.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the comment serializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The comment serializer will help with validation and content creation. In the
    comment application, create a file named `serializers.py`. We’ll write `CommentSerializer`
    in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let’s import the classes and tools needed to create a serializer:'
  prefs: []
  type: TYPE_NORMAL
- en: /core/comment/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s done, we can now write `CommentSerializer`:'
  prefs: []
  type: TYPE_NORMAL
- en: /core/comment/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explain the code concerning the `CommentSerializer` class. To create
    a comment, we need three fields: `public_id` of the author, `public_id` of the
    post, and finally, the body. We’ve also added validation methods for the `author`
    field.'
  prefs: []
  type: TYPE_NORMAL
- en: In `validate_author`, we are blocking users from creating comments for other
    users.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, the `to_representation` method modifies the final object by adding
    information about the author.
  prefs: []
  type: TYPE_NORMAL
- en: The comment serializer is now ready. We can now proceed to write the viewsets
    concerning the comment feature. But before that, let’s talk about the endpoint
    of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting routes for the comment resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create, update, or delete comments, we need to add `ViewSet`. In the `comment`
    directory, create a file called `viewsets.py`. This file will contain the code
    for the `CommentViewSet` class. We won’t be writing the whole code for this viewset
    because we need to get some clear ideas on the structure of the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, add the following content for the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: core/comment/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, now let’s talk about the endpoint architecture. The following table
    shows the structure of the endpoint concerning the comment. You have the method,
    the URL of the endpoint, and finally, the result of a call on this endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **URL** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``api/comment/` | Lists all the comments related to a post |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``api/comment/comment_pk/` | Retrieves a specific comment |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/``api/comment/` | Creates a comment |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/``api/comment/comment_pk/` | Modifies a comment |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/``api/comment/comment_pk/` | Deletes a comment |'
  prefs: []
  type: TYPE_TB
- en: 'However, for the comment feature, we are working with posts. And it’s definitely
    a great idea if comments are directly related to posts. Therefore, a great structure
    for our endpoints will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **URL** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``api/post/post_pk/comment/` | Lists all the comments related to
    a post |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``api/post/post_pk/comment/comment_pk/` | Retrieves a specific
    comment |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `/``api/post/post_pk/comment/` | Creates a comment |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | `/``api/post/post_pk/comment/comment_pk/` | Modifies a comment |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `/``api/post/post_pk/comment/comment_pk/` | Deletes a comment
    |'
  prefs: []
  type: TYPE_TB
- en: In this structure, the endpoint is nested, meaning that comment resources live
    under post resources.
  prefs: []
  type: TYPE_NORMAL
- en: But how do we achieve this simply?
  prefs: []
  type: TYPE_NORMAL
- en: The Django ecosystem has a library called `drf-nested-routers`, which helps
    write routers to create nested resources in a Django project.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install this package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget to add the dependency in the `requirements.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Great! No need to register it in the `settings.py` file, as it doesn’t come
    with signals, models, or applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let’s configure this library to fit the needs of this project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating nested routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to configure the `drf-nested-routers` library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to rewrite the `routers.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`drf-nested-routers` comes with an extended `SimpleRouter`, which will be useful
    for creating nested routes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, create a new nested route called `POST`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`NestedSimpleRouter` is a sub-class of the `SimpleRouter` class, which takes
    initialization parameters, such as `parent_router` – `router` –`parent_prefix`
    – `r''post''` – and the lookup – `post`. The lookup is the regex variable that
    matches an instance of the parent resource – `PostViewSet`.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, the lookup regex will be `post_pk`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to register the `comment` route on `post_router`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great! The comment resource is available, but we must rewrite the `create`,
    `get_object`, and `get_queryset` methods on the `CommentViewSet` class. Let’s
    see how using nested routes can modify the logic of retrieving objects in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the CommentViewSet class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a clear idea of how the endpoint will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps in the `core/comment/viewsets.py` file to finish writing
    the `CommentViewSet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rewrite the `get_queryset` method of the `CommentViewSet` class to fit the
    new architecture of the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/comment/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `get_queryset` is the method called when the user hits
    the `/api/post/post_pk/comment/` endpoint. The first verification here is to check
    whether the user is a superuser. If that’s the case, we return all the comment
    objects in the database.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not a superuser, then we’ll return the comments concerning a
    post. With the post nested route, we set the `lookup` attribute to `post`. That
    means that in `kwargs` (a dictionary containing additional data) of every request,
    a public id value of the `post` with the dictionary key `post_pk` will be passed
    in the URL of the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: If that’s not the case, we just return a 404 Not Found response.
  prefs: []
  type: TYPE_NORMAL
- en: We then make a query to the database by filtering and retrieving only comments
    that have the `post.public_id` field equal to `post_pk`. This is done with the
    filter method provided by the Django ORM. It’s useful to write conditions for
    retrieving objects from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add the `get_object` method to the same `CommentViewSet` so we
    can use the `public_id` to retrieve the specific comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/comment/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `UserViewSet` `get_object` method, this method is called on each
    request made to the `/api/post/post_pk/comment/comment_pk/` endpoint. Here, `pk`
    is represented by `comment_pk`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we retrieve the object and check for permissions. If everything is good,
    we return the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'And as the last step, let’s write the `create` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/comment/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `create` method on `PostViewSet`, we pass `request.data` to the
    `ViewSet` serializer – `CommentSerialier` – and try to validate the serializer.
  prefs: []
  type: TYPE_NORMAL
- en: If everything is good, we move to create a new object – a new comment – based
    on the serializer from `CommentSerializer`.
  prefs: []
  type: TYPE_NORMAL
- en: Great! We now have a fully functional `ViewSet`. Next, let’s test the features
    with Insomnia.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the comments feature with Insomnia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before trying to retrieve comments, let’s create some comments with `POST`
    on the `/api/post/post_id/comment/` URL by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace `post_id` with `public_id` of a post that you have already created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of a payload for this request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s a screenshot of a request made to create a comment in Insomnia:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Creating a post](img/Figure_4.03_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Creating a post
  prefs: []
  type: TYPE_NORMAL
- en: 'Great! Now, modify the type of request from `POST` to `GET`. You’ll get all
    the comments concerning the post:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Listing all comments](img/Figure_4.04_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Listing all comments
  prefs: []
  type: TYPE_NORMAL
- en: Now that it’s possible to create a comment without issues, let’s add a feature
    for updating a comment and deleting a comment.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a comment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Updating a comment is an action that can only be done by the author of the
    comment. And the user should only be able to update the body field of the comment
    and can’t modify the author value. Follow these steps to add the update feature:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `core/comment/viewsets`, make sure that `put` is in the list of `http_method_names`
    of `CommentViewSet`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/comment/viewsets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After that, let’s write a `validate` method for the `post` field. We want to
    make sure that this value is not editable on `PUT` requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `core/comment/serializers.py` file, add a new method called `validate_post`
    to `CommentSerializer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/comment/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Every model serializer provides an `instance` attribute that holds the object
    that will be modified if there is a `delete`, `put`, or `patch` request. If this
    is a `GET` or `POST` request, this attribute is set to `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s rewrite the `update` method on the `CommentSerializer` class. We’ll
    rewrite this class to pass the edited value to `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/comment/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, let’s try a `PUT` request in Insomnia on the `/api/post/post_pk/comment/comment_pk/`
    endpoint. Here’s an example of a JSON body for the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And here’s a screenshot of a `PUT` request in Insomnia:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Modifying a post](img/Figure_4.05_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Modifying a post
  prefs: []
  type: TYPE_NORMAL
- en: You will notice in the response body that the `edited` field is set to `true`,
    and the body of the comment has changed as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now that it’s possible to modify a comment, let’s add the feature for deleting
    a comment.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a comment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting a comment is an action that can only be performed by the author of
    the post, the author of the comment, and a superuser. To implement this rule,
    we’ll simply add some permissions in the `UserPermission` class by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that `delete` is in the list of `http_method_names` of the `CommentViewSet`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/comment/viewsets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s done, let’s add more verifications in the `core/auth/permissions`
    file in the `has_object_permission` method of the `UserPermission` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: core/auth/permissions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All requests can be made on the `post-comment` endpoint. However, if the method
    of the request is `DELETE`, we check whether the user is a superuser, the author
    of the comment, or the author of the post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to delete the comment in Insomnia at this endpoint: `/api/post/post_pk/comment/comment_pk/`.
    Make sure you have the access token of the post author or the comment author.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And here’s a screenshot of a `DELETE` request to delete a comment under a post:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Deleting a post](img/Figure_4.06_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Deleting a post
  prefs: []
  type: TYPE_NORMAL
- en: Great, the feature is working like a charm. And we’ve just learned how to write
    permissions for a `DELETE` request.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve learned how to create a comment feature for the posts
    in our social media projects. That led us to learn more about how to better structure
    an endpoint using nested routers but also how to write custom permissions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also dived deeper into serializer validations and how they work on different
    HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll focus on writing unit and integration tests for every
    feature added to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a nested route?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `drf-nested-routers`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which attribute on a model serializer can help you to know whether the request
    is a `PUT` or a `DELETE` request?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
