- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Adding Comments to Social Media Posts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向社交媒体帖子添加评论
- en: A social media application is more fun if your users can comment on other posts
    or even like them. In this chapter, we’ll first learn how to add comments to posts.
    We’ll see how we can use database relationships again to create a comment section
    for each post and ensure the code quality is maintained.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的用户可以在其他帖子下评论甚至点赞，那么社交媒体应用会更有趣。在本章中，我们将首先学习如何向帖子添加评论。我们将看到如何再次使用数据库关系为每个帖子创建一个评论部分，并确保代码质量得到保持。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Writing the Comment model
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写评论模型
- en: Writing the comment serializer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写评论序列化器
- en: Nesting routes for the comment resource
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为评论资源嵌套路由
- en: Writing the CommentViewSet class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写CommentViewSet类
- en: Updating a comment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新评论
- en: Deleting a comment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除评论
- en: By the end of this chapter, you will be able to create Django models, write
    Django serializers and validation, and write nested viewsets and routes, and will
    have a better understanding of authorization permissions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建Django模型，编写Django序列化器和验证，编写嵌套视图集和路由，并对授权权限有更好的理解。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you need to have Insomnia installed and some knowledge about
    models, database relationships, and permissions. You’ll also need to have the
    Insomnia API client installed on your machine. The code for this chapter can be
    found here: [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要安装Insomnia并了解一些关于模型、数据库关系和权限的知识。你还需要在你的机器上安装Insomnia API客户端。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap4)。
- en: Writing the Comment model
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写评论模型
- en: 'A comment in the context of this project will represent a small text that can
    be viewed by anyone but only be created or updated by authenticated users. Here’s
    what the requirements for this feature look like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目的上下文中，一个评论将代表一个任何人都可以查看但只有认证用户可以创建或更新的简短文本。以下是该功能的需求：
- en: Any user can read comments
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何用户都可以阅读评论
- en: Authenticated users can create comments under posts
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证用户可以在帖子下创建评论
- en: The comment author and post author can delete comments
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论作者和帖子作者可以删除评论
- en: The comment author can update posts
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评论作者可以更新帖子
- en: 'Looking at these requirements, we can definitely start with writing the model
    first. But first of all, let’s quickly talk about the structure of the **Comment**
    table in the database:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这些需求，我们肯定可以从编写模型开始。但首先，让我们快速谈谈数据库中**评论**表的结构：
- en: '![Figure 4.1 – The Comment table structure](img/Figure_4.01_B18221.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 评论表结构](img/Figure_4.01_B18221.jpg)'
- en: Figure 4.1 – The Comment table structure
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 评论表结构
- en: 'A comment will mostly have four important fields: the author of the comment,
    the post on which the comment has been made, the body of the comment, and the
    edited field to track whether the comment has been edited or not.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个评论通常有四个重要的字段：评论的作者、评论所在的帖子、评论正文以及编辑字段，用于跟踪评论是否被编辑。
- en: 'As per *Figure 4**.1*, we have two database relationships in the table: author
    and post. So, how does this schematize in the database?'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4*.1所示，我们在表中有两个数据库关系：作者和帖子。那么，这个结构在数据库中是如何体现的呢？
- en: "![\uFEFFFigure 4.2 – Comment, Post, and User relationships](img/Figure_4.02_B18221.jpg)"
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 评论、帖子与用户关系](img/Figure_4.02_B18221.jpg)'
- en: Figure 4.2 – Comment, Post, and User relationships
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 评论、帖子与用户关系
- en: 'As you can see in *Figure 4**.2*, the author (`User`) and post (`Post`) fields
    are **ForeignKey** types. This relates to some rules for the comment feature:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图4*.2所示，作者（`User`）和帖子（`Post`）字段是**外键**类型。这关系到评论功能的某些规则：
- en: A user can have many comments, but a comment is created by one user
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户可以有多个评论，但一个评论是由一个用户创建的
- en: A post can have many comments, but a comment is linked to only one post
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个帖子可以有多个评论，但一个评论只与一个帖子相关联
- en: Now that we have a structure for the table and a better understanding of the
    requirements, let’s write the model and test it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了表的结构和对需求的更好理解，让我们编写模型并对其进行测试。
- en: Adding the Comment model
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加评论模型
- en: 'In `core/comment/models.py`, add the following content:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/comment/models.py`中添加以下内容：
- en: core/comment/models.py
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/models.py
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, we are declaring a class called `CommentManager`
    which is a subclass of the `AbstractManager` class. Then, we are declaring the
    `Comment` model class with fields such as the `post` and `author` that are respectively
    `ForeignKey` fields in relation to the `Post` model and the `User` model. Finally,
    we are declaring the body and the edited field. The rest of the code is basic
    formality such as telling Django with Manager class to use to manage the `Comment`
    model and finally a default `__str__` method to return the name of the author
    when checking a comment object in the Django shell.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们声明了一个名为`CommentManager`的类，它是`AbstractManager`类的子类。然后，我们声明了`Comment`模型类，其中包含`post`和`author`字段，这些字段分别与`Post`模型和`User`模型相关联，是`ForeignKey`字段。最后，我们声明了正文和编辑字段。其余的代码是基本的礼节，比如告诉Django使用Manager类来管理`Comment`模型，最后在Django
    shell中检查评论对象时返回作者的默认`__str__`方法。
- en: Now that the `Comment` model is written, let’s play with the model in the Django
    shell.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经编写了`Comment`模型，让我们在Django shell中玩一下这个模型。
- en: Creating a comment in the Django shell
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Django shell中创建评论
- en: 'Launch the Django shell with the following comment:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下评论启动Django shell：
- en: python manage.py shell
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: python manage.py shell
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First of all, we are importing the needed models to retrieve and create a comment.
    Next, we’ll retrieve a user and a post and then write the data needed in a Python
    dictionary to create a comment like so:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们正在导入所需的模型以检索和创建一个评论。接下来，我们将检索一个用户和一个帖子，然后将创建评论所需的数据写入一个Python字典，如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we can create the comment as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以按照以下方式创建评论：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Great, now that we are sure that the comment is working, we can write the serializer
    for the comment feature.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们确信评论功能正常，我们可以编写评论功能的序列化器。
- en: Writing the comment serializer
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写评论序列化器
- en: The comment serializer will help with validation and content creation. In the
    comment application, create a file named `serializers.py`. We’ll write `CommentSerializer`
    in this file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 评论序列化器将帮助进行验证和内容创建。在评论应用程序中，创建一个名为`serializers.py`的文件。我们将在这个文件中编写`CommentSerializer`。
- en: 'First of all, let’s import the classes and tools needed to create a serializer:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们导入创建序列化器所需的类和工具：
- en: /core/comment/serializers.py
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: /core/comment/serializers.py
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once it’s done, we can now write `CommentSerializer`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们现在可以编写`CommentSerializer`：
- en: /core/comment/serializers.py
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: /core/comment/serializers.py
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s explain the code concerning the `CommentSerializer` class. To create
    a comment, we need three fields: `public_id` of the author, `public_id` of the
    post, and finally, the body. We’ve also added validation methods for the `author`
    field.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释与`CommentSerializer`类相关的代码。要创建一个评论，我们需要三个字段：作者的`public_id`、帖子的`public_id`以及最后的正文。我们还为`author`字段添加了验证方法。
- en: In `validate_author`, we are blocking users from creating comments for other
    users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`validate_author`中，我们阻止用户为其他用户创建评论。
- en: And finally, the `to_representation` method modifies the final object by adding
    information about the author.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`to_representation`方法通过添加有关作者的信息来修改最终对象。
- en: The comment serializer is now ready. We can now proceed to write the viewsets
    concerning the comment feature. But before that, let’s talk about the endpoint
    of the resource.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 评论序列化器现在已准备就绪。我们现在可以继续编写与评论功能相关的视图集。但在那之前，让我们谈谈资源的端点。
- en: Nesting routes for the comment resource
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为评论资源嵌套路由
- en: To create, update, or delete comments, we need to add `ViewSet`. In the `comment`
    directory, create a file called `viewsets.py`. This file will contain the code
    for the `CommentViewSet` class. We won’t be writing the whole code for this viewset
    because we need to get some clear ideas on the structure of the endpoint.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建、更新或删除评论，我们需要添加`ViewSet`。在`comment`目录中创建一个名为`viewsets.py`的文件。这个文件将包含`CommentViewSet`类的代码。我们不会为这个视图集编写完整的代码，因为我们需要清楚地了解端点的结构。
- en: 'So, add the following content for the moment:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，暂时添加以下内容：
- en: core/comment/viewsets.py
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/viewsets.py
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Great, now let’s talk about the endpoint architecture. The following table
    shows the structure of the endpoint concerning the comment. You have the method,
    the URL of the endpoint, and finally, the result of a call on this endpoint:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在让我们谈谈端点架构。以下表格显示了与评论相关的端点结构。您有方法、端点的URL，以及最终在端点上调用时的结果：
- en: '| **Method** | **URL** | **Result** |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **URL** | **结果** |'
- en: '| `GET` | `/``api/comment/` | Lists all the comments related to a post |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/comment/` | 列出与帖子相关的所有评论 |'
- en: '| `GET` | `/``api/comment/comment_pk/` | Retrieves a specific comment |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/comment/comment_pk/` | 获取特定的评论 |'
- en: '| `POST` | `/``api/comment/` | Creates a comment |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/comment/` | 创建一条评论 |'
- en: '| `PUT` | `/``api/comment/comment_pk/` | Modifies a comment |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/api/comment/comment_pk/` | 修改一条评论 |'
- en: '| `DELETE` | `/``api/comment/comment_pk/` | Deletes a comment |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/api/comment/comment_pk/` | 删除一条评论 |'
- en: 'However, for the comment feature, we are working with posts. And it’s definitely
    a great idea if comments are directly related to posts. Therefore, a great structure
    for our endpoints will look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于评论功能，我们正在处理帖子。如果评论直接与帖子相关，那绝对是一个好主意。因此，我们端点的一个很好的结构将如下所示：
- en: '| **Method** | **URL** | **Action** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **URL** | **操作** |'
- en: '| `GET` | `/``api/post/post_pk/comment/` | Lists all the comments related to
    a post |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/post/post_pk/comment/` | 列出与帖子相关的所有评论 |'
- en: '| `GET` | `/``api/post/post_pk/comment/comment_pk/` | Retrieves a specific
    comment |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/post/post_pk/comment/comment_pk/` | 获取特定的评论 |'
- en: '| `POST` | `/``api/post/post_pk/comment/` | Creates a comment |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/post/post_pk/comment/` | 创建一条评论 |'
- en: '| `PUT` | `/``api/post/post_pk/comment/comment_pk/` | Modifies a comment |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/api/post/post_pk/comment/comment_pk/` | 修改一条评论 |'
- en: '| `DELETE` | `/``api/post/post_pk/comment/comment_pk/` | Deletes a comment
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/api/post/post_pk/comment/comment_pk/` | 删除一条评论 |'
- en: In this structure, the endpoint is nested, meaning that comment resources live
    under post resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，端点是嵌套的，这意味着评论资源位于帖子资源之下。
- en: But how do we achieve this simply?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何简单地实现这一点呢？
- en: The Django ecosystem has a library called `drf-nested-routers`, which helps
    write routers to create nested resources in a Django project.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Django生态系统有一个名为`drf-nested-routers`的库，它有助于在Django项目中编写路由器以创建嵌套资源。
- en: 'You can install this package with the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令安装此软件包：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Don’t forget to add the dependency in the `requirements.txt` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在`requirements.txt`文件中添加依赖项。
- en: Great! No need to register it in the `settings.py` file, as it doesn’t come
    with signals, models, or applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！不需要在`settings.py`文件中注册它，因为它不包含信号、模型或应用程序。
- en: In the next section, let’s configure this library to fit the needs of this project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们配置这个库以满足本项目的需求。
- en: Creating nested routes
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建嵌套路由
- en: 'Follow these steps to configure the `drf-nested-routers` library:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置`drf-nested-routers`库：
- en: 'The first thing to do is to rewrite the `routers.py` file:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首件事是重写`routers.py`文件：
- en: core/routers.py
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`drf-nested-routers` comes with an extended `SimpleRouter`, which will be useful
    for creating nested routes.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`drf-nested-routers`附带一个扩展的`SimpleRouter`，这对于创建嵌套路由非常有用。'
- en: 'After that, create a new nested route called `POST`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个新的嵌套路由`POST`：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`NestedSimpleRouter` is a sub-class of the `SimpleRouter` class, which takes
    initialization parameters, such as `parent_router` – `router` –`parent_prefix`
    – `r''post''` – and the lookup – `post`. The lookup is the regex variable that
    matches an instance of the parent resource – `PostViewSet`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`NestedSimpleRouter`是`SimpleRouter`类的子类，它接受初始化参数，例如`parent_router` – `router`
    – `parent_prefix` – `r''post''` – 以及查找 – `post`。查找是匹配父资源实例（`PostViewSet`）的正则表达式变量。'
- en: In our case, the lookup regex will be `post_pk`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，查找正则表达式将是`post_pk`。
- en: 'The next step is to register the `comment` route on `post_router`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在`post_router`上注册`comment`路由：
- en: core/routers.py
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Great! The comment resource is available, but we must rewrite the `create`,
    `get_object`, and `get_queryset` methods on the `CommentViewSet` class. Let’s
    see how using nested routes can modify the logic of retrieving objects in the
    next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！评论资源现在可用，但我们必须在`CommentViewSet`类上重新编写`create`、`get_object`和`get_queryset`方法。让我们看看在下一节中如何使用嵌套路由来修改获取对象的逻辑。
- en: Writing the CommentViewSet class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写CommentViewSet类
- en: We now have a clear idea of how the endpoint will work.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对端点的工作方式有了清晰的认识。
- en: 'Follow these steps in the `core/comment/viewsets.py` file to finish writing
    the `CommentViewSet` class:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在`core/comment/viewsets.py`文件中完成`CommentViewSet`类的编写：
- en: 'Rewrite the `get_queryset` method of the `CommentViewSet` class to fit the
    new architecture of the endpoint:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新编写`CommentViewSet`类的`get_queryset`方法以适应端点的新架构：
- en: core/comment/viewsets.py
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/viewsets.py
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code, `get_queryset` is the method called when the user hits
    the `/api/post/post_pk/comment/` endpoint. The first verification here is to check
    whether the user is a superuser. If that’s the case, we return all the comment
    objects in the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`get_queryset` 是当用户点击 `/api/post/post_pk/comment/` 端点时调用的方法。这里的第一个验证是检查用户是否是超级用户。如果是这样，我们将返回数据库中所有的评论对象。
- en: If the user is not a superuser, then we’ll return the comments concerning a
    post. With the post nested route, we set the `lookup` attribute to `post`. That
    means that in `kwargs` (a dictionary containing additional data) of every request,
    a public id value of the `post` with the dictionary key `post_pk` will be passed
    in the URL of the endpoint.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不是超级用户，我们将返回与帖子相关的评论。通过嵌套路由的帖子，我们将 `lookup` 属性设置为 `post`。这意味着在每次请求的 `kwargs`（包含额外数据的字典）中，将传递一个具有字典键
    `post_pk` 的 `post` 的公共 ID 值到端点的 URL 中。
- en: If that’s not the case, we just return a 404 Not Found response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是这样，我们只返回一个 404 未找到响应。
- en: We then make a query to the database by filtering and retrieving only comments
    that have the `post.public_id` field equal to `post_pk`. This is done with the
    filter method provided by the Django ORM. It’s useful to write conditions for
    retrieving objects from the database.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过过滤和检索只有 `post.public_id` 字段等于 `post_pk` 的评论来对数据库进行查询。这是通过 Django ORM 提供的过滤方法完成的。编写用于从数据库检索对象的条件的代码是有用的。
- en: 'Next, let’s add the `get_object` method to the same `CommentViewSet` so we
    can use the `public_id` to retrieve the specific comment:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们向同一个 `CommentViewSet` 添加 `get_object` 方法，这样我们就可以使用 `public_id` 来检索特定的评论：
- en: core/comment/viewsets.py
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/viewsets.py
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to the `UserViewSet` `get_object` method, this method is called on each
    request made to the `/api/post/post_pk/comment/comment_pk/` endpoint. Here, `pk`
    is represented by `comment_pk`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `UserViewSet` 上的 `get_object` 方法类似，这个方法在每次向 `/api/post/post_pk/comment/comment_pk/`
    端点发出的请求上被调用。在这里，`pk` 由 `comment_pk` 表示。
- en: Then, we retrieve the object and check for permissions. If everything is good,
    we return the object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检索对象并检查权限。如果一切正常，我们返回该对象。
- en: 'And as the last step, let’s write the `create` method:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，让我们编写 `create` 方法：
- en: core/comment/viewsets.py
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/viewsets.py
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similar to the `create` method on `PostViewSet`, we pass `request.data` to the
    `ViewSet` serializer – `CommentSerialier` – and try to validate the serializer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `PostViewSet` 上的 `create` 方法类似，我们将 `request.data` 传递给 `ViewSet` 序列化器 – `CommentSerialier`
    – 并尝试验证序列化器。
- en: If everything is good, we move to create a new object – a new comment – based
    on the serializer from `CommentSerializer`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们将根据 `CommentSerializer` 创建一个新对象 – 一个新的评论。
- en: Great! We now have a fully functional `ViewSet`. Next, let’s test the features
    with Insomnia.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在有一个完全功能的 `ViewSet`。接下来，让我们使用 Insomnia 测试这些功能。
- en: Testing the comments feature with Insomnia
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Insomnia 测试评论功能
- en: 'Before trying to retrieve comments, let’s create some comments with `POST`
    on the `/api/post/post_id/comment/` URL by following these steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试检索评论之前，让我们按照以下步骤在 `/api/post/post_id/comment/` URL 上使用 `POST` 创建一些评论：
- en: Replace `post_id` with `public_id` of a post that you have already created.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `post_id` 替换为你已经创建的帖子的 `public_id`。
- en: 'Here’s an example of a payload for this request:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个请求的负载示例：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here’s a screenshot of a request made to create a comment in Insomnia:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是向 Insomnia 发起创建评论请求的截图：
- en: '![Figure 4.3 – Creating a post](img/Figure_4.03_B18221.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 创建帖子](img/Figure_4.03_B18221.jpg)'
- en: Figure 4.3 – Creating a post
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 创建帖子
- en: 'Great! Now, modify the type of request from `POST` to `GET`. You’ll get all
    the comments concerning the post:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！现在，将请求类型从 `POST` 更改为 `GET`。你将获得所有关于帖子的评论：
- en: '![Figure 4.4 – Listing all comments](img/Figure_4.04_B18221.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 列出所有评论](img/Figure_4.04_B18221.jpg)'
- en: Figure 4.4 – Listing all comments
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 列出所有评论
- en: Now that it’s possible to create a comment without issues, let’s add a feature
    for updating a comment and deleting a comment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以无问题地创建评论了，让我们添加更新评论和删除评论的功能。
- en: Updating a comment
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新评论
- en: 'Updating a comment is an action that can only be done by the author of the
    comment. And the user should only be able to update the body field of the comment
    and can’t modify the author value. Follow these steps to add the update feature:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 更新评论是一个只能由评论作者执行的操作。用户只能更新评论的正文字段，不能修改作者值。按照以下步骤添加更新功能：
- en: 'In `core/comment/viewsets`, make sure that `put` is in the list of `http_method_names`
    of `CommentViewSet`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `core/comment/viewsets` 中，确保 `put` 包含在 `CommentViewSet` 类的 `http_method_names`
    列表中：
- en: core/comment/viewsets
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/viewsets
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After that, let’s write a `validate` method for the `post` field. We want to
    make sure that this value is not editable on `PUT` requests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们为 `post` 字段编写一个 `validate` 方法。我们想确保在 `PUT` 请求中此值不可编辑。
- en: 'Inside the `core/comment/serializers.py` file, add a new method called `validate_post`
    to `CommentSerializer`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `core/comment/serializers.py` 文件中，为 `CommentSerializer` 添加一个名为 `validate_post`
    的新方法：
- en: core/comment/serializers.py
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/serializers.py
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Every model serializer provides an `instance` attribute that holds the object
    that will be modified if there is a `delete`, `put`, or `patch` request. If this
    is a `GET` or `POST` request, this attribute is set to `None`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型序列化器都提供了一个 `instance` 属性，该属性包含在 `delete`、`put` 或 `patch` 请求中将要修改的对象。如果是
    `GET` 或 `POST` 请求，则此属性设置为 `None`。
- en: 'Next, let’s rewrite the `update` method on the `CommentSerializer` class. We’ll
    rewrite this class to pass the edited value to `True`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们重新编写 `CommentSerializer` 类上的 `update` 方法。我们将重写这个类，将编辑后的值传递给 `True`：
- en: core/comment/serializers.py
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/serializers.py
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Great! Now, let’s try a `PUT` request in Insomnia on the `/api/post/post_pk/comment/comment_pk/`
    endpoint. Here’s an example of a JSON body for the request:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！现在，让我们在 Insomnia 的 `/api/post/post_pk/comment/comment_pk/` 端点上尝试一个 `PUT`
    请求。以下是请求的 JSON 体的一个示例：
- en: '[PRE24]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And here’s a screenshot of a `PUT` request in Insomnia:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Insomnia 中 `PUT` 请求的截图：
- en: '![Figure 4.5 – Modifying a post](img/Figure_4.05_B18221.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 修改帖子](img/Figure_4.05_B18221.jpg)'
- en: Figure 4.5 – Modifying a post
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 修改帖子
- en: You will notice in the response body that the `edited` field is set to `true`,
    and the body of the comment has changed as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在响应体中注意到 `edited` 字段被设置为 `true`，评论的内容也发生了变化。
- en: Now that it’s possible to modify a comment, let’s add the feature for deleting
    a comment.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以修改评论了，让我们添加删除评论的功能。
- en: Deleting a comment
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除评论
- en: 'Deleting a comment is an action that can only be performed by the author of
    the post, the author of the comment, and a superuser. To implement this rule,
    we’ll simply add some permissions in the `UserPermission` class by following these
    steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 删除评论是只有帖子的作者、评论的作者和超级用户才能执行的操作。为了实现这个规则，我们将在 `UserPermission` 类中添加一些权限，按照以下步骤进行：
- en: 'Make sure that `delete` is in the list of `http_method_names` of the `CommentViewSet`
    class:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在 `CommentViewSet` 类的 `http_method_names` 列表中包含 `delete`：
- en: core/comment/viewsets
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: core/comment/viewsets
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once it’s done, let’s add more verifications in the `core/auth/permissions`
    file in the `has_object_permission` method of the `UserPermission` class:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，让我们在 `core/auth/permissions` 文件中 `UserPermission` 类的 `has_object_permission`
    方法中添加更多验证：
- en: core/auth/permissions
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/permissions
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All requests can be made on the `post-comment` endpoint. However, if the method
    of the request is `DELETE`, we check whether the user is a superuser, the author
    of the comment, or the author of the post.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有请求都可以在 `post-comment` 端点进行。然而，如果请求的方法是 `DELETE`，我们将检查用户是否是超级用户、评论的作者或帖子的作者。
- en: 'Let’s try to delete the comment in Insomnia at this endpoint: `/api/post/post_pk/comment/comment_pk/`.
    Make sure you have the access token of the post author or the comment author.'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 Insomnia 的此端点 `/api/post/post_pk/comment/comment_pk/` 上尝试删除评论。确保你有帖子的作者或评论作者的访问令牌。
- en: 'And here’s a screenshot of a `DELETE` request to delete a comment under a post:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个删除帖子下评论的 `DELETE` 请求的截图：
- en: '![Figure 4.6 – Deleting a post](img/Figure_4.06_B18221.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 删除帖子](img/Figure_4.06_B18221.jpg)'
- en: Figure 4.6 – Deleting a post
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 删除帖子
- en: Great, the feature is working like a charm. And we’ve just learned how to write
    permissions for a `DELETE` request.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，功能运行得非常顺畅。我们刚刚学习了如何为 `DELETE` 请求编写权限。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we’ve learned how to create a comment feature for the posts
    in our social media projects. That led us to learn more about how to better structure
    an endpoint using nested routers but also how to write custom permissions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在社交媒体项目中为帖子创建评论功能。这使我们进一步了解了如何使用嵌套路由更好地构建端点，以及如何编写自定义权限。
- en: We’ve also dived deeper into serializer validations and how they work on different
    HTTP requests.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还深入研究了序列化器验证以及它们在不同 HTTP 请求上的工作方式。
- en: In the next chapter, we’ll focus on writing unit and integration tests for every
    feature added to the project.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于为项目添加的每个功能编写单元和集成测试。
- en: Questions
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a nested route?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是嵌套路由？
- en: What is `drf-nested-routers`?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 `drf-nested-routers`？
- en: Which attribute on a model serializer can help you to know whether the request
    is a `PUT` or a `DELETE` request?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型序列化器上的哪个属性可以帮助你判断请求是 `PUT` 还是 `DELETE` 请求？
