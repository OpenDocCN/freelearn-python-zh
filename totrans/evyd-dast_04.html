<html><head></head><body>
<div class="book" title="Chapter&#xA0;4.&#xA0;Stacks: LIFO Collections" id="RL0A1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Stacks: LIFO Collections</h1></div></div></div><p class="calibre7">A <span class="strong"><strong class="calibre16">stack</strong></span> is an abstract data structure that serves as a collection of objects that are inserted and removed based on a <span class="strong"><strong class="calibre16">last-in first-out</strong></span> (<span class="strong"><strong class="calibre16">LIFO</strong></span>) principle. Accordingly, the two operations that most clearly define a stack structure are <span class="strong"><strong class="calibre16">push</strong></span>, which adds objects to the collection, and <span class="strong"><strong class="calibre16">pop</strong></span>, which removes objects from the collection. Other common operations include peek, clear, count, empty and full, all of which will be examined in the Advanced topics section later in this chapter.</p><p class="calibre7">Stacks can be either array-based or linked list-based. And, similar to linked lists, stacks can be either sorted or unsorted. Considering the structure of a linked list, a linked list-based stack will be more efficient for sorting operations than an array-based stack.</p><p class="calibre7">A stack data structure is well suited for any application that requires the ability to add and remove objects only from the tail of a list. A good example of this is backtracking along a specified path or series of operations. If the application allows for adding or removing data from any point within the collection, then a linked list would be a better choice than the data structures we have already examined.</p><p class="calibre7">In this chapter we will cover:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Definition of a Stack data structure</li><li class="listitem">Initializing stacks</li><li class="listitem">Case study: motion planning algorithm</li><li class="listitem">Stack implementations</li><li class="listitem">Common stack operations</li><li class="listitem">Array-based stacks</li><li class="listitem">List-based stacks</li><li class="listitem">Searching</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Stacks: LIFO Collections" id="RL0A1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Initializing stacks"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec21" class="calibre1"/>Initializing stacks</h1></div></div></div><p class="calibre7">Each language provides varying levels of support for the stack data structure. The following are some examples of initializing the collection, adding an object to the collection, and then removing the top object from the collection.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">C# provides a concrete implementation of the stack data structure through the <code class="literal">Stack&lt;T&gt;</code> generic class.</p><pre class="programlisting">    Stack&lt;MyObject&gt; aStack = new Stack&lt;MyObject&gt;(); 
    aStack.Push(anObject); 
    aStack.Pop(); 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Java provides a concrete implementation of the stack data structure through the <code class="literal">Stack&lt;T&gt;</code> generic class.</p><pre class="programlisting">    Stack&lt;MyObject&gt; aStack = new Stack&lt;MyObject&gt;(); 
    aStack.push(anObject); 
    aStack.pop(); 
</pre><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Objective-C does not provide a concrete implementation of the stack data structure, but one can be easily creating using the class cluster <code class="literal">NSMutableArray</code>. Be aware that this will create an array-based implementation of the stack, which is generally less efficient than a linked list-based implementation.</p><pre class="programlisting">    NSMutableArray&lt;MyObject *&gt; *aStack = [NSMutableArray array]; 
    [aStack addObject:anObject]; 
    [aStack removeLastObject]; 
</pre></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Stacks: LIFO Collections" id="RL0A1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Initializing stacks">
<div class="book" title="UINavigationController"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch04lvl2sec23" class="calibre1"/>UINavigationController</h2></div></div></div><p class="calibre7">It's not entirely accurate to state that Objective-C does not provide a stack data structure. Any amount of iOS programming in Objective-C will immediately expose a developer to an implementation of the stack data structure through use of the <code class="literal">UINavigationController</code> class.</p><p class="calibre7">The <code class="literal">UINavigationController</code> class manages the navigation stack, which is an array-based stack of view controllers. The class exposes several methods corresponding to the basic stack operations. These include <code class="literal">pushViewController:animated:</code> (<span class="strong"><em class="calibre20">push</em></span>), <code class="literal">popViewControllerAnimated:</code> (<span class="strong"><em class="calibre20">pop</em></span>), <code class="literal">popToRootViewControllerAnimated:</code> (<span class="strong"><em class="calibre20">clear</em></span>...sort of), and <code class="literal">topViewController:</code> (<span class="strong"><em class="calibre20">peek</em></span>). The navigation stack is never <span class="strong"><em class="calibre20">empty</em></span> unless it is a <span class="strong"><em class="calibre20">nil</em></span> object, and it can only be considered <span class="strong"><em class="calibre20">full</em></span> when your app adds so many view controllers that the device runs out of system resources.</p><p class="calibre7">Since this is an array-based implementation, you can get the <span class="strong"><em class="calibre20">count</em></span> of the stack by simply examining <code class="literal">count</code> on the collection itself. However, this is not a collection class you can use for just any purpose in your application. If you need a stack for more general circumstances, you are going to need to build one of your own.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Like Objective-C, Swift does not provide a concrete implementation of the stack data structure, but the Array class does expose some stack-like operations. The following example demonstrates the <code class="literal">popLast()</code> method, which removes and returns the last object in the array:</p><pre class="programlisting">    var aStack: Array [MyObject](); 
    aStack.append(anObject) 
    aStack.popLast() 
</pre></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Stacks: LIFO Collections" id="RL0A1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Initializing stacks">
<div class="book" title="Stack operations"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_3"><a id="ch04lvl2sec24" class="calibre1"/>Stack operations</h2></div></div></div><p class="calibre7">Not all implementations of stack data structures expose the same operational methods. However, the more common operations should be available or made available as needed by the developer. Each of these operations, whether they are part of an array-based implementation or a linked list-based one, have an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>).</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">push</strong></span>: The push operation adds a new object onto the stack by either appending to the collection, if it is array-based, or adding a new node to the collection if it is linked list-based.</li><li class="listitem"><span class="strong"><strong class="calibre16">pop</strong></span>: The pop operation is the opposite of push. In most implementations, the pop operation both removes and returns the top object off the stack to the caller.</li><li class="listitem"><span class="strong"><strong class="calibre16">peek</strong></span>: The peek operation returns the top object off the stack to the caller, but does not remove the object from the collection.</li><li class="listitem"><span class="strong"><strong class="calibre16">clear</strong></span>: The clear operation removes all objects from the stack, effectively resetting the collection to the empty state.</li><li class="listitem"><span class="strong"><strong class="calibre16">count</strong></span>: The count operation, sometimes referred to as size or length, returns the total number of objects in the collection.</li><li class="listitem"><span class="strong"><strong class="calibre16">empty</strong></span>: The empty operation typically returns a Boolean value denoting whether the collection has any objects.</li><li class="listitem"><span class="strong"><strong class="calibre16">full</strong></span>: The full operation typically returns a Boolean value denoting whether the collection is at capacity or if there is still room to add more objects.</li></ul></div></div></div></div>
<div class="book" title="Case study: motion planning algorithm"><div class="book" id="SJGS2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec22" class="calibre1"/>Case study: motion planning algorithm</h1></div></div></div><p class="calibre7"><span class="strong"><strong class="calibre16">Business problem</strong></span>: An industrial engineer programs a robotic manufacturing device to insert bolts in sequential receptacles on a widget, then attach and tighten nuts onto each bolt. The robot carriers a different tool for each operation, and can switch between them automatically on command. However, the process of switching between tools adds considerable time to the overall workflow, especially when the tool is switched back and forth over each bolt. This has been identified as a source of inefficiency, and the engineer wants to improve the speed of the process, reducing the overall time required to complete each unit.</p><p class="calibre7">In order to eliminate the latency introduced by switching between tools repeatedly, the engineer decides to program the robot to install all of the bolts first, and then switch tools before returning and installing all of the nuts. To further improve performance, he does not want the robot to reset to it's original starting position, but instead he wants it to retrace it's own steps while installing the nuts. By removing the reset before installing the nuts, his workflow eliminates two additional traversals across the widget. To accomplish his goals, the engineer needs to store the commands used to move the robot across the widget while inserting the bolts, and then play them back in reverse order.</p><p class="calibre7">Due to the nature of the data and the application, the class that represents the commands will need several basic pieces of functionality. First, it requires some mechanism for adding and removing commands as part of normal operation, as well as the ability to reset the system when the workflow encounters an error. In the case of a reset, the class must be able to report the count of commands currently waiting to be executed in order to account for inventory loss. Finally, the class should be able to easily report when the command list is at capacity or when the commands have all been completed.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">As we have seen in the prior implementation examples, C# conveniently exposes a stack data structure through the <code class="literal">Stack&lt;T&gt;</code> class. There follows an example of what a simple implementation in C# might look like:</p><pre class="programlisting">    public Stack&lt;Command&gt; _commandStack { get; private set; } 
    int _capacity; 
    public CommandStack(int commandCapacity) 
    { 
        this._commandStack = new Stack&lt;Command&gt;(commandCapacity); 
        this._capacity = commandCapacity; 
    } 
</pre><p class="calibre7">Our class declares two fields. The first is <code class="literal">_commandStack</code>, which represents our stack data structure and the core of this class. The field is publicly visible but can only be modified by the methods within our class. The second field is <code class="literal">_capacity</code>. This field maintains our caller-defined maximum number of commands in the collection. Finally, the constructor initializes <code class="literal">_commandStack</code> and assigns <code class="literal">commandCapacity</code> to <code class="literal">_capacity</code>.</p><pre class="programlisting">    public bool IsFull() 
    { 
        return this._commandStack.Count &gt;= this._capacity; 
    }  
 
    public bool IsEmpty() 
    { 
        return this._commandStack.Count == 0; 
    } 
</pre><p class="calibre7">Our first order of business is to establish some validation for our collection. The first validation method, <code class="literal">IsFull()</code>, checks if our stack has reached it's capacity. Since our business rules state that the robot must backtrack through all of its commands before it can proceed to a new widget, we will always track the number of commands that are being added into our collection. If for whatever reason we find that we have exceeded the pre-defined capacity for <code class="literal">_commandStack</code>, something has gone wrong during the previous backtracking operation and must be addressed. Therefore, we check that <code class="literal">_commandStack.Count</code> is greater than or equal to <code class="literal">_capacity</code> and return the value. <code class="literal">IsEmpty()</code> is the next validation method. This method must be called prior to any operations that could attempt to read from our stack by <span class="strong"><em class="calibre20">peeking</em></span> at the collection. Both of these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public bool PerformCommand(Command command) 
    { 
        if (!this.IsFull()) 
        { 
            this._commandStack.Push(command); 
            return true; 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">PerformCommand(Command)</code> method provides the <span class="strong"><em class="calibre20">push</em></span> functionality of our class. It accepts a single parameter of type <code class="literal">Command</code>, then checks if <code class="literal">_commandStack</code> is full. If it is full, the <code class="literal">PerformCmmand()</code> method returns <code class="literal">false</code>. Otherwise, we add <code class="literal">command</code> to our collection by calling the <code class="literal">Stack&lt;T&gt;.Push()</code> method. Then the method returns <code class="literal">true</code> to the caller. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public bool PerformCommands(List&lt;Command&gt; commands) 
    { 
        bool inserted = true; 
        foreach (Command c in commands) 
        { 
            inserted = this.PerformCommand(c); 
        } 
        return inserted;
    } 
</pre><p class="calibre7">In case the caller has a script of commands that can be executed successively, our class includes the <code class="literal">PerformCommands(List&lt;Command&gt;)</code> class.</p><p class="calibre7">The <code class="literal">PerformCommands()</code> method accepts a list of commands, and inserts them sequentially into our collection by calling <code class="literal">PerformCommand()</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in <code class="literal">commands</code>.</p><pre class="programlisting">    public Command UndoCommand() 
    { 
        return this._commandStack.Pop(); 
    } 
</pre><p class="calibre7">The <code class="literal">UndoCommand()</code> method provides the <span class="strong"><em class="calibre20">pop</em></span> functionality of our class. It takes no parameters, but pops the last <code class="literal">Command</code> from our stack by calling <code class="literal">Stack&lt;T&gt;.Pop()</code>. The <code class="literal">Pop()</code> method removes the last <code class="literal">Command</code> from our <code class="literal">_commandStack</code> collection and returns it. If <code class="literal">_commandStack</code> is empty, <code class="literal">Pop()</code> returns a <code class="literal">null</code> object. This behavior actually works to our advantage, at least within the scope of this block of code. Since the <code class="literal">UndoCommand()</code> method is designed to return an instance of <code class="literal">Command</code>, we would be forced to return <code class="literal">null</code> anyway if <code class="literal">_commandStack</code> were empty. Therefore, it would be a waste of time to first check <code class="literal">IsEmpty() </code>before calling <code class="literal">Pop()</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public void Reset() 
    { 
        this._commandStack.Clear(); 
    } 
 
    public int TotalCommands() 
    { 
        return this._commandStack.Count; 
    } 
</pre><p class="calibre7">The final pair of methods of our <code class="literal">CommandStack</code> class, <code class="literal">Reset()</code> and <code class="literal">TotalCommands()</code>, provide the <span class="strong"><em class="calibre20">clear</em></span> functionality and the <span class="strong"><em class="calibre20">count</em></span> functionality, respectively.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">As seen in the prior implementation examples, Java also exposes a stack data structure through the <code class="literal">Stack&lt;E&gt;</code> class, which is an extension of <code class="literal">Vector&lt;E&gt;</code> including five methods that allow it to operate as a class. However, the Java documentation for <code class="literal">Stack&lt;E&gt;</code> recommends that you should use <code class="literal">Deque&lt;E&gt;</code> in favor of <code class="literal">Stack&lt;E&gt;</code>. However, since we will be evaluating <code class="literal">Queue&lt;E&gt;</code> and <code class="literal">Deque&lt;E&gt;</code> in <a class="calibre1" title="Chapter 5. Queues: FIFO Collections" href="part0033_split_000.html#VF2I1-77f2b5b248f04368a6f723b0e9357ef3">Chapter 5</a>,<span class="strong"><em class="calibre20"> Queues: FIFO Collections</em></span>, we will use the <code class="literal">Stack&lt;E&gt;</code> class here. Here's an example of what a simple implementation in Java might look like:</p><pre class="programlisting">    private Stack&lt;Command&gt; _commandStack; 
    public Stack&lt;Command&gt; GetCommandStack() 
    { 
        return this._commandStack;
    } 
 
    int _capacity; 
 
    public CommandStack(int commandCapacity) 
    { 
        this._commandStack = new Stack&lt;Command&gt;(); 
        this._capacity = commandCapacity; 
    } 
</pre><p class="calibre7">Our class declares three fields. The first is <code class="literal">_commandStack</code>, which represents our stack data structure and the core of this class. The field is private, but we also declare a publicly visible getter called <code class="literal">GetCommandStack()</code>. This is necessary because only methods within our class should be able to modify the collection. The second field is <code class="literal">_capacity</code>. This field maintains our caller-defined maximum number of commands in the collection. Finally, the constructor initializes <code class="literal">_commandStack</code> and assigns <code class="literal">commandCapacity</code> to <code class="literal">_capacity</code>.</p><pre class="programlisting">    public boolean isFull() 
    { 
        return this._commandStack.size() &gt;= this._capacity; 
    } 
 
    public boolean isEmpty() 
    { 
        return this._commandStack.empty(); 
    } 
</pre><p class="calibre7">Again, we need to establish some validation for our collection at the outset. The first validation method, <code class="literal">isFull()</code>, checks if our stack has reached it's capacity. Since our business rules state that the robot must backtrack through all of it's commands before it can proceed to a new widget, we will track the number of commands that are being added into our collection. If for whatever reason we find that we have exceeded the pre-defined capacity for <code class="literal">_commandStack</code>, something has gone wrong during the previous backtracking operation and must be addressed. Therefore, we check that <code class="literal">_commandStack.size()</code> is greater than or equal to <code class="literal">_capacity</code> and return the value. <code class="literal">isEmpty()</code> is the next validation method. This method must be called prior to any operations that could attempt to read from our stack by <span class="strong"><em class="calibre20">peeking</em></span> at the collection. Both of these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public boolean performCommand(Command command) 
    { 
        if (!this.IsFull()) 
        { 
            this._commandStack.push(command); 
            return true; 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">performCommand(Command)</code> method provides the <span class="strong"><em class="calibre20">push</em></span> functionality of our class. It accepts a single parameter of type <code class="literal">Command</code>, then checks if <code class="literal">_commandStack</code> is full. If it is full, <code class="literal">performCmmand()</code> returns <code class="literal">false</code>. Otherwise, we add <code class="literal">command</code> to our collection by calling the <code class="literal">Stack&lt;t&gt;.push()</code> method. Then the method returns <code class="literal">true</code> to the caller. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public boolean performCommands(List&lt;Command&gt; commands) 
    { 
        boolean inserted = true; 
        for (Command c : commands) 
        { 
            inserted = this.performCommand(c); 
        } 
        return inserted; 
    } 
</pre><p class="calibre7">In case the caller has a script of commands that can be executed successively then our class includes the <code class="literal">performCommands(List&lt;Command&gt;) </code>method as well.</p><p class="calibre7">The <code class="literal">performCommands()</code> method accepts a list of commands, and inserts them sequentially into our collection by calling <code class="literal">performCommand()</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in <code class="literal">commands</code>.</p><pre class="programlisting">    public Command undoCommand() 
    { 
        return this._commandStack.pop(); 
    } 
</pre><p class="calibre7">The <code class="literal">undoCommand()</code> method provides the <span class="strong"><em class="calibre20">pop</em></span> functionality of our class. It takes no parameters, but pops the last <code class="literal">Command</code> from our stack by calling <code class="literal">Stack&lt;E&gt;.pop()</code>. The <code class="literal">pop()</code> method removes the last <code class="literal">Command</code> from our <code class="literal">_commandStack</code> collection and returns it. If <code class="literal">_commandStack </code>is empty, <code class="literal">pop() </code>returns a <code class="literal">null </code>object. As with the C# example, this behavior works to our advantage within the scope of this block of code. Since the <code class="literal">undoCommand()</code> method is designed to return an instance of <code class="literal">Command</code>, we would be forced to return <code class="literal">null </code>anyway if <code class="literal">_commandStack </code>were empty. Therefore, it would be a waste of time to first check <code class="literal">isEmpty() </code>before calling <code class="literal">pop()</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public void reset() 
    { 
        this._commandStack.removeAllElements(); 
    } 
 
    public int totalCommands() 
    { 
        return this._commandStack.size(); 
    } 
</pre><p class="calibre7">The final two methods of our <code class="literal">CommandStack</code> class, <code class="literal">Reset()</code> and <code class="literal">TotalCommands()</code>, provide the <span class="strong"><em class="calibre20">clear</em></span> and <span class="strong"><em class="calibre20">count</em></span> functionalities respectively.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">As we have seen before (and probably will again before this text is through), Objective-C does not expose an explicit concrete implementation of the stack data structure, but instead provides the <code class="literal">NSMutableArray</code> class cluster for this purpose. Some could argue that this is a weakness in Objective-C, citing that by not providing methods for every conceivable operation that a developer could need is inconvenient. On the other hand, one could argue that Objective-C is much more powerful in its simplicity, providing the developer with a streamlined API and the basic components necessary to build whichever data structure he may require. I will leave you to come to your own conclusion on the matter. Meanwhile, here's an example of what a simple implementation in Objective-C might look like:</p><pre class="programlisting">    @interface EDSCommandStack() 
    { 
        NSMutableArray&lt;EDSCommand*&gt; *_commandStack; 
        NSInteger _capacity; 
    } 
 
    -(instancetype)initWithCommandCapacity:(NSInteger)commandCapacity 
    { 
        if (self = [super init]) 
        { 
            _commandStack = [NSMutableArray array]; 
            _capacity = capacity; 
        } 
        return self; 
    } 
</pre><p class="calibre7">Our class declares two <span class="strong"><strong class="calibre16">ivar</strong></span> properties. The first is <code class="literal">_commandStack</code>, which represents our stack data structure and the core of this class. The property is private, but we also declare a publicly visible accessor called <code class="literal">commandStack</code>. This is necessary because only methods within our class should be able to modify the collection. The second property is <code class="literal">_capacity</code>. This property maintains our caller defined maximum number of commands in the collection. Finally, the constructor initializes <code class="literal">_commandStack</code> and assigns <code class="literal">commandCapacity</code> to <code class="literal">_capacity</code>.</p><pre class="programlisting">    -(BOOL)isFull 
    { 
        return [_commandStack count] &gt;= _capacity; 
    } 
 
    -(BOOL)isEmpty 
    {  
        return [_commandStack count] == 0; 
    } 
</pre><p class="calibre7">Again, we need to establish some validation for our collection at the outset. The first validation method, <code class="literal">isFull:</code>, checks if our stack has reached it's capacity. Since our business rules state that the robot must backtrack through all of it's commands before it can proceed to a new widget, we will track the number of commands that are being added into our collection. If for whatever reason we find that we have exceeded the pre-defined capacity for <code class="literal">_commandStack</code>, something has gone wrong during the previous backtracking operation and must be addressed. Therefore, we check that <code class="literal">[_commandStack count]</code> is greater than or equal to <code class="literal">_capacity</code> and return the value. <code class="literal">isEmpty:</code> is the next validation method. Both of these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note23" class="calibre1"/>Note</h3><p class="calibre7">Since Objective-C is quite forgiving about passing around <code class="literal">nil</code> objects, you may not even consider <code class="literal">isEmpty:</code> to be a validation method but more of a property in its own right. However, consider that, if this method were declared as a property, we would need to declare it as <code class="literal">readonly</code>, in addition to including the method in our implementation file. Otherwise, Objective-C would dynamically generate the ivar <code class="literal">_isEmpty</code> on our behalf, and callers could modify the value directly. For the sake of simplicity and clarity, in this case it's better to just declare the value as a method.</p></div><pre class="programlisting">    -(BOOL)performCommand:(EDSCommand*)command 
    { 
        if (![self isFull]) 
        { 
            [_commandStack addObject:command]; 
            return YES; 
        } 
        return NO; 
    } 
</pre><p class="calibre7">The <code class="literal">performCommand:</code> method provides the <span class="strong"><em class="calibre20">push</em></span> functionality of our class. It accepts a single parameter of type <code class="literal">Command</code>, then checks if <code class="literal">_commandStack</code> is full. If it is full, <code class="literal">performCmmand:</code> returns <code class="literal">NO</code>. Otherwise, we add <code class="literal">command</code> to our collection by calling the <code class="literal">addObject:</code> method. Then the method returns <code class="literal">YES</code> to the caller. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    -(BOOL)performCommands:(NSArray&lt;EDSCommand*&gt; *)commands 
    { 
        bool inserted = true; 
        for (EDSCommand *c in commands) { 
            inserted =  [self performCommand:c]; 
        } 
        return inserted; 
    } 
</pre><p class="calibre7">In case the caller has a script of commands that can be executed successively, our class includes the <code class="literal">performCommands: </code>class. <code class="literal">performCommands: </code>accepts an array of <code class="literal">EDSCommand</code> objects, and inserts them sequentially into our collection by calling <code class="literal">performCommand:</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(n) cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in <code class="literal">commands</code>.</p><pre class="programlisting">    -(EDSCommand*)undoCommand 
    { 
        EDSCommand *c = [_commandStack lastObject]; 
        [_commandStack removeLastObject]; 
        return c; 
    } 
</pre><p class="calibre7">The <code class="literal">undoCommand:</code> method provides the <span class="strong"><em class="calibre20">pop</em></span> functionality of our class. Since Objective-C does not provide a concrete implementation of the stack structure, our class needs to be somewhat creative here. This method grabs the top object from the stack by calling <code class="literal">lastObject</code>, then it removes the command from the collection by calling <code class="literal">removeLastObject</code>. Finally, it returns the <code class="literal">Command</code> object <code class="literal">c</code> to the caller. This series of calls effectively mimics the <span class="strong"><em class="calibre20">pop</em></span> functionality found in the concrete stack implementations of C# and Java. Although the method has to jump through a hoop or two to get the job done, we are always working with the last object in the array so this operation still has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    -(void)reset 
    { 
        [_commandStack removeAllObjects]; 
    } 
 
    -(NSInteger)totalCommands 
    { 
        return [_commandStack count]; 
    } 
</pre><p class="calibre7">Once again, the final pair of methods of our <code class="literal">CommandStack</code> class, <code class="literal">reset()</code> and <code class="literal">totalCommands()</code>, provide the <span class="strong"><em class="calibre20">clear</em></span> functionality and the <span class="strong"><em class="calibre20">count</em></span> functionality, respectively. Objective-C rules!</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Like Objective-C, Swift does not expose a concrete implementation of the stack data structure, but we can use the mutable, generic <code class="literal">Array</code> class for this purpose. Here's an example of what a simple implementation in Swift might look like:</p><pre class="programlisting">    public fileprivate(set) var _commandStack: Array = [Command]()
    public fileprivate(set) var _capacity: Int;
 
    public init (commandCapacity: Int) 
    { 
        _capacity = commandCapacity; 
    } 
</pre><p class="calibre7">Our class declares two properties. The first is <code class="literal">_commandStack</code>, which represents our stack data structure and is again the core of this class. The property is publicly visible but can only be modified by the methods within our class. The second property is <code class="literal">_capacity</code>. This field maintains our caller defined maximum number of commands in the collection. Finally, the constructor initializes <code class="literal">_commandStack</code> and assigns <code class="literal">commandCapacity</code> to <code class="literal">_capacity</code>.</p><pre class="programlisting">    public func IsFull() -&gt; Bool 
    { 
        return _commandStack.count &gt;= _capacity 
    } 
 
    public func IsEmpty() -&gt; Bool 
    { 
        return _commandStack.count == 0; 
    } 
</pre><p class="calibre7">As with the examples in other languages, we include two validation methods called <code class="literal">IsFull()</code> and <code class="literal">IsEmpty()</code>. The <code class="literal">IsFull()</code> method checks if our stack has reached it's capacity. Since our business rules state that the robot must backtrack through all of it's commands before it can proceed to a new widget, we will track the number of commands that are being added into our collection. If for whatever reason we find that we have exceeded the pre-defined capacity for <code class="literal">_commandStack</code>, something has gone wrong with the previous backtracking operation and must be addressed. Therefore, we check that <code class="literal">_commandStack.count</code> is greater than or equal to <code class="literal">_capacity</code> and return the value. <code class="literal">IsEmpty()</code> must be called prior to any operations that could attempt to read from our stack by <span class="strong"><em class="calibre20">peeking</em></span> at the collection. Both of these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public func PerformCommand(_command: Command) -&gt; Bool 
    { 
        if (!IsFull()) 
        { 
            _commandStack.append(command) 
            return true; 
        } 
        return false; 
    } 
</pre><p class="calibre7">The <code class="literal">PerformCommand(Command)</code> method provides the <span class="strong"><em class="calibre20">push</em></span> functionality of our class. It accepts a single parameter of type <code class="literal">Command</code>, then checks if <code class="literal">_commandStack</code> is full. If it is full, the <code class="literal">PerformCmmand()</code> method returns <code class="literal">false</code>. Otherwise, we add <code class="literal">command</code> to our collection by calling the <code class="literal">Array.append()</code> method. Then the method returns <code class="literal">true</code> to the caller. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public func PerformCommands(_commands: [Command]) -&gt; Bool 
    { 
        var inserted: Bool = true; 
        for c in commands 
        { 
            inserted = PerformCommand(c); 
        } 
        return inserted; 
    } 
</pre><p class="calibre7">In case the caller has a script of commands that can be executed successively our class includes the <code class="literal">PerformCommands(List&lt;Command&gt;)</code> class. <code class="literal">PerformCommands()</code> accepts a list of commands, and inserts them sequentially into our collection by calling the <code class="literal">PerformCommand()</code> method. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of elements in <code class="literal">commands</code>.</p><pre class="programlisting">    public func UndoCommand() -&gt; Command 
    { 
        return _commandStack.popLast()! 
    } 
</pre><p class="calibre7">The <code class="literal">UndoCommand()</code> method provides the <span class="strong"><em class="calibre20">pop</em></span> functionality of our class. It takes no parameters, but pops the last <code class="literal">Command</code> from our stack by calling <code class="literal">Array.popLast()!</code> with the forced unwrapping operator to access the value <span class="strong"><em class="calibre20">wrapped</em></span> inside the <code class="literal">return</code>, assuming the object is not <code class="literal">nil</code>. The <code class="literal">popLast()</code> method removes the top <code class="literal">Command</code> from our <code class="literal">_commandStack</code> collection and returns it. If <code class="literal">_commandStack</code> is empty, <code class="literal">popLast()</code> returns <code class="literal">nil</code>. As seen in Java and Objective-C, this behavior works to our advantage within the scope of this block of code. Since the <code class="literal">UndoCommand()</code> method is designed to return an instance of <code class="literal">Command</code>, we would be forced to return <code class="literal">nil</code> anyway if <code class="literal">_commandStack</code> were empty. Therefore, it would be a waste of time to first check <code class="literal">IsEmpty()</code> before calling <code class="literal">popLast()</code>. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">1</em></span>) cost.</p><pre class="programlisting">    public func Reset() 
    { 
        _commandStack.removeAll() 
    } 
 
    public func TotalCommands() -&gt; Int 
    { 
        return _commandStack.count; 
    } 
</pre><p class="calibre7">The final pair of methods of our <code class="literal">CommandStack</code> class, <code class="literal">Reset()</code> and <code class="literal">TotalCommands()</code>, provide the <span class="strong"><em class="calibre20">clear</em></span> and <span class="strong"><em class="calibre20">count</em></span> functionalities, respectively.</p><div class="informaltable" title="Note"><h3 class="title1"><a id="note24" class="calibre1"/>Note</h3><p class="calibre7">The <span class="strong"><strong class="calibre16">nil coalescing operator</strong></span>, or <span class="strong"><strong class="calibre16">null coalescing operator</strong></span> as it is termed in other languages, is shorthand for the more verbose ternary operator and the explicit <code class="literal">if...else</code> statement. Languages such as C# and Swift designate <code class="literal">??</code> for this operator. Swift goes a step further by including the <code class="literal">!</code>, or unwrapping operator, for cases where a return value is optional, or potentially nil. The <code class="literal">??</code> operator in Swift is necessary for defining a default value when unwrapping an <span class="strong"><strong class="calibre16">optional</strong></span> type.</p></div></div>

<div class="book" title="Advanced topics - stack implementations" id="TI1E1-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>Advanced topics - stack implementations</h1></div></div></div><p class="calibre7">Now that we have seen how stacks are used in common practice, lets examine the different types of stack implementation you may encounter. The two most common implementations are the array-based stack and the linked list-based stack. We will examine each of these here.</p></div>

<div class="book" title="Advanced topics - stack implementations" id="TI1E1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Array-based stack"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_1"><a id="ch04lvl2sec25" class="calibre1"/>Array-based stack</h2></div></div></div><p class="calibre7">An array-based stack utilizes a mutable array to represent the collection. In this implementation, the 0 position in the array represents the <span class="strong"><em class="calibre20">bottom</em></span> of the stack. Therefore, <code class="literal">array[0]</code> is the first object pushed onto the stack and the last one popped off. Array-based structures are not practical for a sorted stack as any reorganizing of the structure would require significantly more operational cost than that of a list-based stack. The Tower of Hanoi puzzle is the quintessential example of sorting am array-based stack, with an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">2<sup class="calibre21">n</sup></em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the number of plates on the starting tower. The Tower of Hanoi puzzle will be examined in more detail in <a class="calibre1" title="Chapter 12. Sorting: Bringing Order Out Of Chaos" href="part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3">Chapter 12</a>, <span class="strong"><em class="calibre20">Sorting: Bringing Order Out Of Chaos</em></span>.</p></div></div>

<div class="book" title="Advanced topics - stack implementations" id="TI1E1-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Linked list-based stack"><div class="book"><div class="book"><div class="book"><h2 class="title2" id="calibre_pb_2"><a id="ch04lvl2sec26" class="calibre1"/>Linked list-based stack</h2></div></div></div><p class="calibre7">The linked list-based stack utilizes a pointer to the <span class="strong"><em class="calibre20">bottom</em></span> object on the stack, and subsequent pointers as each new object is linked from the last object in the list. Popping an object from the top of the stack simply involves removing the last object from the collection. For applications requiring sorted data, a linked list stack is far more efficient.</p></div></div>
<div class="book" title="Summary" id="UGI01-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter we learned the basic definition of the Stack data structure, including how to initialize concrete implementations of the structure in each of the four languages we are discussing. Next, we discussed the most common operations associated with the stack data structure and their operational cost. We examined a case study using stacks to track commands passed to a robotic manufacturing device. These examples demonstrated how C# and Java provide concrete implementations of a stack whereas Objective-C and Swift do not. Finally, we examined the two most common types of stacks, the array-based and the linked-list-based, and showed how the array-based stack is not well suited for a sorted stack.</p></div></body></html>