["```py\n# moveball_1.py\n#>>>>>>>>>>>>>\nfrom Tkinter import *\nroot = Tk()\nroot.title(\"shifted sequence\")\ncw = 250 # canvas width\nch = 130 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\n# The parameters determining the dimensions of the ball and its # position.\n# ==========================================\nposn_x = 1 # x position of box containing the ball (bottom)\nposn_y = 1 # y position of box containing the ball (left edge)\nshift_x = 3 # amount of x-movement each cycle of the 'for' loop\nshift_y = 2 # amount of y-movement each cycle of the 'for' loop\nball_width = 12 # size of ball - width (x-dimension)\nball_height = 12 # size of ball - height (y-dimension)\ncolor = \"violet\" # color of the ball\nfor i in range(1,50): # end the program after 50 position shifts\nposn_x += shift_x\nposn_y += shift_y\nchart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\\\nposn_y + ball_height, fill=color)\nroot.mainloop()\n#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n```", "```py\n# timed_moveball_1.py\n#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nroot = Tk()\nroot.title(\"Time delayed ball drawing\")\ncw = 300 # canvas width\nch = 130 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 200 # time between fresh positions of the ball\n# (milliseconds).\n# The parameters determining the dimensions of the ball and it's # position.\nposn_x = 1 # x position of box containing the ball (bottom).\nposn_y = 1 # y position of box containing the ball (left edge).\nshift_x = 3 # amount of x-movement each cycle of the 'for' loop.\nshift_y = 3 # amount of y-movement each cycle of the 'for' loop.\nball_width = 12 # size of ball - width (x-dimension).\nball_height = 12 # size of ball - height (y-dimension).\ncolor = \"purple\" # color of the ball\nfor i in range(1,50): # end the program after 50 position shifts.\nposn_x += shift_x\nposn_y += shift_y\nchart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\\\nposn_y + ball_height, fill=color)\nchart_1.update() # This refreshes the drawing on the canvas.\nchart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.\nroot.mainloop()\n\n```", "```py\n# move_erase_cycle_1.py\n# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nroot = Tk()\nroot.title(\"move-and-erase\")\ncw = 230 # canvas width\nch = 130 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 50 # time between new positions of the ball\n# (milliseconds).\n# The parameters determining the dimensions of the ball and its\n# position.\nposn_x = 1 # x position of box containing the ball (bottom).\nposn_y = 1 # y position of box containing the ball (left edge).\nshift_x = 1 # amount of x-movement each cycle of the 'for' loop.\ndraw-move-pause-erase cyclesusing, in animationshift_y = 1 # amount of y-movement each cycle of the 'for' loop.\nball_width = 12 # size of ball - width (x-dimension).\nball_height = 12 # size of ball height (y-dimension).\ncolor = \"hot pink\" # color of the ball\nfor i in range(1,500): # end the program after 500 position shifts.\nposn_x += shift_x\nposn_y += shift_y\nchart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\\\nposn_y + ball_height, fill=color)\nchart_1.update() # This refreshes the drawing on the canvas.\nchart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.\nchart_1.delete(ALL) # This erases everything on the canvas.\nroot.mainloop()\n# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n```", "```py\n# two_balls_moving_1.py\n# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nroot = Tk()\nroot.title(\"Two balls\")\ncw = 200 # canvas width\nch = 130 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 100 # time between new positions of the ball\n# (milliseconds).\n# The parameters defining ball no 1.\nposn_x_1 = 1 # x position of box containing the ball (bottom).\nposn_y_1 = 1 # y position of box containing the ball (left edge).\nshift_x_1 = 1 # amount of x-movement each cycle of the 'for' loop.\nshift_y_1 = 1 # amount of y-movement each cycle of the 'for' loop.\nball_width_1 = 12 # size of ball - width (x-dimension).\nball_height_1 = 12 # size of ball - height (y-dimension).\ncolor_1 = \"blue\" # color of ball #1\n# The parameters defining ball no 2.\nposn_x_2 = 180 # x position of box containing the ball (bottom).\nmultiple objectsmovingposn_y_2 = 180 # x position of box containing the ball (left # edge).\nshift_x_2 = -2 # amount of x-movement each cycle of the 'for' # loop.\nshift_y_2 = -2 # amount of y-movement each cycle of the 'for' # loop.\nball_width_2 = 8 # size of ball - width (x-dimension).\nball_height_2 = 8 # size of ball - height (y-dimension).\ncolor_2 = \"green\" # color of ball #2.\nfor i in range(1,100): # end the program after 50 position shifts.\nposn_x_1 += shift_x_1\nposn_y_1 += shift_y_1\nposn_x_2 += shift_x_2\nposn_y_2 += shift_y_2\nchart_1.create_oval(posn_x_1, posn_y_1, posn_x_1 + ball_width_1,\\\nposn_y_1 + ball_height_1, fill=color_1)\nchart_1.create_oval(posn_x_2, posn_y_2, posn_x_2 + ball_width_2,\\\nposn_y_2 + ball_height_2, fill=color_2)\nchart_1.update() # This refreshes the drawing on the canvas.\nchart_1.after(cycle_period) # This makes execution pause for 100 # milliseconds.\nchart_1.delete(ALL) # This erases everything on the canvas\nroot.mainloop()\n# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n```", "```py\n# bounce_ball.py\n#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nimport time\nroot = Tk()\nroot.title(\"The bouncer\")\ncw = 200 # canvas width\nch = 120 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 50 # time between new positions of the ball\n# (milliseconds).\n# The parameters determining the dimensions of the ball and its position.\nposn_x = 1 # x position of box containing the ball (bottom).\nposn_y = 1 # x position of box containing the ball (left edge).\nshift_x = 1 # amount of x-movement each cycle of the 'for' loop.\nshift_y = 1 # amount of y-movement each cycle of the 'for' loop.\nball_width = 12 # size of ball - width (x-dimension).\nball_height = 12 # size of ball - height (y-dimension).\ncolor = \"firebrick\" # color of the ball\n# Here is a function that detects collisions with the walls of the # container\n# and then reverses the direction of movement if a collision is # detected.\ndef detect_wall_collision():\nglobal posn_x, posn_y, shift_x, shift_y, cw, cy\nif posn_x > cw : # Collision with right-hand container wall.\nshift_x = -shift_x # reverse direction.\nif posn_x < 0 : # Collision with left-hand wall.\nshift_x = -shift_x\nif posn_y > ch : # Collision with floor.\nballbouncingshift_y = -shift_y\nif posn_y < 0 : # Collision with ceiling.\nshift_y = -shift_y\nfor i in range(1,1000): # end the program after1000 position shifts.\nposn_x += shift_x\nposn_y += shift_y\nchart_1.create_oval(posn_x, posn_y, posn_x + ball_width,\\\nposn_y + ball_height, fill=color)\ndetect_wall_collision() # Has the ball collided with # any container wall?\nchart_1.update() # This refreshes the drawing on the canvas.\nchart_1.after(cycle_period) # This makes execution pause # for 200 milliseconds.\nchart_1.delete(ALL) # This erases everything on the canvas.\nroot.mainloop()\n#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n\n```", "```py\n# gravityball.py\n# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nroot = Tk()\nroot.title(\"Gravity bounce\")\ncw = 220 # canvas width\nch = 200 # canvas height\nGRAVITY = 4\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 30\n# The parameters determining the dimensions of the ball and its # position.\nposn_x = 15\nposn_y = 180\nshift_x = 1\nvelocity_y = 50\nball_width = 12\nball_height = 12\ncolor = \"blue\"\n# The function that detects collisions with the walls and reverses # direction\ndef detect_wall_collision():\nglobal posn_x, posn_y, shift_x, velocity_y, cw, cy\nif posn_x > cw -ball_width: # Collision with right-hand # container wall.\nshift_x = -shift_x # reverse direction.\nif posn_x < ball_width: # Collision with left-hand wall.\nshift_x = -shift_x\nballbouncing, in gravity fieldif posn_y < ball_height : # Collision with ceiling.\nvelocity_y = -velocity_y\nif posn_y > ch - ball_height : # Floor collision.\nvelocity_y = -velocity_y\nfor i in range(1,300):\nposn_x += shift_x\nvelocity_y = velocity_y + GRAVITY # a crude equation # incorporating gravity.\nposn_y += velocity_y\nchart_1.create_oval(posn_x, posn_y, posn_x + ball_width, \\\nposn_y + ball_height, \\ fill=color)\ndetect_wall_collision() # Has the ball collided with any # container wall?\nchart_1.update() # This refreshes the drawing on the canvas.\nchart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.\nchart_1.delete(ALL) # This erases everything on the canvas.\nroot.mainloop()\n\n```", "```py\nfrom Tkinter import *\nroot = Tk()\nroot.title(\"Collisions with Floating point\")\ncw = 350 # canvas width\nch = 200 # canvas height\nGRAVITY = 1.5\nchart_1 = Canvas(root, width=cw, height=ch, background=\"black\")\nchart_1.grid(row=0, column=0)\ncycle_period = 80 # Time between new positions of the ball # (milliseconds).\nsimulation flawseliminatingtime_scaling = 0.2 # This governs the size of the differential steps\n# when calculating changes in position.\n# The parameters determining the dimensions of the ball and it's # position.\nball_1 = {'posn_x':25.0, # x position of box containing the # ball (bottom).\n'posn_y':180.0, # x position of box containing the # ball (left edge).\n'velocity_x':30.0, # amount of x-movement each cycle of # the 'for' loop.\n'velocity_y':100.0, # amount of y-movement each cycle of # the 'for' loop.\n'ball_width':20.0, # size of ball - width (x-dimension).\n'ball_height':20.0, # size of ball - height (y-dimension).\n'color':\"dark orange\", # color of the ball\n'coef_restitution':0.90} # proportion of elastic energy # recovered each bounce\nball_2 = {'posn_x':cw - 25.0,\n'posn_y':300.0,\n'velocity_x':-50.0,\n'velocity_y':150.0,\n'ball_width':30.0,\nsimulation flawseliminating'ball_height':30.0,\n'color':\"yellow3\",\n'coef_restitution':0.90}\ndef detectWallCollision(ball):\n# Collision detection with the walls of the container\nif ball['posn_x'] > cw - ball['ball_width']: # Collision # with right-hand wall.\nball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \\ restitution'] # reverse direction.\nball['posn_x'] = cw - ball['ball_width']\nif ball['posn_x'] < 1: # Collision with left-hand wall.\nball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \\restitution']\nball['posn_x'] = 2 # anti-stick to the wall\nif ball['posn_y'] < ball['ball_height'] : # Collision # with ceiling.\nball['velocity_y'] = -ball['velocity_y'] * ball['coef_ \\ restitution']\nball['posn_y'] = ball['ball_height']\nif ball['posn_y'] > ch - ball['ball_height']: # Floor # collision.\nball['velocity_y'] = - ball['velocity_y'] * ball['coef_ \\restitution']\nball['posn_y'] = ch - ball['ball_height']\ndef diffEquation(ball):\n# An approximate set of differential equations of motion # for the balls\nball['posn_x'] += ball['velocity_x'] * time_scaling\nball['velocity_y'] = ball['velocity_y'] + GRAVITY # a crude # equation incorporating gravity.\nball['posn_y'] += ball['velocity_y'] * time_scaling\nchart_1.create_oval( ball['posn_x'], ball['posn_y'], ball['posn_x'] + ball['ball_width'],\\\nball ['posn_y'] + ball['ball_height'], \\ fill= ball['color'])\ndetectWallCollision(ball) # Has the ball collided with # any container wall?\nfor i in range(1,2000): # end the program after 1000 position shifts.\ndiffEquation(ball_1)\ndiffEquation(ball_2)\nchart_1.update() # This refreshes the drawing on the canvas.\nchart_1.after(cycle_period) # This makes execution pause for 200 # milliseconds.\nchart_1.delete(ALL) # This erases everything on the\nroot.mainloop()\n\n```", "```py\n# kinetic_gravity_balls_1.py\nanimationmid-air collision# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nimport math\nroot = Tk()\nroot.title(\"Balls bounce off each other\")\ncw = 300 # canvas width\nch = 200 # canvas height\nGRAVITY = 1.5\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 80 # Time between new positions of the ball # (milliseconds).\ntime_scaling = 0.2 # The size of the differential steps\n# The parameters determining the dimensions of the ball and its # position.\nball_1 = {'posn_x':25.0,\n'posn_y':25.0,\n'velocity_x':65.0,\n'velocity_y':50.0,\n'ball_width':20.0,\n'ball_height':20.0,\n'color':\"SlateBlue1\",\n'coef_restitution':0.90}\nball_2 = {'posn_x':180.0,\n'posn_y':ch- 25.0,\n'velocity_x':-50.0,\n'velocity_y':-70.0,\n'ball_width':30.0,\n'ball_height':30.0,\n'color':\"maroon1\",\n'coef_restitution':0.90}\ndef detect_wall_collision(ball):\nanimationmid-air collision# detect ball-to-wall collision\nif ball['posn_x'] > cw - ball['ball_width']: # Right-hand wall.\nball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \\restitution']\nball['posn_x'] = cw - ball['ball_width']\nif ball['posn_x'] < 1: # Left-hand wall.\nball['velocity_x'] = -ball['velocity_x'] * ball['coef_ \\restitution']\nball['posn_x'] = 2\nif ball['posn_y'] < ball['ball_height'] : # Ceiling.\nball['velocity_y'] = -ball['velocity_y'] * ball['coef_ \\restitution']\nball['posn_y'] = ball['ball_height']\nif ball['posn_y'] > ch - ball['ball_height'] : # Floor\nball['velocity_y'] = - ball['velocity_y'] * ball['coef_ \\restitution']\nball['posn_y'] = ch - ball['ball_height']\ndef detect_ball_collision(ball_1, ball_2):\n#detect ball-to-ball collision\n# firstly: is there a close approach in the horizontal direction\nif math.fabs(ball_1['posn_x'] - ball_2['posn_x']) < 25:\n# secondly: is there also a close approach in the vertical # direction.\nif math.fabs(ball_1['posn_y'] - ball_2['posn_y']) < 25:\nball_1['velocity_x'] = -ball_1['velocity_x'] # reverse # direction.\nball_1['velocity_y'] = -ball_1['velocity_y']\nball_2['velocity_x'] = -ball_2['velocity_x']\nball_2['velocity_y'] = -ball_2['velocity_y']\n# to avoid internal rebounding inside balls\nball_1['posn_x'] += ball_1['velocity_x'] * time_scaling\nball_1['posn_y'] += ball_1['velocity_y'] * time_scaling\nball_2['posn_x'] += ball_2['velocity_x'] * time_scaling\nball_2['posn_y'] += ball_2['velocity_y'] * time_scaling\nanimationmid-air collisiondef diff_equation(ball):\nx_old = ball['posn_x']\ny_old = ball['posn_y']\nball['posn_x'] += ball['velocity_x'] * time_scaling\nball['velocity_y'] = ball['velocity_y'] + GRAVITY\nball['posn_y'] += ball['velocity_y'] * time_scaling\nchart_1.create_oval( ball['posn_x'], ball['posn_y'],\\\nball['posn_x'] + ball['ball_width'],\\\nball['posn_y'] + ball['ball_height'],\\\nfill= ball['color'], tags=\"ball_tag\")\nchart_1.create_line( x_old, y_old, ball['posn_x'], \\ ball ['posn_y'], fill= ball['color'])\ndetect_wall_collision(ball) # Has the ball # collided with any container wall?\nfor i in range(1,5000):\ndiff_equation(ball_1)\ndiff_equation(ball_2)\ndetect_ball_collision(ball_1, ball_2)\nchart_1.update()\nchart_1.after(cycle_period)\nchart_1.delete(\"ball_tag\") # Erase the balls but # leave the trajectories\nroot.mainloop()\n\n```", "```py\n# rotate_line_1.py\n#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nimport math\nroot = Tk()\nroot.title(\"Rotating line\")\ncw = 220 # canvas width\nch = 180 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 50 # pause duration (milliseconds).\np1_x = 90.0 # the pivot point\np1_y = 90.0 # the pivot point,\np2_x = 180.0 # the specific point to be rotated\np2_y = 160.0 # the specific point to be rotated.\na_radian = math.atan((p2_y - p1_y)/(p2_x - p1_x))\na_length = math.sqrt((p2_y - p1_y)*(p2_y - p1_y) +\\\n(p2_x - p1_x)*(p2_x - p1_x))\nfor i in range(1,300): # end the program after 300 position shifts\na_radian +=0.05 # incremental rotation of 0.05 radians\np1_x = p2_x - a_length * math.cos(a_radian)\np1_y = p2_y - a_length * math.sin(a_radian)\nchart_1.create_line(p1_x, p1_y, p2_x, p2_y)\nchart_1.update()\nchart_1.after(cycle_period)\nchart_1.delete(ALL)\nroot.mainloop()\n\n```", "```py\n# multiple_line_rotations_1.py\nmultiple line rotationstrajectory tracing#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\nfrom Tkinter import *\nimport math\nroot = Tk()\nroot.title(\"multi-line rotations\")\ncw = 600 # canvas width\nch = 600 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"white\")\nchart_1.grid(row=0, column=0)\ncycle_period = 50 # time between new positions of the ball # (milliseconds).\np0_x = 300.0\np0_y = 300.0\np1_x = 200.0\np1_y = 200.0\np2_x = 150.0 # central pivot\np2_y = 150.0 # central pivot\np3_x = 100.0\np3_y = 100.0\np4_x = 50.0\np4_y = 50.0\nalpha_0 = math.atan((p0_y - p1_y)/(p0_x - p1_x))\nlength_0_1 = math.sqrt((p0_y - p1_y)*(p0_y - p1_y) +\\\n(p0_x - p1_x)*(p0_x - p1_x))\nalpha_1 = math.atan((p1_y - p2_y)/(p1_x - p2_x))\nmultiple line rotationstrajectory tracinglength_1_2 = math.sqrt((p2_y - p1_y)*(p2_y - p1_y) +\\\n(p2_x - p1_x)*(p2_x - p1_x))\nalpha_2 = math.atan((p2_y - p3_y)/(p2_x - p3_x))\nlength_2_3 = math.sqrt((p3_y - p2_y)*(p3_y - p2_y) +\\\n(p3_x - p2_x)*(p3_x - p2_x))\nalpha_3 = math.atan((p3_y - p4_y)/(p3_x - p4_x))\nlength_3_4 = math.sqrt((p4_y - p3_y)*(p4_y - p3_y) +\\\n(p4_x - p3_x)*(p4_x - p3_x))\nfor i in range(1,5000):\nalpha_0 += 0.1\nalpha_1 += 0.3\nalpha_2 -= 0.4\np1_x = p0_x - length_0_1 * math.cos(alpha_0)\np1_y = p0_y - length_0_1 * math.sin(alpha_0)\ntip_locus_2_x = p2_x\ntip_locus_2_y = p2_y\np2_x = p1_x - length_1_2 * math.cos(alpha_1)\np2_y = p1_y - length_1_2 * math.sin(alpha_1)\ntip_locus_3_x = p3_x\ntip_locus_3_y = p3_y\np3_x = p2_x - length_2_3 * math.cos(alpha_2)\np3_y = p2_y - length_2_3 * math.sin(alpha_2)\ntip_locus_4_x = p4_x\ntip_locus_4_y = p4_y\np4_x = p3_x - length_3_4 * math.cos(alpha_3)\np4_y = p3_y - length_3_4 * math.sin(alpha_3)\nchart_1.create_line(p1_x, p1_y, p0_x, p0_y, tag='line_1')\nchart_1.create_line(p2_x, p2_y, p1_x, p1_y, tag='line_2')\nchart_1.create_line(p3_x, p3_y, p2_x, p2_y, tag='line_3')\nchart_1.create_line(p4_x, p4_y, p3_x, p3_y, fill=\"purple\", \\tag='line_4')\n# Locus tip_locus_2 at tip of line 1-2\nchart_1.create_line(tip_locus_2_x, tip_locus_2_y, p2_x, p2_y, \\ fill='maroon')\n# Locus tip_locus_2 at tip of line 2-3\nchart_1.create_line(tip_locus_3_x, tip_locus_3_y, p3_x, p3_y, \\ fill='orchid1')\n# Locus tip_locus_2 at tip of line 2-3\nchart_1.create_line(tip_locus_4_x, tip_locus_4_y, p4_x, p4_y, \\ fill='DeepPink')\nchart_1.update()\nchart_1.after(cycle_period)\nchart_1.delete('line_1', 'line_2', 'line_3')\nroot.mainloop()\n\n```", "```py\nfrom Tkinter import *\nroot = Tk()\nroot.title(\"This is for you dear reader. A token of esteem and affection.\")\nimport math\ncw = 800 # canvas width\nch = 800 # canvas height\nchart_1 = Canvas(root, width=cw, height=ch, background=\"black\")\nchart_1.grid(row=0, column=0)\np0_x = 400.0\np0_y = 400.0\np1_x = 330.0\np1_y = 330.0\np2_x = 250.0\np2_y = 250.0\np3_x = 260.0\np3_y = 260.0\np4_x = 250.0\np4_y = 250.0\np5_x = 180.0\np5_y = 180.0\nalpha_0 = math.atan((p0_y - p1_y)/(p0_x - p1_x))\nlength_0_1 = math.sqrt((p0_y - p1_y)*(p0_y - p1_y) + (p0_x - p1_ \\x)*(p0_x - p1_x))\nalpha_1 = math.atan((p1_y - p2_y)/(p1_x - p2_x))\nlength_1_2 = math.sqrt((p2_y - p1_y)*(p2_y - p1_y) + (p2_x - p1_ \\x)*(p2_x - p1_x))\nalpha_2 = math.atan((p2_y - p3_y)/(p2_x - p3_x))\nlength_2_3 = math.sqrt((p3_y - p2_y)*(p3_y - p2_y) + (p3_x - p2_ \\ x)*(p3_x - p2_x))\nalpha_3 = math.atan((p3_y - p4_y)/(p3_x - p4_x))\nlength_3_4 = math.sqrt((p4_y - p3_y)*(p4_y - p3_y) + (p4_x - p3_ \\ x)*(p4_x - p3_x))\nalpha_4 = math.atan((p3_y - p5_y)/(p3_x - p5_x))\nlength_4_5 = math.sqrt((p5_y - p4_y)*(p5_y - p4_y) + (p5_x - p4_ \\x)*(p5_x - p4_x))\nfor i in range(1,2300): # end the program after 500 position # shifts.\nanimationdigital flower examplealpha_0 += 0.003\nalpha_1 += 0.018\nalpha_2 -= 0.054\nalpha_3 -= 0.108\nalpha_4 += 0.018\np1_x = p0_x - length_0_1 * math.cos(alpha_0)\np1_y = p0_y - length_0_1 * math.sin(alpha_0)\ntip_locus_2_x = p2_x\ntip_locus_2_y = p2_y\np2_x = p1_x - length_1_2 * math.cos(alpha_1)\np2_y = p1_y - length_1_2 * math.sin(alpha_1)\ntip_locus_3_x = p3_x\ntip_locus_3_y = p3_y\np3_x = p2_x - length_2_3 * math.cos(alpha_2)\np3_y = p2_y - length_2_3 * math.sin(alpha_2)\ntip_locus_4_x = p4_x\ntip_locus_4_y = p4_y\np4_x = p3_x - length_3_4 * math.cos(alpha_3)\np4_y = p3_y - length_3_4 * math.sin(alpha_3)\ntip_locus_5_x = p5_x\ntip_locus_5_y = p5_y\np5_x = p4_x - length_4_5 * math.cos(alpha_4)\np5_y = p4_y - length_4_5 * math.sin(alpha_4)\nchart_1.create_line(p1_x, p1_y, p0_x, p0_y, tag='line_1', \\ fill='gray')\nchart_1.create_line(p2_x, p2_y, p1_x, p1_y, tag='line_2', \\ fill='gray')\nchart_1.create_line(p3_x, p3_y, p2_x, p2_y, tag='line_3', \\ fill='gray')\nchart_1.create_line(p4_x, p4_y, p3_x, p3_y, tag='line_4', \\ fill='gray')\nanimationdigital flower examplechart_1.create_line(p5_x, p5_y, p4_x, p4_y, tag='line_5', \\ fill='#550000')\nchart_1.create_line(tip_locus_2_x, tip_locus_2_y, p2_x, p2_y, \\ fill='#ff00aa')\nchart_1.create_line(tip_locus_3_x, tip_locus_3_y, p3_x, p3_y, \\ fill='#aa00aa')\nchart_1.create_line(tip_locus_4_x, tip_locus_4_y, p4_x, p4_y, \\ fill='#dd00dd')\nchart_1.create_line(tip_locus_5_x, tip_locus_5_y, p5_x, p5_y, \\ fill='#880066')\nchart_1.create_line(tip_locus_2_x, tip_locus_2_y, p5_x, p5_y, \\ fill='#0000ff')\nchart_1.create_line(tip_locus_3_x, tip_locus_3_y, p4_x, p4_y, \\ fill='#6600ff')\nchart_1.update() # This refreshes the drawing on the # canvas.\nchart_1.delete('line_1', 'line_2', 'line_3', 'line_4') # Erase # selected tags.\nroot.mainloop()\n\n```"]