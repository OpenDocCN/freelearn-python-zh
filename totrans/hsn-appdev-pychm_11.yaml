- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Database Management in PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do horseshoe crabs, coelacanths, crocodiles, and relational databases have
    in common? I’ll wait while you go look up *coelacanth*. All four of these have
    been around for millions of years and yet have evolved very little. OK, databases
    haven’t been around for millions of years, but they have been around for millions
    of internet years. Everybody knows that internet years are very short. JavaScript
    developers often joke that before lunchtime, anywhere in the world, dozens of
    new frameworks have been invented, risen to prominence, fallen out of favor, and
    then been abandoned all before you finish your noodles.
  prefs: []
  type: TYPE_NORMAL
- en: In the early 1970s, a researcher named E. F. Codd was working at IBM’s San Jose
    Research Laboratory in California. He developed a revolutionary concept called
    **the relational model of data**. In his seminal paper titled *A Relational Model
    of Data for Large Shared Data Banks*, published in 1970, Codd outlined the principles
    and foundations of this new approach to organizing and retrieving data.
  prefs: []
  type: TYPE_NORMAL
- en: Codd’s relational model proposed a way to represent data as a collection of
    tables, known as relations, with each table consisting of rows and columns. He
    introduced the concept of **relational algebra**, a mathematical framework for
    manipulating and querying data in these tables. The model emphasized the use of
    mathematical **set theory** and logic to define relationships and perform operations
    on the data.
  prefs: []
  type: TYPE_NORMAL
- en: Codd’s ideas challenged the prevailing hierarchical and network database models
    of the time, which were more complex and less flexible. The relational model offered
    a simpler and more intuitive way to manage data, providing a foundation for **Structured
    Query Language** (**SQL**) and other tools used in relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 1974, IBM released the first commercially available **relational database
    management system** (**RDBMS**), called *System R*, based on Codd’s work. System
    R implemented many of the concepts outlined in Codd’s research and became an influential
    precursor to subsequent relational database systems. In 1974, IBM released System
    R based on Codd’s work, but the product wasn’t aggressively marketed or sold because
    IBM executives were worried about cannibalizing sales on other database systems
    sold by the company. During that time, another start-up database company was born:
    **Oracle**. The initial release of Oracle was developed by Larry Ellison, Bob
    Miner, and Ed Oates. Released in 1983, Oracle is generally considered to be the
    first commercial success even though IBM had a serious head start.'
  prefs: []
  type: TYPE_NORMAL
- en: Relational database technology evolved throughout the 80s and 90s, and along
    the way, it became a staple of corporate IT in every industry in every corner
    of the globe. In 1986, the SQL language became standardized. The standard evolved
    over time, but to be honest, 49 years after the invention of SQL, most development
    is done with the simplest and oldest set of language statements.
  prefs: []
  type: TYPE_NORMAL
- en: A moment ago, I stated that Codd’s ideas challenged the prevailing hierarchical
    and network database models of the time, which were more complex and less flexible.
    It is interesting to note that in the early 2000s, there was a shift away from
    relational database technology toward what we call **NoSQL databases**. The world
    of IT often acts like a pendulum, forever swinging back and forth. We used to
    have relatively low-powered PCs capable of playing video files at 12 frames per
    second in a postage stamp-sized window. Technology improved to the point where
    we could watch a 4K high-definition video at full speed on a PC, but then we invented
    small hand-held devices, such as the iPod, and we were back to low-end processing
    and choppy, grainy video. Eventually, those improved into the iPhone, which can
    play video at high definition and high frame rates. Some iPhones are bigger than
    the TV I had in college.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, with databases, one day the world was using hierarchical and network-oriented
    databases. The next day everything swung to a new thing called *relational*. Today,
    we see a swing back in the other direction. More and more projects today favor
    non-relational databases, many of which support hierarchical data. Regardless
    of which technology you might favor, it is safe to say that just about any project
    you build, especially in the corporate IT world, will interact with some database
    in some big way.
  prefs: []
  type: TYPE_NORMAL
- en: In 2015, JetBrains created a new product aimed at becoming a popular IDE for
    database developers. **DataGrip** was created to provide a unified interface and
    robust toolset for working with various databases. It offers features such as
    intelligent code completion, advanced SQL editing capabilities, schema navigation,
    data analysis, and integration with version control systems. Like the web development
    product by JetBrains, WebStorm, the DataGrip product is integrated into the Professional
    edition of PyCharm through its plugin system. Consider that your 99 USD investment
    in PyCharm Professional gets you a Python IDE, a JavaScript IDE, an IDE for web
    frontend work in HTML and CSS, and now a fully fledged IDE for database work and
    you’ll see you’ve gotten a solid deal!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the features of PyCharm related to databases.
    By the end of the chapter, you will have learned the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Some database history and some basics just to make sure we’re all on the same
    page in terms of terminology. If you’ve been developing software for a while,
    this might be a review. If you’re new, I will endeavor to provide you with the
    best possible introduction to database technology.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to navigate to the database tools in PyCharm, which are hidden away in a
    tab on the right side of the interface. I have met many developers who have used
    PyCharm for years yet don’t know these tools are even present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to connect to different databases, including how to add the necessary connection
    drivers to PyCharm. JetBrains has made this very easy!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure SQL dialects for individual projects as well as globally.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use SQL generation templates to help you write SQL queries more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate an **entity relationship** **diagram** (**ERD**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the graphical designers to build tables easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use consoles to create and run ad hoc queries against any database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a personal note, besides learning to code in BASIC when I was 12, relational
    technology was the first skill I mastered when I got into the IT field over 30
    years ago. This is a skill set that has always been in demand, and will probably
    continue to be in demand for many years to come. It is a subject I have extensive
    experience in, and I am excited to share that experience with you in this chapter.
    So, let’s get to it!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed with this chapter, and indeed the rest of the book, you
    will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, in case
    you are jumping into the middle of the book.
  prefs: []
  type: TYPE_NORMAL
- en: A database server is a nice-to-have in this chapter so you can practice on a
    real database. There are dozens of popular relational databases to choose from,
    so it is not practical for me to cover all of them. I will be running **MySQL**
    using **Docker Desktop**. If you plan on following along, you’ll need to have
    Docker Desktop installed on your computer. You can find instructions for installation
    at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  prefs: []
  type: TYPE_NORMAL
- en: This book’s sample source code is from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11).
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The idea of relational data conceived by E. F. Codd is based on a few simple
    principles. Firstly, data can be represented in sets called *tables*. A `books`.
    The `books` table will contain columns that define the data within those columns
    – maybe something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Title** | **ISBN** | **Page Count** | **Author** | **Price** |'
  prefs: []
  type: TYPE_TB
- en: '| The Art of War | 1599869772 | 68 | Sun Tzu | 4.99 |'
  prefs: []
  type: TYPE_TB
- en: '| Book of Five Rings | 8387743849 | 43 | Miyamoto Musashi | 4.50 |'
  prefs: []
  type: TYPE_TB
- en: This table has five columns designed to structure data about books. We have
    two books, which are stored as rows in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Structured Query Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E. F. Codd’s paper that defined relational algebra served as the basis for SQL.
    SQL is unlike any other coding language you will ever use because it is one of
    only a handful of languages that use a declarative paradigm. Most languages you
    use, including Python, use an imperative paradigm. In short, the language serves
    as a syntactical framework to give a computer instructions on what you want it
    to do. You are basically a micro-manager. You specify every input, every output
    and every step the program will take during the processing that happens to get
    the input to the output. You must be meticulous, as the computer will take you
    literally. If you leave out even a single detail, you are setting things up to
    malfunction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Declarative programming**, on the other hand, entails merely specifying the
    output you want from an implicit input. You have little to no control over the
    operations performed to derive the output from the input. Consider this SQL statement
    designed to get some rows from your bookstore database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This query will produce some output consisting of a table that has a few of
    the columns from your original database, which serves as the implicit input. You’ll
    get the following columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Title`'
  prefs: []
  type: TYPE_NORMAL
- en: '`ISBN`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Author`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Price`'
  prefs: []
  type: TYPE_NORMAL
- en: But you won’t get the page count because you didn’t ask for it in the query.
    The input data source is implied in the `FROM books` section of the query. At
    the end, we have a request to order the results by price in descending order (`DESC`),
    which will make our resulting tabular list of books appear from the most expensive
    to the cheapest.
  prefs: []
  type: TYPE_NORMAL
- en: The two halves of SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL itself is split into two separate sets of syntax: `SELECT` statement presented
    earlier is an example of a read operation. SQL has keywords for `INSERT`, `UPDATE`,
    and `DELETE` operations for records which are straightforward, so I want to focus
    on DDL since this is going to be a big part of your work in PyCharm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our earlier example of a table to be used in a bookstore application had one
    table in it called `books`. That table contained a set of columns, which we would
    define using DDL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are new to SQL, you might have noticed the keywords are capitalized.
    In fact, I’ll bet you correctly assumed that the capitalized words were keywords.
    While it isn’t a requirement to capitalize keywords, it is good practice – particularly
    if your project’s database lead is a large man retired from the United States
    Marine Corps who is particular about the details of syntax in *his* database!
    In this case, good practice might become a matter of survival.
  prefs: []
  type: TYPE_NORMAL
- en: Most of what you read in the table’s DDL is easy to figure out. We’re creating
    a table called `books`. We already knew about the column names. SQL uses a strong
    type system, meaning you have to define the type of data that will go into a column,
    and violating that constraint might come with consequences. I’ve said many times
    before that a developer’s job is to protect a program from entering an invalid
    state. Likewise, it is a database developer’s job, as well as that of a `VARCHAR`
    refers to a variable-length set of characters. Programmers call this a *string*.
    The number (`255`) after the type refers to the maximum length of `VARCHAR`. All
    of the `VARCHAR` (string) fields in the database are limited to 255 characters
    in length. The number 255 is very common because many of us old-timers grew up
    in the world of 8-bit computing. The number 255, being the maximum value of an
    8-bit unsigned integer, was a common maximum for the length of the field. We’d
    set it to that when we weren’t sure how long the data might be.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, today, we normally work in 32- and even 64-bit architectures, so
    the maximum can be much higher. It is normal to constrain ourselves to the old
    maximum because 255 characters are generally enough for most things. Specifying
    sane maximums helps keep your database storage and memory requirements reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the `price` field. It is specified as the `DECIMAL` type, which is obviously
    like a float. Database systems have different names for their types, so you should
    always consult your database system’s documentation to get the exact naming. `DECIMAL`
    is indeed a floating-point number, but we also specified the level of precision
    with `(10,2)`. This means we can have a 10-digit number with 2 decimal places.
    This is commonly used to specify prices. Some database systems have specialized
    types specifically for currency. SQL Server is an example of this with their `MONEY`
    and `SMALLMONEY` types. Again, check your database system’s documentation for
    appropriate types since these specialized types aren’t part of standard SQL.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider our bookstore will naturally grow in size and complexity. Let’s say
    we’ve added some different fields and removed some we weren’t using. Our new table
    structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Title** | **Author_name** | **Author_email** | **Pages** | **Price** |'
  prefs: []
  type: TYPE_TB
- en: '| C Programming Language, 2nd Edition | Brian Kernighan and Dennis Ritchie
    | bkernigan@notrealaddress.com | 272 | 53.60 |'
  prefs: []
  type: TYPE_TB
- en: '| Real-World Implementation of C# Design Patterns | Bruce Van Horn | bvanhorn@notrealaddress.com
    | 442 | 44.99 |'
  prefs: []
  type: TYPE_TB
- en: '| Hands-On Application Development with PyCharm | Quan Nguyen | qnguyen@notrealaddress.com
    | 785 | 35.45 |'
  prefs: []
  type: TYPE_TB
- en: '| Hands-On Application Development with PyCharm, 2nd Edition | Bruce Van Horn
    | bvanhorn@notrealaddress.com | 840 | 44.99 |'
  prefs: []
  type: TYPE_TB
- en: Besides the complexity coming from more records, we’ve introduced some complexity
    in terms of design. At some point, it became important for us to track more information
    about the authors of any given book. We added fields for the name and email address,
    which seemed to solve our problems at first, but ultimately led to more issues.
  prefs: []
  type: TYPE_NORMAL
- en: The C book has two authors, but we only have one field. While it might be fine
    to store both authors as we did, there is also a field for the email address and
    this can only accommodate one address. This is not ideal since our objective might
    be to send royalty statements or sales reports to the authors. One address is
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: The email addresses will be duplicated in the event we store two books with
    the same author. If the author changes email addresses, all of the records have
    to be updated. This is the equivalent of hardcoded values kept in multiple places
    in a program. You have to remember to change it in lots of places. The problem
    is compounded if this email address data is duplicated in several different tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this is prescribed by SQL and the ideas behind relational algebra.
    You need a single source of truth for the author’s data instead of mixing it in
    with other tables. So, we create a new table for authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This table has fields for the first and last names as well as the email address.
    It also has a field called `id`, which is going to the server as a primary key.
    A primary key is a field that can uniquely identify the information in that row.
    The idea here is that every author gets only one row to store their information.
    We need some piece of data to uniquely identify that row. Consider my own records.
    My first and last names make poor choices to uniquely define my record in the
    database. I know of at least three other people named Bruce Van Horn. One was
    my father, who published in the medical field. One is a motivational speaker who
    publishes books in that literary field. I found another Bruce Van Horn on LinkedIn,
    and believe it or not, he too is a software developer! So the name is a poor choice
    as a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Email addresses might work, except that we’ve already figured out that email
    addresses can change. I have no fewer than five email addresses and at least one
    of these is so overtaken with spam that I no longer even check it. Email isn’t
    going to work.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to use some piece of data that is unique but arbitrary,
    with no bearing at all on the rest of the data in the record. There are two ways
    to do this. The most common is to use a database sequence. A **sequence** is an
    automatically incrementing source of integers. Each time a record is inserted
    into a table, the sequencer generates a sequential number, which is guaranteed
    to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: The other approach is to use `6f35e0e7-d99a-4437-b894-f73ff35bd3ad` versus a
    record with the `id` value of `16`. Which would you rather type into your queries?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a field that uniquely identifies an author’s record, we can
    adjust our book table structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Title** | **pages** | **price** | **author_id** |'
  prefs: []
  type: TYPE_TB
- en: '| Real-World Implementation of C# Design Patterns | 442 | 44.99 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Hands-On Application Development with PyCharm | 785 | 35.45 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Hands-On Application Development with PyCharm, 2nd Edition | 840 | 44.99
    | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Our `authors` table looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **author_id** | **first_name** | **last_name** | **email** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Quan | Nguyen | qnugyen@notrealaddress.com |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Bruce | Van Horn | bvanhorn@notrealaddress.com |'
  prefs: []
  type: TYPE_TB
- en: The author ID in the `authors` table is used as a related column in the `books`
    table using a one-to-many relationship. Each author will have one record, which
    is related to many records in the `books` table.
  prefs: []
  type: TYPE_NORMAL
- en: More relational structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve solved a big problem using our one-to-many table structure. We no longer
    have duplicate data in multiple records for our authors. We didn’t, however, solve
    all of our problems. For example, the C book has multiple authors. How can we
    store authors in a way that allows each book to support multiple authors?
  prefs: []
  type: TYPE_NORMAL
- en: I’m afraid we’ve reached the point where I tell you that this isn’t a book on
    SQL, nor is it a book on relational theory. If I’ve hooked you on this, I can
    recommend some excellent books that I used when I learned these things. We’ve
    presented enough relational database vocabulary to help you relate to what you
    will see in PyCharm’s tooling and that was my real objective.
  prefs: []
  type: TYPE_NORMAL
- en: Since I am not a total degenerate, regardless of what you may read about me
    on Stack Overflow, I will give you the solution quickly and without many pages
    of explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’d solve it using what we call a mapping table. Your structure would require
    the addition of a table called `books_authors_map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **Book_id** | **Author_id** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Your `books` table would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Book_id** | **Title** | **Pages** | **Price** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | The C Programming Language | 442 | 44.99 |'
  prefs: []
  type: TYPE_TB
- en: 'We took out the `author_id` field and added a `book_id` field, which really
    should have been there all along. The `authors` table would look the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Author_id** | **First_name** | **Last_name** | **Email** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Brian | Kernighan | bkernigan@notrealaddress.com |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Dennis | Ritchie | dritche@noterealaddress.com |'
  prefs: []
  type: TYPE_TB
- en: The mapping table can map a `books` and `authors`! If either author goes solo
    and publishes a book without their co-author, that will work! The `books` table’s
    record will have one related record in the map, which has one related record in
    the `authors` table.
  prefs: []
  type: TYPE_NORMAL
- en: If a book has 10 authors, it will have 1 book record, 10 author records, and
    10 mapping entries. Relational algebra is pretty cool! It is an underrated skill
    in today’s world of **object relational mappers** (**ORMs**), which abstract all
    of this into normal object structures. Developers today tend to lose this skill.
    If you do, you give up a lot. You can make fine-grained modifications in your
    DDL that lead to huge performance gains for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of that, let’s learn about PyCharm’s tooling for database development.
  prefs: []
  type: TYPE_NORMAL
- en: Database terminology uses simple English plurals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we go through some of the terminology used when talking about databases,
    I feel compelled to point out something that bothered me for a very long time.
    Many terms used when talking about databases come from Latin root words. For example,
    an **index** is an addition to a table that can speed up data retrieval at the
    cost of the speed of inserting new data. It is also a Latin word that refers to
    *a pointer, indicator, or signpost*. A **schema** refers to a way of partitioning
    off tables and other structures in a database. The word *schema* originated with
    the Greek word σχῆμα (*skema*) and in both languages means *shape, form,* *or
    plan*.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about the plural forms, the words might not be as you expect if
    you received a classical education as I did. If you come from a country where
    your language is based on Latin, you might notice this issue as well.
  prefs: []
  type: TYPE_NORMAL
- en: I would expect the plural form of *schema* to be *schemata*, and the plural
    of *index* to be *indices*. If you expect this, you will always be disappointed.
    The industry has standardized simple plural forms such as *schemas* and *indexes*.
  prefs: []
  type: TYPE_NORMAL
- en: Database tooling in PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The database tooling in PyCharm is complete but generic. By this, I mean that
    PyCharm attempts to support every database out there, and as such, it generally
    supports features common to all. You may find yourself sometimes leaning on more
    specific tools, such as **SQL Server Management Studio** (**SSMS**) for SQL Server.
    However, for general development work, the tooling in PyCharm is more than sufficient.
    The starting point for working with databases in PyCharm is opening the database
    tools and creating a connection. For this, you also need a database. PyCharm supports
    dozens of the most popular database servers. Since this is true, it would be impossible
    for me to predict which one you prefer, so I’m going to fall back on one that
    I know well: MySQL. Regardless of your favorite, the tooling in PyCharm is generic,
    so as long as you pick a relational database that is standards-compliant, the
    processes are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a MySQL database server with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to try out any database system, or pretty much any server technology
    at all, is to use Docker. I have more plans for Docker later in the book, and
    I will be using Docker Desktop, along with the command line. I like the desktop’s
    GUI for seeing what is running graphically, but you should master Docker command-line
    skills in order to remain competitive. If you don’t have Docker Desktop installed,
    you can find the installation instructions at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    Naturally, there are other options, such as installing a database server on your
    computer. I personally rail against this because database servers are very complicated.
    Installing something such as SQL Server or Oracle will make modifications to your
    OS at a level that makes these software packages hard to uninstall. It used to
    be a rule of thumb that if you made any mistakes installing the database server,
    the smartest option was the wipe the OS and start over. I’m relatively sure that’s
    no longer the case, but I still treat database servers with respect because of
    all the moving parts in your solution, this one is easily the most complicated.
    The last thing you want is a broken database server on your laptop while in the
    middle of developing an epic project. So, I recommend Docker. If something goes
    wrong, you delete the container and make a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, you can create a VM using products such as **VMware Workstation**
    or **Oracle VirtualBox**. This is another fine way to work, though it takes up
    more space and resources than Docker will, and you must remember to keep your
    VMs up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Another fine option is to spin up your database server of choice in your favorite
    cloud. I recommend **DigitalOcean** for this since their pricing and setup are
    both extremely easy to understand. I use this service to host the companion website
    for this book. If your computer isn’t up for running a database server, VMware,
    or Docker, using a cloud provider is your best option.
  prefs: []
  type: TYPE_NORMAL
- en: All these options are great, but I need to pick one, so I’m going to be working
    with Docker. Remember, this isn’t a book on Docker. My coverage is going to be
    tacit. Your objective is to get a database server up and running so you can practice.
    If you can do that with something besides Docker, go ahead and skip to the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running the MySQL container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’m assuming you have Docker running on your computer and that your Docker
    commands are available in your `PATH`. We can confirm this by opening our terminal
    and typing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will list all the containers currently running, or stopped. If
    you just installed Docker, you should see an empty list, which is to say, nothing
    at all. The test is really to make sure the command runs and doesn’t throw any
    errors. If it doesn’t, you’re ready to grab MySQL using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see a nicely animated display of the installation, as shown in *Figure
    11**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The Docker command used to pull the images needed for MySQL](img/B19644_11_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The Docker command used to pull the images needed for MySQL'
  prefs: []
  type: TYPE_NORMAL
- en: 'This command pulled all the requirements needed to run one or more containers
    for MySQL. Next, we need to create and run a container with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will create and run a container named `pycharm-mysql`. It sets
    the root password for the MySQL database to `P@ssw0rd`. The `–p` flag maps port
    `3306`, which is the standard port for MySQL, to the same value between your container
    and the host. This will make it seem as though you are running the MySQL server
    directly on your computer. The `-d` flag tells Docker to run MySQL as a background
    process rather than waiting for it to exit. This is common with server software.
    I hope I don’t need to remind you that *this is not production ready*. If you
    are in a small group where the developers are responsible for standing up a production
    environment, don’t simply duplicate your development environment on a server open
    to the internet. You should at least map your database to more robust permanent
    storage, as well as harden MySQL, use non-privileged accounts for your app, and
    use a non-obvious root password.
  prefs: []
  type: TYPE_NORMAL
- en: We are now running the MySQL server. When you run the Docker command, your output
    is somewhat cryptic and unsatisfying. You can see mine in *Figure 11**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: A long string of seemingly random letters and numbers is Docker’s
    way of saying “I love you,” or at least that your container is running](img/B19644_11_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: A long string of seemingly random letters and numbers is Docker’s
    way of saying “I love you,” or at least that your container is running'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an old saying that goes, *Tell a man there are a trillion stars in
    the galaxy, and he’ll believe you. Tell him his container is successfully running
    in Docker and he’ll run* `docker ps -a` *to be sure.* In truth, I might have just
    made that up. Nevertheless, let’s make sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You should see proof like mine in *Figure 11**.3*. The `CONTAINER ID` value
    will be different for every run, so don’t expect yours to match mine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: I can see my container named pycharm-mysql is running and has
    exposed port 3306](img/B19644_11_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: I can see my container named pycharm-mysql is running and has
    exposed port 3306'
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and starting the container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re ready to retire for the day, you might want to stop the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This stops the container. You can check with the same `docker ps -a` command
    we’ve been using to confirm the status changed from *Up* to *Stopped*. Tomorrow
    morning, when you come back, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This starts things up so you can pick up where you left off.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to data sources using PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open PyCharm Professional and create a new Python project called `database_fun`.
    Now, locate the database tools. You can find them on the right side toolbar via
    the database icon that looks like a three-layer cake (yum!). Alternatively, you
    can find it via the hamburger (yum!) menu by clicking **View** | **Tool Windows**
    | **Database**. Both options are shown in *Figure 11**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Two options for opening database tools – one from the menu,
    and the second by clicking the database tools icon](img/B19644_11_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Two options for opening database tools – one from the menu, and
    the second by clicking the database tools icon'
  prefs: []
  type: TYPE_NORMAL
- en: With the database tools open, you need to create a new **data source**. Note
    the generic terminology. PyCharm supports relational as well as non-relational
    databases, so the term *data source* is just a generic way of pointing that out.
    Click the **+** icon shown in *Figure 11**.5*, then hover over **Data Source**.
    You’ll see a long list of supported data sources. Find **MySQL** and click it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Supported data sources in PyCharm](img/B19644_11_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Supported data sources in PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see a configuration window like mine in *Figure 11**.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Configuration window for a MySQL database](img/B19644_11_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Configuration window for a MySQL database'
  prefs: []
  type: TYPE_NORMAL
- en: Each database server may have slightly different settings, but essentially they
    boil down to the IP address (or DNS name), port, security credentials, and, very
    often, the default database, which may not yet exist. We defined the root password
    for our MySQL server as `P@ssw0rd`, and we know since we’re running in Docker
    our IP is just going to be `localhost`. You might also remember the port that
    was displayed in the output of the `docker ps -a` command we ran earlier is `3306`.
    The arrow in the preceding figure points to an important aspect of database tooling
    in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm, like most JetBrains IDEs, is written in Java. As such, PyCharm relies
    on **Java Database Connectivity** (**JDBC**) drivers in order to work. Most JDBC
    drivers are written by the same company or group that publishes the database,
    which means it’s generally not legal for JetBrains to bundle those drivers with
    PyCharm without getting lawyers involved. Nobody wants that! JetBrains did the
    next best thing. The IDE can download and install the driver automatically, but
    you have to initiate this by clicking the **Download missing driver files** link
    on this screen. This only needs to be done the first time you use the database
    driver. Once the drivers are installed, the option shown by the arrow in *Figure
    11**.6* no longer appears. You can test your connection by clicking the **Test
    Connection** link. If everything works, you’ll get a confirmation message stating
    your database connection was successful. Click **OK** to close the connection
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Once the connection dialog is closed, you’ll see a list of data source connections
    for your project in the **Database** panel. There is a small toolbar visible at
    the top of the database panel, as shown in *Figure 11**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: The database panel has a small menu bar at the top](img/B19644_11_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: The database panel has a small menu bar at the top'
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, I’ve numbered the options in the figure. Let’s review them:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Add Data Source** button, which we’ve already seen, allows you to add
    new data sources to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Duplicate** button allows you to make a quick copy, presumably with some
    minor adjustments. Many of my projects entail multiple databases on one server.
    All I have to do is set up the first one, then duplicate the connection and change
    the name of the database. This option makes this a quick and easy process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Refresh** button reloads the metadata for your connections. Remember this
    one. PyCharm doesn’t automatically keep track of all your database changes, especially
    if they are made outside of PyCharm. You’ll need to click the **Refresh** button
    periodically to make sure you’re viewing the latest information on your data sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Data source properties** button will display a dialog that allows you
    to change the settings of the data source configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Disconnect** button will disconnect you from a database server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Edit data** button allows you to directly edit data in tables in your
    database using a graphical, spreadsheet-like UI. This is nice for quickly adding
    or changing test data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Go To DDL** button will take you to the SQL definition of whatever you
    have currently selected. You need to have a DDL mapping for this to work properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compare Structure** lets us compare two database structures. This is usually
    used to help migrate one database structure to another after changes were made
    during the normal development process. Migration technology in PyCharm 2023 is
    only partially complete, so this feature might have changed at the time you are
    reading this book.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Jump to Query Console** is pretty much your go-to tool for interacting with
    the database at the command line. A query console was opened automatically when
    you first connected to the database, but if you closed it, this button opens it
    and brings it into focus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The filter button allows you to filter what you see in the data sources you
    have defined. By default, everything is turned on, which might be a bit much for
    most developers who are not usually accustomed to seeing all the guts of the database
    so explicitly displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides these tools, there are others that pertain to setting up how you view
    and work with your data sources. These will be a little easier to explain once
    we have a database to play with. Let’s take a moment to create one.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we do anything else, we need a new database. Most database servers just
    call this “a new database.” MySQL is a little different. They call a new database
    a new `@localhost`) and click **New** | **Schema**, as shown in *Figure 11**.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Create a new database by right-clicking the server (indicated
    by the arrow), then New | Schema](img/B19644_11_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Create a new database by right-clicking the server (indicated
    by the arrow), then New | Schema'
  prefs: []
  type: TYPE_NORMAL
- en: When you do this, you are prompted to name the schema, as shown in *Figure 11**.9*.
    I’ll name my schema to match my project in PyCharm. I’ll call it `database_fun`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: Name your schema using this dialog](img/B19644_11_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Name your schema using this dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Beneath the covers, PyCharm is just generating and executing DDL statements.
    This is how it is able to be so agnostic with respect to so many database options.
    You can see the preview of the command it will run in *Figure 11**.9*. Click **OK**
    to execute the command, and the database window will update to show the new schema.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just created a new database! It is just as easy using any other database
    server software supported by PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into working on the structure of our database, there are a few
    more setup options to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the SQL dialect (this is crucial)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since PyCharm supports dozens of different databases, each with its own dialect
    of SQL, it stands to reason that you might need to tell PyCharm which SQL dialect
    you intend to use. You won’t have any trouble remembering to do this because PyCharm
    nags you until you fill in the setting.
  prefs: []
  type: TYPE_NORMAL
- en: In your project window, right-click the project and create a new file called
    `test.sql`. It’s the same process we’ve been using for Python files, except there
    isn’t a template in the list. Right-click the project, then click **New File**,
    as shown in *Figure 11**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: There isn’t a specific listing for SQL files, so just right-click
    and pick New | File](img/B19644_11_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: There isn’t a specific listing for SQL files, so just right-click
    and pick New | File'
  prefs: []
  type: TYPE_NORMAL
- en: A small dialog will appear. Type the name of the file as `test.sql`. The moment
    you do this, the nagging begins. You’ll see a message stating the SQL dialect
    is not configured, as shown in *Figure 11**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11: PyCharm will hound you until you configure the SQL dialect](img/B19644_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: PyCharm will hound you until you configure the SQL dialect'
  prefs: []
  type: TYPE_NORMAL
- en: If PyCharm were me and the user of PyCharm were my 13-year-old daughter, there
    would be a lot of eye-rolling, an exasperated grunt, followed by, “Fine! I’ll
    set the SQL dialog! But none of my friends do!” Then I’d say, “If you’re friends
    all installed Windows 7 on their computers, would you follow their example?” Then
    she’d sag her head and say, “No, of course not.”
  prefs: []
  type: TYPE_NORMAL
- en: Nobody wants this dialogue playing out, so we’d better make our IDE overlord
    happy. Click the link in *Figure 11**.11* to set the dialect. You’ll need to set
    it locally and globally. The configuration is shown in *Figure 11**.12*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: Set the SQL dialects globally and locally](img/B19644_11_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Set the SQL dialects globally and locally'
  prefs: []
  type: TYPE_NORMAL
- en: The global setting carries across all projects, so if you’re like me and you
    only ever use one database server type, you can set it globally here, and it will
    be set for all your projects. The project dialect is a little more nuanced. If
    you value your sanity, you really need to create a folder for your SQL files,
    then set the dialect for the folder. Here, I’m just showing you where the settings
    are. Go ahead and pick **MySQL** for your global and local dialect and we’ll worry
    about the whole folder idea a little later.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping and color coding data sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My own work consists of creating the SaaS product sold by my employer. This
    means that for the first seven years of the project, I only had one database to
    deal with. As the product grew in capability, we added two more SQL databases,
    a MongoDB database, and several Redis data caches to the project. My project is
    still pretty tame compared to some I’ve worked on. If you have many databases
    to deal with, PyCharm allows you to organize them in several different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing by folders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can organize your data sources by grouping them into folders. We only have
    one, but we’ll go through the process anyway. Click the data source indicated
    by the arrow in *Figure 11**.8*. Last time, we right-clicked; this time, just
    click the data source and press *F6* on your keyboard. This brings up a dialog,
    as shown in *Figure 11**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13: Create a new folder for your data source](img/B19644_11_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Create a new folder for your data source'
  prefs: []
  type: TYPE_NORMAL
- en: Organizing by folder can be useful if you have lots of databases in your project,
    or maybe you have separate sets of connections for development, **user acceptance
    testing** (**UAT**), and production.
  prefs: []
  type: TYPE_NORMAL
- en: Color coding databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’m fond of this feature since I have four environments:'
  prefs: []
  type: TYPE_NORMAL
- en: A local database, just like we have now
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A central development testing database where the development validates their
    designs before the product team is allowed to see our changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A staging database that is connected to a staged version of our application
    for UAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A production database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I always color code everything! You can set a color for the data source by opening
    up the **Data Source Properties** window. To do this, click the **Data Source
    Properties** button on the toolbar. I showed you this earlier in *Figure 11**.7
    (4)*. Clicking this button reveals a dialog box similar to the one you used to
    create the data source earlier. Look at mine in *Figure 11**.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: Click the innocuous dot next to the data source name in the
    properties window to set a color for your data source](img/B19644_11_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Click the innocuous dot next to the data source name in the properties
    window to set a color for your data source'
  prefs: []
  type: TYPE_NORMAL
- en: You can probably figure it out from here. Once you dismiss the dialog, your
    database elements in the IDE become awash with lovely pastel hues. Personally,
    I set my local development environment to violet, the dev environment to green,
    staging to yellow, and production to red. Not rose from the selection, but a bright,
    obnoxious, over-the-top, fire engine red picked from the custom dialog at the
    bottom of the list. As the project’s development lead, there are times when I
    need to go look at the project in production. I want to make sure I remember where
    I am! Color coding helps!
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a data source between projects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have many projects that use the same data source, it would be tedious
    to have to set the same thing over and over for each project. Thankfully, you
    don’t have to. PyCharm allows you to make a data source global, meaning it is
    available to all your projects in PyCharm. In the data source properties window
    shown in *Figure 11**.15*, find the button indicated by the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15: You can make your data source configuration global so it is
    available to all your projects](img/B19644_11_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: You can make your data source configuration global so it is available
    to all your projects'
  prefs: []
  type: TYPE_NORMAL
- en: If you click it, the dialog changes very subtly to indicate the data source
    is now global. If you want to check, just make a new project like we did earlier.
    Open the database tools and you’ll find the data source is already there. I made
    a project called `more_database_fun`, and as you can see in *Figure 11**.16*,
    the data source indeed carried over.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16: I made a new project and opened the database tools. The global
    data source is there](img/B19644_11_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: I made a new project and opened the database tools. The global
    data source is there'
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no code in this second project, I did not include it in the chapter
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Another fun feature is the global data sources are exported when you export
    your IDE settings. Refer back to [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*, if you need a refresher on importing and exporting
    settings, but I’ll go ahead and point out the export settings I’m talking about
    here in *Figure 11**.17*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17: You can export your global data sources to the settings export
    ZIP file, allowing others to simply import the relevant settings](img/B19644_11_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.17: You can export your global data sources to the settings export
    ZIP file, allowing others to simply import the relevant settings'
  prefs: []
  type: TYPE_NORMAL
- en: If you are a development lead, you might consider creating an export of your
    IDE settings that does not include things such as color and font size. Those are
    likely more personal preferences and make sense when you want to copy your settings
    between a laptop and a workstation. But it does make sense to export more work-specific
    settings such as your data sources so your team can easily import them. If you
    do this, remember you are also potentially copying credentials! You should only
    make development data sources available as global exports lest your `settings.zip`
    file falls into the wrong hands. This is especially important in an age where
    more and more of us are using cloud database servers rather than locally installed
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: If you need tight control over credentials, PyCharm can integrate with a product
    called *KeePass*. Since that is fairly niche, I’ll not cover it here, but I will
    leave a link with more details in the *Further reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with SSL and SSH options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For even more security, especially with respect to cloud data sources, PyCharm
    supports SSL and SSH configuration options. See *Figure 11**.18* for your security
    setup options for your data sources.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18: SSH and SSL security options can be found in the data source
    settings on the SSH/SSL tab](img/B19644_11_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: SSH and SSL security options can be found in the data source
    settings on the SSH/SSL tab'
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go deep into this here, but you need to know where these settings lie
    in the IDE since you will need them for cloud providers such as Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Database design and manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s move on to the part you’ve probably been waiting for: the part where
    we get to build a database! We already created the schema, but at the moment,
    we don’t have any tables. Let’s fix that first!'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click the schema, **database_fun**, which we created earlier, and click
    **New** | **Table**, as shown in *Figure 11**.19*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19: Right-click on the schema indicated by the arrow, then click
    New | Table](img/B19644_11_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.19: Right-click on the schema indicated by the arrow, then click
    New | Table'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll get a new window, as shown in *Figure 11**.20*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20: New window](img/B19644_11_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.20: New window'
  prefs: []
  type: TYPE_NORMAL
- en: I had to stretch mine out a little to see it all, as shown in the figure. The
    next few steps will build our table. I went ahead and typed the table name in
    the **Name** field at the top. You can see what’s going on here. As before, with
    the schema creation DDL, PyCharm is building a DDL script in the preview at the
    bottom of the window. Right now, we have a red squiggly line under the semicolon
    because we have yet to add any fields, so this DDL is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: At the top left of the window is a button with a **+** icon. Click that to see
    a list of elements you can add to the table, as shown in *Figure 11**.21*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21: You can add to the table by clicking the + button](img/B19644_11_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.21: You can add to the table by clicking the + button'
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can pick whatever it is you need to add. We’re going to add our
    primary key field first. If you’re new to relational database design and you need
    a good primer, *Database Design for Mere Mortals* by Michael Hernandez is a must-read.
    I’ve used it as a textbook in my classes for over 20 years! Hernandez has an equally
    impactful book on SQL queries, as does another author, named Ben Forta. I’ll leave
    the details in the *Further reading* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In short, every table we create should have a field that can uniquely identify
    individual records. It should not consist of data that is related to the domain
    of data contained in the table. By this I mean we are making a table to hold information
    about book authors. We should not use any field related to the author as the primary
    key, the record’s unique identifier. Instead, we should use something unrelated.
    With MySQL, the norm is to use an auto-incrementing integer field.
  prefs: []
  type: TYPE_NORMAL
- en: An auto-incrementing integer field refers to a field that will automatically
    populate a number from a sequence starting with the number 1 and increasing automatically
    with each record insertion. The increment is not something you should do in code.
    This is a feature of the database itself. This is important. Relational databases
    are designed to be atomic, meaning all transactions are isolated. This is important
    because it means the database will never generate the same value for the auto-incrementing
    key even if two record insertions happen within microseconds of one another. This
    is something you cannot guarantee with your own code. You need to rely on the
    server for this.
  prefs: []
  type: TYPE_NORMAL
- en: Using the menu shown in *Figure 11**.21*, add a column and set it as shown in
    *Figure 11**.22*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22: Add the first column with the settings shown here](img/B19644_11_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.22: Add the first column with the settings shown here'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve created an auto-incrementing integer field called `author_id`. I’m
    using snake case here, but this is not required. Use whatever naming conventions
    your project requires. Note I haven’t yet officially made it the primary key.
    That’s coming. First, let’s finish out the rest of our columns.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done quickly if you leave the `author_id` field selected, then click
    the plus button three times. When you have a column selected, or even when you
    have the `columns` folder selected in the window, PyCharm assumes that when you
    click the **+** button, you want a column. Likewise, you can select any of the
    other folders for things such as primary keys, foreign keys, and indexes. PyCharm
    will simply create it without making you use the menu we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the three fields like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first_name`: `varchar(30)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`: `varchar(30)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: `varchar(255)` `not null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 11**.23* shows the last field configuration. I gave this one the `not
    null` constraint, which will prevent a record insertion from completing if the
    `email` field is left empty. This is done by clicking the checkbox titled **Not
    null**, as seen in *Figure 11**.22*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23: Configure the email field as shown](img/B19644_11_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.23: Configure the email field as shown'
  prefs: []
  type: TYPE_NORMAL
- en: It’s starting to look like a table, isn’t it? There are just a couple more things
    we need. Let’s go ahead and configure the `author_id` field to be a proper primary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the primary key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Click on the `keys` folder, then click the **+** button. You’re asked whether
    you want to create a primary or unique key, as shown in *Figure 11**.24*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24: Make sure the keys folder is selected, as shown in this figure,
    then click the + icon and pick Primary Key](img/B19644_11_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.24: Make sure the keys folder is selected, as shown in this figure,
    then click the + icon and pick Primary Key'
  prefs: []
  type: TYPE_NORMAL
- en: This will bring up a different window, as seen in *Figure 11**.25*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.25: Adding a primary key entails clicking the + icon and then selecting
    the field name from the dropdown](img/B19644_11_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.25: Adding a primary key entails clicking the + icon and then selecting
    the field name from the dropdown'
  prefs: []
  type: TYPE_NORMAL
- en: To add the key, click the `author_id` field to add it as the primary key. The
    relational theory allows for the creation of compound keys, which is why you could
    potentially add more than one field. It isn’t used in general practice since if
    you stick to an auto-incrementing integer for your key, creating a compound primary
    key isn’t needed. In fact, I consider a compound key to be a code smell.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a unique key constraint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, let’s constrain the `email` field so that the value of any inserted record
    must be unique. This prevents data toxicity problems arising from promiscuous
    inserts. There should really only be one record for each email address. Let’s
    enforce it formally with a unique key.
  prefs: []
  type: TYPE_NORMAL
- en: The process is the same as with the primary key, except this time we’ll pick
    a unique key instead of the primary key and we’ll specify the `email` field. There’s
    a trick though. This time, you’ll need to right-click the `keys` folder to pick
    the **Unique Key**. If you just click the **+** icon, it will add another primary
    key field, which isn’t what we want. *Figure 11**.26* shows you what to do.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.26: Right-click keys, then click New | Unique Key to avoid creating
    a second primary key](img/B19644_11_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.26: Right-click keys, then click New | Unique Key to avoid creating
    a second primary key'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `keys` folder, indicated by the arrow in the preceding figure,
    then click `email` field. I would also change the name from the generated `authors_pk2`
    value to `authors_uq`. This will tell you at a glance in the DDL that it is a
    unique field constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding an index to a table will make filtered read operations more performant.
    It would be a reasonable requirement to expect an application to allow users to
    search for an author by their email address. Adding an index to the `email` field
    will make this search faster at the expense of making new record inserts slightly
    slower. The insert performance hit is small, but if you were to add an index to
    every single field, it would become noticeable, so pick the fields you want to
    index carefully.
  prefs: []
  type: TYPE_NORMAL
- en: The process is the same for creating the keys. Refer to *Figure 11**.27*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.27: Right-click the indexes folder and add the index as shown](img/B19644_11_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.27: Right-click the indexes folder and add the index as shown'
  prefs: []
  type: TYPE_NORMAL
- en: This time, we right-click the `indexes` folder and click **New** | **Index**.
    From here, the dialog is familiar, as shown in *Figure 11**.28*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.28: We’ve added an index to the email field](img/B19644_11_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.28: We’ve added an index to the email field'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our table code won’t fit in a screenshot, so here’s what we
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you’re happy with your table structure, click **OK** and PyCharm will apply
    the DDL code generated to the database. You can see the results in the data source.
    Check mine out in *Figure 11**.29*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.29: The results of our hard work are shown in the data source panel](img/B19644_11_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.29: The results of our hard work are shown in the data source panel'
  prefs: []
  type: TYPE_NORMAL
- en: Altering existing structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve seen a lot of tools over the years that are good at allowing you to graphically
    create a database structure, but when it comes to altering existing structures,
    they fall flat. Microsoft SSMS springs to mind! It will let you merrily design
    away only to tell you when you try to commit your changes that it can’t do it.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s not like that. PyCharm handles changes the way your company’s DBA
    wants you to do it. If you’re new to the field, a DBA is in charge of the database.
    They’re the boss. If you are lucky enough to be granted the *privilege* of creating
    anything in their database, you will follow their rules. And they want you to
    alter structures using SQL `alter` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `authors` table and click **Modify Table…**, as shown in *Figure
    11**.30*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.30: You can alter existing tables by right-clicking the table](img/B19644_11_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.30: You can alter existing tables by right-clicking the table'
  prefs: []
  type: TYPE_NORMAL
- en: When you do this, you get a window like the one shown in *Figure 11**.31*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.31: Changes you make here are generated as an alter statement,
    which is a best practice in database development](img/B19644_11_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.31: Changes you make here are generated as an alter statement, which
    is a best practice in database development'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11**.31*, I’ve added a column called `date_of_birthd` with the type
    of date. As you can see in the preview window, PyCharm is generating an `alter`
    statement rather than trying to drop and recreate the table as many database editors
    do. If you wanted to drop the table, there was an option for that in the menu
    displayed in *Figure 11**.30*.
  prefs: []
  type: TYPE_NORMAL
- en: Generating scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm has a very powerful utility for generating all kinds of SQL scripts.
    Since we’re talking about DDL here, it makes sense to learn how to generate the
    full SQL script that will create the table we’ve been working on.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the database, as shown in *Figure 11**.32*, and click the **SQL
    Scripts** | **SQL Generator…** menu item.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.32: SQL Generator generates the create script for our database](img/B19644_11_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.32: SQL Generator generates the create script for our database'
  prefs: []
  type: TYPE_NORMAL
- en: The panel on the left allows you to set a few interesting options. As you click
    them, the generated SQL will change if applicable. I say *if applicable* because
    not every database platform supports every syntax option in the list. We’re using
    MySQL, which supports the `Use CREATE IF NOT EXISTS` syntax but doesn’t support
    the `CREATE OR REPLACE` syntax, which you would find in Postgres or Oracle. Clicking
    a syntax that isn’t supported simply doesn’t change the syntax in the preview
    window.
  prefs: []
  type: TYPE_NORMAL
- en: When the DDL script meets your needs, you can use the buttons on the far right
    (circled in *Figure 11**.32*) to copy, save, or run the script in a query window.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a database diagram
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Very traditional database practices typically entail a design document such
    as a database schema diagram. In the good old days, we’d use dedicated tools for
    diagramming. PyCharm has a diagramming tool built in, and the best part is the
    diagram is generated based on the structure of the database, rather than being
    drawn from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: To generate a diagram, just right-click your database, find the **Diagrams**
    menu item, and pick either option shown in *Figure 11**.33*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.33: The Diagrams menu items are shown along with a generated diagram](img/B19644_11_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.33: The Diagrams menu items are shown along with a generated diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between the two options is one draws the diagram directly
    in the content area of the IDE while the other generates it in a pop-up window.
    The pop-up window is useful for viewing the diagram on another monitor. You can
    navigate the diagram with zooming tools, as well as panning around by right-clicking
    within the diagram while dragging.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also find export options on the top toolbar for exporting your diagram
    to image files, as well as data files that can be imported into dedicated diagramming
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Querying the data source using SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Querying the database is probably the second most useful feature of having database
    tooling built right into the IDE. As with many of the features in PyCharm, this
    one ensures you never need to leave PyCharm to get your work done.
  prefs: []
  type: TYPE_NORMAL
- en: There are several places that allow you to run queries. You can run ad hoc queries
    in a query console, or you can run queries directly from `.``sql` files.
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ad hoc queries are simply queries for an immediate purpose. An ad hoc query
    has a number of characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unplanned**: Ad hoc queries are not part of a predefined set of queries.
    They are written on the spot to address a particular need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporary**: They are used to retrieve data for a specific task or situation
    and are not saved for future use. They aren’t part of your application, though
    after some experimentation and tweaking, you might formalize them in your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No optimization**: Ad hoc queries might not be optimized for efficiency,
    as they are quickly put together without the time for fine-tuning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variability**: The syntax and structure of ad hoc queries can vary depending
    on the user’s knowledge and experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not stored**: Unlike stored procedures or views, ad hoc queries are not stored
    in the database as with, say, a view or a stored procedure. This means they cannot
    be called or executed again later unless you save them to a file later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ad hoc queries are executed in a database console. A console window appears
    automatically when you complete your connection to the data source, but there
    are many places in the interface where you can create a new console view. Look
    at *Figure 11**.34* and you’ll see the data source window. A button labeled **QL**,
    for **Query Language**, is circled. It doesn’t say *SQL* because, remember, PyCharm
    also supports NoSQL databases, such as MongoDB, Apache Cassandra, and Redis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.34: Any place you see a QL icon like this you can launch a console
    window and query your data source using an ad hoc query](img/B19644_11_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.34: Any place you see a QL icon like this you can launch a console
    window and query your data source using an ad hoc query'
  prefs: []
  type: TYPE_NORMAL
- en: The **QL** button is sensitive to the database selected in the data source window,
    so if you have more than one data source, you can open a query source to any of
    them by selecting them in the data source window and then hitting the **QL** button.
    I actually closed the console that was automatically launched when I created the
    data source. To create a new console, I’ll hit the **QL** button and select **New
    Console**.
  prefs: []
  type: TYPE_NORMAL
- en: The first console you open becomes the **default console**. PyCharm keeps track
    of your consoles in the **Scratches and Consoles** folder, as shown in *Figure
    11**.35*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.35: PyCharm tracks consoles along with scratch files in a dedicated
    folder in the IDE](img/B19644_11_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.35: PyCharm tracks consoles along with scratch files in a dedicated
    folder in the IDE'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve typed any SQL in the console, PyCharm will keep the contents even
    between sessions. Empty consoles will disappear when you exit PyCharm. This is
    handy for keeping track of your ad hoc work.
  prefs: []
  type: TYPE_NORMAL
- en: Generating SQL statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create some seed records, which will ultimately be saved as a seed
    script. A seed script is a script that can be used for testing an application
    by seeding the database with some initial test data. We’re moving away from the
    strictly DDL statements we’ve used so far. We’re going to be using more DML, which
    are the statements used to work with data rather than database structure. Seed
    scripts are also useful for filling in data tables with static data that rarely
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to seed our `authors` table with a few records, but we’re going
    to have PyCharm generate a lot of the SQL for us. Begin by creating a console
    if you don’t have one open already. Right-click the `authors` table, hover over
    **SQL Scripts**, then find **Insert rows into a table**. Check out *Figure 11**.36*
    to see it in action.
  prefs: []
  type: TYPE_NORMAL
- en: s
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.36: PyCharm will generate DML queries for you automatically!](img/B19644_11_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.36: PyCharm will generate DML queries for you automatically!'
  prefs: []
  type: TYPE_NORMAL
- en: Once you click the option, you’ll find an `insert` statement has been inserted
    (oh yes!) directly into the console. You can see mine in *Figure 11**.37*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.37: PyCharm generated an insert statement for the table we selected](img/B19644_11_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.37: PyCharm generated an insert statement for the table we selected'
  prefs: []
  type: TYPE_NORMAL
- en: Note the bounding box around the text. We’ve seen this before. You’re looking
    at a template! This means we can tab from place to place in the templated text,
    which is why you shouldn’t mess with the text as I did.
  prefs: []
  type: TYPE_NORMAL
- en: Copy-paste warning!
  prefs: []
  type: TYPE_NORMAL
- en: If you have an electronic copy of this book that allows you to copy and paste
    from the e-book itself, be careful with any code that relies on single quotation
    marks as the upcoming SQL statement does. The process of editing the book often
    turns them into special characters that won’t work when you paste them into a
    console. Make sure the single quotation marks are really single quotation marks!
  prefs: []
  type: TYPE_NORMAL
- en: '`insert` statements can be divided into two halves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The halves I’m talking about are the parts of the statement that aren’t boilerplate
    – the parts in the two sets of parentheses. The first set specifies which fields
    you’ll be filling, and the second set is the values. You have to match the order
    and type of the fields in the first half when you type values for each field.
    If you hit the *Tab* key, you’ll move between the two halves of the `insert` statement,
    allowing you to modify it as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: Unconventional generated SQL
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm doesn’t generate SQL keywords in all caps by default, which is the normal
    convention. You might notice that statements that I type are all caps, but generated
    ones aren’t. I had to resist the temptation to fix that for the sake of the book,
    but I also need to explain why there are inconsistencies at play.
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm generated a placeholder for the primary key, which is a field you wouldn’t
    normally populate since the database fills that in automatically. Go ahead and
    take that first field out of the field set in the first parentheses as I did in
    the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, tab over to the `values` section, and begin to fill in values. Remember,
    in SQL, `varchar (string)` values must be enclosed in single quotes. Python allows
    you to use either single or double quotes but SQL does not. As you type values,
    PyCharm will give you hints about the field you are matching for the value. It
    does this with a tooltip over the text in the editor, but it also color codes
    the current field in the top half of the statement. See *Figure 11**.38* to see
    what I mean.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.38: PyCharm gives tooltips for the field and type you are currently
    filling in the second half of the query](img/B19644_11_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.38: PyCharm gives tooltips for the field and type you are currently
    filling in the second half of the query'
  prefs: []
  type: TYPE_NORMAL
- en: This is huge! How many times have you written a long `insert` statement only
    to find that you have more values than fields? Or worse, you discover you’ve transposed
    a few fields and you enter a bunch of garbage data by mistake? PyCharm gives you
    a visual indicator to make sure you know exactly which field you’re entering by
    showing you a tooltip with the field and type you are filling in. It also shades
    the field in the top half of the SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Running the query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably don’t need me to tell you this because, at this point, you’re probably
    used to seeing green run arrows where it is appropriate to run something. You
    can run the contents of the console by clicking the green arrow at the top of
    the console’s tab in the IDE. You can also highlight a section of the console’s
    contents and run a portion of the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the contents of your console to match this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All I did was copy the same SQL four times, then I changed the names for a little
    variety, and to give a shout-out to my Packt crew (holla!). Next, highlight the
    first statement and run the query. The **Services** panel will open to show the
    results of the query. As you can see in *Figure 11**.39*, only one record was
    inserted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.39: You can execute single statements by selecting them and clicking
    the Run button](img/B19644_11_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.39: You can execute single statements by selecting them and clicking
    the Run button'
  prefs: []
  type: TYPE_NORMAL
- en: If you select the remainder and run again, you’ll find three insertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some data, let’s query with a `SELECT` statement. Add this
    code to your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I could have generated `select`, but this query is short. I wanted to show you
    how PyCharm displays the results. Take a look at *Figure 11**.40*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.40: By default, select statements produce a nice, tabular output](img/B19644_11_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.40: By default, select statements produce a nice, tabular output'
  prefs: []
  type: TYPE_NORMAL
- en: This is a dense panel! You can do a lot here. By default, you see a tabular
    view of the data (**1**). You can double-click the cells and edit the data in
    place. You can also add and delete rows using this UI (**2**). After you’ve edited
    the data to your liking, you can submit your changes using the small green up
    arrow on the toolbar (**2**) in *Figure 11**.40*.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d rather change the output view from tabular to either raw text or a
    tree view (which makes more sense for querying hierarchical data), you can click
    the eyeball icon in the toolbar (**2**) in *Figure 11**.41*.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting query results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can export the results of your `select` statements using the export button
    *Figure 11**.41*. *Figure 11**.41* shows what this looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.41: Exporting data is easy in PyCharm](img/B19644_11_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.41: Exporting data is easy in PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: The export format defaults to **comma-separated values** (**CSV**), which is
    a common format for tabular data exchange. PyCharm supports dozens of other useful
    formats, which you’ll find in the **Extractor** drop-down list. Change the output
    file to something you like, then click the **Export to** **file** button.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SQL files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm supports files with a `.sql` or `.ddl` file extension. Like other recognized
    file types, you’ll get auto-completion, syntax highlighting, and so on. You can
    also run statements directly in the SQL file just like we can in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s immortalize our console work so far as a proper script. Create a new
    file in PyCharm called `seed.sql`. Next, add this line to the top of the script
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `USE` statement is MySQL-specific and ensures you have the `database_fun`
    database selected prior to executing the SQL statements. The `TRUNCATE` statement
    will delete all the records in the `authors` table and reset the auto-incrementor
    sequence on the table back to its initial value. This is useful for development
    testing since now the seed script can reset to a clean set of testing values.
    Just be careful to never run the seed script in production!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, cut and paste the contents of your console beneath the `TRUNCATE` statement.
    Note that I said cut. You want the console empty. The script should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Save your seed script and run it. It should execute successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have this terrible feeling that I haven’t covered everything. That’s because
    I didn’t. I could write a whole book just on the database features of PyCharm,
    but if I did, I might as well title it something like *Hands-On Database Programming
    with DataGrip*. Don’t forget, we’re seeing a whole other IDE crammed into the
    crevices of PyCharm much as we did with WebStorm in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172),
    *Web Development with JavaScript, HTML, and CSS*. The feature set is truly staggering
    and I didn’t cover some of the really interesting features owing to either lack
    of space in this book or because some of the really cool features are still works
    in progress.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can set code as a data source and synchronize the code to the
    structure of the database. At present, it isn’t 100% complete, which is why I
    left it out. As a database developer, I would expect to be able to have a round-trip
    experience where changes to the code are reflected in the database and changes
    to the database are copied back to the code. I think we’re well on our way.
  prefs: []
  type: TYPE_NORMAL
- en: What we did cover, though, was pretty complete coverage for either full stack
    web development or a data science practitioner needing to tap multiple database
    platforms and data storage paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: We started out with a little history. I like covering the history in this and
    previous chapters because I have the advantage of a long career behind me. I was
    around for most of what I’m describing, and I had a front-row seat. I was in the
    first grade when E. F. Codd formalized relational algebra. Part of me wishes I
    could brag about using his early work, but in truth, I was a bigger fan of watching
    the Saturday morning TV show *Lassie and the Rescue Rangers* in my footy pajamas
    than I was of `SELECT` statements. When I was older, I got to work on IBM mainframes,
    so I did eventually catch up.
  prefs: []
  type: TYPE_NORMAL
- en: Moving into more practical matters, we learned that PyCharm, using separately
    installed JDBC drivers, can connect to dozens of different database platforms.
    We learned it supports not only relational databases but NoSQL as well. After
    we learned how to open the database tools and connect our data source, we learned
    how to design a database using a host of tools that generate DDL for us.
  prefs: []
  type: TYPE_NORMAL
- en: Then we moved on to using PyCharm to generate the DML that would power our work
    once we got some data in our tables. Finally, after working in a console to create
    our initial work, we saved our SQL into a `.``sql` file.
  prefs: []
  type: TYPE_NORMAL
- en: The positioning of this chapter in the book is very intentional. I’ve restrained
    myself from doing a lot of coding in the full stack frameworks we covered in the
    last few chapters. In real life, you would most assuredly have databases attached
    to such projects. While many developers rely on ORMs to handle the database work
    for them, it never hurts to at least be able to examine the database and its contents
    directly using a console.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re like me, and you forgo ORMs entirely, you now have the missing piece
    to the puzzle. You can create your database code using a marvelous set of tools
    without leaving PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also offered a logical split as the next few chapters start coverage
    of PyCharm Professional’s power data science feature set. It only makes sense
    to preface that set of chapters with coverage of these most ubiquitous engines
    for data storage and retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll be turning on *science mode*! Go pick up your lab
    coat from the dry cleaners, grab yourself a big cup of C8H10N4O2, and I’ll see
    you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Desktop installation instructions: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using KeePass in PyCharm: [https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html](https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codd, E. F. (1983). A relational model of data for large shared data banks.
    *Communications of the ACM*, *26*(1), 64-69.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forta, B. (2013). *Sams teach yourself SQL in 10 minutes*. Pearson Education.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hernandez, M. J. (2013). *Database Design for Mere Mortals: A Hands-On Guide
    to Relational Database Design*. Pearson Education.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pettit, T. and Cossetino, S. (2022). *The MySQL Workshop*. Packt Publishing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poulton, N. (2023). *Docker Deep Dive – 2nd Edition.* Packt Publishing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Viescas, J. L. and Hernandez, M. J. (2014). *SQL Queries for Mere Mortals:
    A Hands-On Guide to Data Manipulation in SQL*. Pearson Education.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Data Science with PyCharm'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the previous part, this part of the book focuses on a specific application
    of Python programming, this time data analysis and data science. Readers will
    be able to use PyCharm and its features to efficiently work on their data science
    and scientific computing projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19644_12.xhtml#_idTextAnchor298), *Turning on Scientific Mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19644_13.xhtml#_idTextAnchor318), *Dynamic Data Viewing with
    SciView and Jupyter*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19644_14.xhtml#_idTextAnchor340), *Building a Data Pipeline
    in PyCharm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
