- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Understanding Database Management in PyCharm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm中理解数据库管理
- en: What do horseshoe crabs, coelacanths, crocodiles, and relational databases have
    in common? I’ll wait while you go look up *coelacanth*. All four of these have
    been around for millions of years and yet have evolved very little. OK, databases
    haven’t been around for millions of years, but they have been around for millions
    of internet years. Everybody knows that internet years are very short. JavaScript
    developers often joke that before lunchtime, anywhere in the world, dozens of
    new frameworks have been invented, risen to prominence, fallen out of favor, and
    then been abandoned all before you finish your noodles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 马蹄蟹、肺鱼、鳄鱼和关系数据库有什么共同之处？我等你查一下*肺鱼*。这四种生物都存在了数百万年，但进化很小。好吧，数据库没有存在数百万年，但它们已经存在了数百万个互联网年。众所周知，互联网年是短暂的。JavaScript开发者经常开玩笑说，在午餐时间之前，世界上任何地方都会发明数十个新的框架，它们会崭露头角，失去青睐，然后在你吃完面条之前就被遗弃。
- en: In the early 1970s, a researcher named E. F. Codd was working at IBM’s San Jose
    Research Laboratory in California. He developed a revolutionary concept called
    **the relational model of data**. In his seminal paper titled *A Relational Model
    of Data for Large Shared Data Banks*, published in 1970, Codd outlined the principles
    and foundations of this new approach to organizing and retrieving data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪70年代初，一位名叫E. F. Codd的研究员在加利福尼亚州IBM的圣何塞研究实验室工作。他开发了一种革命性的概念，称为**数据关系模型**。在他的开创性论文《大型共享数据银行的关系数据模型》中，发表于1970年，Codd概述了这种新方法组织数据的原则和基础。
- en: Codd’s relational model proposed a way to represent data as a collection of
    tables, known as relations, with each table consisting of rows and columns. He
    introduced the concept of **relational algebra**, a mathematical framework for
    manipulating and querying data in these tables. The model emphasized the use of
    mathematical **set theory** and logic to define relationships and perform operations
    on the data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Codd的关系模型提出了一种将数据表示为关系集合的方法，即关系，每个表由行和列组成。他引入了**关系代数**的概念，这是一种用于在这些表中操作和查询数据的数学框架。该模型强调了使用数学**集合论**和逻辑来定义关系和执行数据操作。
- en: Codd’s ideas challenged the prevailing hierarchical and network database models
    of the time, which were more complex and less flexible. The relational model offered
    a simpler and more intuitive way to manage data, providing a foundation for **Structured
    Query Language** (**SQL**) and other tools used in relational databases.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Codd的思想挑战了当时盛行的层次结构和网络数据库模型，这些模型更复杂且灵活性较差。关系模型提供了一种更简单、更直观的方式来管理数据，为**结构化查询语言**（**SQL**）和其他在关系数据库中使用的工具奠定了基础。
- en: 'In 1974, IBM released the first commercially available **relational database
    management system** (**RDBMS**), called *System R*, based on Codd’s work. System
    R implemented many of the concepts outlined in Codd’s research and became an influential
    precursor to subsequent relational database systems. In 1974, IBM released System
    R based on Codd’s work, but the product wasn’t aggressively marketed or sold because
    IBM executives were worried about cannibalizing sales on other database systems
    sold by the company. During that time, another start-up database company was born:
    **Oracle**. The initial release of Oracle was developed by Larry Ellison, Bob
    Miner, and Ed Oates. Released in 1983, Oracle is generally considered to be the
    first commercial success even though IBM had a serious head start.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 1974年，IBM发布了第一个商业可用的**关系数据库管理系统**（**RDBMS**），名为*System R*，基于Codd的工作。System R实现了Codd研究中概述的许多概念，并成为后续关系数据库系统的一个有影响力的先驱。1974年，IBM基于Codd的工作发布了System
    R，但由于IBM高管担心会损害公司其他数据库系统的销售，该产品并没有积极地进行市场推广或销售。在那个时期，另一家初创数据库公司诞生了：**Oracle**。Oracle的最初版本是由拉里·埃利森、鲍勃·米纳和埃德·奥茨开发的。1983年发布的Oracle通常被认为是第一个商业上的成功，尽管IBM有明显的先发优势。
- en: Relational database technology evolved throughout the 80s and 90s, and along
    the way, it became a staple of corporate IT in every industry in every corner
    of the globe. In 1986, the SQL language became standardized. The standard evolved
    over time, but to be honest, 49 years after the invention of SQL, most development
    is done with the simplest and oldest set of language statements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库技术在20世纪80年代和90年代不断发展，在这个过程中，它成为了全球每个角落每个行业中企业IT的必备技术。1986年，SQL语言实现了标准化。随着时间的推移，标准也在不断发展，但说实话，在SQL发明49年后，大多数开发工作都是使用最简单、最古老的语句集完成的。
- en: A moment ago, I stated that Codd’s ideas challenged the prevailing hierarchical
    and network database models of the time, which were more complex and less flexible.
    It is interesting to note that in the early 2000s, there was a shift away from
    relational database technology toward what we call **NoSQL databases**. The world
    of IT often acts like a pendulum, forever swinging back and forth. We used to
    have relatively low-powered PCs capable of playing video files at 12 frames per
    second in a postage stamp-sized window. Technology improved to the point where
    we could watch a 4K high-definition video at full speed on a PC, but then we invented
    small hand-held devices, such as the iPod, and we were back to low-end processing
    and choppy, grainy video. Eventually, those improved into the iPhone, which can
    play video at high definition and high frame rates. Some iPhones are bigger than
    the TV I had in college.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才，我说过Codd的想法挑战了当时盛行的层次化和网络数据库模型，这些模型更加复杂且灵活性较低。值得注意的是，在2000年代初，人们开始从关系型数据库技术转向我们所说的**NoSQL数据库**。IT界常常像摆钟一样，永远在来回摇摆。我们曾经有过相对低功耗的PC，能够在邮票大小的窗口中以每秒12帧的速度播放视频文件。技术得到了改进，我们可以全速在PC上观看4K高清视频，但随后我们发明了小型手持设备，如iPod，我们又回到了低端处理和粗糙的视频。最终，这些改进成了iPhone，它能够以高清和高帧率播放视频。有些iPhone比我在大学时拥有的电视还要大。
- en: Likewise, with databases, one day the world was using hierarchical and network-oriented
    databases. The next day everything swung to a new thing called *relational*. Today,
    we see a swing back in the other direction. More and more projects today favor
    non-relational databases, many of which support hierarchical data. Regardless
    of which technology you might favor, it is safe to say that just about any project
    you build, especially in the corporate IT world, will interact with some database
    in some big way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在数据库领域，有一天世界正在使用层次化和面向网络的数据库。第二天，一切又转向了一个新事物，称为*关系型*。如今，我们看到又回到了另一个方向。越来越多的项目今天倾向于非关系型数据库，其中许多支持层次化数据。无论你偏爱哪种技术，可以说，你几乎构建的任何项目，尤其是在企业IT领域，都将以某种方式与数据库交互。
- en: In 2015, JetBrains created a new product aimed at becoming a popular IDE for
    database developers. **DataGrip** was created to provide a unified interface and
    robust toolset for working with various databases. It offers features such as
    intelligent code completion, advanced SQL editing capabilities, schema navigation,
    data analysis, and integration with version control systems. Like the web development
    product by JetBrains, WebStorm, the DataGrip product is integrated into the Professional
    edition of PyCharm through its plugin system. Consider that your 99 USD investment
    in PyCharm Professional gets you a Python IDE, a JavaScript IDE, an IDE for web
    frontend work in HTML and CSS, and now a fully fledged IDE for database work and
    you’ll see you’ve gotten a solid deal!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，JetBrains推出了一款新产品，旨在成为数据库开发人员流行的IDE。**DataGrip**的创建是为了提供用于处理各种数据库的统一界面和强大的工具集。它提供智能代码补全、高级SQL编辑功能、模式导航、数据分析以及与版本控制系统的集成。与JetBrains的Web开发产品WebStorm一样，DataGrip产品通过其插件系统集成到PyCharm的专业版中。考虑到你在PyCharm专业版上的99美元投资，你得到了一个Python
    IDE、一个JavaScript IDE、一个用于HTML和CSS前端工作的IDE，现在还有一个用于数据库工作的完整IDE，你会发现这是一个非常划算的交易！
- en: 'In this chapter, we will cover the features of PyCharm related to databases.
    By the end of the chapter, you will have learned the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍PyCharm与数据库相关的功能。到本章结束时，你将学习以下内容：
- en: Some database history and some basics just to make sure we’re all on the same
    page in terms of terminology. If you’ve been developing software for a while,
    this might be a review. If you’re new, I will endeavor to provide you with the
    best possible introduction to database technology.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些数据库历史和一些基础知识，以确保我们在术语方面处于同一页。如果你已经开发软件一段时间了，这可能是一次复习。如果你是新手，我将努力为你提供数据库技术的最佳可能介绍。
- en: How to navigate to the database tools in PyCharm, which are hidden away in a
    tab on the right side of the interface. I have met many developers who have used
    PyCharm for years yet don’t know these tools are even present.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何导航到PyCharm中的数据库工具，这些工具隐藏在界面右侧的一个标签页中。我遇到过许多使用PyCharm多年的开发者，但他们甚至不知道这些工具的存在。
- en: How to connect to different databases, including how to add the necessary connection
    drivers to PyCharm. JetBrains has made this very easy!
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何连接到不同的数据库，包括如何在PyCharm中添加必要的连接驱动程序。JetBrains使这一过程变得非常简单！
- en: How to configure SQL dialects for individual projects as well as globally.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为单个项目和全局配置SQL方言。
- en: How to use SQL generation templates to help you write SQL queries more quickly.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用SQL生成模板来帮助你更快地编写SQL查询。
- en: How to generate an **entity relationship** **diagram** (**ERD**).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成**实体关系图**（**ERD**）。
- en: How to use the graphical designers to build tables easily.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用图形设计器轻松构建表格。
- en: How to use consoles to create and run ad hoc queries against any database.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用控制台创建和运行针对任何数据库的即席查询。
- en: On a personal note, besides learning to code in BASIC when I was 12, relational
    technology was the first skill I mastered when I got into the IT field over 30
    years ago. This is a skill set that has always been in demand, and will probably
    continue to be in demand for many years to come. It is a subject I have extensive
    experience in, and I am excited to share that experience with you in this chapter.
    So, let’s get to it!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，除了12岁时学习BASIC编程之外，关系技术是我30多年前进入IT领域时掌握的第一项技能。这是一个一直有需求，并且可能在未来许多年里仍将有需求的技能集。这是我有着丰富经验的一个主题，我很高兴能在本章与你分享这些经验。那么，让我们开始吧！
- en: Technical requirements
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed with this chapter, and indeed the rest of the book, you
    will need the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续本章，以及本书的其余部分，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并运行Python解释器。我将使用来自[https://python.org](https://python.org)的最新版本。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*, in case
    you are jumping into the middle of the book.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并运行PyCharm的副本。安装已在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中介绍，以防你是在书的中途开始阅读。
- en: A database server is a nice-to-have in this chapter so you can practice on a
    real database. There are dozens of popular relational databases to choose from,
    so it is not practical for me to cover all of them. I will be running **MySQL**
    using **Docker Desktop**. If you plan on following along, you’ll need to have
    Docker Desktop installed on your computer. You can find instructions for installation
    at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，数据库服务器是一个不错的选择，这样你就可以在实际数据库上练习。有数十种流行的关系型数据库可供选择，因此对我来说涵盖所有这些并不实际。我将使用**MySQL**和**Docker
    Desktop**运行。如果你打算跟随，你需要在你的计算机上安装Docker Desktop。你可以在[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)找到安装说明。
- en: This book’s sample source code is from GitHub. We covered cloning the code in
    [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*.
    You’ll find this chapter’s relevant code at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的示例源代码来自GitHub。我们已在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中介绍了代码克隆。你可以在[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-11)找到本章的相关代码。
- en: Relational databases in a nutshell
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简要介绍关系数据库
- en: 'The idea of relational data conceived by E. F. Codd is based on a few simple
    principles. Firstly, data can be represented in sets called *tables*. A `books`.
    The `books` table will contain columns that define the data within those columns
    – maybe something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: E. F. Codd提出的关于关系数据的概念基于几个简单的原则。首先，数据可以用称为*表*的集合来表示。一个`books`。`books`表将包含定义这些列内数据的列——可能像这样：
- en: '| **Title** | **ISBN** | **Page Count** | **Author** | **Price** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **标题** | **ISBN** | **页数** | **作者** | **价格** |'
- en: '| The Art of War | 1599869772 | 68 | Sun Tzu | 4.99 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 资治通鉴 | 1599869772 | 68 | 孙子 | 4.99 |'
- en: '| Book of Five Rings | 8387743849 | 43 | Miyamoto Musashi | 4.50 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 五轮书 | 8387743849 | 43 | 宫本武藏 | 4.50 |'
- en: This table has five columns designed to structure data about books. We have
    two books, which are stored as rows in the table.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此表有五个列，用于结构化关于书籍的数据。我们有两本书，它们作为行存储在表中。
- en: Structured Query Language
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化查询语言
- en: E. F. Codd’s paper that defined relational algebra served as the basis for SQL.
    SQL is unlike any other coding language you will ever use because it is one of
    only a handful of languages that use a declarative paradigm. Most languages you
    use, including Python, use an imperative paradigm. In short, the language serves
    as a syntactical framework to give a computer instructions on what you want it
    to do. You are basically a micro-manager. You specify every input, every output
    and every step the program will take during the processing that happens to get
    the input to the output. You must be meticulous, as the computer will take you
    literally. If you leave out even a single detail, you are setting things up to
    malfunction.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: E. F. Codd的关于关系代数的论文是SQL的基础。SQL与您将使用的任何其他编程语言都不同，因为它仅是少数几种使用声明性范式的语言之一。您使用的多数语言，包括Python，都使用命令式范式。简而言之，这种语言作为一个句法框架，向计算机提供指令，告诉它您希望它做什么。您基本上是一个微观管理者。您必须指定每个输入、每个输出以及程序在处理过程中将采取的每个步骤，以将输入转换为输出。您必须非常细致，因为计算机将严格地执行您的指令。如果您遗漏了任何细节，您就是在设置系统出现故障。
- en: '**Declarative programming**, on the other hand, entails merely specifying the
    output you want from an implicit input. You have little to no control over the
    operations performed to derive the output from the input. Consider this SQL statement
    designed to get some rows from your bookstore database:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**声明性编程**仅仅涉及指定您希望从隐含输入中获得的输出。您对从输入中推导出输出的操作几乎没有控制权。考虑以下设计用于从您的书店数据库中获取一些行的SQL语句：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This query will produce some output consisting of a table that has a few of
    the columns from your original database, which serves as the implicit input. You’ll
    get the following columns:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询将产生一些输出，包括一个表格，其中包含您原始数据库中的一些列，这些列作为隐含输入。您将得到以下列：
- en: '`Title`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`标题`'
- en: '`ISBN`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ISBN`'
- en: '`Author`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`作者`'
- en: '`Price`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`价格`'
- en: But you won’t get the page count because you didn’t ask for it in the query.
    The input data source is implied in the `FROM books` section of the query. At
    the end, we have a request to order the results by price in descending order (`DESC`),
    which will make our resulting tabular list of books appear from the most expensive
    to the cheapest.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但您不会得到页数，因为您在查询中没有要求。输入数据源隐含在查询的`FROM books`部分中。最后，我们有一个按价格降序排序结果的要求（`DESC`），这将使我们的结果表格从最贵到最便宜排列。
- en: The two halves of SQL
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL的两个部分
- en: 'SQL itself is split into two separate sets of syntax: `SELECT` statement presented
    earlier is an example of a read operation. SQL has keywords for `INSERT`, `UPDATE`,
    and `DELETE` operations for records which are straightforward, so I want to focus
    on DDL since this is going to be a big part of your work in PyCharm.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQL本身分为两个独立的语法集合：前面提到的`SELECT`语句是一个读操作的例子。SQL有`INSERT`、`UPDATE`和`DELETE`操作的关键字，这些操作对于记录来说是直接的，所以我想专注于DDL，因为这将是你PyCharm工作中的一大部分。
- en: 'Our earlier example of a table to be used in a bookstore application had one
    table in it called `books`. That table contained a set of columns, which we would
    define using DDL like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在书店应用程序中使用的表格示例中有一个名为`books`的表。这个表包含了一组列，我们将使用DDL（数据定义语言）如下定义这些列：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are new to SQL, you might have noticed the keywords are capitalized.
    In fact, I’ll bet you correctly assumed that the capitalized words were keywords.
    While it isn’t a requirement to capitalize keywords, it is good practice – particularly
    if your project’s database lead is a large man retired from the United States
    Marine Corps who is particular about the details of syntax in *his* database!
    In this case, good practice might become a matter of survival.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是SQL的新手，您可能已经注意到关键字都是大写的。实际上，我敢打赌您正确地假设那些大写的单词是关键字。虽然关键字大写不是强制性的，但这是一个好的实践——尤其是如果您的项目数据库负责人是一位从美国海军陆战队退休的大个子，他对*他*的数据库中的句法细节非常讲究的话！在这种情况下，好的实践可能成为生存的关键。
- en: Most of what you read in the table’s DDL is easy to figure out. We’re creating
    a table called `books`. We already knew about the column names. SQL uses a strong
    type system, meaning you have to define the type of data that will go into a column,
    and violating that constraint might come with consequences. I’ve said many times
    before that a developer’s job is to protect a program from entering an invalid
    state. Likewise, it is a database developer’s job, as well as that of a `VARCHAR`
    refers to a variable-length set of characters. Programmers call this a *string*.
    The number (`255`) after the type refers to the maximum length of `VARCHAR`. All
    of the `VARCHAR` (string) fields in the database are limited to 255 characters
    in length. The number 255 is very common because many of us old-timers grew up
    in the world of 8-bit computing. The number 255, being the maximum value of an
    8-bit unsigned integer, was a common maximum for the length of the field. We’d
    set it to that when we weren’t sure how long the data might be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在表的DDL中，你读到的内容大部分都很容易理解。我们正在创建一个名为`books`的表。我们已经知道了列名。SQL使用强类型系统，这意味着你必须定义将要放入列中的数据类型，违反这个约束可能会带来后果。我以前说过很多次，开发者的工作就是保护程序不进入无效状态。同样，数据库开发者的工作也是如此，以及`VARCHAR`指的是一组可变长度的字符。程序员称之为*字符串*。类型后面的数字（`255`）指的是`VARCHAR`的最大长度。数据库中所有的`VARCHAR`（字符串）字段长度都被限制在255个字符以内。数字255非常常见，因为我们这些老一辈的人都是在8位计算的世界中长大的。数字255是8位无符号整数的最大值，因此是字段长度的常见最大值。当我们不确定数据可能有多长时，我们会将其设置为这个值。
- en: Naturally, today, we normally work in 32- and even 64-bit architectures, so
    the maximum can be much higher. It is normal to constrain ourselves to the old
    maximum because 255 characters are generally enough for most things. Specifying
    sane maximums helps keep your database storage and memory requirements reasonable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，今天，我们通常在32位甚至64位架构上工作，所以最大值可以更高。将我们限制在旧的最大值是正常的，因为255个字符通常足够用于大多数事情。指定合理的最大值有助于保持你的数据库存储和内存需求合理。
- en: Look at the `price` field. It is specified as the `DECIMAL` type, which is obviously
    like a float. Database systems have different names for their types, so you should
    always consult your database system’s documentation to get the exact naming. `DECIMAL`
    is indeed a floating-point number, but we also specified the level of precision
    with `(10,2)`. This means we can have a 10-digit number with 2 decimal places.
    This is commonly used to specify prices. Some database systems have specialized
    types specifically for currency. SQL Server is an example of this with their `MONEY`
    and `SMALLMONEY` types. Again, check your database system’s documentation for
    appropriate types since these specialized types aren’t part of standard SQL.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`price`字段。它被指定为`DECIMAL`类型，这显然类似于浮点数。数据库系统对它们的类型有不同的命名，所以你应该始终查阅你的数据库系统文档以获取确切的命名。`DECIMAL`确实是一个浮点数，但我们还指定了精度级别为`(10,2)`。这意味着我们可以有一个10位数字，有2位小数。这通常用于指定价格。一些数据库系统有专门针对货币的类型。SQL
    Server就是这样一个例子，它们有`MONEY`和`SMALLMONEY`类型。再次提醒，检查你的数据库系统文档以获取适当类型，因为这些专用类型不是标准SQL的一部分。
- en: Relationships
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系
- en: 'Consider our bookstore will naturally grow in size and complexity. Let’s say
    we’ve added some different fields and removed some we weren’t using. Our new table
    structure looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们的书店自然会增长规模和复杂性。假设我们添加了一些不同的字段，并删除了一些我们没有使用的字段。我们新的表结构看起来像这样：
- en: '| **Title** | **Author_name** | **Author_email** | **Pages** | **Price** |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **标题** | **作者姓名** | **作者邮箱** | **页数** | **价格** |'
- en: '| C Programming Language, 2nd Edition | Brian Kernighan and Dennis Ritchie
    | bkernigan@notrealaddress.com | 272 | 53.60 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| C程序设计语言（第2版） | 布莱恩·肯尼根和丹尼斯·里奇 | bkernigan@notrealaddress.com | 272 | 53.60
    |'
- en: '| Real-World Implementation of C# Design Patterns | Bruce Van Horn | bvanhorn@notrealaddress.com
    | 442 | 44.99 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| C#设计模式实战应用 | 布鲁斯·范·霍恩 | bvanhorn@notrealaddress.com | 442 | 44.99 |'
- en: '| Hands-On Application Development with PyCharm | Quan Nguyen | qnguyen@notrealaddress.com
    | 785 | 35.45 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 使用PyCharm进行实战应用开发 | 阮文 | qnguyen@notrealaddress.com | 785 | 35.45 |'
- en: '| Hands-On Application Development with PyCharm, 2nd Edition | Bruce Van Horn
    | bvanhorn@notrealaddress.com | 840 | 44.99 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 使用PyCharm进行实战应用开发（第2版） | 布鲁斯·范·霍恩 | bvanhorn@notrealaddress.com | 840 | 44.99
    |'
- en: Besides the complexity coming from more records, we’ve introduced some complexity
    in terms of design. At some point, it became important for us to track more information
    about the authors of any given book. We added fields for the name and email address,
    which seemed to solve our problems at first, but ultimately led to more issues.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了来自更多记录的复杂性之外，我们在设计方面也引入了一些复杂性。在某个时候，对我们来说，跟踪任何给定书籍作者的更多信息变得很重要。我们添加了姓名和电子邮件地址字段，起初这似乎解决了我们的问题，但最终导致了更多问题。
- en: The C book has two authors, but we only have one field. While it might be fine
    to store both authors as we did, there is also a field for the email address and
    this can only accommodate one address. This is not ideal since our objective might
    be to send royalty statements or sales reports to the authors. One address is
    a problem.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: C语言书籍有两个作者，但我们只有一个字段。虽然将两位作者都存储起来可能没问题，但我们还有一个电子邮件地址字段，而这个字段只能容纳一个地址。这并不理想，因为我们的目标可能是向作者发送版税声明或销售报告。一个地址就是一个问题。
- en: The email addresses will be duplicated in the event we store two books with
    the same author. If the author changes email addresses, all of the records have
    to be updated. This is the equivalent of hardcoded values kept in multiple places
    in a program. You have to remember to change it in lots of places. The problem
    is compounded if this email address data is duplicated in several different tables.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们存储了两本同一作者的书籍，电子邮件地址将会重复。如果作者更改了电子邮件地址，所有记录都必须更新。这相当于在程序中多个地方硬编码的值。你必须记住在许多地方更改它。如果这个电子邮件地址数据在几个不同的表中重复，问题会更加复杂。
- en: 'The solution to this is prescribed by SQL and the ideas behind relational algebra.
    You need a single source of truth for the author’s data instead of mixing it in
    with other tables. So, we create a new table for authors:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案由SQL和关系代数背后的思想规定。你需要一个作者数据的单一来源，而不是将其与其他表混合。因此，我们为作者创建了一个新表：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This table has fields for the first and last names as well as the email address.
    It also has a field called `id`, which is going to the server as a primary key.
    A primary key is a field that can uniquely identify the information in that row.
    The idea here is that every author gets only one row to store their information.
    We need some piece of data to uniquely identify that row. Consider my own records.
    My first and last names make poor choices to uniquely define my record in the
    database. I know of at least three other people named Bruce Van Horn. One was
    my father, who published in the medical field. One is a motivational speaker who
    publishes books in that literary field. I found another Bruce Van Horn on LinkedIn,
    and believe it or not, he too is a software developer! So the name is a poor choice
    as a unique identifier.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格有姓名、姓氏以及电子邮件地址字段。还有一个名为`id`的字段，它作为主键发送到服务器。主键是一个可以唯一标识该行信息的字段。这里的想法是每个作者只得到一个行来存储他们的信息。我们需要一些数据来唯一标识该行。以我自己的记录为例。我的姓名和姓氏在数据库中作为唯一定义我的记录的选择很糟糕。我知道至少有其他三个人叫布鲁斯·范·霍恩。一个是我的父亲，他在医学领域发表作品。一个是励志演讲者，在那个文学领域出版书籍。我在领英上找到了另一个布鲁斯·范·霍恩，信不信由你，他也是一个软件开发者！所以，名字作为唯一标识符是一个糟糕的选择。
- en: Email addresses might work, except that we’ve already figured out that email
    addresses can change. I have no fewer than five email addresses and at least one
    of these is so overtaken with spam that I no longer even check it. Email isn’t
    going to work.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件地址可能可行，但我们已经发现电子邮件地址可能会更改。我至少有五个电子邮件地址，其中至少有一个被垃圾邮件淹没得如此严重，以至于我甚至不再检查它。电子邮件是不可行的。
- en: The best practice is to use some piece of data that is unique but arbitrary,
    with no bearing at all on the rest of the data in the record. There are two ways
    to do this. The most common is to use a database sequence. A **sequence** is an
    automatically incrementing source of integers. Each time a record is inserted
    into a table, the sequencer generates a sequential number, which is guaranteed
    to be unique.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用一些独特但随机的数据，它与记录中的其他数据没有任何关联。有两种方法可以做到这一点。最常见的是使用数据库序列。序列是一个自动递增的整数源。每次将记录插入到表中时，序列生成器都会生成一个顺序号，该顺序号保证是唯一的。
- en: The other approach is to use `6f35e0e7-d99a-4437-b894-f73ff35bd3ad` versus a
    record with the `id` value of `16`. Which would you rather type into your queries?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`6f35e0e7-d99a-4437-b894-f73ff35bd3ad`这样的记录与具有`id`值为`16`的记录相比。你更愿意在查询中输入哪一个？
- en: 'Now that we have a field that uniquely identifies an author’s record, we can
    adjust our book table structure like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个字段可以唯一标识作者的记录，我们可以调整我们的书籍表结构如下：
- en: '| **Title** | **pages** | **price** | **author_id** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **Title** | **pages** | **price** | **author_id** |'
- en: '| Real-World Implementation of C# Design Patterns | 442 | 44.99 | 2 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Real-World Implementation of C# Design Patterns | 442 | 44.99 | 2 |'
- en: '| Hands-On Application Development with PyCharm | 785 | 35.45 | 1 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| Hands-On Application Development with PyCharm | 785 | 35.45 | 1 |'
- en: '| Hands-On Application Development with PyCharm, 2nd Edition | 840 | 44.99
    | 2 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Hands-On Application Development with PyCharm, 2nd Edition | 840 | 44.99
    | 2 |'
- en: 'Our `authors` table looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `authors` 表看起来是这样的：
- en: '| **author_id** | **first_name** | **last_name** | **email** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **author_id** | **first_name** | **last_name** | **email** |'
- en: '| 1 | Quan | Nguyen | qnugyen@notrealaddress.com |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Quan | Nguyen | qnugyen@notrealaddress.com |'
- en: '| 2 | Bruce | Van Horn | bvanhorn@notrealaddress.com |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Bruce | Van Horn | bvanhorn@notrealaddress.com |'
- en: The author ID in the `authors` table is used as a related column in the `books`
    table using a one-to-many relationship. Each author will have one record, which
    is related to many records in the `books` table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`authors` 表中的作者ID在 `books` 表中用作相关列，通过一对一关系。每个作者将有一个记录，该记录与 `books` 表中的多个记录相关联。'
- en: More relational structures
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关系结构
- en: We’ve solved a big problem using our one-to-many table structure. We no longer
    have duplicate data in multiple records for our authors. We didn’t, however, solve
    all of our problems. For example, the C book has multiple authors. How can we
    store authors in a way that allows each book to support multiple authors?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一对一的表结构解决了一个大问题。我们不再在多个记录中为作者重复数据。然而，我们并没有解决所有问题。例如，C语言书籍有多个作者。我们如何以允许每本书支持多个作者的方式存储作者？
- en: I’m afraid we’ve reached the point where I tell you that this isn’t a book on
    SQL, nor is it a book on relational theory. If I’ve hooked you on this, I can
    recommend some excellent books that I used when I learned these things. We’ve
    presented enough relational database vocabulary to help you relate to what you
    will see in PyCharm’s tooling and that was my real objective.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我恐怕我们已经到了这样一个地步，我告诉你这既不是一本关于SQL的书，也不是一本关于关系理论的书籍。如果我让你对这本书产生了兴趣，我可以推荐一些我学习这些知识时用过的优秀书籍。我们已经提供了足够的数据库关系词汇，以帮助你理解PyCharm工具中看到的内容，那才是我的真正目标。
- en: Since I am not a total degenerate, regardless of what you may read about me
    on Stack Overflow, I will give you the solution quickly and without many pages
    of explanation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我并不是一个彻底的堕落者，无论你在Stack Overflow上读到关于我的什么，我都会快速地给你解决方案，而不会用很多页的解释。
- en: 'You’d solve it using what we call a mapping table. Your structure would require
    the addition of a table called `books_authors_map`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你会使用我们所说的映射表来解决这个问题。你的结构需要添加一个名为 `books_authors_map` 的表：
- en: '| **Id** | **Book_id** | **Author_id** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **Id** | **Book_id** | **Author_id** |'
- en: '| 1 | 1 | 1 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: '| 2 | 1 | 2 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 | 2 |'
- en: 'Your `books` table would look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `books` 表将如下所示：
- en: '| **Book_id** | **Title** | **Pages** | **Price** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **Book_id** | **Title** | **Pages** | **Price** |'
- en: '| 1 | The C Programming Language | 442 | 44.99 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 1 | The C Programming Language | 442 | 44.99 |'
- en: 'We took out the `author_id` field and added a `book_id` field, which really
    should have been there all along. The `authors` table would look the same:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们移除了 `author_id` 字段，并添加了一个 `book_id` 字段，这个字段本来就应该在那里。`authors` 表看起来会相同：
- en: '| **Author_id** | **First_name** | **Last_name** | **Email** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **Author_id** | **First_name** | **Last_name** | **Email** |'
- en: '| 1 | Brian | Kernighan | bkernigan@notrealaddress.com |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Brian | Kernighan | bkernigan@notrealaddress.com |'
- en: '| 2 | Dennis | Ritchie | dritche@noterealaddress.com |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 2 | Dennis | Ritchie | dritche@noterealaddress.com |'
- en: The mapping table can map a `books` and `authors`! If either author goes solo
    and publishes a book without their co-author, that will work! The `books` table’s
    record will have one related record in the map, which has one related record in
    the `authors` table.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 映射表可以将 `books` 和 `authors` 进行映射！如果任何作者独立出版书籍而没有合作者，那也是可以的！`books` 表的记录将在映射中有一个相关记录，该记录在
    `authors` 表中有一个相关记录。
- en: If a book has 10 authors, it will have 1 book record, 10 author records, and
    10 mapping entries. Relational algebra is pretty cool! It is an underrated skill
    in today’s world of **object relational mappers** (**ORMs**), which abstract all
    of this into normal object structures. Developers today tend to lose this skill.
    If you do, you give up a lot. You can make fine-grained modifications in your
    DDL that lead to huge performance gains for your application.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一本书有 10 位作者，它将有一个书记录，10 个作者记录和 10 个映射条目。关系代数非常酷！它是当今**对象关系映射器**（**ORMs**）世界中被低估的技能，ORMs
    将所有这些抽象成常规对象结构。今天的开发者往往失去了这种技能。如果你失去了它，你将失去很多。你可以在 DDL 中进行精细的修改，这将为你的应用程序带来巨大的性能提升。
- en: Speaking of that, let’s learn about PyCharm’s tooling for database development.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个，让我们来了解一下 PyCharm 的数据库开发工具。
- en: Database terminology uses simple English plurals
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库术语使用简单的英语复数形式
- en: As we go through some of the terminology used when talking about databases,
    I feel compelled to point out something that bothered me for a very long time.
    Many terms used when talking about databases come from Latin root words. For example,
    an **index** is an addition to a table that can speed up data retrieval at the
    cost of the speed of inserting new data. It is also a Latin word that refers to
    *a pointer, indicator, or signpost*. A **schema** refers to a way of partitioning
    off tables and other structures in a database. The word *schema* originated with
    the Greek word σχῆμα (*skema*) and in both languages means *shape, form,* *or
    plan*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们讨论数据库讨论中使用的术语，我感到有必要指出困扰我很久的一件事。在讨论数据库时使用的许多术语都源自拉丁语根词。例如，**索引**是表格的一个附加项，可以加快数据检索速度，但会牺牲插入新数据的速度。它也是一个指代**指针、指示器或路标**的拉丁语单词。**模式**指的是在数据库中将表和其他结构划分开来的方式。单词**模式**起源于希腊语单词σχῆμα
    (*skema*)，在两种语言中均意为**形状、形式**或**计划**。
- en: When talking about the plural forms, the words might not be as you expect if
    you received a classical education as I did. If you come from a country where
    your language is based on Latin, you might notice this issue as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到复数形式时，如果你像我一样接受了传统教育，你可能会发现单词的复数形式并不像你预期的那么简单。如果你来自一个以拉丁语为基础的语言国家，你也可能会注意到这个问题。
- en: I would expect the plural form of *schema* to be *schemata*, and the plural
    of *index* to be *indices*. If you expect this, you will always be disappointed.
    The industry has standardized simple plural forms such as *schemas* and *indexes*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我原本预期 *schema* 的复数形式应该是 *schemata*，而 *index* 的复数形式应该是 *indices*。如果你预期这样，你总会感到失望。该行业已经标准化了简单的复数形式，如
    *schemas* 和 *indexes*。
- en: Database tooling in PyCharm
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PyCharm 中的数据库工具
- en: 'The database tooling in PyCharm is complete but generic. By this, I mean that
    PyCharm attempts to support every database out there, and as such, it generally
    supports features common to all. You may find yourself sometimes leaning on more
    specific tools, such as **SQL Server Management Studio** (**SSMS**) for SQL Server.
    However, for general development work, the tooling in PyCharm is more than sufficient.
    The starting point for working with databases in PyCharm is opening the database
    tools and creating a connection. For this, you also need a database. PyCharm supports
    dozens of the most popular database servers. Since this is true, it would be impossible
    for me to predict which one you prefer, so I’m going to fall back on one that
    I know well: MySQL. Regardless of your favorite, the tooling in PyCharm is generic,
    so as long as you pick a relational database that is standards-compliant, the
    processes are the same.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 中的数据库工具功能全面但通用。我的意思是，PyCharm 试图支持所有数据库，因此它通常支持所有数据库共有的功能。你可能会发现自己有时会依赖更具体的工具，例如用于
    SQL Server 的 **SQL Server Management Studio**（**SSMS**）。然而，对于一般开发工作，PyCharm 中的工具已经足够。在
    PyCharm 中处理数据库的起点是打开数据库工具并创建一个连接。为此，你还需要一个数据库。PyCharm 支持数十种最受欢迎的数据库服务器。由于这个原因，我无法预测你更喜欢哪一个，所以我将退而求其次，选择我熟悉的：MySQL。无论你更喜欢哪一个，PyCharm
    中的工具都是通用的，只要你选择一个符合标准的关联数据库，过程都是相同的。
- en: Setting up a MySQL database server with Docker
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 设置 MySQL 数据库服务器
- en: The easiest way to try out any database system, or pretty much any server technology
    at all, is to use Docker. I have more plans for Docker later in the book, and
    I will be using Docker Desktop, along with the command line. I like the desktop’s
    GUI for seeing what is running graphically, but you should master Docker command-line
    skills in order to remain competitive. If you don’t have Docker Desktop installed,
    you can find the installation instructions at [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).
    Naturally, there are other options, such as installing a database server on your
    computer. I personally rail against this because database servers are very complicated.
    Installing something such as SQL Server or Oracle will make modifications to your
    OS at a level that makes these software packages hard to uninstall. It used to
    be a rule of thumb that if you made any mistakes installing the database server,
    the smartest option was the wipe the OS and start over. I’m relatively sure that’s
    no longer the case, but I still treat database servers with respect because of
    all the moving parts in your solution, this one is easily the most complicated.
    The last thing you want is a broken database server on your laptop while in the
    middle of developing an epic project. So, I recommend Docker. If something goes
    wrong, you delete the container and make a new one.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, you can create a VM using products such as **VMware Workstation**
    or **Oracle VirtualBox**. This is another fine way to work, though it takes up
    more space and resources than Docker will, and you must remember to keep your
    VMs up to date.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Another fine option is to spin up your database server of choice in your favorite
    cloud. I recommend **DigitalOcean** for this since their pricing and setup are
    both extremely easy to understand. I use this service to host the companion website
    for this book. If your computer isn’t up for running a database server, VMware,
    or Docker, using a cloud provider is your best option.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: All these options are great, but I need to pick one, so I’m going to be working
    with Docker. Remember, this isn’t a book on Docker. My coverage is going to be
    tacit. Your objective is to get a database server up and running so you can practice.
    If you can do that with something besides Docker, go ahead and skip to the next
    section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running the MySQL container
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’m assuming you have Docker running on your computer and that your Docker
    commands are available in your `PATH`. We can confirm this by opening our terminal
    and typing this command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command will list all the containers currently running, or stopped. If
    you just installed Docker, you should see an empty list, which is to say, nothing
    at all. The test is really to make sure the command runs and doesn’t throw any
    errors. If it doesn’t, you’re ready to grab MySQL using this command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll see a nicely animated display of the installation, as shown in *Figure
    11**.1*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: The Docker command used to pull the images needed for MySQL](img/B19644_11_001.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: The Docker command used to pull the images needed for MySQL'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'This command pulled all the requirements needed to run one or more containers
    for MySQL. Next, we need to create and run a container with this command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will create and run a container named `pycharm-mysql`. It sets
    the root password for the MySQL database to `P@ssw0rd`. The `–p` flag maps port
    `3306`, which is the standard port for MySQL, to the same value between your container
    and the host. This will make it seem as though you are running the MySQL server
    directly on your computer. The `-d` flag tells Docker to run MySQL as a background
    process rather than waiting for it to exit. This is common with server software.
    I hope I don’t need to remind you that *this is not production ready*. If you
    are in a small group where the developers are responsible for standing up a production
    environment, don’t simply duplicate your development environment on a server open
    to the internet. You should at least map your database to more robust permanent
    storage, as well as harden MySQL, use non-privileged accounts for your app, and
    use a non-obvious root password.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: We are now running the MySQL server. When you run the Docker command, your output
    is somewhat cryptic and unsatisfying. You can see mine in *Figure 11**.2*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: A long string of seemingly random letters and numbers is Docker’s
    way of saying “I love you,” or at least that your container is running](img/B19644_11_002.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: A long string of seemingly random letters and numbers is Docker’s
    way of saying “I love you,” or at least that your container is running'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an old saying that goes, *Tell a man there are a trillion stars in
    the galaxy, and he’ll believe you. Tell him his container is successfully running
    in Docker and he’ll run* `docker ps -a` *to be sure.* In truth, I might have just
    made that up. Nevertheless, let’s make sure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You should see proof like mine in *Figure 11**.3*. The `CONTAINER ID` value
    will be different for every run, so don’t expect yours to match mine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: I can see my container named pycharm-mysql is running and has
    exposed port 3306](img/B19644_11_003.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: I can see my container named pycharm-mysql is running and has
    exposed port 3306'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and starting the container
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re ready to retire for the day, you might want to stop the container:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This stops the container. You can check with the same `docker ps -a` command
    we’ve been using to confirm the status changed from *Up* to *Stopped*. Tomorrow
    morning, when you come back, type the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This starts things up so you can pick up where you left off.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to data sources using PyCharm
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open PyCharm Professional and create a new Python project called `database_fun`.
    Now, locate the database tools. You can find them on the right side toolbar via
    the database icon that looks like a three-layer cake (yum!). Alternatively, you
    can find it via the hamburger (yum!) menu by clicking **View** | **Tool Windows**
    | **Database**. Both options are shown in *Figure 11**.4*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: Two options for opening database tools – one from the menu,
    and the second by clicking the database tools icon](img/B19644_11_004.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Two options for opening database tools – one from the menu, and
    the second by clicking the database tools icon'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: With the database tools open, you need to create a new **data source**. Note
    the generic terminology. PyCharm supports relational as well as non-relational
    databases, so the term *data source* is just a generic way of pointing that out.
    Click the **+** icon shown in *Figure 11**.5*, then hover over **Data Source**.
    You’ll see a long list of supported data sources. Find **MySQL** and click it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Supported data sources in PyCharm](img/B19644_11_005.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Supported data sources in PyCharm'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see a configuration window like mine in *Figure 11**.6*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Configuration window for a MySQL database](img/B19644_11_006.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Configuration window for a MySQL database'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Each database server may have slightly different settings, but essentially they
    boil down to the IP address (or DNS name), port, security credentials, and, very
    often, the default database, which may not yet exist. We defined the root password
    for our MySQL server as `P@ssw0rd`, and we know since we’re running in Docker
    our IP is just going to be `localhost`. You might also remember the port that
    was displayed in the output of the `docker ps -a` command we ran earlier is `3306`.
    The arrow in the preceding figure points to an important aspect of database tooling
    in PyCharm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm, like most JetBrains IDEs, is written in Java. As such, PyCharm relies
    on **Java Database Connectivity** (**JDBC**) drivers in order to work. Most JDBC
    drivers are written by the same company or group that publishes the database,
    which means it’s generally not legal for JetBrains to bundle those drivers with
    PyCharm without getting lawyers involved. Nobody wants that! JetBrains did the
    next best thing. The IDE can download and install the driver automatically, but
    you have to initiate this by clicking the **Download missing driver files** link
    on this screen. This only needs to be done the first time you use the database
    driver. Once the drivers are installed, the option shown by the arrow in *Figure
    11**.6* no longer appears. You can test your connection by clicking the **Test
    Connection** link. If everything works, you’ll get a confirmation message stating
    your database connection was successful. Click **OK** to close the connection
    dialog.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Once the connection dialog is closed, you’ll see a list of data source connections
    for your project in the **Database** panel. There is a small toolbar visible at
    the top of the database panel, as shown in *Figure 11**.7*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: The database panel has a small menu bar at the top](img/B19644_11_007.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: The database panel has a small menu bar at the top'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, I’ve numbered the options in the figure. Let’s review them:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The **Add Data Source** button, which we’ve already seen, allows you to add
    new data sources to your project.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Duplicate** button allows you to make a quick copy, presumably with some
    minor adjustments. Many of my projects entail multiple databases on one server.
    All I have to do is set up the first one, then duplicate the connection and change
    the name of the database. This option makes this a quick and easy process.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Refresh** button reloads the metadata for your connections. Remember this
    one. PyCharm doesn’t automatically keep track of all your database changes, especially
    if they are made outside of PyCharm. You’ll need to click the **Refresh** button
    periodically to make sure you’re viewing the latest information on your data sources.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Data source properties** button will display a dialog that allows you
    to change the settings of the data source configuration.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Disconnect** button will disconnect you from a database server.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Edit data** button allows you to directly edit data in tables in your
    database using a graphical, spreadsheet-like UI. This is nice for quickly adding
    or changing test data.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Go To DDL** button will take you to the SQL definition of whatever you
    have currently selected. You need to have a DDL mapping for this to work properly.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compare Structure** lets us compare two database structures. This is usually
    used to help migrate one database structure to another after changes were made
    during the normal development process. Migration technology in PyCharm 2023 is
    only partially complete, so this feature might have changed at the time you are
    reading this book.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Jump to Query Console** is pretty much your go-to tool for interacting with
    the database at the command line. A query console was opened automatically when
    you first connected to the database, but if you closed it, this button opens it
    and brings it into focus.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The filter button allows you to filter what you see in the data sources you
    have defined. By default, everything is turned on, which might be a bit much for
    most developers who are not usually accustomed to seeing all the guts of the database
    so explicitly displayed.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides these tools, there are others that pertain to setting up how you view
    and work with your data sources. These will be a little easier to explain once
    we have a database to play with. Let’s take a moment to create one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new database
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we do anything else, we need a new database. Most database servers just
    call this “a new database.” MySQL is a little different. They call a new database
    a new `@localhost`) and click **New** | **Schema**, as shown in *Figure 11**.8*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Create a new database by right-clicking the server (indicated
    by the arrow), then New | Schema](img/B19644_11_008.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: Create a new database by right-clicking the server (indicated
    by the arrow), then New | Schema'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: When you do this, you are prompted to name the schema, as shown in *Figure 11**.9*.
    I’ll name my schema to match my project in PyCharm. I’ll call it `database_fun`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: Name your schema using this dialog](img/B19644_11_009.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Name your schema using this dialog'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Beneath the covers, PyCharm is just generating and executing DDL statements.
    This is how it is able to be so agnostic with respect to so many database options.
    You can see the preview of the command it will run in *Figure 11**.9*. Click **OK**
    to execute the command, and the database window will update to show the new schema.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just created a new database! It is just as easy using any other database
    server software supported by PyCharm.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into working on the structure of our database, there are a few
    more setup options to consider.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Setting the SQL dialect (this is crucial)
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since PyCharm supports dozens of different databases, each with its own dialect
    of SQL, it stands to reason that you might need to tell PyCharm which SQL dialect
    you intend to use. You won’t have any trouble remembering to do this because PyCharm
    nags you until you fill in the setting.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In your project window, right-click the project and create a new file called
    `test.sql`. It’s the same process we’ve been using for Python files, except there
    isn’t a template in the list. Right-click the project, then click **New File**,
    as shown in *Figure 11**.10*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: There isn’t a specific listing for SQL files, so just right-click
    and pick New | File](img/B19644_11_010.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: There isn’t a specific listing for SQL files, so just right-click
    and pick New | File'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: A small dialog will appear. Type the name of the file as `test.sql`. The moment
    you do this, the nagging begins. You’ll see a message stating the SQL dialect
    is not configured, as shown in *Figure 11**.11*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11: PyCharm will hound you until you configure the SQL dialect](img/B19644_11_11.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: PyCharm will hound you until you configure the SQL dialect'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: If PyCharm were me and the user of PyCharm were my 13-year-old daughter, there
    would be a lot of eye-rolling, an exasperated grunt, followed by, “Fine! I’ll
    set the SQL dialog! But none of my friends do!” Then I’d say, “If you’re friends
    all installed Windows 7 on their computers, would you follow their example?” Then
    she’d sag her head and say, “No, of course not.”
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Nobody wants this dialogue playing out, so we’d better make our IDE overlord
    happy. Click the link in *Figure 11**.11* to set the dialect. You’ll need to set
    it locally and globally. The configuration is shown in *Figure 11**.12*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: Set the SQL dialects globally and locally](img/B19644_11_012.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Set the SQL dialects globally and locally'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The global setting carries across all projects, so if you’re like me and you
    only ever use one database server type, you can set it globally here, and it will
    be set for all your projects. The project dialect is a little more nuanced. If
    you value your sanity, you really need to create a folder for your SQL files,
    then set the dialect for the folder. Here, I’m just showing you where the settings
    are. Go ahead and pick **MySQL** for your global and local dialect and we’ll worry
    about the whole folder idea a little later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Grouping and color coding data sources
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My own work consists of creating the SaaS product sold by my employer. This
    means that for the first seven years of the project, I only had one database to
    deal with. As the product grew in capability, we added two more SQL databases,
    a MongoDB database, and several Redis data caches to the project. My project is
    still pretty tame compared to some I’ve worked on. If you have many databases
    to deal with, PyCharm allows you to organize them in several different ways.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Organizing by folders
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can organize your data sources by grouping them into folders. We only have
    one, but we’ll go through the process anyway. Click the data source indicated
    by the arrow in *Figure 11**.8*. Last time, we right-clicked; this time, just
    click the data source and press *F6* on your keyboard. This brings up a dialog,
    as shown in *Figure 11**.13*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13: Create a new folder for your data source](img/B19644_11_013.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Create a new folder for your data source'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Organizing by folder can be useful if you have lots of databases in your project,
    or maybe you have separate sets of connections for development, **user acceptance
    testing** (**UAT**), and production.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Color coding databases
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’m fond of this feature since I have four environments:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: A local database, just like we have now
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A central development testing database where the development validates their
    designs before the product team is allowed to see our changes
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A staging database that is connected to a staged version of our application
    for UAT
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A production database
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I always color code everything! You can set a color for the data source by opening
    up the **Data Source Properties** window. To do this, click the **Data Source
    Properties** button on the toolbar. I showed you this earlier in *Figure 11**.7
    (4)*. Clicking this button reveals a dialog box similar to the one you used to
    create the data source earlier. Look at mine in *Figure 11**.14*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: Click the innocuous dot next to the data source name in the
    properties window to set a color for your data source](img/B19644_11_014.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Click the innocuous dot next to the data source name in the properties
    window to set a color for your data source'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: You can probably figure it out from here. Once you dismiss the dialog, your
    database elements in the IDE become awash with lovely pastel hues. Personally,
    I set my local development environment to violet, the dev environment to green,
    staging to yellow, and production to red. Not rose from the selection, but a bright,
    obnoxious, over-the-top, fire engine red picked from the custom dialog at the
    bottom of the list. As the project’s development lead, there are times when I
    need to go look at the project in production. I want to make sure I remember where
    I am! Color coding helps!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Sharing a data source between projects
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have many projects that use the same data source, it would be tedious
    to have to set the same thing over and over for each project. Thankfully, you
    don’t have to. PyCharm allows you to make a data source global, meaning it is
    available to all your projects in PyCharm. In the data source properties window
    shown in *Figure 11**.15*, find the button indicated by the arrow.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15: You can make your data source configuration global so it is
    available to all your projects](img/B19644_11_015.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: You can make your data source configuration global so it is available
    to all your projects'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: If you click it, the dialog changes very subtly to indicate the data source
    is now global. If you want to check, just make a new project like we did earlier.
    Open the database tools and you’ll find the data source is already there. I made
    a project called `more_database_fun`, and as you can see in *Figure 11**.16*,
    the data source indeed carried over.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16: I made a new project and opened the database tools. The global
    data source is there](img/B19644_11_016.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: I made a new project and opened the database tools. The global
    data source is there'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no code in this second project, I did not include it in the chapter
    source code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Another fun feature is the global data sources are exported when you export
    your IDE settings. Refer back to [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation and Configuration*, if you need a refresher on importing and exporting
    settings, but I’ll go ahead and point out the export settings I’m talking about
    here in *Figure 11**.17*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17: You can export your global data sources to the settings export
    ZIP file, allowing others to simply import the relevant settings](img/B19644_11_017.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.17: You can export your global data sources to the settings export
    ZIP file, allowing others to simply import the relevant settings'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: If you are a development lead, you might consider creating an export of your
    IDE settings that does not include things such as color and font size. Those are
    likely more personal preferences and make sense when you want to copy your settings
    between a laptop and a workstation. But it does make sense to export more work-specific
    settings such as your data sources so your team can easily import them. If you
    do this, remember you are also potentially copying credentials! You should only
    make development data sources available as global exports lest your `settings.zip`
    file falls into the wrong hands. This is especially important in an age where
    more and more of us are using cloud database servers rather than locally installed
    servers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: If you need tight control over credentials, PyCharm can integrate with a product
    called *KeePass*. Since that is fairly niche, I’ll not cover it here, but I will
    leave a link with more details in the *Further reading* section of this chapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with SSL and SSH options
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For even more security, especially with respect to cloud data sources, PyCharm
    supports SSL and SSH configuration options. See *Figure 11**.18* for your security
    setup options for your data sources.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18: SSH and SSL security options can be found in the data source
    settings on the SSH/SSL tab](img/B19644_11_018.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.18: SSH and SSL security options can be found in the data source
    settings on the SSH/SSL tab'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: I won’t go deep into this here, but you need to know where these settings lie
    in the IDE since you will need them for cloud providers such as Microsoft Azure.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Database design and manipulation
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s move on to the part you’ve probably been waiting for: the part where
    we get to build a database! We already created the schema, but at the moment,
    we don’t have any tables. Let’s fix that first!'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right-click the schema, **database_fun**, which we created earlier, and click
    **New** | **Table**, as shown in *Figure 11**.19*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19: Right-click on the schema indicated by the arrow, then click
    New | Table](img/B19644_11_019.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.19: Right-click on the schema indicated by the arrow, then click
    New | Table'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: You’ll get a new window, as shown in *Figure 11**.20*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20: New window](img/B19644_11_020.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.20: New window'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: I had to stretch mine out a little to see it all, as shown in the figure. The
    next few steps will build our table. I went ahead and typed the table name in
    the **Name** field at the top. You can see what’s going on here. As before, with
    the schema creation DDL, PyCharm is building a DDL script in the preview at the
    bottom of the window. Right now, we have a red squiggly line under the semicolon
    because we have yet to add any fields, so this DDL is invalid.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: At the top left of the window is a button with a **+** icon. Click that to see
    a list of elements you can add to the table, as shown in *Figure 11**.21*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21: You can add to the table by clicking the + button](img/B19644_11_021.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.21: You can add to the table by clicking the + button'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can pick whatever it is you need to add. We’re going to add our
    primary key field first. If you’re new to relational database design and you need
    a good primer, *Database Design for Mere Mortals* by Michael Hernandez is a must-read.
    I’ve used it as a textbook in my classes for over 20 years! Hernandez has an equally
    impactful book on SQL queries, as does another author, named Ben Forta. I’ll leave
    the details in the *Further reading* section of this chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: In short, every table we create should have a field that can uniquely identify
    individual records. It should not consist of data that is related to the domain
    of data contained in the table. By this I mean we are making a table to hold information
    about book authors. We should not use any field related to the author as the primary
    key, the record’s unique identifier. Instead, we should use something unrelated.
    With MySQL, the norm is to use an auto-incrementing integer field.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: An auto-incrementing integer field refers to a field that will automatically
    populate a number from a sequence starting with the number 1 and increasing automatically
    with each record insertion. The increment is not something you should do in code.
    This is a feature of the database itself. This is important. Relational databases
    are designed to be atomic, meaning all transactions are isolated. This is important
    because it means the database will never generate the same value for the auto-incrementing
    key even if two record insertions happen within microseconds of one another. This
    is something you cannot guarantee with your own code. You need to rely on the
    server for this.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Using the menu shown in *Figure 11**.21*, add a column and set it as shown in
    *Figure 11**.22*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22: Add the first column with the settings shown here](img/B19644_11_022.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.22: Add the first column with the settings shown here'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve created an auto-incrementing integer field called `author_id`. I’m
    using snake case here, but this is not required. Use whatever naming conventions
    your project requires. Note I haven’t yet officially made it the primary key.
    That’s coming. First, let’s finish out the rest of our columns.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: This can be done quickly if you leave the `author_id` field selected, then click
    the plus button three times. When you have a column selected, or even when you
    have the `columns` folder selected in the window, PyCharm assumes that when you
    click the **+** button, you want a column. Likewise, you can select any of the
    other folders for things such as primary keys, foreign keys, and indexes. PyCharm
    will simply create it without making you use the menu we saw earlier.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure the three fields like so:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '`first_name`: `varchar(30)`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_name`: `varchar(30)`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: `varchar(255)` `not null`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 11**.23* shows the last field configuration. I gave this one the `not
    null` constraint, which will prevent a record insertion from completing if the
    `email` field is left empty. This is done by clicking the checkbox titled **Not
    null**, as seen in *Figure 11**.22*.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23: Configure the email field as shown](img/B19644_11_023.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.23: Configure the email field as shown'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: It’s starting to look like a table, isn’t it? There are just a couple more things
    we need. Let’s go ahead and configure the `author_id` field to be a proper primary
    key.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Setting the primary key
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Click on the `keys` folder, then click the **+** button. You’re asked whether
    you want to create a primary or unique key, as shown in *Figure 11**.24*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24: Make sure the keys folder is selected, as shown in this figure,
    then click the + icon and pick Primary Key](img/B19644_11_024.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.24: Make sure the keys folder is selected, as shown in this figure,
    then click the + icon and pick Primary Key'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: This will bring up a different window, as seen in *Figure 11**.25*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.25: Adding a primary key entails clicking the + icon and then selecting
    the field name from the dropdown](img/B19644_11_025.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.25: Adding a primary key entails clicking the + icon and then selecting
    the field name from the dropdown'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: To add the key, click the `author_id` field to add it as the primary key. The
    relational theory allows for the creation of compound keys, which is why you could
    potentially add more than one field. It isn’t used in general practice since if
    you stick to an auto-incrementing integer for your key, creating a compound primary
    key isn’t needed. In fact, I consider a compound key to be a code smell.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Adding a unique key constraint
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, let’s constrain the `email` field so that the value of any inserted record
    must be unique. This prevents data toxicity problems arising from promiscuous
    inserts. There should really only be one record for each email address. Let’s
    enforce it formally with a unique key.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The process is the same as with the primary key, except this time we’ll pick
    a unique key instead of the primary key and we’ll specify the `email` field. There’s
    a trick though. This time, you’ll need to right-click the `keys` folder to pick
    the **Unique Key**. If you just click the **+** icon, it will add another primary
    key field, which isn’t what we want. *Figure 11**.26* shows you what to do.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.26: Right-click keys, then click New | Unique Key to avoid creating
    a second primary key](img/B19644_11_026.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.26: Right-click keys, then click New | Unique Key to avoid creating
    a second primary key'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `keys` folder, indicated by the arrow in the preceding figure,
    then click `email` field. I would also change the name from the generated `authors_pk2`
    value to `authors_uq`. This will tell you at a glance in the DDL that it is a
    unique field constraint.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Adding an index
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding an index to a table will make filtered read operations more performant.
    It would be a reasonable requirement to expect an application to allow users to
    search for an author by their email address. Adding an index to the `email` field
    will make this search faster at the expense of making new record inserts slightly
    slower. The insert performance hit is small, but if you were to add an index to
    every single field, it would become noticeable, so pick the fields you want to
    index carefully.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: The process is the same for creating the keys. Refer to *Figure 11**.27*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.27: Right-click the indexes folder and add the index as shown](img/B19644_11_027.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.27: Right-click the indexes folder and add the index as shown'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: This time, we right-click the `indexes` folder and click **New** | **Index**.
    From here, the dialog is familiar, as shown in *Figure 11**.28*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.28: We’ve added an index to the email field](img/B19644_11_028.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.28: We’ve added an index to the email field'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our table code won’t fit in a screenshot, so here’s what we
    have:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you’re happy with your table structure, click **OK** and PyCharm will apply
    the DDL code generated to the database. You can see the results in the data source.
    Check mine out in *Figure 11**.29*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.29: The results of our hard work are shown in the data source panel](img/B19644_11_029.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.29: The results of our hard work are shown in the data source panel'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Altering existing structures
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve seen a lot of tools over the years that are good at allowing you to graphically
    create a database structure, but when it comes to altering existing structures,
    they fall flat. Microsoft SSMS springs to mind! It will let you merrily design
    away only to tell you when you try to commit your changes that it can’t do it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm’s not like that. PyCharm handles changes the way your company’s DBA
    wants you to do it. If you’re new to the field, a DBA is in charge of the database.
    They’re the boss. If you are lucky enough to be granted the *privilege* of creating
    anything in their database, you will follow their rules. And they want you to
    alter structures using SQL `alter` statements.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the `authors` table and click **Modify Table…**, as shown in *Figure
    11**.30*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.30: You can alter existing tables by right-clicking the table](img/B19644_11_30.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.30: You can alter existing tables by right-clicking the table'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: When you do this, you get a window like the one shown in *Figure 11**.31*.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.31: Changes you make here are generated as an alter statement,
    which is a best practice in database development](img/B19644_11_31.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.31: Changes you make here are generated as an alter statement, which
    is a best practice in database development'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11**.31*, I’ve added a column called `date_of_birthd` with the type
    of date. As you can see in the preview window, PyCharm is generating an `alter`
    statement rather than trying to drop and recreate the table as many database editors
    do. If you wanted to drop the table, there was an option for that in the menu
    displayed in *Figure 11**.30*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Generating scripts
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm has a very powerful utility for generating all kinds of SQL scripts.
    Since we’re talking about DDL here, it makes sense to learn how to generate the
    full SQL script that will create the table we’ve been working on.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the database, as shown in *Figure 11**.32*, and click the **SQL
    Scripts** | **SQL Generator…** menu item.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.32: SQL Generator generates the create script for our database](img/B19644_11_32.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.32: SQL Generator generates the create script for our database'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The panel on the left allows you to set a few interesting options. As you click
    them, the generated SQL will change if applicable. I say *if applicable* because
    not every database platform supports every syntax option in the list. We’re using
    MySQL, which supports the `Use CREATE IF NOT EXISTS` syntax but doesn’t support
    the `CREATE OR REPLACE` syntax, which you would find in Postgres or Oracle. Clicking
    a syntax that isn’t supported simply doesn’t change the syntax in the preview
    window.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: When the DDL script meets your needs, you can use the buttons on the far right
    (circled in *Figure 11**.32*) to copy, save, or run the script in a query window.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Generating a database diagram
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Very traditional database practices typically entail a design document such
    as a database schema diagram. In the good old days, we’d use dedicated tools for
    diagramming. PyCharm has a diagramming tool built in, and the best part is the
    diagram is generated based on the structure of the database, rather than being
    drawn from scratch.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: To generate a diagram, just right-click your database, find the **Diagrams**
    menu item, and pick either option shown in *Figure 11**.33*.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.33: The Diagrams menu items are shown along with a generated diagram](img/B19644_11_33.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.33: The Diagrams menu items are shown along with a generated diagram'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The only difference between the two options is one draws the diagram directly
    in the content area of the IDE while the other generates it in a pop-up window.
    The pop-up window is useful for viewing the diagram on another monitor. You can
    navigate the diagram with zooming tools, as well as panning around by right-clicking
    within the diagram while dragging.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also find export options on the top toolbar for exporting your diagram
    to image files, as well as data files that can be imported into dedicated diagramming
    tools.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Querying the data source using SQL
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Querying the database is probably the second most useful feature of having database
    tooling built right into the IDE. As with many of the features in PyCharm, this
    one ensures you never need to leave PyCharm to get your work done.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: There are several places that allow you to run queries. You can run ad hoc queries
    in a query console, or you can run queries directly from `.``sql` files.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc queries
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ad hoc queries are simply queries for an immediate purpose. An ad hoc query
    has a number of characteristics:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**Unplanned**: Ad hoc queries are not part of a predefined set of queries.
    They are written on the spot to address a particular need.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Temporary**: They are used to retrieve data for a specific task or situation
    and are not saved for future use. They aren’t part of your application, though
    after some experimentation and tweaking, you might formalize them in your code.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No optimization**: Ad hoc queries might not be optimized for efficiency,
    as they are quickly put together without the time for fine-tuning.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Variability**: The syntax and structure of ad hoc queries can vary depending
    on the user’s knowledge and experience.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not stored**: Unlike stored procedures or views, ad hoc queries are not stored
    in the database as with, say, a view or a stored procedure. This means they cannot
    be called or executed again later unless you save them to a file later.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ad hoc queries are executed in a database console. A console window appears
    automatically when you complete your connection to the data source, but there
    are many places in the interface where you can create a new console view. Look
    at *Figure 11**.34* and you’ll see the data source window. A button labeled **QL**,
    for **Query Language**, is circled. It doesn’t say *SQL* because, remember, PyCharm
    also supports NoSQL databases, such as MongoDB, Apache Cassandra, and Redis.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.34: Any place you see a QL icon like this you can launch a console
    window and query your data source using an ad hoc query](img/B19644_11_034.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.34: Any place you see a QL icon like this you can launch a console
    window and query your data source using an ad hoc query'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The **QL** button is sensitive to the database selected in the data source window,
    so if you have more than one data source, you can open a query source to any of
    them by selecting them in the data source window and then hitting the **QL** button.
    I actually closed the console that was automatically launched when I created the
    data source. To create a new console, I’ll hit the **QL** button and select **New
    Console**.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The first console you open becomes the **default console**. PyCharm keeps track
    of your consoles in the **Scratches and Consoles** folder, as shown in *Figure
    11**.35*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.35: PyCharm tracks consoles along with scratch files in a dedicated
    folder in the IDE](img/B19644_11_35.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.35: PyCharm tracks consoles along with scratch files in a dedicated
    folder in the IDE'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve typed any SQL in the console, PyCharm will keep the contents even
    between sessions. Empty consoles will disappear when you exit PyCharm. This is
    handy for keeping track of your ad hoc work.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Generating SQL statements
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to create some seed records, which will ultimately be saved as a seed
    script. A seed script is a script that can be used for testing an application
    by seeding the database with some initial test data. We’re moving away from the
    strictly DDL statements we’ve used so far. We’re going to be using more DML, which
    are the statements used to work with data rather than database structure. Seed
    scripts are also useful for filling in data tables with static data that rarely
    changes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to seed our `authors` table with a few records, but we’re going
    to have PyCharm generate a lot of the SQL for us. Begin by creating a console
    if you don’t have one open already. Right-click the `authors` table, hover over
    **SQL Scripts**, then find **Insert rows into a table**. Check out *Figure 11**.36*
    to see it in action.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: s
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.36: PyCharm will generate DML queries for you automatically!](img/B19644_11_36.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.36: PyCharm will generate DML queries for you automatically!'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Once you click the option, you’ll find an `insert` statement has been inserted
    (oh yes!) directly into the console. You can see mine in *Figure 11**.37*.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.37: PyCharm generated an insert statement for the table we selected](img/B19644_11_037.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.37: PyCharm generated an insert statement for the table we selected'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Note the bounding box around the text. We’ve seen this before. You’re looking
    at a template! This means we can tab from place to place in the templated text,
    which is why you shouldn’t mess with the text as I did.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Copy-paste warning!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: If you have an electronic copy of this book that allows you to copy and paste
    from the e-book itself, be careful with any code that relies on single quotation
    marks as the upcoming SQL statement does. The process of editing the book often
    turns them into special characters that won’t work when you paste them into a
    console. Make sure the single quotation marks are really single quotation marks!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '`insert` statements can be divided into two halves:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The halves I’m talking about are the parts of the statement that aren’t boilerplate
    – the parts in the two sets of parentheses. The first set specifies which fields
    you’ll be filling, and the second set is the values. You have to match the order
    and type of the fields in the first half when you type values for each field.
    If you hit the *Tab* key, you’ll move between the two halves of the `insert` statement,
    allowing you to modify it as you see fit.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Unconventional generated SQL
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm doesn’t generate SQL keywords in all caps by default, which is the normal
    convention. You might notice that statements that I type are all caps, but generated
    ones aren’t. I had to resist the temptation to fix that for the sake of the book,
    but I also need to explain why there are inconsistencies at play.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm generated a placeholder for the primary key, which is a field you wouldn’t
    normally populate since the database fills that in automatically. Go ahead and
    take that first field out of the field set in the first parentheses as I did in
    the preceding code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Next, tab over to the `values` section, and begin to fill in values. Remember,
    in SQL, `varchar (string)` values must be enclosed in single quotes. Python allows
    you to use either single or double quotes but SQL does not. As you type values,
    PyCharm will give you hints about the field you are matching for the value. It
    does this with a tooltip over the text in the editor, but it also color codes
    the current field in the top half of the statement. See *Figure 11**.38* to see
    what I mean.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.38: PyCharm gives tooltips for the field and type you are currently
    filling in the second half of the query](img/B19644_11_038.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.38: PyCharm gives tooltips for the field and type you are currently
    filling in the second half of the query'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: This is huge! How many times have you written a long `insert` statement only
    to find that you have more values than fields? Or worse, you discover you’ve transposed
    a few fields and you enter a bunch of garbage data by mistake? PyCharm gives you
    a visual indicator to make sure you know exactly which field you’re entering by
    showing you a tooltip with the field and type you are filling in. It also shades
    the field in the top half of the SQL statement.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Running the query
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You probably don’t need me to tell you this because, at this point, you’re probably
    used to seeing green run arrows where it is appropriate to run something. You
    can run the contents of the console by clicking the green arrow at the top of
    the console’s tab in the IDE. You can also highlight a section of the console’s
    contents and run a portion of the query.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the contents of your console to match this code:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All I did was copy the same SQL four times, then I changed the names for a little
    variety, and to give a shout-out to my Packt crew (holla!). Next, highlight the
    first statement and run the query. The **Services** panel will open to show the
    results of the query. As you can see in *Figure 11**.39*, only one record was
    inserted.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.39: You can execute single statements by selecting them and clicking
    the Run button](img/B19644_11_039.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.39: You can execute single statements by selecting them and clicking
    the Run button'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: If you select the remainder and run again, you’ll find three insertions.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have some data, let’s query with a `SELECT` statement. Add this
    code to your console:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I could have generated `select`, but this query is short. I wanted to show you
    how PyCharm displays the results. Take a look at *Figure 11**.40*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.40: By default, select statements produce a nice, tabular output](img/B19644_11_040.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.40: By default, select statements produce a nice, tabular output'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: This is a dense panel! You can do a lot here. By default, you see a tabular
    view of the data (**1**). You can double-click the cells and edit the data in
    place. You can also add and delete rows using this UI (**2**). After you’ve edited
    the data to your liking, you can submit your changes using the small green up
    arrow on the toolbar (**2**) in *Figure 11**.40*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: If you’d rather change the output view from tabular to either raw text or a
    tree view (which makes more sense for querying hierarchical data), you can click
    the eyeball icon in the toolbar (**2**) in *Figure 11**.41*.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Exporting query results
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can export the results of your `select` statements using the export button
    *Figure 11**.41*. *Figure 11**.41* shows what this looks like.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.41: Exporting data is easy in PyCharm](img/B19644_11_041.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.41: Exporting data is easy in PyCharm'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: The export format defaults to **comma-separated values** (**CSV**), which is
    a common format for tabular data exchange. PyCharm supports dozens of other useful
    formats, which you’ll find in the **Extractor** drop-down list. Change the output
    file to something you like, then click the **Export to** **file** button.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Working with SQL files
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm supports files with a `.sql` or `.ddl` file extension. Like other recognized
    file types, you’ll get auto-completion, syntax highlighting, and so on. You can
    also run statements directly in the SQL file just like we can in the console.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s immortalize our console work so far as a proper script. Create a new
    file in PyCharm called `seed.sql`. Next, add this line to the top of the script
    file:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `USE` statement is MySQL-specific and ensures you have the `database_fun`
    database selected prior to executing the SQL statements. The `TRUNCATE` statement
    will delete all the records in the `authors` table and reset the auto-incrementor
    sequence on the table back to its initial value. This is useful for development
    testing since now the seed script can reset to a clean set of testing values.
    Just be careful to never run the seed script in production!
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, cut and paste the contents of your console beneath the `TRUNCATE` statement.
    Note that I said cut. You want the console empty. The script should look like
    this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Save your seed script and run it. It should execute successfully.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have this terrible feeling that I haven’t covered everything. That’s because
    I didn’t. I could write a whole book just on the database features of PyCharm,
    but if I did, I might as well title it something like *Hands-On Database Programming
    with DataGrip*. Don’t forget, we’re seeing a whole other IDE crammed into the
    crevices of PyCharm much as we did with WebStorm in [*Chapter 7*](B19644_07.xhtml#_idTextAnchor172),
    *Web Development with JavaScript, HTML, and CSS*. The feature set is truly staggering
    and I didn’t cover some of the really interesting features owing to either lack
    of space in this book or because some of the really cool features are still works
    in progress.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can set code as a data source and synchronize the code to the
    structure of the database. At present, it isn’t 100% complete, which is why I
    left it out. As a database developer, I would expect to be able to have a round-trip
    experience where changes to the code are reflected in the database and changes
    to the database are copied back to the code. I think we’re well on our way.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: What we did cover, though, was pretty complete coverage for either full stack
    web development or a data science practitioner needing to tap multiple database
    platforms and data storage paradigms.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: We started out with a little history. I like covering the history in this and
    previous chapters because I have the advantage of a long career behind me. I was
    around for most of what I’m describing, and I had a front-row seat. I was in the
    first grade when E. F. Codd formalized relational algebra. Part of me wishes I
    could brag about using his early work, but in truth, I was a bigger fan of watching
    the Saturday morning TV show *Lassie and the Rescue Rangers* in my footy pajamas
    than I was of `SELECT` statements. When I was older, I got to work on IBM mainframes,
    so I did eventually catch up.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Moving into more practical matters, we learned that PyCharm, using separately
    installed JDBC drivers, can connect to dozens of different database platforms.
    We learned it supports not only relational databases but NoSQL as well. After
    we learned how to open the database tools and connect our data source, we learned
    how to design a database using a host of tools that generate DDL for us.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Then we moved on to using PyCharm to generate the DML that would power our work
    once we got some data in our tables. Finally, after working in a console to create
    our initial work, we saved our SQL into a `.``sql` file.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The positioning of this chapter in the book is very intentional. I’ve restrained
    myself from doing a lot of coding in the full stack frameworks we covered in the
    last few chapters. In real life, you would most assuredly have databases attached
    to such projects. While many developers rely on ORMs to handle the database work
    for them, it never hurts to at least be able to examine the database and its contents
    directly using a console.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: If you’re like me, and you forgo ORMs entirely, you now have the missing piece
    to the puzzle. You can create your database code using a marvelous set of tools
    without leaving PyCharm.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also offered a logical split as the next few chapters start coverage
    of PyCharm Professional’s power data science feature set. It only makes sense
    to preface that set of chapters with coverage of these most ubiquitous engines
    for data storage and retrieval.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll be turning on *science mode*! Go pick up your lab
    coat from the dry cleaners, grab yourself a big cup of C8H10N4O2, and I’ll see
    you in the next chapter!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Desktop installation instructions: [https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/).'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using KeePass in PyCharm: [https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html](https://www.jetbrains.com/help/pycharm/reference-ide-settings-password-safe.html).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Codd, E. F. (1983). A relational model of data for large shared data banks.
    *Communications of the ACM*, *26*(1), 64-69.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forta, B. (2013). *Sams teach yourself SQL in 10 minutes*. Pearson Education.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hernandez, M. J. (2013). *Database Design for Mere Mortals: A Hands-On Guide
    to Relational Database Design*. Pearson Education.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pettit, T. and Cossetino, S. (2022). *The MySQL Workshop*. Packt Publishing.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poulton, N. (2023). *Docker Deep Dive – 2nd Edition.* Packt Publishing.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Viescas, J. L. and Hernandez, M. J. (2014). *SQL Queries for Mere Mortals:
    A Hands-On Guide to Data Manipulation in SQL*. Pearson Education.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 4: Data Science with PyCharm'
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the previous part, this part of the book focuses on a specific application
    of Python programming, this time data analysis and data science. Readers will
    be able to use PyCharm and its features to efficiently work on their data science
    and scientific computing projects.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19644_12.xhtml#_idTextAnchor298), *Turning on Scientific Mode*'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19644_13.xhtml#_idTextAnchor318), *Dynamic Data Viewing with
    SciView and Jupyter*'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19644_14.xhtml#_idTextAnchor340), *Building a Data Pipeline
    in PyCharm*'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
