- en: Meet Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the exciting world of GUI programming with Tkinter. This chapter
    aims to get you acquainted with Tkinter, the built-in **Graphical User Interface**
    (**GUI**)library for all standard Python distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter (pronounced tea-kay-inter) is the Python interface to Tk, the GUI toolkit for Tcl/Tk.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tcl** (**Tool command language**), which is pronounced as tickle, is a popular scripting
    language in the domains of embedded applications, testing, prototyping, and GUI
    development. On the other hand, Tk is an open source, multiplatform widget toolkit
    that is used by many different languages to build GUI programs.'
  prefs: []
  type: TYPE_NORMAL
- en: The Tkinter interface is implemented as a Python module— `Tkinter.py` in Python
    2.x Versions and `tkinter/__init__.py` in Python 3.x Versions. If you look at
    the source code, Tkinter is just a wrapper around a C extension that uses the
    Tcl/Tk libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter is suitable for a wide variety of areas, ranging from small desktop
    applications to scientific modeling and research endeavors across various disciplines.
  prefs: []
  type: TYPE_NORMAL
- en: When a person learning Python needs to graduate to GUI programming, Tkinter seems
    to be the easiest and fastest way to get the work done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter is a great tool for the programming of GUI applications in Python. The
    features that make Tkinter a great choice for GUI programming include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It is simple to learn (simpler than any other GUI package for Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relatively little code can produce powerful GUI applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered design ensures that it is easy to grasp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is portable across all operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easily accessible, as it comes pre-installed with the standard Python
    distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of the other Python GUI toolkits have all of these features at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is to make you comfortable with Tkinter. It aims
    to introduce you to the various components of GUI programming with Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: We believe that the concepts that you will develop in this chapter will enable
    you to apply and develop GUI applications in your area of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key aspects that we want you to learn from this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concept of a root window and the main loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding widgets—the building blocks of programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting acquainted with a list of available widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing layouts by using different geometry managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying events and callbacks to make a program functional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling widgets by using styling options and configuring the root widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We assume a basic working knowledge of Python. You must know how to write and
    run basic programs in Python.
  prefs: []
  type: TYPE_NORMAL
- en: We will develop our application on the Linux Mint platform. However, since Tkinter
    is multiplatform, you can follow along with the instructions in this book on Windows, Mac,
    or any other Linux distribution, without making any modifications to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have developed several partly functional
    dummy applications, such as the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f78ea3b-9479-4dcc-bdfa-ddd657a00e16.png)'
  prefs: []
  type: TYPE_IMG
- en: We call these dummy applications because they are neither fully functional nor
    do they serve any practical purpose other than to show a particular feature of
    Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will write all our projects using Python Version 3.6.3, which is the latest
    *stable* release of Python at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: The Python download package and instructions for downloading for different platforms
    are available at [https://www.python.org/downloads/release/python-363/](https://www.python.org/downloads/release/python-363/).
  prefs: []
  type: TYPE_NORMAL
- en: The installer binaries for macOS X and the Windows platform are available at
    the aforementioned link.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along on Unix, Linux, or BSD, the following procedure will
    install Python from the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install `tk8.6-dev` and `python3-tk` packages on your computer using
    your applicable package manager. For instance, on Debian-based systems such as
    Ubuntu and Mint, run the following two commands from the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Download Python 3.6.3 from the preceding link and extract it to any location
    of your choice. Open a Terminal in the location where you extracted Python and
    type in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This should install Python 3.6.3 on your computer. Now open a command line
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open the Python 3.6 interactive shell. Type in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command should execute without any errors. If there are no error messages,
    the Tkinter module is installed on your Python distribution.
  prefs: []
  type: TYPE_NORMAL
- en: When working with examples from this book, we do not support any Python Version
    except for Python 3.6.3, which comes bundled with Tkinter Tcl/Tk Version 8.6\.
    However, most of the examples should work out-of-the-box on other minor Python
    3 Versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether you have the correct Tkinter Version on your Python installation, type
    the following commands in your IDLE or interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This should confirm the Tcl/Tk Version as 8.6\. We are now ready to build our
    GUI programs!
  prefs: []
  type: TYPE_NORMAL
- en: The next steps are optional and you may skip them at your discretion. While
    the preceding steps are sufficient for us to develop our programs, I highly recommend
    that you use a virtual environment for developing your programs.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments provide a secluded environment with no conflicts with system
    programs, and they can be easily reproduced on any other system.
  prefs: []
  type: TYPE_NORMAL
- en: So now let's set up a virtual environment. First, create a folder where you
    will keep all projects from this book. Let's call it `myTkinterProjects` or whatever
    suits you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, find the location of the Python 3.6 installation on your computer. On
    my computer, I can find the location of the Python installation by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a note of the location. For me it is `/usr/local/bin/python3.6`*. *Now
    open a Terminal in your `myTkinterProjects` folder and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new virtual environment in a folder named `myvenv` inside
    your project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we need to activate this virtual environment. This is done by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now if you type the command `python`, it should pick up Python 3.6.3 from within
    your virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: From now onward, every time we have to run a Python script or install a new
    module, we will first activatethe virtual environment using the preceding command
    and run or install the module within this new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: GUI programming – the big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a GUI programmer, you will generally be responsible for deciding the following three
    aspects of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: Which components should appear on the screen?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This involves choosing the components that make the user interface. Typical
    components include things such as buttons, entry fields, checkboxes, radio buttons,
    and scrollbars. In Tkinter, the components that you add to your GUI are called **widgets**. Widgets
    (short for window gadgets) are the graphical components that make up your application's
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Where should the components go?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This includes deciding the position and the structural layout of various components.
    In Tkinter, this is referred to as **geometry management**.
  prefs: []
  type: TYPE_NORMAL
- en: How do components interact and behave?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This involves adding functionality to each component. Each component or widget
    does something. For example, a button, when clicked on, does something in response.
    A scrollbar handles scrolling, and checkboxes and radio buttons enable users to
    make some choices. In Tkinter, the functionality of various widgets is managed
    by command binding or **event binding** using **callbacks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the three components of GUI programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7542b4be-76af-4fb3-ace5-2748a17594fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The root window – your drawing board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GUI programming is an art, and like all art you need a drawing board to capture your
    ideas. The drawing board that you will use is called the **root window**. Our
    first goal is to get the root window ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot depicts the root window that we are going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad6c9d55-193d-4989-8805-266a5c71321c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drawing the root window is easy. You just need the following three lines of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this with the `.py` file extension or check out the code present in the
    `1.01.py` file. Open it in the IDLE window or run it from within your activated
    virtual environment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running this program should generate a blank root window, as shown in the preceding
    screenshot. This window is equipped with functional minimize, maximize, and close
    buttons, and a blank frame.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the example code
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). Apart
    from going to Packt's official website, you can also find the code files for this
    book at [https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition](https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line imported the `tkinter` module into the namespace with `tk` as
    its alias. Now we can access all definitions of the classes, attributes, and methods
    of Tkinter by appending the alias tk to the name as in `tk.Tk()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line created an instance of the `tkinter.Tk` class. This created what
    is called the **root window**, which is shown in the preceding screenshot. According
    to the conventions, the root window in Tkinter is usually called **root**, but
    you are free to call it by any other name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line executed the `mainloop` (that is, the event loop) method of the root
    object. The `mainloop` method is what keeps the root window visible. If you remove
    the third line, the window created in line 2 will disappear immediately as soon
    as the script stops running. This will happen so fast that you will not even see
    the window appearing on your screen. Keeping the `mainloop` method running also
    lets you keep the program running until you press the Close button, which exits `mainloop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tkinter also exposed the `mainloop` method as `tkinter.mainloop()`. So, you can
    even call `mainloop()` directly instead of calling `root.mainloop()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Congratulations! You have completed your first objective, which was to draw
    the root window. You have now prepared your drawing board (root window). Now,
    get ready to paint it with your imagination!
  prefs: []
  type: TYPE_NORMAL
- en: Commit the three lines of code (shown in code `1.01.py`) to memory. These three
    lines generate your root window, which will accommodate all the other graphical
    components. These lines form the skeleton of any GUI application that you will
    develop in Tkinter. The entire code that will make your GUI application functional
    will go between line 2 (new object creation) and line 3 (`mainloop`) of this code.
  prefs: []
  type: TYPE_NORMAL
- en: Widgets – the building blocks of GUI programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our top level or the root window ready, it is time to think
    over the question: which components should appear in the window? In Tkinter jargon,
    these components are called **widgets**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax that is used to add a widget is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example ( `1.02.py` ), we will add two widgets, a label and
    a button, to the root container. Also, note how all the widgets are added between
    the skeleton code that we defined in the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code(`1.02.py`) will generate a window with a label and
    a button widget, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb8d5d9f-c921-4675-91f6-822f9f7a7f67.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: This code added a new instance named `label` for the label widget. The first
    parameter defined root as its parent or container. The second parameter configured
    its text option to read  `I am a label widget`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we defined an instance of a Button widget. This is also bound to
    the root window as its parent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `pack()` method, which is essentially required to position the label
    and button widgets within the window. We will discuss the `pack()` method and
    several other related concepts when exploring the geometry management task. However,
    you must note that some sort of geometry specification is essential for the widgets
    to be displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some important widget features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note the following few important features that are common to all widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: All widgets are actually objects derived from their respective widget classes. So,
    a statement such as `button = Button(its_parent)` actually creates a button instance
    from the `Button` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each widget has a set of options that decides its behavior and appearance. This
    includes attributes such as text labels, colors, and font size. For example, the
    Button widget has attributes to manage its label, control its size, change its
    foreground and background colors, change the size of the border, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To set these attributes, you can set the values directly at the time of creating
    the widget, as demonstrated in the preceding example. Alternatively, you can later
    set or change the options of the widget by using the `.config()` or `.configure()`
    method. Note that the `.config()` or `.configure()` methods are interchangeable
    and provide the same functionality. In fact, the `.config()` method is simply
    an alias of the `.configure()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to create widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two ways to create widgets in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way involves creating a widget in one line and then adding the `pack()` method
    (or other geometry managers) in the next line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can write both the lines together, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can either save a reference to the widget created ( `my_label`, as in the
    first example), or create a widget without keeping any reference to it (as demonstrated in
    the second example).
  prefs: []
  type: TYPE_NORMAL
- en: You should ideally keep a reference to the widget in case the widget has to
    be accessed later on in the program. For instance, this is useful in case you
    need to call one of its internal methods or for its content modification. If the
    widget state is supposed to remain static after its creation, you need not keep
    a reference to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that calls to `pack()` (or other geometry managers) always return `None`.
    So, consider a situation where you create a widget, and add a geometry manager
    (say, `pack()`) on the same line, as follows: `my_label = tk.Label(...).pack()`.
    In this case, you are not creating a reference to the widget. Instead, you are
    creating a `None` type object for the `my_label` variable. So, when you later
    try to modify the widget through the reference, you get an error because you are
    actually trying to work on a `None` type object. If you need a reference to a
    widget, you must create it on one line and then specify its geometry (like `pack()`)
    on the second line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_label = tk.Label(...)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`my_label.pack()`'
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the most common mistakes committed by beginners.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the core Tkinter widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you will get to know all the core Tkinter widgets. You have already seen
    two of them in the previous example—the Label and Button widgets. Now, let's explore
    all the other core Tkinter widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter includes 21 core widgets, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Top-level** | **Label** | **Button** |'
  prefs: []
  type: TYPE_TB
- en: '| Canvas | Checkbutton | Entry |'
  prefs: []
  type: TYPE_TB
- en: '| Frame | LabelFrame | Listbox |'
  prefs: []
  type: TYPE_TB
- en: '| Menu | Menubutton | Message |'
  prefs: []
  type: TYPE_TB
- en: '| OptionMenu | PanedWindow | Radiobutton |'
  prefs: []
  type: TYPE_TB
- en: '| Scale | Scrollbar | Spinbox |'
  prefs: []
  type: TYPE_TB
- en: '| Text | Bitmap | Image |'
  prefs: []
  type: TYPE_TB
- en: Let's write a program to display all of these widgets in the root window.
  prefs: []
  type: TYPE_NORMAL
- en: Adding widgets to a parent window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The format used to add widgets is the same as the one that we discussed in
    the previous task. To give you an idea about how it''s done, here''s some sample
    code that adds some common widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the pattern that is common to each widget? Can you spot the differences?
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, the syntax for adding a widget is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same pattern, let''s add all the 21 core Tkinter widgets into a dummy application
    (`1.03.py`). We do not reproduce the entire code here. A summarized code description
    for `1.03.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a top-level window and a `mainloop`, as shown in the earlier examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add a frame widget and name it `menu_bar`. Note that frame widgets are just
    holder widgets that hold other widgets. Frame widgets are great for grouping widgets
    together. The syntax for adding a frame is the same as that for all the other
    widgets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Keeping the `menu_bar` frame as the container, we add two widgets to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Menubutton
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create another frame widget and name it `frame`. Keeping `frame` as the
    container/parent widget, we add the following seven widgets to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Label
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Entry
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Button
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkbutton
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Radiobutton
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: OptionMenu
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bitmap` Class'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then proceed to create another frame widget. We add six more widgets to
    the frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Image` Class'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Listbox
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Spinbox
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scale
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: LabelFrame
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Message
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We then create another frame widget. We add two more widgets to the frame:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrollbar
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We create another frame widget and add two more widgets to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PanedWindow
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These constitute the 21 core widgets of Tkinter. Now that you have had a glimpse
    of all the widgets, let's discuss how to specify the location of these widgets
    using geometry managers.
  prefs: []
  type: TYPE_NORMAL
- en: The Tkinter geometry manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may recall that we used the `pack()` method to add widgets to the dummy
    application that we developed in the previous section. The `pack()` method is
    an example of geometry management in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: The `pack()` method is not the only way of managing the geometry in your interface. In
    fact, there are three geometry managers in Tkinter that let you specify the position of
    widgets inside a top-level or parent window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three geometry managers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pack**: This is the one that we have used so far. It is simple to use for
    simpler layouts, but it may get very complex for slightly complex layouts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**grid**: This is the most commonly used geometry manager, and provides a table-like
    layout of management features for easy layout management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**place**: This is the least popular, but it provides the best control for
    the absolute positioning of widgets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's have a look at some examples of all the three geometry managers in
    action.
  prefs: []
  type: TYPE_NORMAL
- en: The pack geometry manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pack manager can be a bit tricky to explain in words, and it can best be understood
    by playing with the code base. Fredrik Lundh, the author of Tkinter, asks us to
    imagine the root as an elastic sheet with a small opening at the center. The pack geometry
    manager makes a hole in the elastic sheet that is just large enough to hold the
    widget. The widget is placed along a given inner edge of the gap (the default
    is the top edge). It then repeats the process till all the widgets are accommodated.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when all the widgets have been packed in the elastic sheet, the geometry manager
    calculates the bounding box for all the widgets. It then makes the parent widget
    large enough to hold all the child widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'When packing child widgets, the pack manager distinguishes between the following
    three kinds of space:'
  prefs: []
  type: TYPE_NORMAL
- en: Unclaimed space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Claimed but unused space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Claimed and used space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most commonly used options in pack include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`side`: `LEFT`, `TOP`, `RIGHT`, and BOTTOM (these decide the alignment of the
    widget)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fill`: X, Y, BOTH, and NONE (these decide whether the widget can grow in size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expand`: Boolean values such as `tkinter.YES`/`tkinter.NO`, `1` / `0`, and
    `True`/`False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor`: NW, N, `NE`, `E`, `SE`, S, SW, `W`, and CENTER (corresponding to
    the cardinal directions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal padding ( `ipadx` and `ipady` ) for the padding inside widgets and external
    padding ( `padx` and `pady` ), which all default to a value of zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at demo code that illustrates some of the pack features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two of the most commonly used pack options are `fill` and `expand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7e36bba-503c-4e0b-9826-8f82f51f42a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code *(*`1.04.py`*)* generates a GUI like the one shown in the
    preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: When you insert the `A` button in the root frame, it captures the leftmost area of
    the frame, expands, and fills the `Y` dimension. Because the fill option is specified
    as `fill=tk.Y`, it claims all the area that it wants and fills the `Y` dimension
    of its container frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because frame is itself packed with a plain `pack()` method with no mention of
    a pack option, it takes the minimum space required to accommodate all of its child
    widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you increase the size of the root window by pulling it down or sideways, you
    will see that all the buttons within the frame do not fill or expand with the
    root window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The positioning of the `B`, `C`, and `D` buttons occurs on the basis of the
    side and fill options specified for each of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three buttons (after `B`, `C`, and `D`) demonstrate the use of the
    expand option. A value of `expand=1` means that the button moves its place on resizing
    the window. Buttons with no explicit expand options stay in their place and do
    not respond to changes in the size of their parent container (the root window,
    in this case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best way to study this piece of code would be to resize the root window to
    see the effect that it has on various buttons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `anchor` attribute (not used in the preceding code) provides a means to position
    a widget relative to a reference point. If the `anchor` attribute is not specified,
    the pack manager places the widget at the center of the available space or the
    packing box. The other options that are allowed include the four cardinal directions
    (N, S, `E`, and `W`) and a combination of any two directions. Therefore, valid
    values for the `anchor` attribute are `CENTER` (the default value), N, S, E, `W`,
    NW, `NE`, SW, and `SE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The values for most Tkinter geometry manager attributes can either be specified
    in capital letters without quotes (such as `side=tk.TOP `and `anchor=tk.SE`) or
    in small letters within quotes (such as `side='top'`and `anchor='se'`).
  prefs: []
  type: TYPE_NORMAL
- en: We will use the pack geometry manager in some of our projects. Therefore, it
    will be worthwhile to get acquainted with pack and its options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pack manager is ideally suited for the following two kinds of situation:'
  prefs: []
  type: TYPE_NORMAL
- en: Placing widgets in a top-down manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing widgets side by side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.05.py` shows an example of both of these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code produces a GUI, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34000aa1-485f-43f3-ae57-9dce5eabbcc3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a complete pack reference, type the following command in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Besides getting interactive help with documentation, Python's REPL is also a
    great tool for iterating and quick prototyping of Tkinter programs.
  prefs: []
  type: TYPE_NORMAL
- en: Where should you use the pack() geometry manager?
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the pack manager is somewhat complicated as compared to the `grid` method,
    which will be discussed next, but it is a great choice in situations such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Having a widget fill the complete container frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing several widgets on top of each other or side by side (as shown in the
    preceding screenshot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although you can create complicated layouts by nesting widgets in multiple frames,
    you will find the grid geometry manager more suitable for most complex layouts.
  prefs: []
  type: TYPE_NORMAL
- en: The grid geometry manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The grid geometry manager is easy to understand and perhaps the most useful
    geometry manager in Tkinter. The central idea of the grid geometry manager is
    to organize the container frame into a two-dimensional table that is divided into
    a number of rows and columns. Each cell in the table can then be targeted to hold
    a widget. In this context, a cell is an intersection of imaginary rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Note that in the `grid` method, each cell can hold only one widget. However,
    widgets can be made to span multiple cells.
  prefs: []
  type: TYPE_NORMAL
- en: Within each cell, you can further align the position of the widget using the
    sticky option. The sticky option decides how the widget is expanded. If its container
    cell is larger than the size of the widget that it contains, the sticky option
    can be specified using one or more of the N, S, `E`, and `W` options or the NW,
    `NE`, SW, and `SE` options.
  prefs: []
  type: TYPE_NORMAL
- en: Not specifying stickiness defaults stickiness to the center of the widget in
    the cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at demo code that illustrates some features of the grid geometry
    manager. The code in `1.06.py` generates a GUI, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ea6ee20-8e4a-4a32-bce6-cb95f6816f82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code (`1.06.py`) generates the preceding GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the grid position defined in terms of the row and column positions
    for an imaginary grid table spanning the entire frame. See how the use of `sticky=tk.W`
    on both the labels makes them stick on the left-hand side, thus resulting in a
    clean layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The width of each column (or the height of each row) is automatically decided
    by the height or width of the widgets in the cell. Therefore, you need not worry
    about specifying the row or column width as equal. You can specify the width for
    widgets if you need that extra bit of control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `sticky=tk.NSEW` argument to make the widget expandable and fill
    the entire cell of the grid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a more complex scenario, your widgets may span across multiple cells in the
    grid. To make a grid to span multiple cells, the `grid` method offers handy options
    such as `rowspan` and `columnspan`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, you may often need to provide some padding between cells in the grid.
    The grid manager provides the `padx` and `pady` options to provide padding that
    needs to be placed around a widget.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `ipadx` and `ipady` options are used for internal padding. These
    options add padding within the widget itself. The default value of external and
    internal padding is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at an example of the grid manager, where we use most of the common
    arguments to the grid method, such as `row`, `column`, `padx`, `pady`, `rowspan`,
    and `columnspan`.
  prefs: []
  type: TYPE_NORMAL
- en: '`1.07.py` produces a GUI, as shown in the following screenshot, to demonstrate how
    to use the grid geometry manager options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d819f6d9-ae50-4602-bd32-95640349200c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code ( `1.07.py` ) generates the preceding GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note how just 14 lines of the core grid manager code generate a complex layout such
    as the one shown in the preceding screenshot. On the other hand, developing this
    with the pack manager would have been much more tedious.
  prefs: []
  type: TYPE_NORMAL
- en: Another grid option that you can sometimes use is the `widget.grid_forget()` method.
    This method can be used to hide a widget from the screen. When you use this option,
    the widget still exists at its former location, but it becomes invisible. The
    hidden widget may be made visible again, but the grid options that you originally
    assigned to the widget will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there is a `widget.grid_remove()` method that removes the widget,
    except that in this case, when you make the widget visible again, all of its grid
    options will be restored.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete grid reference, type the following command in the Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Where should you use the grid geometry manager?
  prefs: []
  type: TYPE_NORMAL
- en: The grid manager is a great tool for the development of complex layouts. Complex
    structures can be easily achieved by breaking the container widget into grids
    of rows and columns and then placing the widgets in grids where they are wanted.
    It is also commonly used to develop different kinds of dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will delve into configuring a grid's column and row sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Different widgets have different heights and widths. So, when you specify the position
    of a widget in terms of rows and columns, the cell automatically expands to accommodate
    the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the height of all the grid rows is automatically adjusted so it's
    the height of its tallest cell. Similarly, the width of all the grid columns is
    adjusted so it's equal to the width of the widest widget cell.
  prefs: []
  type: TYPE_NORMAL
- en: If you then want a smaller widget to fill a larger cell or to stay on any one
    side of the cell, you can use the sticky attribute on the widget to control this
    aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can override this automatic sizing of columns and rows by using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Use these to configure the options for a given widget, `w`, in either the *n*^(th) column
    or the *n*^(th) row, specifying values for the options, minsize, pad, and weight.
    Note that the numbering of rows begins from `0` and not `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options available are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Options** | **Descriptions** |'
  prefs: []
  type: TYPE_TB
- en: '| minsize | This is the minimum size of a column or row in pixels. If there
    is no widget in a given column or row, the cell does not appear in spite of this minsize
    specification. |'
  prefs: []
  type: TYPE_TB
- en: '| pad | This is the external padding in pixels that will be added to the specified column
    or row over the size of the largest cell. |'
  prefs: []
  type: TYPE_TB
- en: '| weight | This specifies the relative weight of a row or column and then distributes
    the extra space. This enables making the row or column stretchable.For example,
    the following code distributes two-fifths of the extra space to the first column
    and three-fifths to the second column: `w.columnconfigure(0, weight=2)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`w.columnconfigure(1, weight=3)` |'
  prefs: []
  type: TYPE_NORMAL
- en: The `columnconfigure()` and `rowconfigure()` methods are often used to implement the
    dynamic resizing of widgets, especially on resizing the root window.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use the `grid` and `pack` methods together in the same container
    window. If you try doing that, your program will raise a `_tkinter.TclError` error.
  prefs: []
  type: TYPE_NORMAL
- en: The place geometry manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The place geometry manager is the most rarely used geometry manager in Tkinter. Nevertheless,
    it has its uses in that it lets you precisely position widgets within their parent
    frame by using the (*x*,*y*) coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: The place manager can be accessed by using the `place()` method on any standard
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important options for place geometry include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute positioning (specified in terms of *x*=*N* or *y*=*N*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relative positioning (the key options include `relx`, `rely`, `relwidth`, and
    `relheight`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other options that are commonly used with place include `width` and `anchor`(the
    default is NW).
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to `1.08.py` for a demonstration of common place options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You may not see much of a difference between the absolute and relative positions simply
    by looking at the code or the window frame. However, if you try resizing the window,
    you will observe that the Absolute Placement button does not change its coordinates, while
    the Relative button changes its coordinates and size to accommodate the new size
    of the root window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb110351-f255-4945-8e08-384c44f9a116.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a complete `place` reference, type the following command in the Python
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When should you use the place manager?
  prefs: []
  type: TYPE_NORMAL
- en: The place manager is useful in situations where you have to implement custom
    geometry managers, or where the widget placement is decided by the end user.
  prefs: []
  type: TYPE_NORMAL
- en: While the pack and grid managers cannot be used together in the same frame,
    the place manager can be used with any geometry manager within the same container
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: The place manager is rarely used because, if you use it, you have to worry about the
    exact coordinates. If you make a minor change to a widget, it is very likely that you
    will have to change the *x*,*y* values for other widgets as well, which can be very
    cumbersome. We will use the place manager in [Chapter 7](d70da161-121d-453a-806b-95b71524fb79.xhtml)*,
    Piano Tutor*.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion on geometry management in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you had a look at how to implement the pack, grid, and place geometry
    managers. You also understood the strengths and weaknesses of each geometry manager.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that pack is suitable for a simple side-wise or top-down widget placement.
    You also learned that the grid manager is best suited for the handling of complex
    layouts. You saw examples of the place geometry manager and explored the reasons
    behind why it is rarely used.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to plan and execute different layouts for your programs using
    these Tkinter geometry managers.
  prefs: []
  type: TYPE_NORMAL
- en: Events and callbacks – adding life to programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned how to add widgets to a screen and position them where you
    want, let's turn our attention to the third component of GUI programming.
  prefs: []
  type: TYPE_NORMAL
- en: This addresses the question of how to make widgets functional.
  prefs: []
  type: TYPE_NORMAL
- en: Making widgets functional involves making them responsive to events such as
    the pressing of buttons, the pressing of keys on a keyboard, and mouse clicks.
  prefs: []
  type: TYPE_NORMAL
- en: This requires associating callbacks with specific events. Callbacks are normally
    associated with specific widget events using command binding rules, which are
    discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Command binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest way to add functionality to a button is called **command binding**, whereby
    a callback function is mentioned in the form of `command = some_callback` in the
    widget option. Note that the `command` option is available only for a few selected
    widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining the preceding callback, we can connect it to, say, a button
    with the `command` option referring to the callback, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A **callback** is a function memory reference ( `my_callback` in the preceding
    example) that is called by another function (which is `Button` in the preceding
    example) and that takes the first function as a parameter. Put simply, a callback
    is a function that you provide to another function so that it can calling it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `my_callback` is passed without parentheses, `()`, from within the
    widget `command` option, because when the callback functions are set it is necessary
    to pass a reference to a function rather than actually call it.
  prefs: []
  type: TYPE_NORMAL
- en: If you add parentheses, `()`, as you would for any normal function, it would
    be called as soon as the program runs. In contrast, the callback is called only
    when an event occurs (the pressing of a button in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to callbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If a callback does not take any argument, it can be handled with a simple function, such
    as the one shown in the preceding code. However, if a callback needs to take arguments,
    we can use the `lambda` function, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, somewhere else in the code, we define a button with a command callback that
    takes some arguments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Python borrows a specific syntax from functional programming, called the `lambda`
    function.  The `lambda` function lets you define a single-line, nameless function
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for using `lambda` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can call the `square` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Limitations of the command option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `command` option that is available with the Button widget and a few other
    widgets is a function that can make the programming of a click-of-a-button event
    easy. Many other widgets do not provide an equivalent command binding option.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the command button binds to the left-click and the spacebar. It
    does not bind to the *Return* key. Therefore, if you bind a button by using the
    `command` function, it will react to the space bar and not the *Return* key. This
    is counter-intuitive for many users. What's worse is that you cannot change the
    binding of the command function easily. The moral is that command binding, though
    a very handy tool, is not flexible enough when it comes to deciding your own bindings.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to the next method for handling events.
  prefs: []
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fortunately, Tkinter provides an alternative event binding mechanism called
    `bind()` to let you deal with different events. The standard syntax used to bind
    an event is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: When an event corresponding to the event description occurs in the widget, it
    calls not only the associated handler, which passes an instance of the event object
    as the argument, but also the details of the event. If there already exists a
    binding for that event for this widget, the old callback is usually replaced with
    the new handler, but you can trigger both the callbacks by passing `add='+'` as
    the last argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of the `bind()` method (code `1.09.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We bind the Frame widget to the `<Button-1>` event, which corresponds to the
    left-click. When this event occurs, it calls the `callback` function, passing an
    object instance as its argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the `callback(event)` function. Note that it takes the `event` object generated
    by the event as an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We inspect the event object by using `dir(event)`, which returns a sorted list
    of attribute names for the event object passed to it. This prints the following
    list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: From the attributes list generated by the object, we use two attributes, `event.x`
    and `event.y`, to print the coordinates of the point of click.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you run the preceding code (code `1.09.py` ), it produces a window, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c500d3b-1712-46dd-b3ca-8e72a994dbc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you left-click anywhere in the yellow colored frame within the root window, it
    outputs messages to the console. A sample message passed to the console is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Event patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, you learned how to use the `<Button-1>` event to denote
    a left-click. This is a built-in pattern in Tkinter that maps it to a left-click
    event. Tkinter has an exhaustive mapping scheme that perfectly identifies events
    such as this one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples to give you an idea of event patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **The event pattern** | **The associated event** |'
  prefs: []
  type: TYPE_TB
- en: '| `<Button-1>` | Left-click of the mouse |'
  prefs: []
  type: TYPE_TB
- en: '| `<KeyPress-B>` |  A keyboard press of the *B* key |'
  prefs: []
  type: TYPE_TB
- en: '| `<Alt-Control-KeyPress- KP_Delete>` | A keyboard press of *Alt* + *Ctrl*
    + *Del* |'
  prefs: []
  type: TYPE_TB
- en: 'In general, the mapping pattern takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, an event pattern will comprise the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An event type**: Some common event types include `Button`, `ButtonRelease`, `KeyRelease`,
    `Keypress`, `FocusIn`, `FocusOut`, `Leave` (when the mouse leaves the widget),
    and `MouseWheel`. For a complete list of event types, refer to the `event` types
    section at [http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An event modifier** (optional): Some common event modifiers include `Alt`, `Any`
    (used like `<Any-KeyPress>`), `Control`, `Double` (used like `<Double-Button-1>`
    to denote a double-click of the left mouse button), `Lock`, and `Shift`. For a
    complete list of event modifiers, refer to the `event modifiers`section at [http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The event detail** (optional): The mouse event detail is captured by the number
    1 for a left-click and the number 2 for a right-click. Similarly, each key press
    on the keyboard is either represented by the key letter itself (say, *B* in `<KeyPress-B>`)
    or by using a key symbol abbreviated as `keysym`. For example, the up arrow key
    on the keyboard is represented by the `keysym` value of `KP_Up`. For a complete
    `keysym` mapping, refer to [https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a practical example of event binding on widgets (refer
    to code `1.10.py` for the complete working example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0de95f4d-c377-4f3e-acc0-a22c06c0cda7.png)'
  prefs: []
  type: TYPE_IMG
- en: The following is a modified snippet of code; it will give you an idea of commonly
  prefs: []
  type: TYPE_NORMAL
- en: 'used event bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Rather than binding an event to a particular widget, you can also bind it to
    the top-level window. The syntax remains the same except that now you call it
    on the root instance of the root window such as `root.bind()`.
  prefs: []
  type: TYPE_NORMAL
- en: Binding levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you had a look at how to bind an event to an instance
    of a widget. This can be called an **instance-level binding**.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there may be times when you need to bind events to an entire application. At
    times, you may want to bind an event to a particular class of widget. Tkinter provides
    the following levels of binding options for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application-level binding**: Application-level bindings let you use the same binding
    across all windows and widgets of an application as long as any one window of
    the application is in focus. The syntax for application-level bindings is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The typical usage pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Application-level binding here means that, irrespective of the widget that is
    currently under focus, pressing the *F1* key will always trigger the `show_help`
    callback as long as the application is in focus.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class-level binding**: You can also bind events at a particular class level. This
    is normally used to set the same behavior for all instances of a particular widget
    class. The syntax for class-level binding is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The typical usage pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, all the entry widgets will be bound to the `<Control-V>`
    event, which will call a method named `paste` (event).
  prefs: []
  type: TYPE_NORMAL
- en: Event propagation
  prefs: []
  type: TYPE_NORMAL
- en: Most keyboard and mouse events occur at the operating system level. The event
    propagates hierarchically upward from its source until it finds a window that
    has the corresponding binding. The event propagation does not stop there. It propagates
    itself upwards, looking for other bindings from other widgets, until it reaches
    the root window. If it does reach the root window and no bindings are discovered
    by it, the event is disregarded.
  prefs: []
  type: TYPE_NORMAL
- en: Handling widget-specific variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need variables with a wide variety of widgets. You likely need a string
    variable to track what the user enters into the entry widget or text widget. You
    most probably need Boolean variables to track whether the user has checked off
    the Checkbox widget. You need integer variables to track the value entered in
    a Spinbox or Slider widget.
  prefs: []
  type: TYPE_NORMAL
- en: In order to respond to changes in widget-specific variables, Tkinter offers
    its own `variable` class. The variable that you can use to track widget-specific
    values must be subclassed from this Tkinter `variable` class. Tkinter offers some
    commonly used predefined variables. They are `StringVar`, `IntVar`, `BooleanVar`,
    and `DoubleVar`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use these variables to capture and play with the changes in the values
    of variables from within your callback functions. You can also define your own
    variable type, if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Tkinter variable is simple. You simply have to call the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the variable is created, you can use it as a widget option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, Tkinter provides access to the values of variables via the `set()`
    and `get()` methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A demonstration of the Tkinter `variable` class is available in the `1.11.py`
    code file. The code generates a window, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35173189-b313-4e3b-9e89-2ca39d7eafeb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This concludes our brief discussion on events and callbacks. Here''s a brief
    summary of the things that we discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: Command binding, which is used to bind simple widgets to certain functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event binding using the `widget.bind_all`(`event`, `callback`, `add=None`) method
    to bind keyboard and mouse events to your widgets and invoke callbacks when certain
    events occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The passing of extra arguments to a callback using the `lambda` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binding of events to an entire application or to a particular class of widget
    by using `bind_all()` and `bind_class()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Tkinter `variable` class to set and get the values of widget-specific
    variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, you now know how to make your GUI program responsive to end-user requests!
  prefs: []
  type: TYPE_NORMAL
- en: Event unbinding and virtual events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the bind method that you previously saw, you might find the following
    two event-related options useful in certain cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unbind:** Tkinter provides the unbind option to undo the effect of an earlier binding.
    The syntax is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some examples of its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '**Virtual events**: Tkinter also lets you create your own events. You can give these
    virtual events any name that you want. For example, let''s suppose that you want
    to create a new event called `<<commit>>`, which is triggered by the *F9* key.
    To create this virtual event on a given widget, use the following syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then bind `<<commit>>` to a callback by using a normal `bind()` method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Other event-related methods can be accessed by typing the following line in
    the Python Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now that you are ready to delve into real application development with Tkinter,
    let's spend some time exploring a few custom styling options that Tkinter offers.
    We will also have a look at some configuration options that are commonly used
    with the root window.
  prefs: []
  type: TYPE_NORMAL
- en: Doing it in style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have relied on Tkinter to provide specific platform-based styling
    for our widgets. However, you can specify your own styling of widgets, such as
    their color, font size, border width, and relief. A brief introduction to styling
    features that are available in Tkinter is supplied in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may recall that we can specify widget options at the time of its instantiation, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can specify the widget options by using `configure()` in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Styling options are also specified as options to the widgets either at the time
    of creating the widgets, or later by using the `configure` option.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the purview of styling, we will cover how to apply different colors, fonts, border
    widths, reliefs, cursors, and bitmap icons to widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how to specify the color options for a widget. You can specify
    the following two types of color for most widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: The background color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The foreground color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify the color by using hexadecimal color codes for the proportion
    of red(*r*), green(*g*), and blue(*b*). The commonly used representations are
    `#rgb` (4 bits), `#rrggbb` (8 bits), and `#rrrgggbbb` (12 bits).
  prefs: []
  type: TYPE_NORMAL
- en: For example, `#fff` is white, `#000000` is black, `#f00` is red (R=`0xf`, G=`0x0`
    , B=`0x0` ), `#00ff00` is green (R=`0x00`, G=`0xff`, B=`0x00`), and `#000000fff`
    is blue (R=`0x000` , G=`0x000` , B=`0xfff` ).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, Tkinter provides mapping for standard color names. For a list
    of predefined named colors, visit [http://wiki.tcl.tk/37701](http://wiki.tcl.tk/37701)
    or [http://wiki.tcl.tk/16166](http://wiki.tcl.tk/16166).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s have a look at how to specify fonts for our widgets. A font can
    be represented as a string by using the following string signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The elements of the preceding syntax can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`font family`: This is the complete font family long name. It should preferably
    be in lowercase, such as `font="{nimbus roman} 36 bold italic"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fontsize`: This is in the printer''s point unit (`pt`) or pixel unit (`px`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fontstyle`: This is a mix of normal/bold/italic and underline/overstrike.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are examples that illustrate the method of specifying fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If you set a Tkinter dimension in a plain integer, the measurements take place
    in pixel units. Alternatively, Tkinter accepts four other measurement units, which
    are `m`(millimeters), `c`(centimeters), `i`(inches), and `p`(printer's points,
    which are about 1/72").
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you want to specify the wrap length of a button in terms of
    a printer''s point, you can specify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The default border width for most Tkinter widgets is *2* px. You can change
    the border width for widgets by specifying it explicitly, as shown in the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The relief style of a widget refers to the difference between the highest and
    lowest elevations in a widget. Tkinter offers six possible relief styles—`flat`,
    `raised`, `sunken`, `groove`, `solid`, and `ridge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Tkinter lets you change the style of the mouse cursor when you hover over a particular
    widget. This is done by using the option cursor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For a complete list of available cursors, refer to [https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'Though you can specify the styling options at each widget level, sometimes
    it may be cumbersome to do so individually for each widget. Widget-specific styling
    has the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It mixes logic and presentation into one file, making the code bulky and difficult
    to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any change in styling has to be applied to each widget individually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It violates the don't repeat yourself (DRY) principle of effective coding, as
    you keep specifying the same style for a large number of widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortunately, Tkinter now offers a way to separate presentation from logic and
    specify styles in what is called the **external option database**. This is just
    a text file where you can specify common styling options.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical option database text file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In its simplest use, the asterisk (`*****`) symbol here means that the particular
    style is applied to all the instances of the given widget. For a more complex
    usage of the asterisk in styling, refer to [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'These entries are placed in an external text (`.txt`) file. To apply this styling
    to a particular piece of code, you can simply call it by using the `option_readfile()`call
    early in your code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at an example (see code `1.12.py` ) of using this external
    styling text file in a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The code connects to an external styling file called `optionDB.txt` that defines
    common styling for the widgets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next segment of code creates a Text widget and specifies styling on the widget
    level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next segment of code has several buttons, all of which derive their styling
    from the centralized `optionDB.txt` file. One of the buttons also defines a custom
    cursor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifying attributes such as font sizes, the border width, the widget width,
    the widget height, and padding in absolute numbers, as we have done in the preceding example,
    can cause some display variations between different operating systems such as
    Ubuntu, Windows, and Mac respectively, as shown in the following screenshot. This
    is due to differences in the rendering engines of different operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a6b31ec-8904-4a4a-ab9d-fad2dcd75293.png)'
  prefs: []
  type: TYPE_IMG
- en: When deploying cross-platform, it is better to avoid specifying attribute sizes
    in absolute numbers. It is often the best choice to let the platform handle the
    attribute sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Some common root window options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are done discussing styling options, let''s wrap up with a discussion
    on some commonly used options for the root window:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method**  | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `*root.geometry(''142x280+150+200'')` | You can specify the size and location
    ofa root window by using a string of the`widthxheight` + `xoffset` + `yoffset`
    form. |'
  prefs: []
  type: TYPE_TB
- en: '| `self.root.wm_iconbitmap(''mynewicon.ico'')` OR`self.root.iconbitmap(''mynewicon.ico
    '')` | This changes the title bar icon to somethingthat is different from the
    default Tk icon. |'
  prefs: []
  type: TYPE_TB
- en: '| `root.overrideredirect(1)` | This removes the root border frame. It hides
    the frame that contains the minimize,'
  prefs: []
  type: TYPE_NORMAL
- en: maximize, and close buttons. |
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain these styling options in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root.geometry(''142x280+150+200'')`: Specifying the geometry of the root window
    limits the launch size of the root window. If the widgets do not fit in the specified
    size, they get clipped from the window. It is often better not to specify this
    and let Tkinter decide this for you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`self.root.wm_iconbitmap(''my_icon.ico'')` or `self.root.iconbitmap(''my_icon.ico
    '')`: This option is only applicable to Windows. Unix-based operating systems
    do not display the title bar icon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting interactive help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section applies not only for Tkinter, but also for any Python object for
    which you may need help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you need a reference to the Tkinter pack geometry manager.
    You can get interactive help in your Python interactive shell by using the help
    command, as shown in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This provides detailed help documentation of all the methods defined under the `Pack`
    class in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can similarly receive help for all the other individual widgets. For instance,
    you can check the comprehensive and authoritative help documentation for the Label widget
    in the interactive shell by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides a list of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All the methods defined in the `Label` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the standard and widget-specific options for the `Label` widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the methods inherited from other classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when in doubt regarding a method, look into the source code of Tkinter, which
    is located at `<location-of-python-installation>\lib\`. For instance, the Tkinter
    source code is located in the `/usr/lib/python3.6.3/tkinter` directory on my Linux
    Mint operating system. You might also find it useful to look at the source code
    implementation of various other modules, such as the `color chooser`, `file dialogs`,
    and `ttk` modules, and the other modules located in the aforementioned directory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This brings us to end of this chapter. This chapter aimed to provide a high-level
    overview of Tkinter. We worked our way through all the important concepts that
    drive a Tkinter program.
  prefs: []
  type: TYPE_NORMAL
- en: You now know what a root window is and how to set it up. You also know the 21
    core Tkinter widgets and how to set them up. We also had a look at how to lay out
    our programs by using the `Pack`, `Grid`, and `Place` geometry managers, and how
    to make our programs functional by using `events` and `callbacks`. Finally, you
    saw how to apply custom styles to GUI programs.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we can now start thinking about making interesting, functional,
    and stylish GUI programs with Tkinter! In the next chapter, we will build our
    first real application - a Text editor.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you proceed to the next chapter, make sure you can answer these questions
    to your satisfaction:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a root window?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the main loop?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you create a root window?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are widgets? How do you create widgets in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you list or identify all available widgets in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are geometry managers used for?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you name all the available geometry managers in Tkinter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are events in a GUI program?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are callbacks? How are callbacks different from regular functions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you apply callbacks to an event?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you style widgets using styling options?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the common configuration options for the root window?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be a good idea to modify the examples from this chapter to lay out
    the widgets in different ways or to tweak the code to function in other ways to
    get your feet wet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We recommend that you take a look at the documentation for all three geometry
    managers in your Python shell using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can also find an excellent documentation of Tkinter at [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html).
  prefs: []
  type: TYPE_NORMAL
