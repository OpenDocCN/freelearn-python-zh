- en: Meet Tkinter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认识 Tkinter
- en: Welcome to the exciting world of GUI programming with Tkinter. This chapter
    aims to get you acquainted with Tkinter, the built-in **Graphical User Interface**
    (**GUI**)library for all standard Python distributions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到使用Tkinter进行GUI编程的激动人心世界。本章旨在让您熟悉Tkinter，这是所有标准Python发行版内置的**图形用户界面**（**GUI**）库。
- en: Tkinter (pronounced tea-kay-inter) is the Python interface to Tk, the GUI toolkit for Tcl/Tk.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter（发音为tea-kay-inter）是Python对Tk的接口，Tk是Tcl/Tk的GUI工具包。
- en: '**Tcl** (**Tool command language**), which is pronounced as tickle, is a popular scripting
    language in the domains of embedded applications, testing, prototyping, and GUI
    development. On the other hand, Tk is an open source, multiplatform widget toolkit
    that is used by many different languages to build GUI programs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tcl**（**工具命令语言**），发音为tickle，是一种在嵌入式应用、测试、原型设计和GUI开发领域流行的脚本语言。另一方面，Tk是一个开源的多平台小部件工具包，被许多不同的语言用来构建GUI程序。'
- en: The Tkinter interface is implemented as a Python module— `Tkinter.py` in Python
    2.x Versions and `tkinter/__init__.py` in Python 3.x Versions. If you look at
    the source code, Tkinter is just a wrapper around a C extension that uses the
    Tcl/Tk libraries.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter界面作为Python模块实现——在Python 2.x版本中为`Tkinter.py`，在Python 3.x版本中为`tkinter/__init__.py`。如果你查看源代码，Tkinter实际上是一个围绕使用Tcl/Tk库的C扩展的包装器。
- en: Tkinter is suitable for a wide variety of areas, ranging from small desktop
    applications to scientific modeling and research endeavors across various disciplines.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter适用于广泛的领域，从小型桌面应用程序到跨各种学科的科学研究建模和研究努力。
- en: When a person learning Python needs to graduate to GUI programming, Tkinter seems
    to be the easiest and fastest way to get the work done.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个学习 Python 的人需要过渡到 GUI 编程时，Tkinter 似乎是最简单和最快完成工作的方法。
- en: 'Tkinter is a great tool for the programming of GUI applications in Python. The
    features that make Tkinter a great choice for GUI programming include the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 是 Python 中用于 GUI 应用程序编程的强大工具。使 Tkinter 成为 GUI 编程优秀选择的特性包括以下内容：
- en: It is simple to learn (simpler than any other GUI package for Python)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习起来很简单（比任何其他Python GUI包都要简单）
- en: Relatively little code can produce powerful GUI applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相当少的代码就能生成强大的图形用户界面应用程序
- en: Layered design ensures that it is easy to grasp
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层设计确保易于掌握
- en: It is portable across all operating systems
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在所有操作系统上通用
- en: It is easily accessible, as it comes pre-installed with the standard Python
    distribution
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于访问，因为它随标准Python发行版预安装
- en: None of the other Python GUI toolkits have all of these features at the same
    time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何其他的Python GUI工具包同时具备所有这些功能。
- en: The purpose of this chapter is to make you comfortable with Tkinter. It aims
    to introduce you to the various components of GUI programming with Tkinter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是让您对Tkinter感到舒适。它旨在向您介绍使用Tkinter进行GUI编程的各种组件。
- en: We believe that the concepts that you will develop in this chapter will enable
    you to apply and develop GUI applications in your area of interest.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信，在本章中你将发展的概念将使你能够在你感兴趣的领域中应用和发展GUI应用程序。
- en: 'The key aspects that we want you to learn from this chapter include the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望您从本章学习的关键要点包括以下内容：
- en: Understanding the concept of a root window and the main loop
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解根窗口的概念和主循环
- en: Understanding widgets—the building blocks of programs
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解小部件——程序的构建块
- en: Getting acquainted with a list of available widgets
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉可用的组件列表
- en: Developing layouts by using different geometry managers
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的几何管理器来开发布局
- en: Applying events and callbacks to make a program functional
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将事件和回调应用于使程序功能化
- en: Styling widgets by using styling options and configuring the root widget
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用样式选项和配置根部件来设置部件样式
- en: Technical requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We assume a basic working knowledge of Python. You must know how to write and
    run basic programs in Python.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您对Python有基本的了解。您必须知道如何编写和运行Python的基本程序。
- en: We will develop our application on the Linux Mint platform. However, since Tkinter
    is multiplatform, you can follow along with the instructions in this book on Windows, Mac,
    or any other Linux distribution, without making any modifications to the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Linux Mint 平台上开发我们的应用程序。然而，由于 Tkinter 是跨平台的，你可以在 Windows、Mac 或任何其他 Linux
    发行版上按照本书中的说明进行操作，无需对代码进行任何修改。
- en: Project overview
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'By the end of this chapter, you will have developed several partly functional
    dummy applications, such as the one shown in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将已经开发出几个部分功能性的模拟应用程序，例如以下截图所示：
- en: '![](img/3f78ea3b-9479-4dcc-bdfa-ddd657a00e16.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f78ea3b-9479-4dcc-bdfa-ddd657a00e16.png)'
- en: We call these dummy applications because they are neither fully functional nor
    do they serve any practical purpose other than to show a particular feature of
    Tkinter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些应用程序称为虚拟应用程序，因为它们既不是完全功能性的，也不提供任何实际用途，除了展示 Tkinter 的特定功能。
- en: Getting started
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用
- en: We will write all our projects using Python Version 3.6.3, which is the latest
    *stable* release of Python at the time of writing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Python 3.6.3 版本编写所有项目，这是撰写时 Python 的最新 *稳定* 版本。
- en: The Python download package and instructions for downloading for different platforms
    are available at [https://www.python.org/downloads/release/python-363/](https://www.python.org/downloads/release/python-363/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python下载包和不同平台的下载说明可在[https://www.python.org/downloads/release/python-363/](https://www.python.org/downloads/release/python-363/)找到。
- en: The installer binaries for macOS X and the Windows platform are available at
    the aforementioned link.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: macOS X和Windows平台的安装程序二进制文件可在上述链接中获取。
- en: If you are following along on Unix, Linux, or BSD, the following procedure will
    install Python from the source.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Unix、Linux 或 BSD 系统，以下步骤将指导你从源代码安装 Python。
- en: 'First, install `tk8.6-dev` and `python3-tk` packages on your computer using
    your applicable package manager. For instance, on Debian-based systems such as
    Ubuntu and Mint, run the following two commands from the Terminal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用您适用的包管理器在您的计算机上安装`tk8.6-dev`和`python3-tk`软件包。例如，在基于Debian的系统上，如Ubuntu和Mint，请在终端中运行以下两个命令：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Download Python 3.6.3 from the preceding link and extract it to any location
    of your choice. Open a Terminal in the location where you extracted Python and
    type in the following commands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的链接下载 Python 3.6.3 并将其解压到您选择的任何位置。在您解压 Python 的位置打开终端，并输入以下命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This should install Python 3.6.3 on your computer. Now open a command line
    and enter the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在您的计算机上安装Python 3.6.3。现在打开命令行并输入以下命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will open the Python 3.6 interactive shell. Type in the following command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 Python 3.6 交互式 shell。输入以下命令：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command should execute without any errors. If there are no error messages,
    the Tkinter module is installed on your Python distribution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应无错误执行。如果没有错误信息，则Tkinter模块已安装在你的Python发行版上。
- en: When working with examples from this book, we do not support any Python Version
    except for Python 3.6.3, which comes bundled with Tkinter Tcl/Tk Version 8.6\.
    However, most of the examples should work out-of-the-box on other minor Python
    3 Versions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用本书中的示例时，我们不支持除Python 3.6.3以外的任何Python版本，该版本捆绑了Tkinter Tcl/Tk版本8.6。然而，大多数示例应该在其他次要的Python
    3版本上直接运行无误。
- en: 'To check whether you have the correct Tkinter Version on your Python installation, type
    the following commands in your IDLE or interactive shell:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查您的Python安装是否具有正确的Tkinter版本，请在您的IDLE或交互式shell中输入以下命令：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This should confirm the Tcl/Tk Version as 8.6\. We are now ready to build our
    GUI programs!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该确认Tcl/Tk版本为8.6。我们现在可以开始构建我们的GUI程序了！
- en: The next steps are optional and you may skip them at your discretion. While
    the preceding steps are sufficient for us to develop our programs, I highly recommend
    that you use a virtual environment for developing your programs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步骤是可选的，您可以根据自己的意愿跳过它们。虽然前面的步骤对我们开发程序已经足够，但我强烈建议您使用虚拟环境来开发您的程序。
- en: Virtual environments provide a secluded environment with no conflicts with system
    programs, and they can be easily reproduced on any other system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境提供了一个与系统程序无冲突的独立环境，并且可以在任何其他系统上轻松复制。
- en: So now let's set up a virtual environment. First, create a folder where you
    will keep all projects from this book. Let's call it `myTkinterProjects` or whatever
    suits you.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们设置一个虚拟环境。首先，创建一个文件夹，用于存放本书的所有项目。我们可以称它为`myTkinterProjects`或者任何适合你的名字。
- en: 'Next, find the location of the Python 3.6 installation on your computer. On
    my computer, I can find the location of the Python installation by running the
    following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到您计算机上Python 3.6的安装位置。在我的计算机上，我可以通过运行以下命令来找到Python安装的位置：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Take a note of the location. For me it is `/usr/local/bin/python3.6`*. *Now
    open a Terminal in your `myTkinterProjects` folder and run the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记录下位置。对我来说是`/usr/local/bin/python3.6`*。*现在在你的`myTkinterProjects`文件夹中打开一个终端，并运行以下命令：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will create a new virtual environment in a folder named `myvenv` inside
    your project folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在你的项目文件夹内名为`myvenv`的文件夹中创建一个新的虚拟环境。
- en: 'Lastly, we need to activate this virtual environment. This is done by running
    the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要激活这个虚拟环境。这通过运行以下命令来完成：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now if you type the command `python`, it should pick up Python 3.6.3 from within
    your virtual environment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您输入命令 `python`，它应该从您的虚拟环境中选择 Python 3.6.3。
- en: From now onward, every time we have to run a Python script or install a new
    module, we will first activatethe virtual environment using the preceding command
    and run or install the module within this new virtual environment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次我们需要运行一个Python脚本或安装一个新的模块，我们首先使用前面的命令激活虚拟环境，然后在新的虚拟环境中运行或安装该模块。
- en: GUI programming – the big picture
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形用户界面编程 – 整体概述
- en: 'As a GUI programmer, you will generally be responsible for deciding the following three
    aspects of your program:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为图形用户界面（GUI）程序员，你通常需要负责决定你程序以下三个方面的内容：
- en: Which components should appear on the screen?
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上应该显示哪些组件？
- en: This involves choosing the components that make the user interface. Typical
    components include things such as buttons, entry fields, checkboxes, radio buttons,
    and scrollbars. In Tkinter, the components that you add to your GUI are called **widgets**. Widgets
    (short for window gadgets) are the graphical components that make up your application's
    frontend.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到选择构成用户界面的组件。典型的组件包括按钮、输入字段、复选框、单选按钮和滚动条。在Tkinter中，您添加到GUI的组件被称为**小部件**。小部件（简称窗口小工具）是构成应用程序前端图形组件。
- en: Where should the components go?
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件应该放在哪里？
- en: This includes deciding the position and the structural layout of various components.
    In Tkinter, this is referred to as **geometry management**.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括决定各种组件的位置和结构布局。在Tkinter中，这被称为**几何管理**。
- en: How do components interact and behave?
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件是如何交互和表现的？
- en: This involves adding functionality to each component. Each component or widget
    does something. For example, a button, when clicked on, does something in response.
    A scrollbar handles scrolling, and checkboxes and radio buttons enable users to
    make some choices. In Tkinter, the functionality of various widgets is managed
    by command binding or **event binding** using **callbacks**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到为每个组件添加功能。每个组件或小部件都执行某些操作。例如，一个按钮在被点击时会产生响应。滚动条处理滚动，复选框和单选按钮使用户能够做出一些选择。在Tkinter中，各种小部件的功能是通过命令绑定或使用**回调函数**的**事件绑定**来管理的。
- en: 'The following diagram shows the three components of GUI programming:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了GUI编程的三个组成部分：
- en: '![](img/7542b4be-76af-4fb3-ace5-2748a17594fd.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7542b4be-76af-4fb3-ace5-2748a17594fd.png)'
- en: The root window – your drawing board
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根窗口 – 你的绘图板
- en: GUI programming is an art, and like all art you need a drawing board to capture your
    ideas. The drawing board that you will use is called the **root window**. Our
    first goal is to get the root window ready.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面编程是一门艺术，就像所有艺术一样，你需要一块画板来捕捉你的想法。你将使用的画板被称为**根窗口**。我们的第一个目标是准备好根窗口。
- en: 'The following screenshot depicts the root window that we are going to create:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了我们将要创建的根窗口：
- en: '![](img/ad6c9d55-193d-4989-8805-266a5c71321c.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad6c9d55-193d-4989-8805-266a5c71321c.png)'
- en: 'Drawing the root window is easy. You just need the following three lines of
    code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制根窗口很简单。你只需要以下三行代码：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save this with the `.py` file extension or check out the code present in the
    `1.01.py` file. Open it in the IDLE window or run it from within your activated
    virtual environment using the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存为`.py`文件扩展名或查看`1.01.py`文件中的代码。在IDLE窗口中打开它，或使用以下命令在激活的虚拟环境中运行它：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running this program should generate a blank root window, as shown in the preceding
    screenshot. This window is equipped with functional minimize, maximize, and close
    buttons, and a blank frame.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序应生成一个空白的根窗口，如图中所示的前一个截图。此窗口配备了功能性的最小化、最大化和关闭按钮，以及一个空白框架。
- en: Downloading the example code
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下载示例代码
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). Apart
    from going to Packt's official website, you can also find the code files for this
    book at [https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition](https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition).
    If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的账户下载您购买的所有Packt书籍的示例代码文件。除了访问Packt的官方网站外，您还可以在[https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition](https://github.com/PacktPublishing/Tkinter-GUI-Application-Development-Blueprints-Second-Edition)找到这本书的代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接将文件通过电子邮件发送给您。
- en: 'The following is a description of the preceding code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: The first line imported the `tkinter` module into the namespace with `tk` as
    its alias. Now we can access all definitions of the classes, attributes, and methods
    of Tkinter by appending the alias tk to the name as in `tk.Tk()`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将`tkinter`模块导入到命名空间中，并以`tk`作为其别名。现在我们可以通过在名称后附加别名tk来访问Tkinter中所有类的定义、属性和方法，例如`tk.Tk()`。
- en: The second line created an instance of the `tkinter.Tk` class. This created what
    is called the **root window**, which is shown in the preceding screenshot. According
    to the conventions, the root window in Tkinter is usually called **root**, but
    you are free to call it by any other name.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行创建了一个`tkinter.Tk`类的实例。这创建了一个被称为**根窗口**的东西，这在前面截图中有展示。根据惯例，Tkinter中的根窗口通常被称为**root**，但你也可以自由地用任何其他名字来称呼它。
- en: The third line executed the `mainloop` (that is, the event loop) method of the root
    object. The `mainloop` method is what keeps the root window visible. If you remove
    the third line, the window created in line 2 will disappear immediately as soon
    as the script stops running. This will happen so fast that you will not even see
    the window appearing on your screen. Keeping the `mainloop` method running also
    lets you keep the program running until you press the Close button, which exits `mainloop`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行执行了root对象的`mainloop`（即事件循环）方法。`mainloop`方法正是保持root窗口可见的原因。如果你删除第三行，第二行创建的窗口将在脚本停止运行后立即消失。这会发生得如此之快，以至于你甚至看不到窗口出现在你的屏幕上。保持`mainloop`方法运行也允许你保持程序运行，直到你按下关闭按钮，这将退出`mainloop`。
- en: Tkinter also exposed the `mainloop` method as `tkinter.mainloop()`. So, you can
    even call `mainloop()` directly instead of calling `root.mainloop()`.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 还暴露了 `mainloop` 方法为 `tkinter.mainloop()`。因此，你可以直接调用 `mainloop()` 而不是调用
    `root.mainloop()`。
- en: Congratulations! You have completed your first objective, which was to draw
    the root window. You have now prepared your drawing board (root window). Now,
    get ready to paint it with your imagination!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经完成了第一个目标，那就是绘制根窗口。现在，你已经准备好了你的画板（根窗口）。现在，准备好用你的想象力来描绘它吧！
- en: Commit the three lines of code (shown in code `1.01.py`) to memory. These three
    lines generate your root window, which will accommodate all the other graphical
    components. These lines form the skeleton of any GUI application that you will
    develop in Tkinter. The entire code that will make your GUI application functional
    will go between line 2 (new object creation) and line 3 (`mainloop`) of this code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三行代码（如代码`1.01.py`所示）牢记于心。这三行代码生成了您的根窗口，它将容纳所有其他图形组件。这些行构成了您在Tkinter中开发的任何GUI应用程序的骨架。使您的GUI应用程序功能化的全部代码将位于此代码的第2行（新对象创建）和第3行（`mainloop`）之间。
- en: Widgets – the building blocks of GUI programs
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Widgets – GUI程序的构建块
- en: 'Now that we have our top level or the root window ready, it is time to think
    over the question: which components should appear in the window? In Tkinter jargon,
    these components are called **widgets**.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了顶级窗口或根窗口，是时候思考这样一个问题了：哪些组件应该出现在窗口中？在Tkinter术语中，这些组件被称为**小部件**。
- en: 'The syntax that is used to add a widget is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 添加小部件所使用的语法如下：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the following example ( `1.02.py` ), we will add two widgets, a label and
    a button, to the root container. Also, note how all the widgets are added between
    the skeleton code that we defined in the first example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例（`1.02.py`）中，我们将向根容器添加两个小部件，一个标签和一个按钮。同时，请注意所有小部件是如何添加到我们在第一个示例中定义的骨架代码之间的：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running the preceding code(`1.02.py`) will generate a window with a label and
    a button widget, as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码(`1.02.py`)将生成一个带有标签和按钮小部件的窗口，如下面的截图所示：
- en: '![](img/bb8d5d9f-c921-4675-91f6-822f9f7a7f67.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb8d5d9f-c921-4675-91f6-822f9f7a7f67.png)'
- en: 'The following is a description of the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: This code added a new instance named `label` for the label widget. The first
    parameter defined root as its parent or container. The second parameter configured
    its text option to read  `I am a label widget`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码为标签小部件添加了一个名为`label`的新实例。第一个参数定义了根元素作为其父元素或容器。第二个参数配置了其文本选项，以读取`我是一个标签小部件`。
- en: Similarly, we defined an instance of a Button widget. This is also bound to
    the root window as its parent.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们定义了一个Button小部件的实例。这也被绑定到根窗口作为其父窗口。
- en: We used the `pack()` method, which is essentially required to position the label
    and button widgets within the window. We will discuss the `pack()` method and
    several other related concepts when exploring the geometry management task. However,
    you must note that some sort of geometry specification is essential for the widgets
    to be displayed.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了`pack()`方法，这基本上是必需的，用于在窗口中定位标签和按钮小部件。当探索几何管理任务时，我们将讨论`pack()`方法以及几个其他相关概念。然而，你必须注意，对于小部件要显示出来，某种形式的几何规格是必不可少的。
- en: Some important widget features
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些重要的部件功能
- en: 'Note the following few important features that are common to all widgets:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下所有小部件共有的几个重要特性：
- en: All widgets are actually objects derived from their respective widget classes. So,
    a statement such as `button = Button(its_parent)` actually creates a button instance
    from the `Button` class.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有小部件实际上都是它们各自小部件类的派生对象。因此，一个如`button = Button(its_parent)`这样的语句实际上是从`Button`类创建了一个按钮实例。
- en: Each widget has a set of options that decides its behavior and appearance. This
    includes attributes such as text labels, colors, and font size. For example, the
    Button widget has attributes to manage its label, control its size, change its
    foreground and background colors, change the size of the border, and more.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个小部件都有一组选项来决定其行为和外观。这包括文本标签、颜色和字体大小等属性。例如，按钮小部件具有管理其标签、控制其大小、更改前景和背景颜色、更改边框大小等属性。
- en: To set these attributes, you can set the values directly at the time of creating
    the widget, as demonstrated in the preceding example. Alternatively, you can later
    set or change the options of the widget by using the `.config()` or `.configure()`
    method. Note that the `.config()` or `.configure()` methods are interchangeable
    and provide the same functionality. In fact, the `.config()` method is simply
    an alias of the `.configure()` method.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要设置这些属性，您可以在创建小部件时直接设置值，如前一个示例所示。或者，您也可以稍后通过使用`.config()`或`.configure()`方法来设置或更改小部件的选项。请注意，`.config()`或`.configure()`方法是可互换的，并提供相同的功能。实际上，`.config()`方法仅仅是`.configure()`方法的别名。
- en: Ways to create widgets
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建小部件的方法
- en: There are two ways to create widgets in Tkinter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中创建小部件有两种方法。
- en: 'The first way involves creating a widget in one line and then adding the `pack()` method
    (or other geometry managers) in the next line, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法涉及在一行中创建一个小部件，然后在下一行添加`pack()`方法（或其他布局管理器），如下所示：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you can write both the lines together, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以将这两行一起写，如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can either save a reference to the widget created ( `my_label`, as in the
    first example), or create a widget without keeping any reference to it (as demonstrated in
    the second example).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择保存对创建的部件的引用（例如，`my_label`，如第一个示例所示），或者创建一个部件而不保留对其的任何引用（如第二个示例所示）。
- en: You should ideally keep a reference to the widget in case the widget has to
    be accessed later on in the program. For instance, this is useful in case you
    need to call one of its internal methods or for its content modification. If the
    widget state is supposed to remain static after its creation, you need not keep
    a reference to the widget.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该保留对组件的引用，以防在程序中稍后需要访问该组件。例如，当你需要调用其内部方法或修改其内容时，这很有用。如果组件状态在创建后应保持静态，那么你不需要保留对组件的引用。
- en: 'Note that calls to `pack()` (or other geometry managers) always return `None`.
    So, consider a situation where you create a widget, and add a geometry manager
    (say, `pack()`) on the same line, as follows: `my_label = tk.Label(...).pack()`.
    In this case, you are not creating a reference to the widget. Instead, you are
    creating a `None` type object for the `my_label` variable. So, when you later
    try to modify the widget through the reference, you get an error because you are
    actually trying to work on a `None` type object. If you need a reference to a
    widget, you must create it on one line and then specify its geometry (like `pack()`)
    on the second line, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，调用 `pack()`（或其他几何管理器）总是返回 `None`。因此，考虑以下情况：你创建了一个小部件，并在同一行上添加了一个几何管理器（例如，`pack()`），如下所示：`my_label
    = tk.Label(...).pack()`。在这种情况下，你并没有创建小部件的引用。相反，你为 `my_label` 变量创建了一个 `None` 类型的对象。所以，当你后来尝试通过引用修改小部件时，你会得到一个错误，因为你实际上是在尝试对一个
    `None` 类型的对象进行操作。如果你需要一个小部件的引用，你必须在一行上创建它，然后在第二行上指定其几何（例如 `pack()`），如下所示：
- en: '`my_label = tk.Label(...)`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_label = tk.Label(...)`'
- en: '`my_label.pack()`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_label.pack()`'
- en: This is one of the most common mistakes committed by beginners.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最常见的初学者犯的错误之一。
- en: Getting to know the core Tkinter widgets
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Tkinter 核心小部件
- en: Now you will get to know all the core Tkinter widgets. You have already seen
    two of them in the previous example—the Label and Button widgets. Now, let's explore
    all the other core Tkinter widgets.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将了解所有核心的 Tkinter 小部件。在前面的示例中，你已经看到了其中的两个——标签（Label）和按钮（Button）小部件。现在，让我们来探索所有其他的核心
    Tkinter 小部件。
- en: 'Tkinter includes 21 core widgets, which are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 包含 21 个核心小部件，具体如下：
- en: '| **Top-level** | **Label** | **Button** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **顶级** | **标签** | **按钮** |'
- en: '| Canvas | Checkbutton | Entry |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 画布 | 复选按钮 | 输入框 |'
- en: '| Frame | LabelFrame | Listbox |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 框架 | 标签框架 | 列表框 |'
- en: '| Menu | Menubutton | Message |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 菜单 | 菜单按钮 | 消息 |'
- en: '| OptionMenu | PanedWindow | Radiobutton |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 选项菜单 | 分割窗口 | 单选按钮 |'
- en: '| Scale | Scrollbar | Spinbox |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 尺度 | 滚动条 | 微调框 |'
- en: '| Text | Bitmap | Image |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 文本 | 位图 | 图片 |'
- en: Let's write a program to display all of these widgets in the root window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序来显示根窗口中的所有这些小部件。
- en: Adding widgets to a parent window
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向父窗口添加小部件
- en: 'The format used to add widgets is the same as the one that we discussed in
    the previous task. To give you an idea about how it''s done, here''s some sample
    code that adds some common widgets:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 添加小部件所使用的格式与我们在上一个任务中讨论的相同。为了给您一个关于如何操作的直观印象，这里有一些示例代码，展示了如何添加一些常见的小部件：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Can you spot the pattern that is common to each widget? Can you spot the differences?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否发现每个小部件共有的模式？你能发现其中的差异吗？
- en: 'As a reminder, the syntax for adding a widget is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，添加小部件的语法如下：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using the same pattern, let''s add all the 21 core Tkinter widgets into a dummy application
    (`1.03.py`). We do not reproduce the entire code here. A summarized code description
    for `1.03.py` is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的模式，让我们将所有 21 个核心 Tkinter 小部件添加到一个虚拟应用程序（`1.03.py`）中。我们在此不展示完整代码。`1.03.py`
    的代码摘要如下：
- en: We create a top-level window and a `mainloop`, as shown in the earlier examples.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个顶级窗口和一个`mainloop`，正如之前示例中所示。
- en: 'We add a frame widget and name it `menu_bar`. Note that frame widgets are just
    holder widgets that hold other widgets. Frame widgets are great for grouping widgets
    together. The syntax for adding a frame is the same as that for all the other
    widgets:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个框架小部件并将其命名为`menu_bar`。请注意，框架小部件只是持有其他小部件的容器小部件。框架小部件非常适合将小部件分组在一起。添加框架的语法与所有其他小部件的语法相同：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Keeping the `menu_bar` frame as the container, we add two widgets to it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`菜单栏`框架作为容器，我们向其中添加了两个小部件：
- en: Menubutton
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单按钮
- en: Menu
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单
- en: 'We create another frame widget and name it `frame`. Keeping `frame` as the
    container/parent widget, we add the following seven widgets to it:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建另一个框架小部件并将其命名为`frame`。将`frame`作为容器/父小部件，我们向其中添加以下七个小部件：
- en: Label
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签
- en: Entry
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入框
- en: Button
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮
- en: Checkbutton
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复选框
- en: Radiobutton
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单选按钮
- en: OptionMenu
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项菜单
- en: '`Bitmap` Class'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`位图` 类'
- en: 'We then proceed to create another frame widget. We add six more widgets to
    the frame:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着创建另一个框架小部件。我们向框架中添加了六个更多的小部件：
- en: '`Image` Class'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image` 类'
- en: Listbox
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表框（Listbox）
- en: Spinbox
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动框（Spinbox）
- en: Scale
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑块（Scale）
- en: LabelFrame
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签框架（LabelFrame）
- en: Message
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息
- en: 'We then create another frame widget. We add two more widgets to the frame:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着创建另一个框架小部件。我们再向框架中添加两个小部件：
- en: Text
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本
- en: Scrollbar
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动条
- en: 'We create another frame widget and add two more widgets to it:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建另一个框架小部件并将其添加两个更多的小部件：
- en: Canvas
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas
- en: PanedWindow
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: PanedWindow
- en: These constitute the 21 core widgets of Tkinter. Now that you have had a glimpse
    of all the widgets, let's discuss how to specify the location of these widgets
    using geometry managers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构成了 Tkinter 的 21 个核心小部件。现在你已经瞥见了所有的小部件，让我们来讨论如何使用布局管理器来指定这些小部件的位置。
- en: The Tkinter geometry manager
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 布局管理器
- en: You may recall that we used the `pack()` method to add widgets to the dummy
    application that we developed in the previous section. The `pack()` method is
    an example of geometry management in Tkinter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，我们在上一节开发的虚拟应用程序中使用了 `pack()` 方法来添加小部件。`pack()` 方法是 Tkinter 中几何管理的一个例子。
- en: The `pack()` method is not the only way of managing the geometry in your interface. In
    fact, there are three geometry managers in Tkinter that let you specify the position of
    widgets inside a top-level or parent window.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack()`方法并不是管理您界面几何形状的唯一方式。实际上，Tkinter中有三种几何形状管理器，允许您指定顶级或父窗口中小部件的位置。'
- en: 'The three geometry managers are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 三种几何管理器如下：
- en: '**pack**: This is the one that we have used so far. It is simple to use for
    simpler layouts, but it may get very complex for slightly complex layouts.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pack**: 这是我们迄今为止所使用的布局方式。对于简单的布局来说，使用起来很简单，但对于稍微复杂一些的布局，它可能会变得非常复杂。'
- en: '**grid**: This is the most commonly used geometry manager, and provides a table-like
    layout of management features for easy layout management.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格布局**：这是最常用的几何管理器，它提供了一个类似表格的管理功能布局，便于进行布局管理。'
- en: '**place**: This is the least popular, but it provides the best control for
    the absolute positioning of widgets.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置**: 这是最受欢迎度最低的，但它为小部件的绝对定位提供了最佳的控制。'
- en: Now, let's have a look at some examples of all the three geometry managers in
    action.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这三个几何管理器在实际操作中的几个示例。
- en: The pack geometry manager
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包布局管理器
- en: The pack manager can be a bit tricky to explain in words, and it can best be understood
    by playing with the code base. Fredrik Lundh, the author of Tkinter, asks us to
    imagine the root as an elastic sheet with a small opening at the center. The pack geometry
    manager makes a hole in the elastic sheet that is just large enough to hold the
    widget. The widget is placed along a given inner edge of the gap (the default
    is the top edge). It then repeats the process till all the widgets are accommodated.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 打包管理器在用言语解释时可能有些棘手，最好是通过实际操作代码库来理解。Tkinter的作者Fredrik Lundh建议我们想象根节点就像一张带有中心小开口的弹性薄片。打包几何管理器在弹性薄片上打一个足够容纳小部件的孔。小部件被放置在间隙的给定内边缘（默认为顶部边缘）上。然后它会重复这个过程，直到所有小部件都被容纳进去。
- en: Finally, when all the widgets have been packed in the elastic sheet, the geometry manager
    calculates the bounding box for all the widgets. It then makes the parent widget
    large enough to hold all the child widgets.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所有的小部件都包装在弹性薄片内时，几何管理器会计算所有小部件的边界框。然后它使父小部件足够大，以便容纳所有子小部件。
- en: 'When packing child widgets, the pack manager distinguishes between the following
    three kinds of space:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当打包子小部件时，打包管理器区分以下三种空间：
- en: Unclaimed space
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未声明的空间
- en: Claimed but unused space
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声称但未使用的空间
- en: Claimed and used space
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声称和使用的空间
- en: 'The most commonly used options in pack include the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 打包中最常用的选项包括以下内容：
- en: '`side`: `LEFT`, `TOP`, `RIGHT`, and BOTTOM (these decide the alignment of the
    widget)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`side`: `LEFT`, `TOP`, `RIGHT`, 和 `BOTTOM` (这些决定小部件的对齐方式)'
- en: '`fill`: X, Y, BOTH, and NONE (these decide whether the widget can grow in size)'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`: X, Y, BOTH, 和 NONE（这些决定小部件是否可以增长大小）'
- en: '`expand`: Boolean values such as `tkinter.YES`/`tkinter.NO`, `1` / `0`, and
    `True`/`False`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expand`: 布尔值，例如 `tkinter.YES`/`tkinter.NO`，`1` / `0`，以及 `True`/`False`'
- en: '`anchor`: NW, N, `NE`, `E`, `SE`, S, SW, `W`, and CENTER (corresponding to
    the cardinal directions)'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor`: NW, N, `NE`, `E`, `SE`, S, SW, `W`, and CENTER (对应于主要方向)'
- en: Internal padding ( `ipadx` and `ipady` ) for the padding inside widgets and external
    padding ( `padx` and `pady` ), which all default to a value of zero
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部填充（`ipadx` 和 `ipady`）用于小部件内部的填充，以及外部填充（`padx` 和 `pady`），它们的所有默认值均为零
- en: Let's take a look at demo code that illustrates some of the pack features.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看演示代码，它展示了该软件包的一些功能特性。
- en: 'Two of the most commonly used pack options are `fill` and `expand`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最常用的包装选项是 `fill` 和 `expand`：
- en: '![](img/f7e36bba-503c-4e0b-9826-8f82f51f42a3.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7e36bba-503c-4e0b-9826-8f82f51f42a3.png)'
- en: 'The following code *(*`1.04.py`*)* generates a GUI like the one shown in the
    preceding screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（`1.04.py`）生成一个类似于前一个截图所示的图形用户界面：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is a description of the preceding code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: When you insert the `A` button in the root frame, it captures the leftmost area of
    the frame, expands, and fills the `Y` dimension. Because the fill option is specified
    as `fill=tk.Y`, it claims all the area that it wants and fills the `Y` dimension
    of its container frame.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在根框架中插入 `A` 按钮，它会捕获框架的最左侧区域，并扩展以填充 `Y` 维度。因为填充选项被指定为 `fill=tk.Y`，它会占据它想要的全部区域，并填充其容器框架的
    `Y` 维度。
- en: Because frame is itself packed with a plain `pack()` method with no mention of
    a pack option, it takes the minimum space required to accommodate all of its child
    widgets.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为框架本身包含一个不带任何打包选项的简单 `pack()` 方法，所以它占用最小的空间来容纳其所有子控件。
- en: If you increase the size of the root window by pulling it down or sideways, you
    will see that all the buttons within the frame do not fill or expand with the
    root window.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你通过向下或向侧面拉动来增加根窗口的大小，你会发现框架内的所有按钮都不会随着根窗口的扩大而填充或扩展。
- en: The positioning of the `B`, `C`, and `D` buttons occurs on the basis of the
    side and fill options specified for each of them.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`B`、`C`和`D`按钮的位置是基于为每个按钮指定的侧面和填充选项来确定的。'
- en: The next three buttons (after `B`, `C`, and `D`) demonstrate the use of the
    expand option. A value of `expand=1` means that the button moves its place on resizing
    the window. Buttons with no explicit expand options stay in their place and do
    not respond to changes in the size of their parent container (the root window,
    in this case).
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三个按钮（在`B`、`C`和`D`之后）展示了`expand`选项的使用。`expand=1`的值表示按钮在窗口调整大小时会移动其位置。没有明确`expand`选项的按钮将保持在原位，并且不会对其父容器（在这种情况下是根窗口）大小的变化做出响应。
- en: The best way to study this piece of code would be to resize the root window to
    see the effect that it has on various buttons.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习这段代码的最佳方式是将根窗口调整大小，以观察它对各种按钮产生的影响。
- en: The `anchor` attribute (not used in the preceding code) provides a means to position
    a widget relative to a reference point. If the `anchor` attribute is not specified,
    the pack manager places the widget at the center of the available space or the
    packing box. The other options that are allowed include the four cardinal directions
    (N, S, `E`, and `W`) and a combination of any two directions. Therefore, valid
    values for the `anchor` attribute are `CENTER` (the default value), N, S, E, `W`,
    NW, `NE`, SW, and `SE`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anchor` 属性（在前面代码中未使用）提供了一种将小部件相对于参考点定位的方法。如果未指定 `anchor` 属性，则打包管理器将小部件放置在可用空间或打包框的中心。允许的其他选项包括四个基本方向（N、S、`E`
    和 `W`）以及任意两个方向的组合。因此，`anchor` 属性的有效值包括 `CENTER`（默认值）、N、S、E、`W`、NW、NE、SW 和 SE。'
- en: The values for most Tkinter geometry manager attributes can either be specified
    in capital letters without quotes (such as `side=tk.TOP `and `anchor=tk.SE`) or
    in small letters within quotes (such as `side='top'`and `anchor='se'`).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 几何管理器的大多数属性值可以是未加引号的全部大写字母（例如 `side=tk.TOP` 和 `anchor=tk.SE`），也可以是加引号的小写字母（例如
    `side='top'` 和 `anchor='se'`）。
- en: We will use the pack geometry manager in some of our projects. Therefore, it
    will be worthwhile to get acquainted with pack and its options.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的某些项目中使用pack布局管理器。因此，熟悉pack及其选项将是有益的。
- en: 'The pack manager is ideally suited for the following two kinds of situation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 包管理器非常适合以下两种情况：
- en: Placing widgets in a top-down manner
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以自上而下的方式放置小部件
- en: Placing widgets side by side
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将小部件并排放置
- en: '`1.05.py` shows an example of both of these scenarios:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.05.py` 展示了这两个场景的示例：'
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code produces a GUI, as shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了一个图形用户界面，如下截图所示：
- en: '![](img/34000aa1-485f-43f3-ae57-9dce5eabbcc3.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34000aa1-485f-43f3-ae57-9dce5eabbcc3.png)'
- en: 'For a complete pack reference, type the following command in the Python shell:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的包参考，请在 Python 命令行中输入以下命令：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Besides getting interactive help with documentation, Python's REPL is also a
    great tool for iterating and quick prototyping of Tkinter programs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过文档获得交互式帮助外，Python 的交互式解释器（REPL）也是迭代和快速原型化 Tkinter 程序的出色工具。
- en: Where should you use the pack() geometry manager?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何处使用 pack() 布局管理器？
- en: 'Using the pack manager is somewhat complicated as compared to the `grid` method,
    which will be discussed next, but it is a great choice in situations such as the
    following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器相对于接下来将要讨论的`grid`方法来说有些复杂，但它在以下情况下是一个很好的选择：
- en: Having a widget fill the complete container frame
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使小部件填充整个容器框架
- en: Placing several widgets on top of each other or side by side (as shown in the
    preceding screenshot)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将几个小部件叠加或并排放置（如前一张截图所示）
- en: Although you can create complicated layouts by nesting widgets in multiple frames,
    you will find the grid geometry manager more suitable for most complex layouts.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以通过在多个框架中嵌套小部件来创建复杂的布局，但您会发现网格几何管理器更适合大多数复杂布局。
- en: The grid geometry manager
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格布局管理器
- en: The grid geometry manager is easy to understand and perhaps the most useful
    geometry manager in Tkinter. The central idea of the grid geometry manager is
    to organize the container frame into a two-dimensional table that is divided into
    a number of rows and columns. Each cell in the table can then be targeted to hold
    a widget. In this context, a cell is an intersection of imaginary rows and columns.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局管理器易于理解，可能是Tkinter中最有用的布局管理器。网格布局管理器的核心思想是将容器框架组织成一个二维表格，该表格被划分为若干行和列。然后，表格中的每个单元格都可以被定位以容纳一个小部件。在这种情况下，单元格是想象中的行和列的交点。
- en: Note that in the `grid` method, each cell can hold only one widget. However,
    widgets can be made to span multiple cells.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`网格`方法中，每个单元格只能容纳一个小部件。然而，可以将小部件设置为跨越多个单元格。
- en: Within each cell, you can further align the position of the widget using the
    sticky option. The sticky option decides how the widget is expanded. If its container
    cell is larger than the size of the widget that it contains, the sticky option
    can be specified using one or more of the N, S, `E`, and `W` options or the NW,
    `NE`, SW, and `SE` options.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个单元格内，您可以使用 sticky 选项进一步对组件的位置进行对齐。sticky 选项决定了组件如何扩展。如果其容器单元格的大小大于它所包含的组件大小，则可以使用一个或多个
    N、S、`E` 和 `W` 选项或 NW、`NE`、SW 和 `SE` 选项来指定 sticky 选项。
- en: Not specifying stickiness defaults stickiness to the center of the widget in
    the cell.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 未指定粘性时，粘性默认设置为单元格中小部件的中心。
- en: 'Let''s have a look at demo code that illustrates some features of the grid geometry
    manager. The code in `1.06.py` generates a GUI, as shown in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看演示代码，它展示了网格几何管理器的一些特性。`1.06.py`中的代码生成一个GUI，如下截图所示：
- en: '![](img/8ea6ee20-8e4a-4a32-bce6-cb95f6816f82.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8ea6ee20-8e4a-4a32-bce6-cb95f6816f82.png)'
- en: 'The following code (`1.06.py`) generates the preceding GUI:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（`1.06.py`）生成了前面的GUI：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is a description of the preceding code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: Take a look at the grid position defined in terms of the row and column positions
    for an imaginary grid table spanning the entire frame. See how the use of `sticky=tk.W`
    on both the labels makes them stick on the left-hand side, thus resulting in a
    clean layout.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看在行和列位置定义的网格位置，对于跨越整个框架的虚拟网格表。看看在标签上使用`sticky=tk.W`是如何使它们固定在左侧的，从而实现整洁的布局。
- en: The width of each column (or the height of each row) is automatically decided
    by the height or width of the widgets in the cell. Therefore, you need not worry
    about specifying the row or column width as equal. You can specify the width for
    widgets if you need that extra bit of control.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一列（或每一行的宽度）都是自动根据单元格中小部件的高度或宽度来决定的。因此，您无需担心指定行或列的宽度是否相等。如果您需要额外的控制，您可以指定小部件的宽度。
- en: You can use the `sticky=tk.NSEW` argument to make the widget expandable and fill
    the entire cell of the grid.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`sticky=tk.NSEW`参数来使小部件可扩展并填充整个网格的单元格。
- en: In a more complex scenario, your widgets may span across multiple cells in the
    grid. To make a grid to span multiple cells, the `grid` method offers handy options
    such as `rowspan` and `columnspan`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在更复杂的场景中，您的组件可能跨越网格中的多个单元格。为了创建跨越多个单元格的网格，`grid`方法提供了便捷的选项，例如`rowspan`和`columnspan`。
- en: Furthermore, you may often need to provide some padding between cells in the grid.
    The grid manager provides the `padx` and `pady` options to provide padding that
    needs to be placed around a widget.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可能经常需要在网格中的单元格之间提供一些填充。网格管理器提供了`padx`和`pady`选项来提供需要放置在部件周围的填充。
- en: Similarly, the `ipadx` and `ipady` options are used for internal padding. These
    options add padding within the widget itself. The default value of external and
    internal padding is `0`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`ipadx` 和 `ipady` 选项用于内部填充。这些选项在控件内部添加填充。外部和内部填充的默认值是 `0`。
- en: Let's have a look at an example of the grid manager, where we use most of the common
    arguments to the grid method, such as `row`, `column`, `padx`, `pady`, `rowspan`,
    and `columnspan`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个网格管理器的示例，其中我们使用了网格方法的大部分常用参数，例如 `row`、`column`、`padx`、`pady`、`rowspan`
    和 `columnspan`。
- en: '`1.07.py` produces a GUI, as shown in the following screenshot, to demonstrate how
    to use the grid geometry manager options:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`1.07.py`生成了一个GUI，如下面的截图所示，以演示如何使用网格几何管理器选项：'
- en: '![](img/d819f6d9-ae50-4602-bd32-95640349200c.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d819f6d9-ae50-4602-bd32-95640349200c.png)'
- en: 'The following code ( `1.07.py` ) generates the preceding GUI:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码（`1.07.py`）生成了前面的GUI：
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note how just 14 lines of the core grid manager code generate a complex layout such
    as the one shown in the preceding screenshot. On the other hand, developing this
    with the pack manager would have been much more tedious.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意仅14行核心网格管理器代码就能生成如前截图所示的复杂布局。另一方面，如果使用打包管理器来开发，将会更加繁琐。
- en: Another grid option that you can sometimes use is the `widget.grid_forget()` method.
    This method can be used to hide a widget from the screen. When you use this option,
    the widget still exists at its former location, but it becomes invisible. The
    hidden widget may be made visible again, but the grid options that you originally
    assigned to the widget will be lost.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有时可以使用的网格选项是`widget.grid_forget()`方法。此方法可用于从屏幕上隐藏小部件。当你使用此选项时，小部件仍然存在于其原始位置，但它变得不可见。隐藏的小部件可以被再次显示，但原本分配给小部件的网格选项将会丢失。
- en: Similarly, there is a `widget.grid_remove()` method that removes the widget,
    except that in this case, when you make the widget visible again, all of its grid
    options will be restored.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，存在一个 `widget.grid_remove()` 方法可以移除小部件，但在这个情况下，当你再次使小部件可见时，它所有的网格选项都将被恢复。
- en: 'For a complete grid reference, type the following command in the Python shell:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的网格参考，请在 Python 命令行中输入以下命令：
- en: '[PRE22]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Where should you use the grid geometry manager?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何处使用网格几何管理器？
- en: The grid manager is a great tool for the development of complex layouts. Complex
    structures can be easily achieved by breaking the container widget into grids
    of rows and columns and then placing the widgets in grids where they are wanted.
    It is also commonly used to develop different kinds of dialog box.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 网格管理器是开发复杂布局的强大工具。通过将容器小部件分解成行和列的网格，然后在这些网格中放置所需的小部件，可以轻松实现复杂结构。它也常用于开发不同类型的对话框。
- en: Now we will delve into configuring a grid's column and row sizes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将深入探讨配置网格的列和行大小。
- en: Different widgets have different heights and widths. So, when you specify the position
    of a widget in terms of rows and columns, the cell automatically expands to accommodate
    the widget.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的部件有不同的高度和宽度。因此，当您以行和列的形式指定部件的位置时，单元格会自动扩展以容纳该部件。
- en: Normally, the height of all the grid rows is automatically adjusted so it's
    the height of its tallest cell. Similarly, the width of all the grid columns is
    adjusted so it's equal to the width of the widest widget cell.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，所有网格行的长度会自动调整，使其等于其最高单元格的长度。同样，所有网格列的宽度也会调整，使其等于最宽小部件单元格的宽度。
- en: If you then want a smaller widget to fill a larger cell or to stay on any one
    side of the cell, you can use the sticky attribute on the widget to control this
    aspect.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个更小的部件来填充更大的单元格或者使其保持在单元格的任何一边，你可以使用部件上的粘性属性来控制这一方面。
- en: 'However, you can override this automatic sizing of columns and rows by using
    the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以通过以下代码来覆盖列和行的自动尺寸：
- en: '[PRE23]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Use these to configure the options for a given widget, `w`, in either the *n*^(th) column
    or the *n*^(th) row, specifying values for the options, minsize, pad, and weight.
    Note that the numbering of rows begins from `0` and not `1`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些选项来配置给定小部件`w`在第*n*列或第*n*行的选项，指定选项、最小尺寸、填充和权重。请注意，行号从`0`开始，而不是`1`。
- en: 'The options available are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的选项如下：
- en: '| **Options** | **Descriptions** |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| **选项** | **描述** |'
- en: '| minsize | This is the minimum size of a column or row in pixels. If there
    is no widget in a given column or row, the cell does not appear in spite of this minsize
    specification. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| minsize | 这是列或行的最小像素大小。如果给定列或行中没有小部件，即使有此minsize指定，单元格也不会出现。 |'
- en: '| pad | This is the external padding in pixels that will be added to the specified column
    or row over the size of the largest cell. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 填充 | 这是在像素中添加到指定列或行的外部填充，其大小将超过最大单元格的大小。 |'
- en: '| weight | This specifies the relative weight of a row or column and then distributes
    the extra space. This enables making the row or column stretchable.For example,
    the following code distributes two-fifths of the extra space to the first column
    and three-fifths to the second column: `w.columnconfigure(0, weight=2)`'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '| 重量 | 这指定了行或列的相对权重，然后分配额外的空间。这使得行或列可拉伸。例如，以下代码将额外的五分之二空间分配给第一列，三分之五分配给第二列：`w.columnconfigure(0,
    weight=2)`'
- en: '`w.columnconfigure(1, weight=3)` |'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The `columnconfigure()` and `rowconfigure()` methods are often used to implement the
    dynamic resizing of widgets, especially on resizing the root window.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`columnconfigure()` 和 `rowconfigure()` 方法通常用于实现小部件的动态调整大小，尤其是在调整根窗口大小时。'
- en: You cannot use the `grid` and `pack` methods together in the same container
    window. If you try doing that, your program will raise a `_tkinter.TclError` error.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在同一个容器窗口中同时使用`grid`和`pack`方法。如果你尝试这样做，你的程序将引发一个`_tkinter.TclError`错误。
- en: The place geometry manager
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理位置管理器
- en: The place geometry manager is the most rarely used geometry manager in Tkinter. Nevertheless,
    it has its uses in that it lets you precisely position widgets within their parent
    frame by using the (*x*,*y*) coordinate system.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 中，位置几何管理器是最不常用的几何管理器。然而，它有其用途，因为它允许您通过使用 (*x*,*y*) 坐标系统来精确地定位其父框架内的小部件。
- en: The place manager can be accessed by using the `place()` method on any standard
    widget.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在任何标准小部件上使用 `place()` 方法来访问位置管理器。
- en: 'The important options for place geometry include the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 空间几何的重要选项包括以下内容：
- en: Absolute positioning (specified in terms of *x*=*N* or *y*=*N*)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对定位（以 *x*=*N* 或 *y*=*N* 的形式指定）
- en: Relative positioning (the key options include `relx`, `rely`, `relwidth`, and
    `relheight`)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对定位（关键选项包括 `relx`、`rely`、`relwidth` 和 `relheight`）
- en: The other options that are commonly used with place include `width` and `anchor`(the
    default is NW).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与位置一起常用的其他选项包括 `width` 和 `anchor`（默认为 NW）。
- en: 'Refer to `1.08.py` for a demonstration of common place options:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考`1.08.py`以演示常见的选项：
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You may not see much of a difference between the absolute and relative positions simply
    by looking at the code or the window frame. However, if you try resizing the window,
    you will observe that the Absolute Placement button does not change its coordinates, while
    the Relative button changes its coordinates and size to accommodate the new size
    of the root window:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看代码或窗口框架，你可能看不出绝对位置和相对位置之间有多大差别。然而，如果你尝试调整窗口大小，你会观察到绝对位置按钮不会改变其坐标，而相对位置按钮则会改变其坐标和大小，以适应根窗口的新尺寸：
- en: '![](img/cb110351-f255-4945-8e08-384c44f9a116.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cb110351-f255-4945-8e08-384c44f9a116.png)'
- en: 'For a complete `place` reference, type the following command in the Python
    shell:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的`位置`引用，请在Python壳中输入以下命令：
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When should you use the place manager?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在何时使用位置管理器？
- en: The place manager is useful in situations where you have to implement custom
    geometry managers, or where the widget placement is decided by the end user.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 地方管理者在需要实现自定义几何管理器或由最终用户决定小部件放置位置的情况下非常有用。
- en: While the pack and grid managers cannot be used together in the same frame,
    the place manager can be used with any geometry manager within the same container
    frame.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然打包管理器和网格管理器不能在同一个框架中一起使用，但位置管理器可以与同一容器框架内的任何几何管理器一起使用。
- en: The place manager is rarely used because, if you use it, you have to worry about the
    exact coordinates. If you make a minor change to a widget, it is very likely that you
    will have to change the *x*,*y* values for other widgets as well, which can be very
    cumbersome. We will use the place manager in [Chapter 7](d70da161-121d-453a-806b-95b71524fb79.xhtml)*,
    Piano Tutor*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 地点管理器很少被使用，因为如果你使用它，你必须担心确切的坐标。如果你对一个部件进行微小的更改，你很可能还需要更改其他部件的 *x*、*y* 值，这可能会非常繁琐。我们将在
    [第7章](d70da161-121d-453a-806b-95b71524fb79.xhtml)*钢琴辅导* 中使用地点管理器。
- en: This concludes our discussion on geometry management in Tkinter.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们关于 Tkinter 中几何管理的讨论的总结。
- en: In this section, you had a look at how to implement the pack, grid, and place geometry
    managers. You also understood the strengths and weaknesses of each geometry manager.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您了解了如何实现pack、grid和place几何管理器。您还了解了每个几何管理器的优缺点。
- en: You learned that pack is suitable for a simple side-wise or top-down widget placement.
    You also learned that the grid manager is best suited for the handling of complex
    layouts. You saw examples of the place geometry manager and explored the reasons
    behind why it is rarely used.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到“pack”布局适合简单的横向或纵向小部件排列。你还了解到网格管理器最适合处理复杂布局。你看到了“place”几何管理器的示例，并探讨了它为何很少被使用的原因。
- en: You should now be able to plan and execute different layouts for your programs using
    these Tkinter geometry managers.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够使用这些 Tkinter 布局管理器来规划和执行你程序的不同布局。
- en: Events and callbacks – adding life to programs
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件和回调 – 为程序注入活力
- en: Now that you have learned how to add widgets to a screen and position them where you
    want, let's turn our attention to the third component of GUI programming.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何将小部件添加到屏幕上并将它们放置到你想要的位置，让我们将注意力转向GUI编程的第三个组成部分。
- en: This addresses the question of how to make widgets functional.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了如何使小部件功能化的问题。
- en: Making widgets functional involves making them responsive to events such as
    the pressing of buttons, the pressing of keys on a keyboard, and mouse clicks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使小工具功能化包括使其对事件做出响应，例如按下按钮、键盘上的按键以及鼠标点击。
- en: This requires associating callbacks with specific events. Callbacks are normally
    associated with specific widget events using command binding rules, which are
    discussed in the following section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要将回调函数与特定事件关联起来。回调函数通常通过命令绑定规则与特定的小部件事件关联，这些规则将在下一节中讨论。
- en: Command binding
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令绑定
- en: The simplest way to add functionality to a button is called **command binding**, whereby
    a callback function is mentioned in the form of `command = some_callback` in the
    widget option. Note that the `command` option is available only for a few selected
    widgets.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 向按钮添加功能的最简单方式被称为**命令绑定**，其中回调函数以`command = some_callback`的形式在部件选项中提及。请注意，`command`选项仅适用于少数选定的部件。
- en: 'Take a look at the following sample code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下示例代码：
- en: '[PRE26]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After defining the preceding callback, we can connect it to, say, a button
    with the `command` option referring to the callback, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了前面的回调函数之后，我们可以将其连接到，比如说，一个按钮，使用带有指向回调函数的`command`选项，如下所示：
- en: '[PRE27]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A **callback** is a function memory reference ( `my_callback` in the preceding
    example) that is called by another function (which is `Button` in the preceding
    example) and that takes the first function as a parameter. Put simply, a callback
    is a function that you provide to another function so that it can calling it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调**是一个函数内存引用（如前例中的`my_callback`），由另一个函数（如前例中的`Button`）调用，并将第一个函数作为参数。简单来说，回调是你提供给另一个函数的函数，以便它可以调用它。'
- en: Note that `my_callback` is passed without parentheses, `()`, from within the
    widget `command` option, because when the callback functions are set it is necessary
    to pass a reference to a function rather than actually call it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`my_callback` 是从 `command` 选项的 widget 中不带括号 `()` 传递的，因为当设置回调函数时，需要传递一个函数的引用而不是实际调用它。
- en: If you add parentheses, `()`, as you would for any normal function, it would
    be called as soon as the program runs. In contrast, the callback is called only
    when an event occurs (the pressing of a button in this case).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你添加括号，即`()`，就像对任何正常函数所做的那样，程序运行时就会立即调用。相比之下，回调函数仅在事件发生时（在这种情况下是按钮的按下）才会被调用。
- en: Passing arguments to callbacks
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将参数传递给回调函数
- en: 'If a callback does not take any argument, it can be handled with a simple function, such
    as the one shown in the preceding code. However, if a callback needs to take arguments,
    we can use the `lambda` function, as shown in the following code snippet:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回调函数不接受任何参数，可以使用一个简单的函数来处理，例如前面代码中所示的那个。然而，如果回调函数需要接受参数，我们可以使用`lambda`函数，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, somewhere else in the code, we define a button with a command callback that
    takes some arguments, as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在代码的另一个地方，我们定义了一个带有命令回调的按钮，该回调函数接受一些参数，如下所示：
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Python borrows a specific syntax from functional programming, called the `lambda`
    function.  The `lambda` function lets you define a single-line, nameless function
    on the fly.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Python 从函数式编程中借鉴了一种特定的语法，称为 `lambda` 函数。`lambda` 函数允许你即时定义一个单行、无名的函数。
- en: 'The format for using `lambda` is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lambda` 的格式如下：
- en: '[PRE30]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here''s an example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE31]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can call the `square` method, as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调用`square`方法，如下所示：
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Limitations of the command option
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令选项的限制
- en: The `command` option that is available with the Button widget and a few other
    widgets is a function that can make the programming of a click-of-a-button event
    easy. Many other widgets do not provide an equivalent command binding option.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮小部件和其他一些小部件中可用的`command`选项是一个可以使编程按钮点击事件变得简单的函数。许多其他小部件不提供等效的命令绑定选项。
- en: By default, the command button binds to the left-click and the spacebar. It
    does not bind to the *Return* key. Therefore, if you bind a button by using the
    `command` function, it will react to the space bar and not the *Return* key. This
    is counter-intuitive for many users. What's worse is that you cannot change the
    binding of the command function easily. The moral is that command binding, though
    a very handy tool, is not flexible enough when it comes to deciding your own bindings.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，命令按钮绑定到左键点击和空格键。它不会绑定到*回车*键。因此，如果你使用`command`函数绑定按钮，它将响应空格键而不是*回车*键。这对许多用户来说是不直观的。更糟糕的是，你不能轻易地更改命令函数的绑定。教训是，虽然命令绑定是一个非常方便的工具，但在决定自己的绑定时，它的灵活性不足。
- en: This brings us to the next method for handling events.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了处理事件的下一个方法。
- en: Event binding
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件绑定
- en: 'Fortunately, Tkinter provides an alternative event binding mechanism called
    `bind()` to let you deal with different events. The standard syntax used to bind
    an event is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Tkinter 提供了一种名为 `bind()` 的替代事件绑定机制，让您能够处理不同的事件。绑定事件的常用语法如下：
- en: '[PRE33]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When an event corresponding to the event description occurs in the widget, it
    calls not only the associated handler, which passes an instance of the event object
    as the argument, but also the details of the event. If there already exists a
    binding for that event for this widget, the old callback is usually replaced with
    the new handler, but you can trigger both the callbacks by passing `add='+'` as
    the last argument.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当小部件中发生与事件描述相对应的事件时，它不仅调用相关的处理程序，并将事件对象的实例作为参数传递，而且还调用事件的详细信息。如果此小部件已存在对该事件的绑定，则通常用新处理程序替换旧回调，但您可以通过将`add='+'`作为最后一个参数传递来触发两个回调。
- en: 'Let''s look at an example of the `bind()` method (code `1.09.py`):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`bind()`方法的示例（代码`1.09.py`）：
- en: '[PRE34]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is a description of the preceding code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: We bind the Frame widget to the `<Button-1>` event, which corresponds to the
    left-click. When this event occurs, it calls the `callback` function, passing an
    object instance as its argument.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 Frame 小部件绑定到 `<Button-1>` 事件，这对应于左键点击。当此事件发生时，它调用 `callback` 函数，并将一个对象实例作为其参数传递。
- en: We define the `callback(event)` function. Note that it takes the `event` object generated
    by the event as an argument.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了`callback(event)`函数。注意，它接受由事件生成的事件对象`event`作为参数。
- en: 'We inspect the event object by using `dir(event)`, which returns a sorted list
    of attribute names for the event object passed to it. This prints the following
    list:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过使用`dir(event)`来检查事件对象，它返回传递给它的事件对象的属性名称的排序列表。这将打印出以下列表：
- en: '[PRE35]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From the attributes list generated by the object, we use two attributes, `event.x`
    and `event.y`, to print the coordinates of the point of click.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从对象生成的属性列表中，我们使用两个属性，`event.x` 和 `event.y`，来打印点击点的坐标。
- en: 'When you run the preceding code (code `1.09.py` ), it produces a window, as
    shown in the following screenshot:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行前面的代码（代码`1.09.py`），它会产生一个窗口，如下面的截图所示：
- en: '![](img/8c500d3b-1712-46dd-b3ca-8e72a994dbc8.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c500d3b-1712-46dd-b3ca-8e72a994dbc8.png)'
- en: 'When you left-click anywhere in the yellow colored frame within the root window, it
    outputs messages to the console. A sample message passed to the console is as
    follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在根窗口中的黄色色框内任意位置进行左键点击时，它会在控制台输出信息。传递到控制台的一个示例信息如下：
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Event patterns
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件模式
- en: In the previous example, you learned how to use the `<Button-1>` event to denote
    a left-click. This is a built-in pattern in Tkinter that maps it to a left-click
    event. Tkinter has an exhaustive mapping scheme that perfectly identifies events
    such as this one.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，你学习了如何使用 `<Button-1>` 事件来表示左键点击。这是 Tkinter 中的一个内置模式，将其映射到左键点击事件。Tkinter
    具有一个详尽的映射方案，可以完美地识别此类事件。
- en: 'Here are some examples to give you an idea of event patterns:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例，以帮助您了解事件模式：
- en: '| **The event pattern** | **The associated event** |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| **事件模式** | **相关事件** |'
- en: '| `<Button-1>` | Left-click of the mouse |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `<Button-1>` | 鼠标左键点击 |'
- en: '| `<KeyPress-B>` |  A keyboard press of the *B* key |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `<KeyPress-B>` |  按下 *B* 键的键盘操作 |'
- en: '| `<Alt-Control-KeyPress- KP_Delete>` | A keyboard press of *Alt* + *Ctrl*
    + *Del* |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `<Alt-Control-KeyPress- KP_Delete>` | 按下 *Alt* + *Ctrl* + *Del* 的键盘操作 |'
- en: 'In general, the mapping pattern takes the following form:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，映射模式具有以下形式：
- en: '[PRE37]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Typically, an event pattern will comprise the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个事件模式将包括以下内容：
- en: '**An event type**: Some common event types include `Button`, `ButtonRelease`, `KeyRelease`,
    `Keypress`, `FocusIn`, `FocusOut`, `Leave` (when the mouse leaves the widget),
    and `MouseWheel`. For a complete list of event types, refer to the `event` types
    section at [http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7).'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件类型**：一些常见的事件类型包括 `Button`、`ButtonRelease`、`KeyRelease`、`Keypress`、`FocusIn`、`FocusOut`、`Leave`（当鼠标离开小部件时）和
    `MouseWheel`。要获取事件类型的完整列表，请参阅[http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M7)中的`event`类型部分。'
- en: '**An event modifier** (optional): Some common event modifiers include `Alt`, `Any`
    (used like `<Any-KeyPress>`), `Control`, `Double` (used like `<Double-Button-1>`
    to denote a double-click of the left mouse button), `Lock`, and `Shift`. For a
    complete list of event modifiers, refer to the `event modifiers`section at [http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6).'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件修饰符**（可选）：一些常见的事件修饰符包括 `Alt`、`Any`（类似于 `<Any-KeyPress>` 使用），`Control`、`Double`（类似于
    `<Double-Button-1>` 表示左鼠标按钮的双击），`Lock` 和 `Shift`。要获取事件修饰符的完整列表，请参阅[http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6](http://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm#M6)中的“事件修饰符”部分。'
- en: '**The event detail** (optional): The mouse event detail is captured by the number
    1 for a left-click and the number 2 for a right-click. Similarly, each key press
    on the keyboard is either represented by the key letter itself (say, *B* in `<KeyPress-B>`)
    or by using a key symbol abbreviated as `keysym`. For example, the up arrow key
    on the keyboard is represented by the `keysym` value of `KP_Up`. For a complete
    `keysym` mapping, refer to [https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm).'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件详情**（可选）：鼠标事件详情通过数字1表示左键点击，数字2表示右键点击。同样，键盘上的每个按键按下都可以由按键字母本身表示（例如，在`<KeyPress-B>`中表示为*B*），或者使用缩写为`keysym`的按键符号。例如，键盘上的向上箭头键由`keysym`值`KP_Up`表示。对于完整的`keysym`映射，请参阅[https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/bind.htm)。'
- en: 'Let''s take a look at a practical example of event binding on widgets (refer
    to code `1.10.py` for the complete working example):'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个在部件上绑定事件的实际例子（完整的工作示例请参考代码 `1.10.py`）：
- en: '![](img/0de95f4d-c377-4f3e-acc0-a22c06c0cda7.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0de95f4d-c377-4f3e-acc0-a22c06c0cda7.png)'
- en: The following is a modified snippet of code; it will give you an idea of commonly
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个修改过的代码片段；它将给你一个关于常见
- en: 'used event bindings:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了事件绑定：
- en: '[PRE38]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Rather than binding an event to a particular widget, you can also bind it to
    the top-level window. The syntax remains the same except that now you call it
    on the root instance of the root window such as `root.bind()`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将事件绑定到特定的控件，您也可以将其绑定到顶级窗口。语法保持不变，只是现在您需要在根窗口的根实例上调用它，例如`root.bind()`。
- en: Binding levels
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定级别
- en: In the previous section, you had a look at how to bind an event to an instance
    of a widget. This can be called an **instance-level binding**.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学习了如何将事件绑定到小部件的实例。这可以被称为**实例级绑定**。
- en: 'However, there may be times when you need to bind events to an entire application. At
    times, you may want to bind an event to a particular class of widget. Tkinter provides
    the following levels of binding options for this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能需要将事件绑定到整个应用程序。在某些情况下，你可能希望将事件绑定到特定类别的窗口小部件。Tkinter为此提供了以下级别的绑定选项：
- en: '**Application-level binding**: Application-level bindings let you use the same binding
    across all windows and widgets of an application as long as any one window of
    the application is in focus. The syntax for application-level bindings is as follows:'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用级绑定**：应用级绑定允许你在应用程序的所有窗口和控件中使用相同的绑定，只要应用程序中的任何一个窗口处于焦点状态。应用级绑定的语法如下：'
- en: '[PRE39]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The typical usage pattern is as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的使用模式如下：
- en: '[PRE40]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Application-level binding here means that, irrespective of the widget that is
    currently under focus, pressing the *F1* key will always trigger the `show_help`
    callback as long as the application is in focus.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在此处的应用级绑定意味着，无论当前聚焦的窗口小部件是什么，只要应用程序处于聚焦状态，按下 *F1* 键总是会触发 `show_help` 回调。
- en: '**Class-level binding**: You can also bind events at a particular class level. This
    is normally used to set the same behavior for all instances of a particular widget
    class. The syntax for class-level binding is as follows:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类级绑定**：您还可以在特定类级别绑定事件。这通常用于为特定小部件类的所有实例设置相同的行为。类级绑定的语法如下：'
- en: '[PRE41]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The typical usage pattern is as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的使用模式如下：
- en: '[PRE42]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding example, all the entry widgets will be bound to the `<Control-V>`
    event, which will call a method named `paste` (event).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，所有条目小部件都将绑定到 `<Control-V>` 事件，这将调用一个名为 `paste` (event) 的方法。
- en: Event propagation
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 事件传播
- en: Most keyboard and mouse events occur at the operating system level. The event
    propagates hierarchically upward from its source until it finds a window that
    has the corresponding binding. The event propagation does not stop there. It propagates
    itself upwards, looking for other bindings from other widgets, until it reaches
    the root window. If it does reach the root window and no bindings are discovered
    by it, the event is disregarded.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数键盘和鼠标事件发生在操作系统级别。事件从其源头按层次向上传播，直到找到具有相应绑定的窗口。事件的传播并不会停止在这里。它会继续向上传播，寻找来自其他小部件的其他绑定，直到达到根窗口。如果它达到了根窗口并且没有发现任何绑定，则该事件将被忽略。
- en: Handling widget-specific variables
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理特定小部件的变量
- en: You need variables with a wide variety of widgets. You likely need a string
    variable to track what the user enters into the entry widget or text widget. You
    most probably need Boolean variables to track whether the user has checked off
    the Checkbox widget. You need integer variables to track the value entered in
    a Spinbox or Slider widget.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要具有广泛多样小部件的变量。你很可能需要一个字符串变量来跟踪用户输入到输入小部件或文本小部件中的内容。你很可能需要一个布尔变量来跟踪用户是否勾选了复选框小部件。你需要整数变量来跟踪在旋转框或滑块小部件中输入的值。
- en: In order to respond to changes in widget-specific variables, Tkinter offers
    its own `variable` class. The variable that you can use to track widget-specific
    values must be subclassed from this Tkinter `variable` class. Tkinter offers some
    commonly used predefined variables. They are `StringVar`, `IntVar`, `BooleanVar`,
    and `DoubleVar`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对小部件特定变量的变化，Tkinter 提供了自己的 `variable` 类。您可以使用从该 Tkinter `variable` 类派生的变量来跟踪小部件特定的值。Tkinter
    提供了一些常用的预定义变量。它们是 `StringVar`、`IntVar`、`BooleanVar` 和 `DoubleVar`。
- en: You can use these variables to capture and play with the changes in the values
    of variables from within your callback functions. You can also define your own
    variable type, if required.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些变量在回调函数内部捕获并处理变量值的变化。如果需要，您还可以定义自己的变量类型。
- en: 'Creating a Tkinter variable is simple. You simply have to call the constructor:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Tkinter变量很简单。你只需调用构造函数：
- en: '[PRE43]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once the variable is created, you can use it as a widget option, as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 变量创建后，您可以用作小部件选项，如下所示：
- en: '[PRE44]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Additionally, Tkinter provides access to the values of variables via the `set()`
    and `get()` methods, as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Tkinter 通过 `set()` 和 `get()` 方法提供了访问变量值的途径，如下所示：
- en: '[PRE45]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A demonstration of the Tkinter `variable` class is available in the `1.11.py`
    code file. The code generates a window, as shown in the following screenshot:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter `变量` 类的演示可以在 `1.11.py` 代码文件中找到。该代码生成一个窗口，如下面的截图所示：
- en: '![](img/35173189-b313-4e3b-9e89-2ca39d7eafeb.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/35173189-b313-4e3b-9e89-2ca39d7eafeb.png)'
- en: 'This concludes our brief discussion on events and callbacks. Here''s a brief
    summary of the things that we discussed:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对事件和回调的简要讨论。以下是我们所讨论内容的简要总结：
- en: Command binding, which is used to bind simple widgets to certain functions
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令绑定，用于将简单的小部件绑定到特定函数
- en: Event binding using the `widget.bind_all`(`event`, `callback`, `add=None`) method
    to bind keyboard and mouse events to your widgets and invoke callbacks when certain
    events occur
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`widget.bind_all`(`event`, `callback`, `add=None`)方法进行事件绑定，将键盘和鼠标事件绑定到您的控件上，并在特定事件发生时调用回调函数
- en: The passing of extra arguments to a callback using the `lambda` function
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `lambda` 函数向回调传递额外的参数
- en: The binding of events to an entire application or to a particular class of widget
    by using `bind_all()` and `bind_class()`
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `bind_all()` 和 `bind_class()` 将事件绑定到整个应用程序或特定类别的控件
- en: Using the Tkinter `variable` class to set and get the values of widget-specific
    variables
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tkinter 的 `variable` 类来设置和获取特定小部件的变量值
- en: In short, you now know how to make your GUI program responsive to end-user requests!
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你现在已经知道了如何让你的图形用户界面程序对最终用户请求做出响应！
- en: Event unbinding and virtual events
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件解绑和虚拟事件
- en: 'In addition to the bind method that you previously saw, you might find the following
    two event-related options useful in certain cases:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你之前看到的绑定方法之外，你可能会在某些情况下发现以下两个与事件相关的选项很有用：
- en: '**Unbind:** Tkinter provides the unbind option to undo the effect of an earlier binding.
    The syntax is as follows:'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解绑:** Tkinter 提供了解绑选项来撤销之前绑定的效果。语法如下：'
- en: '[PRE46]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following are some examples of its usage:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其用法的示例：
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Virtual events**: Tkinter also lets you create your own events. You can give these
    virtual events any name that you want. For example, let''s suppose that you want
    to create a new event called `<<commit>>`, which is triggered by the *F9* key.
    To create this virtual event on a given widget, use the following syntax:'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟事件**：Tkinter 还允许你创建自己的事件。你可以为这些虚拟事件命名任何你想要的名称。例如，假设你想创建一个名为 `<<commit>>`
    的新事件，该事件由 *F9* 键触发。要在指定的小部件上创建此虚拟事件，请使用以下语法：'
- en: '[PRE48]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can then bind `<<commit>>` to a callback by using a normal `bind()` method,
    as follows:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用常规的 `bind()` 方法将 `<<commit>>` 绑定到一个回调，如下所示：
- en: '[PRE49]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Other event-related methods can be accessed by typing the following line in
    the Python Terminal:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 其他与事件相关的方法可以通过在Python终端中输入以下行来访问：
- en: '[PRE50]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now that you are ready to delve into real application development with Tkinter,
    let's spend some time exploring a few custom styling options that Tkinter offers.
    We will also have a look at some configuration options that are commonly used
    with the root window.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好使用 Tkinter 深入实际应用开发，让我们花些时间探索 Tkinter 提供的一些自定义样式选项。我们还将查看一些与根窗口常用的一些配置选项。
- en: Doing it in style
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以风格化的方式完成
- en: So far, we have relied on Tkinter to provide specific platform-based styling
    for our widgets. However, you can specify your own styling of widgets, such as
    their color, font size, border width, and relief. A brief introduction to styling
    features that are available in Tkinter is supplied in the following section.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖Tkinter为我们的小部件提供特定平台的样式。然而，您可以指定您自己的小部件样式，例如它们的颜色、字体大小、边框宽度和浮雕效果。以下章节提供了Tkinter中可用的样式功能的简要介绍。
- en: 'You may recall that we can specify widget options at the time of its instantiation, as
    follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得，我们可以在实例化小部件时指定其选项，如下所示：
- en: '[PRE51]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Alternatively, you can specify the widget options by using `configure()` in
    the following way:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过以下方式使用 `configure()` 来指定小部件选项：
- en: '[PRE52]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Styling options are also specified as options to the widgets either at the time
    of creating the widgets, or later by using the `configure` option.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 样式选项也可以作为小部件的选项来指定，无论是在创建小部件时，还是通过使用`configure`选项来稍后指定。
- en: Specifying styles
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定样式
- en: Under the purview of styling, we will cover how to apply different colors, fonts, border
    widths, reliefs, cursors, and bitmap icons to widgets.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式管理的范畴内，我们将介绍如何将不同的颜色、字体、边框宽度、浮雕效果、光标和位图图标应用到小部件上。
- en: 'First, let''s see how to specify the color options for a widget. You can specify
    the following two types of color for most widgets:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何指定小部件的颜色选项。对于大多数小部件，你可以指定以下两种类型的颜色：
- en: The background color
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景颜色
- en: The foreground color
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前景颜色
- en: You can specify the color by using hexadecimal color codes for the proportion
    of red(*r*), green(*g*), and blue(*b*). The commonly used representations are
    `#rgb` (4 bits), `#rrggbb` (8 bits), and `#rrrgggbbb` (12 bits).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用红色(*r*)、绿色(*g*)和蓝色(*b*)的十六进制颜色代码来指定颜色。常用的表示方法有`#rgb`（4位）、`#rrggbb`（8位）和`#rrrgggbbb`（12位）。
- en: For example, `#fff` is white, `#000000` is black, `#f00` is red (R=`0xf`, G=`0x0`
    , B=`0x0` ), `#00ff00` is green (R=`0x00`, G=`0xff`, B=`0x00`), and `#000000fff`
    is blue (R=`0x000` , G=`0x000` , B=`0xfff` ).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`#fff` 是白色，`#000000` 是黑色，`#f00` 是红色（R=`0xf`，G=`0x0`，B=`0x0`），`#00ff00` 是绿色（R=`0x00`，G=`0xff`，B=`0x00`），而
    `#000000fff` 是蓝色（R=`0x000`，G=`0x000`，B=`0xfff`）。
- en: Alternatively, Tkinter provides mapping for standard color names. For a list
    of predefined named colors, visit [http://wiki.tcl.tk/37701](http://wiki.tcl.tk/37701)
    or [http://wiki.tcl.tk/16166](http://wiki.tcl.tk/16166).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，Tkinter 提供了标准颜色名称的映射。要查看预定义的命名颜色列表，请访问 [http://wiki.tcl.tk/37701](http://wiki.tcl.tk/37701)
    或 [http://wiki.tcl.tk/16166](http://wiki.tcl.tk/16166).
- en: 'Next, let''s have a look at how to specify fonts for our widgets. A font can
    be represented as a string by using the following string signature:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何为我们的小部件指定字体。字体可以通过以下字符串签名表示为一个字符串：
- en: '[PRE53]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The elements of the preceding syntax can be explained as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法的元素可以解释如下：
- en: '`font family`: This is the complete font family long name. It should preferably
    be in lowercase, such as `font="{nimbus roman} 36 bold italic"`.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字体族`: 这是指完整的字体族长名称。它最好使用小写，例如 `font="{nimbus roman} 36 bold italic"`。'
- en: '`fontsize`: This is in the printer''s point unit (`pt`) or pixel unit (`px`).'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`字体大小`: 这是以打印机点单位（`pt`）或像素单位（`px`）表示的。'
- en: '`fontstyle`: This is a mix of normal/bold/italic and underline/overstrike.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fontstyle`: 这是一种普通/粗体/斜体和下划线/删除线的混合。'
- en: 'The following are examples that illustrate the method of specifying fonts:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些说明指定字体方法的示例：
- en: '[PRE54]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If you set a Tkinter dimension in a plain integer, the measurements take place
    in pixel units. Alternatively, Tkinter accepts four other measurement units, which
    are `m`(millimeters), `c`(centimeters), `i`(inches), and `p`(printer's points,
    which are about 1/72").
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 Tkinter 的尺寸设置为普通整数，则测量将以像素为单位进行。或者，Tkinter 还接受其他四种测量单位，分别是 `m`（毫米）、`c`（厘米）、`i`（英寸）和
    `p`（打印点，大约为 1/72")。
- en: 'For instance, if you want to specify the wrap length of a button in terms of
    a printer''s point, you can specify it as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想以打印机的点为单位指定按钮的换行长度，你可以这样指定：
- en: '[PRE55]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The default border width for most Tkinter widgets is *2* px. You can change
    the border width for widgets by specifying it explicitly, as shown in the following
    line:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 大多数小部件的默认边框宽度为 *2* 像素。您可以通过明确指定来更改小部件的边框宽度，如下所示行所示：
- en: '[PRE56]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The relief style of a widget refers to the difference between the highest and
    lowest elevations in a widget. Tkinter offers six possible relief styles—`flat`,
    `raised`, `sunken`, `groove`, `solid`, and `ridge`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的浮雕样式指的是小部件中最高和最低海拔之间的差异。Tkinter提供了六种可能的浮雕样式——`flat`、`raised`、`sunken`、`groove`、`solid`和`ridge`：
- en: '[PRE57]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Tkinter lets you change the style of the mouse cursor when you hover over a particular
    widget. This is done by using the option cursor, as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 允许你在鼠标悬停在特定小部件上时更改鼠标光标的样式。这可以通过使用 cursor 选项来完成，如下所示：
- en: '[PRE58]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For a complete list of available cursors, refer to [https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的光标完整列表，请参阅[https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/cursors.htm).
- en: 'Though you can specify the styling options at each widget level, sometimes
    it may be cumbersome to do so individually for each widget. Widget-specific styling
    has the following disadvantages:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在每个小部件级别指定样式选项，但有时对每个小部件单独进行操作可能会感到繁琐。小部件特定的样式有以下缺点：
- en: It mixes logic and presentation into one file, making the code bulky and difficult
    to manage
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将逻辑和展示合并到一个文件中，使得代码变得庞大且难以管理
- en: Any change in styling has to be applied to each widget individually
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何样式更改都必须单独应用于每个小部件
- en: It violates the don't repeat yourself (DRY) principle of effective coding, as
    you keep specifying the same style for a large number of widgets
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它违反了有效编码的“不要重复自己”（DRY）原则，因为你一直在为大量的小部件指定相同的样式
- en: Fortunately, Tkinter now offers a way to separate presentation from logic and
    specify styles in what is called the **external option database**. This is just
    a text file where you can specify common styling options.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Tkinter 现在提供了一种将展示与逻辑分离并在所谓的 **外部选项数据库** 中指定样式的途径。这只是一个文本文件，您可以在其中指定常见的样式选项。
- en: 'A typical option database text file looks like this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的选项数据库文本文件看起来是这样的：
- en: '[PRE59]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In its simplest use, the asterisk (`*****`) symbol here means that the particular
    style is applied to all the instances of the given widget. For a more complex
    usage of the asterisk in styling, refer to [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的用法中，这里的星号（`*****`）符号表示该特定样式应用于给定小部件的所有实例。对于星号在样式中的更复杂用法，请参阅[http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/resource-lines.html)。
- en: 'These entries are placed in an external text (`.txt`) file. To apply this styling
    to a particular piece of code, you can simply call it by using the `option_readfile()`call
    early in your code, as shown here:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条目被放置在一个外部文本（`.txt`）文件中。要将这种样式应用到特定的代码片段上，你可以在代码中早期使用`option_readfile()`函数来调用它，如下所示：
- en: '[PRE60]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s have a look at an example (see code `1.12.py` ) of using this external
    styling text file in a program:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用这个外部样式文本文件在程序中的示例（见代码 `1.12.py`）：
- en: '[PRE61]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following is a description of the preceding code:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: The code connects to an external styling file called `optionDB.txt` that defines
    common styling for the widgets.
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码连接到一个名为 `optionDB.txt` 的外部样式文件，该文件定义了小部件的通用样式。
- en: The next segment of code creates a Text widget and specifies styling on the widget
    level.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个代码段创建了一个文本小部件，并在小部件级别指定了样式。
- en: The next segment of code has several buttons, all of which derive their styling
    from the centralized `optionDB.txt` file. One of the buttons also defines a custom
    cursor.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一段代码包含几个按钮，所有这些按钮的样式都源自集中式的`optionDB.txt`文件。其中一个按钮还定义了一个自定义的光标。
- en: 'Specifying attributes such as font sizes, the border width, the widget width,
    the widget height, and padding in absolute numbers, as we have done in the preceding example,
    can cause some display variations between different operating systems such as
    Ubuntu, Windows, and Mac respectively, as shown in the following screenshot. This
    is due to differences in the rendering engines of different operating systems:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在绝对数值中指定属性，例如字体大小、边框宽度、小部件宽度、小部件高度和填充，正如我们在前面的示例中所做的那样，这可能会导致在不同操作系统之间（如Ubuntu、Windows和Mac）出现一些显示差异，如下面的截图所示。这是由于不同操作系统的渲染引擎存在差异：
- en: '![](img/9a6b31ec-8904-4a4a-ab9d-fad2dcd75293.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a6b31ec-8904-4a4a-ab9d-fad2dcd75293.png)'
- en: When deploying cross-platform, it is better to avoid specifying attribute sizes
    in absolute numbers. It is often the best choice to let the platform handle the
    attribute sizes.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署跨平台应用时，最好避免使用绝对数值来指定属性大小。通常，让平台处理属性大小是最佳选择。
- en: Some common root window options
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些常见的根窗口选项
- en: 'Now that we are done discussing styling options, let''s wrap up with a discussion
    on some commonly used options for the root window:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论完了样式选项，让我们来总结一下根窗口常用的一些选项：
- en: '| **Method**  | **Description** |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| **方法**  | **描述** |'
- en: '| `*root.geometry(''142x280+150+200'')` | You can specify the size and location
    ofa root window by using a string of the`widthxheight` + `xoffset` + `yoffset`
    form. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `*root.geometry(''142x280+150+200'')` | 您可以通过使用`widthxheight` + `xoffset`
    + `yoffset`格式的字符串来指定根窗口的大小和位置。 |'
- en: '| `self.root.wm_iconbitmap(''mynewicon.ico'')` OR`self.root.iconbitmap(''mynewicon.ico
    '')` | This changes the title bar icon to somethingthat is different from the
    default Tk icon. |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `self.root.wm_iconbitmap(''mynewicon.ico'')` OR `self.root.iconbitmap(''mynewicon.ico
    '')` | 这将标题栏图标更改为与默认Tk图标不同的图标。 |'
- en: '| `root.overrideredirect(1)` | This removes the root border frame. It hides
    the frame that contains the minimize,'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '| `root.overrideredirect(1)` | 这将移除根边框。它隐藏包含最小化按钮的框架。'
- en: maximize, and close buttons. |
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化，和关闭按钮。 |
- en: 'Let''s explain these styling options in more detail:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释这些样式选项：
- en: '`root.geometry(''142x280+150+200'')`: Specifying the geometry of the root window
    limits the launch size of the root window. If the widgets do not fit in the specified
    size, they get clipped from the window. It is often better not to specify this
    and let Tkinter decide this for you.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`root.geometry(''142x280+150+200'')`: 指定根窗口的几何形状限制了根窗口的启动大小。如果小部件无法适应指定的尺寸，它们将被从窗口中裁剪掉。通常最好不指定此参数，让Tkinter为你决定。'
- en: '`self.root.wm_iconbitmap(''my_icon.ico'')` or `self.root.iconbitmap(''my_icon.ico
    '')`: This option is only applicable to Windows. Unix-based operating systems
    do not display the title bar icon.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.root.wm_iconbitmap(''my_icon.ico'')` 或 `self.root.iconbitmap(''my_icon.ico
    '')`: 此选项仅适用于 Windows。基于 Unix 的操作系统不会显示标题栏图标。'
- en: Getting interactive help
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取交互式帮助
- en: This section applies not only for Tkinter, but also for any Python object for
    which you may need help.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不仅适用于Tkinter，也适用于任何可能需要帮助的Python对象。
- en: 'Let''s say that you need a reference to the Tkinter pack geometry manager.
    You can get interactive help in your Python interactive shell by using the help
    command, as shown in the following command lines:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要参考 Tkinter 的 pack 布局管理器。你可以在 Python 的交互式 shell 中通过使用 help 命令来获取交互式帮助，如下所示：
- en: '[PRE62]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This provides detailed help documentation of all the methods defined under the `Pack`
    class in Tkinter.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了 Tkinter 中定义在 `Pack` 类下所有方法的详细帮助文档。
- en: 'You can similarly receive help for all the other individual widgets. For instance,
    you can check the comprehensive and authoritative help documentation for the Label widget
    in the interactive shell by typing the following command:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 您同样可以为所有其他单个小部件获得帮助。例如，您可以通过在交互式外壳中输入以下命令来查看标签小部件的全面且权威的帮助文档：
- en: '[PRE63]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This provides a list of the following:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一份以下内容的列表：
- en: All the methods defined in the `Label` class
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有在`Label`类中定义的方法
- en: All the standard and widget-specific options for the `Label` widget
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Label`小部件的所有标准和小部件特定选项'
- en: All the methods inherited from other classes
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有从其他类继承的方法
- en: Finally, when in doubt regarding a method, look into the source code of Tkinter, which
    is located at `<location-of-python-installation>\lib\`. For instance, the Tkinter
    source code is located in the `/usr/lib/python3.6.3/tkinter` directory on my Linux
    Mint operating system. You might also find it useful to look at the source code
    implementation of various other modules, such as the `color chooser`, `file dialogs`,
    and `ttk` modules, and the other modules located in the aforementioned directory.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当对某个方法不确定时，请查看Tkinter的源代码，它位于`<Python安装位置>\lib\`。例如，在我的Linux Mint操作系统上，Tkinter的源代码位于`/usr/lib/python3.6.3/tkinter`目录中。您还可能发现查看其他模块的源代码实现很有用，例如`颜色选择器`、`文件对话框`和`ttk`模块，以及其他位于上述目录中的模块。
- en: Summary
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This brings us to end of this chapter. This chapter aimed to provide a high-level
    overview of Tkinter. We worked our way through all the important concepts that
    drive a Tkinter program.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这章内容到此结束。本章旨在提供一个Tkinter的高级概述。我们逐一探讨了驱动Tkinter程序的所有重要概念。
- en: You now know what a root window is and how to set it up. You also know the 21
    core Tkinter widgets and how to set them up. We also had a look at how to lay out
    our programs by using the `Pack`, `Grid`, and `Place` geometry managers, and how
    to make our programs functional by using `events` and `callbacks`. Finally, you
    saw how to apply custom styles to GUI programs.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道了什么是根窗口以及如何设置它。你也了解了21个核心Tkinter小部件以及如何设置它们。我们还探讨了如何使用`Pack`、`Grid`和`Place`布局管理器来布局我们的程序，以及如何通过使用`events`和`callbacks`来使我们的程序具有功能性。最后，你看到了如何将自定义样式应用到GUI程序中。
- en: To summarize, we can now start thinking about making interesting, functional,
    and stylish GUI programs with Tkinter! In the next chapter, we will build our
    first real application - a Text editor.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们现在可以开始思考如何使用 Tkinter 制作有趣、实用且时尚的图形用户界面程序了！在下一章中，我们将构建我们的第一个真实应用程序——一个文本编辑器。
- en: QA section
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: 'Before you proceed to the next chapter, make sure you can answer these questions
    to your satisfaction:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读下一章之前，请确保你能满意地回答这些问题：
- en: What is a root window?
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是根窗口？
- en: What is the main loop?
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是主循环？
- en: How do you create a root window?
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何创建一个根窗口？
- en: What are widgets? How do you create widgets in Tkinter?
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件是什么？如何在Tkinter中创建小部件？
- en: Can you list or identify all available widgets in Tkinter?
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能列出或识别出 Tkinter 中所有可用的控件吗？
- en: What are geometry managers used for?
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何管理器有哪些用途？
- en: Can you name all the available geometry managers in Tkinter?
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你能列出 Tkinter 中所有可用的几何管理器吗？
- en: What are events in a GUI program?
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GUI程序中，什么是事件？
- en: What are callbacks? How are callbacks different from regular functions?
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是回调函数？回调函数与普通函数有何不同？
- en: How do you apply callbacks to an event?
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何将回调应用于事件？
- en: How do you style widgets using styling options?
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你如何使用样式选项来设置小部件的样式？
- en: What are the common configuration options for the root window?
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根窗口有哪些常见的配置选项？
- en: Further reading
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: It would be a good idea to modify the examples from this chapter to lay out
    the widgets in different ways or to tweak the code to function in other ways to
    get your feet wet.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 将本章的示例进行修改，以不同的方式布局小部件，或者调整代码以实现其他功能，这样可以帮助你熟悉操作。
- en: 'We recommend that you take a look at the documentation for all three geometry
    managers in your Python shell using the following commands:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用以下命令在您的Python shell中查看所有三个几何管理器的文档：
- en: '[PRE64]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can also find an excellent documentation of Tkinter at [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在[http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/index.html)找到关于Tkinter的优秀文档。
