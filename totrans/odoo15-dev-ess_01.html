<html><head></head><body><div><div><h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor119"/></em><a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>: Extending Modules</h1>
			<p>One of Odoo's most powerful capabilities is being able to add features without directly touching the code of the extended modules. This allows for clean feature extensions that are isolated in their own code components. Extending modules can be achieved through inheritance mechanisms, which work as modification layers on top of existing objects. These modifications can happen at every level – including the model, view, and business logic levels. Instead of directly modifying an existing module, we will create a new module by adding a layer on top of the existing one with the intended modifications.</p>
			<p>The previous chapter guided us through creating a new app from scratch. In this chapter, we will learn how to create modules that extend existing apps or modules and use existing core or community features.</p>
			<p>To achieve this, we will cover the following topics:</p>
			<ul>
				<li>Learning project – extending the Library app</li>
				<li>Adding a new field to an existing model</li>
				<li>Extending models using classic in-place extension</li>
				<li>More model inheritance mechanisms</li>
				<li>Extending views and data</li>
				<li>Extending web pages</li>
			</ul>
			<p>By the end of this chapter, you should be able to create Odoo modules that extend existing apps. You will be able to add modifications to any of the several application components: models, views, business logic code, web page controllers, and web page templates.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor120"/>Technical requirements</h1>
			<p>For this chapter, you will need an Odoo server that you can command from a terminal session.</p>
			<p>The code in this chapter depends on the code that we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>. You should have that code in your add-ons path and have a database with the <code>library_app</code> module installed. </p>
			<p>This chapter adds the <code>library_member</code> add-on module to our project. The corresponding code can be found in this book's GitHub repository, <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>, in the <code>ch04</code> directory.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor121"/>Learning project – extending the Library app</h1>
			<p>In <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, we created the initial module for the <code>library_member</code>.</p>
			<p>These are<a id="_idIndexMarker289"/> the features we must provide:</p>
			<ul>
				<li>Library books can be available to be borrowed or not. This information should be shown in the book form and on the website's catalog page.</li>
				<li>Some library member master data, along with the library card number, plus personal data, such as name, address, and email.</li>
				<li>We would like to provide members with the messaging and social features that are available on the borrowing form, including the planned activities widget, to allow for better collaboration.</li>
			</ul>
			<p>Later, we plan to introduce a feature that allows members to borrow books from the library, but this is outside our scope for now. This will happen gradually throughout the next few chapters.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Books</h2>
			<p>The<a id="_idIndexMarker290"/> following is a summary of the technical changes we must introduce to books:</p>
			<ul>
				<li>Add an <code>Is Available?</code> field. For now, it will be managed manually, but this can be automated later.</li>
				<li>Extend the ISBN validation logic to also support the older 10-digit ISBN format.</li>
				<li>Extend the web catalog page to identify unavailable books and to allow the user to only filter through available books.</li>
			</ul>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>Members</h2>
			<p>The following <a id="_idIndexMarker291"/>is a summary of the technical changes to introduce to library members:</p>
			<ul>
				<li>Add a new model to store the person's name, card number, and contact information, such as email and address.</li>
				<li>Add the social discussion and planned activities features.</li>
			</ul>
			<p>To start working on this extension module, we should create the <code>library_member</code> directory alongside <code>library_app</code> and add two files—an empty <code>__init__.py</code> file and a <code>__manifest__.py</code> file with the following content:</p>
			<pre>{
    "name": "Library Members",
    "license": "AGPL-3",
    "description": "Manage members borrowing books.",
    "author": "Daniel Reis",
    "depends": ["library_app"],
    "application": False,
}</pre>
			<p>Now, we are ready to start working on the features. Our first task is a frequent and simple request – adding a new field to an existing model. This happens to be a great way to introduce Odoo's inheritance mechanisms.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor124"/>Adding a new field to an existing model</h1>
			<p>Our<a id="_idIndexMarker292"/> first task is to add the <code>is_available</code> Boolean field to the book model. For now, this will be a simple editable field, but at a later stage, we can imagine changing it to be automatic, based on books that have been borrowed and returned.</p>
			<p>To extend an existing model, we must use a Python class with the <code>_inherit</code> attribute, identifying the model being extended. The new class inherits all of the features of the parent Odoo model, and we only need to declare the modifications to introduce. We can think of this type of inheritance as getting a reference for the existing model and making in-place changes to it.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>Adding new fields with the in-place model extension</h2>
			<p>Extending<a id="_idIndexMarker293"/> models is done through Python classes by using the Odoo-specific inheritance mechanism that's declared using the <code>_inherit</code> class attribute. This <code>_inherit</code> class attribute identifies the model to be extended. The declared calls capture all the features of the inherited Odoo model and are ready for the modifications to introduce to be declared.</p>
			<p>The coding style guidelines recommend having a Python file for each model, so we will add a <code>library_member/models/library_book.py</code> file that extends the original model. Let's start by adding the <code>__init__.py</code> code files that are needed for that file to be included in the module:</p>
			<ol>
				<li>Add the <code>library_member/__init__.py</code> file, making the code that's in the <code>models</code> subdirectory known:<pre>from . import models</pre></li>
				<li>Add the <code>library_member/models/__init__.py</code> file, importing the used code files inside that subdirectory:<pre>from . import library_book</pre></li>
				<li>Create the <code>library_member/models/library_book.py</code> file by extending the <code>library.book</code> model:<pre>from odoo import fields, models
 
class Book(models.Model): 
    _inherit = "library.book" 
    is_available = fields.Boolean("Is Available?")</pre></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker294"/>used the <code>_inherit</code> class attribute to declare the model to extend. Notice that we didn't use any other class attributes, not even <code>_name</code>. This is not needed unless we want to make changes to any of them.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><code>_name</code> is the model identifier; what happens if we try to change it? This is allowed, and doing so creates a new model that is a copy of the inherited one. This is called <strong class="bold">prototype inheritance</strong> and it will be discussed later in this chapter, in the <em class="italic">Copying models with prototype inheritance</em> section.</p>
			<p>We can think of this as getting a reference to a model definition living in a central registry and making in-place changes to it. This can include adding fields, modifying existing fields, modifying model class attributes, or adding methods with new business logic.</p>
			<p>To add the new model fields to the database tables, we must install the add-on module. If everything goes as expected, the newly added fields should be visible if we go to the <code>library.book</code> model.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor126"/>Adding a field to the Form view</h2>
			<p>Forms, lists, and <a id="_idIndexMarker295"/>search views are defined using XML data structures. To extend views, we need a way to modify the XML. This means locating XML elements and then introducing modifications at those points.</p>
			<p>The XML data record for inherited views is similar to the ones for regular views, with an additional <code>inherit_id</code> attribute for referring to the view being extended.</p>
			<p>We are going to extend the book view to add the <code>is_available</code> field.</p>
			<p>The first<a id="_idIndexMarker296"/> thing we need to do is find the XML ID for the view to be extended. We can find that by looking up the view in the <code>library_app.view_form_book</code>.</p>
			<p>While we're there, we should also locate the XML element to insert the changes. We will choose to add the <code>Is Available?</code> field after the <code>ISBN</code> field. The element to use can usually be identified by its <code>name</code> attribute. In this case, it's <code>&lt;field name="isbn" /&gt;</code>.</p>
			<p>When adding the XML file to extend the <code>Partner</code> views, <code>views/book_view.xml</code>, it should have the following content:</p>
			<pre>&lt;odoo&gt;
  &lt;record id="view_form_book_extend" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Book: add Is Available? 
      field&lt;/field&gt;
    &lt;field name="model"&gt;library.book&lt;/field&gt;
<strong class="bold">    &lt;field name="inherit_id" ref=</strong>
<strong class="bold">      "library_app.view_form_book"/&gt;</strong>
    &lt;field name="arch" type="xml"&gt;
<strong class="bold">      &lt;field name="isbn" position="after"&gt;</strong>
<strong class="bold">        &lt;field name="is_available" /&gt;</strong>
<strong class="bold">      &lt;/field&gt;</strong>
    &lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo&gt;</pre>
			<p>The inheritance-specific elements are highlighted in the preceding code. The <code>inherit_id</code> record field identifies the view to be extended while using the <code>ref</code> attribute to refer to<a id="_idIndexMarker297"/> its external identifier.</p>
			<p>The <code>arch</code> field contains the element for declaring the extension point to use, the <code>&lt;field&gt;</code> element with <code>name="isbn"</code>, and the position of the new elements to add, which is <code>position="after"</code> in this case. Inside the extension elements, we have the XML to add, which is the <code>is_available</code> field in this case.</p>
			<p>This is what the book form will look like after creating this extension:</p>
			<div><div><img src="img/Figure_4.1_B16119.jpg" alt="Figure 4.1 – The book form with the &quot;Is Available?&quot; field added&#13;&#10;" width="1077" height="622"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The book form with the "Is Available?" field added</p>
			<p>We just went through the inheritance basics and added a new field for the model and view layers. Next, we will learn more about the model extension approach we used; that is, classic inheritance.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor127"/>Extending models using classic in-place extension</h1>
			<p>We<a id="_idIndexMarker298"/> can think of the classic model inheritance as an in-place extension. When a Python class with the <code>_inherit</code> attribute is declared, it gets a reference to the corresponding model definition, to then add extensions to it. The model definition is stored in the Odoo model registry and is available for us to add further modifications to it.</p>
			<p>Now, let's learn how to use this for frequent extension use cases: modifying the attributes of an existing field and extending Python methods to add or modify business logic.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor128"/>Incrementally modifying existing fields</h2>
			<p>When we're <a id="_idIndexMarker299"/>extending a model, existing fields can be modified incrementally. This means that we only need to define the field attributes to change or add.</p>
			<p>We will make two changes to the book fields that were created in the <code>library_app</code> module:</p>
			<ul>
				<li>On the <code>isbn</code> field, add a help tooltip explaining that we support both 10- and 13-digit ISBNs, with the latter being implemented in the following section.</li>
				<li>On the <code>publisher_id</code> field, add a database index to it to make searching on it more efficient.</li>
			</ul>
			<p>We should edit the <code>library_member/models/library_book.py</code> file and add the following lines to the <code>library.book</code> model:</p>
			<pre># class Book(models.Model): 
    isbn = fields.Char(help="Use a valid ISBN-13 or 
      ISBN-10.")
    publisher_id = fields.Many2one(index=True)</pre>
			<p>This modifies the fields with the specified attributes, leaving all the other attributes that were not explicitly mentioned unmodified.</p>
			<p>Once we upgrade the module, going to the book form and hovering the mouse pointer over the ISBN field will show the tooltip message that was added to the field. The effect of <code>index=True</code> is harder to notice, but it can be seen in the field definition, which can be <a id="_idIndexMarker300"/>accessed from the <strong class="bold">Developer Tools</strong> menu by choosing the <strong class="bold">View Fields</strong> option, or from the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Database Structure</strong> | <strong class="bold">Models</strong> menu:</p>
			<div><div><img src="img/Figure_4.2_B16119.jpg" alt="Figure 4.2 – The Publisher field with the index enabled&#13;&#10;" width="1045" height="654"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – The Publisher field with the index enabled</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>Extending Python methods to add features to the business logic</h2>
			<p>The <a id="_idIndexMarker301"/>business logic that's coded in Python methods can also be extended. For this, Odoo uses the Python object inheritance mechanism to extend the inherited class behavior.</p>
			<p>As a practical example, we will extend the library book ISBN validation logic. The logic provided by the base Library app validates modern 13-digit ISBNs. But some older titles might come with a 10-digit ISBN. The <code>_check_isbn()</code> method should be extended to also validate these cases.</p>
			<p>Edit the <code>library_member/models/library_book.py</code> file by adding the following <a id="_idIndexMarker302"/>code:</p>
			<pre># class Book(models.Model):
    def _check_isbn(self):
        self.ensure_one()
        digits = [int(x) for x in self.isbn if x.isdigit()]
        if len(digits) == 10:
            ponderators = [1, 2, 3, 4, 5, 6, 7, 8, 9]
            total = sum(
                a * b for a, b in zip(digits[:9], 
                ponderators)
            )
            check = total % 11
            return digits[-1] == check
        else:
            return super()._check_isbn()</pre>
			<p>To extend a method, in the inherited class, we define a method with the same name – <code>_check_isbn()</code>, in this case. This method should, at some point, use <code>super()</code> to call the corresponding method that was implemented in the parent class. In this example, the particular code that was used was <code>super()._check_isbn()</code>.</p>
			<p>In this method extension, we added our logic before the <code>super()</code> call, running the parent class code. It checks whether the ISBN is 10 digits long. In that case, the added ISBN-10 validation logic is executed. Otherwise, it falls back to the original ISBN checking logic, handling the 13-digit case.</p>
			<p>We can try this, or even better, write a test case. Here is an example of a 10-digit ISBN: the original ISBN of William Golding's <em class="italic">Lord of the Flies</em> is 0-571-05686-5.</p>
			<p class="callout-heading">Changes in Odoo 11</p>
			<p class="callout">In Odoo 11, the Python version that was used changed from <em class="italic">2.7</em> to <em class="italic">3.5</em> or later. Python 3 has breaking changes and is not fully compatible with Python 2. In particular, the <code>super()</code> syntax was simplified in Python 3. For previous Odoo versions that use Python 2, <code>super()</code> needs two arguments – the class name and <code>self</code>; for example, <code>super(Book, self)._check_isbn()</code>.</p>
			<p>Classic inheritance<a id="_idIndexMarker303"/> is<a id="_idIndexMarker304"/> the most frequently used extension mechanism. But Odoo provides additional extension approaches that are useful in other cases. We will explore those next.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor130"/>More model inheritance mechanisms</h1>
			<p>The previous <a id="_idIndexMarker305"/>section discussed <strong class="bold">classic inheritance</strong>, which can be seen as an <em class="italic">in-place extension</em>. This is the most frequently used approach, but the Odoo framework also supports a few other extension mechanisms that are useful in other cases.</p>
			<p>These are delegation inheritance, prototype inheritance, and the use of mixins:</p>
			<ul>
				<li><code>User</code> record<a id="_idIndexMarker307"/> embeds a <code>Partner</code> record, so that a <code>User</code> record has all the fields available for the <code>Partner</code> records, plus the fields specific to the <code>User</code> records. It is used through the <code>_inherits</code> attribute.</li>
				<li><code>_inherit</code> with the model to copy and the <code>_name</code> attribute with the identifier for the new model to be created.</li>
				<li><code>mail.thread</code> model, which is provided by the <code>mail</code> add-on module. It implements the chatter and messaging features that are available in several models throughout Odoo, such as <em class="italic">Partners</em> and <em class="italic">Sales Quotations</em>. A <code>mixin</code> class is constructed from <code>Models.abstract</code>, instead of <code>Models.model</code>, and is used with <code>_inherit</code>.</li>
			</ul>
			<p>The next few sections explore these possibilities in more detail.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor131"/>Embedding models using delegation inheritance</h2>
			<p><strong class="bold">Delegation inheritance</strong> allows <a id="_idIndexMarker312"/>us to reuse data structures, without duplication in the database. It embeds an instance of the<a id="_idIndexMarker313"/> delegated model inside the inheriting model.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To be technically precise, delegation inheritance is not real object inheritance; instead, it is object composition, where some features of an object are delegated to, or provided by, a second object.</p>
			<p>Note the following about delegation:</p>
			<ul>
				<li>Creating a new model record also creates and links a delegated model record.</li>
				<li>Fields from the delegated model that don't exist in the inheriting model are available for read and write operations, behaving like related computed fields.</li>
			</ul>
			<p>For example, for the User model, each record contains a Partner record, so the fields you find on a Partner will be available, plus a few fields that are specific to users.</p>
			<p>For the Library project, we want to add <a id="_idIndexMarker314"/>a <strong class="bold">Library Members</strong> model. Members will be able to borrow books and have a library card to be used when borrowing. Member master data should include the card number, plus some personal information, such as email and address. The Partner model already supports contact and address information, so it's best to reuse it, rather than duplicating the data structures.</p>
			<p>To add the<a id="_idIndexMarker315"/> Partner fields to the Library Member <a id="_idIndexMarker316"/>model using delegation inheritance, follow these steps:</p>
			<ol>
				<li value="1">The Python file that will be used to implement inheritance must be imported. Edit <code>library_member/model/__init__.py</code> by adding the following highlighted line:<pre>from . import library_book
<strong class="bold">from . import library_member</strong></pre></li>
				<li>Next, add the Python file describing the new Library Member model, <code>library_member/models/library_member.py</code>, which contains the following code:<pre>from odoo import fields, models
class Member(models.Model): 
    _name = "library.member"
    _description = "Library Member"
    card_number = fields.Char()
    partner_id = fields.Many2one(
        "res.partner",
<code>library.member</code> model embeds the inherited model, <code>res.partner</code>, so that when a new Member record is created, a related Partner is automatically created and referenced in the <code>partner_id</code> field.</p><p>Through<a id="_idIndexMarker317"/> the delegation mechanism, all the fields of the embedded model are automatically made available as if they were fields of the parent model fields. In this case, the Library Member model has all of the Partner fields available for use, such as <code>name</code>, <code>address</code>, and <code>email</code>, plus the ones specific to members, such as <code>card_number</code>. Behind the scenes, the Partner fields are stored in the linked Partner record, and no data structure duplication occurs.</p><p>Delegation inheritance <a id="_idIndexMarker318"/>works only at the data level, not at the logic level. No methods from the inherited model are inherited. They are still accessible using<a id="_idIndexMarker319"/> the <code>partner_id.open_parent()</code> runs the <code>open_parent()</code> method of the embedded Partner record.</p><p>There is an alternative syntax for delegation inheritance that's available through the <code>_inherits</code> model attribute. It comes from the pre-Odoo 8 old API, and it is still widely used. The Library Model example with the same effect as earlier looks like this:</p><pre>from odoo import fields, models
class Member(models.Model): 
    _name = "library.member"
    _description = "Library Member"
<strong class="bold">    _inherits = {"res.partner": "partner_id"}</strong>
    card_number = fields.Char()
    partner_id = fields.Many2one(
        "res.partner",
        ondelete="cascade",
        required=True) </pre><p>To finish adding this new model, a few additional steps are needed – add the security ACLs, a menu item, and some view3.</p></li>
				<li>To add<a id="_idIndexMarker321"/> the security ACLs, create the <code>library_member/security/ir.model.access.csv</code> file with<a id="_idIndexMarker322"/> this content:<pre>id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink
access_member_user,Member User Access,model_library_member,library_app.library_group_user,1,1,1,0
access_member_manager,Member Manager Access,model_library_member,library_app.library_group_manager,1,1,1,4</pre></li>
				<li>To add the menu item, create the <code>library_member/views/library_menu.xml</code> file with the following code:<pre>&lt;odoo&gt;
    &lt;act_window id="action_library_member"
      name="Library Members"
      res_model="library.member"
      view_mode="tree,form" /&gt;
    &lt;menuitem id="menu_library_member"
      name="Members"
      action="action_library_member"
      parent="library_app.menu_library" /&gt;
&lt;/odoo5</pre></li>
				<li>To add the views, create the <code>library_member/views/member_view.xml</code> file <a id="_idIndexMarker323"/>with the <a id="_idIndexMarker324"/>following code:<pre>&lt;odoo&gt;
  &lt;record id="view_form_member" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Library Member Form 
      View&lt;/field&gt;
    &lt;field name="model"&gt;library.member&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;form&gt;
        &lt;group&gt;
          &lt;field name="name" /&gt;
          &lt;field name="email" /&gt;
          &lt;field name="card_number" /&gt;
        &lt;/group&gt;
      &lt;/form&gt;
    &lt;/field&gt;
  &lt;/record&gt;
  &lt;record id="view_tree_member" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Library Member List 
      View&lt;/field&gt;
    &lt;field name="model"&gt;library.member&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;tree&gt;
          &lt;field name="name" /&gt;
          &lt;field name="card_number" /&gt;
      &lt;/tree&gt;
    &lt;/field&gt;
  &lt;/record&gt;
&lt;/odoo6</pre></li>
				<li>Finally, we <a id="_idIndexMarker325"/>should edit the<a id="_idIndexMarker326"/> manifest to declare these three new files:<pre>"data": [
    <strong class="bold">"security/ir.model.access.csv",</strong>
    "views/book_view.xml",
<strong class="bold">    "views/member_view.xml",</strong>
<strong class="bold">    "views/library_menu.xml",</strong>
],</pre></li>
			</ol>
			<p>If everything was entered correctly, after a module upgrade, we should be able to work with the new Library Member model.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor132"/>Copying models with prototype inheritance</h2>
			<p>Classic<a id="_idIndexMarker327"/> inheritance uses the <code>_inherit</code> attribute to extend a model. Since the <code>_name</code> attribute is not modified, it effectively performs<a id="_idIndexMarker328"/> an in-place modification on the same model. </p>
			<p>If the <code>_name</code> attribute is also modified, along with <code>_inherit</code>, we get a new model that is a copy of the inherited one. This new model can then have features added to it that are specific to it and won't be added to the parent model. The copied model is independent of the parent model, which will be unaffected by its modifications. It has its own database table and data. The official documentation calls this <strong class="bold">prototype inheritance</strong>.</p>
			<p>In practice, there is little benefit in using <code>_inherit</code> to copy a model. Instead, delegation inheritance is preferred, since it reuses data structures without duplicating them.</p>
			<p>Things <a id="_idIndexMarker329"/>become more interesting when we use inheritance from multiple parents. For this, <code>_inherit</code> will be a list of model names, instead of a single name.</p>
			<p>This can <a id="_idIndexMarker330"/>be used to mix several models into one. It allows us to have a model proposing features to be reused several times. This pattern is widely used with abstract mixin classes. This will be discussed in detail in the next section.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor133"/>Reusing model features using mixin classes</h2>
			<p>Setting the <code>_inherit</code> attribute <a id="_idIndexMarker331"/>with a list of model names <a id="_idIndexMarker332"/>will inherit the features from those models. Most of the time, this is done to leverage mixin classes.</p>
			<p>A <code>models.AbstractModel</code>, with no actual representation in the database, instead of <code>models.Model</code>.</p>
			<p>The Odoo standard add-ons propose several useful mixins. Searching the code for <code>models.AbstractModel</code> will reveal them. What's noteworthy, and probably the two most widely used, are these mixins, which are provided by the Discuss app (the <code>mail</code> add-on module):</p>
			<ul>
				<li>The <code>mail.thread</code> mixin provides features for the message board, also known as <strong class="bold">chatter</strong>, which can be found at the bottom or right-hand side of many document forms, along with the logic regarding messages and notifications.</li>
				<li>The <code>mail.activity.mixin</code> mixin provides <em class="italic">activities</em>, which are also exposed through the chatter discussion widget, to define and plan to-do tasks.<p class="callout-heading">Changes in Odoo 11</p><p class="callout">The <em class="italic">activities</em> mixin is a new feature that was introduced in Odoo 11 and is not available in earlier versions.</p></li>
			</ul>
			<p>Chatter and activities are widely used features, and in the next section, we will take a moment to <a id="_idIndexMarker334"/>demonstrate how to add them.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor134"/>Adding message chatter and activities to a model</h2>
			<p>We will now <a id="_idIndexMarker335"/>add the message chatter and activity mixins to the <strong class="bold">Library Members</strong> model. This is what is needed to add them:</p>
			<ol>
				<li value="1">Add the dependency to the add-on module that's providing the mixin models; that is, <code>mail</code>.</li>
				<li>Inherit the <code>mail.thread</code> and <code>mail.activity.mixin</code> mixin classes.</li>
				<li>Add fields to the <code>Form</code> view.</li>
			</ol>
			<p>Let's check the preceding steps in detail:</p>
			<ol>
				<li value="1">To add the dependency to the <code>mail</code> add-on, edit the <code>__manifest__.py</code> file:<pre>    "depends": ["library_app", <strong class="bold">"mail"</strong>], </pre></li>
				<li>To inherit the mixin classes, edit the <code>library_member/models/library_member.py</code> file to add the following highlighted text:<pre>class Member(models.Model): 
    _name = "library.member"
    _description = "Library Member"
    _inherits = {"res.partner": "partner_id"}
<code>_inherit = ["library.member", "mail.thread", "mail.activity.mixin"]</code>.</p></li>
				<li>Finally, we<a id="_idIndexMarker336"/> must add the relevant fields to <code>Library Member Form</code>. Edit the <code>library_member/views/member_view.xml</code> file by adding the following highlighted code:<pre>  &lt;record id="view_form_member" model="ir.ui.view"&gt;
    &lt;field name="name"&gt;Library Member Form 
      View&lt;/field&gt;
    &lt;field name="model"&gt;library.member&lt;/field&gt;
    &lt;field name="arch" type="xml"&gt;
      &lt;form&gt;
        &lt;group&gt;
          &lt;field name="name" /&gt;
          &lt;field name="email" /&gt;
          &lt;field name="card_number" /&gt;
        &lt;/group&gt;
<strong class="bold">        &lt;!-- mail mixin fields --&gt;</strong>
<strong class="bold">        &lt;div class="oe_chatter"&gt;</strong>
<strong class="bold">            &lt;field name="message_follower_ids"</strong>
<strong class="bold">                   widget="mail_followers"/&gt;</strong>
<strong class="bold">            &lt;field name="activity_ids"</strong>
<strong class="bold">                   widget="mail_activity"/&gt;</strong>
<strong class="bold">            &lt;field name="message_ids"</strong>
<strong class="bold">                   widget="mail_thread"/&gt;</strong>
<strong class="bold">        </strong><strong class="bold">&lt;/div&gt;</strong>
      &lt;/form&gt;
    &lt;/field&gt;
  &lt;/record&gt;</pre></li>
			</ol>
			<p>As we <a id="_idIndexMarker337"/>can see, the <code>mail</code> module not only provides fields for the followers, activities, and messages, but it also provides specific web client widgets for them, all of which are being used here.</p>
			<p>Once the module has been upgraded, the <strong class="bold">Library Members</strong> form should look like this:</p>
			<div><div><img src="img/Figure_4.3_B16119.jpg" alt="Figure 4.3 – The Library Members form view&#13;&#10;" width="900" height="529"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – The Library Members form view</p>
			<p>Note that the mixins alone don't cause any changes to be made to access security, including record rules. In some cases, there are record rules in place, limiting what records are accessible to each user. For example, if we want users to only view records they are followers<a id="_idIndexMarker338"/> of, a record rule for that must be explicitly added.</p>
			<p>The <code>mail.thread</code> model includes a field for listing the follower <code>message_partner_ids</code>. To implement the followers' access rules, a <code>[('message_partner_ids', 'in', [user.partner_id.id])]</code>.</p>
			<p>With that, we've seen how to extend modules at the model and logic layers. The next step is to extend the views to reflect the changes that were made in the model layer.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor135"/>Extending views and data</h1>
			<p>Views <a id="_idIndexMarker339"/>and other data components can also be modified by an extension module. For views, the case is usually to add features. The view presentation structure is defined with XML. To extend this XML, we must locate the node to extend and then declare the action to perform there, such as inserting additional XML elements.</p>
			<p>The other data elements represent records that were written to the database. Extension modules can write on them to change some values.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor136"/>Extending views</h2>
			<p>Views are<a id="_idIndexMarker340"/> defined using XML and are stored in the architecture field, <code>arch</code>. To extend a view, we must locate the node where the extension will take place, and then perform the intended change, such as adding XML elements.</p>
			<p>Odoo provides a simplified notation to extend XML by using the XML tag we want to match –  <code>&lt;field&gt;</code>, for example – with one or more distinctive attributes to match, such as <code>name</code>. Then, we must add the <code>position</code> attribute to declare the kind of modification to make.</p>
			<p>Recovering the example we used earlier in this chapter, to add additional content after the <code>isbn</code> field, we can use the following code:</p>
			<pre>      &lt;field name="isbn" position="after"&gt;
        &lt;!-- Changed content goes here --&gt;
      &lt;/field&gt;</pre>
			<p>Any XML element and attribute can be used to select the node to use as the extension point, except for <code>string</code> attributes. The values of string attributes are translated into the user's active language during view generation, so they can't be reliably used as node selectors.</p>
			<p>The extension<a id="_idIndexMarker341"/> operation to perform is declared with the <code>position</code> attribute. Several operations are allowed, as follows:</p>
			<ul>
				<li><code>inside</code> (the default): Appends the content inside the selected node. The node should be a container, such as <code>&lt;group&gt;</code> or <code>&lt;page&gt;</code>.</li>
				<li><code>after</code>: Adds the content after the selected node.</li>
				<li><code>before</code>: Adds the content before the selected node.</li>
				<li><code>replace</code>: Replaces the selected node. If it's used with empty content, it deletes the element. Since Odoo 10, it also allows you to wrap an element with other markups by using <code>$0</code> in the content to represent the element being replaced; for example, <code>&lt;field name="name" position="replace"&gt;&lt;h1&gt;$0&lt;/h1&gt;&lt;/field&gt;</code>.</li>
				<li><code>attributes</code>: Modifies the attribute values for the matched element. The content should have one or more <code>&lt;attribute name="attr-name"&gt;value&lt;attribute&gt;</code> elements, such as <code>&lt;attribute name="invisible"&gt;True&gt;&lt;/attribute&gt;</code>. If it's used with no body, such as in <code>&lt;attribute name="invisible"/&gt;</code>, the attribute is removed from the selected element.<p class="callout-heading">Tip</p><p class="callout">While <code>position="replace"</code> allows us to delete XML elements, this should be avoided. It can break based on modules that may be using the deleted node as an extension point to add other elements. As an alternative, consider leaving the element and making it invisible instead.</p></li>
			</ul>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor137"/>Moving XML nodes to a different location</h2>
			<p>Except for the <code>attributes</code> operation, the preceding locators can be combined with a child <a id="_idIndexMarker342"/>element with <code>position="move"</code>. The effect is to move the child locator target node to the parent locator's target position.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <code>position="move"</code> child locator is new in Odoo 12 and is not available in previous versions.</p>
			<p>Here is an example of moving <code>my_field</code> from its current location to the position after <code>target_field</code>:</p>
			<pre>&lt;field name="target_field" position="after"&gt;
    &lt;field name="my_field" position="move"/&gt;
&lt;/field&gt;</pre>
			<p>The other view types, such as list and search views, also have an <code>arch</code> field and can be extended in the same way as form views can.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>Using XPath to select XML extension points</h2>
			<p>In some<a id="_idIndexMarker343"/> cases, we may not have an attribute with a unique value to use as the XML node selector. This can happen when the element to select does not have a <code>name</code> attribute, as is often the case for <code>&lt;group&gt;</code>, <code>&lt;notebook&gt;</code>, or <code>&lt;page&gt;</code> view elements. Another case is when there are several elements with the same <code>name</code> attribute, as in the case of Kanban QWeb views, where the same field can be included more than once in the same XML template.</p>
			<p>For these cases, we need a more sophisticated way to locate the XML element to extend. Being XML, <strong class="bold">XPath expressions</strong> are<a id="_idIndexMarker344"/> the natural way to locate elements.</p>
			<p>For example, taking the book form view we defined in the previous chapter, an XPath expression for locating the <code>&lt;field name="isbn"&gt;</code> element is <code>//field[@name]='isbn'</code>. This expression finds <code>&lt;field&gt;</code> elements with a <code>name</code> attribute equal to <code>isbn</code>.</p>
			<p>The XPath equivalent to the book form view extension that we created in the previous section would be as follows:</p>
			<pre>&lt;xpath expr="//field[@name='isbn']" position="after"&gt;
    &lt;field name="is_available" /&gt;
&lt;/xpath&gt;</pre>
			<p>More<a id="_idIndexMarker345"/> information on the supported XPath syntax <a id="_idIndexMarker346"/>can be found in the official Python documentation: <a href="https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax">https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax</a>.</p>
			<p>If an XPath expression matches multiple elements, only the first one will be selected as the target for an extension. Therefore, they should be made as specific as possible using unique attributes. Using the <code>name</code> attribute is the easiest way to ensure that we find the elements we want to use as an extension point. Thus, it is important to have these unique identifiers in the XML elements of the views we create.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>Modifying existing data</h2>
			<p>Regular <a id="_idIndexMarker347"/>data records can also be <em class="italic">extended</em>, which, in practice, means writing over existing values. For this, we just need to identify the record to write on, as well as the fields and values to update. XPath expressions are not needed since we are not modifying XML <code>arch</code> structures, as we do for views.</p>
			<p>The <code>&lt;record id="x" model="y"&gt;</code> data loading elements perform an insert or update operation on model <code>y</code>: if record <code>x</code> does not exist, it is created; otherwise, it is updated/written over.</p>
			<p>Records in other modules can be accessed using the <code>&lt;module&gt;.&lt;identifier&gt;</code> global identifier, so a module can update a record that's been created by another module.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The dot (<code>.</code>) is reserved to separate the module name from the object identifier. So, it can't be used in identifier names. Instead, use the underscore (<code>_</code>) character.</p>
			<p>As an example, we will change the name of the User security group to <code>Librarian</code>. The record to modify was created in the <code>library_app</code> module, with the <code>library_app.library_group_user</code> identifier.</p>
			<p>To do this, we <a id="_idIndexMarker348"/>will add the <code>library_member/security/library_security.xml</code> file, along with the following code:</p>
			<pre>&lt;odoo&gt;
  &lt;!-- Modify Group name --&gt;
<strong class="bold">  &lt;record id="library_app.library_group_user" </strong>
<strong class="bold">    model="res.groups"&gt; </strong>
<strong class="bold">    &lt;field name="name"&gt;Librarian&lt;/field&gt;</strong>
<strong class="bold">  &lt;/record&gt;</strong>
&lt;/odoo&gt;</pre>
			<p>Note that we used a <code>&lt;record&gt;</code> element, writing only to the <code>name</code> field. You can think of this as a write operation in this field.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When using a <code>&lt;record&gt;</code> element, we can select the fields we want to write on, but the same is not true for shortcut elements, such as <code>&lt;menuitem&gt;</code> and <code>&lt;act_window&gt;</code>. These need all of the attributes to be provided and missing any of them will set the corresponding field to an empty value. However, you can use <code>&lt;record&gt;</code> to set a value on a field that was created through a shortcut element.</p>
			<p>Don't forget to add the <code>library_member/security/library_security.xml</code> file to the <code>data</code> key in the manifest file. Having done this and upgraded the module, we should see the name change in the user groups.</p>
			<p>Extending views allows you to introduce modifications to the backend presentation layer. But the same can be done to the frontend web presentation layer. This is what we will address in the next section.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor140"/>Extending web pages</h1>
			<p>Extensibility is<a id="_idIndexMarker349"/> a key design choice for the Odoo framework, and <a id="_idIndexMarker350"/>the Odoo web components are no exception. So, Odoo web controllers and templates can be also extended.</p>
			<p>The Library app that we created in the previous <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, provided a book catalog page that now needs to be improved.</p>
			<p>We will extend it to leverage the book availability information that was added by the Library Members module:</p>
			<ul>
				<li>On the controller side, we will add support to a query string parameter to filter only the available books; that is, <code>/library/books?available=1</code>.</li>
				<li>On the template side, we will specify the books that are not available.</li>
			</ul>
			<p>Let's start extending the web controller.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Extending the web controllers</h2>
			<p><strong class="bold">Web controllers</strong> are <a id="_idIndexMarker351"/>responsible for handling web requests and <a id="_idIndexMarker352"/>rendering the page to return as a response. They should focus on presentation logic, not deal with business logic, which should be incorporated into model methods instead.</p>
			<p>Supporting additional parameters or even URL routes is web presentation-specific and something appropriate for a web controller to deal with.</p>
			<p>The <code>/library/books</code> endpoint will be extended here to support a query string parameter, <code>available=1</code>, which we will use to filter the catalog of books so that it only displays the available titles.</p>
			<p>To extend an existing controller, we need to import the original object that created it, declare a Python class based on it, and then implement the class method holding the additional logic.</p>
			<p>The code to extend the controller should be added to the <code>library_member/controllers/main.py</code> file, as follows:</p>
			<pre>from odoo import http 
from odoo.addons.library_app.controllers.main import Books 
class BooksExtended(Books):
    @http.route()
    def list(self, **kwargs):
        response = super().list(**kwargs)
        if kwargs.get("available"):
            all_books = response.qcontext["books"]
            available_books = all_books.filtered(
              "is_available")
            response.qcontext["books"] = available_books
        return response</pre>
			<p>The steps<a id="_idIndexMarker353"/> to add the controller code are as follows:</p>
			<ol>
				<li value="1">Add the <code>library_member/controllers/main.py</code> file, ensuring it contains the preceding code.</li>
				<li>Make this new Python file known to the module by adding the controller's subdirectory to the <code>library_member/__init__.py</code> file:<pre>from . import models
<strong class="bold">from . import controllers</strong></pre></li>
				<li>Add the <code>library_member/controllers/__init__.py</code> file with the following line of code:<pre>from . import main </pre></li>
				<li>After this, accessing <code>http://localhost:8069/library/books?available=1</code> should only show us the books with the <code>Is Available?</code> field checked.</li>
			</ol>
			<p>Now, let's review the controller extension code to understand how it works.</p>
			<p>The controller to extend, <code>Books</code>, was originally declared by the <code>library_app</code> module, in the <code>controllers/main.py</code> file. So, to get a reference to it, we need to import <code>odoo.addons.library_app.controllers.main</code>.</p>
			<p>This is <a id="_idIndexMarker354"/>different from models, where we have a central registry available where we can get a reference to any model class, such as <code>self.env['library.book']</code>, without knowing the particular file that's implementing it. We don't have such a registry for controllers, and we need to know the module and file implementing the controller to be able to extend it.</p>
			<p>Then, the <code>BooksExtended</code> class is declared based on the original one, <code>Books</code>. The identifier name that's used for this class is not relevant. It is used as a vehicle to reference the original class and extend it.</p>
			<p>Next, we (re)define the controller method to be extended, which is <code>list()</code> in this case. It needs to be decorated with at least the simple <code>@http.route()</code> for its route to be kept active. If it's used like this, with no arguments, it will preserve the routes that are defined by the parent class. But we could also add parameters to this <code>@http.route()</code> decorator to replace and redefine the class routes.</p>
			<p>The <code>list()</code> method has a <code>**kwargs</code> argument, which captures all the parameters in the <code>kwargs</code> dictionary. These are the parameters that are given in the URL, such as <code>?available=1</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Using a <code>**kwargs</code> argument that sweeps all the given arguments is not required, but it makes our URL tolerant to unexpected URL arguments. If we choose to specify particular arguments, if different ones are set, the page will fail immediately and return an <strong class="bold">internal error</strong> when<a id="_idIndexMarker355"/> trying to call the corresponding controller.</p>
			<p>The code for the <code>list()</code> method starts by calling the corresponding parent class method using <code>super()</code>. This returns the <code>Response</code> object that was computed by the parent method, including the attributes and the template to render, <code>template</code>, and the context to use when rendering, <code>qcontext</code>. But the HTML is yet to be generated. This will only happen when the controller finishes running. So, it is possible to change the <code>Response</code> attributes before the final rendering is done.</p>
			<p>The method checks <code>kwargs</code> for a non-empty value in the <code>available</code> key. If it is found, the <a id="_idIndexMarker356"/>non-available books are filtered out, and <code>qcontext</code> is updated with this recordset. So, when the controller's processing completes, the HTML will be rendered using the updated book's recordset, which will only include available books.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor142"/>Extending QWeb templates</h2>
			<p>Web page<a id="_idIndexMarker357"/> templates are XML documents, just like the other Odoo view types, and selector expressions can be used, as we do for other view types, such as forms. QWeb templates are usually more complex since they include more HTML elements, so most of the time, the more versatile <code>XPath</code> expressions are needed.</p>
			<p>To modify the actual presentation of the web page, we should extend the QWeb template being used. As an example of this, we will extend <code>library_app.book_list_template</code> to add visual information about the books that are not available.</p>
			<p>A QWeb extension is a <code>&lt;template&gt;</code> element that uses the additional <code>inherit_id</code> attribute to identify the QWeb template to extend. It is <code>library_app.book_list_template</code> in this case.</p>
			<p>Follow these steps: </p>
			<ol>
				<li value="1">Add the <code>library_member/views/book_list_template.xml</code> file, along with the following code:<pre>&lt;odoo&gt;
  &lt;template id="book_list_extended"
            name="Extended Book List"
            inherit_id=
              "library_app.book_list_template"&gt;
<code>xpath</code> notation. Note that in this case, we could <a id="_idIndexMarker358"/>have also used the equivalent simplified notation; that is, <code>&lt;span t-field="book.publisher_id" position=after&gt;</code>.</p></li>
				<li>Declare this additional data file in the add-on manifest; that is, <code>library_member/__manifest__.py</code>:<pre>"data": [
    "security/library_security.xml",
    "security/ir.model.access.csv",
    "views/book_view.xml",
    "views/member_view.xml",
    "views/library_menu.xml",
<strong class="bold">    "views/book_list_template.xml",</strong>
],</pre></li>
			</ol>
			<p>After this, accessing <code>http://localhost:8069/library/books</code> should show the additional (not available) visual information on the books that are not available. Here is what the web page will look like:</p>
			<div><div><img src="img/Figure_4.4_B16119.jpg" alt="Figure 4.4 – Books list web page with availability information&#13;&#10;" width="994" height="257"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Books list web page with availability information</p>
			<p>This <a id="_idIndexMarker359"/>completes our review of how to extend each type of Odoo component, from the data model to the user interface elements.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor143"/>Summary</h1>
			<p>Extensibility is a key feature of the Odoo framework. We can build add-on modules that change or add features to other existing add-ons at the several layers needed to implement features in Odoo. With this, our projects will be able to reuse and extend third-party add-on modules in a clean and modular way.</p>
			<p>At the model layer, we use the <code>_inherit</code> model attribute to get a reference to an existing model and then make in-place modifications to it. The field objects inside the model also support incremental definitions so that we can <em class="italic">redeclare</em> an existing field, providing only the attributes to change.</p>
			<p>Additional model inheritance mechanisms allow you to reuse data structures and business logic. Delegation inheritance, which is activated with the <code>delegate=True</code> attribute on a many-to-one relationship field (or the old-style <code>inherits</code> model attribute), makes all the fields from the related model available and reuses its data structure. Prototype inheritance, which uses <code>_inherit</code> with additional models, allows you to copy features (data structure definitions and methods) from other models and enables the use of abstract mixin classes, providing a set of reusable features, such as document discussion messages and followers.</p>
			<p>At the view layer, the view structures are defined using XML, and extensions can be made by locating an XML element (using XPath or the Odoo simplified syntax) and providing the XML fragment to add. Other data records that are created by a module can also be modified by extension modules by simply referencing the corresponding complete XML ID and performing a write operation on the intended fields.</p>
			<p>At the business logic layer, extensions can be made with the same mechanism that's used for model extension and redeclaring the methods to extend. Inside them, the <code>super()</code> Python function is used to call the code of the inherited method, and our additional code can run before or after that.</p>
			<p>For the frontend web pages, the presentation logic in controllers can be extended in a similar way to model methods, and the web templates are also views with XML structures, so these can be extended in the same way as the other view types.</p>
			<p>In the next chapter, we will dive deeper into models and explore everything they can offer us.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor144"/>Further reading</h1>
			<p>The following are some additional references to the official documentation, which can provide useful information regarding module extensions and inheritance mechanisms:</p>
			<ul>
				<li>Model inheritance: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html</a></li>
				<li>View inheritance: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/views.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/views.html</a></li>
				<li>Web controllers: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/http.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/http.html</a></li>
			</ul>
		</div>
	</div></body></html>