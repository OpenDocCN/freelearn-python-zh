<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer042">
			<h1 id="_idParaDest-115"><em class="italic"><a id="_idTextAnchor119"/></em><a href="B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 4</em></a>: Extending Modules</h1>
			<p>One of Odoo's most powerful capabilities is being able to add features without directly touching the code of the extended modules. This allows for clean feature extensions that are isolated in their own code components. Extending modules can be achieved through inheritance mechanisms, which work as modification layers on top of existing objects. These modifications can happen at every level – including the model, view, and business logic levels. Instead of directly modifying an existing module, we will create a new module by adding a layer on top of the existing one with the intended modifications.</p>
			<p>The previous chapter guided us through creating a new app from scratch. In this chapter, we will learn how to create modules that extend existing apps or modules and use existing core or community features.</p>
			<p>To achieve this, we will cover the following topics:</p>
			<ul>
				<li>Learning project – extending the Library app</li>
				<li>Adding a new field to an existing model</li>
				<li>Extending models using classic in-place extension</li>
				<li>More model inheritance mechanisms</li>
				<li>Extending views and data</li>
				<li>Extending web pages</li>
			</ul>
			<p>By the end of this chapter, you should be able to create Odoo modules that extend existing apps. You will be able to add modifications to any of the several application components: models, views, business logic code, web page controllers, and web page templates.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor120"/>Technical requirements</h1>
			<p>For this chapter, you will need an Odoo server that you can command from a terminal session.</p>
			<p>The code in this chapter depends on the code that we created in <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>. You should have that code in your add-ons path and have a database with the <strong class="source-inline">library_app</strong> module installed. </p>
			<p>This chapter adds the <strong class="source-inline">library_member</strong> add-on module to our project. The corresponding code can be found in this book's GitHub repository, <a href="https://github.com/PacktPublishing/Odoo-15-Development-Essentials">https://github.com/PacktPublishing/Odoo-15-Development-Essentials</a>, in the <strong class="source-inline">ch04</strong> directory.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor121"/>Learning project – extending the Library app</h1>
			<p>In <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, we created the initial module for the <strong class="bold">Library</strong> app and <a id="_idIndexMarker288"/>provided a book catalog. Now, we will extend the application to add library members and allow them to borrow books. For this, we will create an extension module called <strong class="source-inline">library_member</strong>.</p>
			<p>These are<a id="_idIndexMarker289"/> the features we must provide:</p>
			<ul>
				<li>Library books can be available to be borrowed or not. This information should be shown in the book form and on the website's catalog page.</li>
				<li>Some library member master data, along with the library card number, plus personal data, such as name, address, and email.</li>
				<li>We would like to provide members with the messaging and social features that are available on the borrowing form, including the planned activities widget, to allow for better collaboration.</li>
			</ul>
			<p>Later, we plan to introduce a feature that allows members to borrow books from the library, but this is outside our scope for now. This will happen gradually throughout the next few chapters.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Books</h2>
			<p>The<a id="_idIndexMarker290"/> following is a summary of the technical changes we must introduce to books:</p>
			<ul>
				<li>Add an <strong class="source-inline">Is Available?</strong> field. For now, it will be managed manually, but this can be automated later.</li>
				<li>Extend the ISBN validation logic to also support the older 10-digit ISBN format.</li>
				<li>Extend the web catalog page to identify unavailable books and to allow the user to only filter through available books.</li>
			</ul>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>Members</h2>
			<p>The following <a id="_idIndexMarker291"/>is a summary of the technical changes to introduce to library members:</p>
			<ul>
				<li>Add a new model to store the person's name, card number, and contact information, such as email and address.</li>
				<li>Add the social discussion and planned activities features.</li>
			</ul>
			<p>To start working on this extension module, we should create the <strong class="source-inline">library_member</strong> directory alongside <strong class="source-inline">library_app</strong> and add two files—an empty <strong class="source-inline">__init__.py</strong> file and a <strong class="source-inline">__manifest__.py</strong> file with the following content:</p>
			<p class="source-code">{</p>
			<p class="source-code">    "name": "Library Members",</p>
			<p class="source-code">    "license": "AGPL-3",</p>
			<p class="source-code">    "description": "Manage members borrowing books.",</p>
			<p class="source-code">    "author": "Daniel Reis",</p>
			<p class="source-code">    "depends": ["library_app"],</p>
			<p class="source-code">    "application": False,</p>
			<p class="source-code">}</p>
			<p>Now, we are ready to start working on the features. Our first task is a frequent and simple request – adding a new field to an existing model. This happens to be a great way to introduce Odoo's inheritance mechanisms.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor124"/>Adding a new field to an existing model</h1>
			<p>Our<a id="_idIndexMarker292"/> first task is to add the <strong class="source-inline">is_available</strong> Boolean field to the book model. For now, this will be a simple editable field, but at a later stage, we can imagine changing it to be automatic, based on books that have been borrowed and returned.</p>
			<p>To extend an existing model, we must use a Python class with the <strong class="source-inline">_inherit</strong> attribute, identifying the model being extended. The new class inherits all of the features of the parent Odoo model, and we only need to declare the modifications to introduce. We can think of this type of inheritance as getting a reference for the existing model and making in-place changes to it.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>Adding new fields with the in-place model extension</h2>
			<p>Extending<a id="_idIndexMarker293"/> models is done through Python classes by using the Odoo-specific inheritance mechanism that's declared using the <strong class="source-inline">_inherit</strong> class attribute. This <strong class="source-inline">_inherit</strong> class attribute identifies the model to be extended. The declared calls capture all the features of the inherited Odoo model and are ready for the modifications to introduce to be declared.</p>
			<p>The coding style guidelines recommend having a Python file for each model, so we will add a <strong class="source-inline">library_member/models/library_book.py</strong> file that extends the original model. Let's start by adding the <strong class="source-inline">__init__.py</strong> code files that are needed for that file to be included in the module:</p>
			<ol>
				<li>Add the <strong class="source-inline">library_member/__init__.py</strong> file, making the code that's in the <strong class="source-inline">models</strong> subdirectory known:<p class="source-code">from . import models</p></li>
				<li>Add the <strong class="source-inline">library_member/models/__init__.py</strong> file, importing the used code files inside that subdirectory:<p class="source-code">from . import library_book</p></li>
				<li>Create the <strong class="source-inline">library_member/models/library_book.py</strong> file by extending the <strong class="source-inline">library.book</strong> model:<p class="source-code">from odoo import fields, models</p><p class="source-code"> </p><p class="source-code">class Book(models.Model): </p><p class="source-code">    _inherit = "library.book" </p><p class="source-code">    is_available = fields.Boolean("Is Available?")</p></li>
			</ol>
			<p>Here, we <a id="_idIndexMarker294"/>used the <strong class="source-inline">_inherit</strong> class attribute to declare the model to extend. Notice that we didn't use any other class attributes, not even <strong class="source-inline">_name</strong>. This is not needed unless we want to make changes to any of them.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout"><strong class="source-inline">_name</strong> is the model identifier; what happens if we try to change it? This is allowed, and doing so creates a new model that is a copy of the inherited one. This is called <strong class="bold">prototype inheritance</strong> and it will be discussed later in this chapter, in the <em class="italic">Copying models with prototype inheritance</em> section.</p>
			<p>We can think of this as getting a reference to a model definition living in a central registry and making in-place changes to it. This can include adding fields, modifying existing fields, modifying model class attributes, or adding methods with new business logic.</p>
			<p>To add the new model fields to the database tables, we must install the add-on module. If everything goes as expected, the newly added fields should be visible if we go to the <strong class="bold">Technical</strong> | <strong class="bold">Database Structure</strong> | <strong class="bold">Models</strong> menu option and inspect the <strong class="source-inline">library.book</strong> model.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor126"/>Adding a field to the Form view</h2>
			<p>Forms, lists, and <a id="_idIndexMarker295"/>search views are defined using XML data structures. To extend views, we need a way to modify the XML. This means locating XML elements and then introducing modifications at those points.</p>
			<p>The XML data record for inherited views is similar to the ones for regular views, with an additional <strong class="source-inline">inherit_id</strong> attribute for referring to the view being extended.</p>
			<p>We are going to extend the book view to add the <strong class="source-inline">is_available</strong> field.</p>
			<p>The first<a id="_idIndexMarker296"/> thing we need to do is find the XML ID for the view to be extended. We can find that by looking up the view in the <strong class="bold">Settings</strong> app, in the <strong class="bold">Technical</strong> | <strong class="bold">User Interface</strong> | <strong class="bold">Views</strong> menu. The XML ID for the book form is <strong class="source-inline">library_app.view_form_book</strong>.</p>
			<p>While we're there, we should also locate the XML element to insert the changes. We will choose to add the <strong class="source-inline">Is Available?</strong> field after the <strong class="source-inline">ISBN</strong> field. The element to use can usually be identified by its <strong class="source-inline">name</strong> attribute. In this case, it's <strong class="source-inline">&lt;field name="isbn" /&gt;</strong>.</p>
			<p>When adding the XML file to extend the <strong class="source-inline">Partner</strong> views, <strong class="source-inline">views/book_view.xml</strong>, it should have the following content:</p>
			<p class="source-code">&lt;odoo&gt;</p>
			<p class="source-code">  &lt;record id="view_form_book_extend" model="ir.ui.view"&gt;</p>
			<p class="source-code">    &lt;field name="name"&gt;Book: add Is Available? </p>
			<p class="source-code">      field&lt;/field&gt;</p>
			<p class="source-code">    &lt;field name="model"&gt;library.book&lt;/field&gt;</p>
			<p class="source-code"><strong class="bold">    &lt;field name="inherit_id" ref=</strong></p>
			<p class="source-code"><strong class="bold">      "library_app.view_form_book"/&gt;</strong></p>
			<p class="source-code">    &lt;field name="arch" type="xml"&gt;</p>
			<p class="source-code"><strong class="bold">      &lt;field name="isbn" position="after"&gt;</strong></p>
			<p class="source-code"><strong class="bold">        &lt;field name="is_available" /&gt;</strong></p>
			<p class="source-code"><strong class="bold">      &lt;/field&gt;</strong></p>
			<p class="source-code">    &lt;/field&gt;</p>
			<p class="source-code">  &lt;/record&gt;</p>
			<p class="source-code">&lt;/odoo&gt;</p>
			<p>The inheritance-specific elements are highlighted in the preceding code. The <strong class="source-inline">inherit_id</strong> record field identifies the view to be extended while using the <strong class="source-inline">ref</strong> attribute to refer to<a id="_idIndexMarker297"/> its external identifier.</p>
			<p>The <strong class="source-inline">arch</strong> field contains the element for declaring the extension point to use, the <strong class="source-inline">&lt;field&gt;</strong> element with <strong class="source-inline">name="isbn"</strong>, and the position of the new elements to add, which is <strong class="source-inline">position="after"</strong> in this case. Inside the extension elements, we have the XML to add, which is the <strong class="source-inline">is_available</strong> field in this case.</p>
			<p>This is what the book form will look like after creating this extension:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="Images/Figure_4.1_B16119.jpg" alt="Figure 4.1 – The book form with the &quot;Is Available?&quot; field added&#13;&#10;" width="1077" height="622"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 – The book form with the "Is Available?" field added</p>
			<p>We just went through the inheritance basics and added a new field for the model and view layers. Next, we will learn more about the model extension approach we used; that is, classic inheritance.</p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor127"/>Extending models using classic in-place extension</h1>
			<p>We<a id="_idIndexMarker298"/> can think of the classic model inheritance as an in-place extension. When a Python class with the <strong class="source-inline">_inherit</strong> attribute is declared, it gets a reference to the corresponding model definition, to then add extensions to it. The model definition is stored in the Odoo model registry and is available for us to add further modifications to it.</p>
			<p>Now, let's learn how to use this for frequent extension use cases: modifying the attributes of an existing field and extending Python methods to add or modify business logic.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor128"/>Incrementally modifying existing fields</h2>
			<p>When we're <a id="_idIndexMarker299"/>extending a model, existing fields can be modified incrementally. This means that we only need to define the field attributes to change or add.</p>
			<p>We will make two changes to the book fields that were created in the <strong class="source-inline">library_app</strong> module:</p>
			<ul>
				<li>On the <strong class="source-inline">isbn</strong> field, add a help tooltip explaining that we support both 10- and 13-digit ISBNs, with the latter being implemented in the following section.</li>
				<li>On the <strong class="source-inline">publisher_id</strong> field, add a database index to it to make searching on it more efficient.</li>
			</ul>
			<p>We should edit the <strong class="source-inline">library_member/models/library_book.py</strong> file and add the following lines to the <strong class="source-inline">library.book</strong> model:</p>
			<p class="source-code"># class Book(models.Model): </p>
			<p class="source-code">    isbn = fields.Char(help="Use a valid ISBN-13 or </p>
			<p class="source-code">      ISBN-10.")</p>
			<p class="source-code">    publisher_id = fields.Many2one(index=True)</p>
			<p>This modifies the fields with the specified attributes, leaving all the other attributes that were not explicitly mentioned unmodified.</p>
			<p>Once we upgrade the module, going to the book form and hovering the mouse pointer over the ISBN field will show the tooltip message that was added to the field. The effect of <strong class="source-inline">index=True</strong> is harder to notice, but it can be seen in the field definition, which can be <a id="_idIndexMarker300"/>accessed from the <strong class="bold">Developer Tools</strong> menu by choosing the <strong class="bold">View Fields</strong> option, or from the <strong class="bold">Settings</strong> | <strong class="bold">Technical</strong> | <strong class="bold">Database Structure</strong> | <strong class="bold">Models</strong> menu:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="Images/Figure_4.2_B16119.jpg" alt="Figure 4.2 – The Publisher field with the index enabled&#13;&#10;" width="1045" height="654"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 – The Publisher field with the index enabled</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>Extending Python methods to add features to the business logic</h2>
			<p>The <a id="_idIndexMarker301"/>business logic that's coded in Python methods can also be extended. For this, Odoo uses the Python object inheritance mechanism to extend the inherited class behavior.</p>
			<p>As a practical example, we will extend the library book ISBN validation logic. The logic provided by the base Library app validates modern 13-digit ISBNs. But some older titles might come with a 10-digit ISBN. The <strong class="source-inline">_check_isbn()</strong> method should be extended to also validate these cases.</p>
			<p>Edit the <strong class="source-inline">library_member/models/library_book.py</strong> file by adding the following <a id="_idIndexMarker302"/>code:</p>
			<p class="source-code"># class Book(models.Model):</p>
			<p class="source-code">    def _check_isbn(self):</p>
			<p class="source-code">        self.ensure_one()</p>
			<p class="source-code">        digits = [int(x) for x in self.isbn if x.isdigit()]</p>
			<p class="source-code">        if len(digits) == 10:</p>
			<p class="source-code">            ponderators = [1, 2, 3, 4, 5, 6, 7, 8, 9]</p>
			<p class="source-code">            total = sum(</p>
			<p class="source-code">                a * b for a, b in zip(digits[:9], </p>
			<p class="source-code">                ponderators)</p>
			<p class="source-code">            )</p>
			<p class="source-code">            check = total % 11</p>
			<p class="source-code">            return digits[-1] == check</p>
			<p class="source-code">        else:</p>
			<p class="source-code">            return super()._check_isbn()</p>
			<p>To extend a method, in the inherited class, we define a method with the same name – <strong class="source-inline">_check_isbn()</strong>, in this case. This method should, at some point, use <strong class="source-inline">super()</strong> to call the corresponding method that was implemented in the parent class. In this example, the particular code that was used was <strong class="source-inline">super()._check_isbn()</strong>.</p>
			<p>In this method extension, we added our logic before the <strong class="source-inline">super()</strong> call, running the parent class code. It checks whether the ISBN is 10 digits long. In that case, the added ISBN-10 validation logic is executed. Otherwise, it falls back to the original ISBN checking logic, handling the 13-digit case.</p>
			<p>We can try this, or even better, write a test case. Here is an example of a 10-digit ISBN: the original ISBN of William Golding's <em class="italic">Lord of the Flies</em> is 0-571-05686-5.</p>
			<p class="callout-heading">Changes in Odoo 11</p>
			<p class="callout">In Odoo 11, the Python version that was used changed from <em class="italic">2.7</em> to <em class="italic">3.5</em> or later. Python 3 has breaking changes and is not fully compatible with Python 2. In particular, the <strong class="source-inline">super()</strong> syntax was simplified in Python 3. For previous Odoo versions that use Python 2, <strong class="source-inline">super()</strong> needs two arguments – the class name and <strong class="source-inline">self</strong>; for example, <strong class="source-inline">super(Book, self)._check_isbn()</strong>.</p>
			<p>Classic inheritance<a id="_idIndexMarker303"/> is<a id="_idIndexMarker304"/> the most frequently used extension mechanism. But Odoo provides additional extension approaches that are useful in other cases. We will explore those next.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor130"/>More model inheritance mechanisms</h1>
			<p>The previous <a id="_idIndexMarker305"/>section discussed <strong class="bold">classic inheritance</strong>, which can be seen as an <em class="italic">in-place extension</em>. This is the most frequently used approach, but the Odoo framework also supports a few other extension mechanisms that are useful in other cases.</p>
			<p>These are delegation inheritance, prototype inheritance, and the use of mixins:</p>
			<ul>
				<li><strong class="bold">Delegation inheritance</strong> embeds<a id="_idIndexMarker306"/> another model in the inheriting one. For example, a <strong class="source-inline">User</strong> record<a id="_idIndexMarker307"/> embeds a <strong class="source-inline">Partner</strong> record, so that a <strong class="source-inline">User</strong> record has all the fields available for the <strong class="source-inline">Partner</strong> records, plus the fields specific to the <strong class="source-inline">User</strong> records. It is used through the <strong class="source-inline">_inherits</strong> attribute.</li>
				<li><strong class="bold">Prototype inheritance</strong> creates<a id="_idIndexMarker308"/> a new <a id="_idIndexMarker309"/>model by copying the features from the inherited model and has a database table and data. It is not used often and it is never used in the Odoo-included add-on modules. It is used to set <strong class="source-inline">_inherit</strong> with the model to copy and the <strong class="source-inline">_name</strong> attribute with the identifier for the new model to be created.</li>
				<li><strong class="bold">Mixin classes</strong> are <a id="_idIndexMarker310"/>abstract models that implement <a id="_idIndexMarker311"/>generic features that are to be reused in other models. They are like feature containers, ready to be added to other models, and are not expected to be used alone. An example is the <strong class="source-inline">mail.thread</strong> model, which is provided by the <strong class="source-inline">mail</strong> add-on module. It implements the chatter and messaging features that are available in several models throughout Odoo, such as <em class="italic">Partners</em> and <em class="italic">Sales Quotations</em>. A <strong class="source-inline">mixin</strong> class is constructed from <strong class="source-inline">Models.abstract</strong>, instead of <strong class="source-inline">Models.model</strong>, and is used with <strong class="source-inline">_inherit</strong>.</li>
			</ul>
			<p>The next few sections explore these possibilities in more detail.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor131"/>Embedding models using delegation inheritance</h2>
			<p><strong class="bold">Delegation inheritance</strong> allows <a id="_idIndexMarker312"/>us to reuse data structures, without duplication in the database. It embeds an instance of the<a id="_idIndexMarker313"/> delegated model inside the inheriting model.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To be technically precise, delegation inheritance is not real object inheritance; instead, it is object composition, where some features of an object are delegated to, or provided by, a second object.</p>
			<p>Note the following about delegation:</p>
			<ul>
				<li>Creating a new model record also creates and links a delegated model record.</li>
				<li>Fields from the delegated model that don't exist in the inheriting model are available for read and write operations, behaving like related computed fields.</li>
			</ul>
			<p>For example, for the User model, each record contains a Partner record, so the fields you find on a Partner will be available, plus a few fields that are specific to users.</p>
			<p>For the Library project, we want to add <a id="_idIndexMarker314"/>a <strong class="bold">Library Members</strong> model. Members will be able to borrow books and have a library card to be used when borrowing. Member master data should include the card number, plus some personal information, such as email and address. The Partner model already supports contact and address information, so it's best to reuse it, rather than duplicating the data structures.</p>
			<p>To add the<a id="_idIndexMarker315"/> Partner fields to the Library Member <a id="_idIndexMarker316"/>model using delegation inheritance, follow these steps:</p>
			<ol>
				<li value="1">The Python file that will be used to implement inheritance must be imported. Edit <strong class="source-inline">library_member/model/__init__.py</strong> by adding the following highlighted line:<p class="source-code">from . import library_book</p><p class="source-code"><strong class="bold">from . import library_member</strong></p></li>
				<li>Next, add the Python file describing the new Library Member model, <strong class="source-inline">library_member/models/library_member.py</strong>, which contains the following code:<p class="source-code">from odoo import fields, models</p><p class="source-code">class Member(models.Model): </p><p class="source-code">    _name = "library.member"</p><p class="source-code">    _description = "Library Member"</p><p class="source-code">    card_number = fields.Char()</p><p class="source-code">    partner_id = fields.Many2one(</p><p class="source-code">        "res.partner",</p><p class="source-code"><strong class="bold">        delegate=True,</strong></p><p class="source-code">        ondelete="cascade",</p><p class="source-code">        required=True)</p><p>With delegation inheritance, the <strong class="source-inline">library.member</strong> model embeds the inherited model, <strong class="source-inline">res.partner</strong>, so that when a new Member record is created, a related Partner is automatically created and referenced in the <strong class="source-inline">partner_id</strong> field.</p><p>Through<a id="_idIndexMarker317"/> the delegation mechanism, all the fields of the embedded model are automatically made available as if they were fields of the parent model fields. In this case, the Library Member model has all of the Partner fields available for use, such as <strong class="source-inline">name</strong>, <strong class="source-inline">address</strong>, and <strong class="source-inline">email</strong>, plus the ones specific to members, such as <strong class="source-inline">card_number</strong>. Behind the scenes, the Partner fields are stored in the linked Partner record, and no data structure duplication occurs.</p><p>Delegation inheritance <a id="_idIndexMarker318"/>works only at the data level, not at the logic level. No methods from the inherited model are inherited. They are still accessible using<a id="_idIndexMarker319"/> the <strong class="bold">dot operator</strong>, which is used to access an object's attributes, also known as <strong class="bold">dot notation</strong>. For <a id="_idIndexMarker320"/>example, for the Library Member model, <strong class="source-inline">partner_id.open_parent()</strong> runs the <strong class="source-inline">open_parent()</strong> method of the embedded Partner record.</p><p>There is an alternative syntax for delegation inheritance that's available through the <strong class="source-inline">_inherits</strong> model attribute. It comes from the pre-Odoo 8 old API, and it is still widely used. The Library Model example with the same effect as earlier looks like this:</p><p class="source-code">from odoo import fields, models</p><p class="source-code">class Member(models.Model): </p><p class="source-code">    _name = "library.member"</p><p class="source-code">    _description = "Library Member"</p><p class="source-code"><strong class="bold">    _inherits = {"res.partner": "partner_id"}</strong></p><p class="source-code">    card_number = fields.Char()</p><p class="source-code">    partner_id = fields.Many2one(</p><p class="source-code">        "res.partner",</p><p class="source-code">        ondelete="cascade",</p><p class="source-code">        required=True) </p><p>To finish adding this new model, a few additional steps are needed – add the security ACLs, a menu item, and some view3.</p></li>
				<li>To add<a id="_idIndexMarker321"/> the security ACLs, create the <strong class="source-inline">library_member/security/ir.model.access.csv</strong> file with<a id="_idIndexMarker322"/> this content:<p class="source-code">id,name,model_id:id,group_id:id,perm_read,perm_write,perm_create,perm_unlink</p><p class="source-code">access_member_user,Member User Access,model_library_member,library_app.library_group_user,1,1,1,0</p><p class="source-code">access_member_manager,Member Manager Access,model_library_member,library_app.library_group_manager,1,1,1,4</p></li>
				<li>To add the menu item, create the <strong class="source-inline">library_member/views/library_menu.xml</strong> file with the following code:<p class="source-code">&lt;odoo&gt;</p><p class="source-code">    &lt;act_window id="action_library_member"</p><p class="source-code">      name="Library Members"</p><p class="source-code">      res_model="library.member"</p><p class="source-code">      view_mode="tree,form" /&gt;</p><p class="source-code">    &lt;menuitem id="menu_library_member"</p><p class="source-code">      name="Members"</p><p class="source-code">      action="action_library_member"</p><p class="source-code">      parent="library_app.menu_library" /&gt;</p><p class="source-code">&lt;/odoo5</p></li>
				<li>To add the views, create the <strong class="source-inline">library_member/views/member_view.xml</strong> file <a id="_idIndexMarker323"/>with the <a id="_idIndexMarker324"/>following code:<p class="source-code">&lt;odoo&gt;</p><p class="source-code">  &lt;record id="view_form_member" model="ir.ui.view"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Library Member Form </p><p class="source-code">      View&lt;/field&gt;</p><p class="source-code">    &lt;field name="model"&gt;library.member&lt;/field&gt;</p><p class="source-code">    &lt;field name="arch" type="xml"&gt;</p><p class="source-code">      &lt;form&gt;</p><p class="source-code">        &lt;group&gt;</p><p class="source-code">          &lt;field name="name" /&gt;</p><p class="source-code">          &lt;field name="email" /&gt;</p><p class="source-code">          &lt;field name="card_number" /&gt;</p><p class="source-code">        &lt;/group&gt;</p><p class="source-code">      &lt;/form&gt;</p><p class="source-code">    &lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">  &lt;record id="view_tree_member" model="ir.ui.view"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Library Member List </p><p class="source-code">      View&lt;/field&gt;</p><p class="source-code">    &lt;field name="model"&gt;library.member&lt;/field&gt;</p><p class="source-code">    &lt;field name="arch" type="xml"&gt;</p><p class="source-code">      &lt;tree&gt;</p><p class="source-code">          &lt;field name="name" /&gt;</p><p class="source-code">          &lt;field name="card_number" /&gt;</p><p class="source-code">      &lt;/tree&gt;</p><p class="source-code">    &lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p><p class="source-code">&lt;/odoo6</p></li>
				<li>Finally, we <a id="_idIndexMarker325"/>should edit the<a id="_idIndexMarker326"/> manifest to declare these three new files:<p class="source-code">"data": [</p><p class="source-code">    <strong class="bold">"security/ir.model.access.csv",</strong></p><p class="source-code">    "views/book_view.xml",</p><p class="source-code"><strong class="bold">    "views/member_view.xml",</strong></p><p class="source-code"><strong class="bold">    "views/library_menu.xml",</strong></p><p class="source-code">],</p></li>
			</ol>
			<p>If everything was entered correctly, after a module upgrade, we should be able to work with the new Library Member model.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor132"/>Copying models with prototype inheritance</h2>
			<p>Classic<a id="_idIndexMarker327"/> inheritance uses the <strong class="source-inline">_inherit</strong> attribute to extend a model. Since the <strong class="source-inline">_name</strong> attribute is not modified, it effectively performs<a id="_idIndexMarker328"/> an in-place modification on the same model. </p>
			<p>If the <strong class="source-inline">_name</strong> attribute is also modified, along with <strong class="source-inline">_inherit</strong>, we get a new model that is a copy of the inherited one. This new model can then have features added to it that are specific to it and won't be added to the parent model. The copied model is independent of the parent model, which will be unaffected by its modifications. It has its own database table and data. The official documentation calls this <strong class="bold">prototype inheritance</strong>.</p>
			<p>In practice, there is little benefit in using <strong class="source-inline">_inherit</strong> to copy a model. Instead, delegation inheritance is preferred, since it reuses data structures without duplicating them.</p>
			<p>Things <a id="_idIndexMarker329"/>become more interesting when we use inheritance from multiple parents. For this, <strong class="source-inline">_inherit</strong> will be a list of model names, instead of a single name.</p>
			<p>This can <a id="_idIndexMarker330"/>be used to mix several models into one. It allows us to have a model proposing features to be reused several times. This pattern is widely used with abstract mixin classes. This will be discussed in detail in the next section.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor133"/>Reusing model features using mixin classes</h2>
			<p>Setting the <strong class="source-inline">_inherit</strong> attribute <a id="_idIndexMarker331"/>with a list of model names <a id="_idIndexMarker332"/>will inherit the features from those models. Most of the time, this is done to leverage mixin classes.</p>
			<p>A <strong class="bold">mixin class</strong> is like <a id="_idIndexMarker333"/>a container of features, meant to be reused. They implement generic features, ready to be added to other models. They are not expected to stand alone and be used directly. So, they are abstract models, based on <strong class="source-inline">models.AbstractModel</strong>, with no actual representation in the database, instead of <strong class="source-inline">models.Model</strong>.</p>
			<p>The Odoo standard add-ons propose several useful mixins. Searching the code for <strong class="source-inline">models.AbstractModel</strong> will reveal them. What's noteworthy, and probably the two most widely used, are these mixins, which are provided by the Discuss app (the <strong class="source-inline">mail</strong> add-on module):</p>
			<ul>
				<li>The <strong class="source-inline">mail.thread</strong> mixin provides features for the message board, also known as <strong class="bold">chatter</strong>, which can be found at the bottom or right-hand side of many document forms, along with the logic regarding messages and notifications.</li>
				<li>The <strong class="source-inline">mail.activity.mixin</strong> mixin provides <em class="italic">activities</em>, which are also exposed through the chatter discussion widget, to define and plan to-do tasks.<p class="callout-heading">Changes in Odoo 11</p><p class="callout">The <em class="italic">activities</em> mixin is a new feature that was introduced in Odoo 11 and is not available in earlier versions.</p></li>
			</ul>
			<p>Chatter and activities are widely used features, and in the next section, we will take a moment to <a id="_idIndexMarker334"/>demonstrate how to add them.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor134"/>Adding message chatter and activities to a model</h2>
			<p>We will now <a id="_idIndexMarker335"/>add the message chatter and activity mixins to the <strong class="bold">Library Members</strong> model. This is what is needed to add them:</p>
			<ol>
				<li value="1">Add the dependency to the add-on module that's providing the mixin models; that is, <strong class="source-inline">mail</strong>.</li>
				<li>Inherit the <strong class="source-inline">mail.thread</strong> and <strong class="source-inline">mail.activity.mixin</strong> mixin classes.</li>
				<li>Add fields to the <strong class="source-inline">Form</strong> view.</li>
			</ol>
			<p>Let's check the preceding steps in detail:</p>
			<ol>
				<li value="1">To add the dependency to the <strong class="source-inline">mail</strong> add-on, edit the <strong class="source-inline">__manifest__.py</strong> file:<p class="source-code">    "depends": ["library_app", <strong class="bold">"mail"</strong>], </p></li>
				<li>To inherit the mixin classes, edit the <strong class="source-inline">library_member/models/library_member.py</strong> file to add the following highlighted text:<p class="source-code">class Member(models.Model): </p><p class="source-code">    _name = "library.member"</p><p class="source-code">    _description = "Library Member"</p><p class="source-code">    _inherits = {"res.partner": "partner_id"}</p><p class="source-code"><strong class="bold">    _inherit = ["mail.thread", "mail.activity.mixin"]</strong></p><p>With this extra line of code, our model will include all the additional fields and methods provided by these mixins.</p><p class="callout-heading">Tip</p><p class="callout">In this example, the mixins are being added to a new model that is being created now. If we were adding these mixins to an already existing model, which had been created in another module, then the parent model should also be included in the inherited list; for example,</p><p class="callout"><strong class="source-inline">_inherit = ["library.member", "mail.thread", "mail.activity.mixin"]</strong>.</p></li>
				<li>Finally, we<a id="_idIndexMarker336"/> must add the relevant fields to <strong class="source-inline">Library Member Form</strong>. Edit the <strong class="source-inline">library_member/views/member_view.xml</strong> file by adding the following highlighted code:<p class="source-code">  &lt;record id="view_form_member" model="ir.ui.view"&gt;</p><p class="source-code">    &lt;field name="name"&gt;Library Member Form </p><p class="source-code">      View&lt;/field&gt;</p><p class="source-code">    &lt;field name="model"&gt;library.member&lt;/field&gt;</p><p class="source-code">    &lt;field name="arch" type="xml"&gt;</p><p class="source-code">      &lt;form&gt;</p><p class="source-code">        &lt;group&gt;</p><p class="source-code">          &lt;field name="name" /&gt;</p><p class="source-code">          &lt;field name="email" /&gt;</p><p class="source-code">          &lt;field name="card_number" /&gt;</p><p class="source-code">        &lt;/group&gt;</p><p class="source-code"><strong class="bold">        &lt;!-- mail mixin fields --&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;div class="oe_chatter"&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;field name="message_follower_ids"</strong></p><p class="source-code"><strong class="bold">                   widget="mail_followers"/&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;field name="activity_ids"</strong></p><p class="source-code"><strong class="bold">                   widget="mail_activity"/&gt;</strong></p><p class="source-code"><strong class="bold">            &lt;field name="message_ids"</strong></p><p class="source-code"><strong class="bold">                   widget="mail_thread"/&gt;</strong></p><p class="source-code"><strong class="bold">        </strong><strong class="bold">&lt;/div&gt;</strong></p><p class="source-code">      &lt;/form&gt;</p><p class="source-code">    &lt;/field&gt;</p><p class="source-code">  &lt;/record&gt;</p></li>
			</ol>
			<p>As we <a id="_idIndexMarker337"/>can see, the <strong class="source-inline">mail</strong> module not only provides fields for the followers, activities, and messages, but it also provides specific web client widgets for them, all of which are being used here.</p>
			<p>Once the module has been upgraded, the <strong class="bold">Library Members</strong> form should look like this:</p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/Figure_4.3_B16119.jpg" alt="Figure 4.3 – The Library Members form view&#13;&#10;" width="900" height="529"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 – The Library Members form view</p>
			<p>Note that the mixins alone don't cause any changes to be made to access security, including record rules. In some cases, there are record rules in place, limiting what records are accessible to each user. For example, if we want users to only view records they are followers<a id="_idIndexMarker338"/> of, a record rule for that must be explicitly added.</p>
			<p>The <strong class="source-inline">mail.thread</strong> model includes a field for listing the follower <strong class="bold">Partners</strong>, called <strong class="source-inline">message_partner_ids</strong>. To implement the followers' access rules, a <strong class="bold">record rule</strong> should be added, with a <strong class="bold">domain</strong> expression including a condition similar to <strong class="source-inline">[('message_partner_ids', 'in', [user.partner_id.id])]</strong>.</p>
			<p>With that, we've seen how to extend modules at the model and logic layers. The next step is to extend the views to reflect the changes that were made in the model layer.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor135"/>Extending views and data</h1>
			<p>Views <a id="_idIndexMarker339"/>and other data components can also be modified by an extension module. For views, the case is usually to add features. The view presentation structure is defined with XML. To extend this XML, we must locate the node to extend and then declare the action to perform there, such as inserting additional XML elements.</p>
			<p>The other data elements represent records that were written to the database. Extension modules can write on them to change some values.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor136"/>Extending views</h2>
			<p>Views are<a id="_idIndexMarker340"/> defined using XML and are stored in the architecture field, <strong class="source-inline">arch</strong>. To extend a view, we must locate the node where the extension will take place, and then perform the intended change, such as adding XML elements.</p>
			<p>Odoo provides a simplified notation to extend XML by using the XML tag we want to match –  <strong class="source-inline">&lt;field&gt;</strong>, for example – with one or more distinctive attributes to match, such as <strong class="source-inline">name</strong>. Then, we must add the <strong class="source-inline">position</strong> attribute to declare the kind of modification to make.</p>
			<p>Recovering the example we used earlier in this chapter, to add additional content after the <strong class="source-inline">isbn</strong> field, we can use the following code:</p>
			<p class="source-code">      &lt;field name="isbn" position="after"&gt;</p>
			<p class="source-code">        &lt;!-- Changed content goes here --&gt;</p>
			<p class="source-code">      &lt;/field&gt;</p>
			<p>Any XML element and attribute can be used to select the node to use as the extension point, except for <strong class="source-inline">string</strong> attributes. The values of string attributes are translated into the user's active language during view generation, so they can't be reliably used as node selectors.</p>
			<p>The extension<a id="_idIndexMarker341"/> operation to perform is declared with the <strong class="source-inline">position</strong> attribute. Several operations are allowed, as follows:</p>
			<ul>
				<li><strong class="source-inline">inside</strong> (the default): Appends the content inside the selected node. The node should be a container, such as <strong class="source-inline">&lt;group&gt;</strong> or <strong class="source-inline">&lt;page&gt;</strong>.</li>
				<li><strong class="source-inline">after</strong>: Adds the content after the selected node.</li>
				<li><strong class="source-inline">before</strong>: Adds the content before the selected node.</li>
				<li><strong class="source-inline">replace</strong>: Replaces the selected node. If it's used with empty content, it deletes the element. Since Odoo 10, it also allows you to wrap an element with other markups by using <strong class="source-inline">$0</strong> in the content to represent the element being replaced; for example, <strong class="source-inline">&lt;field name="name" position="replace"&gt;&lt;h1&gt;$0&lt;/h1&gt;&lt;/field&gt;</strong>.</li>
				<li><strong class="source-inline">attributes</strong>: Modifies the attribute values for the matched element. The content should have one or more <strong class="source-inline">&lt;attribute name="attr-name"&gt;value&lt;attribute&gt;</strong> elements, such as <strong class="source-inline">&lt;attribute name="invisible"&gt;True&gt;&lt;/attribute&gt;</strong>. If it's used with no body, such as in <strong class="source-inline">&lt;attribute name="invisible"/&gt;</strong>, the attribute is removed from the selected element.<p class="callout-heading">Tip</p><p class="callout">While <strong class="source-inline">position="replace"</strong> allows us to delete XML elements, this should be avoided. It can break based on modules that may be using the deleted node as an extension point to add other elements. As an alternative, consider leaving the element and making it invisible instead.</p></li>
			</ul>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor137"/>Moving XML nodes to a different location</h2>
			<p>Except for the <strong class="source-inline">attributes</strong> operation, the preceding locators can be combined with a child <a id="_idIndexMarker342"/>element with <strong class="source-inline">position="move"</strong>. The effect is to move the child locator target node to the parent locator's target position.</p>
			<p class="callout-heading">Changes in Odoo 12</p>
			<p class="callout">The <strong class="source-inline">position="move"</strong> child locator is new in Odoo 12 and is not available in previous versions.</p>
			<p>Here is an example of moving <strong class="source-inline">my_field</strong> from its current location to the position after <strong class="source-inline">target_field</strong>:</p>
			<p class="source-code">&lt;field name="target_field" position="after"&gt;</p>
			<p class="source-code">    &lt;field name="my_field" position="move"/&gt;</p>
			<p class="source-code">&lt;/field&gt;</p>
			<p>The other view types, such as list and search views, also have an <strong class="source-inline">arch</strong> field and can be extended in the same way as form views can.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>Using XPath to select XML extension points</h2>
			<p>In some<a id="_idIndexMarker343"/> cases, we may not have an attribute with a unique value to use as the XML node selector. This can happen when the element to select does not have a <strong class="source-inline">name</strong> attribute, as is often the case for <strong class="source-inline">&lt;group&gt;</strong>, <strong class="source-inline">&lt;notebook&gt;</strong>, or <strong class="source-inline">&lt;page&gt;</strong> view elements. Another case is when there are several elements with the same <strong class="source-inline">name</strong> attribute, as in the case of Kanban QWeb views, where the same field can be included more than once in the same XML template.</p>
			<p>For these cases, we need a more sophisticated way to locate the XML element to extend. Being XML, <strong class="bold">XPath expressions</strong> are<a id="_idIndexMarker344"/> the natural way to locate elements.</p>
			<p>For example, taking the book form view we defined in the previous chapter, an XPath expression for locating the <strong class="source-inline">&lt;field name="isbn"&gt;</strong> element is <strong class="source-inline">//field[@name]='isbn'</strong>. This expression finds <strong class="source-inline">&lt;field&gt;</strong> elements with a <strong class="source-inline">name</strong> attribute equal to <strong class="source-inline">isbn</strong>.</p>
			<p>The XPath equivalent to the book form view extension that we created in the previous section would be as follows:</p>
			<p class="source-code">&lt;xpath expr="//field[@name='isbn']" position="after"&gt;</p>
			<p class="source-code">    &lt;field name="is_available" /&gt;</p>
			<p class="source-code">&lt;/xpath&gt;</p>
			<p>More<a id="_idIndexMarker345"/> information on the supported XPath syntax <a id="_idIndexMarker346"/>can be found in the official Python documentation: <a href="https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax">https://docs.python.org/3/library/xml.etree.elementtree.html#supported-xpath-syntax</a>.</p>
			<p>If an XPath expression matches multiple elements, only the first one will be selected as the target for an extension. Therefore, they should be made as specific as possible using unique attributes. Using the <strong class="source-inline">name</strong> attribute is the easiest way to ensure that we find the elements we want to use as an extension point. Thus, it is important to have these unique identifiers in the XML elements of the views we create.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>Modifying existing data</h2>
			<p>Regular <a id="_idIndexMarker347"/>data records can also be <em class="italic">extended</em>, which, in practice, means writing over existing values. For this, we just need to identify the record to write on, as well as the fields and values to update. XPath expressions are not needed since we are not modifying XML <strong class="source-inline">arch</strong> structures, as we do for views.</p>
			<p>The <strong class="source-inline">&lt;record id="x" model="y"&gt;</strong> data loading elements perform an insert or update operation on model <strong class="source-inline">y</strong>: if record <strong class="source-inline">x</strong> does not exist, it is created; otherwise, it is updated/written over.</p>
			<p>Records in other modules can be accessed using the <strong class="source-inline">&lt;module&gt;.&lt;identifier&gt;</strong> global identifier, so a module can update a record that's been created by another module.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The dot (<strong class="source-inline">.</strong>) is reserved to separate the module name from the object identifier. So, it can't be used in identifier names. Instead, use the underscore (<strong class="source-inline">_</strong>) character.</p>
			<p>As an example, we will change the name of the User security group to <strong class="source-inline">Librarian</strong>. The record to modify was created in the <strong class="source-inline">library_app</strong> module, with the <strong class="source-inline">library_app.library_group_user</strong> identifier.</p>
			<p>To do this, we <a id="_idIndexMarker348"/>will add the <strong class="source-inline">library_member/security/library_security.xml</strong> file, along with the following code:</p>
			<p class="source-code">&lt;odoo&gt;</p>
			<p class="source-code">  &lt;!-- Modify Group name --&gt;</p>
			<p class="source-code"><strong class="bold">  &lt;record id="library_app.library_group_user" </strong></p>
			<p class="source-code"><strong class="bold">    model="res.groups"&gt; </strong></p>
			<p class="source-code"><strong class="bold">    &lt;field name="name"&gt;Librarian&lt;/field&gt;</strong></p>
			<p class="source-code"><strong class="bold">  &lt;/record&gt;</strong></p>
			<p class="source-code">&lt;/odoo&gt;</p>
			<p>Note that we used a <strong class="source-inline">&lt;record&gt;</strong> element, writing only to the <strong class="source-inline">name</strong> field. You can think of this as a write operation in this field.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When using a <strong class="source-inline">&lt;record&gt;</strong> element, we can select the fields we want to write on, but the same is not true for shortcut elements, such as <strong class="source-inline">&lt;menuitem&gt;</strong> and <strong class="source-inline">&lt;act_window&gt;</strong>. These need all of the attributes to be provided and missing any of them will set the corresponding field to an empty value. However, you can use <strong class="source-inline">&lt;record&gt;</strong> to set a value on a field that was created through a shortcut element.</p>
			<p>Don't forget to add the <strong class="source-inline">library_member/security/library_security.xml</strong> file to the <strong class="source-inline">data</strong> key in the manifest file. Having done this and upgraded the module, we should see the name change in the user groups.</p>
			<p>Extending views allows you to introduce modifications to the backend presentation layer. But the same can be done to the frontend web presentation layer. This is what we will address in the next section.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor140"/>Extending web pages</h1>
			<p>Extensibility is<a id="_idIndexMarker349"/> a key design choice for the Odoo framework, and <a id="_idIndexMarker350"/>the Odoo web components are no exception. So, Odoo web controllers and templates can be also extended.</p>
			<p>The Library app that we created in the previous <a href="B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 3</em></a>, <em class="italic">Your First Odoo Application</em>, provided a book catalog page that now needs to be improved.</p>
			<p>We will extend it to leverage the book availability information that was added by the Library Members module:</p>
			<ul>
				<li>On the controller side, we will add support to a query string parameter to filter only the available books; that is, <strong class="source-inline">/library/books?available=1</strong>.</li>
				<li>On the template side, we will specify the books that are not available.</li>
			</ul>
			<p>Let's start extending the web controller.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Extending the web controllers</h2>
			<p><strong class="bold">Web controllers</strong> are <a id="_idIndexMarker351"/>responsible for handling web requests and <a id="_idIndexMarker352"/>rendering the page to return as a response. They should focus on presentation logic, not deal with business logic, which should be incorporated into model methods instead.</p>
			<p>Supporting additional parameters or even URL routes is web presentation-specific and something appropriate for a web controller to deal with.</p>
			<p>The <strong class="source-inline">/library/books</strong> endpoint will be extended here to support a query string parameter, <strong class="source-inline">available=1</strong>, which we will use to filter the catalog of books so that it only displays the available titles.</p>
			<p>To extend an existing controller, we need to import the original object that created it, declare a Python class based on it, and then implement the class method holding the additional logic.</p>
			<p>The code to extend the controller should be added to the <strong class="source-inline">library_member/controllers/main.py</strong> file, as follows:</p>
			<p class="source-code">from odoo import http </p>
			<p class="source-code">from odoo.addons.library_app.controllers.main import Books </p>
			<p class="source-code">class BooksExtended(Books):</p>
			<p class="source-code">    @http.route()</p>
			<p class="source-code">    def list(self, **kwargs):</p>
			<p class="source-code">        response = super().list(**kwargs)</p>
			<p class="source-code">        if kwargs.get("available"):</p>
			<p class="source-code">            all_books = response.qcontext["books"]</p>
			<p class="source-code">            available_books = all_books.filtered(</p>
			<p class="source-code">              "is_available")</p>
			<p class="source-code">            response.qcontext["books"] = available_books</p>
			<p class="source-code">        return response</p>
			<p>The steps<a id="_idIndexMarker353"/> to add the controller code are as follows:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">library_member/controllers/main.py</strong> file, ensuring it contains the preceding code.</li>
				<li>Make this new Python file known to the module by adding the controller's subdirectory to the <strong class="source-inline">library_member/__init__.py</strong> file:<p class="source-code">from . import models</p><p class="source-code"><strong class="bold">from . import controllers</strong></p></li>
				<li>Add the <strong class="source-inline">library_member/controllers/__init__.py</strong> file with the following line of code:<p class="source-code">from . import main </p></li>
				<li>After this, accessing <strong class="source-inline">http://localhost:8069/library/books?available=1</strong> should only show us the books with the <strong class="source-inline">Is Available?</strong> field checked.</li>
			</ol>
			<p>Now, let's review the controller extension code to understand how it works.</p>
			<p>The controller to extend, <strong class="source-inline">Books</strong>, was originally declared by the <strong class="source-inline">library_app</strong> module, in the <strong class="source-inline">controllers/main.py</strong> file. So, to get a reference to it, we need to import <strong class="source-inline">odoo.addons.library_app.controllers.main</strong>.</p>
			<p>This is <a id="_idIndexMarker354"/>different from models, where we have a central registry available where we can get a reference to any model class, such as <strong class="source-inline">self.env['library.book']</strong>, without knowing the particular file that's implementing it. We don't have such a registry for controllers, and we need to know the module and file implementing the controller to be able to extend it.</p>
			<p>Then, the <strong class="source-inline">BooksExtended</strong> class is declared based on the original one, <strong class="source-inline">Books</strong>. The identifier name that's used for this class is not relevant. It is used as a vehicle to reference the original class and extend it.</p>
			<p>Next, we (re)define the controller method to be extended, which is <strong class="source-inline">list()</strong> in this case. It needs to be decorated with at least the simple <strong class="source-inline">@http.route()</strong> for its route to be kept active. If it's used like this, with no arguments, it will preserve the routes that are defined by the parent class. But we could also add parameters to this <strong class="source-inline">@http.route()</strong> decorator to replace and redefine the class routes.</p>
			<p>The <strong class="source-inline">list()</strong> method has a <strong class="source-inline">**kwargs</strong> argument, which captures all the parameters in the <strong class="source-inline">kwargs</strong> dictionary. These are the parameters that are given in the URL, such as <strong class="source-inline">?available=1</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Using a <strong class="source-inline">**kwargs</strong> argument that sweeps all the given arguments is not required, but it makes our URL tolerant to unexpected URL arguments. If we choose to specify particular arguments, if different ones are set, the page will fail immediately and return an <strong class="bold">internal error</strong> when<a id="_idIndexMarker355"/> trying to call the corresponding controller.</p>
			<p>The code for the <strong class="source-inline">list()</strong> method starts by calling the corresponding parent class method using <strong class="source-inline">super()</strong>. This returns the <strong class="source-inline">Response</strong> object that was computed by the parent method, including the attributes and the template to render, <strong class="source-inline">template</strong>, and the context to use when rendering, <strong class="source-inline">qcontext</strong>. But the HTML is yet to be generated. This will only happen when the controller finishes running. So, it is possible to change the <strong class="source-inline">Response</strong> attributes before the final rendering is done.</p>
			<p>The method checks <strong class="source-inline">kwargs</strong> for a non-empty value in the <strong class="source-inline">available</strong> key. If it is found, the <a id="_idIndexMarker356"/>non-available books are filtered out, and <strong class="source-inline">qcontext</strong> is updated with this recordset. So, when the controller's processing completes, the HTML will be rendered using the updated book's recordset, which will only include available books.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor142"/>Extending QWeb templates</h2>
			<p>Web page<a id="_idIndexMarker357"/> templates are XML documents, just like the other Odoo view types, and selector expressions can be used, as we do for other view types, such as forms. QWeb templates are usually more complex since they include more HTML elements, so most of the time, the more versatile <strong class="source-inline">XPath</strong> expressions are needed.</p>
			<p>To modify the actual presentation of the web page, we should extend the QWeb template being used. As an example of this, we will extend <strong class="source-inline">library_app.book_list_template</strong> to add visual information about the books that are not available.</p>
			<p>A QWeb extension is a <strong class="source-inline">&lt;template&gt;</strong> element that uses the additional <strong class="source-inline">inherit_id</strong> attribute to identify the QWeb template to extend. It is <strong class="source-inline">library_app.book_list_template</strong> in this case.</p>
			<p>Follow these steps: </p>
			<ol>
				<li value="1">Add the <strong class="source-inline">library_member/views/book_list_template.xml</strong> file, along with the following code:<p class="source-code">&lt;odoo&gt;</p><p class="source-code">  &lt;template id="book_list_extended"</p><p class="source-code">            name="Extended Book List"</p><p class="source-code">            inherit_id=</p><p class="source-code">              "library_app.book_list_template"&gt;</p><p class="source-code"><strong class="bold">    &lt;xpath expr="//span[@t-field='book.publisher_id']"</strong></p><p class="source-code"><strong class="bold">           position="after"&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;t t-if="not book.is_available"&gt;</strong></p><p class="source-code"><strong class="bold">        &lt;b&gt;(Not Available)&lt;/b&gt;</strong></p><p class="source-code"><strong class="bold">      &lt;/t&gt;</strong></p><p class="source-code"><strong class="bold">    &lt;/xpath&gt;</strong></p><p class="source-code">  &lt;/template&gt;</p><p class="source-code">&lt;/odoo&gt;</p><p>The preceding example uses an <strong class="source-inline">xpath</strong> notation. Note that in this case, we could <a id="_idIndexMarker358"/>have also used the equivalent simplified notation; that is, <strong class="source-inline">&lt;span t-field="book.publisher_id" position=after&gt;</strong>.</p></li>
				<li>Declare this additional data file in the add-on manifest; that is, <strong class="source-inline">library_member/__manifest__.py</strong>:<p class="source-code">"data": [</p><p class="source-code">    "security/library_security.xml",</p><p class="source-code">    "security/ir.model.access.csv",</p><p class="source-code">    "views/book_view.xml",</p><p class="source-code">    "views/member_view.xml",</p><p class="source-code">    "views/library_menu.xml",</p><p class="source-code"><strong class="bold">    "views/book_list_template.xml",</strong></p><p class="source-code">],</p></li>
			</ol>
			<p>After this, accessing <strong class="source-inline">http://localhost:8069/library/books</strong> should show the additional (not available) visual information on the books that are not available. Here is what the web page will look like:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/Figure_4.4_B16119.jpg" alt="Figure 4.4 – Books list web page with availability information&#13;&#10;" width="994" height="257"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 – Books list web page with availability information</p>
			<p>This <a id="_idIndexMarker359"/>completes our review of how to extend each type of Odoo component, from the data model to the user interface elements.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor143"/>Summary</h1>
			<p>Extensibility is a key feature of the Odoo framework. We can build add-on modules that change or add features to other existing add-ons at the several layers needed to implement features in Odoo. With this, our projects will be able to reuse and extend third-party add-on modules in a clean and modular way.</p>
			<p>At the model layer, we use the <strong class="source-inline">_inherit</strong> model attribute to get a reference to an existing model and then make in-place modifications to it. The field objects inside the model also support incremental definitions so that we can <em class="italic">redeclare</em> an existing field, providing only the attributes to change.</p>
			<p>Additional model inheritance mechanisms allow you to reuse data structures and business logic. Delegation inheritance, which is activated with the <strong class="source-inline">delegate=True</strong> attribute on a many-to-one relationship field (or the old-style <strong class="source-inline">inherits</strong> model attribute), makes all the fields from the related model available and reuses its data structure. Prototype inheritance, which uses <strong class="source-inline">_inherit</strong> with additional models, allows you to copy features (data structure definitions and methods) from other models and enables the use of abstract mixin classes, providing a set of reusable features, such as document discussion messages and followers.</p>
			<p>At the view layer, the view structures are defined using XML, and extensions can be made by locating an XML element (using XPath or the Odoo simplified syntax) and providing the XML fragment to add. Other data records that are created by a module can also be modified by extension modules by simply referencing the corresponding complete XML ID and performing a write operation on the intended fields.</p>
			<p>At the business logic layer, extensions can be made with the same mechanism that's used for model extension and redeclaring the methods to extend. Inside them, the <strong class="source-inline">super()</strong> Python function is used to call the code of the inherited method, and our additional code can run before or after that.</p>
			<p>For the frontend web pages, the presentation logic in controllers can be extended in a similar way to model methods, and the web templates are also views with XML structures, so these can be extended in the same way as the other view types.</p>
			<p>In the next chapter, we will dive deeper into models and explore everything they can offer us.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor144"/>Further reading</h1>
			<p>The following are some additional references to the official documentation, which can provide useful information regarding module extensions and inheritance mechanisms:</p>
			<ul>
				<li>Model inheritance: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html</a></li>
				<li>View inheritance: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/views.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/views.html</a></li>
				<li>Web controllers: <a href="https://www.odoo.com/documentation/15.0/developer/reference/backend/http.html">https://www.odoo.com/documentation/15.0/developer/reference/backend/http.html</a></li>
			</ul>
		</div>
	</div></body></html>