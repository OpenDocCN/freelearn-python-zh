<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Digging Deep into Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Digging Deep into Requests</h1></div></div></div><p>In this chapter, we are going to deal with advanced topics in the Requests module. There are many more features in the Requests module that makes the interaction with the web a cakewalk. Let us get to know more about different ways to use Requests module which helps us to understand the ease of using it.</p><p>In a nutshell, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Persisting parameters across requests using Session objects</li><li class="listitem" style="list-style-type: disc">Revealing the structure of request and response</li><li class="listitem" style="list-style-type: disc">Using prepared requests</li><li class="listitem" style="list-style-type: disc">Verifying SSL certificate with Requests</li><li class="listitem" style="list-style-type: disc">Body Content Workflow</li><li class="listitem" style="list-style-type: disc">Using generator for sending chunk encoded requests</li><li class="listitem" style="list-style-type: disc">Getting the request method arguments with event hooks</li><li class="listitem" style="list-style-type: disc">Iterating over streaming API</li><li class="listitem" style="list-style-type: disc">Self-describing the APIs with link headers</li><li class="listitem" style="list-style-type: disc">Transport Adapter</li></ul></div><div class="section" title="Persisting parameters across Requests using Session objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Persisting parameters across Requests using Session objects</h1></div></div></div><p>The Requests module contains a <code class="literal">session</code> object, which has the capability to persist settings across the requests. Using<a class="indexterm" id="id42"/> this <code class="literal">session</code> object, we can persist cookies, we can create prepared requests, we can use the keep-alive feature<a class="indexterm" id="id43"/> and do many more things. The Session object contains all the methods of Requests API such as <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, <code class="literal">DELETE</code> and so on. Before using all the capabilities of the Session object, let us get to know how to use sessions and persist cookies across requests.</p><p>Let us use the session method to get the resource.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import requests</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; session = requests.Session()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; response = requests.get("https://google.co.in", cookies={"new-cookie-identifier": "1234abcd"})</strong></span>
</pre></div><p>In the preceding example, we created a <code class="literal">session</code> object with <code class="literal">requests</code> and its <code class="literal">get</code> method is used to <a class="indexterm" id="id44"/>access a web resource.</p><p>The <code class="literal">cookie</code> value<a class="indexterm" id="id45"/> which we had set in the previous example will be accessible using <code class="literal">response.request.headers</code>.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; response.request.headers</strong></span>
<span class="strong"><strong>CaseInsensitiveDict({'Cookie': 'new-cookie-identifier=1234abcd', 'Accept-Encoding': 'gzip, deflate, compress', 'Accept': '*/*', 'User-Agent': 'python-requests/2.2.1 CPython/2.7.5+ Linux/3.13.0-43-generic'})</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; response.request.headers['Cookie']</strong></span>
<span class="strong"><strong>'new-cookie-identifier=1234abcd'</strong></span>
</pre></div><p>With <code class="literal">session</code> object, we can specify some default values of the properties, which needs to be sent to the server using GET, POST, PUT and so on. We can achieve this by specifying the values to the properties like <code class="literal">headers</code>, <code class="literal">auth</code> and so on, on a <code class="literal">Session</code> object.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; session.params = {"key1": "value", "key2": "value2"}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; session.auth = ('username', 'password')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; session.headers.update({'foo': 'bar'})</strong></span>
</pre></div><p>In the preceding example, we have set some default values to the properties—<code class="literal">params</code>, <code class="literal">auth</code>, and <code class="literal">headers</code> using the <code class="literal">session</code> object. We can override them in the subsequent request, as shown in the following example, if we want to:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; session.get('http://mysite.com/new/url', headers={'foo': 'new-bar'})</strong></span>
</pre></div></div></div>
<div class="section" title="Revealing the structure of a request and response"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Revealing the structure of a request and response</h1></div></div></div><p>A Requests object is the one<a class="indexterm" id="id46"/> which is created by the user when he/she tries to interact with a web resource. It will be sent as a prepared request to the server and does contain some parameters which are optional. Let us have an eagle eye view on the parameters:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Method</code>: This is the<a class="indexterm" id="id47"/> HTTP method to be used to interact with the web service. For example: GET, POST, PUT.</li><li class="listitem" style="list-style-type: disc"><code class="literal">URL</code>: The web address to <a class="indexterm" id="id48"/>which the request needs to be sent.</li><li class="listitem" style="list-style-type: disc"><code class="literal">headers</code>: A dictionary of<a class="indexterm" id="id49"/> headers to be sent in the request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">files</code>: This can be used <a class="indexterm" id="id50"/>while dealing with the multipart upload. It's the dictionary of files, with key as file name and value as file object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">data</code>: This is the body to be<a class="indexterm" id="id51"/> attached to the <code class="literal">request.json</code>. There <a class="indexterm" id="id52"/>are two cases that come in to the picture here:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If <code class="literal">json</code> is provided, <code class="literal">content-type</code> in the header is changed to <code class="literal">application/json</code> and at this point, <code class="literal">json</code> acts as a body to the request.</li><li class="listitem" style="list-style-type: disc">In the second case, if both <code class="literal">json</code> and <code class="literal">data</code> are provided together, <code class="literal">data</code> is silently ignored.</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">params</code>: A dictionary<a class="indexterm" id="id53"/> of URL parameters to append to the URL.</li><li class="listitem" style="list-style-type: disc"><code class="literal">auth</code>: This is used when we<a class="indexterm" id="id54"/> need to specify the authentication to the request. It's a tuple containing username and password.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cookies</code>: A dictionary<a class="indexterm" id="id55"/> or a cookie jar of cookies which can be added to the request.</li><li class="listitem" style="list-style-type: disc"><code class="literal">hooks</code>: A dictionary of callback<a class="indexterm" id="id56"/> hooks.</li></ul></div><p>A Response object contains<a class="indexterm" id="id57"/> the response of the server to a HTTP request. It is generated once Requests gets a response back from the server. It contains all of the information returned by the server and also stores the Request object we created originally.</p><p>Whenever we make a call to a server using the <code class="literal">requests</code>, two major transactions are taking place in this context which are listed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are constructing a Request object which will be sent out to the server to request a resource</li><li class="listitem" style="list-style-type: disc">A Response object is generated by the <code class="literal">requests</code> module</li></ul></div><p>Now, let us look at an example of getting a resource from Python's official site.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; response = requests.get('https://python.org')</strong></span>
</pre></div><p>In the preceding line of code, a <code class="literal">requests</code> object gets constructed and will be sent to <code class="literal">'https://python.org'</code>. Thus obtained Requests object will be stored in the <code class="literal">response.request</code> variable. We can access the headers of the Request object which was sent off to the server in the following way:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; response.request.headers</strong></span>
<span class="strong"><strong>CaseInsensitiveDict({'Accept-Encoding': 'gzip, deflate, compress', 'Accept': '*/*', 'User-Agent': 'python-requests/2.2.1 CPython/2.7.5+ Linux/3.13.0-43-generic'})</strong></span>
</pre></div><p>The headers returned by the server can be accessed with its 'headers' attribute as shown in the following <a class="indexterm" id="id58"/>example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; response.headers</strong></span>
<span class="strong"><strong>CaseInsensitiveDict({'content-length': '45950', 'via': '1.1 varnish', 'x-cache': 'HIT', 'accept-ranges': 'bytes', 'strict-transport-security': 'max-age=63072000; includeSubDomains', 'vary': 'Cookie', 'server': 'nginx', 'age': '557','content-type': 'text/html; charset=utf-8', 'public-key-pins': 'max-age=600; includeSubDomains; ..)</strong></span>
</pre></div><p>The <code class="literal">response</code> object contains different attributes like <code class="literal">_content</code>, <code class="literal">status_code</code>, <code class="literal">headers</code>, <code class="literal">url</code>, <code class="literal">history</code>, <code class="literal">encoding</code>, <code class="literal">reason</code>, <code class="literal">cookies</code>, <code class="literal">elapsed</code>, <code class="literal">request</code>.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; response.status_code</strong></span>
<span class="strong"><strong>200</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; response.url</strong></span>
<span class="strong"><strong>u'https://www.python.org/'</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; response.elapsed</strong></span>
<span class="strong"><strong>datetime.timedelta(0, 1, 904954)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; response.reason</strong></span>
<span class="strong"><strong>'OK'</strong></span>
</pre></div></div>
<div class="section" title="Using prepared Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Using prepared Requests</h1></div></div></div><p>Every request we send to the server turns to be a <code class="literal">PreparedRequest</code> by default. The <code class="literal">request</code> attribute<a class="indexterm" id="id59"/> of the <code class="literal">Response</code> object which is received from an API call or a session call is actually the <code class="literal">PreparedRequest</code> that was used.</p><p>There might be cases in which we ought to send a request which would incur an extra step of adding a different parameter. Parameters can be <code class="literal">cookies</code>, <code class="literal">files</code>, <code class="literal">auth</code>, <code class="literal">timeout</code> and so on. We can handle this extra step efficiently by using the combination of sessions and prepared requests. Let us look at an example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from requests import Request, Session</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; header = {}</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; request = Request('get', 'some_url', headers=header)</strong></span>
</pre></div><p>We are trying to send a <code class="literal">get</code> request with a header in the previous example. Now, take an instance where we are planning to send the request with the same method, URL, and headers, but we want to add some more parameters to it. In this condition, we can use the session method to receive complete session level state to access the parameters of the initial sent request. This can be done by using the <code class="literal">session</code> object.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; from requests import Request, Session</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; session = Session()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; request1 = Request('GET', 'some_url', headers=header)</strong></span>
</pre></div><p>Now, let us prepare a request using the <code class="literal">session</code> object to get the values of the <code class="literal">session</code> level state:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; prepare = session.prepare_request(request1)</strong></span>
</pre></div><p>We can send the request object <code class="literal">request</code> with more parameters now, as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; response = session.send(prepare, stream=True, verify=True)</strong></span>
<span class="strong"><strong>200</strong></span>
</pre></div><p>Voila! Huge time saving!</p><p>The <code class="literal">prepare</code> method prepares the complete request with the supplied parameters. In the previous example, the <code class="literal">prepare_request</code> method was used. There are also some other <a class="indexterm" id="id60"/>methods like <code class="literal">prepare_auth</code>, <code class="literal">prepare_body</code>, <code class="literal">prepare_cookies</code>, <code class="literal">prepare_headers</code>, <code class="literal">prepare_hooks</code>, <code class="literal">prepare_method</code>, <code class="literal">prepare_url</code> which are used to create individual properties.</p></div>
<div class="section" title="Verifying an SSL certificate with Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Verifying an SSL certificate with Requests</h1></div></div></div><p>Requests provides the facility<a class="indexterm" id="id61"/> to verify an SSL certificate for HTTPS requests. We can use the <code class="literal">verify</code> argument to check whether the host's SSL certificate is verified or not.</p><p>Let us consider a <a class="indexterm" id="id62"/>website which has got no SSL certificate. We shall send a GET request with the argument <code class="literal">verify</code> to it.</p><p>The syntax to send the request is as follows:</p><div class="informalexample"><pre class="programlisting">requests.get('no ssl certificate site', verify=True)</pre></div><p>As the website doesn't have an SSL certificate, it will result an error similar to the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>requests.exceptions.ConnectionError: ('Connection aborted.', error(111, 'Connection refused'))</strong></span>
</pre></div><p>Let us verify the SSL certificate for a website which is certified. Consider the following example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; requests.get('https://python.org', verify=True)</strong></span>
<span class="strong"><strong>&lt;Response [200]&gt;</strong></span>
</pre></div><p>In the preceding example, the result was <code class="literal">200,</code> as the mentioned website is SSL certified one.</p><p>If we do not want to verify the SSL certificate with a request, then we can put the argument <code class="literal">verify=False</code>. By default, the value of <code class="literal">verify</code> will turn to <code class="literal">True</code>.</p></div>
<div class="section" title="Body Content Workflow"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Body Content Workflow</h1></div></div></div><p>Take an instance where a continuous stream of data is being downloaded when we make a request. In this situation, the client has to listen to the server continuously until it receives the complete data. Consider the case of accessing the content from the response first and the worry about the body next. In the above two situations, we can use the parameter <code class="literal">stream</code>. Let us look at an example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; requests.get("https://pypi.python.org/packages/source/F/Flask/Flask-0.10.1.tar.gz", stream=True)</strong></span>
</pre></div><p>If we make a request with the parameter <code class="literal">stream=True,</code> the connection remains open and only the headers of the response will be downloaded. This gives us the capability to fetch the content whenever we need by specifying the conditions like the number of bytes of data.</p><p>The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">if int(request.headers['content_length']) &lt; TOO_LONG:
content = r.content</pre></div><p>By setting the parameter <code class="literal">stream=True</code> and by accessing the response as a file-like object that is <code class="literal">response.raw</code>, if we use the method <code class="literal">iter_content,</code> we can iterate over <code class="literal">response.data</code>. This<a class="indexterm" id="id63"/> will avoid reading of larger responses at once.</p><p>The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">iter_content(chunk_size=size in bytes, decode_unicode=False)</pre></div><p>In the same way, we can iterate through the content using <code class="literal">iter_lines</code> method which will iterate over the response data one line at a time.</p><p>The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">iter_lines(chunk_size = size in bytes, decode_unicode=None, delimitter=None)</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The important thing that should be noted while using the <code class="literal">stream</code> parameter is it doesn't release the connection when it is set as <code class="literal">True,</code> unless all the data is consumed or <code class="literal">response.close</code> is executed.</p></div></div><div class="section" title="The Keep-alive facility"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>The Keep-alive facility</h2></div></div></div><p>As the <code class="literal">urllib3</code> supports the<a class="indexterm" id="id64"/> reuse of the same socket connection for multiple requests, we can send many requests with one socket and receive the responses using the keep-alive feature in the <code class="literal">Requests</code> library.</p><p>Within a session, it turns to be automatic. Every request made within a session automatically uses the appropriate connection by default. The connection that is being used will be released after <a class="indexterm" id="id65"/>all the data from the body is read.</p></div><div class="section" title="Streaming uploads"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Streaming uploads</h2></div></div></div><p>A file-like object <a class="indexterm" id="id66"/>which is of massive size can be streamed and uploaded using the <code class="literal">Requests</code> library. All we need to do is to supply the contents of the stream as a value to the <code class="literal">data</code> attribute in the <code class="literal">request</code> call as shown in the following lines.</p><p>The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">with open('massive-body', 'rb') as file:
    requests.post('http://example.com/some/stream/url',
                  data=file)</pre></div></div></div>
<div class="section" title="Using generator for sending chunk encoded Requests"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec27"/>Using generator for sending chunk encoded Requests</h1></div></div></div><p>Chunked transfer encoding<a class="indexterm" id="id67"/> is a mechanism for transferring data in an HTTP request. With this mechanism, the <a class="indexterm" id="id68"/>data is sent in a series of chunks. Requests supports chunked transfer encoding, for both outgoing and incoming requests. In order to send a chunk encoded request, we need to supply a generator for your body.</p><p>The usage is shown in the following example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; def generator():</strong></span>
<span class="strong"><strong>...     yield "Hello "</strong></span>
<span class="strong"><strong>...     yield "World!"</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; requests.post('http://example.com/some/chunked/url/path',</strong></span>
<span class="strong"><strong>                  data=generator())</strong></span>
</pre></div></div>
<div class="section" title="Getting the request method arguments with event hooks"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec28"/>Getting the request method arguments with event hooks</h1></div></div></div><p>We can alter the portions<a class="indexterm" id="id69"/> of the request process signal event handling using hooks. For example, there is hook named<a class="indexterm" id="id70"/> <code class="literal">response</code> which contains the response generated from a request. It is a dictionary which can be passed as a parameter to the request. The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">hooks = {hook_name: callback_function, … }</pre></div><p>The <code class="literal">callback_function</code> parameter may or may not return a value. When it returns a value, it is assumed that it is to replace the data that was passed in. If the callback function doesn't return any value, there won't be any effect on the data.</p><p>Here is an example of a callback function:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; def print_attributes(request, *args, **kwargs):</strong></span>
<span class="strong"><strong>...     print(request.url)</strong></span>
<span class="strong"><strong>...     print(request .status_code)</strong></span>
<span class="strong"><strong>...     print(request .headers)</strong></span>
</pre></div><p>If there is an error in the execution of <code class="literal">callback_function</code>, you'll receive a warning message in the standard output.</p><p>Now let us print<a class="indexterm" id="id71"/> some of the attributes <a class="indexterm" id="id72"/>of the request, using the preceding <code class="literal">callback_function</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; requests.get('https://www.python.org/',</strong></span>
<span class="strong"><strong>                 hooks=dict(response=print_attributes))</strong></span>
<span class="strong"><strong>https://www.python.org/</strong></span>
<span class="strong"><strong>200</strong></span>
<span class="strong"><strong>CaseInsensitiveDict({'content-type': 'text/html; ...})</strong></span>
<span class="strong"><strong>&lt;Response [200]&gt;</strong></span>
</pre></div></div>
<div class="section" title="Iterating over streaming APIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec29"/>Iterating over streaming APIs</h1></div></div></div><p>Streaming API tends to keep the request open allowing us to collect the stream data in real time. While dealing with a continuous stream of data, to ensure that none of the messages being missed from it we<a class="indexterm" id="id73"/> can take the help of <code class="literal">iter_lines()</code> in Requests. The <code class="literal">iter_lines()</code> iterates over the response data line by line. This can be achieved by setting the parameter stream as <code class="literal">True</code> while sending the request.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>It's better to keep in mind that it's not always safe to call the <code class="literal">iter_lines()</code> function as it may result in loss of received data.</p></div></div><p>Consider the following example<a class="indexterm" id="id74"/> taken from <a class="ulink" href="http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests">http://docs.python-requests.org/en/latest/user/advanced/#streaming-requests</a>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; import json</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import requests</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; r = requests.get('http://httpbin.org/stream/4', stream=True)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; for line in r.iter_lines():</strong></span>
<span class="strong"><strong>...     if line:</strong></span>
<span class="strong"><strong>...         print(json.loads(line) )</strong></span>
</pre></div><p>In the preceding example, the response contains a stream of data. With the help of <code class="literal">iter_lines()</code>, we tried to print the data by iterating through every line.</p><div class="section" title="Encodings"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Encodings</h2></div></div></div><p>As specified in the HTTP protocol (RFC 7230), applications can request the server to return the HTTP responses in an encoded format. The process of encoding turns the response content into an <a class="indexterm" id="id75"/>understandable format which makes it easy to access it. When the HTTP header fails to return the type of encoding, Requests will try to assume the encoding with the help of <code class="literal">chardet</code>.</p><p>If we access the response headers of a request, it does contain the keys of <code class="literal">content-type</code>. Let us look at a response header's <code class="literal">content-type</code>:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; re = requests.get('http://google.com')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; re.headers['content-type']</strong></span>
<span class="strong"><strong> 'text/html; charset=ISO-8859-1'</strong></span>
</pre></div><p>In the preceding example the content type contains <code class="literal">'text/html; charset=ISO-8859-1'</code>. This happens when the Requests finds the <code class="literal">charset</code> value to be <code class="literal">None</code> and the <code class="literal">'content-type'</code> value to be <code class="literal">'Text'</code>.</p><p>It follows the protocol RFC 7230 to change the value of <code class="literal">charset</code> to <code class="literal">ISO-8859-1</code> in this type of a situation. In case we are dealing with different types of encodings like <code class="literal">'utf-8',</code> we can explicitly specify the encoding by setting the property to <code class="literal">Response.encoding</code>.</p></div><div class="section" title="HTTP verbs"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>HTTP verbs</h2></div></div></div><p>Requests support the usage of the full range of HTTP verbs which are defined in the following table. To most of<a class="indexterm" id="id76"/> the supported verbs, <code class="literal">'url'</code> is the only argument that must be passed while using them.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>GET</p>
</td><td style="text-align: left" valign="top">
<p>GET method<a class="indexterm" id="id77"/> requests a representation of the specified resource. Apart from retrieving the data, there will be no other effect of using this method.</p>
<p>Definition is given as <code class="literal">requests.get(url, **kwargs)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>POST</p>
</td><td style="text-align: left" valign="top">
<p>The POST<a class="indexterm" id="id78"/> verb is used for the creation of new resources. The submitted <code class="literal">data</code> will be handled by the server to a specified resource.</p>
<p>Definition is given as <code class="literal">requests.post(url, data=None, json=None, **kwargs)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PUT</p>
</td><td style="text-align: left" valign="top">
<p>This method uploads a representation of the specified URI. If the URI is not pointing to any resource, the server can create a new object<a class="indexterm" id="id79"/> with the given <code class="literal">data</code> or it will modify the existing resource.</p>
<p>Definition is given as <code class="literal">requests.put(url, data=None, **kwargs)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>DELETE</p>
</td><td style="text-align: left" valign="top">
<p>This is<a class="indexterm" id="id80"/> pretty easy to understand. It is used to delete the specified resource.</p>
<p>Definition is given as <code class="literal">requests.delete(url, **kwargs)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HEAD</p>
</td><td style="text-align: left" valign="top">
<p>This verb<a class="indexterm" id="id81"/> is useful for retrieving meta-information written in response headers without having to fetch the response body.</p>
<p>Definition is given as <code class="literal">requests.head(url, **kwargs)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>OPTIONS</p>
</td><td style="text-align: left" valign="top">
<p>OPTIONS is a HTTP method which returns the HTTP methods that the server supports for a<a class="indexterm" id="id82"/> specified<a class="indexterm" id="id83"/> URL.</p>
<p>Definition is given as <code class="literal">requests.options(url, **kwargs)</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PATCH</p>
</td><td style="text-align: left" valign="top">
<p>This method<a class="indexterm" id="id84"/> is used to apply partial modifications to a resource.</p>
<p>Definition is given as <code class="literal">requests.patch(url, data=None, **kwargs)</code>
</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Self-describing the APIs with link headers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec30"/>Self-describing the APIs with link headers</h1></div></div></div><p>Take a case of accessing<a class="indexterm" id="id85"/> a resource in which the information is accommodated in different pages. If we need to approach the next page of the resource, we can make use of the link headers. The link headers contain the meta data of the requested resource, that is the next page information in our case.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; url = "https://api.github.com/search/code?q=addClass+user:mozilla&amp;page=1&amp;per_page=4"</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; response = requests.head(url=url)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; response.headers['link']</strong></span>
<span class="strong"><strong>'&lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=2&amp;per_page=4&gt;; rel="next", &lt;https://api.github.com/search/code?q=addClass+user%3Amozilla&amp;page=250&amp;per_page=4&gt;; rel="last"</strong></span>
</pre></div><p>In the preceding example, we have specified in the URL that we want to access page number one and it should contain four records. The Requests automatically parses the link headers and updates<a class="indexterm" id="id86"/> the information about the next page. When we try to access the link header, it showed the output with the values of the page and the number of records per page.</p></div>
<div class="section" title="Transport Adapter"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec31"/>Transport Adapter</h1></div></div></div><p>It is used to provide an interface for Requests sessions to connect with HTTP and HTTPS. This will help us to mimic the <a class="indexterm" id="id87"/>web service to fit our needs. With the help of Transport Adapters, we can configure the request according to the HTTP service we opt to use. Requests contains a Transport Adapter called <span class="strong"><strong>HTTPAdapter</strong></span><a class="indexterm" id="id88"/> included in it.</p><p>Consider the following example:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>&gt;&gt;&gt; session = requests.Session()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; adapter = requests.adapters.HTTPAdapter(max_retries=6)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; session.mount("http://google.co.in", adapter)</strong></span>
</pre></div><p>In this example, we created a request session in which every request we make retries only six times, when the connection fails.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we learnt about creating sessions and using the session with different criteria. We also looked deeply into HTTP verbs and using proxies. We learnt about streaming requests, dealing with SSL certificate verifications and streaming responses. We also got to know how to use prepared requests, link headers and chunk encoded requests. </p><p>In the next chapter, we will learn about various types of authentication and ways to use them with Requests.</p></div></body></html>