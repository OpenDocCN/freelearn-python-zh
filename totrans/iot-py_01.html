<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Understanding and Setting up the Base IoT Hardware</h1></div></div></div><p>In this chapter, we will start our journey towards<a id="id0" class="indexterm"/> <strong>Internet of Things</strong> (<strong>IoT</strong>) with Python and the Intel Galileo Gen 2 board. Python is one of the most popular and versatile programming languages. You can use Python to create multiplatform desktops and Web, mobile, and scientific applications. You can work with huge amounts of data and develop the complex algorithms that are popular in Big Data scenarios with Python. There are thousands of Python packages, which allow you to extend Python capabilities to any kind of domain you can imagine.</p><p>We can leverage our existing knowledge of Python and all of its packages to code the different pieces of our IoT ecosystem. We can use the object-oriented features, which we love from Python. in code that interacts with the Intel Galileo Gen 2 board and the electronic components connected to it. We can use the different packages that make it possible for us to easily run a Web server and provide a RESTful API. We can use all the packages that we already know to interact with databases, Web services, and different APIs. Python makes it easy for us to jump into the IoT world. We don't need to learn another programming language, we can use the one we already know and love.</p><p>First, we will learn about the features included in the Intel Galileo Gen 2 board. We will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understand the Intel Galileo Gen 2 board and its components</li><li class="listitem" style="list-style-type: disc">Recognize the Input/Output and the Arduino 1.0 pinout</li><li class="listitem" style="list-style-type: disc">Learn about the additional expansion and connectivity capabilities</li><li class="listitem" style="list-style-type: disc">Understand the buttons and the LEDs found in the board</li><li class="listitem" style="list-style-type: disc">Check and upgrade the board's firmware</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding the Intel Galileo Gen 2 board and its components</h1></div></div></div><p>We want <a id="id1" class="indexterm"/>to bring our ideas to life, easily. We want to be able to display a happy birthday message on a screen when we clap our hands. We want to collect huge amounts of data from the real world. We want to create wearables that keep track of all our activities during an entire day. We want to use the data to perform actions and interact with real-world elements. We want to use our mobile devices to control robots. We want to be able to determine whether the weather is hot or cold based on the data retrieved from a temperature sensor. We want to make decisions based on the values collected from a humidity sensor.</p><p>We want to measure how much of our favorite beverage is there in the cup and display the information on an LCD dot matrix display. We want to analyze all the data collected by things that are connected to the Internet. We want to become makers in the Internet of Things era by leveraging our existing Python programming skills.</p><p>We will use Python as the main programming language to control the different components connected to an Intel Galileo Gen 2 board, specifically Python 2.7.3. However, before we can become makers, it is necessary to understand some of this board's features.</p><p>After we unbox an Intel Galileo Gen 2, we <a id="id2" class="indexterm"/>will find the following elements:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Intel Galileo Gen 2 board</li><li class="listitem" style="list-style-type: disc">A 12 VDC (Volts direct current), 1.5 A (Amperes) power supply</li></ul></div><p>The following image shows the front view for an unboxed Intel Galileo Gen 2 board:</p><div><img src="img/B05042_01_01.jpg" alt="Understanding the Intel Galileo Gen 2 board and its components"/></div><p>Let's have a<a id="id3" class="indexterm"/> look at the front view of the board for a few minutes. We will notice many familiar elements, such as an Ethernet jack, host USB port, and many labeled pins. In case we have previous experience with an Arduino UNO R3 board, we will easily realize that many elements are in the same locations as in that board. In case we have previous experience with embedded systems and electronics, we will easily realize that the board provides the necessary pins (SCL and SDA) to talk with the devices that support the I<sup>2</sup>C bus. In case we don't have any previous experience, we will learn what we can do with all these pins in the examples included in the forthcoming chapters.</p><p>The next image shows the graphical representation of the Intel Galileo Gen 2 board in the Fritzing open source and free software. As you might notice, the graphical representation includes only the important pieces of the board and all the things we can wire and connect, with the necessary labels to help recognize them easily. We will use the Fritzing diagrams to illustrate all the wirings that we must do in order to complete each sample project through the book.</p><div><img src="img/B05042_01_02.jpg" alt="Understanding the Intel Galileo Gen 2 board and its components"/></div><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>You can <a id="id4" class="indexterm"/>download the latest version of Fritzing from <a class="ulink" href="http://fritzing.org/download/">http://fritzing.org/download/</a>. Fritzing runs on Windows, Mac OS X and Linux. You will find the Fritzing sketches for all the examples included throughout the book in files with an FZZ extension (<code class="literal">*.fzz</code>) as a part of the code files that you can download for this book. The files are saved with Fritzing 0.92. Thus, you can open the sketches in Fritzing, check the breadboard view, and make any changes to it based on your needs.</p></div></div><p>The <a id="id5" class="indexterm"/>next image shows the electronic schematic representation of the Intel Galileo Gen 2 board, that is, the symbolic representation of the board to make it easy to understand the interconnections of the electronic circuits related to the board. The electronic schematic is also known as circuit diagram or electrical diagram. The symbol includes all the pins provided by the board shown as connectors. We can easily recognize the many labels that appear on the board as labels for each connector in the symbol. Fritzing allows us to work with both the breadboard and the electronic schematic representation.</p><div><img src="img/B05042_01_03.jpg" alt="Understanding the Intel Galileo Gen 2 board and its components"/></div><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>When you open the Fritzing file for each sample included in the book, you will be able to easily switch from the breadboard view to the schematic view by clicking on either the Breadboard or the Schematic buttons located at the top of the main Fritzing window.</p></div></div><p>The <a id="id6" class="indexterm"/>next image shows the system block diagram for the Intel Galileo Gen 2 board. The diagram is a part of the content included in the<a id="id7" class="indexterm"/> Intel Galileo Gen 2 design document: <a class="ulink" href="http://www.intel.com/content/dam/www/public/us/en/documents/guides/galileo-g2-schematic.pdf">http://www.intel.com/content/dam/www/public/us/en/documents/guides/galileo-g2-schematic.pdf</a>.</p><div><img src="img/B05042_01_04.jpg" alt="Understanding the Intel Galileo Gen 2 board and its components"/></div><p>The<a id="id8" class="indexterm"/> Intel Galileo Gen 2 board is an Arduino certified embedded computer that we will use to develop and prototype our IoT projects. The board is based on Intel architecture and uses an Intel Quark SoC X1000 system on a chip, known as SoC or application processor. The<a id="id9" class="indexterm"/> SoC is a single-core and single-threaded application processor that is compatible with the Intel Pentium 32-bit <strong>instruction set architecture</strong> (<strong>ISA</strong>). Its<a id="id10" class="indexterm"/> operating speed is up to 400 MHz. The following image shows the SoC, located approximately at the center of the board. The following page provides detailed information about <a id="id11" class="indexterm"/>the Intel Quark SoC X1000: <a class="ulink" href="http://ark.intel.com/products/79084/Intel-Quark-SoC-X1000-16K-Cache-400-MHz">http://ark.intel.com/products/79084/Intel-Quark-SoC-X1000-16K-Cache-400-MHz</a>
</p><div><img src="img/B05042_01_05.jpg" alt="Understanding the Intel Galileo Gen 2 board and its components"/></div><p>On the<a id="id12" class="indexterm"/> right-hand side of the CPU, the board has two integrated circuits that provide 256 MB of DDR3 <strong>RAM</strong> (short for <strong>Random Access Memory</strong>) memory. The <a id="id13" class="indexterm"/>operating system and Python will be able to work with this RAM memory. As it happens in any computer, RAM memory loses its information after we turn off the board. Thus, we say that RAM is volatile, as the data stored in it is lost when the memory isn't powered. The following image shows the DDR3 memory chips.</p><div><img src="img/B05042_01_06.jpg" alt="Understanding the Intel Galileo Gen 2 board and its components"/></div><p>In addition, the <a id="id14" class="indexterm"/>board provides access to the following onboard memories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">512 KB embedded <a id="id15" class="indexterm"/><strong>SRAM</strong> (short for <strong>Static Random Access Memory</strong>).</li><li class="listitem" style="list-style-type: disc">8 MB Legacy SPI NOR Flash, non-volatile memory. Its goal is to store the board's firmware and sketches.</li><li class="listitem" style="list-style-type: disc">11 KB <strong>EEPROM</strong> (short for <strong>Electrically Erasable Programmable Read-Only Memory</strong>). It is <a id="id16" class="indexterm"/>non-volatile and we can store data in it for our own purposes.</li></ul></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Recognizing the Input/Output and the Arduino 1.0 pinout</h1></div></div></div><p>The <a id="id17" class="indexterm"/>board provides the following I/O pins:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">14 digital I/O pins</li><li class="listitem" style="list-style-type: disc">Six <strong>PWM</strong> (short for <strong>Pulse Width Modulation</strong>) output pins</li><li class="listitem" style="list-style-type: disc">Six analog input pins</li></ul></div><p>The <a id="id18" class="indexterm"/>board is hardware and software pin-compatible <a id="id19" class="indexterm"/>with Arduino shields designed for the Arduino Uno R3. The 14 digital I/O pins numbered from 0 to 13 are located in the upper-right corner of the board and they also include the adjacent <strong>AREF</strong> and <strong>GND</strong> pins, as in the Arduino Uno R3. The pins configuration is also known as Arduino 1.0 pinout.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>Shields are boards that we can plug on top of the Intel Galileo Gen 2 board to extend its capabilities. For example, you can plug a shield that provides two high current motor controllers or a shield that adds an LED matrix.</p></div></div><p>As it happens in<a id="id20" class="indexterm"/> the Arduino Uno R3, we can use six of these digital I/O pins as PWM (Pulse Width Modulation) output pins. Specifically, the pins labeled with a tilde symbol (<strong>~</strong>) as a prefix to the number have this capability: pins <strong>~11</strong>, <strong>~10</strong>, <strong>~9</strong>, <strong>~6</strong>, <strong>~5</strong> and <strong>~3</strong>. The following are the pins that compose the header from left to right:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">SCL</li><li class="listitem" style="list-style-type: disc">SDA</li><li class="listitem" style="list-style-type: disc">AREF</li><li class="listitem" style="list-style-type: disc">GND</li><li class="listitem" style="list-style-type: disc">13</li><li class="listitem" style="list-style-type: disc">12</li><li class="listitem" style="list-style-type: disc">~11</li><li class="listitem" style="list-style-type: disc">~10</li><li class="listitem" style="list-style-type: disc">~9</li><li class="listitem" style="list-style-type: disc">8</li><li class="listitem" style="list-style-type: disc">7</li><li class="listitem" style="list-style-type: disc">~6</li><li class="listitem" style="list-style-type: disc">~5</li><li class="listitem" style="list-style-type: disc">4</li><li class="listitem" style="list-style-type: disc">~3</li><li class="listitem" style="list-style-type: disc">2</li><li class="listitem" style="list-style-type: disc">TX-&gt;1</li><li class="listitem" style="list-style-type: disc">RX&lt;-0</li></ul></div><p>The <a id="id21" class="indexterm"/>next image shows the 14 digital I/O pins and the six PWM output<a id="id22" class="indexterm"/> pins labeled with a tilde symbol (<strong>~</strong>) as a <a id="id23" class="indexterm"/>prefix for the number. The first two pins, starting from the left are for the two I<sup>2</sup>C bus lines: <strong>SCL</strong> (<strong>Serial CLock</strong>) and <strong>SDA</strong> (<strong>Serial DAta</strong>). The<a id="id24" class="indexterm"/> last two pins, starting from the left, labeled <strong>TX-&gt;1</strong> and <strong>RX&lt;-0</strong> are the UART 0 port pins. A <strong>UART</strong> port stands for<a id="id25" class="indexterm"/> <strong>Universal Asynchronous Receiver/Transmitter</strong>.</p><div><img src="img/B05042_01_07.jpg" alt="Recognizing the Input/Output and the Arduino 1.0 pinout"/></div><p>The six analogous input pins numbered from <strong>A0</strong> to <strong>A5</strong> are located in the lower-right corner of the board, as in the Arduino Uno R3. On the left-hand side of the analog input pins, we can see the following power pins that compose the power header:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">POWER</li><li class="listitem" style="list-style-type: disc">IOREF</li><li class="listitem" style="list-style-type: disc">RESET</li><li class="listitem" style="list-style-type: disc">3.3V</li><li class="listitem" style="list-style-type: disc">5V</li><li class="listitem" style="list-style-type: disc">GND</li><li class="listitem" style="list-style-type: disc">GND</li><li class="listitem" style="list-style-type: disc">VIN</li></ul></div><p>The <strong>VIN</strong> pin in the power header provides the input voltage that is supplied to the board through its power jack. The power supply included in the box provides 12V. However, the board can operate <a id="id26" class="indexterm"/>with an input voltage ranging from 7V to 15V. The board also provides support to Power over Ethernet, also known as PoE, this passes the electrical power to the board along with data on the Ethernet cable.</p><p>The following<a id="id27" class="indexterm"/> screenshot shows the power pins, also known as power headers, and the six analog input pins:</p><div><img src="img/B05042_01_08.jpg" alt="Recognizing the Input/Output and the Arduino 1.0 pinout"/></div><p>The board includes a jumper labeled <strong>IOREF</strong> that allows us to select between a 3.3V or 5V shield operation and provides voltage-level translation to all the I/O pins. Based on the jumper position, the board can work with either a 3.3V or 5V Arduino shield. By default, the <strong>IOREF</strong> jumper is set to the 5V position, and therefore, the initial setting allows us to work with 5V shields. The following screenshot shows the<strong> IOREF</strong> jumper set to the 5V position.</p><div><img src="img/B05042_01_09.jpg" alt="Recognizing the Input/Output and the Arduino 1.0 pinout"/></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>The <strong>IOREF</strong> pin in the power header provides the operational voltage reference based on the <strong>IOREF</strong> jumper position. Thus, based on the <strong>IOREF</strong> jumper position, the voltage reference in the <strong>IOREF</strong> pin can be either 5V or 3.3V.</p></div></div><p>On the<a id="id28" class="indexterm"/> right-hand side of the board, there is a 6 pin, specifically 2x3 pin, ICSP (In-Circuit Serial Programming) header, labeled <strong>ICSP</strong>. The location <a id="id29" class="indexterm"/>of this header is also compatible with the Arduino 1.0 pinout. The following screenshot shows the ICSP header:</p><div><img src="img/B05042_01_11.jpg" alt="Recognizing the Input/Output and the Arduino 1.0 pinout"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Recognizing additional expansion and connectivity capabilities</h1></div></div></div><p>The <a id="id30" class="indexterm"/>power jack is located on the left-hand side of the board and it is labeled <strong>PWR</strong>. Below the power jack, there is a microSD card connector, labeled <strong>SDIO</strong>. The microSD card connector supports microSD cards with a maximum support capacity of 32 GB. We will use the microSD card as our main storage to store the operating system, Python, and the necessary libraries. The board can boot from the microSD card. Thus, we can think of the microSD card as our main hard drive to work with IoT projects. The following screenshot shows the power jack with the power supply connected to it and the microSD card connector with an 8 GB microSD card being connected to it.</p><div><img src="img/B05042_01_10.jpg" alt="Recognizing additional expansion and connectivity capabilities"/></div><p>The<a id="id31" class="indexterm"/> Ethernet jack is located in the upper-left corner of the board, labeled <strong>10/100 LAN</strong>, above the power jack. The Ethernet port supports both the Ethernet and Fast Ethernet standards, and therefore, it can work with either 10 Mbps or 100 Mbps nominal throughput rates. The Ethernet port is extremely useful to connect the board to our LAN and access it through an IP address. There is an adhesive label with the MAC (Media Access Control) address for the Ethernet onboard network interface card. The MAC address is also known as physical address.</p><p>The following screenshot shows this adhesive label on the Ethernet jacket and a cable plugged in it. The MAC address for the board shown in the image is A1B2C3D4E5F6. If we use the convention that expresses a MAC address as six groups of two hexadecimal digits separated by colons (:), the MAC address will be expressed as A1:B2:C3:D4:E5:F6. The MAC address is extremely useful to identify the board in our LAN DHCP client list. For security reasons, the original MAC address has been erased and we use a fake MAC address for our example.</p><div><img src="img/B05042_01_12.jpg" alt="Recognizing additional expansion and connectivity capabilities"/></div><p>A six pin, 3.3V USB TTL UART header is located next to the Ethernet jack, specifically UART 1, the <a id="id32" class="indexterm"/>second UART port in the board. The six pin, 3.3V USB TTL UART header has the following labels on the right-hand side:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">CTS</li><li class="listitem" style="list-style-type: disc">TXO</li><li class="listitem" style="list-style-type: disc">RXI</li><li class="listitem" style="list-style-type: disc">No label (empty)</li><li class="listitem" style="list-style-type: disc">RTS</li><li class="listitem" style="list-style-type: disc">GND</li></ul></div><p>Next to the Ethernet jack and the UART header, there is a micro USB Type B connection, labeled <strong>USB CLIENT</strong>. We can use this connection to connect the computer to the board, in order to perform firmware updates or transfer sketches.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>However, it is important to know that you cannot power the board off USB. In addition to it, never connect a cable to the micro USB Type B connection before you connect the power supply to the board.</p></div></div><p>Next to the micro USB connection, there is a USB 2.0 host connector, labeled <strong>USB HOST</strong>. The connector supports a maximum of 128 USB endpoint devices. We can use this connector to plug a USB thumb drive for additional storage, USB keyboard, USB mouse, or any other USB device that we might need. However, we must consider the necessary drivers and their compatibility with the Linux distribution that we will be using with the board, before we plug any device.</p><p>The following image shows the UART header, micro USB connector, and the USB 2.0 port, from left to right, next to the Ethernet jack.</p><div><img src="img/B05042_01_13.jpg" alt="Recognizing additional expansion and connectivity capabilities"/></div><p>The following image shows the side view with all the connectors and jacks. From left to right, the USB 2.0 port, the micro USB connector, the UART header, and the Ethernet jack with the green (SPEED) and yellow (LINK) LEDs.</p><div><img src="img/B05042_01_14.jpg" alt="Recognizing additional expansion and connectivity capabilities"/></div><p>The back of<a id="id33" class="indexterm"/> the board provides a mini PCI Express slot, also known as the mPICe slot, compliant with PCIe 2.0 features, labeled <strong>PCIE</strong>. The slot is compatible with both full size and half size mPCIe modules that we can connect to the board to expand its capabilities. The half size mPCIe module requires an adapter to be connected to the slot on the board.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>It is possible to add another USB host port via the mPCIe slot. The mPCIe slot is extremely useful to provide WiFi, Bluetooth, and other types of connectivity that aren't included as onboard features.</p></div></div><p>Next to the mPCIe slot, there is a 10-pin JTAG (Joint Test Action Group) header, labeled <strong>JTAG</strong>. It is possible to use the JTAG interface for debugging purposes in combination with debugging software that supports the Intel Quark SoC X1000 application processor, such as the free and open source on-chip debugging software OpenOCD.</p><p>The next image shows the back-view for the board with mPCIe slot and the JTAG header.</p><div><img src="img/B05042_01_15.jpg" alt="Recognizing additional expansion and connectivity capabilities"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Understanding the buttons and the LEDs</h1></div></div></div><p>The<a id="id34" class="indexterm"/> front of the board provides two buttons located at the bottom labeled <strong>REBOOT</strong> and <strong>RESET</strong>. The following image shows these two buttons:</p><div><img src="img/B05042_01_16.jpg" alt="Understanding the buttons and the LEDs"/></div><p>The button <a id="id35" class="indexterm"/>labeled <strong>REBOOT</strong> resets the Intel Quark SoC X1000 application processor. The button labeled <strong>RESET</strong> resets the sketch and any shield attached to the board. In this book, we won't be working with the Arduino sketches but we might need to reset a shield.</p><p>There are five rectangular LEDs located next to the USB 2.0 host connector: two LEDs on the left-hand side of the connector and three LEDs on the right-hand side. The following are the labels and the meaning of the LEDs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>OC</strong>: The LED signals over-current when the board is powered through the micro USB connector. However, this feature is not enabled on Intel Galileo Gen 2 boards, and therefore, we just have the LED turned off. If the LED turns on, it means that the board is not working OK or the power supply is failing. This LED usually turns on when the board is bricked. We say a board is bricked when it doesn't work anymore and is technologically as useful as a brick.</li><li class="listitem" style="list-style-type: disc"><strong>USB</strong>: It is the micro USB ready LED. The LED turns on after the board has finished the boot process and allows us to connect the micro USB cable to the micro USB connection labeled <strong>USB CLIENT</strong>. We should never connect a cable to the micro USB connection before this LED turns on because we can damage the board.</li><li class="listitem" style="list-style-type: disc"><strong>L</strong>: The <a id="id36" class="indexterm"/>LED is connected to pin 13 of the digital I/O pins, and therefore, a high level sent to pin 13 will turn on this LED and a low level will turn it off.</li><li class="listitem" style="list-style-type: disc"><strong>ON</strong>: It is a power LED and indicates that the board is connected to the power supply.</li><li class="listitem" style="list-style-type: disc"><strong>SD</strong>: The LED indicates I/O activity with the microSD card connector, labeled <strong>SDIO</strong>, and therefore, this LED will blink whenever the board is reading or writing on the microSD card.</li></ul></div><p>The following <a id="id37" class="indexterm"/>image shows the <strong>OC</strong> and <strong>USB</strong> LEDs on the left-hand side of the USB 2.0 host connector and the <strong>L</strong>, <strong>ON</strong> and <strong>SD</strong> LEDs on its right-hand side.</p><div><img src="img/B05042_01_17.jpg" alt="Understanding the buttons and the LEDs"/></div><p>The board includes an integrated real-time clock, known as RTC. It is possible to connect a 3V coin-cell battery to keep the RTC operation between turn-on cycles. Unluckily, the battery is not included in the box. The two RTC coin-cell connector pins are located in the lower-left corner <a id="id38" class="indexterm"/>of the Intel Quark SoC X1000 application processor, labeled <strong>COIN</strong> and with a battery<a id="id39" class="indexterm"/> icon. The next image shows the two RTC coin-cell connector pins.</p><div><img src="img/B05042_01_18.jpg" alt="Understanding the buttons and the LEDs"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Checking and upgrading the board's firmware</h1></div></div></div><p>Sometimes, the <a id="id40" class="indexterm"/>original firmware included in the board is the latest one available for Intel Galileo Gen 2. However, in some cases, we might need a firmware update, and <a id="id41" class="indexterm"/>therefore it is always convenient to make sure that we are working with the latest available version for the onboard firmware.</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>Firmware updates solve bugs and compatibility issues. Thus, it is always convenient to work with the latest firmware. However, in case you don't feel sure about following the procedure to update the firmware, it is convenient to keep the version that came with the board. A wrong procedure while updating the firmware or a power loss during the process might damage the board, that is, it might transform the board into a bricked one. You definitely don't want this to happen to your board.</p></div></div><p>If you want to check the current firmware version and check whether it is necessary to upgrade the board's firmware, you must follow the following steps:</p><p>Go to the<a id="id42" class="indexterm"/> Intel Galileo Firmware and Drivers download page at <a class="ulink" href="http://downloadcenter.intel.com/download/24748/Intel-Galileo-Firmware-and-Drivers-1-0-4">http://downloadcenter.intel.com/download/24748/Intel-Galileo-Firmware-and-Drivers-1-0-4</a>. The URL is for the latest firmware version at the time this book has been written: 1.0.4. However, always make sure that you are downloading the latest available version from Intel Drivers &amp; Software Download Center. In case the version is higher than 1.0.4, the procedure will be the same but you just need to replace 1.0.4 with the new version numbers.</p><p>The Web browser <a id="id43" class="indexterm"/>will display the available downloads for the supported operating <a id="id44" class="indexterm"/>systems. The Web page doesn't detect the operating system you are using, and therefore, it offers the downloads for all the supported operating systems: Windows, Mac OS X, and Linux. The following image shows the contents for the Web page:</p><div><img src="img/B05042_01_19.jpg" alt="Checking and upgrading the board's firmware"/></div><p>You will find a PDF user guide under <strong>OS Independent</strong>: <strong>IntelGalileoFirmwareUpdaterUserGuide-1.0.4.pdf</strong>. Click on the button, read and accept the Intel Software License Agreement, and read the Intel Galileo Firmware Updater Tool documentation. The documentation includes all the necessary steps to install the drivers in Windows and Linux. The Mac OS X doesn't require any driver installation.</p><p>Before you <a id="id45" class="indexterm"/>install the drivers or start the process to check the firmware version in your board, remove all the connections from the board, such as the microUSB cable and any USB device plugged into the USB 2.0 host connector. Remove any sketches and also the microSD card. Your Intel Galileo Gen 2 board should be empty just as when you unboxed it.</p><p>Connect the<a id="id46" class="indexterm"/> power supply to the board and wait a few seconds until the rectangular LED labeled <strong>USB</strong> turns on. Once this LED is turned on, the boot process has already finished and it is safe to connect a USB Type A to Micro-B USB cable from your computer to the micro USB connector labeled <strong>USB CLIENT</strong> in the board. Unluckily, the cable isn't included within the board's box. The following image shows an Intel Galileo Gen 2 board with the connections done and the firmware updater tool running on Mac OS X.</p><div><img src="img/B05042_01_20.jpg" alt="Checking and upgrading the board's firmware"/></div><p>In case you are working with either Windows or Linux, follow the procedure to install the necessary drivers as explained in the <strong>IntelGalileoFirmwareUpdaterUserGuide-1.0.4.pdf</strong> document.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>You already have the board connected to your computer, and therefore, you can skip this step in the document. In fact, many versions of this document didn't explain that you had to wait for the USB LED to turn on before you can connect the board to a computer through the micro USB connector and that caused many boards to have unexpected problems.</p></div></div><p>Once you <a id="id47" class="indexterm"/>have the <a id="id48" class="indexterm"/>drivers installed in your computer and your board is connected to it, you can download and execute the ZIP file of the Intel Galileo Firmware Updater for your operating system. For Windows, the file is <strong>IntelGalileoFirmwareUpdater-1.0.4-Windows.zip</strong>. For Mac OS X, the file is <strong>IntelGalileoFirmwareUpdater-1.0.4-OSX.zip</strong>. You usually have to scroll down the Web page to find the appropriate file for your operating system. Once you click on the desired file button, it is necessary to read and accept the Intel Software License Agreement before you can download the zip file.</p><p>In Windows, download the <strong>IntelGalileoFirmwareUpdater-1.0.4-Windows.zip</strong> file, open it, and execute the <strong>firmware-updater-1.0.4.exe</strong> application included in the zip file. The <strong>Intel Galileo Firmware Updater Tool</strong> window will appear and it will automatically select the virtual COM port number, such as <strong>COM3</strong>, generated by the previously installed driver in the <strong>Port</strong> dropdown. The application will communicate with the board and then display the firmware version included with the tool in <strong>Update Firmware Version</strong> and the current board's firmware version in <strong>Current Board Firmware</strong>.</p><p>The following image shows the Intel Galileo Firmware Updater Tool running on Windows 10. In this case, the tool has the newest version for the firmware because it offers version <strong>1.0.4</strong> and the current board's firmware is <strong>1.0.2</strong>.</p><div><img src="img/B05042_01_21.jpg" alt="Checking and upgrading the board's firmware"/></div><p>In Mac OS X, download the <strong>IntelGalileoFirmwareUpdater-1.0.4- OSX.zip</strong> file and then execute the <a id="id49" class="indexterm"/>downloaded <strong>Firmware Updater</strong> application. Take into account that you might need to authorize the operating system to run the application<a id="id50" class="indexterm"/> based on your security settings and your OS X version. The <strong>Intel Galileo Firmware Updater Tool</strong> window will appear and it will automatically select the generated USB modem device for the connected board, such as <strong>/dev/cu.usbmodem1411</strong>, in the <strong>Port</strong> dropdown. The application will communicate with the board and then it will display the firmware version included with the tool in <strong>Update Firmware Version</strong> and the current board's firmware version in <strong>Current Board Firmware</strong>.</p><p>The following image shows the Intel Galileo Firmware Updater Tool running on OS X El Capitan. In this case, the tool has the newest version for the firmware because it offers version <strong>1.0.4</strong> and the current board's firmware is <strong>1.0.2</strong>, as it happened with the Windows version.</p><div><img src="img/B05042_01_22.jpg" alt="Checking and upgrading the board's firmware"/></div><p>In case you decide that you need and want to update the firmware, considering the previously <a id="id51" class="indexterm"/>explained risks, you just need to click on the <strong>Update Firmware</strong> button <a id="id52" class="indexterm"/>and wait for the tool to indicate that the process has finished. The procedure is the same for either Windows or Mac OS X.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>Don't unplug the USB cable from your computer connected to the board, don't disconnect the power supply from the board, and don't close the application until the tool indicates that the firmware update has finished. The safest way to perform a firmware update is to plug the power supply to a UPS (Uninterruptible Power Supply) to protect it from a power failure during the firmware update process.</p></div></div><p>Once the firmware update process has finished and the tool displays that you have the same firmware version on the board that the firmware version that the tool offers, you can close the application and disconnect the USB cable from your computer and the board. Make sure that you don't leave the USB cable connected to your board and then unplug the power supply.</p></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">The Intel Galileo Gen 2 board includes:<div><ol class="orderedlist arabic"><li class="listitem">WiFi connectivity onboard with three antennas.</li><li class="listitem">Ethernet connectivity onboard.</li><li class="listitem">Bluetooth connectivity onboard.</li></ol></div></li><li class="listitem">The Intel Galileo Gen 2 board is hardware and pin compatible with a wide range of:<div><ol class="orderedlist arabic"><li class="listitem">Arduino Uno R3 shields.</li><li class="listitem">Arduino Pi shields.</li><li class="listitem">Raspberry Pi shields.</li></ol></div></li><li class="listitem">The jumper labeled IOREF allows us to:<div><ol class="orderedlist arabic"><li class="listitem">Select between 3.5V or 7V shield operation and provide voltage-level translation to all the I/O pins.</li><li class="listitem">Select between 3.3V or 5V shield operation and provide voltage-level translation to all the I/O pins.</li><li class="listitem">Reset the board.</li></ol></div></li><li class="listitem">The LED labeled L is connected to the following pins of the digital I/O pins:<div><ol class="orderedlist arabic"><li class="listitem">11<code class="literal">.</code></li><li class="listitem">12<code class="literal">.</code></li><li class="listitem">13<code class="literal">.</code></li></ol></div></li><li class="listitem">The back of the board provides the following slot:<div><ol class="orderedlist arabic"><li class="listitem">Mini PCI Express.</li><li class="listitem">PCMCIA.</li><li class="listitem">Thunderbolt.</li></ol></div></li></ol></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we learnt the different features offered by the Intel Galileo Gen 2 board. We visualized the different components of the board and we understood the meaning of the different pins, LEDs, and connectors. We also learned to check the board's firmware version and to update it in case it is necessary to do so.</p><p>Now that we recognize the different components of the board, we have to prepare it to work with Python as our main programming language, which is what we are going to discuss in the next chapter.</p></div></div>
</body></html>