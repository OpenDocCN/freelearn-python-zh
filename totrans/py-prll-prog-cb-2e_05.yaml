- en: Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: 'Beside the sequential and parallel execution models, there is a third model
    that is of fundamental importance together with the concept of event programming:
    the *asynchronous model*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了顺序和并行执行模型之外，还有一个基本重要的第三模型，与事件编程的概念一起：*异步模型*。
- en: The execution model of asynchronous tasks can be implemented through a single
    main control flow, both in single-processor systems and in multiprocessor systems.
    In the concurrent asynchronous execution model, the executions of various tasks
    intersect along the timeline, and everything happens under the action of a single
    flow of control (single-threaded). Once started, the execution of tasks can be
    suspended and then resumed over time, alternating with the execution of other
    current tasks that are present.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异步任务的执行模型可以通过单个主控制流实现，无论是在单处理器系统还是在多处理器系统中。在并发异步执行模型中，各种任务的执行在时间线上相互交叉，所有事情都在单一控制流的作用下发生（单线程）。一旦开始，任务的执行可以被暂停，然后在一段时间后恢复，与当前其他任务的执行交替进行。
- en: The development of code for the asynchronous model is completely different from
    that for multithreaded programming. A substantial difference between the concurrent
    multithreaded parallel model and the single-threaded concurrent asynchronous model
    lies in the fact that, in the first case, the OS decides on the timeline if we
    suspend the activity of one thread and start another.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 异步模型的代码开发与多线程编程的代码开发完全不同。并发多线程并行模型与单线程并发异步模型之间的重要区别在于，在前一种情况下，操作系统决定在暂停一个线程的活动并启动另一个线程的时间线。
- en: This remains outside the control of the coder, unlike the asynchronous model.
    The execution or termination of a task continues as long as it is explicitly required.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点超出了程序员的控制范围，与异步模型不同。任务的执行或终止会持续进行，只要它被明确地需要。
- en: The most important feature of this type of programming is that the code is not
    performed on multiple threads, as in the classic concurrent programming, but on
    a single thread. Thus, it is not at all true that two tasks are executed at the
    same time, but, according to this approach, they are performed at almost the same
    time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型编程最重要的特性是代码不是在多个线程上执行，就像在经典并发编程中那样，而是在单个线程上执行。因此，两个任务同时执行的说法完全不正确，但根据这种方法，它们几乎是同时执行的。
- en: In particular, we will describe the `asyncio`Python module, which was introduced
    in Python 3.4\. This allows us to use coroutines and futures to make writing asynchronous
    code easier and to make it more readable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们将描述在Python 3.4中引入的`asyncio`Python模块。这使我们能够使用协程和未来来简化异步代码的编写，并使其更具可读性。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using the `concurrent.futures` Python module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`concurrent.futures` Python模块
- en: Managing the event loop with `asyncio`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`管理事件循环
- en: Handling coroutines with `asyncio`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`处理协程
- en: Manipulating tasks with `asyncio`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`asyncio`操作任务
- en: Dealing with `asyncio` and futures
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理`asyncio`和未来
- en: Using the concurrent.futures Python module
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`concurrent.futures` Python模块
- en: The `concurrent.futures` module, which is part of the standard Python library,
    provides a level of abstraction on threads by modelling them as asynchronous functions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures`模块是Python标准库的一部分，通过将线程建模为异步函数，提供了对线程的抽象层次。'
- en: 'This module is built by two main classes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块由两个主要类构建：
- en: '`concurrent.futures.Executor`: This is an abstract class that provides methods
    to execute calls asynchronously.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.Executor`：这是一个抽象类，提供了执行异步调用的方法。'
- en: '`concurrent.futures.Future`: This encapsulates the asynchronous execution of
    a callable. Future objects are instantiated by submitting tasks (functions with
    optional parameters) to `Executors`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.Future`：这封装了可调用函数的异步执行。`Future`对象通过将任务（具有可选参数的函数）提交给`Executors`来实例化。'
- en: 'Here are some of the main methods of the module:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是该模块的一些主要方法：
- en: '`submit(function,argument)`: This schedules the execution of the callable function
    on the arguments.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit(function,argument)`：这安排在参数上调用可调用函数的执行。'
- en: '**`map(function,argument)`**: This executes the functions of arguments in asynchronous
    mode.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`map(function,argument)`**：这以异步模式执行参数的函数。'
- en: '`shutdown(Wait=True)`: This signals the executor to free any resource.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown(Wait=True)`：这向执行器发出信号，释放任何资源。'
- en: 'The executors are accessed through their subclasses: `ThreadPoolExecutor` or
    `ProcessPoolExecutor`. Because the instantiation of threads and processes is a
    resource-demanding task, it is better to pool these resources and use them as
    repeatable launchers or executors (hence the `Executors` concept) for parallel
    or concurrent tasks.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其子类访问执行器：`ThreadPoolExecutor` 或 `ProcessPoolExecutor`。因为线程和进程的实例化是一个资源密集型任务，所以最好将这些资源池化，并将它们用作可重复的启动器或执行器（因此有
    `Executors` 概念），用于并行或并发任务。
- en: The approach we are taking here involves using a pool executor. We will submit
    the assets to the pool (thread and process) and get the futures, which are the
    results that will be available to us in the future. Of course, we can wait for
    all futures to become real results.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里采取的方法是使用池执行器。我们将提交资产到池（线程和进程）并获取未来，这些是将来将对我们可用的结果。当然，我们可以等待所有未来成为真实的结果。
- en: A thread or process pool (also called *pooling*) indicates a management software
    that is being used to optimize and simplify the use of threads and/or processes
    within a program. Through pooling, you can submit the task (or tasks) in order
    to execute them to the pooler.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池或进程池（也称为 *pooling*）表示正在使用的管理软件，用于优化和简化程序中线程和/或进程的使用。通过池化，您可以提交任务（或多个任务）以便将它们执行到池中。
- en: 'The pool is equipped with an internal queue of tasks pending and several threads
    *or* processes that execute them. A recurring concept in pooling is reusing: a
    thread (or process) is used several times for different tasks during its life
    cycle. This decreases the overhead of creating new threads or processes and increases
    the performance of the program.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 池配备了待处理任务的内部队列和执行它们的几个线程 *或* 进程。在池化中的一个常见概念是重用：在生命周期中，线程（或进程）被多次用于不同的任务。这减少了创建新线程或进程的开销，并提高了程序的性能。
- en: Reuse *is not a rule*, but it is one of the main reasons that lead a coder to
    use pooling in their application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重用 *不是规则*，但它是一个主要的原因，导致编码者在他们的应用程序中使用池化。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `concurrent.futures` module provides two subclasses of the `Executor` class, which
    asynchronously manipulate a pool of threads and a pool of processes. The two subclasses
    are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures` 模块提供了 `Executor` 类的两个子类，它们异步地操作线程池和进程池。这两个子类如下：'
- en: '`concurrent.futures.ThreadPoolExecutor(max_workers)`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.ThreadPoolExecutor(max_workers)`'
- en: '`concurrent.futures.ProcessPoolExecutor(max_workers)`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrent.futures.ProcessPoolExecutor(max_workers)`'
- en: The `max_workers` parameter identifies the maximum number of workers that execute
    the call asynchronously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`max_workers` 参数标识异步执行调用时的工作者最大数量。'
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Here is an example of thread and process pool usage, where we will compare the
    execution time with the time it takes for sequential execution.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个线程和进程池使用的示例，我们将比较执行时间与顺序执行所需的时间。
- en: 'The task to be performed is as follows: we have a list of 10 elements. Each
    element of the list is made to count up to 100,000,000 (just to waste time), and
    then the last number is multiplied by the *i-th* element of the list. In particular,
    we are evaluating the following cases:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行的任务如下：我们有一个包含 10 个元素的列表。列表的每个元素都被设置为计数到 100,000,000（只是为了浪费时间），然后最后一个数字乘以列表的
    *i-th* 元素。特别是，我们正在评估以下情况：
- en: '**Sequential execution**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序执行**'
- en: '**Thread pool with five workers**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有五个工作者的线程池**'
- en: '**Process pool with five workers**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有五个工作者的进程池**'
- en: 'Now, let''s look at how to do it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何操作：
- en: 'Import the relevant libraries:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入相关库：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Define the list of numbers from `1` to `10`:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义从 `1` 到 `10` 的数字列表：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `count(number)` function counts the numbers from `1` to `100000000`, and
    then returns the product of `number` × 100,000,000:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`count(number)` 函数从 `1` 计数到 `100000000`，然后返回 `number` × 100,000,000 的乘积：'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `evaluate(item)` function evaluates the `count` function on the `item`
    parameter. It prints out the `item` value and the result of `count(item)`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`evaluate(item)` 函数在 `item` 参数上评估 `count` 函数。它打印出 `item` 的值和 `count(item)`
    的结果：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In `__main__`, the sequential execution, thread pool, and process pool are
    executed:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__main__` 中，执行顺序执行、线程池和进程池：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For the sequential execution, the `evaluate` function is executed for each
    item of `number_list`. Then, the execution time is printed out:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于顺序执行，`evaluate` 函数对 `number_list` 的每个项目执行。然后，打印出执行时间：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Regarding thread and process pool execution, the same number of workers (`max_workers=5`)
    is used. Of course, for both pools, execution times are displayed:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于线程和进程池执行，使用相同的工人数量（`max_workers=5`）。当然，对于两个池，都会显示执行时间：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We build a list of numbers stored in `number_list`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个存储在`number_list`中的数字列表：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For each element in the list, we operate the counting procedure until we reach `100000000`
    iterations, and then multiply the resulting value for `100000000`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表中的每个元素，我们执行计数过程，直到达到`100000000`次迭代，然后乘以`100000000`的结果值：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `main` program, we execute the same task in sequential mode:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们以顺序模式执行相同的任务：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, in parallel mode, use the `concurrent.futures` pooling capabilities for
    a thread pool:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在并行模式下，使用`concurrent.futures`的线程池功能：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And do the same for a process pool:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进程池也做同样的操作：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that both the thread *and* process pools are set with `max_workers=5`;
    moreover, if `max_workers` is equal to `None`, it will default to the number of
    processors on the machine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，线程池和进程池都设置了`max_workers=5`；此外，如果`max_workers`等于`None`，它将默认为机器上的处理器数量。
- en: 'To run this example, open Command Prompt and, in the same folder where the
    example is contained, type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，打开命令提示符，并在包含示例的同一文件夹中，输入以下内容：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By executing the preceding example, we can see the execution of the three execution
    models with relative times:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行前面的示例，我们可以看到三种执行模型的相对时间：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It should be noted that although the example is not expensive in computational
    terms, sequential and thread pool execution are comparable in terms of time. Using
    a process pool gives us the fastest execution time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，尽管示例在计算上并不昂贵，但顺序和线程池执行在时间上是可以比较的。使用进程池给我们提供了最快的执行时间。
- en: The pool then distributes the processes (in this case, five processes) between
    the available cores (for this example, a machine with four cores was used) in
    **FIFO** (short for **first in, first out**) mode.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，池将进程（在这种情况下，五个进程）在可用的核心之间（对于本例，使用了一个具有四个核心的机器）以**FIFO**（即**先进先出**）模式分配。
- en: So, for each core, the assigned process runs in series. Only after the I/O operation
    is performed does the pool schedule the execution of another process. Of course,
    the execution mechanism is the same if you use a thread pool.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个核心，分配的进程按顺序运行。只有在执行I/O操作之后，池才会安排另一个进程的执行。当然，如果你使用线程池，执行机制也是相同的。
- en: The computational times, which are lower in the case of the process pool, must
    be traced back to the fact that I/O operations are not significant. This allows
    the pool of processes to be faster because, unlike threads, they do not require
    any synchronization mechanisms (as explained in [Chapter 1](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml), *Getting
    Started with Parallel Computing and Python*, in the *Introducing parallel programming* recipe).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 计算时间在进程池的情况下较低，这必须追溯到I/O操作并不重要的原因。这使得进程池可以更快，因为，与线程不同，它们不需要任何同步机制（如[第1章](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml)中所述，*使用Python进行并行计算入门*，在*介绍并行编程*食谱中）。
- en: There's more...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The pooling technique is widely used in server applications, as it is necessary
    to manage multiple simultaneous requests from any number of clients.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 池技术被广泛应用于服务器应用程序中，因为需要管理来自任意数量客户端的多个同时请求。
- en: 'Many other applications, however, require that every activity be performed
    immediately or that you have more control over the thread that runs it: in this
    case, pooling is not the best choice.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多其他应用程序要求每个活动都立即执行，或者你需要对运行它的线程有更多的控制：在这种情况下，池不是最佳选择。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'An interesting tutorial on `concurrent.futures` can be found here: [http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html](http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里找到一个关于`concurrent.futures`的有趣教程：[http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html](http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html)。
- en: Managing the event loop with asyncio
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asyncio管理事件循环
- en: The `asyncio` Python module provides facilities for managing events, coroutines,
    tasks, as well as threads, and synchronization primitives for writing concurrent
    code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` Python模块提供了管理事件、协程、任务以及线程的设施，以及编写并发代码的同步原语。'
- en: 'The main components of this module are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块的主要组件如下：
- en: '**Event loop**: The `asyncio` module allows one event loop per process. This
    is the entity that deals with managing and distributing the execution of different
    tasks. In particular, this registers the tasks and manages them by switching the
    control flow from one task to another.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件循环**：`asyncio`模块允许每个进程有一个事件循环。这是处理管理和分配不同任务执行的实体。特别是，它注册任务并通过在任务之间切换控制流来管理它们。'
- en: '**Coroutines**: This is a generalization of the concept of the subroutine.
    Also, a coroutine can be suspended during execution to wait for external processing
    (some routine in I/O) and return from the point it had stopped at when the external
    processing is done.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协程**：这是子程序概念的推广。此外，协程可以在执行过程中暂停以等待外部处理（某些I/O中的例程）并从外部处理完成后返回到停止的位置。'
- en: '**Futures**: This defines the `Future` object exactly like the `concurrent.futures`
    module. It represents a computation that *has still not been accomplished*.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**期货**：这定义了`Future`对象，与`concurrent.futures`模块中的定义完全相同。它表示一个尚未完成的计算。'
- en: '**Tasks**: This is a subclass of `asyncio` that is used to encapsulate and
    manage coroutines in a parallel mode.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务**：这是`asyncio`的一个子类，用于在并行模式下封装和管理协程。'
- en: In this recipe, the focus is on the concept of eventsand event management (namely, event
    loops) within a software program.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，重点是软件程序中事件和事件管理（即事件循环）的概念。
- en: Understanding event loops
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件循环
- en: In computer science, an *event *is an action intercepted by the program that
    can be managed by the program itself. As an example, an event could be the virtual
    pressure of a key by the user during interaction with the graphical interface,
    the pressure of a key on the physical keyboard, an external interrupt signal,
    or, more abstractly, the reception of data through the network. But more generally,
    any other form of event that has happened that can be detected and managed in
    some way.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*事件*是程序可以管理的程序拦截的动作。例如，一个事件可以是用户与图形界面交互时虚拟按键的压力、物理键盘上的按键压力、外部中断信号，或者更抽象地说，通过网络接收数据。但更普遍地，任何其他形式的事件，只要可以以某种方式检测和管理，都可以被视为事件。
- en: Within a system, the entity that can generate events is called an *event source*,
    while the entity that deals with handling an event that occurs are an event handler.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个系统中，能够生成事件的实体被称为*事件源*，而处理发生事件的实体被称为事件处理器。
- en: The *event loop* programming construct realizes the functionality of managing
    events within a program. More precisely, the event loop acts cyclically during
    the whole execution of the program, keeping track of events that have occurred
    within a data structure to queue and then process them one at a time by invoking
    the event handler if the main thread is free.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件循环*编程结构实现了在程序中管理事件的功能。更确切地说，事件循环在整个程序执行期间循环运行，跟踪在数据结构中发生的事件，并将它们排队，然后逐个调用事件处理器来处理，如果主线程空闲的话。'
- en: 'The pseudocode of the event loop manager is shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环管理器的伪代码如下所示：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All the events that are fed into the `while` loop are caught and then processed
    by the event handler. The handler that processes an event is the only activity
    taking place in the system. When the handler has ended, control passes to the
    next event scheduled.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所有输入到`while`循环的事件都被捕获，然后由事件处理器处理。处理事件的处理器是系统中唯一的活动。当处理器结束时，控制权传递到下一个计划的事件。
- en: '`asyncio` provides the following methods to manage an event loop:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`提供了以下方法来管理事件循环：'
- en: '`loop = get_event_loop()`: This gets the event loop for the current context.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop = get_event_loop()`: 这获取当前上下文的事件循环。'
- en: '`loop.call_later(time_delay,callback,argument)`: This arranges for the callback
    to be called after the given `time_delay`, in seconds.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.call_later(time_delay,callback,argument)`: 这安排在给定的`time_delay`（以秒为单位）后调用回调。'
- en: '`loop.call_soon(callback, argument)`: This arranges for a callback to be called
    as soon as possible. The callback is called after `call_soon()` ([https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html))
    returns when control returns to the event loop.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.call_soon(callback, argument)`: 这安排在尽可能早的时候调用回调。回调在`call_soon()`返回后调用，当控制返回到事件循环时。'
- en: '`loop.time()`: This returns the current time as a `float` value ([https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)),
    according to the event loop''s internal clock.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.time()`: 这返回事件循环内部时钟的当前时间作为`float`值 ([https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html))。'
- en: '`asyncio.set_event_loop()`: This sets the event loop for the current context
    to loop.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.set_event_loop()`: 这将当前上下文的事件循环设置为循环。'
- en: '`asyncio.new_event_loop()`: This creates and returns a new event loop object
    according to this policy''s rules.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio.new_event_loop()`: 根据此策略的规则创建并返回一个新的事件循环对象。'
- en: '`loop.run_forever()`: This runs until `stop()` ([https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html))
    is called.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop.run_forever()`: 这将一直运行，直到调用`stop()` ([https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html))。'
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example, we look at how to use the event loop statements provided by
    the `asyncio` library, in order to build an application that works in asynchronous
    mode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看看如何使用`asyncio`库提供的事件循环语句，以构建一个异步模式工作的应用程序。
- en: In this example, we defined three tasks. Each task has an execution time determined
    by a time random parameter. Once the execution is finished, **Task A** calls **Task
    B**, **Task B** calls **Task C**, and **Task C** calls **Task A**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了三个任务。每个任务的执行时间由一个随机时间参数确定。一旦执行完成，**任务A**调用**任务B**，**任务B**调用**任务C**，而**任务C**调用**任务A**。
- en: 'The event loop will continue until a termination condition is met. As we can
    imagine, this example follows this asynchronous schema:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环将继续，直到满足终止条件。正如我们可以想象的那样，这个例子遵循以下异步模式：
- en: '![](img/49fee3e4-437a-47a5-b656-1ecf755cf488.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49fee3e4-437a-47a5-b656-1ecf755cf488.png)'
- en: Asynchronous programming model
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程模型
- en: 'Let''s have a look at the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Let''s start by importing the libraries needed for our implementation:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先导入实现所需的库：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we define `task_A`, whose execution time is determined randomly and can
    vary from `1` to `5` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes to `task_B`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`task_A`，其执行时间随机确定，可以从`1`秒到`5`秒不等。在执行结束时，如果未满足终止条件，则计算转到`task_B`：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, `task_B` is defined. Its execution time is determined randomly and can
    vary from `4` to `7` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes to `task_B`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，定义了`task_B`。其执行时间随机确定，可以从`4`秒到`7`秒不等。在执行结束时，如果未满足终止条件，则计算转到`task_B`：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, `task_C` is implemented. Its execution time is determined randomly and
    can vary from `6` to `10` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes back to `task_A`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现`task_C`。其执行时间随机确定，可以从`6`秒到`10`秒不等。在执行结束时，如果未满足终止条件，则计算回到`task_A`：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next statement defines the `loop` parameter, which simply gets the current
    event loop:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个语句定义了`loop`参数，它简单地获取当前事件循环：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `end_loop` value defines the termination condition. The execution of this
    example code must last `60` seconds:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end_loop`值定义了终止条件。此示例代码的执行必须持续`60`秒：'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, let''s request the execution of `task_A`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们请求执行`task_A`：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we set a long duration cycle that continues to respond to events until
    it is stopped:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们设置一个长时间周期，它会持续响应事件，直到被停止：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, close the event loop:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭事件循环：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In order to manage the execution of the three tasks, `task_A`, `task_B`, and `task_C`,
    we need to capture the event loop:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理`task_A`、`task_B`和`task_C`三个任务的执行，我们需要捕获事件循环：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we schedule the first call to `task_A` by using the `call_soon` construct:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`call_soon`构造函数安排对`task_A`的第一个调用：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s note the definition of `task_A`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记录`task_A`的定义：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The asynchronous behavior of the application is determined by the following
    parameters:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的非同步行为由以下参数确定：
- en: '`time.sleep(random.randint(0, 5))`: This defines the duration time of the task
    execution.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time.sleep(random.randint(0, 5))`: 这定义了任务执行的持续时间。'
- en: '`end_time`: This defines the upper time limit within `task_A` and makes the
    call to `task_B` through the `call_later` method.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_time`: 这定义了`task_A`中的上限时间限制，并通过`call_later`方法调用`task_B`。'
- en: '`loop`: This is the event loop captured previously with the `get_event_loop()`
    method.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop`：这是之前使用 `get_event_loop()` 方法捕获的事件循环。'
- en: 'After executing the task, `loop.time` is compared to `end_time`. If the execution
    time is within the maximum time (60 seconds), then the computation continues by
    calling `task_B`, otherwise, the computation ends, closing the event loop:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 执行任务后，`loop.time` 与 `end_time` 进行比较。如果执行时间在最大时间（60秒）内，则通过调用 `task_B` 继续计算，否则计算结束，关闭事件循环：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the other two tasks, the operations are practically the same, but only the
    execution time and the call to the next task vary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他两个任务，操作实际上相同，但只有执行时间和对下一个任务的调用不同。
- en: 'Now, let me summarize the situation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我总结一下情况：
- en: '`task_A` calls `task_B` with a random execution time between 1 and 5 seconds.'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task_A` 使用随机执行时间在1到5秒之间调用 `task_B`。'
- en: '`task_B` calls `task_C` with a random execution time between 4 and 7 seconds.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task_B` 使用随机执行时间在4到7秒之间调用 `task_C`。'
- en: '`task_C` calls `task_A` with a random execution time between 6 and 10 seconds.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`task_C` 使用随机执行时间在6到10秒之间调用 `task_A`。'
- en: 'When the running time expires, the event loop must end:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时间到期时，事件循环必须结束：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A possible output of this example would be the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的可能输出如下：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: Asynchronous event programming replaces a type of concurrent programming in
    which several parts of the program are executed simultaneously by different threads
    that have access to the same data in memory, thus giving rise to the problem of
    critical runs. At the same time, it has become essential to be able to exploit
    the different cores of modern CPUs because, in certain areas, performance similar
    to that made available by the latter can no longer be achieved with a single-core
    processor.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 异步事件编程取代了一种并发编程类型，其中程序的不同部分由不同的线程同时执行，这些线程可以访问内存中的相同数据，从而引发临界区问题。同时，能够利用现代 CPU
    的不同核心已成为必要，因为在某些领域，使用单核处理器已无法达到后者提供的性能。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Here is a good introduction to `asyncio`: [https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c](https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `asyncio` 的一个很好的介绍：[https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c](https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c)。
- en: Handling coroutines with asyncio
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 asyncio 处理协程
- en: Throughout the various examples presented, we have seen that when a program
    becomes very long and complex, it is convenient to divide it into subroutines,
    each of which implements a specific task. However, subroutines cannot be executed
    independently, but only at the request of the main program, which is responsible
    for coordinating the use of subroutines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示的各种示例中，我们看到当程序变得非常长且复杂时，将其划分为子程序是很方便的，每个子程序实现一个特定的任务。然而，子程序不能独立执行，只能由主程序请求执行，主程序负责协调子程序的使用。
- en: 'In this section, we introduce a generalization of the concept of subroutines,
    known as coroutines: just like subroutines, coroutines compute a single computational
    step, but unlike subroutines, there is no `main` program to coordinate the results.
    The coroutines link themselves together to form a pipeline without any supervising
    function responsible for calling them in a particular order.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了子程序概念的推广，称为协程：就像子程序一样，协程计算单个计算步骤，但与子程序不同，没有 `main` 程序来协调结果。协程将自己链接起来形成一个没有负责以特定顺序调用它们的监督函数的管道。
- en: 'In a coroutine, the execution point can be suspended and resumed later, since
    the coroutine keeps track of the state of execution. Having a pool of coroutines,
    it is possible to interleave the computations: the first one runs until it *yields
    control back*, then the second runs and goes on down the line.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程中，执行点可以被挂起并在稍后恢复，因为协程跟踪执行状态。拥有协程池，可以交错计算：第一个运行直到它 *交出控制权*，然后第二个运行并继续下去。
- en: The interleaving is managed by the event loop, which was described in the *Managing
    the event loop with asyncio* recipe. It keeps track of all the coroutines and
    schedules when they will be executed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 交错由事件循环管理，这在 *使用 asyncio 管理事件循环* 的配方中已有描述。它跟踪所有协程并安排它们的执行时间。
- en: 'Other important aspects of coroutines are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的其他重要方面如下：
- en: Coroutines allow for multiple entry points that can yield multiple times.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程允许有多个入口点，可以多次产生值。
- en: Coroutines can transfer execution to any other coroutine.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程可以将执行权传递给任何其他协程。
- en: The term *yield* is used here to describe a coroutine pausing and passing the
    control flow to another coroutine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，术语*yield*用于描述协程暂停并将控制流传递给另一个协程。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the following notation to work with coroutines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下符号来处理协程：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Coroutines use the `yield from` syntax introduced in PEP 380 (read more at [https://www.python.org/dev/peps/pep-0380/](https://www.python.org/dev/peps/pep-0380/))
    to stop the execution of the current computation and suspends the coroutine's
    internal state.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 协程使用PEP 380中引入的`yield from`语法来停止当前计算的执行并挂起协程的内部状态。
- en: In particular, in the case of `yield from future`, the coroutine is suspended
    until `future` is done, then the result of `future` will be propagated (or raise
    an exception); in the case of `yield from coroutine`, the coroutine waits for
    another coroutine to produce a result that will be propagated (or raise an exception).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，在`yield from future`的情况下，协程将在`future`完成之前挂起，然后`future`的结果将被传播（或引发异常）；在`yield
    from coroutine`的情况下，协程将等待另一个协程产生一个将被传播（或引发异常）的结果。
- en: As we shall see in the next example, in which the coroutines will be used to
    simulate a finite state machine, we will use the `yield from coroutine` notation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将看到如何使用协程模拟有限状态机，我们将使用`yield from coroutine`符号。
- en: More on coroutines with `asyncio` are available at [https://docs.python.org/3.5/library/asyncio-task.html](https://docs.python.org/3.5/library/asyncio-task.html).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`asyncio`的协程信息，请参阅[https://docs.python.org/3.5/library/asyncio-task.html](https://docs.python.org/3.5/library/asyncio-task.html)。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example, we see how to use coroutines to simulate a finite state machine
    with five states.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了如何使用协程模拟具有五个状态的状态机。
- en: A **finite state machine** or **finite state automaton** is a mathematical model
    that is widely used in engineering disciplines, but also in sciences such as mathematics
    and computer science.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限状态机**或**有限状态自动机**是一个在工程学科中广泛使用的数学模型，但也在数学和计算机科学等科学中得到应用。'
- en: 'The automaton that we want to simulate the behavior of using coroutines is
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用协程模拟其行为的自动机如下：
- en: '![](img/11c82c0c-3add-446c-8ca7-ba4f599bc622.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11c82c0c-3add-446c-8ca7-ba4f599bc622.png)'
- en: Finite-state machine
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有限状态机
- en: 'The states of the system are **S0**, **S1**, **S2**, **S3**, and **S4**, with
    **0** and **1**: the values for which the automaton can pass from one state to
    the next state (this operation is called a *transition*). So, for example, state
    **S0** can pass to state **S1**, but only for the value **1**, and **S0** can
    pass to state **S2**, but only for the value **0**.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的状态是**S0**、**S1**、**S2**、**S3**和**S4**，**0**和**1**是状态机可以从一个状态转换到下一个状态（这个操作称为*转换*）的值。例如，状态**S0**可以转换到状态**S1**，但仅对于值**1**，而**S0**可以转换到状态**S2**，但仅对于值**0**。
- en: 'The following Python code simulates a transition of the automaton from state
    **S0** (the start state), up to state **S4** (the end state):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码模拟了自动机从状态**S0**（起始状态）到状态**S4**（结束状态）的转换：
- en: 'The first step is obviously to import the relevant libraries:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步显然是导入相关库：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we define the coroutine relative to `start_state`. The `input_value`
    parameter is evaluated randomly; it can be `0` or `1`. If it is `0`, then the
    control goes to coroutine `state2`; otherwise, it changes to coroutine `state1`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们相对于`start_state`定义协程。`input_value`参数随机评估；它可以是`0`或`1`。如果是`0`，则控制流转到协程`state2`；否则，它变为协程`state1`：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here is the coroutine for `state1`. The `input_value` parameter is evaluated
    randomly; it can be `0` or `1`. If it is `0`, then the control goes to `state2`;
    otherwise, it changes to `state1`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是`state1`的协程。`input_value`参数随机评估；它可以是`0`或`1`。如果是`0`，则控制流转到`state2`；否则，它变为`state1`：
- en: '[PRE33]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The coroutine for `state1` has the `transition_value` argument that allowed
    the passage of the state. Also, in this case, `input_value` is randomly evaluated.
    If it is `0`, then the state transitions to `state3`; otherwise, the control changes
    to `state2`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`state1`的协程有一个允许状态通过的`transition_value`参数。此外，在这种情况下，`input_value`是随机评估的。如果是`0`，则状态转换到`state3`；否则，控制流变为`state2`：'
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The coroutine for `state3` has the `transition_value` argument, which allowed
    the passage of the state. `input_value` is randomly evaluated. If it is `0`, then
    the state transitions to `state1`; otherwise, the control changes to `end_state`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`state3` 的协程具有允许状态转换的 `transition_value` 参数。`input_value` 是随机评估的。如果是 `0`，则状态转换到
    `state1`；否则，控制权转移到 `end_state`：'
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`end_state` prints out the `transition_value` argument, which allowed the passage
    of the state, and then stops the computation:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end_state` 打印出允许状态转换的 `transition_value` 参数，然后停止计算：'
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `__main__` function, the event loop is acquired, and then we start the
    simulation of the finite state machine, calling the automaton''s `start_state`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__main__` 函数中，获取事件循环，然后我们开始模拟有限状态机的仿真，调用自动机的 `start_state`：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each state of the automaton has been defined by using the decorator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自动机的每个状态都是通过使用装饰器定义的：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For example, state **S0** is defined here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，状态 **S0** 在这里定义：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The transition to the next state is determined by `input_value`, which is defined
    by the `randint (0,1)` function of Python's `random` module. This function randomly provides
    a value of `0` or `1`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个状态的转换是由 `input_value` 决定的，它由 Python 的 `random` 模块的 `randint (0,1)` 函数定义。此函数随机提供
    `0` 或 `1` 的值。
- en: 'In this manner, `randint` randomly determines the state to which the finite
    state machine will pass:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，`randint` 随机确定有限状态机将要转换到的状态：
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After determining the values to pass, the coroutine calls the next coroutine
    using the `yield from` command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 确定传递的值之后，协程使用 `yield from` 命令调用下一个协程：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `result` variable is the value that each coroutine returns. It is a string,
    and, at the end of the computation, we can reconstruct the transition from the
    initial state of the automaton, `start_state`, up to `end_state`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`result` 变量是每个协程返回的值。它是一个字符串，在计算结束时，我们可以从自动机的初始状态 `start_state` 重建到 `end_state`
    的转换。'
- en: 'The `main` program starts the evaluation inside the event loop:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 程序在事件循环内部开始评估：'
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the code, we have an output like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码，我们得到如下输出：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There's more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Before Python 3.5 was released, the `asyncio` module used generators to mimic
    asynchronous calls and, therefore, had a different syntax than the current version
    of Python 3.5.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.5 发布之前，`asyncio` 模块使用生成器来模拟异步调用，因此其语法与 Python 3.5 的当前版本不同。
- en: Python 3.5 introduced the `async` and `await` keywords. Notice the lack of parentheses
    around the `await func()` call.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5 引入了 `async` 和 `await` 关键字。注意 `await func()` 调用周围没有括号。
- en: 'The following is an example of `"Hello, world!"`, using `asyncio` with the
    new syntax introduced by Python 3.5+:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 Python 3.5+ 引入的新语法的 `"Hello, world!"` 示例，使用 `asyncio`：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'Coroutines in Python are well described here: [https://www.geeksforgeeks.org/coroutine-in-python/](https://www.geeksforgeeks.org/coroutine-in-python/).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的协程在这里有很好的描述：[https://www.geeksforgeeks.org/coroutine-in-python/](https://www.geeksforgeeks.org/coroutine-in-python/)。
- en: Manipulating tasks with asyncio
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 asyncio 操作任务
- en: The `asyncio` module is designed to handle asynchronous processes and concurrent
    task execution over an event loop. It also provides the `asyncio.Task()` class
    for the purpose of wrapping coroutines in a task ([https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)).
    Its use is to allow independently running tasks to run concurrently with other
    tasks over the same event loop.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 模块旨在处理事件循环上的异步过程和并发任务执行。它还提供了 `asyncio.Task()` 类，用于将协程包装在任务中（[https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)）。它的用途是允许独立运行的任务在相同的事件循环上与其他任务并发运行。'
- en: When a coroutine is wrapped in a task, it connects `Task` to the event loop
    and then runs automatically when the loop is started, thus providing a mechanism
    for automatically driving the coroutine.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当协程被任务包装时，它将 `Task` 连接到事件循环，并在循环启动时自动运行，从而提供了一种自动驱动协程的机制。
- en: The `asyncio` module provides the `asyncio.Task(coroutine)` method to handle
    computations with tasks; moreover, `asyncio.Task(coroutine)` schedules the execution
    of a coroutine ([https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 模块提供了 `asyncio.Task(coroutine)` 方法来处理带有任务的计算；此外，`asyncio.Task(coroutine)`
    调度协程的执行（[https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)）。'
- en: A task is responsible for executing a coroutine object in an *event loop.*
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: If the wrapped coroutine uses the `yields from future` notation, as already
    described in the *Handling coroutines with asyncio* section*, *then the task suspends
    the execution of the wrapped coroutine and awaits completion of the future.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: When the future is done, the execution of the wrapped coroutine restarts with
    the result or the exception of the future. Also, we must note that an event loop
    only runs one task at a time. Other tasks may run in parallel if other event loops
    are running in different threads.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: While a task waits for the completion of a future, the event loop executes a
    new task.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we show how three mathematical functions can be executed concurrently
    by the `asyncio.Task()` statement:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, let''s start by importing the `asyncio` library:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the first coroutine, the `factorial` function is defined:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After which, the second function is defined—the `fibonacci` function:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last function to be executed concurrently is the binomial coefficient:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `__main__` function, `task_list` contains the functions that must be
    performed in parallel using the `asyncio.Task` function:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we acquire the event loop and start the computation:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each coroutine is defined by the `@asyncio.coroutine` annotation (called the *decorator*):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To run in parallel, each function is an argument of the `asyncio.Task` module,
    and therefore, they are included in `task_list`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we get the event loop:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we add the execution of `task_list` to the event loop:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note that the `asyncio.wait(task_list)` statement waits for the given coroutines
    to complete.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the preceding code looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: There's more...
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`asyncio` provides other ways to schedule tasks using the `ensure_future()`
    or `AbstractEventLoop.create_task()` methods, which both accept a coroutine object.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More on `asyncio` and tasks can be found here: [https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/](https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with asyncio and futures
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another key component of the `asyncio` module is the `asyncio.Future` class. It
    is very similar to `concurrent.Futures`, but, of course, it is adapted to the
    main mechanism of `asyncio`: the event loop.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio.Future` class represents a result (but can also be an exception)
    that is not yet available.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Hence, it represents an abstraction of something that is yet to be achieved.
    The callbacks that have to process any results are, in fact, added to instances
    of this class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define a `future` object, the following syntax must be used:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The main methods to manage this object are the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '`cancel()`: This cancels the `future` object and schedules callbacks.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result()`: This returns the result that this `future` represents.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exception()`: This returns the exception that was set on this `future`.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_done_callback(fn)`: This adds a callback to be run when `future` is done.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_done_callback(fn)`: 这将在`future`完成时添加一个要运行的回调。'
- en: '`remove_done_callback(fn)`: This removes all instances of a callback from the
    call when done.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove_done_callback(fn)`: 这将在完成时从调用中移除所有回调实例。'
- en: '`set_result(result)`: This marks `future` as done and sets its result.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_result(result)`: 这将`future`标记为完成并设置其结果。'
- en: '`set_exception(exception)`: This marks `future` as done and sets an exception.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_exception(exception)`: 这将`future`标记为完成并设置一个异常。'
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following example shows how to use the `asyncio.Future` class for the management
    of two coroutines: `first_coroutine` and `second_coroutine`, which perform the
    following tasks. `first_coroutine` performs the sum of the first *N* integers,
    and `second_coroutine` performs the factorial of N:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用`asyncio.Future`类来管理两个协程：`first_coroutine`和`second_coroutine`，它们执行以下任务。`first_coroutine`执行前*N*个整数的求和，而`second_coroutine`执行N的阶乘：
- en: 'Now, let''s import the relevant libraries:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们导入相关的库：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`first_coroutine` implements the `sum` function of the first *N* integers:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`first_coroutine`实现了前*N*个整数的`sum`函数：'
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In `second_coroutine`, we still implement the `factorial` function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`second_coroutine`中，我们仍然实现了`factorial`函数：
- en: '[PRE59]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Using the `got_result` function, we print the output of the computation:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`got_result`函数，我们打印计算的输出：
- en: '[PRE60]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the `main` function, the `num1` and `num2` parameters must be set by the
    user. They will be used as parameters for the functions implemented by the first
    and second coroutines:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，`num1`和`num2`参数必须由用户设置。它们将被用作第一个和第二个协程实现的功能的参数：
- en: '[PRE61]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s take the event loop:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看事件循环：
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here, the futures are defined by the `asyncio.future` function:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，未来对象是通过`asyncio.future`函数定义的：
- en: '[PRE63]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The two coroutines—`first_couroutine` and `second_couroutine`—included in the
    `tasks` list have the `future1` and `future2` futures, the user-defined arguments,
    and the `num1` and `num2` parameters:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含在`tasks`列表中的两个协程——`first_couroutine`和`second_couroutine`——具有`future1`和`future2`未来对象、用户定义的参数以及`num1`和`num2`参数：
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The futures have added a callback:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 未来对象添加了一个回调：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, the `tasks` list is added to the event loop, so that the computation
    can begin:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`tasks`列表添加到事件循环中，以便开始计算：
- en: '[PRE66]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How it works...
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `main` program, we define the `future` objects,`future1` and `future2` respectively,
    using via the `asyncio.Future()` directive:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`程序中，我们使用`asyncio.Future()`指令分别定义了`future`对象`future1`和`future2`：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In defining the tasks, we pass the `future` objects as an argument of the two
    coroutines `first_couroutine` and `second_couroutine`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义任务时，我们将`future`对象作为两个协程`first_couroutine`和`second_couroutine`的参数传递：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we add a callback to be run when `future` is done:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加一个在`future`完成时要运行的回调：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, `got_result` is a function that prints the result of `future`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`got_result`是一个打印`future`结果的函数：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the coroutine, we pass the `future` object as an argument. After the computation,
    we set `sleep` times of 3 seconds for the first coroutine and 4 seconds for the
    second one:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程中，我们将`future`对象作为参数传递。计算完成后，我们为第一个协程设置3秒的睡眠时间，为第二个协程设置4秒的睡眠时间：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following output is obtained by executing the command with different values:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令时，根据不同的值可以获得以下输出：
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: There's more...
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can invert the output results, that is, have the output of `second_coroutine`
    first, by simply swapping the sleep time between the coroutines: `yield from asyncio.sleep(2)` in
    the `first_coroutine` definition, and `yield from asyncio.sleep(1)` in the `second_coroutine`
    definition. This can be shown by the following example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以反转输出结果，即先输出`second_coroutine`的结果，只需简单地交换两个协程之间的睡眠时间：在`first_coroutine`定义中使用`yield
    from asyncio.sleep(2)`，在`second_coroutine`定义中使用`yield from asyncio.sleep(1)`。这可以通过以下示例展示：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: See also
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: More examples of `asyncio` and futures can be found at [https://www.programcreek.com/python/example/102763/asyncio.futures](https://www.programcreek.com/python/example/102763/asyncio.futures).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于`asyncio`和未来的示例可以在[https://www.programcreek.com/python/example/102763/asyncio.futures](https://www.programcreek.com/python/example/102763/asyncio.futures)找到。
