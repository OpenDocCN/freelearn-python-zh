- en: Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Beside the sequential and parallel execution models, there is a third model
    that is of fundamental importance together with the concept of event programming:
    the *asynchronous model*.'
  prefs: []
  type: TYPE_NORMAL
- en: The execution model of asynchronous tasks can be implemented through a single
    main control flow, both in single-processor systems and in multiprocessor systems.
    In the concurrent asynchronous execution model, the executions of various tasks
    intersect along the timeline, and everything happens under the action of a single
    flow of control (single-threaded). Once started, the execution of tasks can be
    suspended and then resumed over time, alternating with the execution of other
    current tasks that are present.
  prefs: []
  type: TYPE_NORMAL
- en: The development of code for the asynchronous model is completely different from
    that for multithreaded programming. A substantial difference between the concurrent
    multithreaded parallel model and the single-threaded concurrent asynchronous model
    lies in the fact that, in the first case, the OS decides on the timeline if we
    suspend the activity of one thread and start another.
  prefs: []
  type: TYPE_NORMAL
- en: This remains outside the control of the coder, unlike the asynchronous model.
    The execution or termination of a task continues as long as it is explicitly required.
  prefs: []
  type: TYPE_NORMAL
- en: The most important feature of this type of programming is that the code is not
    performed on multiple threads, as in the classic concurrent programming, but on
    a single thread. Thus, it is not at all true that two tasks are executed at the
    same time, but, according to this approach, they are performed at almost the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, we will describe the `asyncio`Python module, which was introduced
    in Python 3.4\. This allows us to use coroutines and futures to make writing asynchronous
    code easier and to make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `concurrent.futures` Python module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the event loop with `asyncio`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling coroutines with `asyncio`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating tasks with `asyncio`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with `asyncio` and futures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the concurrent.futures Python module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `concurrent.futures` module, which is part of the standard Python library,
    provides a level of abstraction on threads by modelling them as asynchronous functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module is built by two main classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`concurrent.futures.Executor`: This is an abstract class that provides methods
    to execute calls asynchronously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concurrent.futures.Future`: This encapsulates the asynchronous execution of
    a callable. Future objects are instantiated by submitting tasks (functions with
    optional parameters) to `Executors`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of the main methods of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`submit(function,argument)`: This schedules the execution of the callable function
    on the arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**`map(function,argument)`**: This executes the functions of arguments in asynchronous
    mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown(Wait=True)`: This signals the executor to free any resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The executors are accessed through their subclasses: `ThreadPoolExecutor` or
    `ProcessPoolExecutor`. Because the instantiation of threads and processes is a
    resource-demanding task, it is better to pool these resources and use them as
    repeatable launchers or executors (hence the `Executors` concept) for parallel
    or concurrent tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: The approach we are taking here involves using a pool executor. We will submit
    the assets to the pool (thread and process) and get the futures, which are the
    results that will be available to us in the future. Of course, we can wait for
    all futures to become real results.
  prefs: []
  type: TYPE_NORMAL
- en: A thread or process pool (also called *pooling*) indicates a management software
    that is being used to optimize and simplify the use of threads and/or processes
    within a program. Through pooling, you can submit the task (or tasks) in order
    to execute them to the pooler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pool is equipped with an internal queue of tasks pending and several threads
    *or* processes that execute them. A recurring concept in pooling is reusing: a
    thread (or process) is used several times for different tasks during its life
    cycle. This decreases the overhead of creating new threads or processes and increases
    the performance of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Reuse *is not a rule*, but it is one of the main reasons that lead a coder to
    use pooling in their application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `concurrent.futures` module provides two subclasses of the `Executor` class, which
    asynchronously manipulate a pool of threads and a pool of processes. The two subclasses
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`concurrent.futures.ThreadPoolExecutor(max_workers)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`concurrent.futures.ProcessPoolExecutor(max_workers)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `max_workers` parameter identifies the maximum number of workers that execute
    the call asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is an example of thread and process pool usage, where we will compare the
    execution time with the time it takes for sequential execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task to be performed is as follows: we have a list of 10 elements. Each
    element of the list is made to count up to 100,000,000 (just to waste time), and
    then the last number is multiplied by the *i-th* element of the list. In particular,
    we are evaluating the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequential execution**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread pool with five workers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process pool with five workers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the relevant libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the list of numbers from `1` to `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `count(number)` function counts the numbers from `1` to `100000000`, and
    then returns the product of `number` × 100,000,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `evaluate(item)` function evaluates the `count` function on the `item`
    parameter. It prints out the `item` value and the result of `count(item)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In `__main__`, the sequential execution, thread pool, and process pool are
    executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sequential execution, the `evaluate` function is executed for each
    item of `number_list`. Then, the execution time is printed out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding thread and process pool execution, the same number of workers (`max_workers=5`)
    is used. Of course, for both pools, execution times are displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We build a list of numbers stored in `number_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For each element in the list, we operate the counting procedure until we reach `100000000`
    iterations, and then multiply the resulting value for `100000000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` program, we execute the same task in sequential mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in parallel mode, use the `concurrent.futures` pooling capabilities for
    a thread pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And do the same for a process pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that both the thread *and* process pools are set with `max_workers=5`;
    moreover, if `max_workers` is equal to `None`, it will default to the number of
    processors on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this example, open Command Prompt and, in the same folder where the
    example is contained, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'By executing the preceding example, we can see the execution of the three execution
    models with relative times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that although the example is not expensive in computational
    terms, sequential and thread pool execution are comparable in terms of time. Using
    a process pool gives us the fastest execution time.
  prefs: []
  type: TYPE_NORMAL
- en: The pool then distributes the processes (in this case, five processes) between
    the available cores (for this example, a machine with four cores was used) in
    **FIFO** (short for **first in, first out**) mode.
  prefs: []
  type: TYPE_NORMAL
- en: So, for each core, the assigned process runs in series. Only after the I/O operation
    is performed does the pool schedule the execution of another process. Of course,
    the execution mechanism is the same if you use a thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: The computational times, which are lower in the case of the process pool, must
    be traced back to the fact that I/O operations are not significant. This allows
    the pool of processes to be faster because, unlike threads, they do not require
    any synchronization mechanisms (as explained in [Chapter 1](64fc65f9-fe29-4c34-9da7-13f272eaab9e.xhtml), *Getting
    Started with Parallel Computing and Python*, in the *Introducing parallel programming* recipe).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pooling technique is widely used in server applications, as it is necessary
    to manage multiple simultaneous requests from any number of clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many other applications, however, require that every activity be performed
    immediately or that you have more control over the thread that runs it: in this
    case, pooling is not the best choice.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An interesting tutorial on `concurrent.futures` can be found here: [http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html](http://masnun.com/2016/03/29/python-a-quick-introduction-to-the-concurrent-futures-module.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the event loop with asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `asyncio` Python module provides facilities for managing events, coroutines,
    tasks, as well as threads, and synchronization primitives for writing concurrent
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main components of this module are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event loop**: The `asyncio` module allows one event loop per process. This
    is the entity that deals with managing and distributing the execution of different
    tasks. In particular, this registers the tasks and manages them by switching the
    control flow from one task to another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coroutines**: This is a generalization of the concept of the subroutine.
    Also, a coroutine can be suspended during execution to wait for external processing
    (some routine in I/O) and return from the point it had stopped at when the external
    processing is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Futures**: This defines the `Future` object exactly like the `concurrent.futures`
    module. It represents a computation that *has still not been accomplished*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tasks**: This is a subclass of `asyncio` that is used to encapsulate and
    manage coroutines in a parallel mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, the focus is on the concept of eventsand event management (namely, event
    loops) within a software program.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding event loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer science, an *event *is an action intercepted by the program that
    can be managed by the program itself. As an example, an event could be the virtual
    pressure of a key by the user during interaction with the graphical interface,
    the pressure of a key on the physical keyboard, an external interrupt signal,
    or, more abstractly, the reception of data through the network. But more generally,
    any other form of event that has happened that can be detected and managed in
    some way.
  prefs: []
  type: TYPE_NORMAL
- en: Within a system, the entity that can generate events is called an *event source*,
    while the entity that deals with handling an event that occurs are an event handler.
  prefs: []
  type: TYPE_NORMAL
- en: The *event loop* programming construct realizes the functionality of managing
    events within a program. More precisely, the event loop acts cyclically during
    the whole execution of the program, keeping track of events that have occurred
    within a data structure to queue and then process them one at a time by invoking
    the event handler if the main thread is free.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode of the event loop manager is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: All the events that are fed into the `while` loop are caught and then processed
    by the event handler. The handler that processes an event is the only activity
    taking place in the system. When the handler has ended, control passes to the
    next event scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: '`asyncio` provides the following methods to manage an event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loop = get_event_loop()`: This gets the event loop for the current context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop.call_later(time_delay,callback,argument)`: This arranges for the callback
    to be called after the given `time_delay`, in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop.call_soon(callback, argument)`: This arranges for a callback to be called
    as soon as possible. The callback is called after `call_soon()` ([https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html))
    returns when control returns to the event loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop.time()`: This returns the current time as a `float` value ([https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)),
    according to the event loop''s internal clock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asyncio.set_event_loop()`: This sets the event loop for the current context
    to loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asyncio.new_event_loop()`: This creates and returns a new event loop object
    according to this policy''s rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop.run_forever()`: This runs until `stop()` ([https://docs.python.org/3/library/asyncio-eventloop.html](https://docs.python.org/3/library/asyncio-eventloop.html))
    is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we look at how to use the event loop statements provided by
    the `asyncio` library, in order to build an application that works in asynchronous
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we defined three tasks. Each task has an execution time determined
    by a time random parameter. Once the execution is finished, **Task A** calls **Task
    B**, **Task B** calls **Task C**, and **Task C** calls **Task A**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event loop will continue until a termination condition is met. As we can
    imagine, this example follows this asynchronous schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49fee3e4-437a-47a5-b656-1ecf755cf488.png)'
  prefs: []
  type: TYPE_IMG
- en: Asynchronous programming model
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the libraries needed for our implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define `task_A`, whose execution time is determined randomly and can
    vary from `1` to `5` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes to `task_B`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `task_B` is defined. Its execution time is determined randomly and can
    vary from `4` to `7` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes to `task_B`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `task_C` is implemented. Its execution time is determined randomly and
    can vary from `6` to `10` seconds. At the end of the execution, if the termination
    condition is not satisfied, then the computation goes back to `task_A`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next statement defines the `loop` parameter, which simply gets the current
    event loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `end_loop` value defines the termination condition. The execution of this
    example code must last `60` seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s request the execution of `task_A`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we set a long duration cycle that continues to respond to events until
    it is stopped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, close the event loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to manage the execution of the three tasks, `task_A`, `task_B`, and `task_C`,
    we need to capture the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we schedule the first call to `task_A` by using the `call_soon` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s note the definition of `task_A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The asynchronous behavior of the application is determined by the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`time.sleep(random.randint(0, 5))`: This defines the duration time of the task
    execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end_time`: This defines the upper time limit within `task_A` and makes the
    call to `task_B` through the `call_later` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop`: This is the event loop captured previously with the `get_event_loop()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After executing the task, `loop.time` is compared to `end_time`. If the execution
    time is within the maximum time (60 seconds), then the computation continues by
    calling `task_B`, otherwise, the computation ends, closing the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For the other two tasks, the operations are practically the same, but only the
    execution time and the call to the next task vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let me summarize the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`task_A` calls `task_B` with a random execution time between 1 and 5 seconds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`task_B` calls `task_C` with a random execution time between 4 and 7 seconds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`task_C` calls `task_A` with a random execution time between 6 and 10 seconds.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the running time expires, the event loop must end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible output of this example would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous event programming replaces a type of concurrent programming in
    which several parts of the program are executed simultaneously by different threads
    that have access to the same data in memory, thus giving rise to the problem of
    critical runs. At the same time, it has become essential to be able to exploit
    the different cores of modern CPUs because, in certain areas, performance similar
    to that made available by the latter can no longer be achieved with a single-core
    processor.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a good introduction to `asyncio`: [https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c](https://hackernoon.com/a-simple-introduction-to-pythons-asyncio-595d9c9ecf8c).'
  prefs: []
  type: TYPE_NORMAL
- en: Handling coroutines with asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the various examples presented, we have seen that when a program
    becomes very long and complex, it is convenient to divide it into subroutines,
    each of which implements a specific task. However, subroutines cannot be executed
    independently, but only at the request of the main program, which is responsible
    for coordinating the use of subroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we introduce a generalization of the concept of subroutines,
    known as coroutines: just like subroutines, coroutines compute a single computational
    step, but unlike subroutines, there is no `main` program to coordinate the results.
    The coroutines link themselves together to form a pipeline without any supervising
    function responsible for calling them in a particular order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a coroutine, the execution point can be suspended and resumed later, since
    the coroutine keeps track of the state of execution. Having a pool of coroutines,
    it is possible to interleave the computations: the first one runs until it *yields
    control back*, then the second runs and goes on down the line.'
  prefs: []
  type: TYPE_NORMAL
- en: The interleaving is managed by the event loop, which was described in the *Managing
    the event loop with asyncio* recipe. It keeps track of all the coroutines and
    schedules when they will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other important aspects of coroutines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines allow for multiple entry points that can yield multiple times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines can transfer execution to any other coroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term *yield* is used here to describe a coroutine pausing and passing the
    control flow to another coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the following notation to work with coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Coroutines use the `yield from` syntax introduced in PEP 380 (read more at [https://www.python.org/dev/peps/pep-0380/](https://www.python.org/dev/peps/pep-0380/))
    to stop the execution of the current computation and suspends the coroutine's
    internal state.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, in the case of `yield from future`, the coroutine is suspended
    until `future` is done, then the result of `future` will be propagated (or raise
    an exception); in the case of `yield from coroutine`, the coroutine waits for
    another coroutine to produce a result that will be propagated (or raise an exception).
  prefs: []
  type: TYPE_NORMAL
- en: As we shall see in the next example, in which the coroutines will be used to
    simulate a finite state machine, we will use the `yield from coroutine` notation.
  prefs: []
  type: TYPE_NORMAL
- en: More on coroutines with `asyncio` are available at [https://docs.python.org/3.5/library/asyncio-task.html](https://docs.python.org/3.5/library/asyncio-task.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we see how to use coroutines to simulate a finite state machine
    with five states.
  prefs: []
  type: TYPE_NORMAL
- en: A **finite state machine** or **finite state automaton** is a mathematical model
    that is widely used in engineering disciplines, but also in sciences such as mathematics
    and computer science.
  prefs: []
  type: TYPE_NORMAL
- en: 'The automaton that we want to simulate the behavior of using coroutines is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11c82c0c-3add-446c-8ca7-ba4f599bc622.png)'
  prefs: []
  type: TYPE_IMG
- en: Finite-state machine
  prefs: []
  type: TYPE_NORMAL
- en: 'The states of the system are **S0**, **S1**, **S2**, **S3**, and **S4**, with
    **0** and **1**: the values for which the automaton can pass from one state to
    the next state (this operation is called a *transition*). So, for example, state
    **S0** can pass to state **S1**, but only for the value **1**, and **S0** can
    pass to state **S2**, but only for the value **0**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code simulates a transition of the automaton from state
    **S0** (the start state), up to state **S4** (the end state):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is obviously to import the relevant libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the coroutine relative to `start_state`. The `input_value`
    parameter is evaluated randomly; it can be `0` or `1`. If it is `0`, then the
    control goes to coroutine `state2`; otherwise, it changes to coroutine `state1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the coroutine for `state1`. The `input_value` parameter is evaluated
    randomly; it can be `0` or `1`. If it is `0`, then the control goes to `state2`;
    otherwise, it changes to `state1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The coroutine for `state1` has the `transition_value` argument that allowed
    the passage of the state. Also, in this case, `input_value` is randomly evaluated.
    If it is `0`, then the state transitions to `state3`; otherwise, the control changes
    to `state2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The coroutine for `state3` has the `transition_value` argument, which allowed
    the passage of the state. `input_value` is randomly evaluated. If it is `0`, then
    the state transitions to `state1`; otherwise, the control changes to `end_state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`end_state` prints out the `transition_value` argument, which allowed the passage
    of the state, and then stops the computation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `__main__` function, the event loop is acquired, and then we start the
    simulation of the finite state machine, calling the automaton''s `start_state`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each state of the automaton has been defined by using the decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, state **S0** is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The transition to the next state is determined by `input_value`, which is defined
    by the `randint (0,1)` function of Python's `random` module. This function randomly provides
    a value of `0` or `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this manner, `randint` randomly determines the state to which the finite
    state machine will pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After determining the values to pass, the coroutine calls the next coroutine
    using the `yield from` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `result` variable is the value that each coroutine returns. It is a string,
    and, at the end of the computation, we can reconstruct the transition from the
    initial state of the automaton, `start_state`, up to `end_state`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main` program starts the evaluation inside the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code, we have an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Python 3.5 was released, the `asyncio` module used generators to mimic
    asynchronous calls and, therefore, had a different syntax than the current version
    of Python 3.5.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.5 introduced the `async` and `await` keywords. Notice the lack of parentheses
    around the `await func()` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of `"Hello, world!"`, using `asyncio` with the
    new syntax introduced by Python 3.5+:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coroutines in Python are well described here: [https://www.geeksforgeeks.org/coroutine-in-python/](https://www.geeksforgeeks.org/coroutine-in-python/).'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating tasks with asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `asyncio` module is designed to handle asynchronous processes and concurrent
    task execution over an event loop. It also provides the `asyncio.Task()` class
    for the purpose of wrapping coroutines in a task ([https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)).
    Its use is to allow independently running tasks to run concurrently with other
    tasks over the same event loop.
  prefs: []
  type: TYPE_NORMAL
- en: When a coroutine is wrapped in a task, it connects `Task` to the event loop
    and then runs automatically when the loop is started, thus providing a mechanism
    for automatically driving the coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio` module provides the `asyncio.Task(coroutine)` method to handle
    computations with tasks; moreover, `asyncio.Task(coroutine)` schedules the execution
    of a coroutine ([https://docs.python.org/3/library/asyncio-task.html](https://docs.python.org/3/library/asyncio-task.html)).
  prefs: []
  type: TYPE_NORMAL
- en: A task is responsible for executing a coroutine object in an *event loop.*
  prefs: []
  type: TYPE_NORMAL
- en: If the wrapped coroutine uses the `yields from future` notation, as already
    described in the *Handling coroutines with asyncio* section*, *then the task suspends
    the execution of the wrapped coroutine and awaits completion of the future.
  prefs: []
  type: TYPE_NORMAL
- en: When the future is done, the execution of the wrapped coroutine restarts with
    the result or the exception of the future. Also, we must note that an event loop
    only runs one task at a time. Other tasks may run in parallel if other event loops
    are running in different threads.
  prefs: []
  type: TYPE_NORMAL
- en: While a task waits for the completion of a future, the event loop executes a
    new task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we show how three mathematical functions can be executed concurrently
    by the `asyncio.Task()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, let''s start by importing the `asyncio` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first coroutine, the `factorial` function is defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After which, the second function is defined—the `fibonacci` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The last function to be executed concurrently is the binomial coefficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `__main__` function, `task_list` contains the functions that must be
    performed in parallel using the `asyncio.Task` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we acquire the event loop and start the computation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each coroutine is defined by the `@asyncio.coroutine` annotation (called the *decorator*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To run in parallel, each function is an argument of the `asyncio.Task` module,
    and therefore, they are included in `task_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we get the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the execution of `task_list` to the event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `asyncio.wait(task_list)` statement waits for the given coroutines
    to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the preceding code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`asyncio` provides other ways to schedule tasks using the `ensure_future()`
    or `AbstractEventLoop.create_task()` methods, which both accept a coroutine object.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More on `asyncio` and tasks can be found here: [https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/](https://tutorialedge.net/python/concurrency/asyncio-tasks-tutorial/).'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with asyncio and futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another key component of the `asyncio` module is the `asyncio.Future` class. It
    is very similar to `concurrent.Futures`, but, of course, it is adapted to the
    main mechanism of `asyncio`: the event loop.'
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio.Future` class represents a result (but can also be an exception)
    that is not yet available.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, it represents an abstraction of something that is yet to be achieved.
    The callbacks that have to process any results are, in fact, added to instances
    of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define a `future` object, the following syntax must be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The main methods to manage this object are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cancel()`: This cancels the `future` object and schedules callbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`result()`: This returns the result that this `future` represents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exception()`: This returns the exception that was set on this `future`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_done_callback(fn)`: This adds a callback to be run when `future` is done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_done_callback(fn)`: This removes all instances of a callback from the
    call when done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_result(result)`: This marks `future` as done and sets its result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_exception(exception)`: This marks `future` as done and sets an exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example shows how to use the `asyncio.Future` class for the management
    of two coroutines: `first_coroutine` and `second_coroutine`, which perform the
    following tasks. `first_coroutine` performs the sum of the first *N* integers,
    and `second_coroutine` performs the factorial of N:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s import the relevant libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`first_coroutine` implements the `sum` function of the first *N* integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In `second_coroutine`, we still implement the `factorial` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `got_result` function, we print the output of the computation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` function, the `num1` and `num2` parameters must be set by the
    user. They will be used as parameters for the functions implemented by the first
    and second coroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take the event loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the futures are defined by the `asyncio.future` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The two coroutines—`first_couroutine` and `second_couroutine`—included in the
    `tasks` list have the `future1` and `future2` futures, the user-defined arguments,
    and the `num1` and `num2` parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The futures have added a callback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `tasks` list is added to the event loop, so that the computation
    can begin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `main` program, we define the `future` objects,`future1` and `future2` respectively,
    using via the `asyncio.Future()` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In defining the tasks, we pass the `future` objects as an argument of the two
    coroutines `first_couroutine` and `second_couroutine`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add a callback to be run when `future` is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `got_result` is a function that prints the result of `future`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the coroutine, we pass the `future` object as an argument. After the computation,
    we set `sleep` times of 3 seconds for the first coroutine and 4 seconds for the
    second one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is obtained by executing the command with different values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can invert the output results, that is, have the output of `second_coroutine`
    first, by simply swapping the sleep time between the coroutines: `yield from asyncio.sleep(2)` in
    the `first_coroutine` definition, and `yield from asyncio.sleep(1)` in the `second_coroutine`
    definition. This can be shown by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More examples of `asyncio` and futures can be found at [https://www.programcreek.com/python/example/102763/asyncio.futures](https://www.programcreek.com/python/example/102763/asyncio.futures).
  prefs: []
  type: TYPE_NORMAL
