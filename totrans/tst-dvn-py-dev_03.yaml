- en: Chapter 3. Code Smells and Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we went through the TDD cycle in a little more detail.
    In this chapter, we will look at the related concept of code smells and refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest advantages of following a test-driven development process
    is that the tests that we write are always around to make sure that we don't break
    anything. This gives us a safety net to tinker with the code and make sure that
    it is easy to read, easy to maintain, and well written. Without tests, we always
    have a nagging doubt about whether we are about to break something, and more often
    than not we decide to leave things alone. This leads to the code decaying over
    time, until it is such a mess that no one wants to touch it anymore. The result
    is that it takes longer to implement new features, not only because the design
    is a mess, but also because we have to follow it with extensive testing to make
    sure none of the existing functionality has broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, it is vital that we do not skip the third step of the TDD
    cycle: refactoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code for this chapter starts at the point after the exercise in the previous
    chapter has been completed. See the [Appendix A](apa.html "Appendix A. Answers
    to Exercises"), *Answers to Exercises* for the changes done in the exercise, or
    download the starting point of the code for this chapter from [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)
  prefs: []
  type: TYPE_NORMAL
- en: A dual crossover moving average
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we wrote a method to check for an increasing trend.
    We will take that example forward in this chapter by developing a method to check
    for a dual crossover moving average.
  prefs: []
  type: TYPE_NORMAL
- en: A **dual crossover moving average** (**DMAC**) is a simple indicator to show
    the short-term trend of a stock compared to a long-term trend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how the DMAC works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A dual crossover moving average](img/3125_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consider a stock, with closing prices as shown above. First, we calculate two
    moving average trends. The short-term (5-day) moving average is calculated by
    taking the moving average for a short number of days. The long-term moving average
    is calculated by taking the moving average for a longer number of days, for example
    the moving average of the last 10 days.
  prefs: []
  type: TYPE_NORMAL
- en: When we plot the values of the long- term and short-term moving average graphs,
    we see that at certain points, the short-term graph crosses from below the long-term
    to above the long-term graph. This point represents a **Buy Signal**. At other
    points, the short-term crosses from above to below. This point represents a **Sell
    Signal**. At all other points, nothing should be done.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the dual crossover moving average
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we are going to do is to implement a method `get_crossover_signal` for
    the `Stock` class. The following are the requirements for the method:'
  prefs: []
  type: TYPE_NORMAL
- en: The method takes a date as a parameter, and returns if there is any crossover
    on that date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method should return `1` if there is a **Buy Signal** (5-day moving average
    crosses 10-day moving average from below to above on that date)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method should return –1 if there is a **Sell Signal** (5-day moving average
    crosses 10-day moving average from above to below on that date)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no crossover, then the method returns 0 (**neutral** signal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method should only take into account the closing price (the last update
    for the date), and not the opening or intermediate prices for the date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are no updates for the date, then the method should use the previous
    closing price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is not enough data to calculate the long-term moving average (we need
    closing prices for at least 11 days), then the method should return 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying code smells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an implementation that passes the tests (for a listing of the
    test cases, download the code for this chapter from [https://github.com/siddhi/test_driven_python](https://github.com/siddhi/test_driven_python)).
    The implementation uses the `timedelta` class from the `datetime` module, so you'll
    have to import it at the top of the file to get it to work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While the above code implements the functionality, it is totally unreadable.
    This is what happens when the refactoring step is skipped. It will take a long
    time to understand when we come back to this code after some months to fix a bug
    or add functionality. Therefore, refactoring regularly is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are the problems you can find with this code? The following are some problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Long method**: Long methods and classes are difficult to read and understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unclear naming**: For instance, what is variable `cpl` supposed to be?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex conditionals**: The `if` conditions are quite complicated, and it
    is unclear what exactly they are checking for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bad comments**: None of the comments are descriptive and, in addition, two
    comments both say `BUY signal`. Obviously, one of them is wrong.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Magic constants**: In various places, the numbers 5, 10, –11, and so on are
    hard coded. Suppose we decide to change the long-term moving average to use a
    20-day period, then where are the places we need to change? What is the possibility
    that we may miss one?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code duplication**: Both the conditionals seem almost the same, with a very
    minor difference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these problems are generally referred to as code smells. **Code smells**
    are simple patterns that can be easily spotted and refactored to make code better.
    Sometimes, code smells can be rectified by doing a few simple changes. Other times,
    it may lead up to a change of the design itself.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Refactoring** is the process of cleaning up code or changing a design using
    a sequence of very small steps. No new functionality is added or removed during
    the refactoring process. The aim of refactoring is to make the code better by
    eliminating some code smell. There are many types of refactoring, from the extremely
    simple going up to much more complex refactorings. Let us apply some of these
    to the code above.'
  prefs: []
  type: TYPE_NORMAL
- en: The Rename Variable and Rename Method refactorings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These two are probably the two simplest refactorings. The names are self explanatory—the
    refactoring is to rename a variable or a method. Although simple, they are very
    important because poor variable and method names are very common code smells.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps to apply the **Rename Variable** refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Run all the tests to make sure they are passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the name of the variable, and make the change in all the places where
    it is being used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all the tests again to make sure we didn't break anything.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **Rename Method** refactoring follows the following sequence of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run all the tests to make sure they are passing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the name of the method, and make the change in all the places where this
    method is being called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us now apply the Rename Variable refactoring to our code. The `cpl` variable
    holds the list of the closing prices of the stock for the last 11 days. We should
    rename this to something more descriptive, like `closing_price_list`. Let us do
    this now:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests (a listing of the test cases is given in the *Exercise* section
    at the end of this chapter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `cpl` to `closing_price_list` at all places in the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests again. If there are any places where we forgot to rename the variable,
    then the tests will fail and we can fix it and run the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Tests as a safety net**'
  prefs: []
  type: TYPE_NORMAL
- en: Having a solid set of tests is critical before we do refactoring. This is because
    tests give us the confidence that we haven't broken anything during the refactoring.
    We will be running the tests multiple times during a refactoring as we proceed
    from step to step.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now apply the Rename Variable refactoring to our code. The `cpl` variable
    holds the list of the closing prices of the stock for the last eleven days. We
    should rename this to something more descriptive, like `closing_price`_list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick search and replace and the code now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Commenting Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let us look at the comments in the method. Generally speaking, comments
    are a code smell because they indicate that the code itself is not easy to read.
    Some comments, like the one in the code above, simply repeat what the code is
    doing. Often, we put in a comment like this because it is easier to do so rather
    than clean up the code. So, wherever we see comments, it is worthwhile exploring
    if a code cleanup might be required. The other problem with comments is that they
    can very easily go out of sync with the code. It is quite common that when we
    come back in the future to implement a new feature, we don't update the comments.
    It leads to a great deal of confusion when we try to understand code where the
    comments are not in sync with the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'not all comments are bad. Helpful comments explain *why* a certain piece of
    code has been written that way. This is the information that cannot be deduced
    by just reading the code. Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first example shows a comment that just repeats the code below it. There
    is no value added here by the comments. A cursory glance at the code will tell
    the reader exactly what the comment says.
  prefs: []
  type: TYPE_NORMAL
- en: The second example shows a much better comment. This comment doesn't repeat
    the code, but instead explains the rationale behind why this particular piece
    of code exists.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example, the hardcoded numbers have been replaced by constants.
    In this example, the code is self-explanatory, so we can get rid of the comment
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: The three examples show the ideal process for writing comments. First, we see
    if we can make the code clearer in such a way that we don't need comments. If
    that is not possible, then write a comment around why the code has been written
    in a particular way. If you are tempted to write a comment about what a piece
    of code does, then stop and think about refactoring the code instead.
  prefs: []
  type: TYPE_NORMAL
- en: Replace Magic Literals with Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous example, replacing hardcoded values with constants
    accomplishes two things: first, should we need to change the values, we can do
    it at a single place, and, second, the constants are more descriptive and help
    make the code more readable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for this refactoring is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the constant and replace one hardcoded value with the constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 and 3 until all values are replaced with the constant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our method uses the timespan for the long-term moving average and the short-term
    moving average in all the calculations. We can create constants to identify these
    two values like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the constants in our method like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the constants used in the calculation, we can also replace the return
    value with more descriptive `Enum` class. This is a new feature in Python 3.4
    that we can use here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While `Enum` is a part of the standard library in Python 3.4, it has also been
    backported to earlier versions of Python. Download and install the enum34 package
    from PyPy if you are using an older Python version.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first import `Enum` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We then create the enumeration class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can replace the return value with the enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this change, we can also remove the comments above the return values, as
    the constants are descriptive enough.
  prefs: []
  type: TYPE_NORMAL
- en: The Extract Method refactoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another way to make comments redundant is to take the code and put it in a
    method with a descriptive name. This also helps break down a long method into
    smaller methods that are easier to understand. The **Extract Method** refactoring
    is used for this purpose. The steps for the Extract Method refactoring are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the existing tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the variables in the code block that we want to refactor, that are
    also used before the code block. These variables will need to be passed into our
    method as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the variables in the code block that are used after the code block.
    These variables will be the return values from our method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method with a descriptive name that takes in the above variables as
    a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new method return the appropriate values that are needed after the
    code block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the code block into the method. Replace the lines with a call to the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us apply this refactoring to our method. This loop is used to create a
    list of closing prices for each of the previous eleven days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract this code into a separate method. Here are the steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create a new method called `_get_closing_price_list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes two parameters because those values are used in the loop.
    Currently they are local variables, but once we extract the loop into this method,
    we will need to pass those values to the method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We now cut the loop code from the main method and paste it into this new method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, the loop still refers to the `NUM_DAYS` constant that was a
    local variable. We need to change this to use the value from the parameter. We
    also make this method return the `closing_price_list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we put in a call to this method where the loop code originally was
    used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we run the tests to make sure we didn't break anything. They should all
    pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our code after refactoring looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Replace Calculation with Temporary Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now turn our attention to the conditional statements where we perform
    the checks for crossover.
  prefs: []
  type: TYPE_NORMAL
- en: The conditional is messy because we are doing many calculations and comparisons
    at the same time, which is hard to follow. We can clean this up by using temporary
    variables to store the calculation values and then using the variables in the
    conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: In this refactoring, we are not using the variables for any purpose other than
    just being able to give a name to the calculations, and thereby making the code
    easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we do this refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the calculation and assign it to a variable. Make the name of the variable
    explain the purpose of the calculation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the variable in the conditional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us extract the four calculations in our conditional into variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use these variables in the conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Extract Conditional to Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now turn our attention to the conditional. It isn't very clear as to
    what comparison is happening in the conditional. One way to handle this is to
    continue with the Replace Calculation with Temporary Variable refactoring above.
    Another option is to apply the **Extract Conditional to Method** refactoring.
    In this refactoring, we take the comparison and move it into its own method with
    a descriptive name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the steps for the refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the entire conditional and move it into a method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the method where the conditional was before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the conditional code that we currently have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First we apply the Replace Calculation with Temporary Variable refactoring
    and extract the moving average calculation into a named variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next the comparisons being made in the conditional can be extracted to methods
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We now call the method in the `if` statement, passing in our temporary variables
    as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the method looks like after the last few refactorings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The DRY principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important principles in writing good code is the DRY principle.
    **DRY** stands for **Don't Repeat Yourself**. If you ever find yourself writing
    the same (or similar) code in multiple places, there is a good chance that a refactoring
    will allow you to put that logic in once place and call it from each place that
    it is needed. It could be something as simple as moving the code into a function
    and calling the function from each place, or it could be a more complex refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at the conditionals that we just refactored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We can see that they are almost the same. The only difference being that the
    comparisons are the other way around. Is there a way we can eliminate this code
    duplication?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to change the order of the comparators in the first method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Except for parameter names, it is now identical to the second method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now merge both methods into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'and call this single method in both conditionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the order of the short and long term parameters are exchanged between
    the two calls. The first checks that the short term moving average crosses the
    long term moving average from down to up. The second checks that the long term
    moving average crosses the short term moving average from down to up—this is the
    same as checking that the short term crosses from above to below. By doing the
    same check in both cases (below to above) and exchanging the parameters, we are
    able to eliminate the duplication in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we have performed a number of local refactorings. These are refactorings
    such as moving code into or out of methods, pulling calculations into variables,
    and so on. These refactorings improve the readability of the code, but are mostly
    localized changes and don't affect the larger design.
  prefs: []
  type: TYPE_NORMAL
- en: From a design perspective, the most common reason that classes get cluttered
    is due to not following the **Single Responsibility Principle** (**SRP**). What
    this principle states is that a class should have a single, clear, coherent purpose.
    A class that tries to do too many different things is an indicator of a poor design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us review whether the `Stock` class meets this criterion. The core responsibilities
    of the class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping a history of price updates for a particular stock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the stock meets certain conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, the class is also performing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a list of closing prices per day (or, more generally, code for handling
    a time series)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the moving average for various points in time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latter two responsibilities should be offloaded to a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: Extract Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Extract Class** refactoring is used to take some functionality and move
    it into a separate class. This is easily the most commonly used design refactoring.
    It is an ideal refactoring to apply when we see that a class has become saddled
    with multiple responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what we want to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Move all code relating to managing a time series into a `TimeSeries` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move all code relating to moving averages into a `MovingAverage` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The steps for performing an Extract Class refactoring are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run all tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate the new class in the `__init__` scope, or pass it in as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move one method from the source class to the new class. If the code to be moved
    is not in a method, then extract it to a local method using the Extract Method
    refactoring first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change all local calls to call the method in the new class instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 3 to 5 for each piece of functionality to be moved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us now extract all the time series related functionality into a `TimeSeries`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a file called `timeseries.py` in the `stock_alerter` directory.
    We'll create our class here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create an empty `TimeSeries` class in `timeseries.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we''ve been using `price_history`, a list, to store the price history.
    We now want to store all this information in our `TimeSeries` class. We''ll make
    this transition step by step. The first step is to add an instance variable to
    the `Stock` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to import `TimeSeries` at the top of the file before making this change.
    Now we can migrate the update functionality into the `TimeSeries` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once migrated, we make a call to the new method in the `Stock` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we have just added the call to the timeseries, but we haven't removed
    the old call that updates `self.price_history`. This is because this list is still
    used directly in other places. By not removing this line yet, we don't break any
    functionality. All the tests still pass. Once we are done with the migration,
    we'll come back and remove this line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to change the price and `is_increasing_trend` methods to stop using
    `self.price_history` and start using the time series class. This is what they
    look like currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Our next step is to add a dictionary access method to `TimeSeries`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This enables us to change the `Stock.price` and `Stock.is_increasing_trend`
    methods to use the `TimeSeries` class instead of accessing `self.price_history`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We should run the tests again to check that the new implementation of `Stock.price`
    and `Stock.is_increasing_trend` still work as expected. All 21 tests should still
    be passing.
  prefs: []
  type: TYPE_NORMAL
- en: Move Method to Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one final place where `self.price_history` is used, and this is in
    the `_get_closing_price_list` method. Instead of replacing the usage of `self.price_history`,
    we are instead going to move the whole method into the `TimeSeries` class. This
    is the **Move Method to Class** refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this refactoring, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the method to the target class. If the method uses any instance variables,
    then we need to add them to the parameter list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace all calls to use the method in the other class, adding any new parameters
    that need to be passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some callers may not have a reference to the target class. In that case, we
    need to instantiate the object in the `__init__` scope or pass a reference to
    it as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the tests again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Usually, at the end of this refactoring, we need to do some further local refactoring
    in the target class. So, some of those extra parameters that were added might
    need to be moved elsewhere or changed. Some parameters might be added to the initializer
    and callers modified appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The following example will make this clearer. Let us start by moving the `_get_closing_price_list`
    method to the `TimeSeries` class. Since this will be a public method in the new
    class, we can drop the initial underscore in the name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice the extra `price_history` parameter that we added to this method. The
    original method used the `self.price_history` variable. Since this is an instance
    variable of the `Stock` class, it is not available in the `TimeSeries` class.
    To fix that, we pass in the `price_history` as a parameter and use this in the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call from the `Stock` class now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We run the tests at this point to validate that all the tests are still passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we verify that the tests are passing, we can now go back and remove the
    extra parameter that we added. The `TimeSeries` class has its own instance variable
    `self.series` that contains the price history. We can use this variable in the
    method and remove the extra parameter. The method now becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And the call becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests again to check that everything is working, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Oops! Looks like some of the tests are failing!
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that the updates stored in `self.price_history` use the `price`
    attribute to refer to the price, but the `timeseries` module calls it value. So,
    we need to change the places where we calculate the moving average and replace
    price with value. With that change, the tests pass again and our moving average
    calculation now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The above code is the same as before except that we now use `update.value` instead
    of `update.price`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `price_history` is no longer used anywhere in the `Stock` class, so we
    can remove it from the class. We can also remove the `PriceEvent` named tuple
    as well as any unused imports. The initializer and update method after those changes
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: With this change, our Extract Class refactoring is complete.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Extract Class refactoring shows the importance of having a good unit test
    suite as well as running it frequently during the refactoring. It is easy to overlook
    small things when moving code around, which could end up breaking the code. By
    running the tests often, we know immediately when we break something. This makes
    it easy to fix the mistake. Had we done the whole refactoring before running the
    tests, it would have not been clear which step in the refactoring broke the tests,
    and we would have to go back and debug the whole refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing that we need to do is to adjust the tests after the refactoring
    is complete. In some refactorings, such as Extract Class, we may find that we
    have to also move tests to the new class. For instance, if we had any tests for
    the `_get_closing_price_list` method, then we would move those tests over to the
    `TimeSeries` class. In this case, since the method was not public, we didn't write
    tests for them and we didn't have anything to move.
  prefs: []
  type: TYPE_NORMAL
- en: After the refactoring, that method has become a public method on the `TimeSeries`
    class, and it currently doesn't have any tests. It is a good idea to go back and
    write some tests for the method.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we extracted the time series code into its own class, we can also extract
    the moving average code into a separate class. Try doing this refactoring as an
    exercise. Once you are done, check out the Appendix for a walkthrough of one possible
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the algorithm for calculating the DMAC in pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the short term and long term moving averages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the short term crosses the long term from bottom to top, then *buy*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the long term crosses the short term from bottom to top, then *sell*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise do nothing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the code we started with, which passed all the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After the moving average code is extracted into its own class (see the exercise
    above to try this, or the [Appendix A](apa.html "Appendix A. Answers to Exercises"),
    *Answers to Exercises* to see one solution of how we got here), this is what the
    `get_crossover_signal` method looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The difference is clear. The refactored code reads just like the pseudocode
    above, with an almost 1:1 correspondence. A person who knows the algorithm will
    instantly know what this method is doing. We don't need to write a line of comments
    to make this readable. We cannot say the same for the code we started with.
  prefs: []
  type: TYPE_NORMAL
- en: The new code is only 9 statements long and delegates all the non-core functionality
    to the `TimeSeries` and `MovingAverage` classes. These classes are themselves
    quite short, and easy to understand. Overall, the refactoring has made a huge
    improvement in the quality of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The best part? We made small changes and always had the tests as a safety net
    so we were sure we didn't break anything. Without the tests, we could not have
    undertaken these refactorings—the risk of breaking code is just too large. In
    fact, while writing the code that you see in this chapter, I did break the tests
    several times. Fortunately the tests were there and the errors were fixed in minutes.
  prefs: []
  type: TYPE_NORMAL
- en: One might ask about the time taken to perform all the refactorings we have gone
    through so far. This chapter looks quite huge and intimidating, but once we are
    comfortable with the techniques, it would take only about 30 to 60 minutes to
    perform all these refactorings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you looked at some of the most common code smells as well as
    the most common refactorings to fix them. You saw, step by step, how to perform
    each of the refactorings on our project and how having a good test suite enables
    us to perform such refactorings with confidence. Test-driven development and refactoring
    go hand in hand and are invaluable tools in any developer's toolbox. In the next
    chapter, we will take a look at testing code interactions using mock objects.
  prefs: []
  type: TYPE_NORMAL
