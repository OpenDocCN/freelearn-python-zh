<html><head></head><body>
		<div><h1 id="_idParaDest-616" class="chapter-number"><a id="_idTextAnchor697"/>13</h1>
			<h1 id="_idParaDest-617"><a id="_idTextAnchor698"/>Web Server Development</h1>
			<p>We’ll introduce the basics of the web server part of Odoo in this chapter. Note that this will cover the fundamental aspects; for high-level functionality, you should refer to <a href="B20997_14.xhtml#_idTextAnchor734"><em class="italic">Chapter 14</em></a>, <em class="italic">CMS </em><em class="italic">Website Development</em>.</p>
			<p>The Odoo web server is a crucial component of the Odoo framework, responsible for handling web requests and serving the web interface to users.</p>
			<p>Here are key <a id="_idIndexMarker904"/>aspects of the Odoo web server:</p>
			<ul>
				<li><strong class="bold">The web interface and modules</strong>: The web server provides a user-friendly web interface <a id="_idIndexMarker905"/>to access and interact with Odoo applications. Users <a id="_idIndexMarker906"/>can navigate through different modules, access data, and perform various business operations using this interface.</li>
				<li><strong class="bold">An HTTP server</strong>: Odoo uses <a id="_idIndexMarker907"/>an HTTP server to handle web requests. It can be configured to work with popular web servers such as Nginx or Apache or can run its own built-in HTTP server.</li>
				<li><strong class="bold">Werkzeug</strong>: Werkzeug is <a id="_idIndexMarker908"/>a <strong class="bold">WSGI</strong> (<strong class="bold">Web Server Gateway Interface</strong>) library for <a id="_idIndexMarker909"/>Python, and Odoo uses it to handle HTTP requests and responses. Werkzeug helps in routing requests, handling sessions, and managing other web-related tasks.</li>
				<li><strong class="bold">Controllers and routing</strong>: Odoo uses <a id="_idIndexMarker910"/>controllers to handle different web <a id="_idIndexMarker911"/>requests and routes them to the appropriate controllers and methods. The routing mechanism ensures that requests are directed to the correct modules and functionalities.</li>
				<li><strong class="bold">Views and templates</strong>: Odoo uses <a id="_idIndexMarker912"/>views and templates to define how data should be presented in the web interface. Views determine the structure of pages, and templates provide the HTML and presentation logic to render data.</li>
				<li><strong class="bold">Business logic</strong>: The web server is tightly integrated with the business logic of Odoo. It communicates <a id="_idIndexMarker913"/>with the backend to fetch and update data, ensuring that the web interface reflects the most current state of the business applications.</li>
				<li><strong class="bold">Security</strong>: Security is a critical aspect of the Odoo web server. It includes features such <a id="_idIndexMarker914"/>as authentication, authorization, and session management to ensure that users have appropriate access levels and that their interactions with the system are secure.</li>
				<li><strong class="bold">JavaScript and CSS</strong>: The Odoo web interface relies on JavaScript and CSS to enhance user <a id="_idIndexMarker915"/>experience and provide dynamic and responsive features. This includes <a id="_idIndexMarker916"/>form validation, interactive elements, and real-time updates.</li>
				<li><strong class="bold">A RESTful API</strong>: The web <a id="_idIndexMarker917"/>server also provides a RESTful API, allowing external applications to interact with Odoo programmatically. This enables integration with third-party systems and the development of custom applications.</li>
				<li><strong class="bold">Customization and extensions</strong>: Developers can extend and customize the Odoo web <a id="_idIndexMarker918"/>server to meet specific business requirements. This includes creating custom modules, views, and controllers.</li>
			</ul>
			<p>Understanding the Odoo web server is essential for developers and administrators working with Odoo to deploy, configure, and customize the system based on the unique needs of a business.</p>
			<p>Werkzeug (<a href="https://werkzeug.palletsprojects.com/en/2.3.x">https://werkzeug.palletsprojects.com/en/2.3.x</a>) is a WSGI library for Python and is <a id="_idIndexMarker919"/>used by Odoo to handle HTTP requests and responses. WSGI is a specification for how web servers and web applications communicate in Python. Werkzeug provides a set of utilities and classes that make it easier to work with WSGI applications. Here are some details about how Werkzeug is used in the context of Odoo:</p>
			<ul>
				<li><code>Request</code> object that represents an incoming HTTP request. In Odoo, this object is used to extract information from the incoming HTTP request, such as form data, query parameters, and headers.</li>
				<li><code>Response</code> object in Werkzeug is used to create HTTP responses. Odoo <a id="_idIndexMarker921"/>utilizes this to construct and send responses back to the client, including rendering web pages or providing data in response to AJAX requests.</li>
				<li><strong class="bold">Routing</strong>: Werkzeug enables easy URL routing. In Odoo, the routing mechanism is used to map <a id="_idIndexMarker922"/>incoming requests to the appropriate controller methods or views. This helps in directing requests to the correct functionality within the Odoo application.</li>
				<li><strong class="bold">Middleware</strong>: Middleware components can be added to the Odoo application using Werkzeug. Middleware <a id="_idIndexMarker923"/>sits between the web server and the Odoo application and can perform tasks such as authentication, logging, or modifying requests and responses.</li>
				<li><strong class="bold">URL building</strong>: Werkzeug provides a URL building facility that helps to generate URLs for different <a id="_idIndexMarker924"/>routes within the Odoo application. This is essential for creating links and redirects dynamically in the web interface.</li>
				<li><strong class="bold">Session management</strong>: Werkzeug supports session management, which Odoo utilizes <a id="_idIndexMarker925"/>to handle user sessions. This is important for maintaining user state across multiple requests and ensuring security features such as user authentication.</li>
				<li><strong class="bold">Utilities for common tasks</strong>: Werkzeug includes various utilities that simplify common <a id="_idIndexMarker926"/>web development tasks. Odoo leverages these utilities for tasks such as parsing form data, handling file uploads, and managing cookies.</li>
				<li><strong class="bold">Error handling</strong>: Werkzeug provides mechanisms to handle errors, including HTTP error <a id="_idIndexMarker927"/>responses. Odoo uses this to ensure that appropriate error messages are returned to the client when needed.</li>
			</ul>
			<p>To work with Werkzeug in the context of Odoo, developers often interact with these features through the controllers and views defined in Odoo modules. Understanding Werkzeug is beneficial for developers who want to extend or customize Odoo, as it provides insights into the underlying mechanisms to handle HTTP requests and responses within the application. However, in day-to-day Odoo development, developers often work at a higher level using the Odoo framework itself, without directly interacting with Werkzeug.</p>
			<p>In this chapter, we’ll cover the following topics:</p>
			<ul>
				<li>Making a path accessible from a network</li>
				<li>Restricting access to web-accessible paths</li>
				<li>Consuming parameters passed to your handlers</li>
				<li>Modifying an existing handler</li>
				<li>Serving static</li>
			</ul>
			<h1 id="_idParaDest-618"><a id="_idTextAnchor699"/>Technical requirements</h1>
			<p>The technical requirements for this chapter include the online Odoo platform.</p>
			<p>All the code used in this chapter can be downloaded from the GitHub repository at <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13</a>.</p>
			<h2 id="_idParaDest-619"><a id="_idTextAnchor700"/>Making a path accessible from a network</h2>
			<p>Making a path accessible from a network means defining the entry points or URLs through which <a id="_idIndexMarker928"/>users can access the application. This is fundamental to any web development project, as it determines how users will interact with the system. In this recipe, we’ll look at how to make a URL of the <a href="http://yourserver/path1/path2">http://yourserver/path1/path2</a> form accessible to users. This can be either a web page or a path returning arbitrary data to be consumed by other programs. In the latter case, you would usually use the JSON format to consume paramet<a id="_idTextAnchor701"/>ers and offer your data.</p>
			<h2 id="_idParaDest-620"><a id="_idTextAnchor702"/>Getting ready</h2>
			<p>We’ll make use of the <code>hostel.student</code> model, which we looked at in <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>; therefore, if you haven’t done so yet, grab the initial module from <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13/00_initial_module">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13/00_initial_module</a> so that you will be able to follow the examples.</p>
			<p>We want to allow <a id="_idIndexMarker929"/>any user to query the full list of students in the hostel. Furthermore, we want to provide the same information to programs through a JSON request. Let’<a id="_idTextAnchor703"/>s check out how to do it.</p>
			<h2 id="_idParaDest-621"><a id="_idTextAnchor704"/>How to do it...</h2>
			<p>We’ll need to add controllers, which go into a folder called <code>controllers</code> by convention:</p>
			<ol>
				<li>Add a <code>controllers/main.py</code> file with the HTML version of our page, as follows:<pre class="source-code">
from odoo import http
from odoo.http import request
    class Main(http.Controller):
        @http.route('/my_hostel/students', type='http', auth='none')
    def students(self):
        students = request.env['hostel.student'].sudo().search([])
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>				<li>Add a function <a id="_idIndexMarker930"/>to serve the same information in the JSON format, as shown in the following example:<pre class="source-code">
@http.route('/my_hostel/students/json', type='json', auth='none')
    def students_json(self):
        records = request.env['hostel.student'].sudo().search([])
        return records.read(['name'])</pre></li>				<li>Add the <code>controllers/__init__.py</code> file, as follows:<pre class="source-code">
from . import main</pre></li>				<li>Import <code>controllers</code> into your <code>my_hostel/__init__.py</code> file, as follows:<pre class="source-code">
from . import controllers</pre></li>			</ol>
			<p>After restarting your server, you can visit <code>/my_hostel/students</code> in your browser, and you’ll be presented with a flat list of the student names.</p>
			<div><div><img src="img/B20997_13_1.jpg" alt="Figure 13.1 – A list of students"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – A list of students</p>
			<p>To test the JSON-RPC part, you’ll have to craft a JSON request. A simple way to do that is by using the <a id="_idIndexMarker931"/>following command to receive the output on the command line:</p>
			<pre class="console">
curl -i -X POST -H "Content-Type: application/json" -d "{}"
localhost:8069/my_hostel/students/json</pre>			<p>If you get <code>404</code> errors at this point, you probably have more than one database available on your instance. If so, it’s impossible for Odoo to determine which database is meant to serve the request.</p>
			<p>Use the <code>--db-filter='^yourdatabasename$'</code> parameter to force Odoo to use the exact database you installed the module in. The path should now be accessible.</p>
			<h2 id="_idParaDest-622"><a id="_idTextAnchor705"/>How it works...</h2>
			<p>The two crucial <a id="_idIndexMarker932"/>parts here are that our controller is derived from <code>odoo.http.Controller</code>, and the methods we use to serve content are decorated with <code>odoo.http.route</code>. Inheriting from <code>odoo.http.Controller</code> registers the controller with Odoo’s routing system in a similar way to how the models are registered – by inheriting from <code>odoo.models.Model</code>. Also, <code>Controller</code> has a metaclass that takes care of this.</p>
			<div><div><img src="img/B20997_13_2.jpg" alt="Figure 13.2 – A diagram of controllers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – A diagram of controllers</p>
			<p>In general, paths handled by your add-on should start with your add-on’s name, to avoid name clashes. Of course, if you extend some of the add-on’s functionality, you’<a id="_idTextAnchor706"/>ll use this add-on’s name.</p>
			<h3>odoo.http.route</h3>
			<p>The <code>route</code> decorator allows us to tell Odoo that a method should be web-accessible in the first place, and the <a id="_idIndexMarker933"/>first parameter determines on which path it is accessible. Instead of a string, you can also pass a list of strings, if you use the same function to serve multiple paths.</p>
			<p>The <code>type</code> argument defaults to <code>http</code> and determines what type of request will be served. While, strictly speaking, JSON is HTTP, declaring the second function as <code>type='json'</code> makes life a lot easier because Odoo then handles type conversions for us.</p>
			<p>Don’t worry about the <code>auth</code> parameter for now; it will be addressed in the <em class="italic">Restricting access to web-accessible paths</em> recipe in this chapter.</p>
			<h3>Return values</h3>
			<p>Odoo’s treatment <a id="_idIndexMarker934"/>of the functions’ return values is determined by the <code>type</code> argument of the <code>route</code> decorator. For <code>type='http'</code>, we usually want to deliver some HTML, so the first function simply returns a string containing it. An alternative is to use <code>request.make_response()</code>, which gives you control over the headers to send in the response. So, to indicate when our page was last updated, we might change the last line in <code>students()</code> to the following code:</p>
			<pre class="source-code">
return request.make_response(
  html_result, headers=[
    ('Last-modified', email.utils.formatdate(
      (
        fields.Datetime.from_string(
        request.env['hostel.student'].sudo()
        .search([], order='write_date desc', limit=1)
        .write_date) -
        datetime.datetime(1970, 1, 1)
      ).total_seconds(),
      usegmt=True)),
])</pre>			<p>This code sends a <code>Last-modified</code> header along with the HTML we generated, telling the browser when the list was modified for the last time. We can extract this information from the <code>write_date</code> field of the <code>hostel.student</code> model.</p>
			<p>In order for the preceding <a id="_idIndexMarker935"/>snippet to work, you’ll have to add some imports at the top of the file, as follows:</p>
			<pre class="source-code">
import email
import datetime
from odoo import fields</pre>			<p>You can also create a <code>Response</code> object of <code>werkzeug</code> manually and return that, but there’s little to gain for the effort.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout">Generating HTML manually is nice for demonstration purposes, but you should never do this in production code. Always use templates, as demonstrated in the <em class="italic">Creating or modifying templates – QWeb</em> recipe in <a href="B20997_15.xhtml#_idTextAnchor861"><em class="italic">Chapter 15</em></a>, <em class="italic">Web Client Development</em>, and return them by calling <code>request.render()</code>. This will give you localization for free and will make your code better by separating business logic from the presentation layer. Also, templates provide you with functions to escape data before outputting HTML. The preceding code is vulnerable to cross-site scripting attacks (if a user manages to slip a <code>script</code> tag into the book name, for example).</p>
			<p>For a JSON request, simply return the data structure you want to hand over to the client; Odoo takes care of serialization. For this to work, you should restrict yourself to data types that are JSON-serializable, which generally means dictionaries, lists, strings, floats, and integers.</p>
			<h3>odoo.http.request</h3>
			<p>The <code>request</code> object is a static object referring to the currently handled request, which contains everything you <a id="_idIndexMarker936"/>need in order to take action. The most important aspect here is the <code>request.env</code> property, which contains an <code>Environment</code> object that is just the same as <code>self.env</code> for models. This environment is bound to the current user, which is not in the preceding example, because we used <code>auth='none'</code>. The lack of a user is also why we have to <code>sudo()</code> all our calls to model methods in the example code.</p>
			<p>If you’re used to web development, you’ll expect session handling, which is perfectly correct. Use <code>request.session</code> for an <code>OpenERPSession</code> object (which is quite a thin wrapper around the <code>Session</code> object of <code>werkzeug</code>) and <code>request.session.sid</code> to access the session ID. To store session values, just treat <code>request.session</code> as a dictionary, as shown in the following example:</p>
			<pre class="source-code">
request.session['hello'] = 'world'
request.session.get('hello')</pre>			<p class="callout-heading">Important note</p>
			<p class="callout">Note that storing data in the session is no different from using global variables. Only do so if you must. This is usually the case for multi-request actions, such as a checkout in the <code>website_sale</code> module.</p>
			<h2 id="_idParaDest-623"><a id="_idTextAnchor707"/>There’s more...</h2>
			<p>The <code>route</code> decorator can have <a id="_idIndexMarker937"/>some extra parameters in order to customize its behavior further. By default, all HTTP methods are allowed, and Odoo intermingles the <a id="_idIndexMarker938"/>parameters passed. Using the <code>methods</code> parameter, you can pass a list of methods to accept, which would usually be one of either <code>['GET']</code> or <code>['POST']</code>.</p>
			<p>To allow cross-origin requests (browsers block AJAX and some other types of requests to domains other <a id="_idIndexMarker939"/>than where the script was loaded from, for security and privacy reasons), set the <code>cors</code> parameter to <code>*</code> to allow requests from all origins, or a URI to restrict requests to ones originating from that URI. If this parameter is unset, which is the default, the <code>Access-Control-Allow-Origin</code> header is not set, leaving you with the browser’s standard behavior. In our example, we might want to set it on</p>
			<p><code>/my_module/students/json</code> in order to allow scripts pulled from other websites to access the list of students.</p>
			<p>By default, Odoo protects certain types of requests from an attack known as cross-site request forgery, by passing a token along on every request. If you want to turn that off, set the <code>csrf</code> parameter to <code>False</code>, but note that this is a bad idea, in general.</p>
			<h2 id="_idParaDest-624"><a id="_idTextAnchor708"/>See also</h2>
			<p>Refer to the <a id="_idIndexMarker940"/>following points to learn more about the HTTP routes:</p>
			<ul>
				<li>If you host multiple Odoo databases on the same instance, then different databases might be running on different domains. If so, you can use the <code>--db-filter</code> options, or you can use the <code>dbfilter_from_header</code> module from <a href="https://github.com/OCA/server-tools">https://github.com/OCA/server-tools</a>, which helps you filter databases based on the domain.</li>
				<li>To see how using templates makes modularity possible, check out the <em class="italic">Modifying an existing handler</em> recipe later in the chapter.</li>
			</ul>
			<h1 id="_idParaDest-625"><a id="_idTextAnchor709"/>Restricting access to web-accessible paths</h1>
			<p>As an Odoo developer, one of your primary concerns is ensuring the security of the application. Restricting <a id="_idIndexMarker941"/>access to web-accessible paths is a crucial aspect of access control. It involves determining who can or cannot access specific routes or functionalities within the Odoo application. Odoo provides different authentication mechanisms to control user access. Understanding and implementing these mechanisms is essential for ensuring that only authorized users can interact with sensitive or protected parts of the application. For instance, you might want to restrict certain routes to authenticated users only.</p>
			<p>We’ll explore the three authentication mechanisms Odoo provides for routes in this recipe. We’ll define routes with different authentication mechanisms in order to show their differences.</p>
			<h2 id="_idParaDest-626"><a id="_idTextAnchor710"/>Getting ready</h2>
			<p>As we extend the code from the previous recipe, we’ll also depend on the <code>hostel.student</code> model of <a href="B20997_04.xhtml#_idTextAnchor118"><em class="italic">Chapter 4</em></a>, <em class="italic">Application Models</em>, so you should ret<a id="_idTextAnchor711"/>rieve its code in order to proceed.</p>
			<h2 id="_idParaDest-627"><a id="_idTextAnchor712"/>How to do it...</h2>
			<p>Define the handlers in <code>controllers/main.py</code>:</p>
			<ol>
				<li>Add a path <a id="_idIndexMarker942"/>that shows all the students, as shown in the following example:<pre class="source-code">
    @http.route('/my_hostel/all-students', type='http', auth='none')
    def all_students(self):
        students = request.env['hostel.student'].sudo().search([])
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>				<li>Add a path that shows all the students and indicates which ones belong to the current user, if any. This is shown in the following example:<pre class="source-code">
@http.route('/my_hostel/all-students/mark-mine', type='http', auth='public')
    def all_students_mark_mine(self):
        students = request.env['hostel.student'].sudo().search([])
        hostels = request.env['hostel.hostel'].sudo().search([('rector', '=', request.env.user.partner_id.id)])
        hostel_rooms = request.env['hostel.room'].sudo().search([('hostel_id', 'in', hostels.ids)])
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            if student.id in hostel_rooms.student_ids.ids:
                html_result += "&lt;li&gt; &lt;b&gt;%s&lt;/b&gt; &lt;/li&gt;" % student.name
            else:
                html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>				<li>Add a path <a id="_idIndexMarker943"/>that shows the current user’s students, as follows:<pre class="source-code">
@http.route('/my_hostel/all-students/mine', type='http', auth='user')
    def all_students_mine(self):
        hostels = request.env['hostel.hostel'].sudo().search([('rector', '=', request.env.user.partner_id.id)])
        students = request.env['hostel.room'].sudo().search([('hostel_id', 'in', hostels.ids)]).student_ids
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>			</ol>
			<p>With this code, the <code>/my_hostel/all-students</code> and <code>/my_hostel/all-students/mark-mine</code> paths look the same for unauthenticated users, while a logged-in user <a id="_idIndexMarker944"/>sees their students in a bold font on the latter path.</p>
			<div><div><img src="img/B20997_13_3.jpg" alt="Figure 13.3 – Mark as mine students – with login"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Mark as mine students – with login</p>
			<p>The following screenshot shows the results without login:</p>
			<div><div><img src="img/B20997_13_4.jpg" alt="Figure 13.4 – Mark as mine students – without login"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Mark as mine students – without login</p>
			<p>The <code>/my_hostel/all-students/mine</code> path is not accessible at all for unauthenticated <a id="_idIndexMarker945"/>users. If you try to access it without being authenticated, you’ll be redirected to the login screen in order to do so.</p>
			<div><div><img src="img/B20997_13_5.jpg" alt="Figure 13.5 – Access via unauthenticated users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Access via unauthenticated users</p>
			<h2 id="_idParaDest-628"><a id="_idTextAnchor713"/>How it works...</h2>
			<p>The difference between authentication methods is basically what you can expect from the content of <code>request.env.user</code>.</p>
			<p>For <code>auth='none'</code>, the user record is always empty, even if an authenticated user accesses the path. Use this if you want to serve content that has no dependencies on users, or if you <a id="_idIndexMarker946"/>want to provide database-agnostic functionality in a server-wide module.</p>
			<p>The <code>auth='public'</code> value sets the user record as a special user with an XML ID of <code>base.public_user</code> for unauthenticated users, and to the user’s record for authenticated ones. This is the right choice if you want to offer functionality to both unauthenticated and authenticated users, while the authenticated ones get some extras, as demonstrated in the preceding code.</p>
			<p>Use <code>auth='user'</code> to ensure that only authenticated users have access to what you’ve got to offer. With this method, you can be sure that <code>request<a id="_idTextAnchor714"/>.env.user</code> points to an existing user.</p>
			<h2 id="_idParaDest-629"><a id="_idTextAnchor715"/>There’s more...</h2>
			<p>The magic of authentication methods happens in the <code>ir.http</code> model from the base add-on. For whatever value you pass to the <code>auth</code> parameter in your route, Odoo searches for <a id="_idIndexMarker947"/>a function called <code>_auth_method_&lt;yourvalue&gt;</code> on this model, so you can easily customize it by inheriting it and declaring a method that takes care of your authentication method of choice.</p>
			<p>As an example, we will <a id="_idIndexMarker948"/>provide an authentication method called <code>base_group_user</code>, which will only authorize the user if the currently logged-in user is part of the <code>base.group_user</code> group, as shown in the following example:</p>
			<pre class="source-code">
from odoo import exceptions, http, models
from odoo.http import request
class IrHttp(models.Model):
  _inherit = 'ir.http'
  def _auth_method_base_group_user(self):
    self._auth_method_user()
    if not request.env.user.has_group('base.group_user'):
      raise exceptions.AccessDenied()</pre>			<p>Now, you can say <code>auth='base_group_user'</code> in your decorator and be sure that users running <a id="_idIndexMarker949"/>this route’s handler are members of the group. With a little trickery, you can extend this to <code>auth='groups(xmlid1,...)'</code>; its implementation is left as an exercise for you but is included in the GitHub repository example code at <code>Chapter13/02_paths_auth/my_hostel/models/sample_auth_http.py</code>.</p>
			<h1 id="_idParaDest-630"><a id="_idTextAnchor716"/>Consuming parameters passed to your handlers</h1>
			<p>It’s nice to be able to show content, but it’s better to show content as a result of user input. This <a id="_idIndexMarker950"/>recipe will demonstrate the different ways to receive this input and react to it. As in the previous recipes, we’ll make use of the <code>hostel.student</code> model.</p>
			<h2 id="_idParaDest-631"><a id="_idTextAnchor717"/>How to do it...</h2>
			<p>First, we’ll add a route that expects a traditional parameter with a student’s ID to show some details about them. Then, we’ll do the same again, but we’ll incorporate our parameter into the path itself:</p>
			<ol>
				<li>Add a path that expects a student’s ID as a parameter, as shown in the following example:<pre class="source-code">
        @http.route('/my_hostel/student_details', type='http', auth='none')
        def student_details(self, student_id):
                record = request.env['hostel.student'].sudo().browse(int(student_id))
                return u'&lt;html&gt;&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;Room No: %s' % (
                        record.name, str(record.room_id.room_no) or 'none')</pre></li>				<li>Add a path where we can pass the student’s ID in the path, as follows:<pre class="source-code">
@http.route("/my_hostel/student_details/&lt;model('hostel.student'):student&gt;",
            type='http', auth='none')
    def student_details_in_path(self, book):
        return self.student_details(student.id)</pre></li>			</ol>
			<p>If you point <a id="_idIndexMarker951"/>your browser to <code>/my_hostel/student_details?student_id=1</code>, you should see a detailed page of the student with ID 1.</p>
			<div><div><img src="img/B20997_13_6.jpg" alt="Figure 13.6 – The student details web page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – The student details web page</p>
			<p>If this doesn’t exist, you’ll receive an error page.</p>
			<div><div><img src="img/B20997_13_7.jpg" alt="Figure 13.7 – The student not found:Error page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – The student not found:Error page</p>
			<h2 id="_idParaDest-632"><a id="_idTextAnchor718"/>How it works...</h2>
			<p>By default, Odoo (actually, <code>werkzeug</code>) intermingles the <code>GET</code> and <code>POST</code> parameters and passes them as keyword arguments to your handler. So, by simply declaring your function as expecting <a id="_idIndexMarker952"/>a parameter called <code>student_id</code>, you introduce this parameter as either <code>GET</code> (the parameter in the URL) or <code>POST</code> (usually passed by the <code>&lt;form&gt;</code> element with your handler as the <code>action</code> attribute). Given that we didn’t add a default value for this parameter, the runtime will raise an error if you try to access this path without setting the parameter.</p>
			<p>The second example makes use of the fact that, in a <code>werkzeug</code> environment, most paths are virtual anyway. So, we can simply define our path as containing some input. In this case, we say that we expect the ID of a <code>hostel.student</code> instance as the last component of the path. The name after the colon is the name of a keyword argument. Our function will be called, with this parameter passed as a keyword argument. Here, Odoo takes care of looking up this ID and delivering a browse record, which, of course, only works if the user accessing this path has appropriate permissions. Given that <code>student</code> is a browse record, we can simply recycle the first example’s function by passing <code>student.id</code> as a <code>student_id</code> parameter, outputing the same content.</p>
			<h2 id="_idParaDest-633"><a id="_idTextAnchor719"/>There’s more...</h2>
			<p>Defining parameters <a id="_idIndexMarker953"/>within a path is a functionality delivered by <code>werkzeug</code>, called <code>converters</code>. The <code>model</code> converter is added by Odoo, which also defines the converter models that accept a comma-separated list of IDs and pass a recordset containing those IDs to your handler.</p>
			<p>The beauty of converters is that the runtime coerces parameters to the expected type, whereas you’re on your <a id="_idIndexMarker954"/>own with normal keyword parameters. These are delivered as strings, and you have to take care of the necessary type conversions yourself, as seen in the first example.</p>
			<p>Built-in <code>werkzeug</code> converters include not only <code>int</code>, <code>float</code>, and <code>string</code> but also more intricate ones, such as <code>path</code>, <code>any</code>, and <code>uuid</code>. You can look up their semantics at <a href="https://werkzeug.palletsprojects.com/en/2.3.x/">https://werkzeug.palletsprojects.com/en/2.3.x/</a>.</p>
			<h2 id="_idParaDest-634"><a id="_idTextAnchor721"/>See also</h2>
			<p>If you want to learn more about the HTTP routes, refer to the following points:</p>
			<ul>
				<li>Odoo’s custom converters are defined in <code>ir_http.py</code> in the base module and registered in the <code>_get_converters</code> class method of <code>ir.http</code></li>
				<li>If you want to learn more about the form submission on the route, refer to the <em class="italic">Getting input from users</em> recipe from <a href="B20997_14.xhtml#_idTextAnchor734"><em class="italic">Chapter 14</em></a>, <em class="italic">CMS </em><em class="italic">Website Development</em></li>
			</ul>
			<h1 id="_idParaDest-635"><a id="_idTextAnchor722"/>Modifying an existing handler</h1>
			<p>When you install <a id="_idIndexMarker955"/>the website module, the <code>/website/info</code> path displays some information about your Odoo instance. In this recipe, we will override this in order to change this information page’s layout, as well as to change what is displayed.</p>
			<h2 id="_idParaDest-636"><a id="_idTextAnchor723"/>Getting ready</h2>
			<p>Install the <code>website</code> module and inspect the /<code>website/info</code> path. In this recipe, we will update the <code>/website/info</code> route to provide more information.</p>
			<h2 id="_idParaDest-637"><a id="_idTextAnchor724"/>How to do it...</h2>
			<p>We’ll have to <a id="_idIndexMarker956"/>adapt the existing template and override the existing handler. We can do this as follows:</p>
			<ol>
				<li>Override the <code>qweb</code> template in a file called <code>views/templates.xml</code>, as follows:<pre class="source-code">
&lt;?xml version="1.0"?&gt;
&lt;odoo&gt;
  &lt;template id="show_website_info"
            inherit_id="website.show_website_info"&gt;
   &lt;xpath expr="//dl[@t-foreach='apps']" position="replace"&gt;
            &lt;table class="table"&gt;
                &lt;tr t-foreach="apps" t-as="app"&gt;
                    &lt;th&gt;
                        &lt;a t-att-href="app.website" groups='base.group_no_one'&gt;
                            &lt;t t-out="app.name" /&gt;
                        &lt;/a&gt;
                    &lt;/th&gt;
                    &lt;td&gt;
                        &lt;span t-out="app.summary" /&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/xpath&gt;
  &lt;/template&gt;
&lt;/odoo&gt;</pre></li>				<li>Override the <a id="_idIndexMarker957"/>handler in a file called <code>controllers/main.py</code>, as shown in the following example:<pre class="source-code">
from odoo import http
from odoo.addons.website.controllers.main import Website
class WebsiteInfo(Website):
    @http.route()
    def website_info(self):
        result = super(WebsiteInfo, self).website_info()
        result.qcontext['apps'] = result.qcontext['apps'].filtered(
            lambda x: x.name != 'website'
        )
        return result</pre></li>				<li>Now, when visiting the info page, we’ll only see a filtered list of installed applications in a table, as opposed to the original definition list.</li>
			</ol>
			<div><div><img src="img/B20997_13_8.jpg" alt="Figure 13.8 – The website info page (original)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – The website info page (original)</p>
			<p>The following <a id="_idIndexMarker958"/>screenshot shows the customized page:</p>
			<div><div><img src="img/B20997_13_9.jpg" alt="Figure 13.9 – The website info page (customized)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – The website info page (customized)</p>
			<h2 id="_idParaDest-638"><a id="_idTextAnchor725"/>How it works…</h2>
			<p>In the first step, we overrode an existing QWeb template. In order to find out which one it is, you’ll have to consult the code of the original handler. Usually, this will give you something similar to the following line, which tells you that you need to override <code>template.name</code>:</p>
			<pre class="source-code">
return request.render('template.name', values)</pre>			<p>In our case, the handler used a template called <code>website_info</code>, but this one was immediately extended by another template called <code>website.show_website_info</code>, so it’s more convenient to override this one. Here, we replaced the definition list showing installed apps with a table. For details on how QWeb inheritance works, consult <a href="B20997_15.xhtml#_idTextAnchor861"><em class="italic">Chapter 15</em></a>, <em class="italic">Web </em><em class="italic">Client Development</em>.</p>
			<p>In order to override the handler method, we must identify the class that defines the handler, which is <code>odoo.addons.website.controllers.main.Website</code> in this case. We need to import the class to be able to inherit from it. Now, we can override the method and change the data passed to the response. Note that what the overridden handler <a id="_idIndexMarker959"/>returns here is a <code>Response</code> object and not a string of HTML, as the previous recipes did, for the sake of brevity. This object contains a reference to the template to be used and the values accessible to the template, but it is only evaluated at the very end of the request.</p>
			<p>In general, there are three ways to change an existing handler:</p>
			<ul>
				<li>If it uses a QWeb template, the simplest way to change it is to override the template. This is the right choice for layout changes and small logic changes.</li>
				<li>QWeb templates get a context passed, which is available in the response as the <code>qcontext</code> member. This is usually a dictionary where you can add or remove values to suit your needs. In the preceding example, we filtered the list of apps to the website only.</li>
				<li>If the handler receives parameters, you can also preprocess those in order to make the overridden handler behave in the way you want.</li>
			</ul>
			<h2 id="_idParaDest-639"><a id="_idTextAnchor726"/>There’s more...</h2>
			<p>As seen in the preceding section, inheritance with controllers works slightly differently than model inheritance; you actually need a reference to the base class and to use Python inheritance on it.</p>
			<p>Don’t forget to decorate your new handler with the <code>@http.route</code> decorator; Odoo uses it as a marker, for which methods are exposed to the network layer. If you omit the decorator, you actually make the handler’s path inaccessible.</p>
			<p>The <code>@http.route</code> decorator itself behaves similarly to field declarations – every value you don’t set <a id="_idIndexMarker960"/>will be derived from the decorator of the function you’re overriding, so we don’t have to repeat values we don’t want to change.</p>
			<p>After receiving a <code>response</code> object from the function you override, you can do a lot more than just change the QWeb context:</p>
			<ul>
				<li>You can add or remove HTTP headers by manipulating <code>response.headers</code>.</li>
				<li>If you want to render an entirely different template, you can overwrite <code>response.template</code>.</li>
				<li>To detect whether a response is based on QWeb in the first place, query <code>response.is_qweb</code>.</li>
				<li>The resulting HTML <a id="_idTextAnchor727"/>code is available by calling <code>response.render()</code>.</li>
			</ul>
			<h2 id="_idParaDest-640"><a id="_idTextAnchor728"/>See also</h2>
			<ul>
				<li>Details on QWeb templates will be given in <a href="B20997_15.xhtml#_idTextAnchor861"><em class="italic">Chapter 15</em></a>, <em class="italic">Web </em><em class="italic">Client Development</em>.</li>
			</ul>
			<h1 id="_idParaDest-641"><a id="_idTextAnchor729"/>Serving static resources</h1>
			<p>Web pages contain <a id="_idIndexMarker961"/>several types of static resources, such as images, videos, CSS, and so on. In this recipe, we will see how you can manage such static resources for your module.</p>
			<h2 id="_idParaDest-642"><a id="_idTextAnchor730"/>Getting ready</h2>
			<p>For this recipe, we will display an image on the page. Grab the <code>my_hostel</code> module from the previous recipe. Select any image from your system and put that image inside the <code>/</code><code>my_hostel/static/src/img</code> directory.</p>
			<h2 id="_idParaDest-643"><a id="_idTextAnchor731"/>How to do it...</h2>
			<p>Follow these steps to show an image on the web page:</p>
			<ol>
				<li>Add your image to the <code>/</code><code>my_hostel/static/src/img</code> directory.</li>
				<li>Define the <a id="_idIndexMarker962"/>new route in <code>controller</code>. In the code, replace the image URL with the URL of your image:<pre class="source-code">
        @http.route('/demo_page', type='http', auth='none')
        def students(self):
                image_url = '/my_hostel/static/src/image/odoo.png'
                html_result = """&lt;html&gt;
                            &lt;body&gt;
                            &lt;img src="img/%s"/&gt;
                            &lt;/body&gt;
                        &lt;/html&gt;""" % image_url
        return html_result</pre></li>				<li>Restart the server and update the module to apply the changes. Now, visit <code>/demo_page</code> to see the image on the page.<div><img src="img/B20997_13_10.jpg" alt="Figure 13.10 – The static image on the web page"/></div></li>
			</ol>
			<p class="IMG---Figure"><a id="_idTextAnchor732"/></p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – The static image on the web page</p>
			<h2 id="_idParaDest-644"><a id="_idTextAnchor733"/>How it works…</h2>
			<p>All the files <a id="_idIndexMarker963"/>placed under the <code>/static</code> folder are considered static resources and are publicly accessible. In our example, we have put our image in the <code>/static/src/img</code> directory. You can place the static resource anywhere under the <code>static</code> directory, but there is a recommended directory structure based on the type of file:</p>
			<ul>
				<li><code>/static/src/img</code> is the directory used for images</li>
				<li><code>/static/src/css</code> is the directory used for CSS files</li>
				<li><code>/static/src/scss</code> is the directory used for SCSS files</li>
				<li><code>/static/src/fonts</code> is the directory used for font files</li>
				<li><code>/static/src/js</code> is the directory used for JavaScript files</li>
				<li><code>/static/src/xml</code> is the directory used for XML files for client-side QWeb templates</li>
				<li><code>/static/lib</code> is the directory used for files of external libraries</li>
			</ul>
			<p>In our example, we displayed an image on the page. You can also access the image directly from <code>/my_hostel/static/src/image/odoo.png</code>.</p>
			<p>In this recipe, we displayed a static resource (an image) on the web page, and we saw the recommended <a id="_idIndexMarker964"/>directories for different static resources. There are more simple ways to present page content and static resources, which we will see in the next chapter.</p>
		</div>
	</body></html>