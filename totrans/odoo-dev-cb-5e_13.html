<html><head></head><body>
		<div id="_idContainer119">
			<h1 id="_idParaDest-616" class="chapter-number"><a id="_idTextAnchor697"/>13</h1>
			<h1 id="_idParaDest-617"><a id="_idTextAnchor698"/>Web Server Development</h1>
			<p>We’ll introduce the basics of the web server part of Odoo in this chapter. Note that this will cover the fundamental aspects; for high-level functionality, you should refer to <a href="B20997_14.xhtml#_idTextAnchor734"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">CMS </em><span class="No-Break"><em class="italic">Website Development</em></span><span class="No-Break">.</span></p>
			<p>The Odoo web server is a crucial component of the Odoo framework, responsible for handling web requests and serving the web interface <span class="No-Break">to users.</span></p>
			<p>Here are key <a id="_idIndexMarker904"/>aspects of the Odoo <span class="No-Break">web server:</span></p>
			<ul>
				<li><strong class="bold">The web interface and modules</strong>: The web server provides a user-friendly web interface <a id="_idIndexMarker905"/>to access and interact with Odoo applications. Users <a id="_idIndexMarker906"/>can navigate through different modules, access data, and perform various business operations using <span class="No-Break">this interface.</span></li>
				<li><strong class="bold">An HTTP server</strong>: Odoo uses <a id="_idIndexMarker907"/>an HTTP server to handle web requests. It can be configured to work with popular web servers such as Nginx or Apache or can run its own built-in <span class="No-Break">HTTP server.</span></li>
				<li><strong class="bold">Werkzeug</strong>: Werkzeug is <a id="_idIndexMarker908"/>a <strong class="bold">WSGI</strong> (<strong class="bold">Web Server Gateway Interface</strong>) library for <a id="_idIndexMarker909"/>Python, and Odoo uses it to handle HTTP requests and responses. Werkzeug helps in routing requests, handling sessions, and managing other <span class="No-Break">web-related tasks.</span></li>
				<li><strong class="bold">Controllers and routing</strong>: Odoo uses <a id="_idIndexMarker910"/>controllers to handle different web <a id="_idIndexMarker911"/>requests and routes them to the appropriate controllers and methods. The routing mechanism ensures that requests are directed to the correct modules <span class="No-Break">and functionalities.</span></li>
				<li><strong class="bold">Views and templates</strong>: Odoo uses <a id="_idIndexMarker912"/>views and templates to define how data should be presented in the web interface. Views determine the structure of pages, and templates provide the HTML and presentation logic to <span class="No-Break">render data.</span></li>
				<li><strong class="bold">Business logic</strong>: The web server is tightly integrated with the business logic of Odoo. It communicates <a id="_idIndexMarker913"/>with the backend to fetch and update data, ensuring that the web interface reflects the most current state of the <span class="No-Break">business applications.</span></li>
				<li><strong class="bold">Security</strong>: Security is a critical aspect of the Odoo web server. It includes features such <a id="_idIndexMarker914"/>as authentication, authorization, and session management to ensure that users have appropriate access levels and that their interactions with the system <span class="No-Break">are secure.</span></li>
				<li><strong class="bold">JavaScript and CSS</strong>: The Odoo web interface relies on JavaScript and CSS to enhance user <a id="_idIndexMarker915"/>experience and provide dynamic and responsive features. This includes <a id="_idIndexMarker916"/>form validation, interactive elements, and <span class="No-Break">real-time updates.</span></li>
				<li><strong class="bold">A RESTful API</strong>: The web <a id="_idIndexMarker917"/>server also provides a RESTful API, allowing external applications to interact with Odoo programmatically. This enables integration with third-party systems and the development of <span class="No-Break">custom applications.</span></li>
				<li><strong class="bold">Customization and extensions</strong>: Developers can extend and customize the Odoo web <a id="_idIndexMarker918"/>server to meet specific business requirements. This includes creating custom modules, views, <span class="No-Break">and controllers.</span></li>
			</ul>
			<p>Understanding the Odoo web server is essential for developers and administrators working with Odoo to deploy, configure, and customize the system based on the unique needs of <span class="No-Break">a business.</span></p>
			<p>Werkzeug (<a href="https://werkzeug.palletsprojects.com/en/2.3.x">https://werkzeug.palletsprojects.com/en/2.3.x</a>) is a WSGI library for Python and is <a id="_idIndexMarker919"/>used by Odoo to handle HTTP requests and responses. WSGI is a specification for how web servers and web applications communicate in Python. Werkzeug provides a set of utilities and classes that make it easier to work with WSGI applications. Here are some details about how Werkzeug is used in the context <span class="No-Break">of Odoo:</span></p>
			<ul>
				<li><strong class="bold">Request handling</strong>: Werkzeug provides <a id="_idIndexMarker920"/>a <strong class="source-inline">Request</strong> object that represents an incoming HTTP request. In Odoo, this object is used to extract information from the incoming HTTP request, such as form data, query parameters, <span class="No-Break">and headers.</span></li>
				<li><strong class="bold">Response generation</strong>: The <strong class="source-inline">Response</strong> object in Werkzeug is used to create HTTP responses. Odoo <a id="_idIndexMarker921"/>utilizes this to construct and send responses back to the client, including rendering web pages or providing data in response to <span class="No-Break">AJAX requests.</span></li>
				<li><strong class="bold">Routing</strong>: Werkzeug enables easy URL routing. In Odoo, the routing mechanism is used to map <a id="_idIndexMarker922"/>incoming requests to the appropriate controller methods or views. This helps in directing requests to the correct functionality within the <span class="No-Break">Odoo application.</span></li>
				<li><strong class="bold">Middleware</strong>: Middleware components can be added to the Odoo application using Werkzeug. Middleware <a id="_idIndexMarker923"/>sits between the web server and the Odoo application and can perform tasks such as authentication, logging, or modifying requests <span class="No-Break">and responses.</span></li>
				<li><strong class="bold">URL building</strong>: Werkzeug provides a URL building facility that helps to generate URLs for different <a id="_idIndexMarker924"/>routes within the Odoo application. This is essential for creating links and redirects dynamically in the <span class="No-Break">web interface.</span></li>
				<li><strong class="bold">Session management</strong>: Werkzeug supports session management, which Odoo utilizes <a id="_idIndexMarker925"/>to handle user sessions. This is important for maintaining user state across multiple requests and ensuring security features such as <span class="No-Break">user authentication.</span></li>
				<li><strong class="bold">Utilities for common tasks</strong>: Werkzeug includes various utilities that simplify common <a id="_idIndexMarker926"/>web development tasks. Odoo leverages these utilities for tasks such as parsing form data, handling file uploads, and <span class="No-Break">managing cookies.</span></li>
				<li><strong class="bold">Error handling</strong>: Werkzeug provides mechanisms to handle errors, including HTTP error <a id="_idIndexMarker927"/>responses. Odoo uses this to ensure that appropriate error messages are returned to the client <span class="No-Break">when needed.</span></li>
			</ul>
			<p>To work with Werkzeug in the context of Odoo, developers often interact with these features through the controllers and views defined in Odoo modules. Understanding Werkzeug is beneficial for developers who want to extend or customize Odoo, as it provides insights into the underlying mechanisms to handle HTTP requests and responses within the application. However, in day-to-day Odoo development, developers often work at a higher level using the Odoo framework itself, without directly interacting <span class="No-Break">with Werkzeug.</span></p>
			<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Making a path accessible from <span class="No-Break">a network</span></li>
				<li>Restricting access to <span class="No-Break">web-accessible paths</span></li>
				<li>Consuming parameters passed to <span class="No-Break">your handlers</span></li>
				<li>Modifying an <span class="No-Break">existing handler</span></li>
				<li><span class="No-Break">Serving static</span></li>
			</ul>
			<h1 id="_idParaDest-618"><a id="_idTextAnchor699"/>Technical requirements</h1>
			<p>The technical requirements for this chapter include the online <span class="No-Break">Odoo platform.</span></p>
			<p>All the code used in this chapter can be downloaded from the GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-619"><a id="_idTextAnchor700"/>Making a path accessible from a network</h2>
			<p>Making a path accessible from a network means defining the entry points or URLs through which <a id="_idIndexMarker928"/>users can access the application. This is fundamental to any web development project, as it determines how users will interact with the system. In this recipe, we’ll look at how to make a URL of the <a href="http://yourserver/path1/path2">http://yourserver/path1/path2</a> form accessible to users. This can be either a web page or a path returning arbitrary data to be consumed by other programs. In the latter case, you would usually use the JSON format to consume paramet<a id="_idTextAnchor701"/>ers and offer <span class="No-Break">your data.</span></p>
			<h2 id="_idParaDest-620"><a id="_idTextAnchor702"/>Getting ready</h2>
			<p>We’ll make use of the <strong class="source-inline">hostel.student</strong> model, which we looked at in <a href="B20997_04.xhtml#_idTextAnchor118"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Application Models</em>; therefore, if you haven’t done so yet, grab the initial module from <a href="https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13/00_initial_module">https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter13/00_initial_module</a> so that you will be able to follow <span class="No-Break">the examples.</span></p>
			<p>We want to allow <a id="_idIndexMarker929"/>any user to query the full list of students in the hostel. Furthermore, we want to provide the same information to programs through a JSON request. Let’<a id="_idTextAnchor703"/>s check out how to <span class="No-Break">do it.</span></p>
			<h2 id="_idParaDest-621"><a id="_idTextAnchor704"/>How to do it...</h2>
			<p>We’ll need to add controllers, which go into a folder called <strong class="source-inline">controllers</strong> <span class="No-Break">by convention:</span></p>
			<ol>
				<li>Add a <strong class="source-inline">controllers/main.py</strong> file with the HTML version of our page, <span class="No-Break">as follows:</span><pre class="source-code">
from odoo import http
from odoo.http import request
    class Main(http.Controller):
        @http.route('/my_hostel/students', type='http', auth='none')
    def students(self):
        students = request.env['hostel.student'].sudo().search([])
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>				<li>Add a function <a id="_idIndexMarker930"/>to serve the same information in the JSON format, as shown in the <span class="No-Break">following example:</span><pre class="source-code">
@http.route('/my_hostel/students/json', type='json', auth='none')
    def students_json(self):
        records = request.env['hostel.student'].sudo().search([])
        return records.read(['name'])</pre></li>				<li>Add the <strong class="source-inline">controllers/__init__.py</strong> file, <span class="No-Break">as follows:</span><pre class="source-code">
from . import main</pre></li>				<li>Import <strong class="source-inline">controllers</strong> into your <strong class="source-inline">my_hostel/__init__.py</strong> file, <span class="No-Break">as follows:</span><pre class="source-code">
from . import controllers</pre></li>			</ol>
			<p>After restarting your server, you can visit <strong class="source-inline">/my_hostel/students</strong> in your browser, and you’ll be presented with a flat list of the <span class="No-Break">student names.</span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B20997_13_1.jpg" alt="Figure 13.1 – A list of students"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – A list of students</p>
			<p>To test the JSON-RPC part, you’ll have to craft a JSON request. A simple way to do that is by using the <a id="_idIndexMarker931"/>following command to receive the output on the <span class="No-Break">command line:</span></p>
			<pre class="console">
curl -i -X POST -H "Content-Type: application/json" -d "{}"
localhost:8069/my_hostel/students/json</pre>			<p>If you get <strong class="source-inline">404</strong> errors at this point, you probably have more than one database available on your instance. If so, it’s impossible for Odoo to determine which database is meant to serve <span class="No-Break">the request.</span></p>
			<p>Use the <strong class="source-inline">--db-filter='^yourdatabasename$'</strong> parameter to force Odoo to use the exact database you installed the module in. The path should now <span class="No-Break">be accessible.</span></p>
			<h2 id="_idParaDest-622"><a id="_idTextAnchor705"/>How it works...</h2>
			<p>The two crucial <a id="_idIndexMarker932"/>parts here are that our controller is derived from <strong class="source-inline">odoo.http.Controller</strong>, and the methods we use to serve content are decorated with <strong class="source-inline">odoo.http.route</strong>. Inheriting from <strong class="source-inline">odoo.http.Controller</strong> registers the controller with Odoo’s routing system in a similar way to how the models are registered – by inheriting from <strong class="source-inline">odoo.models.Model</strong>. Also, <strong class="source-inline">Controller</strong> has a metaclass that takes care <span class="No-Break">of this.</span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B20997_13_2.jpg" alt="Figure 13.2 – A diagram of controllers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – A diagram of controllers</p>
			<p>In general, paths handled by your add-on should start with your add-on’s name, to avoid name clashes. Of course, if you extend some of the add-on’s functionality, you’<a id="_idTextAnchor706"/>ll use this <span class="No-Break">add-on’s name.</span></p>
			<h3>odoo.http.route</h3>
			<p>The <strong class="source-inline">route</strong> decorator allows us to tell Odoo that a method should be web-accessible in the first place, and the <a id="_idIndexMarker933"/>first parameter determines on which path it is accessible. Instead of a string, you can also pass a list of strings, if you use the same function to serve <span class="No-Break">multiple paths.</span></p>
			<p>The <strong class="source-inline">type</strong> argument defaults to <strong class="source-inline">http</strong> and determines what type of request will be served. While, strictly speaking, JSON is HTTP, declaring the second function as <strong class="source-inline">type='json'</strong> makes life a lot easier because Odoo then handles type conversions <span class="No-Break">for us.</span></p>
			<p>Don’t worry about the <strong class="source-inline">auth</strong> parameter for now; it will be addressed in the <em class="italic">Restricting access to web-accessible paths</em> recipe in <span class="No-Break">this chapter.</span></p>
			<h3>Return values</h3>
			<p>Odoo’s treatment <a id="_idIndexMarker934"/>of the functions’ return values is determined by the <strong class="source-inline">type</strong> argument of the <strong class="source-inline">route</strong> decorator. For <strong class="source-inline">type='http'</strong>, we usually want to deliver some HTML, so the first function simply returns a string containing it. An alternative is to use <strong class="source-inline">request.make_response()</strong>, which gives you control over the headers to send in the response. So, to indicate when our page was last updated, we might change the last line in <strong class="source-inline">students()</strong> to the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
return request.make_response(
  html_result, headers=[
    ('Last-modified', email.utils.formatdate(
      (
        fields.Datetime.from_string(
        request.env['hostel.student'].sudo()
        .search([], order='write_date desc', limit=1)
        .write_date) -
        datetime.datetime(1970, 1, 1)
      ).total_seconds(),
      usegmt=True)),
])</pre>			<p>This code sends a <strong class="source-inline">Last-modified</strong> header along with the HTML we generated, telling the browser when the list was modified for the last time. We can extract this information from the <strong class="source-inline">write_date</strong> field of the <span class="No-Break"><strong class="source-inline">hostel.student</strong></span><span class="No-Break"> model.</span></p>
			<p>In order for the preceding <a id="_idIndexMarker935"/>snippet to work, you’ll have to add some imports at the top of the file, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import email
import datetime
from odoo import fields</pre>			<p>You can also create a <strong class="source-inline">Response</strong> object of <strong class="source-inline">werkzeug</strong> manually and return that, but there’s little to gain for <span class="No-Break">the effort.</span></p>
			<p class="callout-heading">Important information</p>
			<p class="callout">Generating HTML manually is nice for demonstration purposes, but you should never do this in production code. Always use templates, as demonstrated in the <em class="italic">Creating or modifying templates – QWeb</em> recipe in <a href="B20997_15.xhtml#_idTextAnchor861"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, <em class="italic">Web Client Development</em>, and return them by calling <strong class="source-inline">request.render()</strong>. This will give you localization for free and will make your code better by separating business logic from the presentation layer. Also, templates provide you with functions to escape data before outputting HTML. The preceding code is vulnerable to cross-site scripting attacks (if a user manages to slip a <strong class="source-inline">script</strong> tag into the book name, <span class="No-Break">for example).</span></p>
			<p>For a JSON request, simply return the data structure you want to hand over to the client; Odoo takes care of serialization. For this to work, you should restrict yourself to data types that are JSON-serializable, which generally means dictionaries, lists, strings, floats, <span class="No-Break">and integers.</span></p>
			<h3>odoo.http.request</h3>
			<p>The <strong class="source-inline">request</strong> object is a static object referring to the currently handled request, which contains everything you <a id="_idIndexMarker936"/>need in order to take action. The most important aspect here is the <strong class="source-inline">request.env</strong> property, which contains an <strong class="source-inline">Environment</strong> object that is just the same as <strong class="source-inline">self.env</strong> for models. This environment is bound to the current user, which is not in the preceding example, because we used <strong class="source-inline">auth='none'</strong>. The lack of a user is also why we have to <strong class="source-inline">sudo()</strong> all our calls to model methods in the <span class="No-Break">example code.</span></p>
			<p>If you’re used to web development, you’ll expect session handling, which is perfectly correct. Use <strong class="source-inline">request.session</strong> for an <strong class="source-inline">OpenERPSession</strong> object (which is quite a thin wrapper around the <strong class="source-inline">Session</strong> object of <strong class="source-inline">werkzeug</strong>) and <strong class="source-inline">request.session.sid</strong> to access the session ID. To store session values, just treat <strong class="source-inline">request.session</strong> as a dictionary, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
request.session['hello'] = 'world'
request.session.get('hello')</pre>			<p class="callout-heading">Important note</p>
			<p class="callout">Note that storing data in the session is no different from using global variables. Only do so if you must. This is usually the case for multi-request actions, such as a checkout in the <span class="No-Break"><strong class="source-inline">website_sale</strong></span><span class="No-Break"> module.</span></p>
			<h2 id="_idParaDest-623"><a id="_idTextAnchor707"/>There’s more...</h2>
			<p>The <strong class="source-inline">route</strong> decorator can have <a id="_idIndexMarker937"/>some extra parameters in order to customize its behavior further. By default, all HTTP methods are allowed, and Odoo intermingles the <a id="_idIndexMarker938"/>parameters passed. Using the <strong class="source-inline">methods</strong> parameter, you can pass a list of methods to accept, which would usually be one of either <strong class="source-inline">['GET']</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">['POST']</strong></span><span class="No-Break">.</span></p>
			<p>To allow cross-origin requests (browsers block AJAX and some other types of requests to domains other <a id="_idIndexMarker939"/>than where the script was loaded from, for security and privacy reasons), set the <strong class="source-inline">cors</strong> parameter to <strong class="source-inline">*</strong> to allow requests from all origins, or a URI to restrict requests to ones originating from that URI. If this parameter is unset, which is the default, the <strong class="source-inline">Access-Control-Allow-Origin</strong> header is not set, leaving you with the browser’s standard behavior. In our example, we might want to set <span class="No-Break">it on</span></p>
			<p><strong class="source-inline">/my_module/students/json</strong> in order to allow scripts pulled from other websites to access the list <span class="No-Break">of students.</span></p>
			<p>By default, Odoo protects certain types of requests from an attack known as cross-site request forgery, by passing a token along on every request. If you want to turn that off, set the <strong class="source-inline">csrf</strong> parameter to <strong class="source-inline">False</strong>, but note that this is a bad idea, <span class="No-Break">in general.</span></p>
			<h2 id="_idParaDest-624"><a id="_idTextAnchor708"/>See also</h2>
			<p>Refer to the <a id="_idIndexMarker940"/>following points to learn more about the <span class="No-Break">HTTP routes:</span></p>
			<ul>
				<li>If you host multiple Odoo databases on the same instance, then different databases might be running on different domains. If so, you can use the <strong class="source-inline">--db-filter</strong> options, or you can use the <strong class="source-inline">dbfilter_from_header</strong> module from <a href="https://github.com/OCA/server-tools">https://github.com/OCA/server-tools</a>, which helps you filter databases based on <span class="No-Break">the domain.</span></li>
				<li>To see how using templates makes modularity possible, check out the <em class="italic">Modifying an existing handler</em> recipe later in <span class="No-Break">the chapter.</span></li>
			</ul>
			<h1 id="_idParaDest-625"><a id="_idTextAnchor709"/>Restricting access to web-accessible paths</h1>
			<p>As an Odoo developer, one of your primary concerns is ensuring the security of the application. Restricting <a id="_idIndexMarker941"/>access to web-accessible paths is a crucial aspect of access control. It involves determining who can or cannot access specific routes or functionalities within the Odoo application. Odoo provides different authentication mechanisms to control user access. Understanding and implementing these mechanisms is essential for ensuring that only authorized users can interact with sensitive or protected parts of the application. For instance, you might want to restrict certain routes to authenticated <span class="No-Break">users only.</span></p>
			<p>We’ll explore the three authentication mechanisms Odoo provides for routes in this recipe. We’ll define routes with different authentication mechanisms in order to show <span class="No-Break">their differences.</span></p>
			<h2 id="_idParaDest-626"><a id="_idTextAnchor710"/>Getting ready</h2>
			<p>As we extend the code from the previous recipe, we’ll also depend on the <strong class="source-inline">hostel.student</strong> model of <a href="B20997_04.xhtml#_idTextAnchor118"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Application Models</em>, so you should ret<a id="_idTextAnchor711"/>rieve its code in order <span class="No-Break">to proceed.</span></p>
			<h2 id="_idParaDest-627"><a id="_idTextAnchor712"/>How to do it...</h2>
			<p>Define the handlers <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">controllers/main.py</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>Add a path <a id="_idIndexMarker942"/>that shows all the students, as shown in the <span class="No-Break">following example:</span><pre class="source-code">
    @http.route('/my_hostel/all-students', type='http', auth='none')
    def all_students(self):
        students = request.env['hostel.student'].sudo().search([])
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>				<li>Add a path that shows all the students and indicates which ones belong to the current user, if any. This is shown in the <span class="No-Break">following example:</span><pre class="source-code">
@http.route('/my_hostel/all-students/mark-mine', type='http', auth='public')
    def all_students_mark_mine(self):
        students = request.env['hostel.student'].sudo().search([])
        hostels = request.env['hostel.hostel'].sudo().search([('rector', '=', request.env.user.partner_id.id)])
        hostel_rooms = request.env['hostel.room'].sudo().search([('hostel_id', 'in', hostels.ids)])
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            if student.id in hostel_rooms.student_ids.ids:
                html_result += "&lt;li&gt; &lt;b&gt;%s&lt;/b&gt; &lt;/li&gt;" % student.name
            else:
                html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>				<li>Add a path <a id="_idIndexMarker943"/>that shows the current user’s students, <span class="No-Break">as follows:</span><pre class="source-code">
@http.route('/my_hostel/all-students/mine', type='http', auth='user')
    def all_students_mine(self):
        hostels = request.env['hostel.hostel'].sudo().search([('rector', '=', request.env.user.partner_id.id)])
        students = request.env['hostel.room'].sudo().search([('hostel_id', 'in', hostels.ids)]).student_ids
        html_result = '&lt;html&gt;&lt;body&gt;&lt;ul&gt;'
        for student in students:
            html_result += "&lt;li&gt; %s &lt;/li&gt;" % student.name
        html_result += '&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;'
        return html_result</pre></li>			</ol>
			<p>With this code, the <strong class="source-inline">/my_hostel/all-students</strong> and <strong class="source-inline">/my_hostel/all-students/mark-mine</strong> paths look the same for unauthenticated users, while a logged-in user <a id="_idIndexMarker944"/>sees their students in a bold font on the <span class="No-Break">latter path.</span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B20997_13_3.jpg" alt="Figure 13.3 – Mark as mine students – with login"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Mark as mine students – with login</p>
			<p>The following screenshot shows the results <span class="No-Break">without login:</span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B20997_13_4.jpg" alt="Figure 13.4 – Mark as mine students – without login"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Mark as mine students – without login</p>
			<p>The <strong class="source-inline">/my_hostel/all-students/mine</strong> path is not accessible at all for unauthenticated <a id="_idIndexMarker945"/>users. If you try to access it without being authenticated, you’ll be redirected to the login screen in order to <span class="No-Break">do so.</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B20997_13_5.jpg" alt="Figure 13.5 – Access via unauthenticated users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Access via unauthenticated users</p>
			<h2 id="_idParaDest-628"><a id="_idTextAnchor713"/>How it works...</h2>
			<p>The difference between authentication methods is basically what you can expect from the content <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">request.env.user</strong></span><span class="No-Break">.</span></p>
			<p>For <strong class="source-inline">auth='none'</strong>, the user record is always empty, even if an authenticated user accesses the path. Use this if you want to serve content that has no dependencies on users, or if you <a id="_idIndexMarker946"/>want to provide database-agnostic functionality in a <span class="No-Break">server-wide module.</span></p>
			<p>The <strong class="source-inline">auth='public'</strong> value sets the user record as a special user with an XML ID of <strong class="source-inline">base.public_user</strong> for unauthenticated users, and to the user’s record for authenticated ones. This is the right choice if you want to offer functionality to both unauthenticated and authenticated users, while the authenticated ones get some extras, as demonstrated in the <span class="No-Break">preceding code.</span></p>
			<p>Use <strong class="source-inline">auth='user'</strong> to ensure that only authenticated users have access to what you’ve got to offer. With this method, you can be sure that <strong class="source-inline">request<a id="_idTextAnchor714"/>.env.user</strong> points to an <span class="No-Break">existing user.</span></p>
			<h2 id="_idParaDest-629"><a id="_idTextAnchor715"/>There’s more...</h2>
			<p>The magic of authentication methods happens in the <strong class="source-inline">ir.http</strong> model from the base add-on. For whatever value you pass to the <strong class="source-inline">auth</strong> parameter in your route, Odoo searches for <a id="_idIndexMarker947"/>a function called <strong class="source-inline">_auth_method_&lt;yourvalue&gt;</strong> on this model, so you can easily customize it by inheriting it and declaring a method that takes care of your authentication method <span class="No-Break">of choice.</span></p>
			<p>As an example, we will <a id="_idIndexMarker948"/>provide an authentication method called <strong class="source-inline">base_group_user</strong>, which will only authorize the user if the currently logged-in user is part of the <strong class="source-inline">base.group_user</strong> group, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
from odoo import exceptions, http, models
from odoo.http import request
class IrHttp(models.Model):
  _inherit = 'ir.http'
  def _auth_method_base_group_user(self):
    self._auth_method_user()
    if not request.env.user.has_group('base.group_user'):
      raise exceptions.AccessDenied()</pre>			<p>Now, you can say <strong class="source-inline">auth='base_group_user'</strong> in your decorator and be sure that users running <a id="_idIndexMarker949"/>this route’s handler are members of the group. With a little trickery, you can extend this to <strong class="source-inline">auth='groups(xmlid1,...)'</strong>; its implementation is left as an exercise for you but is included in the GitHub repository example code <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">Chapter13/02_paths_auth/my_hostel/models/sample_auth_http.py</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-630"><a id="_idTextAnchor716"/>Consuming parameters passed to your handlers</h1>
			<p>It’s nice to be able to show content, but it’s better to show content as a result of user input. This <a id="_idIndexMarker950"/>recipe will demonstrate the different ways to receive this input and react to it. As in the previous recipes, we’ll make use of the <span class="No-Break"><strong class="source-inline">hostel.student</strong></span><span class="No-Break"> model.</span></p>
			<h2 id="_idParaDest-631"><a id="_idTextAnchor717"/>How to do it...</h2>
			<p>First, we’ll add a route that expects a traditional parameter with a student’s ID to show some details about them. Then, we’ll do the same again, but we’ll incorporate our parameter into the <span class="No-Break">path itself:</span></p>
			<ol>
				<li>Add a path that expects a student’s ID as a parameter, as shown in the <span class="No-Break">following example:</span><pre class="source-code">
        @http.route('/my_hostel/student_details', type='http', auth='none')
        def student_details(self, student_id):
                record = request.env['hostel.student'].sudo().browse(int(student_id))
                return u'&lt;html&gt;&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;Room No: %s' % (
                        record.name, str(record.room_id.room_no) or 'none')</pre></li>				<li>Add a path where we can pass the student’s ID in the path, <span class="No-Break">as follows:</span><pre class="source-code">
@http.route("/my_hostel/student_details/&lt;model('hostel.student'):student&gt;",
            type='http', auth='none')
    def student_details_in_path(self, book):
        return self.student_details(student.id)</pre></li>			</ol>
			<p>If you point <a id="_idIndexMarker951"/>your browser to <strong class="source-inline">/my_hostel/student_details?student_id=1</strong>, you should see a detailed page of the student with <span class="No-Break">ID 1.</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B20997_13_6.jpg" alt="Figure 13.6 – The student details web page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – The student details web page</p>
			<p>If this doesn’t exist, you’ll receive an <span class="No-Break">error page.</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B20997_13_7.jpg" alt="Figure 13.7 – The student not found:Error page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – The student not found:Error page</p>
			<h2 id="_idParaDest-632"><a id="_idTextAnchor718"/>How it works...</h2>
			<p>By default, Odoo (actually, <strong class="source-inline">werkzeug</strong>) intermingles the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> parameters and passes them as keyword arguments to your handler. So, by simply declaring your function as expecting <a id="_idIndexMarker952"/>a parameter called <strong class="source-inline">student_id</strong>, you introduce this parameter as either <strong class="source-inline">GET</strong> (the parameter in the URL) or <strong class="source-inline">POST</strong> (usually passed by the <strong class="source-inline">&lt;form&gt;</strong> element with your handler as the <strong class="source-inline">action</strong> attribute). Given that we didn’t add a default value for this parameter, the runtime will raise an error if you try to access this path without setting <span class="No-Break">the parameter.</span></p>
			<p>The second example makes use of the fact that, in a <strong class="source-inline">werkzeug</strong> environment, most paths are virtual anyway. So, we can simply define our path as containing some input. In this case, we say that we expect the ID of a <strong class="source-inline">hostel.student</strong> instance as the last component of the path. The name after the colon is the name of a keyword argument. Our function will be called, with this parameter passed as a keyword argument. Here, Odoo takes care of looking up this ID and delivering a browse record, which, of course, only works if the user accessing this path has appropriate permissions. Given that <strong class="source-inline">student</strong> is a browse record, we can simply recycle the first example’s function by passing <strong class="source-inline">student.id</strong> as a <strong class="source-inline">student_id</strong> parameter, outputing the <span class="No-Break">same content.</span></p>
			<h2 id="_idParaDest-633"><a id="_idTextAnchor719"/>There’s more...</h2>
			<p>Defining parameters <a id="_idIndexMarker953"/>within a path is a functionality delivered by <strong class="source-inline">werkzeug</strong>, called <strong class="source-inline">converters</strong>. The <strong class="source-inline">model</strong> converter is added by Odoo, which also defines the converter models that accept a comma-separated list of IDs and pass a recordset containing those IDs to <span class="No-Break">your handler.</span></p>
			<p>The beauty of converters is that the runtime coerces parameters to the expected type, whereas you’re on your <a id="_idIndexMarker954"/>own with normal keyword parameters. These are delivered as strings, and you have to take care of the necessary type conversions yourself, as seen in the <span class="No-Break">first example.</span></p>
			<p>Built-in <strong class="source-inline">werkzeug</strong> converters include not only <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, and <strong class="source-inline">string</strong> but also more intricate ones, such as <strong class="source-inline">path</strong>, <strong class="source-inline">any</strong>, and <strong class="source-inline">uuid</strong>. You can look up their semantics <span class="No-Break">at </span><a href="https://werkzeug.palletsprojects.com/en/2.3.x/"><span class="No-Break">http<span id="_idTextAnchor720"/>s://werkzeug.palletsprojects.com/en/2.3.x/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-634"><a id="_idTextAnchor721"/>See also</h2>
			<p>If you want to learn more about the HTTP routes, refer to the <span class="No-Break">following points:</span></p>
			<ul>
				<li>Odoo’s custom converters are defined in <strong class="source-inline">ir_http.py</strong> in the base module and registered in the <strong class="source-inline">_get_converters</strong> class method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ir.http</strong></span></li>
				<li>If you want to learn more about the form submission on the route, refer to the <em class="italic">Getting input from users</em> recipe from <a href="B20997_14.xhtml#_idTextAnchor734"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, <em class="italic">CMS </em><span class="No-Break"><em class="italic">Website Development</em></span></li>
			</ul>
			<h1 id="_idParaDest-635"><a id="_idTextAnchor722"/>Modifying an existing handler</h1>
			<p>When you install <a id="_idIndexMarker955"/>the website module, the <strong class="source-inline">/website/info</strong> path displays some information about your Odoo instance. In this recipe, we will override this in order to change this information page’s layout, as well as to change what <span class="No-Break">is displayed.</span></p>
			<h2 id="_idParaDest-636"><a id="_idTextAnchor723"/>Getting ready</h2>
			<p>Install the <strong class="source-inline">website</strong> module and inspect the /<strong class="source-inline">website/info</strong> path. In this recipe, we will update the <strong class="source-inline">/website/info</strong> route to provide <span class="No-Break">more information.</span></p>
			<h2 id="_idParaDest-637"><a id="_idTextAnchor724"/>How to do it...</h2>
			<p>We’ll have to <a id="_idIndexMarker956"/>adapt the existing template and override the existing handler. We can do this <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Override the <strong class="source-inline">qweb</strong> template in a file called <strong class="source-inline">views/templates.xml</strong>, <span class="No-Break">as follows:</span><pre class="source-code">
&lt;?xml version="1.0"?&gt;
&lt;odoo&gt;
  &lt;template id="show_website_info"
            inherit_id="website.show_website_info"&gt;
   &lt;xpath expr="//dl[@t-foreach='apps']" position="replace"&gt;
            &lt;table class="table"&gt;
                &lt;tr t-foreach="apps" t-as="app"&gt;
                    &lt;th&gt;
                        &lt;a t-att-href="app.website" groups='base.group_no_one'&gt;
                            &lt;t t-out="app.name" /&gt;
                        &lt;/a&gt;
                    &lt;/th&gt;
                    &lt;td&gt;
                        &lt;span t-out="app.summary" /&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/xpath&gt;
  &lt;/template&gt;
&lt;/odoo&gt;</pre></li>				<li>Override the <a id="_idIndexMarker957"/>handler in a file called <strong class="source-inline">controllers/main.py</strong>, as shown in the <span class="No-Break">following example:</span><pre class="source-code">
from odoo import http
from odoo.addons.website.controllers.main import Website
class WebsiteInfo(Website):
    @http.route()
    def website_info(self):
        result = super(WebsiteInfo, self).website_info()
        result.qcontext['apps'] = result.qcontext['apps'].filtered(
            lambda x: x.name != 'website'
        )
        return result</pre></li>				<li>Now, when visiting the info page, we’ll only see a filtered list of installed applications in a table, as opposed to the original <span class="No-Break">definition list.</span></li>
			</ol>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B20997_13_8.jpg" alt="Figure 13.8 – The website info page (original)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – The website info page (original)</p>
			<p>The following <a id="_idIndexMarker958"/>screenshot shows the <span class="No-Break">customized page:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B20997_13_9.jpg" alt="Figure 13.9 – The website info page (customized)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – The website info page (customized)</p>
			<h2 id="_idParaDest-638"><a id="_idTextAnchor725"/>How it works…</h2>
			<p>In the first step, we overrode an existing QWeb template. In order to find out which one it is, you’ll have to consult the code of the original handler. Usually, this will give you something similar to the following line, which tells you that you need to <span class="No-Break">override </span><span class="No-Break"><strong class="source-inline">template.name</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
return request.render('template.name', values)</pre>			<p>In our case, the handler used a template called <strong class="source-inline">website_info</strong>, but this one was immediately extended by another template called <strong class="source-inline">website.show_website_info</strong>, so it’s more convenient to override this one. Here, we replaced the definition list showing installed apps with a table. For details on how QWeb inheritance works, consult <a href="B20997_15.xhtml#_idTextAnchor861"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, <em class="italic">Web </em><span class="No-Break"><em class="italic">Client Development</em></span><span class="No-Break">.</span></p>
			<p>In order to override the handler method, we must identify the class that defines the handler, which is <strong class="source-inline">odoo.addons.website.controllers.main.Website</strong> in this case. We need to import the class to be able to inherit from it. Now, we can override the method and change the data passed to the response. Note that what the overridden handler <a id="_idIndexMarker959"/>returns here is a <strong class="source-inline">Response</strong> object and not a string of HTML, as the previous recipes did, for the sake of brevity. This object contains a reference to the template to be used and the values accessible to the template, but it is only evaluated at the very end of <span class="No-Break">the request.</span></p>
			<p>In general, there are three ways to change an <span class="No-Break">existing handler:</span></p>
			<ul>
				<li>If it uses a QWeb template, the simplest way to change it is to override the template. This is the right choice for layout changes and small <span class="No-Break">logic changes.</span></li>
				<li>QWeb templates get a context passed, which is available in the response as the <strong class="source-inline">qcontext</strong> member. This is usually a dictionary where you can add or remove values to suit your needs. In the preceding example, we filtered the list of apps to the <span class="No-Break">website only.</span></li>
				<li>If the handler receives parameters, you can also preprocess those in order to make the overridden handler behave in the way <span class="No-Break">you want.</span></li>
			</ul>
			<h2 id="_idParaDest-639"><a id="_idTextAnchor726"/>There’s more...</h2>
			<p>As seen in the preceding section, inheritance with controllers works slightly differently than model inheritance; you actually need a reference to the base class and to use Python inheritance <span class="No-Break">on it.</span></p>
			<p>Don’t forget to decorate your new handler with the <strong class="source-inline">@http.route</strong> decorator; Odoo uses it as a marker, for which methods are exposed to the network layer. If you omit the decorator, you actually make the handler’s <span class="No-Break">path inaccessible.</span></p>
			<p>The <strong class="source-inline">@http.route</strong> decorator itself behaves similarly to field declarations – every value you don’t set <a id="_idIndexMarker960"/>will be derived from the decorator of the function you’re overriding, so we don’t have to repeat values we don’t want <span class="No-Break">to change.</span></p>
			<p>After receiving a <strong class="source-inline">response</strong> object from the function you override, you can do a lot more than just change the <span class="No-Break">QWeb context:</span></p>
			<ul>
				<li>You can add or remove HTTP headers by <span class="No-Break">manipulating </span><span class="No-Break"><strong class="source-inline">response.headers</strong></span><span class="No-Break">.</span></li>
				<li>If you want to render an entirely different template, you can <span class="No-Break">overwrite </span><span class="No-Break"><strong class="source-inline">response.template</strong></span><span class="No-Break">.</span></li>
				<li>To detect whether a response is based on QWeb in the first place, <span class="No-Break">query </span><span class="No-Break"><strong class="source-inline">response.is_qweb</strong></span><span class="No-Break">.</span></li>
				<li>The resulting HTML <a id="_idTextAnchor727"/>code is available by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">response.render()</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h2 id="_idParaDest-640"><a id="_idTextAnchor728"/>See also</h2>
			<ul>
				<li>Details on QWeb templates will be given in <a href="B20997_15.xhtml#_idTextAnchor861"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, <em class="italic">Web </em><span class="No-Break"><em class="italic">Client Development</em></span><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-641"><a id="_idTextAnchor729"/>Serving static resources</h1>
			<p>Web pages contain <a id="_idIndexMarker961"/>several types of static resources, such as images, videos, CSS, and so on. In this recipe, we will see how you can manage such static resources for <span class="No-Break">your module.</span></p>
			<h2 id="_idParaDest-642"><a id="_idTextAnchor730"/>Getting ready</h2>
			<p>For this recipe, we will display an image on the page. Grab the <strong class="source-inline">my_hostel</strong> module from the previous recipe. Select any image from your system and put that image inside the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">my_hostel/static/src/img</strong></span><span class="No-Break"> directory.</span></p>
			<h2 id="_idParaDest-643"><a id="_idTextAnchor731"/>How to do it...</h2>
			<p>Follow these steps to show an image on the <span class="No-Break">web page:</span></p>
			<ol>
				<li>Add your image to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">my_hostel/static/src/img</strong></span><span class="No-Break"> directory.</span></li>
				<li>Define the <a id="_idIndexMarker962"/>new route in <strong class="source-inline">controller</strong>. In the code, replace the image URL with the URL of <span class="No-Break">your image:</span><pre class="source-code">
        @http.route('/demo_page', type='http', auth='none')
        def students(self):
                image_url = '/my_hostel/static/src/image/odoo.png'
                html_result = """&lt;html&gt;
                            &lt;body&gt;
                            &lt;img src="%s"/&gt;
                            &lt;/body&gt;
                        &lt;/html&gt;""" % image_url
        return html_result</pre></li>				<li>Restart the server and update the module to apply the changes. Now, visit <strong class="source-inline">/demo_page</strong> to see the image on <span class="No-Break">the page.</span><div id="_idContainer118" class="IMG---Figure"><img src="image/B20997_13_10.jpg" alt="Figure 13.10 – The static image on the web page"/></div></li>
			</ol>
			<p class="IMG---Figure"><a id="_idTextAnchor732"/></p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – The static image on the web page</p>
			<h2 id="_idParaDest-644"><a id="_idTextAnchor733"/>How it works…</h2>
			<p>All the files <a id="_idIndexMarker963"/>placed under the <strong class="source-inline">/static</strong> folder are considered static resources and are publicly accessible. In our example, we have put our image in the <strong class="source-inline">/static/src/img</strong> directory. You can place the static resource anywhere under the <strong class="source-inline">static</strong> directory, but there is a recommended directory structure based on the type <span class="No-Break">of file:</span></p>
			<ul>
				<li><strong class="source-inline">/static/src/img</strong> is the directory used <span class="No-Break">for images</span></li>
				<li><strong class="source-inline">/static/src/css</strong> is the directory used for <span class="No-Break">CSS files</span></li>
				<li><strong class="source-inline">/static/src/scss</strong> is the directory used for <span class="No-Break">SCSS files</span></li>
				<li><strong class="source-inline">/static/src/fonts</strong> is the directory used for <span class="No-Break">font files</span></li>
				<li><strong class="source-inline">/static/src/js</strong> is the directory used for <span class="No-Break">JavaScript files</span></li>
				<li><strong class="source-inline">/static/src/xml</strong> is the directory used for XML files for client-side <span class="No-Break">QWeb templates</span></li>
				<li><strong class="source-inline">/static/lib</strong> is the directory used for files of <span class="No-Break">external libraries</span></li>
			</ul>
			<p>In our example, we displayed an image on the page. You can also access the image directly <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">/my_hostel/static/src/image/odoo.png</strong></span><span class="No-Break">.</span></p>
			<p>In this recipe, we displayed a static resource (an image) on the web page, and we saw the recommended <a id="_idIndexMarker964"/>directories for different static resources. There are more simple ways to present page content and static resources, which we will see in the <span class="No-Break">next chapter.</span></p>
		</div>
	</body></html>