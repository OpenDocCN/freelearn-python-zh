- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Investigating Dependency Injection
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the first chapter, `BaseModel`, `Request`, `Response`, and `BackgroundTasks`
    in their processes. Applying DI proves that instantiating some FastAPI classes
    is not always the ideal approach, since the framework has a built-in container
    that can provide the objects of these classes for the API services. This method
    of object management makes FastAPI easy and efficient to use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI has a container where the DI policy is applied to instantiate module
    classes and even functions. We only need to specify and declare these module APIs
    to the services, middleware, authenticator, data sources, and test cases because
    the rest of the object assembly, management, and instantiation is now the responsibility
    of the built-in container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you to understand how to manage objects needed by the
    application, such as minimizing some instances and creating loose bindings among
    them. Knowing the effectiveness of DI on FastAPI is the first step in designing
    our microservice applications. Our discussions will focus on the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Applying **Inversion of Control** (**IoC**) and DI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring ways of injecting dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing a project based on dependencies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoping of instances
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses a software prototype called *online recipe system*, which
    manages, evaluates, rates, and reports recipes of different types and origins.
    Applying a DI pattern is the priority of this project, so expect some changes
    in the development strategies and approaches, such as adding `model`, `repository`,
    and `service` folders. This software is for food enthusiasts or chefs who want
    to share their specialties, newbies looking for recipes to experiment with, and
    guests who just like to browse through different food menus. This open-ended application
    does not use any database management system yet, so all the data is temporarily
    stored in Python containers. Code is all uploaded at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Applying IoC/DI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FastAPI is a framework that supports the IoC principle, which means that it
    has a container that can instantiate objects for an application. In a typical
    programming scenario, we instantiate classes to use them in many ways to build
    a running application. But with IoC, the framework instantiates the components
    for the application. *Figure 3.1* shows the whole picture of the IoC principle
    and the participation of one of its forms, called the DI.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The IoC principle](img/Figure_3.1_B17975.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The IoC principle
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: For FastAPI, DI is not only a principle but a mechanism to integrate an object
    into a component that leads to creating a *loosely coupled* but *highly cohesive*
    software structure. Almost all components can be candidates for DI, including
    *functions*. But for now, let us focus on *callable components* that provide some
    JSON objects once they are injected into an API service – injectable and callable
    components that we call *dependency functions*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FastAPI来说，依赖注入（DI）不仅是一个原则，也是一种将对象集成到组件中的机制，这有助于创建一个*松散耦合*但*高度内聚*的软件结构。几乎所有的组件都可以成为DI的候选者，包括*函数*。但就目前而言，让我们专注于*可调用组件*，一旦它们被注入到API服务中，就会提供一些JSON对象——我们称之为*依赖函数*的可注入和可调用组件。
- en: Injecting a dependency function
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入依赖函数
- en: 'A `create_login()`, as shown in the following code, which is in the project’s
    `/api/users.py` module:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，`create_login()`位于项目的`/api/users.py`模块中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The function requires the `id`, `username`, and `password` parameters and `type`
    to continue its process and return a valid JSON `account` object, derived from
    these parameters. A dependency function sometimes uses some underlying formula,
    resource, or complex algorithms to derive its function value, but for now, we
    utilize it as a *placeholder of data* or `dict`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要`id`、`username`、`password`参数以及`type`来继续其过程并返回一个有效的JSON `account`对象，这些参数是其派生出来的。依赖函数有时会使用一些底层公式、资源或复杂算法来推导其函数值，但就目前而言，我们将其用作*数据占位符*或`dict`。
- en: 'Common to dependency functions are method parameters that serve as placeholders
    to a REST API’s incoming request. These are wired into the API’s method parameter
    list as a domain model to the query parameters or request body through DI. The
    `Depends()` function from the `fastapi` module pursues the injection before it
    wires the injectable to a local parameter. The module function can only take one
    parameter for injection:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖函数来说，常见的做法是将方法参数用作REST API接收到的请求的占位符。这些参数通过DI连接到API的方法参数列表，作为领域模型，对应于查询参数或请求体。`fastapi`模块中的`Depends()`函数在将注入项连接到本地参数之前执行注入。模块函数只能接受一个参数进行注入：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding is a code fragment from our *online recipe system* that shows
    how `Depends()` injects `create_login()`into the framework’s container and fetches
    its instance for *wiring* to the `populate_user_accounts()` service. Syntactically,
    the injection process only needs the name of the function dependency without the
    parenthesis. Again, the purpose of `create_login()` is to capture the query parameters
    of the API service. The `jsonable_encoder()` is very useful to many APIs in converting
    these injectables to JSON-compatible types such as `dict`, which are essential
    for *instantiating the needed data models* and *generating responses*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面是一个来自我们*在线食谱系统*的代码片段，展示了`Depends()`如何将`create_login()`注入到框架的容器中，并获取其实例以用于将`populate_user_accounts()`服务连接起来。在语法上，注入过程只需要函数依赖项的名称，无需括号。再次强调，`create_login()`的目的在于捕获API服务的查询参数。`jsonable_encoder()`对于许多API来说非常有用，它可以将这些注入项转换为JSON兼容的类型，如`dict`，这对于*实例化所需的数据模型*和*生成响应*至关重要。
- en: Important Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The term **dependencies** can be used interchangeably with **injectables**,
    **dependables**, **resources**, **providers**, or **components**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**依赖项**可以与**注入项**、**依赖项**、**资源**、**提供者**或**组件**互换使用。
- en: Injecting a callable class
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入一个可调用类
- en: 'FastAPI also allows classes to be injected into any components, since they
    can also be considered *callable* components. A class becomes *callable* during
    instantiation when the call to its constructor, `__init__(self)`, is done. Some
    of these classes have *no-arg* constructors, while others, such as the following
    `Login` class, require constructor arguments:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI还允许将类注入到任何组件中，因为它们也可以被视为*可调用*组件。一个类在实例化过程中成为可调用，当对其构造函数`__init__(self)`的调用完成时。其中一些类具有*无参*构造函数，而其他类，如以下`Login`类，则需要构造函数参数：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Login` class, located in `/model/users.py`, needs `id`, `username`, `password`,
    and `type` passed to its constructor before the instantiation. A possible instantiation
    would be `Login(id=' 249a0837-c52e-48cd-bc19-c78e6099f931', username='admin',
    password='admin2255', type=UserType.admin)`. Overall, we can observe the similarity
    between a class and a dependency function based on their callable behavior and
    the ability to capture request data, such as a model attribute.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 位于`/model/users.py`的`Login`类在实例化之前需要将`id`、`username`、`password`和`type`传递给其构造函数。一个可能的实例化方式是`Login(id='249a0837-c52e-48cd-bc19-c78e6099f931',
    username='admin', password='admin2255', type=UserType.admin)`。总体来看，我们可以观察到类和依赖函数在可调用行为和捕获请求数据（如模型属性）方面的相似性。
- en: 'Conversely, the `populate_login_without_service()` shown in the following code
    block shows how `Depends()` injects `Login` to the service. The `Depends()` function
    tells the built-in container to instantiate `Login` and fetches that instance,
    ready to be assigned to the `user_account` local parameter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，以下代码块中展示的`populate_login_without_service()`显示了`Depends()`如何将`Login`注入到服务中。`Depends()`函数告诉内置容器实例化`Login`并获取该实例，准备分配给`user_account`局部参数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All dependencies should be declared at the right-most part of the service’s
    parameter list. If there are query, path, or form parameters, injectables should
    come last. Moreover, the use of the `jsonable_encoder()` function can be an option
    if the *injectables* do not contain data that are hard to encode by default.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖都应该在服务参数列表的最右侧声明。如果有查询、路径或表单参数，注入式依赖应该放在最后。此外，如果注入式依赖不包含默认难以编码的数据，使用`jsonable_encoder()`函数也是一个选项。
- en: Building nested dependencies
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建嵌套依赖
- en: 'There are some scenarios when injectables are also dependent on other dependencies.
    When we inject a function dependency to another function, a class dependency to
    another class injectable, or a function resource to a class, the goal is to build
    nested dependencies. Nested dependencies are beneficial to REST APIs, with lengthy
    and complex request data that needs structuring and grouping through sub-domain
    models. These sub-domains or domain models within a model are later encoded as
    sub-dependencies into JSON-compatible types by FastAPI:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些场景下，注入式依赖也依赖于其他依赖。当我们向另一个函数注入函数依赖、向另一个类注入式依赖或向类注入函数资源时，目标是构建嵌套依赖。嵌套依赖对REST
    API有益，特别是对于需要通过子域模型进行结构化和分组的长时间和复杂请求数据。这些子域或模型内的域模型随后被FastAPI编码为与JSON兼容的类型作为子依赖：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding asynchronous `create_user_details()` function shows that even
    a dependency function needs another dependency to satisfy its purpose. This function
    is dependent on `create_login()`, which is another dependable component. With
    this nested dependency setup, wiring the `create_user_details()` into an API service
    also includes the injection of `create_login()` into the container. In short,
    there is a chain of DIs that will be created when nested dependencies are applied:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 之前异步的`create_user_details()`函数表明，即使依赖函数也需要另一个依赖来满足其目的。这个函数依赖于`create_login()`，这是另一个可靠的组件。通过这种嵌套依赖设置，将`create_user_details()`连接到API服务也包括将`create_login()`注入到容器中。简而言之，当应用嵌套依赖时，将创建一系列依赖注入链：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding `add_profile_login()` service provides a clear picture of its
    dependency on `create_user_details()`, including its underlying login details.
    The FastAPI container successfully created the two functions through chained DI
    to capture the request data during the API’s request transactions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`add_profile_login()`服务清楚地展示了其对`create_user_details()`的依赖，包括其底层的登录详情。FastAPI容器通过链式依赖成功创建了两个函数，以在API请求事务中捕获请求数据。
- en: 'Conversely, a class can also be dependable on another class. An example is
    the `Profile` class, shown here, which is dependent on `UserDetails` and `Login`
    classes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一个类也可以依赖于另一个类。这里以`Profile`类为例，它依赖于`UserDetails`和`Login`类：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is a nested dependency here because two classes will be injected altogether
    once `Profile` is wired to a REST API service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个嵌套依赖，因为一旦`Profile`连接到REST API服务，两个类将一起注入。
- en: 'A clear advantage of these chained dependencies is depicted in the following
    `add_profile_login_models()` service:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`add_profile_login_models()`服务展示了这些链式依赖的明显优势：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The extraction of `profile.user` and `profile.login` makes it easier for the
    service to identify what query data to deserialize. It also helps the service
    determine which group of data needs `Login` instantiation and which is for `UserDetails`.
    As a result, it will be easier to manage the persistency of these objects in their
    respective `dict` repositories.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提取`profile.user`和`profile.login`使得服务更容易识别需要反序列化的查询数据。它还有助于服务确定哪些数据组需要`Login`实例化，哪些是为`UserDetails`。因此，将更容易管理这些对象在其各自的`dict`存储库中的持久性。
- en: Creating explicit dependencies between function and class will be discussed
    later, but for now, let us examine how to fine-tune whenever we use lots of these
    nested dependencies in our application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后讨论如何在函数和类之间创建显式依赖关系，但现在，让我们看看如何在应用中使用大量这些嵌套依赖项时进行微调。
- en: Caching the dependencies
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存依赖项
- en: All dependencies are *cacheable*, and FastAPI caches all these dependencies
    during a request transaction. If a dependable is common to all services, FastAPI
    will not allow you to fetch these objects from its container *by default*. Rather,
    it will look for this injectable from its cache to be used multiple times across
    the API layer. Saving dependencies, especially nested ones, is a good feature
    of FastAPI because it optimizes the performance of the REST service.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖项都是*可缓存的*，FastAPI在请求事务期间会缓存所有这些依赖项。如果一个依赖项对所有服务都是通用的，FastAPI默认不会允许你从其容器中获取这些对象。相反，它会在其缓存中寻找这个可注入项，以便在API层跨多次使用。保存依赖项，特别是嵌套依赖项，是FastAPI的一个好特性，因为它优化了REST服务的性能。
- en: 'Conversely, `Depends()` has a `use_cache` parameter that we can set to `False`
    if we want to bypass this caching mechanism. Configuring this hook will not save
    the dependencies from the cache during request transactions, allowing `Depends()`
    to fetch the instances from the container more frequently. Another version of
    the `add_profile_login_models()` service, shown here, shows how to disable dependency
    caching:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`Depends()`有一个`use_cache`参数，如果我们想绕过这个缓存机制，我们可以将其设置为`False`。配置这个钩子将不会在请求事务期间从缓存中保存依赖项，允许`Depends()`更频繁地从容器中获取实例。下面所示`add_profile_login_models()`服务的另一个版本展示了如何禁用依赖项缓存：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Another obvious change in the preceding service implementation is the presence
    of the `Profile` data type in the local parameter declaration. Is this really
    allowed by FastAPI?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面服务实现中的另一个明显变化是`Profile`数据类型出现在局部参数声明中。这是FastAPI允许的吗？
- en: Declaring Depends() parameter types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明Depends()参数类型
- en: 'Generally, we do not declare types of the local parameters that will reference
    the injected dependencies. Due to *type hints*, we can optionally associate the
    references with their appropriate object types. For instance, we can re-implement
    `populate_user_accounts()` to include the type of `user_account`, such as the
    following one:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会声明将引用注入依赖项的局部参数的类型。由于*类型提示*，我们可以选择性地将引用与其适当的对象类型关联起来。例如，我们可以重新实现`populate_user_accounts()`以包含`user_account`的类型，如下所示：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This scenario happens very rarely, since `create_login()` is a dependency function,
    and we usually do not create classes only to provide the blueprint type of its
    returned values. But when we use class dependables, declaring the appropriate
    class type to the wired object is feasible, as in the following `add_profile_login_models()`
    service, which declares the `profile` parameter as `Profile`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景很少发生，因为`create_login()`是一个依赖函数，我们通常不会仅为了提供其返回值的蓝图类型而创建类。但是，当我们使用类依赖项时，将适当的类类型声明给连接的对象是可行的，如下面的`add_profile_login_models()`服务所示，其中将`profile`参数声明为`Profile`：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Although the declaration is syntactically valid, the expression looks *repetitive*
    and *redundant* because the `Profile` type appears twice in the declaration portion.
    To avoid this redundancy, we can replace the statement with a shorthand version
    by omitting the class name inside the `Depends()` function. Thus, a better way
    of declaring the preceding `profile` should be the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然声明在语法上是有效的，但由于`Profile`类型在声明部分出现了两次，所以表达式看起来*重复*且*冗余*。为了避免这种冗余，我们可以通过在`Depends()`函数内部省略类名来替换语句，使用简写版本。因此，声明前面`profile`的更好方式应该是以下这样：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The changes reflected on the parameter list will not affect the performance
    of the request transaction of the `add_profile_login_models()` service.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表上的更改不会影响`add_profile_login_models()`服务请求事务的性能。
- en: Injecting asynchronous dependencies
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入异步依赖项
- en: 'A FastAPI built-in container does not only manage *synchronous* function dependables
    but also *asynchronous* ones. The following `create_user_details()` is an asynchronous
    dependency, read to be wired to a service:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 内置容器不仅管理 *同步* 函数依赖项，还管理 *异步* 依赖项。下面的 `create_user_details()` 是一个异步依赖项，准备好连接到服务：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The container can manage both synchronous and asynchronous function dependency.
    It can allow the wiring of *asynchronous dependables* on an asynchronous API service
    or some *asynchronous ones* on a synchronous API. In cases where the dependency
    and the services are both asynchronous, applying the `async`/`await` protocol
    is recommended to avoid discrepancies in the results. `create_user_details()`,
    which is dependent on a synchronous `create_login()`, is wired on `add_profile_login()`,
    which is an asynchronous API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以管理同步和异步函数依赖项。它允许在异步 API 服务上连接 *异步依赖项* 或在同步 API 上连接一些 *异步依赖项*。当依赖项和服务都是异步的情况下，建议使用
    `async`/`await` 协议以避免结果的不一致。依赖于同步 `create_login()` 的 `create_user_details()` 在异步
    API `add_profile_login()` 上被连接。
- en: After learning how DI design pattern works in FastAPI, the next step is to know
    the different levels of strategy for applying `Depends()` in our application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 FastAPI 中依赖注入设计模式的工作原理之后，下一步是了解在我们的应用程序中应用 `Depends()` 的不同策略级别。
- en: Exploring ways of injecting dependencies
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索注入依赖项的方法
- en: From the previous discussions, we know that FastAPI has a built-in container
    through which some objects are injected and instantiated. Likewise, we have learned
    that the only FastAPI components that are injectables are those so-called dependables,
    injectables, or dependencies. Now, let us enumerate different ways to pursue the
    DI pattern in our application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的讨论中，我们知道 FastAPI 有一个内置的容器，通过它一些对象被注入和实例化。同样，我们也了解到，唯一可注入的 FastAPI 组件是那些所谓的依赖项、可注入项或依赖。现在，让我们列举出在我们的应用程序中追求依赖注入模式的不同方法。
- en: Dependency injection on services
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务上的依赖注入
- en: 'The most common area where DI occurs is in the *parameter list* of a service
    method. Any discussions regarding this strategy have been tackled already in the
    previous examples, so we only need to present additional points concerning this
    strategy:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: DI 发生最常见的地方是在服务方法的 *参数列表* 中。关于这种策略的任何讨论已经在之前的示例中解决，所以我们只需要提出关于这种策略的额外观点：
- en: First, the number of custom injectables a service method should take is also
    part of the concern. When it comes to complex query parameters or request bodies,
    API services can take more than one injectable as long as there are no similar
    instance variable names among these dependables. This *variable name collision*
    among the dependables will lead to having one parameter entry for the conflicted
    variable during the request transactions, thus sharing the same value for all
    these conflicting variables.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，服务方法应该接受的定制可注入项的数量也是需要关注的一部分。当涉及到复杂的查询参数或请求体时，只要这些依赖项中没有相似的实例变量名，API 服务就可以接受多个可注入项。这些依赖项之间的
    *变量名冲突* 将导致在请求事务中只有一个参数条目用于冲突变量，从而使得所有这些冲突变量共享相同的值。
- en: Second, the appropriate *HTTP method operation* to work with the injectables
    is also one aspect to consider. Both function and class dependencies can work
    with the `GET`, `POST`, `PUT`, and `PATCH` operations, except for those dependables
    with attribute types such as numeric `Enum` and `UUID` that can cause an *HTTP
    Status 422* (**Unprocessable Entity**) due to conversion problems. We must plan
    which HTTP method is applicable for some dependable(s) first, before implementing
    the service method.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，与可注入项一起工作的合适的 *HTTP 方法操作* 也是需要考虑的一个方面。函数和类依赖项都可以与 `GET`、`POST`、`PUT` 和 `PATCH`
    操作一起工作，但那些具有如数值 `Enum` 和 `UUID` 等属性类型的依赖项可能会因为转换问题而导致 *HTTP 状态 422*（**不可处理实体**）。我们必须首先计划适用于某些依赖项的
    HTTP 方法，然后再实现服务方法。
- en: 'Third, not all dependables are placeholders of request data. Unlike the class
    dependables, dependency functions are not specifically used for returning objects
    or `dict`. Some of them are used in *filtering request data*, *scrutinizing authentication
    details*, *managing form data*, *verifying header values*, *handling cookies*,
    and *throwing some errors* when there are violations of some rules. The following
    `get_all_recipes()` service is dependent on a `get_recipe_service()` injectable
    that will query all the recipes from the `dict` repository of the application:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，并非所有依赖项都是请求数据的占位符。与类依赖项不同，依赖函数并不专门用于返回对象或`dict`。其中一些用于**过滤请求数据**、**审查认证细节**、**管理表单数据**、**验证头值**、**处理cookie**，并在违反某些规则时**抛出一些错误**。以下`get_all_recipes()`服务依赖于一个`get_recipe_service()`注入函数，该函数将从应用的`dict`存储库中查询所有食谱：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The dependency function provides the needed transactions such as saving and
    retrieving records of recipes. Instead of the usual instantiation or method call,
    a better strategy is to inject these *dependable services* into the API implementation.
    The `handler` method parameter, which refers to the instance of `get_recipe_service()`,
    invokes the `get_recipes()` transactions of a particular service to retrieve all
    the menus and ingredients stored in the repository.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖函数提供了所需的交易，例如保存和检索食谱的记录。而不是使用常规的实例化或方法调用，更好的策略是将这些**依赖服务**注入到API实现中。`handler`方法参数，它指的是`get_recipe_service()`的实例，调用特定服务的`get_recipes()`交易以检索存储库中存储的所有菜单和成分。
- en: Dependency injection on path operators
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径操作符上的依赖注入
- en: 'There is always an option to implement *triggers*, *validators*, and *exception
    handlers* as injectable functions. Since these dependables work like *filters*
    to the incoming request, their injection happens in the *path operator* and not
    in the service parameter list. The following code is an implementation of the
    `check_feedback_length()` validator, found in `/dependencies/posts.py`, which
    checks whether the feedback posted by a user regarding a recipe should be at least
    20 characters, including spaces:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一个选项来实现**触发器**、**验证器**和**异常处理器**作为可注入的函数。由于这些依赖项像**过滤器**一样作用于传入的请求，它们的注入发生在**路径操作符**中，而不是在服务参数列表中。以下代码是`/dependencies/posts.py`中找到的`check_feedback_length()`验证器的实现，该验证器检查用户针对食谱发布的反馈是否至少包含20个字符（包括空格）：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The validator pauses the API execution to retrieve the feedback from a post
    to be validated *if its length is lower than 20*. If the dependency function finds
    it `True`, it will throw an *HTTP Status 403*. Alternatively, it will emit a *Status
    Code 500* if the feedback is missing from the request data; otherwise, it will
    let the API transaction finish its task.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证器的长度小于20，验证器会暂停API执行以从待验证的帖子中检索反馈。如果依赖函数发现它是`True`，它将抛出**HTTP状态403**。如果请求数据中缺少反馈，它将发出**状态码500**；否则，它将允许API事务完成其任务。
- en: 'Compared to the `create_post()` and `post_service()` dependables, the following
    script shows that the `check_feedback_length()` validator is not invoked anywhere
    inside the `insert_post_feedback()` service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`create_post()`和`post_service()`依赖项相比，以下脚本显示`check_feedback_length()`验证器在`insert_post_feedback()`服务内部没有任何地方被调用：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The validator will always work closely with the incoming request transaction,
    whereas the other two injectables, `post` and `handler`, are part of the API’s
    transactions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器将始终与传入的请求事务紧密工作，而其他两个注入项`post`和`handler`则是API事务的一部分。
- en: Important Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The path router of `APIRouter` can accommodate more than one injectable, which
    is why its `dependencies` parameter always needs a `List` value (`[]`).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIRouter`的路径路由器可以容纳多个可注入项，这就是为什么它的`dependencies`参数始终需要一个`List`值（`[]`）。'
- en: Dependency injection on routers
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器上的依赖注入
- en: 'However, some transactions are not localized to work on one specific API. There
    are dependency functions created to work with a certain group of REST API services
    within an application, such as the following `count_user_by_type()` and `handler
    check_credential_error()` events that are designed to manage incoming requests
    of REST APIs under the `user.router` group. This strategy requires DI at the `APIRouter`
    level:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些事务并不是专门针对一个特定的API进行本地化的。有一些依赖函数被创建出来，用于与一个应用中特定组的REST API服务一起工作，例如以下`count_user_by_type()`和`handler
    check_credential_error()`事件，这些事件被设计用来管理`user.router`组下的REST API的传入请求。这种策略需要在`APIRouter`级别进行依赖注入：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Based on the preceding implementations, the goal of `count_user_by_type()` is
    to build an updated frequency of users in `stats_user_type` according to `UserType`.
    Its execution starts right after the REST API receives a new user and login details
    from the client. While it checks the `UserType` of the new record, the API service
    pauses briefly and resumes after the function dependency has completed its tasks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 preceding 实现，`count_user_by_type()` 的目标是根据 `UserType` 在 `stats_user_type`
    中构建用户的更新频率。它的执行是在 REST API 从客户端接收到新用户和登录详情后立即开始的。在检查新记录的 `UserType` 时，API 服务会短暂暂停，并在函数依赖完成其任务后恢复。
- en: Conversely, the task of `check_credential_error()` is to ensure that the `username`
    and `password` of the new user should not be the same. It throws an *HTTP Status
    403* when the credentials are the same, which will halt the whole REST service
    transaction.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`check_credential_error()` 的任务是确保新用户的 `username` 和 `password` 不应相同。当凭证相同时，它会抛出
    *HTTP 状态 403*，这将停止整个 REST 服务事务。
- en: 'Injecting these two dependables through `APIRouter` means that all the REST
    API services registered in that `APIRouter` will always trigger the executions
    of these dependencies. The dependencies can only work with API services designed
    to persist the like of the `user` and `login` details, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `APIRouter` 注入这两个依赖项意味着在该 `APIRouter` 中注册的所有 REST API 服务都将始终触发这些依赖项的执行。这些依赖项只能与设计用于持久化
    `user` 和 `login` 详情的 API 服务一起工作，如下所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`check_credential_error()`, which is injected into the `APIRouter` component,
    filters the `username` and `password` derived from the `create_login()` injectable
    function. Likewise, it filters the `create_user_details()` injectable of the `add_profile_login()`
    service, as shown in the following snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注入到 `APIRouter` 组件中的 `check_credential_error()` 会过滤从 `create_login()` 注入式函数中得到的
    `username` 和 `password`。同样，它也会过滤 `add_profile_login()` 服务的 `create_user_details()`
    注入式，如下面的片段所示：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Login` injectable class also undergoes filtering through `check_credential_error()`.
    It also contains the `username` and `password` parameters that the injectable
    function can filter. Conversely, the injectable `Profile` of the following `add_profile_login_models()`
    service is not excluded from the error-checking mechanism because it has a `Login`
    dependency in its constructor. Having the `Login` dependable means `check_cedential_error()`
    will also filter `Profile`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login` 注入式类也会通过 `check_credential_error()` 进行过滤。它也包含注入式函数可以过滤的 `username`
    和 `password` 参数。相反，以下 `add_profile_login_models()` 服务的 `Profile` 注入式没有被排除在错误检查机制之外，因为它在其构造函数中有一个
    `Login` 依赖。拥有 `Login` 依赖意味着 `check_cedential_error()` 也会过滤 `Profile`。'
- en: 'With `check_credential_error()` is the `count_user_by_type()` injectable that
    counts the number of users that access the API service:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `check_credential_error()` 是 `count_user_by_type()` 注入式，用于统计访问 API 服务的用户数量：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A dependency function wired into `APIRouter` should apply defensive programming
    and a proper `try-except` to avoid parameter conflicts with the API services.
    If we were to run `check_credential_error()` with a `list_all_user()` service,
    for instance, expect some runtime problems because there is no `login` persistence
    involved during data retrieval.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到 `APIRouter` 的依赖函数应该应用防御性编程和适当的 `try-except` 来避免与 API 服务发生参数冲突。例如，如果我们用 `list_all_user()`
    服务运行 `check_credential_error()`，可能会遇到一些运行时问题，因为在数据检索期间没有涉及 `login` 持久化。
- en: Important Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Like its path operators, the constructor of `APIRouter` can also accept more
    than one injectable because its `dependencies` parameter will allow a `List` (`[]`)
    of valid ones.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于其路径操作符，`APIRouter` 的构造函数也可以接受多个注入式，因为它的 `dependencies` 参数将允许一个 `List` (`[]`)
    的有效值。
- en: Dependency injection on main.py
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 main.py 上的依赖注入
- en: There are portions of the software that are very hard to automate because of
    their vast and complex scopes, so considering them will always be a waste of time
    and effort. These *cross-cutting concerns* span from the UI level down to the
    data tier, which explains why these functionalities are impractical and even inconceivable
    to manage and implement using typical programming paradigms. These cross-cutting
    concerns are transactions such as *exception logging*, *caching*, *instrumentation*,
    and *user authorization*, common to any application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于范围广泛且复杂，软件的某些部分很难自动化，因此考虑它们将始终是时间和精力的浪费。这些 *横切关注点* 从 UI 层到数据层，这解释了为什么这些功能在实际管理和实现上是不切实际的，甚至难以想象。这些横切关注点包括如
    *异常记录*、*缓存*、*监控* 和 *用户授权* 等事务，这些是任何应用程序都共有的。
- en: 'FastAPI has an easy remedy to address these *features*: to create them as injectables
    to the FastAPI instance of `main.py`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 有一个简单的解决方案来解决这些 *特性*：将它们作为可注入到 `main.py` 的 FastAPI 实例中的可注入项：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding `log_transaction()` is a simple logger of the `URL` paths invoked
    or accessed by the client. While the application is running, this cross-cut should
    propagate the repository with different URLs coming from any `APIRouter`. This
    task can only happen when we inject this function through the FastAPI instance
    of `main.py`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `log_transaction()` 是一个简单的记录器，用于记录客户端调用的或访问的 `URL` 路径。当应用程序运行时，这个跨切面应该将不同的
    `APIRouter` 发来的不同 `URL` 传播到存储库中。这项任务只能在通过 `main.py` 的 FastAPI 实例注入这个函数时发生：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Dependencies *auto-wired* to the FastAPI constructor are known as *global dependencies*
    because they are accessible by any REST APIs from the routers. For instance, `log_transaction()`,
    depicted in the preceding script, will execute every time the APIs from the `recipes`,
    `users`, `posts`, or `complaints` routers process their respective request transactions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与 FastAPI 构造函数自动连接的依赖项被称为 *全局依赖项*，因为它们可以通过任何路由器的 REST API 访问。例如，前面脚本中描述的 `log_transaction()`
    将在 `recipes`、`users`、`posts` 或 `complaints` 路由器处理它们各自的请求事务时执行。
- en: Important Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Like `APIRouter`, the constructor of `FastAPI` allows more than function dependency.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `APIRouter` 类似，`FastAPI` 的构造函数允许更多的函数依赖。
- en: Aside from these strategies, DI can also help us organize our application by
    having `repository`, `service`, and `model` layers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些策略之外，依赖注入（DI）还可以通过拥有 `repository`、`service` 和 `model` 层来组织我们的应用程序。
- en: Organizing a project based on dependencies
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于依赖关系组织项目
- en: It is feasible to use a *repository-service* pattern in some complex FastAPI
    applications through DI. The repository-service pattern is responsible for the
    creation of the **repository layer** of the application, which manages the Creation,
    Reading, Updates, and Deletion (CRUD) of data source. A repository layer requires
    **data models** that depict the table schemas of a collection or database. The
    repository layer needs the **service layer** to establish a connection with other
    parts of the application. The service layer operates like a business layer, where
    the data sources and business processes meet to derive all the necessary objects
    needed by the REST API. The communication between the repository and service layers
    can only be possible by creating injectables. Now, let us explore how the layers
    shown in *Figure 3.2* are built by DI using injectable components.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些复杂的 FastAPI 应用程序中，可以通过依赖注入（DI）使用 *存储库-服务* 模式。存储库-服务模式负责创建应用程序的 **存储库层**，该层管理数据源的增加、读取、更新和删除（CRUD）。存储库层需要
    **数据模型** 来描述集合或数据库的表结构。存储库层需要 **服务层** 来与其他应用程序部分建立连接。服务层就像一个业务层，数据源和业务流程在这里相遇，以生成
    REST API 所需的所有必要对象。存储库和服务层之间的通信只能通过创建可注入项来实现。现在，让我们通过可注入组件来探索 *图 3.2* 中显示的层是如何构建的。
- en: '![Figure 3.2 – The repository-service layers](img/Figure_3.2_B17975.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 存储库-服务层](img/Figure_3.2_B17975.jpg)'
- en: Figure 3.2 – The repository-service layers
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 存储库-服务层
- en: The model layer
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型层
- en: 'This layer is purely composed of *resources*, *collections*, and *Python classes*
    that can be used by the repository layer to create CRUD transactions. Some model
    classes are dependable on other models, but some are just independent blueprints
    designed for data placeholder. Some of the application’s model classes that store
    recipe-related details are shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The repository layer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layer is composed of class dependencies, which have access to the *data
    store* or improvised `dict` repositories, just like in our *online recipe system*.
    Together with the model layer, these repository classes build the CRUD transactions
    needed by the REST API. The following is an implementation of `RecipeRepository`
    that has two transactions, namely `insert_recipe()` and `query_recipes()`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Its constructor is used to populate the recipes with some initial data. The
    constructor of an *injectable repository* class plays a role in datastore setup
    and configuration, and this is where we *auto-wire* dependency if there is any.
    Conversely, the implementation includes two `Enum` classes – `Category` and `Origin`
    – which provide lookup values to the recipe’s menu category and place of origin
    respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The repository factory methods
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layer uses the *factory design pattern* to add a more loose coupling design
    between the repository and service layer. Although this approach is optional,
    this is still an option to manage the threshold of interdependency between the
    two layers, especially when there are frequent changes in the performance, processes,
    and results of the CRUD transactions. The following are the repository factory
    methods used by our application:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see from the preceding script that `RecipeRepository` is a dependable
    object of the factory methods, which are also injectable components but of the
    service layer. For instance, `get_recipe_repo()` will be wired to a service class
    to pursue the implementation of native services that require some transactions
    from `RecipeRepository`. In a way, we are indirectly wiring the repository class
    to the service layer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The service layer
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layer has all the application’s services with the domain logic, such as
    our `RecipeService`, which provides business processes and algorithms to `RecipeRepository`.
    The `get_recipe_repo()` factory is injected through its constructor to provide
    CRUD transactions from `RecipeRepository`. The injection strategy used here is
    the function of class dependency, which is depicted in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The constructor of a typical Python class is always the appropriate place to
    inject components, which can either be a function or class dependable. With the
    preceding `RecipeService`, its `get_recipes()` and `add_recipe()` are realized
    because of the transactions derived from `get_recipe_repo()`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The REST API and the service layer
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The REST API methods can directly inject the service class or factory method
    if it needs to access the service layer. In our application, there is a factory
    method associated with each service class to apply the same strategy used in the
    `RecipeRepository` injection. That is why, in the following script, the `get_recipe_service()`
    method is wired to the REST API instead of `RecipeService`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `insert_recipe()` is a REST API that accepts a recipe and its ingredients
    from a client for persistency, while `get_all_recipes()` returns `List[Recipe]`
    as a response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The actual project structure
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the power of DI, we have created an *online recipe system* with an organized
    set of *models*, *repository*, and *service* layers. The project structure shown
    in *Figure 3.3* is quite different from the previous prototypes because of the
    additional layers, but it still has `main.py` and all the packages and modules
    with their respective `APIRouter`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The Online Recipe System’s project structure](img/Figure_3.3_B17975.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The Online Recipe System’s project structure
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, DI has offered many advantages to FastAPI applications, from
    the engineering of object instantiation to breaking down monolithic components
    to set up loosely coupled structures. But there is only one slight problem: FastAPI’s
    default container. The framework’s container has no easy configuration to set
    all its managed objects to a *singleton* scope. Most applications prefer fetching
    singleton objects to avoid wasting memory in the **Python Virtual Machine** (**PVM**).
    Moreover, the built-in container is not open to a more detailed container configuration,
    such as having a *multiple container* setup. The next series of discussions will
    focus on the limitation of FastAPI’s default container and solutions to overcome
    it.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party containers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI has a lot to offer to improve our application, but it still depends on the
    framework we use to get the full potential of this design pattern. FastAPI’s container
    is very acceptable to some when the concerns are simply on object management and
    project organization. However, when it comes to configuring the container to add
    more advanced features, it is not feasible for short-term projects, and it will
    be impossible for huge applications due to constraints. So, the practical way
    is to rely on *third-party modules* for the set of utilities needed to support
    all these advancements. So, let us explore these popular external modules that
    integrate seamlessly with FastAPI, the *Dependency Injector* and *Lagom*, which
    we can use to set up a complete and manageable container.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Using configurable containers – Dependency Injector
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to configurable containers, the *Dependency Injector* has several
    module APIs that can be used to build variations of custom containers that can
    manage, assemble, and inject objects. But before we can use this module, we need
    to install it first using `pip`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The containers and providers module
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Among all the API types, *Dependency Injector* is popular with its *containers*
    and *providers*. One of its container types is `DeclarativeContainer`, which can
    be subclassed to contain all its providers. Its providers can be `Factory`, `Dict`,
    `List`, `Callable`, `Singleton`, or other *containers*. Both the `Dict` and `List`
    providers are easy to set up because they only need `list` and `dict` respectively
    to be instantiated. A `Factory` provider, conversely, instantiates any class,
    such as a repository, service, or a generic Python class, while `Singleton` only
    creates one instance per class, which is valid throughout the application’s runtime.
    The `Callable` provider manages function dependencies, while `Container` instantiates
    other containers. Another container type is `DynamicContainer`, which is built
    from a configuration file, databases, or other resources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The container types
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Aside from these container APIs, the *Dependency Injector* allows us to customize
    a container based on the volume of the dependable objects, project structure,
    or other criteria from the project. The most common style or setup is the single
    declarative container that fits in small-, medium-, or large-scale applications.
    Our *o**nline recipe system* prototype owns a single declarative container, which
    is implemented in the following script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By simply subclassing `DeclarativeContainer`, we can easily create a single
    container, with its instances injected by the various providers previously mentioned.
    `LoginRepository` and `KeywordRepository` are both injected as new instances through
    the Factory provider. `AdminRepository` is an injected singleton object, `get_recipe_names()`
    is an injected function dependable, and `login_details` is an injected dictionary
    containing login credentials.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI and Dependency Injector integration
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To wire the dependencies to a component through the Dependency Injector, the
    `@inject` decorator is applied. `@inject` is imported from the `dependency_injector.wiring`
    module and is decorated over the *dependent* component.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, the instance will be fetched from the container using the `Provide`
    wiring marker. Wiring markers search for the `Provider` object that references
    the injectable in the container, and if it exists, it will prepare for *auto-wiring*.
    Both `@inject` and `Provide` belong to the same API module:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The integration happens when the `Depends()` function directive is invoked to
    register the wiring marker and the `Provider` instance to FastAPI. Aside from
    the acknowledgment, the registration adds *type hints* and *Pydantic validation
    rules* to the third-party `Provider` to appropriately wire the injectables into
    FastAPI. The preceding script imports `Container` from its module to wire `KeywordRepository`
    through `@inject`, the wire marker, and the `keywordservice` `Provider` of *Dependency
    Injector*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last piece of the puzzle is to *assemble*, *create*, and *deploy*
    the single declarative container through the FastAPI platform. This last integration
    measure requires instantiating the *container* inside the module where the injections
    happened and then invoking its `wire()` method, which builds the assemblage. Since
    the preceding `insert_recipe_keywords()` is part of `/api/keywords.py`, we should
    add the following lines in the `keywords` module script, particularly at its end
    portion:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The multiple container setup
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For large applications, the number of repository transactions and services increases
    based on the functionality and special features of the application. If the single
    declarative type becomes unfeasible for a growing application, then we can always
    replace it with a *multiple-container* setup.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency Injector allows us to create a separate container for each group
    of services. Our application has created a sample setup found in `/containers/multiple_containers.py`,
    just in case this prototype becomes full-blown. That sample of multiple declarative
    containers is shown as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Based on the preceding configuration, the three different instances of `DeclarativeContainer`
    created are `KeywordsContainer`, `AdminContainer`, and `LoginContainer`. The `KeywordsContainer`
    instance will assemble all dependencies related to keywords, `AdminContainer`
    will hold all instances related to administrative tasks, and `LoginContainer`
    for login- and user-related services. Then, there is `RecipeAppContainer`, which
    will consolidate all these containers through DI also.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The injection of the dependencies to the API is like the single declarative
    style, except that the container needs to be indicated in the wiring marker. The
    following is an admin-related API that shows how we wire dependencies to REST
    services:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The presence of `admincontainer` inside `Provide` checks first for the container
    of the same name before it fetches the `adminservice` provider that references
    the service dependable. The rest of the details are just the same with a single
    declarative, including the FastAPI integration and object assembly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: What is highlighted here about *Dependency Injector* is just basic configurations
    for simple applications. There are still other features and integrations that
    this module can provide to optimize our application using DI. Now, if we need
    thread-safe and non-blocking but with simple, streamlined, and straightforward
    APIs, setup and configuration, there is the *Lagom* module.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Using a simple configuration – Lagom
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third-party *Lagom* module is widely used because of its simplicity when
    it comes to wiring dependables. It is also ideal for building asynchronous microservice-driven
    applications because it is thread-safe at runtime. Moreover, it can easily integrate
    into many web frameworks, including FastAPI. To apply its APIs, we need to install
    it first using `pip`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The container
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Containers in *Lagom* are created instantly using the `Container` class from
    its module. Unlike in *Dependency Injector*, Lagom’s containers are created before
    the injection happens inside the module of the REST APIs:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All dependables are injected into the container through typical instantiation.
    The container behaves like a `dict` when adding new dependables because it also
    uses a *key-value pair* as an entry. When we inject an object, the container needs
    its class name as its *key* and the instance as its *value*. Moreover, the DI
    framework also allows instantiation with arguments if the constructors require
    some parameter values.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The FastAPI and Lagom integration
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before the wiring happens, integration to the FastAPI platform must come first
    by instantiating a new API class called `FastApiIntegration`, which is found in
    the `lagom.integrations.fast_api` module. It takes `container` as a required parameter:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The dependables
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The instance of `FastAPIIntegration` has a `depends()` method, which we will
    use to perform the injection. One of the best features of Lagom is its easy and
    seamless integration mechanism into any framework. Thus, wiring the dependencies
    will not need FastAPI’s `Depends()` function anymore:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding `report_recipe()` utilizes `BadRecipeRepository` as an injectable
    service. Since it is part of the container, *Lagom*’s `depends()` function will
    search for the object in the container, and then it will be wired to the API service,
    if that exists, to save the complaints to the `dict` datastore.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, these two third-party modules are the most popular and elaborative
    when employing DI in our applications. These modules may change through future
    updates, but one thing is for sure: IoC and DI design patterns will always be
    the powerful solution in managing memory usage in an application. Let us now discusses
    issues surrounding memory space, container, and object assembly.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Scoping of dependables
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In FastAPI, the scope of dependables can be either a new instance or a singleton.
    FastAPI’s DI does not support the creation of singleton objects by default. In
    every execution of an API service with dependencies, FastAPI always fetches a
    new instance of each wired dependable, which can be proven by getting the *object
    ID* using `id()`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: A `singleton` object is created only once by a container, no matter how many
    times the framework injects it. Its *object ID* remains the same the entire runtime
    of the application. Services and repository classes are preferred to be singleton
    to control the increase of memory utilization of the application. And since it
    is not easy to create a singleton with FastAPI, we can use either *Dependency
    Injector* or *Lagom*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `Singleton` provider in Dependency Injector that is responsible
    for the creation of singleton dependencies. This provider was mentioned already
    during the discussions on its `DeclarativeContainer` setup. With Lagom, there
    are two ways to create singleton injectables: (a) using its `Singleton` class,
    and (b) through the constructor of `FastAPIIntegration`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Singleton` class wraps the instance of the dependency before injecting
    it into the container. The following sample snippet shows one example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The other way is to declare the dependency in the `request_singletons` parameter
    of the constructor of `FastAPIIntegration`. The following snippet shows how it
    is done:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By the way, the `request_singletons` parameter is a `List` type, so it will
    allow us to declare at least one dependable when we want to make singletons.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect that makes a framework easy and practical to use is its support for
    the IoC principle. FastAPI has a built-in container that we can utilize to establish
    dependency among components. The use of a *DI* pattern to integrate all these
    components through wiring is a strong prerequisite in building microservice-driven
    applications. From simple injection using `Depends()`, we can extend DI to build
    pluggable components for database integration, authentication, security, and unit
    testing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced some third-party modules such as *Dependency Injector*
    and *Lagom* that can design and customize containers. Because of the limitations
    of FastAPI on DI, there are external libraries that can help extend its responsibility
    to assemble, control, and manage object creation in a container. These third-party
    APIs can also create singleton objects, which can help decrease the heap size
    in the PVM.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Aside from performance tuning and memory management, DI can contribute to the
    organization of a project, especially huge applications. The addition of model,
    repository, and service layers is a remarkable effect of creating dependencies.
    Injection opens the development to other design patterns, such as factory method,
    service, and data access object patterns. In the next chapter, we will start to
    build some microservice-related components based on the core design patterns of
    microservices.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
