- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Investigating Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the first chapter, `BaseModel`, `Request`, `Response`, and `BackgroundTasks`
    in their processes. Applying DI proves that instantiating some FastAPI classes
    is not always the ideal approach, since the framework has a built-in container
    that can provide the objects of these classes for the API services. This method
    of object management makes FastAPI easy and efficient to use.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI has a container where the DI policy is applied to instantiate module
    classes and even functions. We only need to specify and declare these module APIs
    to the services, middleware, authenticator, data sources, and test cases because
    the rest of the object assembly, management, and instantiation is now the responsibility
    of the built-in container.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you to understand how to manage objects needed by the
    application, such as minimizing some instances and creating loose bindings among
    them. Knowing the effectiveness of DI on FastAPI is the first step in designing
    our microservice applications. Our discussions will focus on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Applying **Inversion of Control** (**IoC**) and DI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring ways of injecting dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing a project based on dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using third-party containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoping of instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses a software prototype called *online recipe system*, which
    manages, evaluates, rates, and reports recipes of different types and origins.
    Applying a DI pattern is the priority of this project, so expect some changes
    in the development strategies and approaches, such as adding `model`, `repository`,
    and `service` folders. This software is for food enthusiasts or chefs who want
    to share their specialties, newbies looking for recipes to experiment with, and
    guests who just like to browse through different food menus. This open-ended application
    does not use any database management system yet, so all the data is temporarily
    stored in Python containers. Code is all uploaded at [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI/tree/main/ch03).
  prefs: []
  type: TYPE_NORMAL
- en: Applying IoC/DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FastAPI is a framework that supports the IoC principle, which means that it
    has a container that can instantiate objects for an application. In a typical
    programming scenario, we instantiate classes to use them in many ways to build
    a running application. But with IoC, the framework instantiates the components
    for the application. *Figure 3.1* shows the whole picture of the IoC principle
    and the participation of one of its forms, called the DI.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The IoC principle](img/Figure_3.1_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The IoC principle
  prefs: []
  type: TYPE_NORMAL
- en: For FastAPI, DI is not only a principle but a mechanism to integrate an object
    into a component that leads to creating a *loosely coupled* but *highly cohesive*
    software structure. Almost all components can be candidates for DI, including
    *functions*. But for now, let us focus on *callable components* that provide some
    JSON objects once they are injected into an API service – injectable and callable
    components that we call *dependency functions*.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a dependency function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `create_login()`, as shown in the following code, which is in the project’s
    `/api/users.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The function requires the `id`, `username`, and `password` parameters and `type`
    to continue its process and return a valid JSON `account` object, derived from
    these parameters. A dependency function sometimes uses some underlying formula,
    resource, or complex algorithms to derive its function value, but for now, we
    utilize it as a *placeholder of data* or `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common to dependency functions are method parameters that serve as placeholders
    to a REST API’s incoming request. These are wired into the API’s method parameter
    list as a domain model to the query parameters or request body through DI. The
    `Depends()` function from the `fastapi` module pursues the injection before it
    wires the injectable to a local parameter. The module function can only take one
    parameter for injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is a code fragment from our *online recipe system* that shows
    how `Depends()` injects `create_login()`into the framework’s container and fetches
    its instance for *wiring* to the `populate_user_accounts()` service. Syntactically,
    the injection process only needs the name of the function dependency without the
    parenthesis. Again, the purpose of `create_login()` is to capture the query parameters
    of the API service. The `jsonable_encoder()` is very useful to many APIs in converting
    these injectables to JSON-compatible types such as `dict`, which are essential
    for *instantiating the needed data models* and *generating responses*.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The term **dependencies** can be used interchangeably with **injectables**,
    **dependables**, **resources**, **providers**, or **components**.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a callable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'FastAPI also allows classes to be injected into any components, since they
    can also be considered *callable* components. A class becomes *callable* during
    instantiation when the call to its constructor, `__init__(self)`, is done. Some
    of these classes have *no-arg* constructors, while others, such as the following
    `Login` class, require constructor arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Login` class, located in `/model/users.py`, needs `id`, `username`, `password`,
    and `type` passed to its constructor before the instantiation. A possible instantiation
    would be `Login(id=' 249a0837-c52e-48cd-bc19-c78e6099f931', username='admin',
    password='admin2255', type=UserType.admin)`. Overall, we can observe the similarity
    between a class and a dependency function based on their callable behavior and
    the ability to capture request data, such as a model attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, the `populate_login_without_service()` shown in the following code
    block shows how `Depends()` injects `Login` to the service. The `Depends()` function
    tells the built-in container to instantiate `Login` and fetches that instance,
    ready to be assigned to the `user_account` local parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: All dependencies should be declared at the right-most part of the service’s
    parameter list. If there are query, path, or form parameters, injectables should
    come last. Moreover, the use of the `jsonable_encoder()` function can be an option
    if the *injectables* do not contain data that are hard to encode by default.
  prefs: []
  type: TYPE_NORMAL
- en: Building nested dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some scenarios when injectables are also dependent on other dependencies.
    When we inject a function dependency to another function, a class dependency to
    another class injectable, or a function resource to a class, the goal is to build
    nested dependencies. Nested dependencies are beneficial to REST APIs, with lengthy
    and complex request data that needs structuring and grouping through sub-domain
    models. These sub-domains or domain models within a model are later encoded as
    sub-dependencies into JSON-compatible types by FastAPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding asynchronous `create_user_details()` function shows that even
    a dependency function needs another dependency to satisfy its purpose. This function
    is dependent on `create_login()`, which is another dependable component. With
    this nested dependency setup, wiring the `create_user_details()` into an API service
    also includes the injection of `create_login()` into the container. In short,
    there is a chain of DIs that will be created when nested dependencies are applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `add_profile_login()` service provides a clear picture of its
    dependency on `create_user_details()`, including its underlying login details.
    The FastAPI container successfully created the two functions through chained DI
    to capture the request data during the API’s request transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, a class can also be dependable on another class. An example is
    the `Profile` class, shown here, which is dependent on `UserDetails` and `Login`
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is a nested dependency here because two classes will be injected altogether
    once `Profile` is wired to a REST API service.
  prefs: []
  type: TYPE_NORMAL
- en: 'A clear advantage of these chained dependencies is depicted in the following
    `add_profile_login_models()` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The extraction of `profile.user` and `profile.login` makes it easier for the
    service to identify what query data to deserialize. It also helps the service
    determine which group of data needs `Login` instantiation and which is for `UserDetails`.
    As a result, it will be easier to manage the persistency of these objects in their
    respective `dict` repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating explicit dependencies between function and class will be discussed
    later, but for now, let us examine how to fine-tune whenever we use lots of these
    nested dependencies in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Caching the dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All dependencies are *cacheable*, and FastAPI caches all these dependencies
    during a request transaction. If a dependable is common to all services, FastAPI
    will not allow you to fetch these objects from its container *by default*. Rather,
    it will look for this injectable from its cache to be used multiple times across
    the API layer. Saving dependencies, especially nested ones, is a good feature
    of FastAPI because it optimizes the performance of the REST service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, `Depends()` has a `use_cache` parameter that we can set to `False`
    if we want to bypass this caching mechanism. Configuring this hook will not save
    the dependencies from the cache during request transactions, allowing `Depends()`
    to fetch the instances from the container more frequently. Another version of
    the `add_profile_login_models()` service, shown here, shows how to disable dependency
    caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another obvious change in the preceding service implementation is the presence
    of the `Profile` data type in the local parameter declaration. Is this really
    allowed by FastAPI?
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Depends() parameter types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generally, we do not declare types of the local parameters that will reference
    the injected dependencies. Due to *type hints*, we can optionally associate the
    references with their appropriate object types. For instance, we can re-implement
    `populate_user_accounts()` to include the type of `user_account`, such as the
    following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This scenario happens very rarely, since `create_login()` is a dependency function,
    and we usually do not create classes only to provide the blueprint type of its
    returned values. But when we use class dependables, declaring the appropriate
    class type to the wired object is feasible, as in the following `add_profile_login_models()`
    service, which declares the `profile` parameter as `Profile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the declaration is syntactically valid, the expression looks *repetitive*
    and *redundant* because the `Profile` type appears twice in the declaration portion.
    To avoid this redundancy, we can replace the statement with a shorthand version
    by omitting the class name inside the `Depends()` function. Thus, a better way
    of declaring the preceding `profile` should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The changes reflected on the parameter list will not affect the performance
    of the request transaction of the `add_profile_login_models()` service.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting asynchronous dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A FastAPI built-in container does not only manage *synchronous* function dependables
    but also *asynchronous* ones. The following `create_user_details()` is an asynchronous
    dependency, read to be wired to a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The container can manage both synchronous and asynchronous function dependency.
    It can allow the wiring of *asynchronous dependables* on an asynchronous API service
    or some *asynchronous ones* on a synchronous API. In cases where the dependency
    and the services are both asynchronous, applying the `async`/`await` protocol
    is recommended to avoid discrepancies in the results. `create_user_details()`,
    which is dependent on a synchronous `create_login()`, is wired on `add_profile_login()`,
    which is an asynchronous API.
  prefs: []
  type: TYPE_NORMAL
- en: After learning how DI design pattern works in FastAPI, the next step is to know
    the different levels of strategy for applying `Depends()` in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring ways of injecting dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the previous discussions, we know that FastAPI has a built-in container
    through which some objects are injected and instantiated. Likewise, we have learned
    that the only FastAPI components that are injectables are those so-called dependables,
    injectables, or dependencies. Now, let us enumerate different ways to pursue the
    DI pattern in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection on services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common area where DI occurs is in the *parameter list* of a service
    method. Any discussions regarding this strategy have been tackled already in the
    previous examples, so we only need to present additional points concerning this
    strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the number of custom injectables a service method should take is also
    part of the concern. When it comes to complex query parameters or request bodies,
    API services can take more than one injectable as long as there are no similar
    instance variable names among these dependables. This *variable name collision*
    among the dependables will lead to having one parameter entry for the conflicted
    variable during the request transactions, thus sharing the same value for all
    these conflicting variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, the appropriate *HTTP method operation* to work with the injectables
    is also one aspect to consider. Both function and class dependencies can work
    with the `GET`, `POST`, `PUT`, and `PATCH` operations, except for those dependables
    with attribute types such as numeric `Enum` and `UUID` that can cause an *HTTP
    Status 422* (**Unprocessable Entity**) due to conversion problems. We must plan
    which HTTP method is applicable for some dependable(s) first, before implementing
    the service method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Third, not all dependables are placeholders of request data. Unlike the class
    dependables, dependency functions are not specifically used for returning objects
    or `dict`. Some of them are used in *filtering request data*, *scrutinizing authentication
    details*, *managing form data*, *verifying header values*, *handling cookies*,
    and *throwing some errors* when there are violations of some rules. The following
    `get_all_recipes()` service is dependent on a `get_recipe_service()` injectable
    that will query all the recipes from the `dict` repository of the application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The dependency function provides the needed transactions such as saving and
    retrieving records of recipes. Instead of the usual instantiation or method call,
    a better strategy is to inject these *dependable services* into the API implementation.
    The `handler` method parameter, which refers to the instance of `get_recipe_service()`,
    invokes the `get_recipes()` transactions of a particular service to retrieve all
    the menus and ingredients stored in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection on path operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is always an option to implement *triggers*, *validators*, and *exception
    handlers* as injectable functions. Since these dependables work like *filters*
    to the incoming request, their injection happens in the *path operator* and not
    in the service parameter list. The following code is an implementation of the
    `check_feedback_length()` validator, found in `/dependencies/posts.py`, which
    checks whether the feedback posted by a user regarding a recipe should be at least
    20 characters, including spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The validator pauses the API execution to retrieve the feedback from a post
    to be validated *if its length is lower than 20*. If the dependency function finds
    it `True`, it will throw an *HTTP Status 403*. Alternatively, it will emit a *Status
    Code 500* if the feedback is missing from the request data; otherwise, it will
    let the API transaction finish its task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to the `create_post()` and `post_service()` dependables, the following
    script shows that the `check_feedback_length()` validator is not invoked anywhere
    inside the `insert_post_feedback()` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The validator will always work closely with the incoming request transaction,
    whereas the other two injectables, `post` and `handler`, are part of the API’s
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The path router of `APIRouter` can accommodate more than one injectable, which
    is why its `dependencies` parameter always needs a `List` value (`[]`).
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection on routers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'However, some transactions are not localized to work on one specific API. There
    are dependency functions created to work with a certain group of REST API services
    within an application, such as the following `count_user_by_type()` and `handler
    check_credential_error()` events that are designed to manage incoming requests
    of REST APIs under the `user.router` group. This strategy requires DI at the `APIRouter`
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding implementations, the goal of `count_user_by_type()` is
    to build an updated frequency of users in `stats_user_type` according to `UserType`.
    Its execution starts right after the REST API receives a new user and login details
    from the client. While it checks the `UserType` of the new record, the API service
    pauses briefly and resumes after the function dependency has completed its tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, the task of `check_credential_error()` is to ensure that the `username`
    and `password` of the new user should not be the same. It throws an *HTTP Status
    403* when the credentials are the same, which will halt the whole REST service
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Injecting these two dependables through `APIRouter` means that all the REST
    API services registered in that `APIRouter` will always trigger the executions
    of these dependencies. The dependencies can only work with API services designed
    to persist the like of the `user` and `login` details, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`check_credential_error()`, which is injected into the `APIRouter` component,
    filters the `username` and `password` derived from the `create_login()` injectable
    function. Likewise, it filters the `create_user_details()` injectable of the `add_profile_login()`
    service, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `Login` injectable class also undergoes filtering through `check_credential_error()`.
    It also contains the `username` and `password` parameters that the injectable
    function can filter. Conversely, the injectable `Profile` of the following `add_profile_login_models()`
    service is not excluded from the error-checking mechanism because it has a `Login`
    dependency in its constructor. Having the `Login` dependable means `check_cedential_error()`
    will also filter `Profile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `check_credential_error()` is the `count_user_by_type()` injectable that
    counts the number of users that access the API service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A dependency function wired into `APIRouter` should apply defensive programming
    and a proper `try-except` to avoid parameter conflicts with the API services.
    If we were to run `check_credential_error()` with a `list_all_user()` service,
    for instance, expect some runtime problems because there is no `login` persistence
    involved during data retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Like its path operators, the constructor of `APIRouter` can also accept more
    than one injectable because its `dependencies` parameter will allow a `List` (`[]`)
    of valid ones.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection on main.py
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are portions of the software that are very hard to automate because of
    their vast and complex scopes, so considering them will always be a waste of time
    and effort. These *cross-cutting concerns* span from the UI level down to the
    data tier, which explains why these functionalities are impractical and even inconceivable
    to manage and implement using typical programming paradigms. These cross-cutting
    concerns are transactions such as *exception logging*, *caching*, *instrumentation*,
    and *user authorization*, common to any application.
  prefs: []
  type: TYPE_NORMAL
- en: 'FastAPI has an easy remedy to address these *features*: to create them as injectables
    to the FastAPI instance of `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `log_transaction()` is a simple logger of the `URL` paths invoked
    or accessed by the client. While the application is running, this cross-cut should
    propagate the repository with different URLs coming from any `APIRouter`. This
    task can only happen when we inject this function through the FastAPI instance
    of `main.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Dependencies *auto-wired* to the FastAPI constructor are known as *global dependencies*
    because they are accessible by any REST APIs from the routers. For instance, `log_transaction()`,
    depicted in the preceding script, will execute every time the APIs from the `recipes`,
    `users`, `posts`, or `complaints` routers process their respective request transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Like `APIRouter`, the constructor of `FastAPI` allows more than function dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from these strategies, DI can also help us organize our application by
    having `repository`, `service`, and `model` layers.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing a project based on dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is feasible to use a *repository-service* pattern in some complex FastAPI
    applications through DI. The repository-service pattern is responsible for the
    creation of the **repository layer** of the application, which manages the Creation,
    Reading, Updates, and Deletion (CRUD) of data source. A repository layer requires
    **data models** that depict the table schemas of a collection or database. The
    repository layer needs the **service layer** to establish a connection with other
    parts of the application. The service layer operates like a business layer, where
    the data sources and business processes meet to derive all the necessary objects
    needed by the REST API. The communication between the repository and service layers
    can only be possible by creating injectables. Now, let us explore how the layers
    shown in *Figure 3.2* are built by DI using injectable components.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The repository-service layers](img/Figure_3.2_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The repository-service layers
  prefs: []
  type: TYPE_NORMAL
- en: The model layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layer is purely composed of *resources*, *collections*, and *Python classes*
    that can be used by the repository layer to create CRUD transactions. Some model
    classes are dependable on other models, but some are just independent blueprints
    designed for data placeholder. Some of the application’s model classes that store
    recipe-related details are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The repository layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layer is composed of class dependencies, which have access to the *data
    store* or improvised `dict` repositories, just like in our *online recipe system*.
    Together with the model layer, these repository classes build the CRUD transactions
    needed by the REST API. The following is an implementation of `RecipeRepository`
    that has two transactions, namely `insert_recipe()` and `query_recipes()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Its constructor is used to populate the recipes with some initial data. The
    constructor of an *injectable repository* class plays a role in datastore setup
    and configuration, and this is where we *auto-wire* dependency if there is any.
    Conversely, the implementation includes two `Enum` classes – `Category` and `Origin`
    – which provide lookup values to the recipe’s menu category and place of origin
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The repository factory methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layer uses the *factory design pattern* to add a more loose coupling design
    between the repository and service layer. Although this approach is optional,
    this is still an option to manage the threshold of interdependency between the
    two layers, especially when there are frequent changes in the performance, processes,
    and results of the CRUD transactions. The following are the repository factory
    methods used by our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the preceding script that `RecipeRepository` is a dependable
    object of the factory methods, which are also injectable components but of the
    service layer. For instance, `get_recipe_repo()` will be wired to a service class
    to pursue the implementation of native services that require some transactions
    from `RecipeRepository`. In a way, we are indirectly wiring the repository class
    to the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: The service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This layer has all the application’s services with the domain logic, such as
    our `RecipeService`, which provides business processes and algorithms to `RecipeRepository`.
    The `get_recipe_repo()` factory is injected through its constructor to provide
    CRUD transactions from `RecipeRepository`. The injection strategy used here is
    the function of class dependency, which is depicted in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of a typical Python class is always the appropriate place to
    inject components, which can either be a function or class dependable. With the
    preceding `RecipeService`, its `get_recipes()` and `add_recipe()` are realized
    because of the transactions derived from `get_recipe_repo()`.
  prefs: []
  type: TYPE_NORMAL
- en: The REST API and the service layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The REST API methods can directly inject the service class or factory method
    if it needs to access the service layer. In our application, there is a factory
    method associated with each service class to apply the same strategy used in the
    `RecipeRepository` injection. That is why, in the following script, the `get_recipe_service()`
    method is wired to the REST API instead of `RecipeService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `insert_recipe()` is a REST API that accepts a recipe and its ingredients
    from a client for persistency, while `get_all_recipes()` returns `List[Recipe]`
    as a response.
  prefs: []
  type: TYPE_NORMAL
- en: The actual project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the power of DI, we have created an *online recipe system* with an organized
    set of *models*, *repository*, and *service* layers. The project structure shown
    in *Figure 3.3* is quite different from the previous prototypes because of the
    additional layers, but it still has `main.py` and all the packages and modules
    with their respective `APIRouter`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – The Online Recipe System’s project structure](img/Figure_3.3_B17975.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – The Online Recipe System’s project structure
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, DI has offered many advantages to FastAPI applications, from
    the engineering of object instantiation to breaking down monolithic components
    to set up loosely coupled structures. But there is only one slight problem: FastAPI’s
    default container. The framework’s container has no easy configuration to set
    all its managed objects to a *singleton* scope. Most applications prefer fetching
    singleton objects to avoid wasting memory in the **Python Virtual Machine** (**PVM**).
    Moreover, the built-in container is not open to a more detailed container configuration,
    such as having a *multiple container* setup. The next series of discussions will
    focus on the limitation of FastAPI’s default container and solutions to overcome
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Using third-party containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI has a lot to offer to improve our application, but it still depends on the
    framework we use to get the full potential of this design pattern. FastAPI’s container
    is very acceptable to some when the concerns are simply on object management and
    project organization. However, when it comes to configuring the container to add
    more advanced features, it is not feasible for short-term projects, and it will
    be impossible for huge applications due to constraints. So, the practical way
    is to rely on *third-party modules* for the set of utilities needed to support
    all these advancements. So, let us explore these popular external modules that
    integrate seamlessly with FastAPI, the *Dependency Injector* and *Lagom*, which
    we can use to set up a complete and manageable container.
  prefs: []
  type: TYPE_NORMAL
- en: Using configurable containers – Dependency Injector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to configurable containers, the *Dependency Injector* has several
    module APIs that can be used to build variations of custom containers that can
    manage, assemble, and inject objects. But before we can use this module, we need
    to install it first using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The containers and providers module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Among all the API types, *Dependency Injector* is popular with its *containers*
    and *providers*. One of its container types is `DeclarativeContainer`, which can
    be subclassed to contain all its providers. Its providers can be `Factory`, `Dict`,
    `List`, `Callable`, `Singleton`, or other *containers*. Both the `Dict` and `List`
    providers are easy to set up because they only need `list` and `dict` respectively
    to be instantiated. A `Factory` provider, conversely, instantiates any class,
    such as a repository, service, or a generic Python class, while `Singleton` only
    creates one instance per class, which is valid throughout the application’s runtime.
    The `Callable` provider manages function dependencies, while `Container` instantiates
    other containers. Another container type is `DynamicContainer`, which is built
    from a configuration file, databases, or other resources.
  prefs: []
  type: TYPE_NORMAL
- en: The container types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Aside from these container APIs, the *Dependency Injector* allows us to customize
    a container based on the volume of the dependable objects, project structure,
    or other criteria from the project. The most common style or setup is the single
    declarative container that fits in small-, medium-, or large-scale applications.
    Our *o**nline recipe system* prototype owns a single declarative container, which
    is implemented in the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By simply subclassing `DeclarativeContainer`, we can easily create a single
    container, with its instances injected by the various providers previously mentioned.
    `LoginRepository` and `KeywordRepository` are both injected as new instances through
    the Factory provider. `AdminRepository` is an injected singleton object, `get_recipe_names()`
    is an injected function dependable, and `login_details` is an injected dictionary
    containing login credentials.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI and Dependency Injector integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To wire the dependencies to a component through the Dependency Injector, the
    `@inject` decorator is applied. `@inject` is imported from the `dependency_injector.wiring`
    module and is decorated over the *dependent* component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, the instance will be fetched from the container using the `Provide`
    wiring marker. Wiring markers search for the `Provider` object that references
    the injectable in the container, and if it exists, it will prepare for *auto-wiring*.
    Both `@inject` and `Provide` belong to the same API module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The integration happens when the `Depends()` function directive is invoked to
    register the wiring marker and the `Provider` instance to FastAPI. Aside from
    the acknowledgment, the registration adds *type hints* and *Pydantic validation
    rules* to the third-party `Provider` to appropriately wire the injectables into
    FastAPI. The preceding script imports `Container` from its module to wire `KeywordRepository`
    through `@inject`, the wire marker, and the `keywordservice` `Provider` of *Dependency
    Injector*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last piece of the puzzle is to *assemble*, *create*, and *deploy*
    the single declarative container through the FastAPI platform. This last integration
    measure requires instantiating the *container* inside the module where the injections
    happened and then invoking its `wire()` method, which builds the assemblage. Since
    the preceding `insert_recipe_keywords()` is part of `/api/keywords.py`, we should
    add the following lines in the `keywords` module script, particularly at its end
    portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The multiple container setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For large applications, the number of repository transactions and services increases
    based on the functionality and special features of the application. If the single
    declarative type becomes unfeasible for a growing application, then we can always
    replace it with a *multiple-container* setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependency Injector allows us to create a separate container for each group
    of services. Our application has created a sample setup found in `/containers/multiple_containers.py`,
    just in case this prototype becomes full-blown. That sample of multiple declarative
    containers is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding configuration, the three different instances of `DeclarativeContainer`
    created are `KeywordsContainer`, `AdminContainer`, and `LoginContainer`. The `KeywordsContainer`
    instance will assemble all dependencies related to keywords, `AdminContainer`
    will hold all instances related to administrative tasks, and `LoginContainer`
    for login- and user-related services. Then, there is `RecipeAppContainer`, which
    will consolidate all these containers through DI also.
  prefs: []
  type: TYPE_NORMAL
- en: 'The injection of the dependencies to the API is like the single declarative
    style, except that the container needs to be indicated in the wiring marker. The
    following is an admin-related API that shows how we wire dependencies to REST
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The presence of `admincontainer` inside `Provide` checks first for the container
    of the same name before it fetches the `adminservice` provider that references
    the service dependable. The rest of the details are just the same with a single
    declarative, including the FastAPI integration and object assembly.
  prefs: []
  type: TYPE_NORMAL
- en: What is highlighted here about *Dependency Injector* is just basic configurations
    for simple applications. There are still other features and integrations that
    this module can provide to optimize our application using DI. Now, if we need
    thread-safe and non-blocking but with simple, streamlined, and straightforward
    APIs, setup and configuration, there is the *Lagom* module.
  prefs: []
  type: TYPE_NORMAL
- en: Using a simple configuration – Lagom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third-party *Lagom* module is widely used because of its simplicity when
    it comes to wiring dependables. It is also ideal for building asynchronous microservice-driven
    applications because it is thread-safe at runtime. Moreover, it can easily integrate
    into many web frameworks, including FastAPI. To apply its APIs, we need to install
    it first using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Containers in *Lagom* are created instantly using the `Container` class from
    its module. Unlike in *Dependency Injector*, Lagom’s containers are created before
    the injection happens inside the module of the REST APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: All dependables are injected into the container through typical instantiation.
    The container behaves like a `dict` when adding new dependables because it also
    uses a *key-value pair* as an entry. When we inject an object, the container needs
    its class name as its *key* and the instance as its *value*. Moreover, the DI
    framework also allows instantiation with arguments if the constructors require
    some parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: The FastAPI and Lagom integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before the wiring happens, integration to the FastAPI platform must come first
    by instantiating a new API class called `FastApiIntegration`, which is found in
    the `lagom.integrations.fast_api` module. It takes `container` as a required parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The dependables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The instance of `FastAPIIntegration` has a `depends()` method, which we will
    use to perform the injection. One of the best features of Lagom is its easy and
    seamless integration mechanism into any framework. Thus, wiring the dependencies
    will not need FastAPI’s `Depends()` function anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `report_recipe()` utilizes `BadRecipeRepository` as an injectable
    service. Since it is part of the container, *Lagom*’s `depends()` function will
    search for the object in the container, and then it will be wired to the API service,
    if that exists, to save the complaints to the `dict` datastore.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, these two third-party modules are the most popular and elaborative
    when employing DI in our applications. These modules may change through future
    updates, but one thing is for sure: IoC and DI design patterns will always be
    the powerful solution in managing memory usage in an application. Let us now discusses
    issues surrounding memory space, container, and object assembly.'
  prefs: []
  type: TYPE_NORMAL
- en: Scoping of dependables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In FastAPI, the scope of dependables can be either a new instance or a singleton.
    FastAPI’s DI does not support the creation of singleton objects by default. In
    every execution of an API service with dependencies, FastAPI always fetches a
    new instance of each wired dependable, which can be proven by getting the *object
    ID* using `id()`.
  prefs: []
  type: TYPE_NORMAL
- en: A `singleton` object is created only once by a container, no matter how many
    times the framework injects it. Its *object ID* remains the same the entire runtime
    of the application. Services and repository classes are preferred to be singleton
    to control the increase of memory utilization of the application. And since it
    is not easy to create a singleton with FastAPI, we can use either *Dependency
    Injector* or *Lagom*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `Singleton` provider in Dependency Injector that is responsible
    for the creation of singleton dependencies. This provider was mentioned already
    during the discussions on its `DeclarativeContainer` setup. With Lagom, there
    are two ways to create singleton injectables: (a) using its `Singleton` class,
    and (b) through the constructor of `FastAPIIntegration`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Singleton` class wraps the instance of the dependency before injecting
    it into the container. The following sample snippet shows one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The other way is to declare the dependency in the `request_singletons` parameter
    of the constructor of `FastAPIIntegration`. The following snippet shows how it
    is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: By the way, the `request_singletons` parameter is a `List` type, so it will
    allow us to declare at least one dependable when we want to make singletons.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect that makes a framework easy and practical to use is its support for
    the IoC principle. FastAPI has a built-in container that we can utilize to establish
    dependency among components. The use of a *DI* pattern to integrate all these
    components through wiring is a strong prerequisite in building microservice-driven
    applications. From simple injection using `Depends()`, we can extend DI to build
    pluggable components for database integration, authentication, security, and unit
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced some third-party modules such as *Dependency Injector*
    and *Lagom* that can design and customize containers. Because of the limitations
    of FastAPI on DI, there are external libraries that can help extend its responsibility
    to assemble, control, and manage object creation in a container. These third-party
    APIs can also create singleton objects, which can help decrease the heap size
    in the PVM.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from performance tuning and memory management, DI can contribute to the
    organization of a project, especially huge applications. The addition of model,
    repository, and service layers is a remarkable effect of creating dependencies.
    Injection opens the development to other design patterns, such as factory method,
    service, and data access object patterns. In the next chapter, we will start to
    build some microservice-related components based on the core design patterns of
    microservices.
  prefs: []
  type: TYPE_NORMAL
