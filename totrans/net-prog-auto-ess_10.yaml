- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Hands-On and Going Forward
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践和前进
- en: Congratulations, you have reached the last chapter of this book, and nothing
    is better than having some real examples using network automation to help consolidate
    all of the knowledge learned. We probably won’t be able to write examples on all
    the subjects covered in this book, but the idea is to have at least a foundation
    for further experimentation and learning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经到达了这本书的最后一章，没有什么比用一些使用网络自动化的真实例子来巩固所学的所有知识更好的了。我们可能无法为这本书涵盖的所有主题都编写例子，但目的是至少为进一步的实验和学习打下基础。
- en: In this chapter, we are going to build a network from scratch using our network
    automation skills and emulated routers. The finished network emulated will have
    enough components for us to experiment with several techniques described in this
    book. You will be able to use it for your own experimentation whenever you need
    it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们的网络自动化技能和模拟路由器从头开始构建一个网络。构建完成的模拟网络将包含足够的组件，使我们能够实验本书中描述的几种技术。无论何时你需要，你都可以用它来进行自己的实验。
- en: We are also going to add a few remarks and some guidance for future studies
    and work, which should be good enough to wrap up the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些关于未来学习和工作的备注和指导，这应该足以结束本书。
- en: At the end of this chapter, you are going to be able to build your own network
    emulation and experiment with your own network automation projects within your
    own computer, which will give you a great environment foundation for future experimentation
    and learning.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够构建自己的网络模拟，并在自己的计算机上实验自己的网络自动化项目，这将为你未来的实验和学习提供一个很好的环境基础。
- en: 'We are going to cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using a network lab
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络实验室
- en: Building our network lab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的网络实验室
- en: Connecting the devices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接设备
- en: Adding automation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自动化
- en: Going forward and further studies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前进和进一步学习
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code described in this chapter is stored in the GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的源代码存储在GitHub仓库[https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10)。
- en: Using a network lab
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络实验室
- en: It’s time for us to do some real code automation tests in a virtual environment.
    Certain open source and commercial products can be used in your environment for
    testing network automation. The differences between the commercial and open source
    solutions rely on the number of different types of devices that are supported
    and how to scale. Using an open source solution, you might be able to scale up
    thousands of devices, but it would be limited in terms of the types of devices
    that can be emulated. A combination of a commercial and open source network might
    be more useful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在我们虚拟环境中进行一些真正的代码自动化测试了。某些开源和商业产品可以在你的环境中用于测试网络自动化。商业和开源解决方案之间的区别在于支持的设备类型数量以及如何扩展。使用开源解决方案，你可能能够扩展数千台设备，但在模拟的设备类型方面可能会有所限制。商业和开源网络的组合可能更有用。
- en: Cisco has a program that allows the public to access emulated routers in a virtual
    lab; they are called sandboxes. Cisco offers free 24/7 remote access to its sandboxes,
    but the number of devices is limited. More on Cisco sandboxes can be found at
    [https://developer.cisco.com/site/sandbox/](https://developer.cisco.com/site/sandbox/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco有一个项目允许公众访问虚拟实验室中的模拟路由器；它们被称为沙盒。Cisco提供免费24/7远程访问其沙盒，但设备数量有限。有关Cisco沙盒的更多信息，请参阅[https://developer.cisco.com/site/sandbox/](https://developer.cisco.com/site/sandbox/)。
- en: As an example, the `scrapligo` project, described in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166),
    uses Cisco sandboxes; check details on the usage at [https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14](https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14).
    There are also other commercial products, such as Cisco Packet Tracer, which is
    part of the Cisco Network Academy (https://www.netacad.com/courses/packet-tracer),
    and EVE-NG ([https://www.eve-ng.net/](https://www.eve-ng.net/)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*第 6 章* [B18165_06.xhtml#_idTextAnchor166] 中描述的 `scrapligo` 项目使用 Cisco 沙盒；有关使用详情，请参阅
    [https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14](https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14)。还有其他商业产品，例如
    Cisco Packet Tracer，它是 Cisco 网络学院的一部分（https://www.netacad.com/courses/packet-tracer），以及
    EVE-NG ([https://www.eve-ng.net/](https://www.eve-ng.net/))。
- en: In terms of open source, the most popular ones are GNS3 ([https://gns3.com/](https://gns3.com/))
    and Mininet ([http://mininet.org](http://mininet.org)/). Mininet uses Linux containers
    to scale up the network, while GNS3 is more focused on virtual machines such as
    Dynamips. Therefore, GNS3 can run with several different router types but is limited
    in scale. On the other hand, Mininet can scale to thousands, but with only one
    router type, which is more appropriate for testing network concepts and network
    topologies instead of functionalities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源方面，最受欢迎的是 GNS3 ([https://gns3.com/](https://gns3.com/)) 和 Mininet ([http://mininet.org](http://mininet.org)/)。Mininet
    使用 Linux 容器来扩展网络，而 GNS3 则更专注于虚拟机，如 Dynamips。因此，GNS3 可以运行多种不同的路由器类型，但在规模上有限。另一方面，Mininet
    可以扩展到数千个，但只有一种路由器类型，这更适合测试网络概念和网络拓扑，而不是功能。
- en: For us, it will be more interesting to start from the ground and build our own
    network lab, which will give us more insights on how to use it and how we can
    use network automation tools, which, in fact, will be helpful later for real networks.
    The basis of our network lab will be Linux containers. Consequently, we need to
    use routers that can be easily containerized, and because of license issues, we
    should stick with open source solutions such as FRRouting, Quagga, OpenWRT, or
    DD-WRT, as described in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，从零开始构建自己的网络实验室将更有趣，这将让我们更深入地了解如何使用它以及我们如何使用网络自动化工具，实际上，这将在真实网络中有所帮助。我们网络实验室的基础将是
    Linux 容器。因此，我们需要使用易于容器化的路由器，并且由于许可问题，我们应该坚持使用如 FRRouting、Quagga、OpenWRT 或 DD-WRT
    等开源解决方案，如 *第 9 章* [B18165_09.xhtml#_idTextAnchor209] 中所述。
- en: Our network lab will use FRRouting as the basis of our routers, which has an
    interface configuration close to Cisco routers and can be accessed via the `vtysh`
    command. More details on FRRouting setup and configuration can be found at [https://docs.frrouting.org/en/latest/basic.html](https://docs.frrouting.org/en/latest/basic.html).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络实验室将使用 FRRouting 作为路由器的基础，它具有接近 Cisco 路由器的接口配置，可以通过 `vtysh` 命令访问。有关 FRRouting
    设置和配置的更多详细信息，请参阅 [https://docs.frrouting.org/en/latest/basic.html](https://docs.frrouting.org/en/latest/basic.html)。
- en: Let’s now build our own network lab.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建自己的网络实验室。
- en: Building our network lab
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的网络实验室
- en: In our network lab, we are going to use Linux containers for all our devices.
    There will basically be two types of devices, one running a router and one running
    Linux. The Linux containers that are not working as routers are going to be used
    to generate traffic or to receive traffic; they are going to mimic a user’s PC
    and a server on the internet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络实验室中，我们将为所有设备使用 Linux 容器。基本上会有两种类型的设备，一种是运行路由器，另一种运行 Linux。那些不作为路由器运行的
    Linux 容器将被用来生成流量或接收流量；它们将模拟用户的 PC 和互联网上的服务器。
- en: 'The intended topology is described in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的拓扑结构在以下图中描述：
- en: '![Figure 10.1 – Network lab topology](img/B18165_10_001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 网络实验室拓扑](img/B18165_10_001.jpg)'
- en: Figure 10.1 – Network lab topology
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 网络实验室拓扑
- en: The containers that are going to work as routers are the white rectangles in
    *Figure 10.1*, the yellow rectangles are going to work as user PCs, and the green
    rectangle is going to emulate the servers on the internet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为路由器运行的容器是 *图 10.1* 中的白色矩形，黄色矩形将作为用户 PC 运行，绿色矩形将模拟互联网上的服务器。
- en: In total, the network lab will have 16 routers, 3 PCs, and 1 server. The container
    images to be used in the network lab were created using Docker and stored in Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)), which are publicly available
    and can be used for image download. The routers were created based on the FRRouting
    docker image ([https://hub.docker.com/r/frrouting/frr](https://hub.docker.com/r/frrouting/frr))
    and the PCs and server were created based on the Alpine Linux Docker image ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，网络实验室将拥有16台路由器、3台PC和1台服务器。网络实验室中使用的容器镜像使用Docker创建并存储在Docker Hub ([https://hub.docker.com/](https://hub.docker.com/))，这些是公开可用的，可以用于镜像下载。路由器是基于FRRouting
    Docker镜像([https://hub.docker.com/r/frrouting/frr](https://hub.docker.com/r/frrouting/frr))创建的，PC和服务器是基于Alpine
    Linux Docker镜像([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine))创建的。
- en: The original images were slightly modified with a few more tools and configuration
    changes to create three new images. The image for the routers is [hub.docker.com/r/brnuts/routerlab](https://hub.docker.com/r/brnuts/routerlab),
    the image for the PCs is [hub.docker.com/r/brnuts/pclab](https://hub.docker.com/r/brnuts/pclab),
    and the image for the internet is [hub.docker.com/r/brnuts/internetlab](https://hub.docker.com/r/brnuts/internetlab).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原始镜像经过了一些工具和配置更改的轻微修改，创建了三个新的镜像。路由器的镜像为[hub.docker.com/r/brnuts/routerlab](https://hub.docker.com/r/brnuts/routerlab)，PC的镜像为[hub.docker.com/r/brnuts/pclab](https://hub.docker.com/r/brnuts/pclab)，互联网的镜像为[hub.docker.com/r/brnuts/internetlab](https://hub.docker.com/r/brnuts/internetlab)。
- en: Let’s see now how we can launch our lab host.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何启动我们的实验室主机。
- en: Launching the lab host
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动实验室主机
- en: 'The Linux containers need a host to run from. Therefore, you will first need
    to launch the Linux host where the routers will be running. I prepared two pre-built
    images to help, one for VirtualBox and another for Qemu. You can get instructions
    on how to download them and launch them on GitHub: `Chapter10/NetworkLab/README.md`.
    These virtual machine images use Debian Linux.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器需要一个主机来运行。因此，你首先需要启动路由器将运行在其中的Linux主机。我准备了两个预构建镜像以帮助，一个是用于VirtualBox的，另一个是用于Qemu的。你可以在GitHub上找到如何下载和启动它们的说明：`Chapter10/NetworkLab/README.md`。这些虚拟机镜像使用Debian
    Linux。
- en: However, if you don’t want to use the pre-built virtual machine, I have also
    included instructions on how to build your own host, which is basically any Linux
    distribution with additional packages and some configuration changes. If you build
    your own image, you will need to start all containers by yourself. I have added
    a script in Shell that should be able to do that, called `start-containers.sh`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不想使用预构建的虚拟机，我还包括了如何构建你自己的主机的说明，这基本上是任何带有额外包和一些配置更改的Linux发行版。如果你构建自己的镜像，你需要自己启动所有容器。我添加了一个Shell脚本，应该能够做到这一点，叫做`start-containers.sh`。
- en: Once you have launched the host, let’s see how we can check whether it was launched
    properly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了主机，让我们看看如何检查它是否正确启动。
- en: Checking the lab host
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查实验室主机
- en: After uncompressing and launching the pre-built image, you should be able to
    see all devices running once the host has finished the boot sequence. The reason
    is that I have updated the containers so that they restart automatically unless
    explicitly stopped.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在解压缩并启动预构建镜像后，一旦主机完成引导序列，你应该能够看到所有设备正在运行。原因是我已经更新了容器，以便它们会自动重启，除非明确停止。
- en: 'To verify whether the containers representing the devices are running, you
    just need to use the `docker ps` command, as in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证代表设备的容器是否正在运行，你只需使用`docker ps`命令，如下面的截图所示：
- en: '![Figure 10.2 – Output showing all devices running on the network lab](img/B18165_10_002.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 显示网络实验室上所有设备运行的输出](img/B18165_10_002.jpg)'
- en: Figure 10.2 – Output showing all devices running on the network lab
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 显示网络实验室上所有设备运行的输出
- en: The output of the `docker ps` command should show all running devices, which
    should be, in total, 20 containers, 16 representing routers (using the `brnuts/routerlab`
    image), 3 representing PCs (using the `brnuts/pclab` image), and 1 representing
    the internet (using the `brnuts/internetlab` image).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令的输出应该显示所有正在运行的设备，总共应该是20个容器，其中16个代表路由器（使用`brnuts/routerlab`镜像），3个代表PC（使用`brnuts/pclab`镜像），1个代表互联网（使用`brnuts/internetlab`镜像）。'
- en: I have also added volumes to all containers and attached them as persistent
    storage, so configuration changes won’t be removed even on restarting the container.
    To see the volumes, you can just type in `docker volume list`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我还向所有容器添加了卷，并将它们作为持久存储附加，因此即使在重启容器时配置更改也不会被删除。要查看卷，只需输入`docker volume list`即可。
- en: 'Now, check whether `/etc/hosts` was updated with the IPs of the containers.
    You should be able to see several lines after `# BEGIN DOCKER CONTAINERS`, as
    in the example in the following screenshot. This file is updated by the `update-hosts.sh`
    script included by `systemctl`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查`/etc/hosts`文件是否已更新为容器的IP地址。你应该能在`# BEGIN DOCKER CONTAINERS`之后看到几行，就像以下截图中的示例一样。此文件由`systemctl`中包含的`update-hosts.sh`脚本更新：
- en: '![Figure 10.3 – Checking the /etc/hosts file](img/B18165_10_003.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 检查/etc/hosts文件](img/B18165_10_003.jpg)'
- en: Figure 10.3 – Checking the /etc/hosts file
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 检查/etc/hosts文件
- en: 'We are going to explain later why we need LLDP in the next section, but for
    now, let’s just check whether `lldpd` is running on the host using the `systemctl
    status lldpd.service` command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节解释为什么我们需要LLDP，但现在，让我们使用`systemctl status lldpd.service`命令来检查主机上是否正在运行`lldpd`：
- en: '![Figure 10.4 – Checking whether lldpd is running on the host](img/B18165_10_004.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 检查主机上lldpd是否正在运行](img/B18165_10_004.jpg)'
- en: Figure 10.4 – Checking whether lldpd is running on the host
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 检查主机上lldpd是否正在运行
- en: If the `lldpd` daemon is running correctly, you should be able to see `active
    (running)` in green, as in the preceding screenshot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`lldpd`守护进程运行正确，你应该能在绿色中看到`active (running)`，就像前面的截图所示。
- en: Now, we should be ready to start doing some network automation to finish building
    our lab. Let’s now see how we connect the devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该准备好开始进行一些网络自动化，以完成构建我们的实验室。现在让我们看看我们如何连接设备。
- en: Connecting the devices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接设备
- en: Connecting the devices in our network lab will be done by using `veth` peer
    interfaces as was explained in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
    If we need to connect two different labs from two different hosts, we can use
    VXLAN, but for our exercise in this section, we are only making connections on
    the same host. Therefore, `veth` peer interfaces will do the job.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络实验室中连接设备将通过使用`veth`对等接口来完成，正如在[*第9章*](B18165_09.xhtml#_idTextAnchor209)中所述。如果我们需要从两个不同的主机连接两个不同的实验室，我们可以使用VXLAN，但在这个部分的练习中，我们只在本主机上建立连接。因此，`veth`对等接口将完成这项工作。
- en: One protocol that I have included in the pre-built virtual machine image and
    will be very important to us is **Link Layer Discovery Protocol** (**LLDP**).
    LLDP is one IETF standard that came after the successful Cisco proprietary protocol
    called **Cisco Discovery Protocol** (**CDP**). It is used to obtain information
    about the other side of a layer 2 connection by sending specific Ethernet frames.
    We are going to use it to validate the connections between devices in our network
    lab.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我在预构建的虚拟机镜像中包含了一个协议，这对我们来说非常重要，那就是**链路层发现协议**（**LLDP**）。LLDP是IETF标准之一，它是在成功实施思科的专有协议**Cisco
    Discovery Protocol**（**CDP**）之后出现的。它通过发送特定的以太网帧来获取关于2层连接另一侧的信息。我们将使用它来验证我们网络实验室中设备之间的连接。
- en: Before we proceed with our connections, let’s check how Docker created our **out-of-band**
    (**OOB**) management network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行连接之前，让我们检查Docker是如何创建我们的**带外**（**OOB**）管理网络的。
- en: The OOB management network
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带外管理网络
- en: Docker, by default, creates a network connecting all containers, which we are
    going to use as our OOB management network (described in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015)).
    To do that, Docker creates `veth` interface peers between the container and the
    host. On the container side, Docker attributes `eth0` as the name, and on the
    other side, uses `veth` followed by some hexadecimal characters to make it unique
    – for instance, `veth089f94f`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker创建了一个连接所有容器的网络，我们将使用它作为我们的带外管理网络（在第[*第1章*](B18165_01.xhtml#_idTextAnchor015)中描述）。为此，Docker在容器和主机之间创建`veth`接口对。在容器一侧，Docker将`eth0`作为名称，而在另一侧，使用`veth`后跟一些十六进制字符以使其唯一
    – 例如，`veth089f94f`。
- en: 'All `veth` interfaces located on the host are then connected to a software
    bridge called `docker0`. To use the `brctl` command, you might need to install
    the `bridge-utils` package by doing `sudo apt install bridge-utils`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 主机上的所有`veth`接口都连接到一个名为`docker0`的软件桥。要使用`brctl`命令，你可能需要通过执行`sudo apt install
    bridge-utils`来安装`bridge-utils`包：
- en: '![Figure 10.5 – Checking interfaces on the docker0 bridge](img/B18165_10_005.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 检查docker0桥接上的接口](img/B18165_10_005.jpg)'
- en: Figure 10.5 – Checking interfaces on the docker0 bridge
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 检查docker0桥接上的接口
- en: 'To verify which `veth` interface belongs to which container, you might need
    to perform two commands, as in the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证哪个`veth`接口属于哪个容器，你可能需要执行两个命令，如下例所示：
- en: '![Figure 10.6 – Checking the veth peer name on the host for a container](img/B18165_10_006.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 检查容器在主机上的veth对端名称](img/B18165_10_006.jpg)'
- en: Figure 10.6 – Checking the veth peer name on the host for a container
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 检查容器在主机上的veth对端名称
- en: As you can see in the output of the preceding screenshot, to identify which
    `veth` peer interface belongs to the `border` router, you need to execute a command
    inside the container to obtain an index for the `eth0` interface, which, in this
    case, was `23`. Once you have the index, you can check which `veth` interface
    on the host has the index by using a `grep` command on all files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图的输出所示，为了确定哪个`veth`对等接口属于`border`路由器，你需要在容器内执行一个命令以获取`eth0`接口的索引，在这种情况下，是`23`。一旦你有了索引，你可以通过在所有文件上使用`grep`命令来检查主机上的哪个`veth`接口具有该索引。
- en: 'We can also use LLDP to find out the `veth` interface name by doing the command
    directly on the router:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在路由器上直接执行命令来使用LLDP找出`veth`接口名称：
- en: '![Figure 10.7 – Showing the LLDP neighbor inside the border router](img/B18165_10_007.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 显示边界路由器内的LLDP邻居](img/B18165_10_007.jpg)'
- en: Figure 10.7 – Showing the LLDP neighbor inside the border router
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 显示边界路由器内的LLDP邻居
- en: The preceding screenshot shows a successful output of `lldpctl` showing the
    `eth0` interface’s neighbor, which, in this case, is the host Debian Linux, with
    a `SysName` of `netlab`. The interface that peers with `eth0` on the border router
    is described in the `PortDescr` field as `veth089f94f` – the same interface that
    we discovered using the commands in *Figure 10.6*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了`lldpctl`命令的成功输出，显示了`eth0`接口的邻居，在这种情况下，是主机Debian Linux，`SysName`为`netlab`。与边界路由器上的`eth0`对等的接口在`PortDescr`字段中描述为`veth089f94f`——这正是我们使用*图10.6*中的命令发现的接口。
- en: However, why not use the first method described in *Figure 10.6* to find out
    the connection instead of LLDP? Because in real networks, LLDP is used to identify
    the connections between devices. Thus, writing an automation code to verify all
    the network connections in the lab using LLDP can also be used in production.
    Our lab will be used as the first place to test our automation code – in this
    case, checking the LLDP topology.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么不使用*图10.6*中描述的第一种方法来找出连接而不是使用LLDP呢？因为在实际网络中，LLDP用于识别设备之间的连接。因此，编写一个自动化代码来验证实验室中所有网络连接使用LLDP也可以在生产中使用。我们的实验室将作为测试我们自动化代码的第一个地方——在这种情况下，检查LLDP拓扑。
- en: By now, you have probably noticed that we can access the routers just by using
    the `docker exec <name of the router>` command, so why do we need the OOB management
    network to access the devices? The answer is like the LLDP case – with OOB network
    access, the devices can be accessed via SSH, which is what we are going to do
    in production. Consequently, any code developed for the lab can be used in production.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到我们只需使用`docker exec <router名称>`命令就可以访问路由器，那么为什么我们还需要OOB管理网络来访问设备呢？答案是像LLDP的情况一样——通过OOB网络访问，设备可以通过SSH访问，这正是我们将在生产中要做的。因此，为实验室开发的任何代码都可以在生产中使用。
- en: 'To test our lab OOB management network, we just need to access the device via
    the IP using `ping` or `ssh` commands – the `ping cpe-a` command, for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的实验室OOB管理网络，我们只需使用`ping`或`ssh`命令通过IP访问设备——例如，使用`ping cpe-a`命令：
- en: '![Figure 10.8 – Testing connection to a router from the host using OOB](img/B18165_10_008.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 使用OOB从主机测试连接到路由器](img/B18165_10_008.jpg)'
- en: Figure 10.8 – Testing connection to a router from the host using OOB
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 使用OOB从主机测试连接到路由器
- en: 'You should also be able to SSH to any container, using `netlab` for the username
    and password:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该能够使用`netlab`作为用户名和密码SSH到任何容器：
- en: '![Figure 10.9 – Testing whether you can access a device via SSH using OOB](img/B18165_10_009.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 测试是否可以通过OOB使用SSH访问设备](img/B18165_10_009.jpg)'
- en: Figure 10.9 – Testing whether you can access a device via SSH using OOB
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 测试是否可以通过OOB使用SSH访问设备
- en: Now that we know how our OOB management network works in our lab, let’s connect
    the devices using the OOB network.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了我们的实验室中OOB管理网络的工作方式，让我们使用OOB网络连接设备。
- en: Looking at the topology
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看拓扑
- en: '*Figure 10.1* shows the topology that we are aiming to create. The devices
    in our lab are running and connected to an OOB network, but they do not have connections
    like the topology described in *Figure 10.1*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.1* 展示了我们旨在创建的拓扑结构。我们实验室中的设备正在运行并连接到一个OOB网络，但它们没有像*图10.1*中描述的拓扑那样的连接。'
- en: In addition to the diagram, there is also a formal topology description in a
    file on GitHub, which can be accessed at `Chapter10/NetworkLab/topology.yaml`.
    The file describes the routers in the topology and their connections. It is a
    simple version of network definition in YAML format as we discussed in [*Chapter
    4*](B18165_04.xhtml#_idTextAnchor100).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图表之外，GitHub上的一个文件中也包含了一个正式的拓扑描述，可以通过`Chapter10/NetworkLab/topology.yaml`访问。该文件描述了拓扑中的路由器和它们的连接。这是我们之前在[*第4章*](B18165_04.xhtml#_idTextAnchor100)中讨论的YAML格式的网络定义的简单版本。
- en: 'The topology file has basically two main keys, `devices` and `links`. These
    keys should describe the same connections shown in *Figure 10.1*. The following
    is a sample of the file for the `devices` and `links` keys:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑文件基本上有两个主要键，`devices`和`links`。这些键应该描述与*图10.1*中显示相同的连接。以下是`devices`和`links`键的文件样本：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file should contain all the links that are depicted in *Figure 10.1*. Ideally,
    the diagram in *Figure 10.1* should be created automatically by a tool reading
    from `topology.yaml`. In our example, the diagram and the YAML file are the same,
    but I have built the diagram manually myself, and for any topology change, I need
    to update the `topology.yaml` file and the diagram. This problem was discussed
    as well in [*Chapter 4*](B18165_04.xhtml#_idTextAnchor100), and the update synchronization
    between a file and a diagram tends to break as the topology gets more complex.
    But, for our examples using this small topology, an automated diagram builder
    is not necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件应包含*图10.1*中描绘的所有链接。理想情况下，*图10.1*中的图表应该由一个读取`topology.yaml`的工具自动创建。在我们的例子中，图表和YAML文件是相同的，但我自己手动构建了图表，并且对于任何拓扑变化，我需要更新`topology.yaml`文件和图表。这个问题也在[*第4章*](B18165_04.xhtml#_idTextAnchor100)中讨论过，随着拓扑变得更加复杂，文件和图表之间的更新同步往往会出错。但是，对于使用这个小拓扑的示例，自动图表构建器不是必需的。
- en: Creating the connections between devices
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建设备之间的连接
- en: To connect the devices, like in the topology, we have to use `veth` peer interfaces,
    and as we discussed in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209), we need
    the namespace numbers for each side of the peer and the interface names we going
    to use. Most of the connections in *Figure 10.1* are point-to-point between devices,
    except for the connections to the **backbone** or **WAN**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接设备，就像在拓扑中一样，我们必须使用`veth`对等接口，并且正如我们在[*第9章*](B18165_09.xhtml#_idTextAnchor209)中讨论的那样，我们需要对等接口每边的命名空间编号以及我们将要使用的接口名称。*图10.1*中的大多数连接都是设备之间的点对点连接，除了连接到**骨干**或**WAN**。
- en: 'The following diagram shows all the `veth` peers that we must configure; the
    majority are connected between two containers in a point-to-point configuration.
    However, the core routers will use, let’s say, backbone veth or WAN veth, because
    they are connected in a multi-to-multi-point environment, similar to a WAN. For
    that, we are going to use a software bridge in the host to provide connectivity
    between the backbone veth – latency and packet loss can be added to the bridge
    interfaces if tests for network degradation are required:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了我们必须配置的所有`veth`对等接口；大多数是在两个容器之间以点对点配置连接。然而，核心路由器将使用，比如说，骨干`veth`或WAN`veth`，因为它们在多对多点的环境中连接，类似于WAN。为此，我们将在主机上使用一个软件桥来提供骨干`veth`之间的连接性；如果需要进行网络降级测试，可以在桥接口上添加延迟和丢包：
- en: '![Figure 10.10 – Lab topology showing all veth peer interfaces](img/B18165_10_010.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 实验室拓扑，显示所有`veth`对等接口](img/B18165_10_010.jpg)'
- en: Figure 10.10 – Lab topology showing all veth peer interfaces
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 实验室拓扑，显示所有`veth`对等接口
- en: 'When we start creating the `veth` interfaces for the backbone to connect all
    core routers, we are going to use one namespace on the host and the other in the
    core router. This is different from all other veth, which will have two namespaces.
    The following is one example of how to create a connection manually between `pc-a`
    and `cpe-a`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始创建用于连接所有核心路由器的骨干`veth`接口时，我们将在主机上使用一个命名空间，在核心路由器上使用另一个命名空间。这与所有其他`veth`不同，它们将有两个命名空间。以下是如何手动在`pc-a`和`cpe-a`之间创建连接的一个示例：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in these commands, first, we need to obtain the network namespace
    IDs of each router we want to connect, and then we can create the `veth` peer
    and attribute each side of the peer to a namespace ID. Finally, we bring the interfaces
    up on each router. Note that the interface name on `pc-a` is `pc-cpe` and on `cpe-a`
    is `cpe-pc`, to help identify the direction in which the interface goes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在这组命令中所见，首先，我们需要获取我们想要连接的每个路由器的网络命名空间 ID，然后我们可以创建 `veth` 对等端，并将对等端的每一侧分配给一个命名空间
    ID。最后，我们在每个路由器上启动接口。请注意，`pc-a` 上的接口名称是 `pc-cpe`，而 `cpe-a` 上的接口名称是 `cpe-pc`，这有助于识别接口的方向。
- en: 'To verify whether our connection between the routers was created properly,
    we can run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们之间路由器的连接是否创建正确，我们可以运行以下命令：
- en: '![Figure 10.11 – Checking the connection between pc-a and cpe-a](img/B18165_10_011.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 检查 pc-a 和 cpe-a 之间的连接](img/B18165_10_011.jpg)'
- en: Figure 10.11 – Checking the connection between pc-a and cpe-a
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 检查 pc-a 和 cpe-a 之间的连接
- en: Now, we can confirm that `pc-a` is connected to `cpe-a` by looking into the
    `lldpctl` command output in *Figure 10.11*. The output shows the name for `SysName`,
    which is `cpe-a`, confirming the connection. We can also see the interface name
    on the other side, which is `cpe-pc`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过查看 *图 10.11* 中的 `lldpctl` 命令输出，确认 `pc-a` 是否连接到 `cpe-a`。输出显示了 `SysName`
    的名称为 `cpe-a`，确认了连接。我们还可以看到另一侧的接口名称，它是 `cpe-pc`。
- en: Let’s now see how we automate the device connections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何自动化设备连接。
- en: Automating the connections
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化连接
- en: Our lab now has all devices running, and we are going to connect all devices
    using a program that will connect all devices. You can get access to the program
    on `Chapter10/NetworkLab/AUTOMATION.md`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络实验室现在所有设备都在运行，我们将使用一个程序连接所有设备。您可以在 `Chapter10/NetworkLab/AUTOMATION.md`
    获取该程序。
- en: 'To install it on your computer, just need to clone it using the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的计算机上安装它，只需使用以下命令克隆它：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, you need to build the Go program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要构建 Go 程序：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you are using the pre-build VirtualBox image, you probably are accessing
    the network lab via SSH on localhost port `22`. Then, you just need to run it
    like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用预构建的 VirtualBox 映像，您可能正在通过本地主机端口 `22` 使用 SSH 访问网络实验室。然后，您只需像这样运行它：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are using QEMU or your own Linux virtual machine with the network lab,
    you can pass the username, password, and IP of the host as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 QEMU 或带有网络实验室的自己的 Linux 虚拟机，您可以按照以下方式传递用户名、密码和主机 IP：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A small help guide can be accessed by adding `-help`, like here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `-help`，可以访问一个小型帮助指南，如下所示：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The program shows some logs on the output, and a successful run should show
    similar lines to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在输出中显示了一些日志，成功运行应该显示类似于以下类似的行：
- en: '![Figure 10.12 – Running the Go automation program to connect devices](img/B18165_10_012.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 运行 Go 自动化程序连接设备](img/B18165_10_012.jpg)'
- en: Figure 10.12 – Running the Go automation program to connect devices
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 运行 Go 自动化程序连接设备
- en: As you can see in the preceding screenshot, the program takes around 12 seconds
    to run, and it should show `all done successfully` at the end.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，程序运行大约需要 12 秒，并且在结束时应该显示 `all done successfully`。
- en: Let’s have a look at this program and what it is doing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序以及它在做什么。
- en: Looking into the automation program
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看自动化程序
- en: 'In our example, the program was written in Go, and the directory where it is
    located consists of nine files, of which six are Go source code with `.go` extensions
    as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，程序是用 Go 语言编写的，它所在的目录包含九个文件，其中六个是带有 `.go` 扩展名的 Go 源代码，如下所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s discuss each file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个文件。
- en: go.mod and go.sum
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: go.mod 和 go.sum
- en: These files are used by the Go builder for package dependency management; they
    contain all the necessary information to add the third-party library to our program.
    Every time we import a package, it automatically updates these files. More on
    these files can be obtained at [https://go.dev/ref/mod](https://go.dev/ref/mod).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件被 Go 构建器用于包依赖管理；它们包含将第三方库添加到我们程序所需的所有必要信息。每次我们导入一个包时，它都会自动更新这些文件。更多关于这些文件的信息可以在
    [https://go.dev/ref/mod](https://go.dev/ref/mod) 获取。
- en: topology.yaml
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: topology.yaml
- en: This contains the description of the topology that is shown in *Figure 10.1*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了 *图 10.1* 中显示的拓扑描述。
- en: types.go
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: types.go
- en: 'This contains all the data structure definitions used in the program, which
    include variable types and the YAML topology data structure. Different from Python,
    in Go, it is better to specify the data structure that you are going to read from
    a YAML file. In our case, the `TopologyConfType` struct type is used to define
    the YAML file structure, like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了程序中使用的所有数据结构定义，包括变量类型和YAML拓扑数据结构。与Python不同，在Go中，最好指定要从YAML文件中读取的数据结构。在我们的案例中，使用`TopologyConfType`结构类型来定义YAML文件结构，如下所示：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: readtopology.go
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: readtopology.go
- en: This contains the function that is used to read the `topology.yaml` file. The
    data structure of this file is defined in the `TopologyConfType` structure type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了用于读取`topology.yaml`文件的函数。该文件的 数据结构定义在`TopologyConfType`结构类型中。
- en: runcommand.go
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: runcommand.go
- en: 'This contains generic functions that wrap the command to run on the host of
    the lab. If an error occurs by running a command, the output is combined with
    the error message to be returned in the error message, as in this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了封装在实验室主机上运行的命令的通用函数。如果运行命令时发生错误，输出将与错误消息结合，以错误消息的形式返回，如下例所示：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The idea to add the output to the error message is because when running remote
    commands via SSH and shell, the error might not be easy to interpret without the
    `stdout` messages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出添加到错误信息中的想法是因为当通过SSH和shell运行远程命令时，没有`stdout`消息，错误可能不容易解释。
- en: veth.go
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: veth.go
- en: This contains the functions that form the command strings that will be used
    to run on the host to create or manipulate `veth` interfaces. It also contains
    all functions that are used to populate the `conf.Veths` list, such as `loadVeth()`
    and `createPeerVeths()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了形成将在主机上运行的命令字符串的函数，这些命令字符串用于创建或操作`veth`接口。它还包含了所有用于填充`conf.Veths`列表的函数，例如`loadVeth()`和`createPeerVeths()`。
- en: hostconnect.go
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hostconnect.go
- en: This file contains the function used to connect to our lab. In our case, we
    are using a third-party package called `melbahja/goph`, which is an SSH client
    that allows the execution of a command and immediate output. For faster and better
    performance, we should use vSSH instead, as explained in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含了用于连接我们实验室的函数。在我们的案例中，我们使用了一个名为`melbahja/goph`的第三方包，它是一个SSH客户端，允许执行命令并立即输出。为了获得更快和更好的性能，我们应该使用vSSH，如[*第6章*](B18165_06.xhtml#_idTextAnchor166)中所述。
- en: netlab.go
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: netlab.go
- en: This is the main program file that contains the `main()` and `init()` functions.
    The library called `flags` is used to pass arguments during the command execution
    in the shell. By default, they are initiated in the `init()` function, and they
    use default values if the arguments are not passed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主程序文件，其中包含了`main()`和`init()`函数。`flags`库用于在shell中命令执行时传递参数。默认情况下，它们在`init()`函数中初始化，如果没有传递参数，则使用默认值。
- en: The `main()` function also describes the flow of the whole process, which consists
    of five main calls – `readTopologyFile`, `connectToHost`, `loadVeths`, `createVeths`,
    and `addVethsToBackbone`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数还描述了整个过程的流程，它由五个主要调用组成 – `readTopologyFile`、`connectToHost`、`loadVeths`、`createVeths`和`addVethsToBackbone`。'
- en: Now that we have all devices connected and we understand how the automation
    works, let’s do some manual checks to verify that the connections have been created
    properly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有设备连接起来，并且我们了解了自动化是如何工作的，让我们进行一些手动检查，以验证连接是否已正确创建。
- en: Checking the connections manually
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动检查连接
- en: To create automation for checking connections, we have to understand how the
    process of checking connections works first. Once we know how a manual check works,
    we can later automate it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建检查连接的自动化，我们首先需要了解检查连接的过程。一旦我们知道了手动检查是如何工作的，我们就可以稍后自动化它。
- en: 'Once the `netlab` program has run without errors, it should have created the
    connections and the software bridge called `backbone`, and attached the WAN interfaces
    to it. Let’s use the following figure as guidance for our manual verification
    of the connections:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`netlab`程序运行无误，它应该已经创建了连接和名为`backbone`的软件桥，并将WAN接口连接到它。让我们使用以下图作为我们手动验证连接的指导：
- en: '![Figure 10.13 – Diagram showing where we manually check the connections](img/B18165_10_013.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 显示我们手动检查连接的示意图](img/B18165_10_013.jpg)'
- en: Figure 10.13 – Diagram showing where we manually check the connections
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 显示我们手动检查连接的示意图
- en: The figure shows numbers to indicate where we are going to do the manual checks.
    Let’s first start checking the connection that is represented by **1**. We are
    going to use LLDP to validate the connection in all cases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the `sudo lldpctl cpe-acc` command,
    which runs inside the `cpe-a` router via SSH. Note that in the example, we start
    from the `netlab` host:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection
    to acc-a](img/B18165_10_014.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection
    to acc-a
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `cpe-acc` interface in the `cpe-a` router is connected to
    the `acc-cpe` interface in the `acc-a` router.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate the connection for case `core-a1`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection
    to the backbone](img/B18165_10_015.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection
    to the backbone
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `core-a1` router’s interface, `core-a1-wan`, is connected
    to the `netlab` host via `wan-core-a1`. To verify whether the `wan-core-a1` interface
    belongs to the `backbone` bridge, we need to perform one of the extra commands:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone
    bridge](img/B18165_10_016.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone bridge
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Either of the commands shown in *Figure 10.16* confirms that `wan-core-a1` belongs
    to `backbone`. The difference is the second command presents the output in a JSON
    format, which is easier to parse by software. `lldpctl` also supports JSON output
    using `lldpctl -f json`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss how we can add more automation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Adding automation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are infinite possibilities for processes for which you might want to create
    automation. Most of the operational procedures are repetitive and prone to errors
    if manually operated. So, we need to automate our network as much as possible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Let’s then describe a few simple forms of automation that can help our network
    operation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Link connection check automation
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the procedures that is very important and requires lots of attention
    is the build and construction of the physical network, in particular a physical
    rack and its cables. Its complexity will vary, depending on whether a star topology
    configuration or a Clos topology configuration is used, which we discussed in
    [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: A mixed topology configuration that combines all possible topologies is even
    more complex, and its complexity will increase the chances of building a network
    incorrectly. For instance, a Clos network, as shown in *Figure 10.17*, has a total
    of 32 connections, and imagine the complexity added if three more routers were
    included.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Clos network connections](img/B18165_10_017.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Clos network connections
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Having included **E5**, **S5**, and **L5**, the Clos network will have now 50
    connections. So, for us, connection check automation is important to avoid operation
    failures down the network setup.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, our network lab can be used for us to test the automation
    of the link connection check, which can be used later in production.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, a bastion host normally needs to be accessed first,
    before accessing the devices using the OOB network. In our network lab, the bastion
    is the same as the network lab host. Once logged in to the bastion, the automation
    code can then access the router via the OOB network, which is the same as in the
    network lab.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now write some code to automate this process
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Link check example code
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have added a Python script that returns a JSON list format with all interfaces
    and the device connected to each interface for a particular device. The Python
    code can be accessed at `Chapter10/NetworkLab/AUTOMATION.md`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run a few examples to see how the Python script works; the following
    screenshot is showing results for the `internet` device:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Output for checking connections to the internet device](img/B18165_10_018.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Output for checking connections to the internet device
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `internet` device has only two interfaces, one connected
    via the OOB network with the `eth0` interface to the `netlab` device, and one
    interface called `internet-border` connected to the `border` device, which confirms
    the connections in *Figure 10.1*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now check how the `border` device is connected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Output for checking connections of the border device](img/B18165_10_019.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Output for checking connections of the border device
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 10.19*, the `border` device is connected to the `internet`
    device and three core routers, `core-i1`, `core-i2`, and `core-i3`, as in *Figure
    10.1*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: If you run this for all devices, you should confirm all the connections. But
    can we automate confirming connections for all routers in just one run? Yes, of
    course, but for that, we will need to read `topology.yaml`, and then create a
    loop that will run on each device to confirm the connections. I will leave completing
    this as an exercise for you.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explain some parts of the `show-connections.py` code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Looking into the code
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `show-connections.py` Python code uses the `paramiko` third-party library
    as the base for the SSH connection, which we discussed in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166),
    (`paramiko` can be installed using `pip install paramiko`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Paramiko is a lower-level SSH connectivity library that allows us to create
    an SSH session within an SSH session because we are using a bastion to connect
    to our devices in the network lab, which is the lab host. The details of this
    stacked SSH connection are described in the code by the `NetLab()` class, which
    has a method to connect to the bastion called `connectBastion()`, and a method
    to connect to a device called `connectDevice()`. Note that these methods use a
    class attribute called `self.transport` to pass the bastion `paramiko` handler
    to the device channel described in the code and shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are other ways to use bastion, such as using SSH proxies or SSH agents.
    However, in our example, I wanted to show how to natively create an SSH stack
    connection. Because if you do have two bastions before connecting a device, it
    is also possible to use `paramiko`, but perhaps not that easy using SSH agents
    and proxies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the Python code, we use `argparser` to add arguments to our command line,
    so you can change the address of the bastion or the username and password. The
    arguments and default values are located in `parse_arguments()`. A help guide
    is also automatically produced if you type `--help`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – help output for the Python code show-connections.py](img/B18165_10_020.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – help output for the Python code show-connections.py
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: I will leave you to improve this Python script to read the `topology.yaml` file
    and then verify all the connections in the network lab depicted in *Figure 10.1*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can automate the IP configuration for the interfaces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: IP configuration automation
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use our network for IP traffic, we need to attribute IPs to our
    network interfaces, which can be done manually by adding IPs to each interface,
    or we can create an automated code that distributes the IPs and configure them
    on the devices in the network lab.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: For our network lab, there are basically two types of IP allocation, one that
    is point-to-point between devices, and one that is multi-point for the WAN on
    the backbone interfaces. Let’s give an example of automation for the WAN interfaces.
    The Python code called `configure-ip-wan.py` is located at `Chapter10/NetworkLab/AUTOMATION.md`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output after running the `configure-ip-wan.py`
    program:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Output of the configure-ip-wan.py Python code](img/B18165_10_021.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Output of the configure-ip-wan.py Python code
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the IPs are configured on the devices using Paramiko, as in the previous
    example. The code uses the `ipaddress` Python library, which allocates the IPs
    that will be used in the WAN interfaces by creating a list of IPs using the following
    commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, each IP is obtained by using `pop()` in the `valid_ips` list, like in
    the following loop:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can test the IP connectivity between devices in the WAN using the Python
    script included at `Chapter10/NetworkLab/AUTOMATION.md`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via
    the WAN](img/B18165_10_022.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via the
    WAN
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: From the output shown in *Figure 10.21*, we can assume the `core-b1` interface
    IP is `10.200.200.4`. So, the test executed on `core-a1` is testing the IP connectivity
    between `core-a1` and `core-b1` via the `backbone` bridge.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: To finish the IP configuration, you will have to also configure IPs for all
    other interfaces. I will leave adding the IPs to other network lab interfaces
    as an exercise, but for now, the example is sufficient to guide you to proceed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Additional network lab automation
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss briefly what other possible automation we can add to our lab.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing devices
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can add code that can read the `topology.yaml` file and then, based on what
    is running, determine whether certain modifications are required, such as adding
    devices or removing devices. I will say that is easier for us to just tear down
    a network lab and start another one from scratch instead of removing and adding
    devices because, in our network emulation, the shutdown and startup are quick.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: So, adding code to remove and add devices is more of an exercise than a real
    utility in our network lab.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC for automation
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also can do some automation using gRPC, as FRRouting supports this interface.
    With this, we eliminate the necessity to access the devices via SSH. You can find
    more on gRPC for FRRouting at [https://docs.frrouting.org/en/latest/grpc.html](https://docs.frrouting.org/en/latest/grpc.html).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Using NETCONF for automation
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use NETCONF for automation, you need to have `libyang` installed in the router
    image, which, in our network lab, is FRRouting running on Alpine Linux. To add
    `libyang`, just type the `sudo apk add libyang` command on the router device.
    Using FRRouting and NETCONF together is not a very well-documented option, so
    good luck doing so.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Adding network degradation
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add latency, jitter, packet loss, congestion, and other degradations
    to your network lab, which can be permanent or vary over time. To remove and add
    these degradations, the best thing to do is to write automated code that can apply
    the necessary traffic shaping mechanisms and then remove them. We discussed these
    degradation methods in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can add some latency to the backbone interfaces in our network
    lab by using Linux `tc` like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command should run on the lab host, and it will add a 100 ms delay to the
    `wan-core-a1` interface that connects `core-a1` to the backbone.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.23* show the same test done in *Figure 10.22* but with WAN latency
    added.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to
    WAN](img/B18165_10_023.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to WAN
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to add other network degradations to your network lab by automating
    how Linux traffic control can be used in the network lab interfaces.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Configure routing
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this stage, our network lab does not provide IP traffic capabilities because
    it does not know how to route IP packets. Two kinds of routing can be done using
    static routes by configuring the interfaces with them or adding dynamic protocol
    for the devices to talk and exchange routing tables.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: As all routers in our network lab are FRRouting; the protocols available that
    can be used are EIGRP, OSPF, ISIS, RIP, or BGP. A complete list and more details
    can be found at [https://docs.frrouting.org/](https://docs.frrouting.org/).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Many more kinds of automation are possible. Some will only work for the network
    lab, but some could be used in a production network. Hopefully, you can use the
    network lab to improve your network automation code skills, and then gain more
    confidence on building a solution for a production network.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now discuss what to do next and further study.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Going forward and further study
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are probably now thinking about what to do next and how you can progress
    to the next topic in network automation. I have put together a few suggestions
    here that I would recommend following, but keep in mind that there might be many
    other paths to follow. So, it is just a humble suggestion, and I hope you can
    enjoy the journey.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Checking popular platforms and tools
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many automation platforms that you can use and perhaps investigate
    how they work. This list will be dynamic and may change from one year to another.
    So, keep in mind how to search for them and how to evaluate them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: I have done superficial research on some of the platforms, but I would recommend
    going deeper if you want to improve your knowledge and get even sharper on how
    to automate a network. You may get some ideas, and perhaps improve what you are
    doing today.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small list of the most popular automation platforms and tools that
    you might want to have a look at, not in any particular order:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The Salt project:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A remote execution manager'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/saltstack/salt](https://github.com/saltstack/salt
    )'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 2K'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: February 2011'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 98%'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor: VMware/public'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 13K stars, 5.4K forks, 544 watching'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Ansible project:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A simple automation system for configuration management,
    deployment, and orchestration'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/ansible/ansible](https://github.com/ansible/ansible
    )'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 5K'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: March 2012'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 88%, PowerShell 6.9%'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: GPL 3.0'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor: Red Hat'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 56K stars, 23K forks, 2K watching'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Puppet project:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A general administrative management system designed to configure,
    update, and install systems'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/puppetlabs/puppet](https://github.com/puppetlabs/puppet
    )'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 1K'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: September 2010'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Ruby 99%'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor/Owner: Puppet by Perforce'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 6.8K stars, 2.3K forks, 475 watching'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Chef project:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A configuration management tool designed to cover the automation
    of all IT infrastructure'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/chef/chef](https://github.com/chef/chef)'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 1K'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: January 2009'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Ruby 98%'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor/Owner: Progress Software Corporation'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 7.1K stars, 2.6K forks, 374 watching'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Stackstorm project:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: An event-driven automation tool'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/StackStorm/st2](https://github.com/StackStorm/st2
    )'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 300'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: April 2014'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 94%'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor/Owner: Linux Foundation'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 5.4K stars, 696 forks, 168 watching'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The eNMS automation project:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A higher-level management system to create workflow-based
    network automation solutions'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/eNMS-automation/eNMS](https://github.com/eNMS-automation/eNMS
    )'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: 30'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: October 2017'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 53%, JavaScript 26%, HTML 16%'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: GLP 3.0'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor: N/A'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 700 stars, 148 forks, 73 watching'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NetBrain products:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: NetBrain has developed several products for network automation,
    including **Problem Diagnosis Automation System** (**PDAS**)'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.netbraintech.com/](https://www.netbraintech.com/ )'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Owner: NetBrain Automation'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SolarWinds Network Automation Manager:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: Proprietary product developed by SolarWinds for network
    automation'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.solarwinds.com/network-automation-manager](https://www.solarwinds.com/network-automation-manager
    )'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Owner: SolarWinds'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the tools and platforms that you can investigate, you also can participate
    in working groups related to network automation. Let’s have a look at some of
    them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Joining the network automation community
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the strategies to improve your knowledge and get updated with new technologies
    is to participate in the community. The following is a small list of possible
    groups that you might be interested in watching or participating in:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'IETF netmgmt working group:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A group that has a focus on working on standards for automated
    network management, such as RESTCONF, NETCONF, and YANG'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.ietf.org/topics/netmgmt/](https://www.ietf.org/topics/netmgmt/
    )'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Meetup groups:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: One good idea is to join a local meetup group that has regular
    meetings. Then, you can talk with professionals in the same area and improve your
    network and knowledge. [https://www.meetup.com/](https://www.meetup.com/) is a
    site where people can organize and meet.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example in New York: [https://www.meetup.com/Network-to-Coders/](https://www.meetup.com/Network-to-Coders/).'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example in Sydney: [https://www.meetup.com/it-automation/](https://www.meetup.com/it-automation/).'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example in San Francisco: [https://www.meetup.com/sf-network-automation/](https://www.meetup.com/sf-network-automation/).'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**North American Network Operators’ Group** (**NANOG**):'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: NANOG has tons of documents and presentations, and also
    organizes conferences where you can find multiple topics on network automation'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.nanog.org/](https://www.nanog.org/ )'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global Network Advancement Group** (**GNA-G**):'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: GNA-G is a community of network professionals from several
    areas, including research, operation, and education all over the world. They organize
    meetings and have some documentation resources.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.gna-g.net/](https://www.gna-g.net/).'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Network to Code company community:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: Network to Code is a consulting company that maintains GitHub
    repositories and a [slack.com](https://slack.com) group that discusses network
    automation, which can be joined for free'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/networktocode/awesome-network-automation](https://github.com/networktocode/awesome-network-automation
    )'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slack group: [networktocode.slack.com](https://networktocode.slack.com )'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IP Fabric company community:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: The IP Fabric company also maintains GitHub repositories
    and has a [slack.com](http://slack.com) group open to anyone to join'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/community-fabric](https://github.com/community-fabric)'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slack group: [ipfabric-community.slack.com](http://ipfabric-community.slack.com)'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other communities also can be found attached to some private companies, such
    as IBM, Oracle, VMware, Google, and Amazon. They might even use public tools such
    as Slack, LinkedIn, or GitHub to communicate, and they are maybe more focused
    on products that these companies offer instead of generic discussion. They are
    worth checking out, because they might have something to add.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Another idea to improve your knowledge and skills is to contribute to a platform
    that already exists as a developer, or to build your own if you dare.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: I hope this section can give you ideas on the path forward.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was focused on getting your hands dirty in a network lab, checking
    how some code automation works in Go and Python, and, finally, exploring the possibilities
    of how to go forward with network automation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be very confident about how to build your own network
    lab, how to improve your network automation code, and what to do next to continue
    improving.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: On behalf of all the people who worked hard on this book, we want to thank you
    for investing the time to read this book. It was a hard accomplishment to gather
    so much information and pass it on to others in an easy and pleasurable way. I
    hope you have made the most of it by reading it and discovering new technologies
    and techniques in the realm of network automation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can embark on further challenges that will take you deeper into network
    automation, which you will find when building a complete solution and putting
    into practice everything that you have learned.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始接受进一步的挑战，这将使你更深入地了解网络自动化，你将在构建完整解决方案并实践你所学的所有内容时发现这一点。
