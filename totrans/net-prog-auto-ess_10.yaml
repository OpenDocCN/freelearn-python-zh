- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hands-On and Going Forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, you have reached the last chapter of this book, and nothing
    is better than having some real examples using network automation to help consolidate
    all of the knowledge learned. We probably won’t be able to write examples on all
    the subjects covered in this book, but the idea is to have at least a foundation
    for further experimentation and learning.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to build a network from scratch using our network
    automation skills and emulated routers. The finished network emulated will have
    enough components for us to experiment with several techniques described in this
    book. You will be able to use it for your own experimentation whenever you need
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to add a few remarks and some guidance for future studies
    and work, which should be good enough to wrap up the book.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you are going to be able to build your own network
    emulation and experiment with your own network automation projects within your
    own computer, which will give you a great environment foundation for future experimentation
    and learning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a network lab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building our network lab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going forward and further studies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code described in this chapter is stored in the GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Using a network lab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time for us to do some real code automation tests in a virtual environment.
    Certain open source and commercial products can be used in your environment for
    testing network automation. The differences between the commercial and open source
    solutions rely on the number of different types of devices that are supported
    and how to scale. Using an open source solution, you might be able to scale up
    thousands of devices, but it would be limited in terms of the types of devices
    that can be emulated. A combination of a commercial and open source network might
    be more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco has a program that allows the public to access emulated routers in a virtual
    lab; they are called sandboxes. Cisco offers free 24/7 remote access to its sandboxes,
    but the number of devices is limited. More on Cisco sandboxes can be found at
    [https://developer.cisco.com/site/sandbox/](https://developer.cisco.com/site/sandbox/).
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the `scrapligo` project, described in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166),
    uses Cisco sandboxes; check details on the usage at [https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14](https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14).
    There are also other commercial products, such as Cisco Packet Tracer, which is
    part of the Cisco Network Academy (https://www.netacad.com/courses/packet-tracer),
    and EVE-NG ([https://www.eve-ng.net/](https://www.eve-ng.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: In terms of open source, the most popular ones are GNS3 ([https://gns3.com/](https://gns3.com/))
    and Mininet ([http://mininet.org](http://mininet.org)/). Mininet uses Linux containers
    to scale up the network, while GNS3 is more focused on virtual machines such as
    Dynamips. Therefore, GNS3 can run with several different router types but is limited
    in scale. On the other hand, Mininet can scale to thousands, but with only one
    router type, which is more appropriate for testing network concepts and network
    topologies instead of functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: For us, it will be more interesting to start from the ground and build our own
    network lab, which will give us more insights on how to use it and how we can
    use network automation tools, which, in fact, will be helpful later for real networks.
    The basis of our network lab will be Linux containers. Consequently, we need to
    use routers that can be easily containerized, and because of license issues, we
    should stick with open source solutions such as FRRouting, Quagga, OpenWRT, or
    DD-WRT, as described in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
  prefs: []
  type: TYPE_NORMAL
- en: Our network lab will use FRRouting as the basis of our routers, which has an
    interface configuration close to Cisco routers and can be accessed via the `vtysh`
    command. More details on FRRouting setup and configuration can be found at [https://docs.frrouting.org/en/latest/basic.html](https://docs.frrouting.org/en/latest/basic.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now build our own network lab.
  prefs: []
  type: TYPE_NORMAL
- en: Building our network lab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our network lab, we are going to use Linux containers for all our devices.
    There will basically be two types of devices, one running a router and one running
    Linux. The Linux containers that are not working as routers are going to be used
    to generate traffic or to receive traffic; they are going to mimic a user’s PC
    and a server on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intended topology is described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Network lab topology](img/B18165_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Network lab topology
  prefs: []
  type: TYPE_NORMAL
- en: The containers that are going to work as routers are the white rectangles in
    *Figure 10.1*, the yellow rectangles are going to work as user PCs, and the green
    rectangle is going to emulate the servers on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: In total, the network lab will have 16 routers, 3 PCs, and 1 server. The container
    images to be used in the network lab were created using Docker and stored in Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)), which are publicly available
    and can be used for image download. The routers were created based on the FRRouting
    docker image ([https://hub.docker.com/r/frrouting/frr](https://hub.docker.com/r/frrouting/frr))
    and the PCs and server were created based on the Alpine Linux Docker image ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)).
  prefs: []
  type: TYPE_NORMAL
- en: The original images were slightly modified with a few more tools and configuration
    changes to create three new images. The image for the routers is [hub.docker.com/r/brnuts/routerlab](https://hub.docker.com/r/brnuts/routerlab),
    the image for the PCs is [hub.docker.com/r/brnuts/pclab](https://hub.docker.com/r/brnuts/pclab),
    and the image for the internet is [hub.docker.com/r/brnuts/internetlab](https://hub.docker.com/r/brnuts/internetlab).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see now how we can launch our lab host.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the lab host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Linux containers need a host to run from. Therefore, you will first need
    to launch the Linux host where the routers will be running. I prepared two pre-built
    images to help, one for VirtualBox and another for Qemu. You can get instructions
    on how to download them and launch them on GitHub: `Chapter10/NetworkLab/README.md`.
    These virtual machine images use Debian Linux.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you don’t want to use the pre-built virtual machine, I have also
    included instructions on how to build your own host, which is basically any Linux
    distribution with additional packages and some configuration changes. If you build
    your own image, you will need to start all containers by yourself. I have added
    a script in Shell that should be able to do that, called `start-containers.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have launched the host, let’s see how we can check whether it was launched
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the lab host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After uncompressing and launching the pre-built image, you should be able to
    see all devices running once the host has finished the boot sequence. The reason
    is that I have updated the containers so that they restart automatically unless
    explicitly stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify whether the containers representing the devices are running, you
    just need to use the `docker ps` command, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Output showing all devices running on the network lab](img/B18165_10_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Output showing all devices running on the network lab
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `docker ps` command should show all running devices, which
    should be, in total, 20 containers, 16 representing routers (using the `brnuts/routerlab`
    image), 3 representing PCs (using the `brnuts/pclab` image), and 1 representing
    the internet (using the `brnuts/internetlab` image).
  prefs: []
  type: TYPE_NORMAL
- en: I have also added volumes to all containers and attached them as persistent
    storage, so configuration changes won’t be removed even on restarting the container.
    To see the volumes, you can just type in `docker volume list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check whether `/etc/hosts` was updated with the IPs of the containers.
    You should be able to see several lines after `# BEGIN DOCKER CONTAINERS`, as
    in the example in the following screenshot. This file is updated by the `update-hosts.sh`
    script included by `systemctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Checking the /etc/hosts file](img/B18165_10_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Checking the /etc/hosts file
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to explain later why we need LLDP in the next section, but for
    now, let’s just check whether `lldpd` is running on the host using the `systemctl
    status lldpd.service` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Checking whether lldpd is running on the host](img/B18165_10_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Checking whether lldpd is running on the host
  prefs: []
  type: TYPE_NORMAL
- en: If the `lldpd` daemon is running correctly, you should be able to see `active
    (running)` in green, as in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we should be ready to start doing some network automation to finish building
    our lab. Let’s now see how we connect the devices.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting the devices in our network lab will be done by using `veth` peer
    interfaces as was explained in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
    If we need to connect two different labs from two different hosts, we can use
    VXLAN, but for our exercise in this section, we are only making connections on
    the same host. Therefore, `veth` peer interfaces will do the job.
  prefs: []
  type: TYPE_NORMAL
- en: One protocol that I have included in the pre-built virtual machine image and
    will be very important to us is **Link Layer Discovery Protocol** (**LLDP**).
    LLDP is one IETF standard that came after the successful Cisco proprietary protocol
    called **Cisco Discovery Protocol** (**CDP**). It is used to obtain information
    about the other side of a layer 2 connection by sending specific Ethernet frames.
    We are going to use it to validate the connections between devices in our network
    lab.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed with our connections, let’s check how Docker created our **out-of-band**
    (**OOB**) management network.
  prefs: []
  type: TYPE_NORMAL
- en: The OOB management network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker, by default, creates a network connecting all containers, which we are
    going to use as our OOB management network (described in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015)).
    To do that, Docker creates `veth` interface peers between the container and the
    host. On the container side, Docker attributes `eth0` as the name, and on the
    other side, uses `veth` followed by some hexadecimal characters to make it unique
    – for instance, `veth089f94f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All `veth` interfaces located on the host are then connected to a software
    bridge called `docker0`. To use the `brctl` command, you might need to install
    the `bridge-utils` package by doing `sudo apt install bridge-utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Checking interfaces on the docker0 bridge](img/B18165_10_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Checking interfaces on the docker0 bridge
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify which `veth` interface belongs to which container, you might need
    to perform two commands, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Checking the veth peer name on the host for a container](img/B18165_10_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Checking the veth peer name on the host for a container
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the output of the preceding screenshot, to identify which
    `veth` peer interface belongs to the `border` router, you need to execute a command
    inside the container to obtain an index for the `eth0` interface, which, in this
    case, was `23`. Once you have the index, you can check which `veth` interface
    on the host has the index by using a `grep` command on all files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use LLDP to find out the `veth` interface name by doing the command
    directly on the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Showing the LLDP neighbor inside the border router](img/B18165_10_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Showing the LLDP neighbor inside the border router
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows a successful output of `lldpctl` showing the
    `eth0` interface’s neighbor, which, in this case, is the host Debian Linux, with
    a `SysName` of `netlab`. The interface that peers with `eth0` on the border router
    is described in the `PortDescr` field as `veth089f94f` – the same interface that
    we discovered using the commands in *Figure 10.6*.
  prefs: []
  type: TYPE_NORMAL
- en: However, why not use the first method described in *Figure 10.6* to find out
    the connection instead of LLDP? Because in real networks, LLDP is used to identify
    the connections between devices. Thus, writing an automation code to verify all
    the network connections in the lab using LLDP can also be used in production.
    Our lab will be used as the first place to test our automation code – in this
    case, checking the LLDP topology.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have probably noticed that we can access the routers just by using
    the `docker exec <name of the router>` command, so why do we need the OOB management
    network to access the devices? The answer is like the LLDP case – with OOB network
    access, the devices can be accessed via SSH, which is what we are going to do
    in production. Consequently, any code developed for the lab can be used in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our lab OOB management network, we just need to access the device via
    the IP using `ping` or `ssh` commands – the `ping cpe-a` command, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Testing connection to a router from the host using OOB](img/B18165_10_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Testing connection to a router from the host using OOB
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also be able to SSH to any container, using `netlab` for the username
    and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Testing whether you can access a device via SSH using OOB](img/B18165_10_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Testing whether you can access a device via SSH using OOB
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how our OOB management network works in our lab, let’s connect
    the devices using the OOB network.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Figure 10.1* shows the topology that we are aiming to create. The devices
    in our lab are running and connected to an OOB network, but they do not have connections
    like the topology described in *Figure 10.1*.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the diagram, there is also a formal topology description in a
    file on GitHub, which can be accessed at `Chapter10/NetworkLab/topology.yaml`.
    The file describes the routers in the topology and their connections. It is a
    simple version of network definition in YAML format as we discussed in [*Chapter
    4*](B18165_04.xhtml#_idTextAnchor100).
  prefs: []
  type: TYPE_NORMAL
- en: 'The topology file has basically two main keys, `devices` and `links`. These
    keys should describe the same connections shown in *Figure 10.1*. The following
    is a sample of the file for the `devices` and `links` keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The file should contain all the links that are depicted in *Figure 10.1*. Ideally,
    the diagram in *Figure 10.1* should be created automatically by a tool reading
    from `topology.yaml`. In our example, the diagram and the YAML file are the same,
    but I have built the diagram manually myself, and for any topology change, I need
    to update the `topology.yaml` file and the diagram. This problem was discussed
    as well in [*Chapter 4*](B18165_04.xhtml#_idTextAnchor100), and the update synchronization
    between a file and a diagram tends to break as the topology gets more complex.
    But, for our examples using this small topology, an automated diagram builder
    is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the connections between devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To connect the devices, like in the topology, we have to use `veth` peer interfaces,
    and as we discussed in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209), we need
    the namespace numbers for each side of the peer and the interface names we going
    to use. Most of the connections in *Figure 10.1* are point-to-point between devices,
    except for the connections to the **backbone** or **WAN**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows all the `veth` peers that we must configure; the
    majority are connected between two containers in a point-to-point configuration.
    However, the core routers will use, let’s say, backbone veth or WAN veth, because
    they are connected in a multi-to-multi-point environment, similar to a WAN. For
    that, we are going to use a software bridge in the host to provide connectivity
    between the backbone veth – latency and packet loss can be added to the bridge
    interfaces if tests for network degradation are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Lab topology showing all veth peer interfaces](img/B18165_10_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Lab topology showing all veth peer interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'When we start creating the `veth` interfaces for the backbone to connect all
    core routers, we are going to use one namespace on the host and the other in the
    core router. This is different from all other veth, which will have two namespaces.
    The following is one example of how to create a connection manually between `pc-a`
    and `cpe-a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in these commands, first, we need to obtain the network namespace
    IDs of each router we want to connect, and then we can create the `veth` peer
    and attribute each side of the peer to a namespace ID. Finally, we bring the interfaces
    up on each router. Note that the interface name on `pc-a` is `pc-cpe` and on `cpe-a`
    is `cpe-pc`, to help identify the direction in which the interface goes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify whether our connection between the routers was created properly,
    we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Checking the connection between pc-a and cpe-a](img/B18165_10_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Checking the connection between pc-a and cpe-a
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can confirm that `pc-a` is connected to `cpe-a` by looking into the
    `lldpctl` command output in *Figure 10.11*. The output shows the name for `SysName`,
    which is `cpe-a`, confirming the connection. We can also see the interface name
    on the other side, which is `cpe-pc`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how we automate the device connections.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the connections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our lab now has all devices running, and we are going to connect all devices
    using a program that will connect all devices. You can get access to the program
    on `Chapter10/NetworkLab/AUTOMATION.md`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it on your computer, just need to clone it using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you need to build the Go program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using the pre-build VirtualBox image, you probably are accessing
    the network lab via SSH on localhost port `22`. Then, you just need to run it
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using QEMU or your own Linux virtual machine with the network lab,
    you can pass the username, password, and IP of the host as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A small help guide can be accessed by adding `-help`, like here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The program shows some logs on the output, and a successful run should show
    similar lines to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Running the Go automation program to connect devices](img/B18165_10_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Running the Go automation program to connect devices
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the program takes around 12 seconds
    to run, and it should show `all done successfully` at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at this program and what it is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Looking into the automation program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, the program was written in Go, and the directory where it is
    located consists of nine files, of which six are Go source code with `.go` extensions
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s discuss each file.
  prefs: []
  type: TYPE_NORMAL
- en: go.mod and go.sum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These files are used by the Go builder for package dependency management; they
    contain all the necessary information to add the third-party library to our program.
    Every time we import a package, it automatically updates these files. More on
    these files can be obtained at [https://go.dev/ref/mod](https://go.dev/ref/mod).
  prefs: []
  type: TYPE_NORMAL
- en: topology.yaml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This contains the description of the topology that is shown in *Figure 10.1*.
  prefs: []
  type: TYPE_NORMAL
- en: types.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This contains all the data structure definitions used in the program, which
    include variable types and the YAML topology data structure. Different from Python,
    in Go, it is better to specify the data structure that you are going to read from
    a YAML file. In our case, the `TopologyConfType` struct type is used to define
    the YAML file structure, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: readtopology.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This contains the function that is used to read the `topology.yaml` file. The
    data structure of this file is defined in the `TopologyConfType` structure type.
  prefs: []
  type: TYPE_NORMAL
- en: runcommand.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This contains generic functions that wrap the command to run on the host of
    the lab. If an error occurs by running a command, the output is combined with
    the error message to be returned in the error message, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The idea to add the output to the error message is because when running remote
    commands via SSH and shell, the error might not be easy to interpret without the
    `stdout` messages.
  prefs: []
  type: TYPE_NORMAL
- en: veth.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This contains the functions that form the command strings that will be used
    to run on the host to create or manipulate `veth` interfaces. It also contains
    all functions that are used to populate the `conf.Veths` list, such as `loadVeth()`
    and `createPeerVeths()`.
  prefs: []
  type: TYPE_NORMAL
- en: hostconnect.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This file contains the function used to connect to our lab. In our case, we
    are using a third-party package called `melbahja/goph`, which is an SSH client
    that allows the execution of a command and immediate output. For faster and better
    performance, we should use vSSH instead, as explained in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166).
  prefs: []
  type: TYPE_NORMAL
- en: netlab.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the main program file that contains the `main()` and `init()` functions.
    The library called `flags` is used to pass arguments during the command execution
    in the shell. By default, they are initiated in the `init()` function, and they
    use default values if the arguments are not passed.
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function also describes the flow of the whole process, which consists
    of five main calls – `readTopologyFile`, `connectToHost`, `loadVeths`, `createVeths`,
    and `addVethsToBackbone`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all devices connected and we understand how the automation
    works, let’s do some manual checks to verify that the connections have been created
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the connections manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create automation for checking connections, we have to understand how the
    process of checking connections works first. Once we know how a manual check works,
    we can later automate it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `netlab` program has run without errors, it should have created the
    connections and the software bridge called `backbone`, and attached the WAN interfaces
    to it. Let’s use the following figure as guidance for our manual verification
    of the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Diagram showing where we manually check the connections](img/B18165_10_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Diagram showing where we manually check the connections
  prefs: []
  type: TYPE_NORMAL
- en: The figure shows numbers to indicate where we are going to do the manual checks.
    Let’s first start checking the connection that is represented by **1**. We are
    going to use LLDP to validate the connection in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the `sudo lldpctl cpe-acc` command,
    which runs inside the `cpe-a` router via SSH. Note that in the example, we start
    from the `netlab` host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection
    to acc-a](img/B18165_10_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection
    to acc-a
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `cpe-acc` interface in the `cpe-a` router is connected to
    the `acc-cpe` interface in the `acc-a` router.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate the connection for case `core-a1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection
    to the backbone](img/B18165_10_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection
    to the backbone
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `core-a1` router’s interface, `core-a1-wan`, is connected
    to the `netlab` host via `wan-core-a1`. To verify whether the `wan-core-a1` interface
    belongs to the `backbone` bridge, we need to perform one of the extra commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone
    bridge](img/B18165_10_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone bridge
  prefs: []
  type: TYPE_NORMAL
- en: Either of the commands shown in *Figure 10.16* confirms that `wan-core-a1` belongs
    to `backbone`. The difference is the second command presents the output in a JSON
    format, which is easier to parse by software. `lldpctl` also supports JSON output
    using `lldpctl -f json`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss how we can add more automation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are infinite possibilities for processes for which you might want to create
    automation. Most of the operational procedures are repetitive and prone to errors
    if manually operated. So, we need to automate our network as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s then describe a few simple forms of automation that can help our network
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Link connection check automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the procedures that is very important and requires lots of attention
    is the build and construction of the physical network, in particular a physical
    rack and its cables. Its complexity will vary, depending on whether a star topology
    configuration or a Clos topology configuration is used, which we discussed in
    [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015).
  prefs: []
  type: TYPE_NORMAL
- en: A mixed topology configuration that combines all possible topologies is even
    more complex, and its complexity will increase the chances of building a network
    incorrectly. For instance, a Clos network, as shown in *Figure 10.17*, has a total
    of 32 connections, and imagine the complexity added if three more routers were
    included.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Clos network connections](img/B18165_10_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Clos network connections
  prefs: []
  type: TYPE_NORMAL
- en: Having included **E5**, **S5**, and **L5**, the Clos network will have now 50
    connections. So, for us, connection check automation is important to avoid operation
    failures down the network setup.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, our network lab can be used for us to test the automation
    of the link connection check, which can be used later in production.
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, a bastion host normally needs to be accessed first,
    before accessing the devices using the OOB network. In our network lab, the bastion
    is the same as the network lab host. Once logged in to the bastion, the automation
    code can then access the router via the OOB network, which is the same as in the
    network lab.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now write some code to automate this process
  prefs: []
  type: TYPE_NORMAL
- en: Link check example code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have added a Python script that returns a JSON list format with all interfaces
    and the device connected to each interface for a particular device. The Python
    code can be accessed at `Chapter10/NetworkLab/AUTOMATION.md`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run a few examples to see how the Python script works; the following
    screenshot is showing results for the `internet` device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Output for checking connections to the internet device](img/B18165_10_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Output for checking connections to the internet device
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `internet` device has only two interfaces, one connected
    via the OOB network with the `eth0` interface to the `netlab` device, and one
    interface called `internet-border` connected to the `border` device, which confirms
    the connections in *Figure 10.1*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now check how the `border` device is connected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Output for checking connections of the border device](img/B18165_10_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Output for checking connections of the border device
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 10.19*, the `border` device is connected to the `internet`
    device and three core routers, `core-i1`, `core-i2`, and `core-i3`, as in *Figure
    10.1*.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this for all devices, you should confirm all the connections. But
    can we automate confirming connections for all routers in just one run? Yes, of
    course, but for that, we will need to read `topology.yaml`, and then create a
    loop that will run on each device to confirm the connections. I will leave completing
    this as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now explain some parts of the `show-connections.py` code.
  prefs: []
  type: TYPE_NORMAL
- en: Looking into the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `show-connections.py` Python code uses the `paramiko` third-party library
    as the base for the SSH connection, which we discussed in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166),
    (`paramiko` can be installed using `pip install paramiko`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Paramiko is a lower-level SSH connectivity library that allows us to create
    an SSH session within an SSH session because we are using a bastion to connect
    to our devices in the network lab, which is the lab host. The details of this
    stacked SSH connection are described in the code by the `NetLab()` class, which
    has a method to connect to the bastion called `connectBastion()`, and a method
    to connect to a device called `connectDevice()`. Note that these methods use a
    class attribute called `self.transport` to pass the bastion `paramiko` handler
    to the device channel described in the code and shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are other ways to use bastion, such as using SSH proxies or SSH agents.
    However, in our example, I wanted to show how to natively create an SSH stack
    connection. Because if you do have two bastions before connecting a device, it
    is also possible to use `paramiko`, but perhaps not that easy using SSH agents
    and proxies.
  prefs: []
  type: TYPE_NORMAL
- en: In the Python code, we use `argparser` to add arguments to our command line,
    so you can change the address of the bastion or the username and password. The
    arguments and default values are located in `parse_arguments()`. A help guide
    is also automatically produced if you type `--help`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – help output for the Python code show-connections.py](img/B18165_10_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – help output for the Python code show-connections.py
  prefs: []
  type: TYPE_NORMAL
- en: I will leave you to improve this Python script to read the `topology.yaml` file
    and then verify all the connections in the network lab depicted in *Figure 10.1*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can automate the IP configuration for the interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: IP configuration automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can use our network for IP traffic, we need to attribute IPs to our
    network interfaces, which can be done manually by adding IPs to each interface,
    or we can create an automated code that distributes the IPs and configure them
    on the devices in the network lab.
  prefs: []
  type: TYPE_NORMAL
- en: For our network lab, there are basically two types of IP allocation, one that
    is point-to-point between devices, and one that is multi-point for the WAN on
    the backbone interfaces. Let’s give an example of automation for the WAN interfaces.
    The Python code called `configure-ip-wan.py` is located at `Chapter10/NetworkLab/AUTOMATION.md`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output after running the `configure-ip-wan.py`
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Output of the configure-ip-wan.py Python code](img/B18165_10_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Output of the configure-ip-wan.py Python code
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the IPs are configured on the devices using Paramiko, as in the previous
    example. The code uses the `ipaddress` Python library, which allocates the IPs
    that will be used in the WAN interfaces by creating a list of IPs using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, each IP is obtained by using `pop()` in the `valid_ips` list, like in
    the following loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test the IP connectivity between devices in the WAN using the Python
    script included at `Chapter10/NetworkLab/AUTOMATION.md`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via
    the WAN](img/B18165_10_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via the
    WAN
  prefs: []
  type: TYPE_NORMAL
- en: From the output shown in *Figure 10.21*, we can assume the `core-b1` interface
    IP is `10.200.200.4`. So, the test executed on `core-a1` is testing the IP connectivity
    between `core-a1` and `core-b1` via the `backbone` bridge.
  prefs: []
  type: TYPE_NORMAL
- en: To finish the IP configuration, you will have to also configure IPs for all
    other interfaces. I will leave adding the IPs to other network lab interfaces
    as an exercise, but for now, the example is sufficient to guide you to proceed.
  prefs: []
  type: TYPE_NORMAL
- en: Additional network lab automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s discuss briefly what other possible automation we can add to our lab.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can add code that can read the `topology.yaml` file and then, based on what
    is running, determine whether certain modifications are required, such as adding
    devices or removing devices. I will say that is easier for us to just tear down
    a network lab and start another one from scratch instead of removing and adding
    devices because, in our network emulation, the shutdown and startup are quick.
  prefs: []
  type: TYPE_NORMAL
- en: So, adding code to remove and add devices is more of an exercise than a real
    utility in our network lab.
  prefs: []
  type: TYPE_NORMAL
- en: Using gRPC for automation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We also can do some automation using gRPC, as FRRouting supports this interface.
    With this, we eliminate the necessity to access the devices via SSH. You can find
    more on gRPC for FRRouting at [https://docs.frrouting.org/en/latest/grpc.html](https://docs.frrouting.org/en/latest/grpc.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using NETCONF for automation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use NETCONF for automation, you need to have `libyang` installed in the router
    image, which, in our network lab, is FRRouting running on Alpine Linux. To add
    `libyang`, just type the `sudo apk add libyang` command on the router device.
    Using FRRouting and NETCONF together is not a very well-documented option, so
    good luck doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Adding network degradation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add latency, jitter, packet loss, congestion, and other degradations
    to your network lab, which can be permanent or vary over time. To remove and add
    these degradations, the best thing to do is to write automated code that can apply
    the necessary traffic shaping mechanisms and then remove them. We discussed these
    degradation methods in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we can add some latency to the backbone interfaces in our network
    lab by using Linux `tc` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command should run on the lab host, and it will add a 100 ms delay to the
    `wan-core-a1` interface that connects `core-a1` to the backbone.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 10.23* show the same test done in *Figure 10.22* but with WAN latency
    added.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to
    WAN](img/B18165_10_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to WAN
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to add other network degradations to your network lab by automating
    how Linux traffic control can be used in the network lab interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Configure routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this stage, our network lab does not provide IP traffic capabilities because
    it does not know how to route IP packets. Two kinds of routing can be done using
    static routes by configuring the interfaces with them or adding dynamic protocol
    for the devices to talk and exchange routing tables.
  prefs: []
  type: TYPE_NORMAL
- en: As all routers in our network lab are FRRouting; the protocols available that
    can be used are EIGRP, OSPF, ISIS, RIP, or BGP. A complete list and more details
    can be found at [https://docs.frrouting.org/](https://docs.frrouting.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Many more kinds of automation are possible. Some will only work for the network
    lab, but some could be used in a production network. Hopefully, you can use the
    network lab to improve your network automation code skills, and then gain more
    confidence on building a solution for a production network.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now discuss what to do next and further study.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward and further study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are probably now thinking about what to do next and how you can progress
    to the next topic in network automation. I have put together a few suggestions
    here that I would recommend following, but keep in mind that there might be many
    other paths to follow. So, it is just a humble suggestion, and I hope you can
    enjoy the journey.
  prefs: []
  type: TYPE_NORMAL
- en: Checking popular platforms and tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many automation platforms that you can use and perhaps investigate
    how they work. This list will be dynamic and may change from one year to another.
    So, keep in mind how to search for them and how to evaluate them.
  prefs: []
  type: TYPE_NORMAL
- en: I have done superficial research on some of the platforms, but I would recommend
    going deeper if you want to improve your knowledge and get even sharper on how
    to automate a network. You may get some ideas, and perhaps improve what you are
    doing today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a small list of the most popular automation platforms and tools that
    you might want to have a look at, not in any particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Salt project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A remote execution manager'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/saltstack/salt](https://github.com/saltstack/salt
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 2K'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: February 2011'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 98%'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor: VMware/public'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 13K stars, 5.4K forks, 544 watching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Ansible project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A simple automation system for configuration management,
    deployment, and orchestration'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/ansible/ansible](https://github.com/ansible/ansible
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 5K'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: March 2012'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 88%, PowerShell 6.9%'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: GPL 3.0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor: Red Hat'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 56K stars, 23K forks, 2K watching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Puppet project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A general administrative management system designed to configure,
    update, and install systems'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/puppetlabs/puppet](https://github.com/puppetlabs/puppet
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 1K'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: September 2010'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Ruby 99%'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor/Owner: Puppet by Perforce'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 6.8K stars, 2.3K forks, 475 watching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Chef project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A configuration management tool designed to cover the automation
    of all IT infrastructure'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/chef/chef](https://github.com/chef/chef)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 1K'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: January 2009'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Ruby 98%'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor/Owner: Progress Software Corporation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 7.1K stars, 2.6K forks, 374 watching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Stackstorm project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: An event-driven automation tool'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/StackStorm/st2](https://github.com/StackStorm/st2
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: Over 300'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: April 2014'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 94%'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: Apache 2.0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor/Owner: Linux Foundation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 5.4K stars, 696 forks, 168 watching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The eNMS automation project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A higher-level management system to create workflow-based
    network automation solutions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source: [https://github.com/eNMS-automation/eNMS](https://github.com/eNMS-automation/eNMS
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contributors: 30'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Repository creation date: October 2017'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Top languages: Python 53%, JavaScript 26%, HTML 16%'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'License: GLP 3.0'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sponsor: N/A'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Popularity: 700 stars, 148 forks, 73 watching'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NetBrain products:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: NetBrain has developed several products for network automation,
    including **Problem Diagnosis Automation System** (**PDAS**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.netbraintech.com/](https://www.netbraintech.com/ )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Owner: NetBrain Automation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SolarWinds Network Automation Manager:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: Proprietary product developed by SolarWinds for network
    automation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.solarwinds.com/network-automation-manager](https://www.solarwinds.com/network-automation-manager
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Owner: SolarWinds'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the tools and platforms that you can investigate, you also can participate
    in working groups related to network automation. Let’s have a look at some of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Joining the network automation community
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the strategies to improve your knowledge and get updated with new technologies
    is to participate in the community. The following is a small list of possible
    groups that you might be interested in watching or participating in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'IETF netmgmt working group:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: A group that has a focus on working on standards for automated
    network management, such as RESTCONF, NETCONF, and YANG'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.ietf.org/topics/netmgmt/](https://www.ietf.org/topics/netmgmt/
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Meetup groups:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: One good idea is to join a local meetup group that has regular
    meetings. Then, you can talk with professionals in the same area and improve your
    network and knowledge. [https://www.meetup.com/](https://www.meetup.com/) is a
    site where people can organize and meet.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example in New York: [https://www.meetup.com/Network-to-Coders/](https://www.meetup.com/Network-to-Coders/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example in Sydney: [https://www.meetup.com/it-automation/](https://www.meetup.com/it-automation/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example in San Francisco: [https://www.meetup.com/sf-network-automation/](https://www.meetup.com/sf-network-automation/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**North American Network Operators’ Group** (**NANOG**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: NANOG has tons of documents and presentations, and also
    organizes conferences where you can find multiple topics on network automation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.nanog.org/](https://www.nanog.org/ )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global Network Advancement Group** (**GNA-G**):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: GNA-G is a community of network professionals from several
    areas, including research, operation, and education all over the world. They organize
    meetings and have some documentation resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Site: [https://www.gna-g.net/](https://www.gna-g.net/).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Network to Code company community:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: Network to Code is a consulting company that maintains GitHub
    repositories and a [slack.com](https://slack.com) group that discusses network
    automation, which can be joined for free'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/networktocode/awesome-network-automation](https://github.com/networktocode/awesome-network-automation
    )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slack group: [networktocode.slack.com](https://networktocode.slack.com )'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IP Fabric company community:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Short description: The IP Fabric company also maintains GitHub repositories
    and has a [slack.com](http://slack.com) group open to anyone to join'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub: [https://github.com/community-fabric](https://github.com/community-fabric)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Slack group: [ipfabric-community.slack.com](http://ipfabric-community.slack.com)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Other communities also can be found attached to some private companies, such
    as IBM, Oracle, VMware, Google, and Amazon. They might even use public tools such
    as Slack, LinkedIn, or GitHub to communicate, and they are maybe more focused
    on products that these companies offer instead of generic discussion. They are
    worth checking out, because they might have something to add.
  prefs: []
  type: TYPE_NORMAL
- en: Another idea to improve your knowledge and skills is to contribute to a platform
    that already exists as a developer, or to build your own if you dare.
  prefs: []
  type: TYPE_NORMAL
- en: I hope this section can give you ideas on the path forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was focused on getting your hands dirty in a network lab, checking
    how some code automation works in Go and Python, and, finally, exploring the possibilities
    of how to go forward with network automation.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should be very confident about how to build your own network
    lab, how to improve your network automation code, and what to do next to continue
    improving.
  prefs: []
  type: TYPE_NORMAL
- en: On behalf of all the people who worked hard on this book, we want to thank you
    for investing the time to read this book. It was a hard accomplishment to gather
    so much information and pass it on to others in an easy and pleasurable way. I
    hope you have made the most of it by reading it and discovering new technologies
    and techniques in the realm of network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can embark on further challenges that will take you deeper into network
    automation, which you will find when building a complete solution and putting
    into practice everything that you have learned.
  prefs: []
  type: TYPE_NORMAL
