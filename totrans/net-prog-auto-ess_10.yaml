- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Hands-On and Going Forward
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践和前进
- en: Congratulations, you have reached the last chapter of this book, and nothing
    is better than having some real examples using network automation to help consolidate
    all of the knowledge learned. We probably won’t be able to write examples on all
    the subjects covered in this book, but the idea is to have at least a foundation
    for further experimentation and learning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经到达了这本书的最后一章，没有什么比用一些使用网络自动化的真实例子来巩固所学的所有知识更好的了。我们可能无法为这本书涵盖的所有主题都编写例子，但目的是至少为进一步的实验和学习打下基础。
- en: In this chapter, we are going to build a network from scratch using our network
    automation skills and emulated routers. The finished network emulated will have
    enough components for us to experiment with several techniques described in this
    book. You will be able to use it for your own experimentation whenever you need
    it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们的网络自动化技能和模拟路由器从头开始构建一个网络。构建完成的模拟网络将包含足够的组件，使我们能够实验本书中描述的几种技术。无论何时你需要，你都可以用它来进行自己的实验。
- en: We are also going to add a few remarks and some guidance for future studies
    and work, which should be good enough to wrap up the book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些关于未来学习和工作的备注和指导，这应该足以结束本书。
- en: At the end of this chapter, you are going to be able to build your own network
    emulation and experiment with your own network automation projects within your
    own computer, which will give you a great environment foundation for future experimentation
    and learning.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够构建自己的网络模拟，并在自己的计算机上实验自己的网络自动化项目，这将为你未来的实验和学习提供一个很好的环境基础。
- en: 'We are going to cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Using a network lab
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络实验室
- en: Building our network lab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建我们的网络实验室
- en: Connecting the devices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接设备
- en: Adding automation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加自动化
- en: Going forward and further studies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前进和进一步学习
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code described in this chapter is stored in the GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的源代码存储在GitHub仓库[https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter10)。
- en: Using a network lab
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络实验室
- en: It’s time for us to do some real code automation tests in a virtual environment.
    Certain open source and commercial products can be used in your environment for
    testing network automation. The differences between the commercial and open source
    solutions rely on the number of different types of devices that are supported
    and how to scale. Using an open source solution, you might be able to scale up
    thousands of devices, but it would be limited in terms of the types of devices
    that can be emulated. A combination of a commercial and open source network might
    be more useful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在我们虚拟环境中进行一些真正的代码自动化测试了。某些开源和商业产品可以在你的环境中用于测试网络自动化。商业和开源解决方案之间的区别在于支持的设备类型数量以及如何扩展。使用开源解决方案，你可能能够扩展数千台设备，但在模拟的设备类型方面可能会有所限制。商业和开源网络的组合可能更有用。
- en: Cisco has a program that allows the public to access emulated routers in a virtual
    lab; they are called sandboxes. Cisco offers free 24/7 remote access to its sandboxes,
    but the number of devices is limited. More on Cisco sandboxes can be found at
    [https://developer.cisco.com/site/sandbox/](https://developer.cisco.com/site/sandbox/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco有一个项目允许公众访问虚拟实验室中的模拟路由器；它们被称为沙盒。Cisco提供免费24/7远程访问其沙盒，但设备数量有限。有关Cisco沙盒的更多信息，请参阅[https://developer.cisco.com/site/sandbox/](https://developer.cisco.com/site/sandbox/)。
- en: As an example, the `scrapligo` project, described in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166),
    uses Cisco sandboxes; check details on the usage at [https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14](https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14).
    There are also other commercial products, such as Cisco Packet Tracer, which is
    part of the Cisco Network Academy (https://www.netacad.com/courses/packet-tracer),
    and EVE-NG ([https://www.eve-ng.net/](https://www.eve-ng.net/)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*第 6 章* [B18165_06.xhtml#_idTextAnchor166] 中描述的 `scrapligo` 项目使用 Cisco 沙盒；有关使用详情，请参阅
    [https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14](https://github.com/scrapli/scrapligo/blob/main/examples/generic_driver/interactive_prompts/main.go#L14)。还有其他商业产品，例如
    Cisco Packet Tracer，它是 Cisco 网络学院的一部分（https://www.netacad.com/courses/packet-tracer），以及
    EVE-NG ([https://www.eve-ng.net/](https://www.eve-ng.net/))。
- en: In terms of open source, the most popular ones are GNS3 ([https://gns3.com/](https://gns3.com/))
    and Mininet ([http://mininet.org](http://mininet.org)/). Mininet uses Linux containers
    to scale up the network, while GNS3 is more focused on virtual machines such as
    Dynamips. Therefore, GNS3 can run with several different router types but is limited
    in scale. On the other hand, Mininet can scale to thousands, but with only one
    router type, which is more appropriate for testing network concepts and network
    topologies instead of functionalities.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源方面，最受欢迎的是 GNS3 ([https://gns3.com/](https://gns3.com/)) 和 Mininet ([http://mininet.org](http://mininet.org)/)。Mininet
    使用 Linux 容器来扩展网络，而 GNS3 则更专注于虚拟机，如 Dynamips。因此，GNS3 可以运行多种不同的路由器类型，但在规模上有限。另一方面，Mininet
    可以扩展到数千个，但只有一种路由器类型，这更适合测试网络概念和网络拓扑，而不是功能。
- en: For us, it will be more interesting to start from the ground and build our own
    network lab, which will give us more insights on how to use it and how we can
    use network automation tools, which, in fact, will be helpful later for real networks.
    The basis of our network lab will be Linux containers. Consequently, we need to
    use routers that can be easily containerized, and because of license issues, we
    should stick with open source solutions such as FRRouting, Quagga, OpenWRT, or
    DD-WRT, as described in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，从零开始构建自己的网络实验室将更有趣，这将让我们更深入地了解如何使用它以及我们如何使用网络自动化工具，实际上，这将在真实网络中有所帮助。我们网络实验室的基础将是
    Linux 容器。因此，我们需要使用易于容器化的路由器，并且由于许可问题，我们应该坚持使用如 FRRouting、Quagga、OpenWRT 或 DD-WRT
    等开源解决方案，如 *第 9 章* [B18165_09.xhtml#_idTextAnchor209] 中所述。
- en: Our network lab will use FRRouting as the basis of our routers, which has an
    interface configuration close to Cisco routers and can be accessed via the `vtysh`
    command. More details on FRRouting setup and configuration can be found at [https://docs.frrouting.org/en/latest/basic.html](https://docs.frrouting.org/en/latest/basic.html).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络实验室将使用 FRRouting 作为路由器的基础，它具有接近 Cisco 路由器的接口配置，可以通过 `vtysh` 命令访问。有关 FRRouting
    设置和配置的更多详细信息，请参阅 [https://docs.frrouting.org/en/latest/basic.html](https://docs.frrouting.org/en/latest/basic.html)。
- en: Let’s now build our own network lab.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建自己的网络实验室。
- en: Building our network lab
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的网络实验室
- en: In our network lab, we are going to use Linux containers for all our devices.
    There will basically be two types of devices, one running a router and one running
    Linux. The Linux containers that are not working as routers are going to be used
    to generate traffic or to receive traffic; they are going to mimic a user’s PC
    and a server on the internet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络实验室中，我们将为所有设备使用 Linux 容器。基本上会有两种类型的设备，一种是运行路由器，另一种运行 Linux。那些不作为路由器运行的
    Linux 容器将被用来生成流量或接收流量；它们将模拟用户的 PC 和互联网上的服务器。
- en: 'The intended topology is described in the following diagram:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的拓扑结构在以下图中描述：
- en: '![Figure 10.1 – Network lab topology](img/B18165_10_001.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 网络实验室拓扑](img/B18165_10_001.jpg)'
- en: Figure 10.1 – Network lab topology
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 网络实验室拓扑
- en: The containers that are going to work as routers are the white rectangles in
    *Figure 10.1*, the yellow rectangles are going to work as user PCs, and the green
    rectangle is going to emulate the servers on the internet.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将作为路由器运行的容器是 *图 10.1* 中的白色矩形，黄色矩形将作为用户 PC 运行，绿色矩形将模拟互联网上的服务器。
- en: In total, the network lab will have 16 routers, 3 PCs, and 1 server. The container
    images to be used in the network lab were created using Docker and stored in Docker
    Hub ([https://hub.docker.com/](https://hub.docker.com/)), which are publicly available
    and can be used for image download. The routers were created based on the FRRouting
    docker image ([https://hub.docker.com/r/frrouting/frr](https://hub.docker.com/r/frrouting/frr))
    and the PCs and server were created based on the Alpine Linux Docker image ([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，网络实验室将拥有16台路由器、3台PC和1台服务器。网络实验室中使用的容器镜像使用Docker创建并存储在Docker Hub ([https://hub.docker.com/](https://hub.docker.com/))，这些是公开可用的，可以用于镜像下载。路由器是基于FRRouting
    Docker镜像([https://hub.docker.com/r/frrouting/frr](https://hub.docker.com/r/frrouting/frr))创建的，PC和服务器是基于Alpine
    Linux Docker镜像([https://hub.docker.com/_/alpine](https://hub.docker.com/_/alpine))创建的。
- en: The original images were slightly modified with a few more tools and configuration
    changes to create three new images. The image for the routers is [hub.docker.com/r/brnuts/routerlab](https://hub.docker.com/r/brnuts/routerlab),
    the image for the PCs is [hub.docker.com/r/brnuts/pclab](https://hub.docker.com/r/brnuts/pclab),
    and the image for the internet is [hub.docker.com/r/brnuts/internetlab](https://hub.docker.com/r/brnuts/internetlab).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 原始镜像经过了一些工具和配置更改的轻微修改，创建了三个新的镜像。路由器的镜像为[hub.docker.com/r/brnuts/routerlab](https://hub.docker.com/r/brnuts/routerlab)，PC的镜像为[hub.docker.com/r/brnuts/pclab](https://hub.docker.com/r/brnuts/pclab)，互联网的镜像为[hub.docker.com/r/brnuts/internetlab](https://hub.docker.com/r/brnuts/internetlab)。
- en: Let’s see now how we can launch our lab host.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何启动我们的实验室主机。
- en: Launching the lab host
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动实验室主机
- en: 'The Linux containers need a host to run from. Therefore, you will first need
    to launch the Linux host where the routers will be running. I prepared two pre-built
    images to help, one for VirtualBox and another for Qemu. You can get instructions
    on how to download them and launch them on GitHub: `Chapter10/NetworkLab/README.md`.
    These virtual machine images use Debian Linux.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux容器需要一个主机来运行。因此，你首先需要启动路由器将运行在其中的Linux主机。我准备了两个预构建镜像以帮助，一个是用于VirtualBox的，另一个是用于Qemu的。你可以在GitHub上找到如何下载和启动它们的说明：`Chapter10/NetworkLab/README.md`。这些虚拟机镜像使用Debian
    Linux。
- en: However, if you don’t want to use the pre-built virtual machine, I have also
    included instructions on how to build your own host, which is basically any Linux
    distribution with additional packages and some configuration changes. If you build
    your own image, you will need to start all containers by yourself. I have added
    a script in Shell that should be able to do that, called `start-containers.sh`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你不想使用预构建的虚拟机，我还包括了如何构建你自己的主机的说明，这基本上是任何带有额外包和一些配置更改的Linux发行版。如果你构建自己的镜像，你需要自己启动所有容器。我添加了一个Shell脚本，应该能够做到这一点，叫做`start-containers.sh`。
- en: Once you have launched the host, let’s see how we can check whether it was launched
    properly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了主机，让我们看看如何检查它是否正确启动。
- en: Checking the lab host
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查实验室主机
- en: After uncompressing and launching the pre-built image, you should be able to
    see all devices running once the host has finished the boot sequence. The reason
    is that I have updated the containers so that they restart automatically unless
    explicitly stopped.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在解压缩并启动预构建镜像后，一旦主机完成引导序列，你应该能够看到所有设备正在运行。原因是我已经更新了容器，以便它们会自动重启，除非明确停止。
- en: 'To verify whether the containers representing the devices are running, you
    just need to use the `docker ps` command, as in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证代表设备的容器是否正在运行，你只需使用`docker ps`命令，如下面的截图所示：
- en: '![Figure 10.2 – Output showing all devices running on the network lab](img/B18165_10_002.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 显示网络实验室上所有设备运行的输出](img/B18165_10_002.jpg)'
- en: Figure 10.2 – Output showing all devices running on the network lab
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 显示网络实验室上所有设备运行的输出
- en: The output of the `docker ps` command should show all running devices, which
    should be, in total, 20 containers, 16 representing routers (using the `brnuts/routerlab`
    image), 3 representing PCs (using the `brnuts/pclab` image), and 1 representing
    the internet (using the `brnuts/internetlab` image).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令的输出应该显示所有正在运行的设备，总共应该是20个容器，其中16个代表路由器（使用`brnuts/routerlab`镜像），3个代表PC（使用`brnuts/pclab`镜像），1个代表互联网（使用`brnuts/internetlab`镜像）。'
- en: I have also added volumes to all containers and attached them as persistent
    storage, so configuration changes won’t be removed even on restarting the container.
    To see the volumes, you can just type in `docker volume list`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我还向所有容器添加了卷，并将它们作为持久存储附加，因此即使在重启容器时配置更改也不会被删除。要查看卷，只需输入`docker volume list`即可。
- en: 'Now, check whether `/etc/hosts` was updated with the IPs of the containers.
    You should be able to see several lines after `# BEGIN DOCKER CONTAINERS`, as
    in the example in the following screenshot. This file is updated by the `update-hosts.sh`
    script included by `systemctl`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查`/etc/hosts`文件是否已更新为容器的IP地址。你应该能在`# BEGIN DOCKER CONTAINERS`之后看到几行，就像以下截图中的示例一样。此文件由`systemctl`中包含的`update-hosts.sh`脚本更新：
- en: '![Figure 10.3 – Checking the /etc/hosts file](img/B18165_10_003.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 检查/etc/hosts文件](img/B18165_10_003.jpg)'
- en: Figure 10.3 – Checking the /etc/hosts file
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 检查/etc/hosts文件
- en: 'We are going to explain later why we need LLDP in the next section, but for
    now, let’s just check whether `lldpd` is running on the host using the `systemctl
    status lldpd.service` command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节解释为什么我们需要LLDP，但现在，让我们使用`systemctl status lldpd.service`命令来检查主机上是否正在运行`lldpd`：
- en: '![Figure 10.4 – Checking whether lldpd is running on the host](img/B18165_10_004.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 检查主机上lldpd是否正在运行](img/B18165_10_004.jpg)'
- en: Figure 10.4 – Checking whether lldpd is running on the host
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 检查主机上lldpd是否正在运行
- en: If the `lldpd` daemon is running correctly, you should be able to see `active
    (running)` in green, as in the preceding screenshot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`lldpd`守护进程运行正确，你应该能在绿色中看到`active (running)`，就像前面的截图所示。
- en: Now, we should be ready to start doing some network automation to finish building
    our lab. Let’s now see how we connect the devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该准备好开始进行一些网络自动化，以完成构建我们的实验室。现在让我们看看我们如何连接设备。
- en: Connecting the devices
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接设备
- en: Connecting the devices in our network lab will be done by using `veth` peer
    interfaces as was explained in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
    If we need to connect two different labs from two different hosts, we can use
    VXLAN, but for our exercise in this section, we are only making connections on
    the same host. Therefore, `veth` peer interfaces will do the job.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络实验室中连接设备将通过使用`veth`对等接口来完成，正如在[*第9章*](B18165_09.xhtml#_idTextAnchor209)中所述。如果我们需要从两个不同的主机连接两个不同的实验室，我们可以使用VXLAN，但在这个部分的练习中，我们只在本主机上建立连接。因此，`veth`对等接口将完成这项工作。
- en: One protocol that I have included in the pre-built virtual machine image and
    will be very important to us is **Link Layer Discovery Protocol** (**LLDP**).
    LLDP is one IETF standard that came after the successful Cisco proprietary protocol
    called **Cisco Discovery Protocol** (**CDP**). It is used to obtain information
    about the other side of a layer 2 connection by sending specific Ethernet frames.
    We are going to use it to validate the connections between devices in our network
    lab.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我在预构建的虚拟机镜像中包含了一个协议，这对我们来说非常重要，那就是**链路层发现协议**（**LLDP**）。LLDP是IETF标准之一，它是在成功实施思科的专有协议**Cisco
    Discovery Protocol**（**CDP**）之后出现的。它通过发送特定的以太网帧来获取关于2层连接另一侧的信息。我们将使用它来验证我们网络实验室中设备之间的连接。
- en: Before we proceed with our connections, let’s check how Docker created our **out-of-band**
    (**OOB**) management network.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行连接之前，让我们检查Docker是如何创建我们的**带外**（**OOB**）管理网络的。
- en: The OOB management network
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带外管理网络
- en: Docker, by default, creates a network connecting all containers, which we are
    going to use as our OOB management network (described in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015)).
    To do that, Docker creates `veth` interface peers between the container and the
    host. On the container side, Docker attributes `eth0` as the name, and on the
    other side, uses `veth` followed by some hexadecimal characters to make it unique
    – for instance, `veth089f94f`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker创建了一个连接所有容器的网络，我们将使用它作为我们的带外管理网络（在第[*第1章*](B18165_01.xhtml#_idTextAnchor015)中描述）。为此，Docker在容器和主机之间创建`veth`接口对。在容器一侧，Docker将`eth0`作为名称，而在另一侧，使用`veth`后跟一些十六进制字符以使其唯一
    – 例如，`veth089f94f`。
- en: 'All `veth` interfaces located on the host are then connected to a software
    bridge called `docker0`. To use the `brctl` command, you might need to install
    the `bridge-utils` package by doing `sudo apt install bridge-utils`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 主机上的所有`veth`接口都连接到一个名为`docker0`的软件桥。要使用`brctl`命令，你可能需要通过执行`sudo apt install
    bridge-utils`来安装`bridge-utils`包：
- en: '![Figure 10.5 – Checking interfaces on the docker0 bridge](img/B18165_10_005.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 检查docker0桥接上的接口](img/B18165_10_005.jpg)'
- en: Figure 10.5 – Checking interfaces on the docker0 bridge
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 检查docker0桥接上的接口
- en: 'To verify which `veth` interface belongs to which container, you might need
    to perform two commands, as in the following example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证哪个`veth`接口属于哪个容器，你可能需要执行两个命令，如下例所示：
- en: '![Figure 10.6 – Checking the veth peer name on the host for a container](img/B18165_10_006.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 检查容器在主机上的veth对端名称](img/B18165_10_006.jpg)'
- en: Figure 10.6 – Checking the veth peer name on the host for a container
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 检查容器在主机上的veth对端名称
- en: As you can see in the output of the preceding screenshot, to identify which
    `veth` peer interface belongs to the `border` router, you need to execute a command
    inside the container to obtain an index for the `eth0` interface, which, in this
    case, was `23`. Once you have the index, you can check which `veth` interface
    on the host has the index by using a `grep` command on all files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图的输出所示，为了确定哪个`veth`对等接口属于`border`路由器，你需要在容器内执行一个命令以获取`eth0`接口的索引，在这种情况下，是`23`。一旦你有了索引，你可以通过在所有文件上使用`grep`命令来检查主机上的哪个`veth`接口具有该索引。
- en: 'We can also use LLDP to find out the `veth` interface name by doing the command
    directly on the router:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过在路由器上直接执行命令来使用LLDP找出`veth`接口名称：
- en: '![Figure 10.7 – Showing the LLDP neighbor inside the border router](img/B18165_10_007.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 显示边界路由器内的LLDP邻居](img/B18165_10_007.jpg)'
- en: Figure 10.7 – Showing the LLDP neighbor inside the border router
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 显示边界路由器内的LLDP邻居
- en: The preceding screenshot shows a successful output of `lldpctl` showing the
    `eth0` interface’s neighbor, which, in this case, is the host Debian Linux, with
    a `SysName` of `netlab`. The interface that peers with `eth0` on the border router
    is described in the `PortDescr` field as `veth089f94f` – the same interface that
    we discovered using the commands in *Figure 10.6*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了`lldpctl`命令的成功输出，显示了`eth0`接口的邻居，在这种情况下，是主机Debian Linux，`SysName`为`netlab`。与边界路由器上的`eth0`对等的接口在`PortDescr`字段中描述为`veth089f94f`——这正是我们使用*图10.6*中的命令发现的接口。
- en: However, why not use the first method described in *Figure 10.6* to find out
    the connection instead of LLDP? Because in real networks, LLDP is used to identify
    the connections between devices. Thus, writing an automation code to verify all
    the network connections in the lab using LLDP can also be used in production.
    Our lab will be used as the first place to test our automation code – in this
    case, checking the LLDP topology.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么不使用*图10.6*中描述的第一种方法来找出连接而不是使用LLDP呢？因为在实际网络中，LLDP用于识别设备之间的连接。因此，编写一个自动化代码来验证实验室中所有网络连接使用LLDP也可以在生产中使用。我们的实验室将作为测试我们自动化代码的第一个地方——在这种情况下，检查LLDP拓扑。
- en: By now, you have probably noticed that we can access the routers just by using
    the `docker exec <name of the router>` command, so why do we need the OOB management
    network to access the devices? The answer is like the LLDP case – with OOB network
    access, the devices can be accessed via SSH, which is what we are going to do
    in production. Consequently, any code developed for the lab can be used in production.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到我们只需使用`docker exec <router名称>`命令就可以访问路由器，那么为什么我们还需要OOB管理网络来访问设备呢？答案是像LLDP的情况一样——通过OOB网络访问，设备可以通过SSH访问，这正是我们将在生产中要做的。因此，为实验室开发的任何代码都可以在生产中使用。
- en: 'To test our lab OOB management network, we just need to access the device via
    the IP using `ping` or `ssh` commands – the `ping cpe-a` command, for example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的实验室OOB管理网络，我们只需使用`ping`或`ssh`命令通过IP访问设备——例如，使用`ping cpe-a`命令：
- en: '![Figure 10.8 – Testing connection to a router from the host using OOB](img/B18165_10_008.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 使用OOB从主机测试连接到路由器](img/B18165_10_008.jpg)'
- en: Figure 10.8 – Testing connection to a router from the host using OOB
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 使用OOB从主机测试连接到路由器
- en: 'You should also be able to SSH to any container, using `netlab` for the username
    and password:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你也应该能够使用`netlab`作为用户名和密码SSH到任何容器：
- en: '![Figure 10.9 – Testing whether you can access a device via SSH using OOB](img/B18165_10_009.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 测试是否可以通过OOB使用SSH访问设备](img/B18165_10_009.jpg)'
- en: Figure 10.9 – Testing whether you can access a device via SSH using OOB
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 测试是否可以通过OOB使用SSH访问设备
- en: Now that we know how our OOB management network works in our lab, let’s connect
    the devices using the OOB network.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了我们的实验室中OOB管理网络的工作方式，让我们使用OOB网络连接设备。
- en: Looking at the topology
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看拓扑
- en: '*Figure 10.1* shows the topology that we are aiming to create. The devices
    in our lab are running and connected to an OOB network, but they do not have connections
    like the topology described in *Figure 10.1*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.1* 展示了我们旨在创建的拓扑结构。我们实验室中的设备正在运行并连接到一个OOB网络，但它们没有像*图10.1*中描述的拓扑那样的连接。'
- en: In addition to the diagram, there is also a formal topology description in a
    file on GitHub, which can be accessed at `Chapter10/NetworkLab/topology.yaml`.
    The file describes the routers in the topology and their connections. It is a
    simple version of network definition in YAML format as we discussed in [*Chapter
    4*](B18165_04.xhtml#_idTextAnchor100).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图表之外，GitHub上的一个文件中也包含了一个正式的拓扑描述，可以通过`Chapter10/NetworkLab/topology.yaml`访问。该文件描述了拓扑中的路由器和它们的连接。这是我们之前在[*第4章*](B18165_04.xhtml#_idTextAnchor100)中讨论的YAML格式的网络定义的简单版本。
- en: 'The topology file has basically two main keys, `devices` and `links`. These
    keys should describe the same connections shown in *Figure 10.1*. The following
    is a sample of the file for the `devices` and `links` keys:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 拓扑文件基本上有两个主要键，`devices`和`links`。这些键应该描述与*图10.1*中显示相同的连接。以下是`devices`和`links`键的文件样本：
- en: '[PRE0]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file should contain all the links that are depicted in *Figure 10.1*. Ideally,
    the diagram in *Figure 10.1* should be created automatically by a tool reading
    from `topology.yaml`. In our example, the diagram and the YAML file are the same,
    but I have built the diagram manually myself, and for any topology change, I need
    to update the `topology.yaml` file and the diagram. This problem was discussed
    as well in [*Chapter 4*](B18165_04.xhtml#_idTextAnchor100), and the update synchronization
    between a file and a diagram tends to break as the topology gets more complex.
    But, for our examples using this small topology, an automated diagram builder
    is not necessary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件应包含*图10.1*中描绘的所有链接。理想情况下，*图10.1*中的图表应该由一个读取`topology.yaml`的工具自动创建。在我们的例子中，图表和YAML文件是相同的，但我自己手动构建了图表，并且对于任何拓扑变化，我需要更新`topology.yaml`文件和图表。这个问题也在[*第4章*](B18165_04.xhtml#_idTextAnchor100)中讨论过，随着拓扑变得更加复杂，文件和图表之间的更新同步往往会出错。但是，对于使用这个小拓扑的示例，自动图表构建器不是必需的。
- en: Creating the connections between devices
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建设备之间的连接
- en: To connect the devices, like in the topology, we have to use `veth` peer interfaces,
    and as we discussed in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209), we need
    the namespace numbers for each side of the peer and the interface names we going
    to use. Most of the connections in *Figure 10.1* are point-to-point between devices,
    except for the connections to the **backbone** or **WAN**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接设备，就像在拓扑中一样，我们必须使用`veth`对等接口，并且正如我们在[*第9章*](B18165_09.xhtml#_idTextAnchor209)中讨论的那样，我们需要对等接口每边的命名空间编号以及我们将要使用的接口名称。*图10.1*中的大多数连接都是设备之间的点对点连接，除了连接到**骨干**或**WAN**。
- en: 'The following diagram shows all the `veth` peers that we must configure; the
    majority are connected between two containers in a point-to-point configuration.
    However, the core routers will use, let’s say, backbone veth or WAN veth, because
    they are connected in a multi-to-multi-point environment, similar to a WAN. For
    that, we are going to use a software bridge in the host to provide connectivity
    between the backbone veth – latency and packet loss can be added to the bridge
    interfaces if tests for network degradation are required:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了我们必须配置的所有`veth`对等接口；大多数是在两个容器之间以点对点配置连接。然而，核心路由器将使用，比如说，骨干`veth`或WAN`veth`，因为它们在多对多点的环境中连接，类似于WAN。为此，我们将在主机上使用一个软件桥来提供骨干`veth`之间的连接性；如果需要进行网络降级测试，可以在桥接口上添加延迟和丢包：
- en: '![Figure 10.10 – Lab topology showing all veth peer interfaces](img/B18165_10_010.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 实验室拓扑，显示所有`veth`对等接口](img/B18165_10_010.jpg)'
- en: Figure 10.10 – Lab topology showing all veth peer interfaces
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 实验室拓扑，显示所有`veth`对等接口
- en: 'When we start creating the `veth` interfaces for the backbone to connect all
    core routers, we are going to use one namespace on the host and the other in the
    core router. This is different from all other veth, which will have two namespaces.
    The following is one example of how to create a connection manually between `pc-a`
    and `cpe-a`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始创建用于连接所有核心路由器的骨干`veth`接口时，我们将在主机上使用一个命名空间，在核心路由器上使用另一个命名空间。这与所有其他`veth`不同，它们将有两个命名空间。以下是如何手动在`pc-a`和`cpe-a`之间创建连接的一个示例：
- en: '[PRE1]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see in these commands, first, we need to obtain the network namespace
    IDs of each router we want to connect, and then we can create the `veth` peer
    and attribute each side of the peer to a namespace ID. Finally, we bring the interfaces
    up on each router. Note that the interface name on `pc-a` is `pc-cpe` and on `cpe-a`
    is `cpe-pc`, to help identify the direction in which the interface goes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在这组命令中所见，首先，我们需要获取我们想要连接的每个路由器的网络命名空间 ID，然后我们可以创建 `veth` 对等端，并将对等端的每一侧分配给一个命名空间
    ID。最后，我们在每个路由器上启动接口。请注意，`pc-a` 上的接口名称是 `pc-cpe`，而 `cpe-a` 上的接口名称是 `cpe-pc`，这有助于识别接口的方向。
- en: 'To verify whether our connection between the routers was created properly,
    we can run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们之间路由器的连接是否创建正确，我们可以运行以下命令：
- en: '![Figure 10.11 – Checking the connection between pc-a and cpe-a](img/B18165_10_011.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 检查 pc-a 和 cpe-a 之间的连接](img/B18165_10_011.jpg)'
- en: Figure 10.11 – Checking the connection between pc-a and cpe-a
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 检查 pc-a 和 cpe-a 之间的连接
- en: Now, we can confirm that `pc-a` is connected to `cpe-a` by looking into the
    `lldpctl` command output in *Figure 10.11*. The output shows the name for `SysName`,
    which is `cpe-a`, confirming the connection. We can also see the interface name
    on the other side, which is `cpe-pc`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过查看 *图 10.11* 中的 `lldpctl` 命令输出，确认 `pc-a` 是否连接到 `cpe-a`。输出显示了 `SysName`
    的名称为 `cpe-a`，确认了连接。我们还可以看到另一侧的接口名称，它是 `cpe-pc`。
- en: Let’s now see how we automate the device connections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何自动化设备连接。
- en: Automating the connections
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化连接
- en: Our lab now has all devices running, and we are going to connect all devices
    using a program that will connect all devices. You can get access to the program
    on `Chapter10/NetworkLab/AUTOMATION.md`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的网络实验室现在所有设备都在运行，我们将使用一个程序连接所有设备。您可以在 `Chapter10/NetworkLab/AUTOMATION.md`
    获取该程序。
- en: 'To install it on your computer, just need to clone it using the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的计算机上安装它，只需使用以下命令克隆它：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, you need to build the Go program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要构建 Go 程序：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you are using the pre-build VirtualBox image, you probably are accessing
    the network lab via SSH on localhost port `22`. Then, you just need to run it
    like so:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用预构建的 VirtualBox 映像，您可能正在通过本地主机端口 `22` 使用 SSH 访问网络实验室。然后，您只需像这样运行它：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are using QEMU or your own Linux virtual machine with the network lab,
    you can pass the username, password, and IP of the host as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 QEMU 或带有网络实验室的自己的 Linux 虚拟机，您可以按照以下方式传递用户名、密码和主机 IP：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A small help guide can be accessed by adding `-help`, like here:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `-help`，可以访问一个小型帮助指南，如下所示：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The program shows some logs on the output, and a successful run should show
    similar lines to the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在输出中显示了一些日志，成功运行应该显示类似于以下类似的行：
- en: '![Figure 10.12 – Running the Go automation program to connect devices](img/B18165_10_012.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 运行 Go 自动化程序连接设备](img/B18165_10_012.jpg)'
- en: Figure 10.12 – Running the Go automation program to connect devices
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 运行 Go 自动化程序连接设备
- en: As you can see in the preceding screenshot, the program takes around 12 seconds
    to run, and it should show `all done successfully` at the end.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的屏幕截图中所见，程序运行大约需要 12 秒，并且在结束时应该显示 `all done successfully`。
- en: Let’s have a look at this program and what it is doing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个程序以及它在做什么。
- en: Looking into the automation program
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看自动化程序
- en: 'In our example, the program was written in Go, and the directory where it is
    located consists of nine files, of which six are Go source code with `.go` extensions
    as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，程序是用 Go 语言编写的，它所在的目录包含九个文件，其中六个是带有 `.go` 扩展名的 Go 源代码，如下所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let’s discuss each file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论每个文件。
- en: go.mod and go.sum
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: go.mod 和 go.sum
- en: These files are used by the Go builder for package dependency management; they
    contain all the necessary information to add the third-party library to our program.
    Every time we import a package, it automatically updates these files. More on
    these files can be obtained at [https://go.dev/ref/mod](https://go.dev/ref/mod).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件被 Go 构建器用于包依赖管理；它们包含将第三方库添加到我们程序所需的所有必要信息。每次我们导入一个包时，它都会自动更新这些文件。更多关于这些文件的信息可以在
    [https://go.dev/ref/mod](https://go.dev/ref/mod) 获取。
- en: topology.yaml
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: topology.yaml
- en: This contains the description of the topology that is shown in *Figure 10.1*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了 *图 10.1* 中显示的拓扑描述。
- en: types.go
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: types.go
- en: 'This contains all the data structure definitions used in the program, which
    include variable types and the YAML topology data structure. Different from Python,
    in Go, it is better to specify the data structure that you are going to read from
    a YAML file. In our case, the `TopologyConfType` struct type is used to define
    the YAML file structure, like so:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了程序中使用的所有数据结构定义，包括变量类型和YAML拓扑数据结构。与Python不同，在Go中，最好指定要从YAML文件中读取的数据结构。在我们的案例中，使用`TopologyConfType`结构类型来定义YAML文件结构，如下所示：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: readtopology.go
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: readtopology.go
- en: This contains the function that is used to read the `topology.yaml` file. The
    data structure of this file is defined in the `TopologyConfType` structure type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了用于读取`topology.yaml`文件的函数。该文件的 数据结构定义在`TopologyConfType`结构类型中。
- en: runcommand.go
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: runcommand.go
- en: 'This contains generic functions that wrap the command to run on the host of
    the lab. If an error occurs by running a command, the output is combined with
    the error message to be returned in the error message, as in this example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了封装在实验室主机上运行的命令的通用函数。如果运行命令时发生错误，输出将与错误消息结合，以错误消息的形式返回，如下例所示：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The idea to add the output to the error message is because when running remote
    commands via SSH and shell, the error might not be easy to interpret without the
    `stdout` messages.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出添加到错误信息中的想法是因为当通过SSH和shell运行远程命令时，没有`stdout`消息，错误可能不容易解释。
- en: veth.go
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: veth.go
- en: This contains the functions that form the command strings that will be used
    to run on the host to create or manipulate `veth` interfaces. It also contains
    all functions that are used to populate the `conf.Veths` list, such as `loadVeth()`
    and `createPeerVeths()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了形成将在主机上运行的命令字符串的函数，这些命令字符串用于创建或操作`veth`接口。它还包含了所有用于填充`conf.Veths`列表的函数，例如`loadVeth()`和`createPeerVeths()`。
- en: hostconnect.go
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: hostconnect.go
- en: This file contains the function used to connect to our lab. In our case, we
    are using a third-party package called `melbahja/goph`, which is an SSH client
    that allows the execution of a command and immediate output. For faster and better
    performance, we should use vSSH instead, as explained in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含了用于连接我们实验室的函数。在我们的案例中，我们使用了一个名为`melbahja/goph`的第三方包，它是一个SSH客户端，允许执行命令并立即输出。为了获得更快和更好的性能，我们应该使用vSSH，如[*第6章*](B18165_06.xhtml#_idTextAnchor166)中所述。
- en: netlab.go
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: netlab.go
- en: This is the main program file that contains the `main()` and `init()` functions.
    The library called `flags` is used to pass arguments during the command execution
    in the shell. By default, they are initiated in the `init()` function, and they
    use default values if the arguments are not passed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主程序文件，其中包含了`main()`和`init()`函数。`flags`库用于在shell中命令执行时传递参数。默认情况下，它们在`init()`函数中初始化，如果没有传递参数，则使用默认值。
- en: The `main()` function also describes the flow of the whole process, which consists
    of five main calls – `readTopologyFile`, `connectToHost`, `loadVeths`, `createVeths`,
    and `addVethsToBackbone`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数还描述了整个过程的流程，它由五个主要调用组成 – `readTopologyFile`、`connectToHost`、`loadVeths`、`createVeths`和`addVethsToBackbone`。'
- en: Now that we have all devices connected and we understand how the automation
    works, let’s do some manual checks to verify that the connections have been created
    properly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有设备连接起来，并且我们了解了自动化是如何工作的，让我们进行一些手动检查，以验证连接是否已正确创建。
- en: Checking the connections manually
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动检查连接
- en: To create automation for checking connections, we have to understand how the
    process of checking connections works first. Once we know how a manual check works,
    we can later automate it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建检查连接的自动化，我们首先需要了解检查连接的过程。一旦我们知道了手动检查是如何工作的，我们就可以稍后自动化它。
- en: 'Once the `netlab` program has run without errors, it should have created the
    connections and the software bridge called `backbone`, and attached the WAN interfaces
    to it. Let’s use the following figure as guidance for our manual verification
    of the connections:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`netlab`程序运行无误，它应该已经创建了连接和名为`backbone`的软件桥，并将WAN接口连接到它。让我们使用以下图作为我们手动验证连接的指导：
- en: '![Figure 10.13 – Diagram showing where we manually check the connections](img/B18165_10_013.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 显示我们手动检查连接的示意图](img/B18165_10_013.jpg)'
- en: Figure 10.13 – Diagram showing where we manually check the connections
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 显示我们手动检查连接的示意图
- en: The figure shows numbers to indicate where we are going to do the manual checks.
    Let’s first start checking the connection that is represented by **1**. We are
    going to use LLDP to validate the connection in all cases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了表示我们将要进行的手动检查的位置的数字。让我们首先开始检查由**1**表示的连接。我们将使用LLDP在所有情况下验证连接。
- en: 'The following screenshot shows the output of the `sudo lldpctl cpe-acc` command,
    which runs inside the `cpe-a` router via SSH. Note that in the example, we start
    from the `netlab` host:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了 `sudo lldpctl cpe-acc` 命令的输出，该命令通过SSH在 `cpe-a` 路由器内部运行。请注意，在示例中，我们从
    `netlab` 主机开始：
- en: '![Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection
    to acc-a](img/B18165_10_014.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 验证cpe-a连接到acc-a的lldpctl命令输出](img/B18165_10_014.jpg)'
- en: Figure 10.14 – Output of the lldpctl command to verify the cpe-a connection
    to acc-a
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 验证cpe-a连接到acc-a的lldpctl命令输出
- en: As you can see, the `cpe-acc` interface in the `cpe-a` router is connected to
    the `acc-cpe` interface in the `acc-a` router.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`cpe-a` 路由器中的 `cpe-acc` 接口连接到 `acc-a` 路由器中的 `acc-cpe` 接口。
- en: 'To validate the connection for case `core-a1`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 `core-a1` 的情况：
- en: '![Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection
    to the backbone](img/B18165_10_015.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 验证core-a1连接到骨干的lldpctl命令输出](img/B18165_10_015.jpg)'
- en: Figure 10.15 – Output of the lldpctl command to verify the core-a1 connection
    to the backbone
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 验证core-a1连接到骨干的lldpctl命令输出
- en: 'As you can see, the `core-a1` router’s interface, `core-a1-wan`, is connected
    to the `netlab` host via `wan-core-a1`. To verify whether the `wan-core-a1` interface
    belongs to the `backbone` bridge, we need to perform one of the extra commands:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`core-a1` 路由器的接口 `core-a1-wan` 通过 `wan-core-a1` 连接到 `netlab` 主机。为了验证 `wan-core-a1`
    接口是否属于 `backbone` 交换机，我们需要执行以下额外命令之一：
- en: '![Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone
    bridge](img/B18165_10_016.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 检查wan-core-a1是否属于backbone桥接的命令](img/B18165_10_016.jpg)'
- en: Figure 10.16 – Command to check that wan-core-a1 belongs to the backbone bridge
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 检查wan-core-a1是否属于backbone桥接的命令
- en: Either of the commands shown in *Figure 10.16* confirms that `wan-core-a1` belongs
    to `backbone`. The difference is the second command presents the output in a JSON
    format, which is easier to parse by software. `lldpctl` also supports JSON output
    using `lldpctl -f json`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.16* 中显示的任何命令都可以确认 `wan-core-a1` 属于 `backbone`。区别在于第二个命令以JSON格式显示输出，这对于软件解析更容易。`lldpctl`
    也支持使用 `lldpctl -f json` 的JSON输出。'
- en: Now, let’s discuss how we can add more automation.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何添加更多自动化。
- en: Adding automation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自动化
- en: There are infinite possibilities for processes for which you might want to create
    automation. Most of the operational procedures are repetitive and prone to errors
    if manually operated. So, we need to automate our network as much as possible.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您可能想要创建自动化的过程，有无限的可能性。大多数操作程序都是重复的，如果手动操作，则容易出错。因此，我们需要尽可能自动化我们的网络。
- en: Let’s then describe a few simple forms of automation that can help our network
    operation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们描述一些简单的自动化形式，这些形式可以帮助我们的网络操作。
- en: Link connection check automation
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链路连接检查自动化
- en: One of the procedures that is very important and requires lots of attention
    is the build and construction of the physical network, in particular a physical
    rack and its cables. Its complexity will vary, depending on whether a star topology
    configuration or a Clos topology configuration is used, which we discussed in
    [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个非常重要且需要大量注意的程序是物理网络的构建和施工，特别是物理机架及其电缆。其复杂性会根据是否使用星型拓扑配置或Clos拓扑配置而有所不同，我们已在[*第一章*](B18165_01.xhtml#_idTextAnchor015)中讨论过。
- en: A mixed topology configuration that combines all possible topologies is even
    more complex, and its complexity will increase the chances of building a network
    incorrectly. For instance, a Clos network, as shown in *Figure 10.17*, has a total
    of 32 connections, and imagine the complexity added if three more routers were
    included.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 结合所有可能拓扑的混合拓扑配置更加复杂，其复杂性会增加构建网络错误的机会。例如，如图*图10.17*所示的Clos网络共有32个连接，如果再增加三个路由器，其复杂性将增加。
- en: '![Figure 10.17 – Clos network connections](img/B18165_10_017.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – Clos网络连接](img/B18165_10_017.jpg)'
- en: Figure 10.17 – Clos network connections
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – Clos网络连接
- en: Having included **E5**, **S5**, and **L5**, the Clos network will have now 50
    connections. So, for us, connection check automation is important to avoid operation
    failures down the network setup.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了 **E5**、**S5** 和 **L5** 后，Clos 网络现在将有 50 个连接。因此，对我们来说，连接检查自动化非常重要，可以避免网络设置中的操作失败。
- en: Most importantly, our network lab can be used for us to test the automation
    of the link connection check, which can be used later in production.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们的网络实验室可以用来测试链路连接检查的自动化，这可以在生产中后期使用。
- en: In a production environment, a bastion host normally needs to be accessed first,
    before accessing the devices using the OOB network. In our network lab, the bastion
    is the same as the network lab host. Once logged in to the bastion, the automation
    code can then access the router via the OOB network, which is the same as in the
    network lab.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，通常需要首先访问堡垒主机，然后才能通过 OOB 网络访问设备。在我们的网络实验室中，堡垒主机与网络实验室主机相同。一旦登录到堡垒主机，自动化代码就可以通过
    OOB 网络访问路由器，这与网络实验室中的情况相同。
- en: Let’s now write some code to automate this process
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写一些代码来自动化这个过程
- en: Link check example code
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链路检查示例代码
- en: I have added a Python script that returns a JSON list format with all interfaces
    and the device connected to each interface for a particular device. The Python
    code can be accessed at `Chapter10/NetworkLab/AUTOMATION.md`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个 Python 脚本，该脚本返回一个包含所有接口及其连接的特定设备的 JSON 列表格式。Python 代码可以在 `Chapter10/NetworkLab/AUTOMATION.md`
    中访问。
- en: 'Let’s run a few examples to see how the Python script works; the following
    screenshot is showing results for the `internet` device:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行几个示例来查看 Python 脚本的工作方式；以下截图显示了 `internet` 设备的结果：
- en: '![Figure 10.18 – Output for checking connections to the internet device](img/B18165_10_018.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – 检查连接到互联网设备的输出](img/B18165_10_018.jpg)'
- en: Figure 10.18 – Output for checking connections to the internet device
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – 检查连接到互联网设备的输出
- en: As you can see, the `internet` device has only two interfaces, one connected
    via the OOB network with the `eth0` interface to the `netlab` device, and one
    interface called `internet-border` connected to the `border` device, which confirms
    the connections in *Figure 10.1*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`internet` 设备只有两个接口，一个通过 OOB 网络使用 `eth0` 接口连接到 `netlab` 设备，另一个名为 `internet-border`
    的接口连接到 `border` 设备，这证实了 *图 10.1* 中的连接。
- en: Let’s now check how the `border` device is connected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查 `border` 设备的连接情况。
- en: '![Figure 10.19 – Output for checking connections of the border device](img/B18165_10_019.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – 检查边界设备连接的输出](img/B18165_10_019.jpg)'
- en: Figure 10.19 – Output for checking connections of the border device
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – 检查边界设备连接的输出
- en: As you can see in *Figure 10.19*, the `border` device is connected to the `internet`
    device and three core routers, `core-i1`, `core-i2`, and `core-i3`, as in *Figure
    10.1*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 10.19* 所示，`border` 设备连接到 `internet` 设备和三个核心路由器，`core-i1`、`core-i2` 和 `core-i3`，正如
    *图 10.1* 所示。
- en: If you run this for all devices, you should confirm all the connections. But
    can we automate confirming connections for all routers in just one run? Yes, of
    course, but for that, we will need to read `topology.yaml`, and then create a
    loop that will run on each device to confirm the connections. I will leave completing
    this as an exercise for you.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为所有设备运行此操作，您应该确认所有连接。但我们可以自动化确认所有路由器的连接吗？当然可以，但为此，我们需要读取 `topology.yaml`
    文件，然后创建一个循环，该循环将在每个设备上运行以确认连接。我将把这个任务留给你作为练习。
- en: Let’s now explain some parts of the `show-connections.py` code.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解释一下 `show-connections.py` 代码的一些部分。
- en: Looking into the code
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看代码
- en: The `show-connections.py` Python code uses the `paramiko` third-party library
    as the base for the SSH connection, which we discussed in [*Chapter 6*](B18165_06.xhtml#_idTextAnchor166),
    (`paramiko` can be installed using `pip install paramiko`).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`show-connections.py` Python 代码使用 `paramiko` 第三方库作为 SSH 连接的基础，我们已在 [*第 6 章*](B18165_06.xhtml#_idTextAnchor166)
    中讨论过（可以使用 `pip install paramiko` 安装 `paramiko`）。'
- en: 'Paramiko is a lower-level SSH connectivity library that allows us to create
    an SSH session within an SSH session because we are using a bastion to connect
    to our devices in the network lab, which is the lab host. The details of this
    stacked SSH connection are described in the code by the `NetLab()` class, which
    has a method to connect to the bastion called `connectBastion()`, and a method
    to connect to a device called `connectDevice()`. Note that these methods use a
    class attribute called `self.transport` to pass the bastion `paramiko` handler
    to the device channel described in the code and shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Paramiko是一个低级别的SSH连接库，它允许我们在SSH会话内创建一个SSH会话，因为我们正在使用堡垒机连接到网络实验室中的设备，即实验室主机。通过`NetLab()`类描述的代码，这些堆叠的SSH连接的细节被描述，该类有一个名为`connectBastion()`的方法用于连接堡垒机，还有一个名为`connectDevice()`的方法用于连接设备。请注意，这些方法使用一个名为`self.transport`的类属性将堡垒机的`paramiko`处理程序传递给代码中描述的设备通道，如下所示：
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are other ways to use bastion, such as using SSH proxies or SSH agents.
    However, in our example, I wanted to show how to natively create an SSH stack
    connection. Because if you do have two bastions before connecting a device, it
    is also possible to use `paramiko`, but perhaps not that easy using SSH agents
    and proxies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堡垒机还有其他方法，例如使用SSH代理或SSH代理。然而，在我们的例子中，我想展示如何原生地创建一个SSH堆叠连接。因为如果您在连接设备之前有两个堡垒机，也有可能使用`paramiko`，但可能不会那么容易使用SSH代理和代理。
- en: In the Python code, we use `argparser` to add arguments to our command line,
    so you can change the address of the bastion or the username and password. The
    arguments and default values are located in `parse_arguments()`. A help guide
    is also automatically produced if you type `--help`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码中，我们使用`argparser`向我们的命令行添加参数，这样您就可以更改堡垒机的地址或用户名和密码。参数和默认值位于`parse_arguments()`中。如果您输入`--help`，还会自动生成一个帮助指南。
- en: '![Figure 10.20 – help output for the Python code show-connections.py](img/B18165_10_020.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图10.20 – Python代码show-connections.py的帮助输出](img/B18165_10_020.jpg)'
- en: Figure 10.20 – help output for the Python code show-connections.py
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.20 – Python代码show-connections.py的帮助输出
- en: I will leave you to improve this Python script to read the `topology.yaml` file
    and then verify all the connections in the network lab depicted in *Figure 10.1*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我将让您改进这个Python脚本，使其能够读取`topology.yaml`文件，然后验证网络实验室中*图10.1*所示的所有连接。
- en: Now, let’s see how we can automate the IP configuration for the interfaces.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何自动化接口的IP配置。
- en: IP configuration automation
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IP配置自动化
- en: Before we can use our network for IP traffic, we need to attribute IPs to our
    network interfaces, which can be done manually by adding IPs to each interface,
    or we can create an automated code that distributes the IPs and configure them
    on the devices in the network lab.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用我们的网络进行IP流量之前，我们需要将IP分配给我们的网络接口，这可以通过手动为每个接口添加IP来完成，或者我们可以创建一个自动化的代码来分配IP并在网络实验室的设备上配置它们。
- en: For our network lab, there are basically two types of IP allocation, one that
    is point-to-point between devices, and one that is multi-point for the WAN on
    the backbone interfaces. Let’s give an example of automation for the WAN interfaces.
    The Python code called `configure-ip-wan.py` is located at `Chapter10/NetworkLab/AUTOMATION.md`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络实验室，基本上有两种IP分配方式，一种是在设备之间点对点的，另一种是在骨干接口上的多点WAN。让我们举一个WAN接口自动化的例子。名为`configure-ip-wan.py`的Python代码位于`Chapter10/NetworkLab/AUTOMATION.md`。
- en: 'The following screenshot shows the output after running the `configure-ip-wan.py`
    program:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行`configure-ip-wan.py`程序后的输出：
- en: '![Figure 10.21 – Output of the configure-ip-wan.py Python code](img/B18165_10_021.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图10.21 – Python代码configure-ip-wan.py的输出](img/B18165_10_021.jpg)'
- en: Figure 10.21 – Output of the configure-ip-wan.py Python code
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.21 – Python代码configure-ip-wan.py的输出
- en: 'Note that the IPs are configured on the devices using Paramiko, as in the previous
    example. The code uses the `ipaddress` Python library, which allocates the IPs
    that will be used in the WAN interfaces by creating a list of IPs using the following
    commands:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，IP是在设备上使用Paramiko配置的，就像前面的例子一样。代码使用`ipaddress` Python库，通过创建一个IP列表来分配将在WAN接口中使用的IP，如下面的命令所示：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, each IP is obtained by using `pop()` in the `valid_ips` list, like in
    the following loop:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个IP都是通过在`valid_ips`列表中使用`pop()`方法获得的，如下面的循环所示：
- en: '[PRE12]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can test the IP connectivity between devices in the WAN using the Python
    script included at `Chapter10/NetworkLab/AUTOMATION.md`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用包含在`Chapter10/NetworkLab/AUTOMATION.md`中的Python脚本来测试WAN中设备之间的IP连通性：
- en: '![Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via
    the WAN](img/B18165_10_022.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图10.22 – 通过WAN测试core-a1和core-b1之间的IP连通性](img/B18165_10_022.jpg)'
- en: Figure 10.22 – Testing the IP connectivity between core-a1 and core-b1 via the
    WAN
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.22 – 通过WAN测试core-a1和core-b1之间的IP连通性
- en: From the output shown in *Figure 10.21*, we can assume the `core-b1` interface
    IP is `10.200.200.4`. So, the test executed on `core-a1` is testing the IP connectivity
    between `core-a1` and `core-b1` via the `backbone` bridge.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图10.21*所示的输出中，我们可以假设`core-b1`接口的IP地址是`10.200.200.4`。因此，在`core-a1`上执行的测试是测试`core-a1`和`core-b1`之间通过`骨干网`桥的IP连通性。
- en: To finish the IP configuration, you will have to also configure IPs for all
    other interfaces. I will leave adding the IPs to other network lab interfaces
    as an exercise, but for now, the example is sufficient to guide you to proceed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 完成IP配置后，您还需要为所有其他接口配置IP。我将把为其他网络实验室接口添加IP作为练习，但就目前而言，这个例子足以指导您继续操作。
- en: Additional network lab automation
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络实验室自动化补充
- en: Let’s discuss briefly what other possible automation we can add to our lab.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要讨论一下我们可以添加到实验室中的其他可能的自动化。
- en: Adding and removing devices
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和移除设备
- en: We can add code that can read the `topology.yaml` file and then, based on what
    is running, determine whether certain modifications are required, such as adding
    devices or removing devices. I will say that is easier for us to just tear down
    a network lab and start another one from scratch instead of removing and adding
    devices because, in our network emulation, the shutdown and startup are quick.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加可以读取`topology.yaml`文件的代码，然后根据正在运行的内容确定是否需要某些修改，例如添加或移除设备。我会说，对于我们来说，简单地拆除网络实验室并从头开始构建另一个实验室比移除和添加设备要容易得多，因为在我们的网络仿真中，关闭和启动都很迅速。
- en: So, adding code to remove and add devices is more of an exercise than a real
    utility in our network lab.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，添加代码以移除和添加设备在我们的网络实验室中更像是一项练习，而不是真正的实用工具。
- en: Using gRPC for automation
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用gRPC进行自动化
- en: We also can do some automation using gRPC, as FRRouting supports this interface.
    With this, we eliminate the necessity to access the devices via SSH. You can find
    more on gRPC for FRRouting at [https://docs.frrouting.org/en/latest/grpc.html](https://docs.frrouting.org/en/latest/grpc.html).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用gRPC进行一些自动化，因为FRRouting支持此接口。有了这个，我们就消除了通过SSH访问设备的必要性。您可以在[https://docs.frrouting.org/en/latest/grpc.html](https://docs.frrouting.org/en/latest/grpc.html)上找到有关FRRouting的gRPC的更多信息。
- en: Using NETCONF for automation
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用NETCONF进行自动化
- en: To use NETCONF for automation, you need to have `libyang` installed in the router
    image, which, in our network lab, is FRRouting running on Alpine Linux. To add
    `libyang`, just type the `sudo apk add libyang` command on the router device.
    Using FRRouting and NETCONF together is not a very well-documented option, so
    good luck doing so.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用NETCONF进行自动化，您需要在路由器映像中安装`libyang`，在我们的网络实验室中，这是在Alpine Linux上运行的FRRouting。要添加`libyang`，只需在路由器设备上输入`sudo
    apk add libyang`命令。将FRRouting和NETCONF结合使用并不是一个很好的文档化选项，所以祝您好运。
- en: Adding network degradation
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加网络退化
- en: You can add latency, jitter, packet loss, congestion, and other degradations
    to your network lab, which can be permanent or vary over time. To remove and add
    these degradations, the best thing to do is to write automated code that can apply
    the necessary traffic shaping mechanisms and then remove them. We discussed these
    degradation methods in [*Chapter 9*](B18165_09.xhtml#_idTextAnchor209).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向您的网络实验室添加延迟、抖动、丢包、拥塞和其他退化，这些可以是永久的或随时间变化。要移除和添加这些退化，最好的做法是编写可以应用必要的流量整形机制并随后移除它们的自动化代码。我们已在[*第9章*](B18165_09.xhtml#_idTextAnchor209)中讨论了这些退化方法。
- en: 'As an example, we can add some latency to the backbone interfaces in our network
    lab by using Linux `tc` like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过使用Linux `tc`来在我们的网络实验室的骨干接口上添加一些延迟，如下所示：
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command should run on the lab host, and it will add a 100 ms delay to the
    `wan-core-a1` interface that connects `core-a1` to the backbone.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应在实验室主机上运行，并将向连接`core-a1`到骨干网的`wan-core-a1`接口添加100毫秒的延迟。
- en: '*Figure 10.23* show the same test done in *Figure 10.22* but with WAN latency
    added.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10.23*显示了与*图10.22*中相同的测试，但增加了WAN延迟。'
- en: '![Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to
    WAN](img/B18165_10_023.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图10.23 – 在WAN中添加100毫秒延迟后与图10.22中相同的测试](img/B18165_10_023.jpg)'
- en: Figure 10.23 – Same test done in Figure 10.22 with 100 ms latency added to WAN
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.23 – 在WAN中添加100毫秒延迟后与图10.22中相同的测试
- en: Feel free to add other network degradations to your network lab by automating
    how Linux traffic control can be used in the network lab interfaces.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 随意将其他网络退化添加到你的网络实验室中，通过自动化Linux流量控制在网络实验室接口中的使用。
- en: Configure routing
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置路由
- en: At this stage, our network lab does not provide IP traffic capabilities because
    it does not know how to route IP packets. Two kinds of routing can be done using
    static routes by configuring the interfaces with them or adding dynamic protocol
    for the devices to talk and exchange routing tables.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们的网络实验室不提供IP流量功能，因为它不知道如何路由IP数据包。可以通过配置接口使用静态路由或为设备添加动态协议来实现两种路由方式，以进行路由表的通信和交换。
- en: As all routers in our network lab are FRRouting; the protocols available that
    can be used are EIGRP, OSPF, ISIS, RIP, or BGP. A complete list and more details
    can be found at [https://docs.frrouting.org/](https://docs.frrouting.org/).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的网络实验室中，所有路由器都使用FRRouting；可用的协议包括EIGRP、OSPF、ISIS、RIP或BGP。完整的列表和更多详细信息可以在[https://docs.frrouting.org/](https://docs.frrouting.org/)找到。
- en: Many more kinds of automation are possible. Some will only work for the network
    lab, but some could be used in a production network. Hopefully, you can use the
    network lab to improve your network automation code skills, and then gain more
    confidence on building a solution for a production network.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有更多种类的自动化。有些可能只适用于网络实验室，但有些可能在生产网络中使用。希望你能利用网络实验室来提高你的网络自动化代码技能，并在构建生产网络解决方案时更有信心。
- en: Let’s now discuss what to do next and further study.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在讨论接下来要做什么以及进一步学习。
- en: Going forward and further study
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前进和进一步学习
- en: You are probably now thinking about what to do next and how you can progress
    to the next topic in network automation. I have put together a few suggestions
    here that I would recommend following, but keep in mind that there might be many
    other paths to follow. So, it is just a humble suggestion, and I hope you can
    enjoy the journey.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在正在思考接下来要做什么，以及你如何可以进步到网络自动化的下一个主题。我在这里提供了一些建议，我建议你遵循这些建议，但请记住，可能还有许多其他路径可以遵循。所以，这只是一个谦逊的建议，希望你能享受这个过程。
- en: Checking popular platforms and tools
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查流行的平台和工具
- en: There are many automation platforms that you can use and perhaps investigate
    how they work. This list will be dynamic and may change from one year to another.
    So, keep in mind how to search for them and how to evaluate them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用许多自动化平台，也许可以调查它们是如何工作的。这个列表将会是动态的，可能每年都会有所变化。所以，请记住如何搜索它们以及如何评估它们。
- en: I have done superficial research on some of the platforms, but I would recommend
    going deeper if you want to improve your knowledge and get even sharper on how
    to automate a network. You may get some ideas, and perhaps improve what you are
    doing today.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我对一些平台进行了初步研究，但如果你想要提高你的知识并更深入地了解如何自动化网络，我建议你深入研究。你可能会有一些想法，也许还能改进你今天正在做的事情。
- en: 'Here is a small list of the most popular automation platforms and tools that
    you might want to have a look at, not in any particular order:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个你可能想要查看的、最受欢迎的自动化平台和工具的小列表，不分先后顺序：
- en: 'The Salt project:'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salt项目：
- en: 'Short description: A remote execution manager'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一个远程执行管理器
- en: 'Source: [https://github.com/saltstack/salt](https://github.com/saltstack/salt
    )'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源：[https://github.com/saltstack/salt](https://github.com/saltstack/salt)
- en: 'Contributors: Over 2K'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者：超过2K
- en: 'Repository creation date: February 2011'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库创建日期：2011年2月
- en: 'Top languages: Python 98%'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要语言：Python 98%
- en: 'License: Apache 2.0'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证：Apache 2.0
- en: 'Sponsor: VMware/public'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赞助商：VMware/public
- en: 'Popularity: 13K stars, 5.4K forks, 544 watching'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人气：13K星标，5.4K分叉，544关注
- en: 'The Ansible project:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible项目：
- en: 'Short description: A simple automation system for configuration management,
    deployment, and orchestration'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一个用于配置管理、部署和编排的简单自动化系统
- en: 'Source: [https://github.com/ansible/ansible](https://github.com/ansible/ansible
    )'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源：[https://github.com/ansible/ansible](https://github.com/ansible/ansible)
- en: 'Contributors: Over 5K'
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者：超过5K
- en: 'Repository creation date: March 2012'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库创建日期：2012年3月
- en: 'Top languages: Python 88%, PowerShell 6.9%'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要语言：Python 88%，PowerShell 6.9%
- en: 'License: GPL 3.0'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证：GPL 3.0
- en: 'Sponsor: Red Hat'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赞助商：红帽
- en: 'Popularity: 56K stars, 23K forks, 2K watching'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人气：56K星标，23K分叉，2K关注
- en: 'The Puppet project:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet项目：
- en: 'Short description: A general administrative management system designed to configure,
    update, and install systems'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一个旨在配置、更新和安装系统的通用管理控制系统
- en: 'Source: [https://github.com/puppetlabs/puppet](https://github.com/puppetlabs/puppet
    )'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源：[https://github.com/puppetlabs/puppet](https://github.com/puppetlabs/puppet)
- en: 'Contributors: Over 1K'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者：超过 1K
- en: 'Repository creation date: September 2010'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库创建日期：2010年9月
- en: 'Top languages: Ruby 99%'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要语言：Ruby 99%
- en: 'License: Apache 2.0'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证：Apache 2.0
- en: 'Sponsor/Owner: Puppet by Perforce'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赞助商/所有者：Puppet by Perforce
- en: 'Popularity: 6.8K stars, 2.3K forks, 475 watching'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人气：6.8K 星标，2.3K 分支，475 关注
- en: 'The Chef project:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef 项目：
- en: 'Short description: A configuration management tool designed to cover the automation
    of all IT infrastructure'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一款旨在涵盖所有 IT 基础设施自动化的配置管理工具
- en: 'Source: [https://github.com/chef/chef](https://github.com/chef/chef)'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源：[https://github.com/chef/chef](https://github.com/chef/chef)
- en: 'Contributors: Over 1K'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者：超过 1K
- en: 'Repository creation date: January 2009'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库创建日期：2009年1月
- en: 'Top languages: Ruby 98%'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要语言：Ruby 98%
- en: 'License: Apache 2.0'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证：Apache 2.0
- en: 'Sponsor/Owner: Progress Software Corporation'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赞助商/所有者：Progress Software Corporation
- en: 'Popularity: 7.1K stars, 2.6K forks, 374 watching'
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人气：7.1K 星标，2.6K 分支，374 关注
- en: 'The Stackstorm project:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stackstorm 项目：
- en: 'Short description: An event-driven automation tool'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一个事件驱动的自动化工具
- en: 'Source: [https://github.com/StackStorm/st2](https://github.com/StackStorm/st2
    )'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源：[https://github.com/StackStorm/st2](https://github.com/StackStorm/st2 )
- en: 'Contributors: Over 300'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者：超过 300
- en: 'Repository creation date: April 2014'
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库创建日期：2014年4月
- en: 'Top languages: Python 94%'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要语言：Python 94%
- en: 'License: Apache 2.0'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证：Apache 2.0
- en: 'Sponsor/Owner: Linux Foundation'
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赞助商/所有者：Linux 基金会
- en: 'Popularity: 5.4K stars, 696 forks, 168 watching'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人气：5.4K 星标，696 分支，168 关注
- en: 'The eNMS automation project:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: eNMS 自动化项目：
- en: 'Short description: A higher-level management system to create workflow-based
    network automation solutions'
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一个创建基于工作流程的网络自动化解决方案的高级管理系统
- en: 'Source: [https://github.com/eNMS-automation/eNMS](https://github.com/eNMS-automation/eNMS
    )'
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源：[https://github.com/eNMS-automation/eNMS](https://github.com/eNMS-automation/eNMS
    )
- en: 'Contributors: 30'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贡献者：30
- en: 'Repository creation date: October 2017'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库创建日期：2017年10月
- en: 'Top languages: Python 53%, JavaScript 26%, HTML 16%'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要语言：Python 53%，JavaScript 26%，HTML 16%
- en: 'License: GLP 3.0'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许可证：GLP 3.0
- en: 'Sponsor: N/A'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赞助商：N/A
- en: 'Popularity: 700 stars, 148 forks, 73 watching'
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人气：700 星标，148 分支，73 关注
- en: 'NetBrain products:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NetBrain 产品：
- en: 'Short description: NetBrain has developed several products for network automation,
    including **Problem Diagnosis Automation System** (**PDAS**)'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：NetBrain 开发了多个网络自动化产品，包括**问题诊断自动化系统**（**PDAS**）
- en: 'Site: [https://www.netbraintech.com/](https://www.netbraintech.com/ )'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站：[https://www.netbraintech.com/](https://www.netbraintech.com/)
- en: 'Owner: NetBrain Automation'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者：NetBrain Automation
- en: 'SolarWinds Network Automation Manager:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SolarWinds 网络自动化管理器：
- en: 'Short description: Proprietary product developed by SolarWinds for network
    automation'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：SolarWinds 为网络自动化开发的专有产品
- en: 'Site: [https://www.solarwinds.com/network-automation-manager](https://www.solarwinds.com/network-automation-manager
    )'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站：[https://www.solarwinds.com/network-automation-manager](https://www.solarwinds.com/network-automation-manager)
- en: 'Owner: SolarWinds'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者：SolarWinds
- en: Besides the tools and platforms that you can investigate, you also can participate
    in working groups related to network automation. Let’s have a look at some of
    them.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你可以调查的工具和平台，你还可以参与与网络自动化相关的工作组。让我们看看其中的一些。
- en: Joining the network automation community
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入网络自动化社区
- en: 'One of the strategies to improve your knowledge and get updated with new technologies
    is to participate in the community. The following is a small list of possible
    groups that you might be interested in watching or participating in:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 提高你的知识和跟上新技术的一个策略是参与社区。以下是一些你可能感兴趣关注或参与的团体的小列表：
- en: 'IETF netmgmt working group:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IETF netmgmt 工作组：
- en: 'Short description: A group that has a focus on working on standards for automated
    network management, such as RESTCONF, NETCONF, and YANG'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一个专注于制定自动化网络管理标准（如 RESTCONF、NETCONF 和 YANG）的团体
- en: 'Site: [https://www.ietf.org/topics/netmgmt/](https://www.ietf.org/topics/netmgmt/
    )'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站：[https://www.ietf.org/topics/netmgmt/](https://www.ietf.org/topics/netmgmt/)
- en: 'Meetup groups:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚会小组：
- en: 'Short description: One good idea is to join a local meetup group that has regular
    meetings. Then, you can talk with professionals in the same area and improve your
    network and knowledge. [https://www.meetup.com/](https://www.meetup.com/) is a
    site where people can organize and meet.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：一个很好的建议是加入一个定期举行会议的本地聚会小组。这样，你可以与同一领域的专业人士交谈，并提升你的网络和知识。[https://www.meetup.com/](https://www.meetup.com/)
    是一个人们可以组织和聚会的网站。
- en: 'Example in New York: [https://www.meetup.com/Network-to-Coders/](https://www.meetup.com/Network-to-Coders/).'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纽约的例子：[https://www.meetup.com/Network-to-Coders/](https://www.meetup.com/Network-to-Coders/)
- en: 'Example in Sydney: [https://www.meetup.com/it-automation/](https://www.meetup.com/it-automation/).'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悉尼的例子：[https://www.meetup.com/it-automation/](https://www.meetup.com/it-automation/).
- en: 'Example in San Francisco: [https://www.meetup.com/sf-network-automation/](https://www.meetup.com/sf-network-automation/).'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧金山的例子：[https://www.meetup.com/sf-network-automation/](https://www.meetup.com/sf-network-automation/).
- en: '**North American Network Operators’ Group** (**NANOG**):'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**北美网络运营商小组**（**NANOG**）：'
- en: 'Short description: NANOG has tons of documents and presentations, and also
    organizes conferences where you can find multiple topics on network automation'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：NANOG拥有大量的文档和演示文稿，还组织会议，在那里你可以找到关于网络自动化的多个主题。
- en: 'Site: [https://www.nanog.org/](https://www.nanog.org/ )'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站：[https://www.nanog.org/](https://www.nanog.org/ )
- en: '**Global Network Advancement Group** (**GNA-G**):'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全球网络进步小组**（**GNA-G**）：'
- en: 'Short description: GNA-G is a community of network professionals from several
    areas, including research, operation, and education all over the world. They organize
    meetings and have some documentation resources.'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：GNA-G是一个来自世界各地的网络专业人士的社区，包括研究、运营和教育。他们组织会议并有一些文档资源。
- en: 'Site: [https://www.gna-g.net/](https://www.gna-g.net/).'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站：[https://www.gna-g.net/](https://www.gna-g.net/).
- en: 'The Network to Code company community:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络到代码公司社区：
- en: 'Short description: Network to Code is a consulting company that maintains GitHub
    repositories and a [slack.com](https://slack.com) group that discusses network
    automation, which can be joined for free'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：网络到代码是一家维护GitHub存储库和讨论网络自动化的[slack.com](https://slack.com)群组的咨询公司，可以免费加入。
- en: 'GitHub: [https://github.com/networktocode/awesome-network-automation](https://github.com/networktocode/awesome-network-automation
    )'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：[https://github.com/networktocode/awesome-network-automation](https://github.com/networktocode/awesome-network-automation
    )
- en: 'Slack group: [networktocode.slack.com](https://networktocode.slack.com )'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slack群组：[networktocode.slack.com](https://networktocode.slack.com )
- en: 'IP Fabric company community:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP Fabric公司社区：
- en: 'Short description: The IP Fabric company also maintains GitHub repositories
    and has a [slack.com](http://slack.com) group open to anyone to join'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简短描述：IP Fabric公司也维护GitHub存储库，并有一个对任何人开放的[slack.com](http://slack.com)群组。
- en: 'GitHub: [https://github.com/community-fabric](https://github.com/community-fabric)'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：[https://github.com/community-fabric](https://github.com/community-fabric)
- en: 'Slack group: [ipfabric-community.slack.com](http://ipfabric-community.slack.com)'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slack群组：[ipfabric-community.slack.com](http://ipfabric-community.slack.com)
- en: Other communities also can be found attached to some private companies, such
    as IBM, Oracle, VMware, Google, and Amazon. They might even use public tools such
    as Slack, LinkedIn, or GitHub to communicate, and they are maybe more focused
    on products that these companies offer instead of generic discussion. They are
    worth checking out, because they might have something to add.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 其他社区也可以在IBM、Oracle、VMware、Google和Amazon等一些私营公司中找到。他们甚至可能使用像Slack、LinkedIn或GitHub这样的公共工具进行沟通，并且可能更专注于这些公司提供的产品，而不是通用的讨论。它们值得一看，因为它们可能有一些可以补充的内容。
- en: Another idea to improve your knowledge and skills is to contribute to a platform
    that already exists as a developer, or to build your own if you dare.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 提高知识和技能的另一个想法是作为开发者为已经存在的平台做出贡献，或者如果你敢的话，建立自己的平台。
- en: I hope this section can give you ideas on the path forward.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这一部分能给你提供前进的思路。
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was focused on getting your hands dirty in a network lab, checking
    how some code automation works in Go and Python, and, finally, exploring the possibilities
    of how to go forward with network automation.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是在网络实验室中亲自动手，检查一些代码自动化在Go和Python中的工作情况，并最终探索如何继续进行网络自动化的可能性。
- en: At this point, you should be very confident about how to build your own network
    lab, how to improve your network automation code, and what to do next to continue
    improving.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该对自己如何构建自己的网络实验室、如何改进你的网络自动化代码以及下一步如何继续改进非常有信心。
- en: On behalf of all the people who worked hard on this book, we want to thank you
    for investing the time to read this book. It was a hard accomplishment to gather
    so much information and pass it on to others in an easy and pleasurable way. I
    hope you have made the most of it by reading it and discovering new technologies
    and techniques in the realm of network automation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 代表所有为这本书辛勤工作的人们，我们想感谢您抽出时间阅读这本书。收集如此多的信息并以简单愉快的方式传递给他人是一项艰巨的成就。我希望您通过阅读它并发现网络自动化领域的新技术和技巧，已经充分利用了它。
- en: Now, you can embark on further challenges that will take you deeper into network
    automation, which you will find when building a complete solution and putting
    into practice everything that you have learned.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始接受进一步的挑战，这将使你更深入地了解网络自动化，你将在构建完整解决方案并实践你所学的所有内容时发现这一点。
