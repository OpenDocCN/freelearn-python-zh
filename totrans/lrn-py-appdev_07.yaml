- en: Chapter 7. Performance – Identifying Bottlenecks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。性能 – 识别瓶颈
- en: 'So far, you have learned various ways to make the application robust and accommodating
    for new features. Now, let''s discuss techniques to improve the application performance.
    This broad topic is split into a series of three chapters—this is the first one
    in this series. It will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经学习了各种使应用程序健壮并适应新功能的方法。现在，让我们讨论提高应用程序性能的技术。这个广泛的话题被分为三个章节系列——这是本系列中的第一个。它将涵盖以下主题：
- en: Basic ways to clock the application runtime
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时应用程序运行时间的基本方法
- en: How to identify the runtime performance bottlenecks by profiling the code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过代码分析来识别运行时性能瓶颈
- en: Basic memory profiling with the `memory_profiler` package
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`memory_profiler`包进行基本内存分析
- en: '**Big O** notation for the computational complexity'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算复杂度的**大O**表示法
- en: To understand these concepts better, we will develop an interesting game scenario
    called *Gold Hunt*. You will soon realize that the application runs very slow
    when you increase the input data size. This chapter will elaborate on techniques
    to pinpoint such problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些概念，我们将开发一个有趣的场景游戏，称为*黄金狩猎*。您很快就会意识到，当您增加输入数据大小时，应用程序运行得非常慢。本章将详细阐述定位此类问题的技术。
- en: Overview of three performance chapters
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三个性能章节概述
- en: Before we dive into the main discussion, let's first understand how the chapters
    on performance improvement are organized. As mentioned earlier, this discussion
    is split into a series of three interlinked chapters.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入主要讨论之前，让我们首先了解性能提升章节是如何组织的。如前所述，这个讨论被分为一系列三个相互关联的章节。
- en: More focus on the runtime performance
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的关注运行时性能
- en: The term performance improvement can mean several things. One can be talking
    about improving the runtime (CPU usage), making the application memory efficient,
    reducing the network consumption, or a combination of these. In this book, we
    will primarily focus on the runtime performance improvement. We will also discuss
    the memory consumption aspect, but the discussion will be limited to the **memory
    profiling** technique and the use of generator expressions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 性能提升这个术语可以意味着几件事情。可能是在谈论提高运行时间（CPU使用率），使应用程序内存高效，减少网络消耗，或者这些的组合。在这本书中，我们将主要关注运行时性能提升。我们还将讨论内存消耗方面，但讨论将限于**内存分析**技术和生成器表达式的使用。
- en: The first performance chapter
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一个性能章节
- en: You are reading the first chapter in this series. It does some preparatory work
    to improve the application performance. This preparation involves measuring the
    runtime, identifying pieces of the code that cause the performance bottlenecks,
    understanding the big O notation, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在阅读本系列的第一个章节。它进行了一些准备工作以提高应用程序的性能。这些准备工作包括测量运行时间，识别导致性能瓶颈的代码片段，理解大O表示法，等等。
- en: '![The first performance chapter](img/B05034_07_19.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![第一个性能章节](img/B05034_07_19.jpg)'
- en: '| *Of course! We will develop the earlier mentioned **Gold Hunt scenario**,
    and then identify the performance bottlenecks in the code. The next two chapters
    will use this groundwork to gradually improve the application performance.* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| *当然！我们将开发之前提到的**黄金狩猎场景**，然后识别代码中的性能瓶颈。接下来的两个章节将利用这个基础逐步提高应用程序的性能。* |'
- en: The second performance chapter
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二个性能章节
- en: The next chapter is all about learning various performance improvement techniques.
    The first half aims at improving the application runtime for the *Gold Hunt* application.
    The second half teaches several tricks to optimize the code. The chapter covers
    some built-in modules designed for high performance and memory efficiency. It
    also talks about list comprehension, generator expressions, choice of data structures,
    algorithmic changes, and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全部关于学习各种性能提升技术。前半部分旨在提高*黄金狩猎*应用程序的应用程序运行时间。后半部分教授一些优化代码的技巧。本章涵盖了为高性能和内存效率设计的内置模块。它还讨论了列表推导式、生成器表达式、数据结构的选择、算法变更等等。
- en: The third performance chapter
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三个性能章节
- en: The last chapter in this series will briefly talk about the **NumPy** package
    and **parallelization** using the `multiprocessing` module in Python. We will
    use these techniques to drastically improve the runtime performance of the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本系列中的最后一章将简要介绍**NumPy**包和Python中`multiprocessing`模块的**并行化**。我们将使用这些技术来显著提高应用程序的运行时性能。
- en: Sneak peek at the upcoming application speedup
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即将到来的应用程序加速预览
- en: Here is a preview of how the *Gold Hunt* program will evolve from a turtle to
    a rabbit. The following figure shows the approximate runtime after each major
    step of performance improvement. By the time we complete [Chapter 9](ch09.html
    "Chapter 9. Improving Performance – Part Two, NumPy and Parallelization"), *Improving
    Performance – Part two, NumPy and Parallelization*, the application runtime will
    be brought down to approximately 14 seconds from an initial value of nearly 106
    seconds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是*金矿寻宝*程序从乌龟进化到兔子的预览。以下图表显示了性能改进每个主要步骤后的近似运行时间。当我们完成[第9章](ch09.html "第9章。性能改进
    – 第二部分，NumPy和并行化")，*性能改进 – 第二部分，NumPy和并行化*时，应用程序的运行时间将从大约106秒减少到大约14秒。
- en: '![Sneak peek at the upcoming application speedup](img/B05034_07_20.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![即将到来的应用程序加速预览](img/B05034_07_20.jpg)'
- en: No need to spend any time trying to understand the elements presented in this
    chart; things will become clear once you read all three chapters on performance.
    For now, all you need to know is that we will learn some techniques to drastically
    improve the application runtime in the upcoming chapters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要花费时间去理解图表中展示的元素；一旦你阅读完关于性能的三个章节，一切都会变得清晰。现在，你需要知道的是，在接下来的章节中，我们将学习一些技术来显著提高应用程序的运行时间。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Caution**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The chapters on performance will show some examples of inefficient code. Running
    these examples can consume a lot of compute resources. Instead of using the problem
    size illustrated in these chapters, you should choose an appropriate data size
    depending on what your machine can handle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 性能章节将展示一些低效代码的例子。运行这些例子可能会消耗大量的计算资源。你不需要使用这些章节中展示的问题规模，而应根据你的机器能处理的数据量选择合适的数据规模。
- en: Scenario – The Gold Hunt
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景 – 金矿寻宝
- en: '| *You recently introduced* *a new scenario in the game—to meet the expenses
    of his army, Sir Foo is out on a mission to collect gold from a recently acquired
    territory. The scenario starts with Sir Foo arriving at a place full of gold coins,
    jewelry, and so on. There are a couple of problems though. Firstly, the gold is
    scattered all over the field. Secondly, Sir Foo doesn''t have time to collect
    all the gold on the field.* |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| *你最近在游戏中引入了一个新的场景——为了支付军队的开销，Sir Foo正在执行一项任务，从最近获得的领土中收集金子。这个场景从Sir Foo到达一个充满金币、珠宝等等的地方开始。然而有几个问题。首先，金子散落在整个矿场上。其次，Sir
    Foo没有时间收集矿场上所有的金子。* |'
- en: '![Scenario – The Gold Hunt](img/B05034_07_22.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![场景 – 金矿寻宝](img/B05034_07_22.jpg)'
- en: '| *What you see behind Sir Foo is an imaginary **gold field**. Sir Foo will
    enter from the left side and travel across the field. He will only collect the
    coins lying along his path and **ignore all the remaining gold** scattered across
    the field.* |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| *Sir Foo身后你所看到的是一个虚构的**金矿**。Sir Foo将从左侧进入并穿越这片矿场。他只会收集沿着他路径躺着的硬币，**忽略矿场上散落的其余金子**。*
    |'
- en: 'Let''s represent this gold field as a circle with a radius of nearly 10 miles
    (diameter of 20 miles), and center located at coordinates *x = 0* and *y = 0*,
    as shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个金矿表示为一个半径约为10英里（直径20英里）的圆，中心位于坐标*x = 0*和*y = 0*，如下截图所示：
- en: '![Scenario – The Gold Hunt](img/B05034_07_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![场景 – 金矿寻宝](img/B05034_07_01.jpg)'
- en: Observe the following screenshot. The *dotted line* (the diameter of the field)
    shows the path that Sir Foo traverses on his way out. During this 20 mile journey,
    he stops at 10 *equally spaced points*. In other words, these points are 2 miles
    apart, represented by the centers of the small "search circles". For each stop,
    he collects the gold within a search circle. The total collected gold is the sum
    of the coins inside each of those 10 tiny circles. Let's not worry about the gold
    lying outside of these search circles.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下截图。*虚线*（矿场的直径）显示了Sir Foo在离开时走过的路径。在这20英里的旅程中，他在10个*等距的点*上停下来。换句话说，这些点相隔2英里，由小“搜索圆”的中心表示。对于每个停留点，他收集搜索圆内的金子。收集到的总金子是这10个小圆内硬币的总和。让我们不考虑这些搜索圆外的金子。
- en: Assume that the remaining gold on the field is irrelevant for the problem we
    are solving.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设矿场上剩余的金子对我们正在解决的问题无关紧要。
- en: '![Scenario – The Gold Hunt](img/B05034_07_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![场景 – 金矿寻宝](img/B05034_07_02.jpg)'
- en: High-level algorithm
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级算法
- en: 'With the preceding screenshot as a reference, let''s write the high-level algorithm.
    We will keep it simple. The task is to collect the gold coins found inside each
    of the small circles in this image (recall that these circles are referred to
    as *search circles*). We will call the radius of each of these circles a *search
    radius*. In the present scenario, the search radius is 1 mile, or let''s simply
    call it 1 unit:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以前面的截图为参考，让我们编写高级算法。我们将保持其简单。任务是收集图中每个小圆内的金币（记住，这些圆被称为*搜索圆*）。我们将这些圆的半径称为*搜索半径*。在当前场景中，搜索半径是1英里，或者我们可以简单地称之为1个单位：
- en: Randomly create points representing the gold coins inside a gold field. The
    gold field is represented by a large circle with a radius of 10 units and center
    at *(x = 0, y = 0)*. Each gold coin is represented with a *(x,y)* location.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个金矿区域内随机创建代表金币的点。金矿区域用一个半径为10个单位的圆表示，圆心在*(x = 0, y = 0)*。每枚金币用一个*(x,y)*位置表示。
- en: Start with the leftmost search circle, the center of which represents Sir Foo's
    current location. The coin hunt is constrained within this search circle.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最左边的搜索圆开始，其中心代表Sir Foo的当前位置。金币搜索被限制在这个搜索圆内。
- en: 'For each search circle:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个搜索圆：
- en: Get Sir Foo's current location coordinates.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取Sir Foo的当前位置坐标。
- en: Find the distance between each gold coin on the field and Sir Foo's location,
    the center of a search circle.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算场上每枚金币与Sir Foo位置（搜索圆的中心）之间的距离。
- en: Collect all the coins with distance less than the *search radius*. These are
    the coins lying inside the perimeter of the current search circle.
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集所有距离小于*搜索半径*的金币。这些是位于当前搜索圆周内的金币。
- en: Advance Sir Foo to the center of the next search circle.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Sir Foo移动到下一个搜索圆的中心。
- en: Repeat the preceding steps until you reach the rightmost circle.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复前面的步骤，直到达到最右边的圆。
- en: Report the total number of collected gold coins.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 报告收集到的金币总数。
- en: Reviewing the initial code
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查初始代码
- en: 'Let''s review the code next (it can also be found in the supporting code bundle,
    just look for the `goldhunt_inefficient.py` file). Here is a new `GoldHunt` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接下来回顾代码（它也可以在支持代码包中找到，只需查找`goldhunt_inefficient.py`文件）。下面是一个新的`GoldHunt`类：
- en: '![Reviewing the initial code](img/B05034_07_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![检查初始代码](img/B05034_07_03.jpg)'
- en: 'The `play` method of this class contains the main logic, as shown in the following
    screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的`play`方法包含主要逻辑，如下面的截图所示：
- en: '![Reviewing the initial code](img/B05034_07_21.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![检查初始代码](img/B05034_07_21.jpg)'
- en: 'Let''s review the code in the preceding screenshots:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾前面截图中的代码：
- en: The input arguments for the `play` method, `field_coins` and `field_radius`,
    set the number of coins and the radius of the circular gold field, respectively.
    These are optional arguments with default values, as shown in the `__init__` method.
    The third optional argument, `search_radius`, helps define the radius of the smaller
    search circles.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play`方法的输入参数`field_coins`和`field_radius`分别设置金币的数量和圆形金矿的半径。这些是可选参数，具有默认值，如`__init__`方法中所示。第三个可选参数`search_radius`帮助定义较小搜索圆的半径。'
- en: The `x_ref` and `y_ref` variables represent the *center* of the current search
    circle. We simplified the problem by assuming a constant `y_ref` of `0.0`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x_ref`和`y_ref`变量代表当前搜索圆的*中心*。我们通过假设一个恒定的`y_ref`值为`0.0`来简化了问题。'
- en: The `play` method starts by generating random points representing the scattered
    gold coins. The `generate_random_points` function returns two Python lists containing
    the `x` and `y` coordinates of all the coins on the field.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`play`方法首先生成代表散布在金矿上的金币的随机点。`generate_random_points`函数返回两个Python列表，包含场上所有金币的`x`和`y`坐标。'
- en: In a `while` loop, the `total_collected_coins` list stores the coordinates of
    coins inside the *search circles*, starting with the leftmost one.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`while`循环中，`total_collected_coins`列表存储了位于*搜索圆*内的金币坐标，从最左边的一个开始。
- en: The actual search operation is performed by the `find_coins` method.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的搜索操作是通过`find_coins`方法完成的。
- en: 'Next, let''s review the `GoldHunt.find_coins` method:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回顾`GoldHunt.find_coins`方法：
- en: '![Reviewing the initial code](img/B05034_07_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![检查初始代码](img/B05034_07_04.jpg)'
- en: This method loops over all the points (gold coins) on the field and for each
    point, it computes its distance from the center of the search circle. With this
    distance, we can determine whether or not the given gold coin lies inside the
    perimeter of the search circle. This is shown schematically in the following diagram.
    The `(x_ref, y_ref)` coordinates represent the center of the search circle. The
    `(x, y)` parameters are the coordinates of any gold coin on the field.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历场上的所有点（金币），并对每个点，计算其与搜索圆心的距离。有了这个距离，我们可以确定给定的金币是否位于搜索圆的周界内。这在下图中以示意图的形式展示。`(x_ref,
    y_ref)` 坐标代表搜索圆心的位置。`(x, y)` 参数是场上任何金币的坐标。
- en: '![Reviewing the initial code](img/B05034_07_05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![查看初始代码](img/B05034_07_05.jpg)'
- en: In this diagram, the distance between a point and the center is represented
    by **dist**. It shows two representative points (or coins). The first one with
    a *check mark* next to it lies inside the circle, whereas the other one with a
    *cross mark* is outside. Only the point lying inside the circle is collected.
    The method returns a `collected_coins` list that contains the location tuples
    `(x,y)` of all such points.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，点与中心之间的距离用 **dist** 表示。它显示了两个代表性的点（或金币）。旁边带有 *勾号* 的第一个点位于圆内，而带有 *叉号* 的另一个点位于圆外。只有位于圆内的点被收集。该方法返回一个
    `collected_coins` 列表，其中包含所有此类点的位置元组 `(x,y)`。
- en: 'Let''s review the function that creates random points on the field:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在场上创建随机点的函数：
- en: '![Reviewing the initial code](img/B05034_07_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![查看初始代码](img/B05034_07_06.jpg)'
- en: 'You should be able to understand this code fragment fairly easily if you have
    a basic math background. Here is how it works:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你具备基本的数学背景，你应该能够比较容易地理解这段代码。以下是它是如何工作的：
- en: Consider a point with radius `r` and an angle `theta`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一个半径为 `r`、角度为 `theta` 的点。
- en: The Cartesian coordinates of this point are *x = r*cos(theta)* and *y = r*sin(theta)*.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个点的笛卡尔坐标是 *x = r*cos(theta)* 和 *y = r*sin(theta)*。
- en: The built-in function, `random.uniform`, is used to randomly vary `r` between
    `0.0` (the field center) and `ref_radius` (the field radius). Note that the `import`
    statements are not shown. For that, refer to `goldhunt_inefficient.py`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置函数 `random.uniform` 用于在 `0.0`（场中心）和 `ref_radius`（场半径）之间随机变化 `r`。注意，没有显示 `import`
    语句。有关这些，请参阅 `goldhunt_inefficient.py`。
- en: Similarly, the `theta` angle is randomly varied between `0.0` and `2*math.pi`
    (360 degrees).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，`theta` 角度在 `0.0` 和 `2*math.pi`（360度）之间随机变化。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Plotting the points**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘制点**'
- en: You can visualize the generated random distribution of gold coins using **matplotlib**,
    a Python plotting library. We won't discuss the plotting techniques here. Check
    out their website ([http://matplotlib.org](http://matplotlib.org)) that hosts
    a number of tutorials and installation instructions. Python distributions, such
    as Anaconda, come preinstalled with matplotlib. You can also use the plotting
    function, `plot_points`, provided in the `goldhunt_inefficient.py` file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 **matplotlib**，一个Python绘图库，可视化生成的随机分布的金币。我们在这里不会讨论绘图技术。请查看他们的网站 ([http://matplotlib.org](http://matplotlib.org))，那里提供了一些教程和安装说明。Python发行版，如Anaconda，预装了matplotlib。您还可以使用
    `goldhunt_inefficient.py` 文件中提供的绘图函数 `plot_points`。
- en: Running the code
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: 'The main execution code is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 主要执行代码如下：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code uses the default arguments to instantiate `GoldHunt`. With the default
    arguments, the code should run smoothly and finish within a few seconds. The actual
    time will vary depending on your machine configuration, available RAM, and so
    on. You can add some informative `print` statements to see how the game is progressing.
    Here is a sample output using the default arguments:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用默认参数来实例化 `GoldHunt`。使用默认参数，代码应该可以顺利运行并在几秒钟内完成。实际时间将取决于您的机器配置、可用RAM等因素。您可以通过添加一些信息性的
    `print` 语句来查看游戏进度。以下是使用默认参数的示例输出：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The problem
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '| *In the game scenario, you allowed the users to tweak certain parameters.
    For example, the users can control the **total number of coins** on the field
    or modify the **radius of the search circle**. Unknowingly, you opened a new can
    of worms. For a large input size, the program runs very slow. For example, one
    variant of the game, **The Great Dwarf of the Foo mountain**, is performing the
    gold hunt. Let''s hear what he has to say:* |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 在游戏场景中，你允许用户调整某些参数。例如，用户可以控制场上的**总硬币数**或修改**搜索圆的半径**。无意中，你打开了一个新的问题。对于大量输入，程序运行非常慢。例如，游戏的一个变体，**Foo山的巨魔**正在执行黄金狩猎。让我们听听他有什么要说的：|'
- en: '![The problem](img/B05034_07_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![问题](img/B05034_07_07.jpg)'
- en: 'If you change `field_coins` from `5000` to `1000000` and set `search_radius`
    to `0.1`, the application will take quite a bit of time to finish. Here is the
    updated main execution code with these new parameters:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`field_coins`从`5000`改为`1000000`，并将`search_radius`设置为`0.1`，应用程序完成这个过程将需要相当长的时间。以下是带有这些新参数的更新后的主要执行代码：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you increase the coins further or make the search radius even smaller, it
    will severely affect the application runtime.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进一步增加硬币数量或使搜索半径变得更小，这将严重影响应用程序的运行时间。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Warning!**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告！**'
- en: If you run the following code, depending on your machine configuration, it can
    slow down your machine, take longer time to finish, and in some cases (a machine
    with an average configuration) the computer can stop responding. If you are unsure,
    it is better not to run it! It is presented here just as an example. If you really
    want to, then do it at your own risk!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行以下代码，根据你的机器配置，它可能会减慢你的机器速度，延长完成时间，在某些情况下（配置平均的机器）计算机可能停止响应。如果你不确定，最好不要运行它！这里只是作为一个例子展示。如果你真的想尝试，那么请自行承担风险！
- en: For example, it can take several seconds or minutes to complete this operation.
    What can we do here to improve the performance? Before jumping to that, let's
    first review some techniques to identify the bottlenecks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，完成此操作可能需要几秒钟或几分钟。我们在这里能做些什么来提高性能？在跳到那之前，让我们首先回顾一些识别瓶颈的技术。
- en: Identifying the bottlenecks
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别瓶颈
- en: In the previous section, we saw how a different choice of input parameters degrades
    the application runtime. Now, we need some way to accurately measure the execution
    time and find out the performance bottlenecks or the time consuming blocks of
    the code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了不同的输入参数选择如何降低应用程序的运行时间。现在，我们需要一种方法来准确测量执行时间，并找出性能瓶颈或代码中耗时的部分。
- en: Measuring the execution time
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量执行时间
- en: Let's start by monitoring the time taken by the application. To do this, we
    will use Python's built-in `time` module. The `time.perf_counter` function is
    a performance counter that returns a clock with the highest available resolution.
    This function can be used to determine the time interval or the system-wide time
    difference between the two consecutive calls to the function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从监控应用程序的执行时间开始。为此，我们将使用Python的内置`time`模块。`time.perf_counter`函数是一个性能计数器，它返回一个具有最高可用分辨率的时钟。此函数可用于确定函数连续两次调用之间的时间间隔或系统范围内的时间差。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `time.perf_counter` function is available in Python versions 3.3 onwards.
    If you have an older version of Python (for example, version 2.7), use `time.clock()`
    instead. On Unix, `time.clock()` returns a floating point number within seconds
    that represents the processor time. On Windows, it returns the elapsed wall-clock
    time within seconds after the first call to the function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.perf_counter`函数从Python 3.3版本开始可用。如果你有较旧的Python版本（例如，2.7版本），请使用`time.clock()`代替。在Unix上，`time.clock()`返回一个表示处理器时间的浮点数（以秒为单位）。在Windows上，它返回自函数第一次调用以来经过的墙钟时间（以秒为单位）。'
- en: 'The original file, `goldhunt_inefficient.py`, already has the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 原始文件`goldhunt_inefficient.py`已经包含了以下代码：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At the beginning of the file, we import the `time` module. The `start` variable
    marks the beginning of the performance counter, and the `end` variable represents
    its second consecutive call. In between, we will run the main execution code.
    The difference between the two values of the counter can be used as an indicator
    for the runtime of the application. Similarly, you can insert these calls elsewhere
    in the code to monitor individual code fragments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件开头，我们导入 `time` 模块。`start` 变量标记性能计数器的开始，而 `end` 变量代表其第二次连续调用。在这之间，我们将运行主要执行代码。计数器两个值之间的差异可以用作应用程序运行时间的指标。同样，你可以在代码的其他地方插入这些调用以监控单个代码片段。
- en: Measuring the runtime of small code snippets
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量小代码片段的运行时间
- en: 'The built-in `timeit` module is a useful tool for quickly checking the execution
    time of a small code fragment. It can be used from the command line or imported
    and called inside the code. Here is one way to use this functionality using the
    command-line interface:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `timeit` 模块是一个用于快速检查小代码片段执行时间的有用工具。它可以从命令行使用，也可以在代码内部导入和调用。以下是使用命令行界面使用此功能的一种方法：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-m` option allows running the `timeit` module from the command line. In
    the preceding example, it measures the execution time for the `x = 100*100` statement.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m` 选项允许从命令行运行 `timeit` 模块。在上面的例子中，它测量了 `x = 100*100` 语句的执行时间。'
- en: 'Let''s review the output of this execution. The `100000000 loops` in the output
    indicates how many times the code is executed by `timeit`. It reports the best
    of three timings. In this example, the best time taken is `0.0155` microseconds
    for a single execution. You can also tweak the number of times the code is run
    by using the `--number` argument, as shown in the following code snippet. Here,
    the code is run only `10` times:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下这个执行的输出。输出中的 `100000000 loops` 表示 `timeit` 执行代码的次数。它报告了三次测量的最佳时间。在这个例子中，单次执行的最好时间是
    `0.0155` 微秒。你也可以通过使用 `--number` 参数来调整代码运行的次数，如下面的代码片段所示。在这里，代码只运行了 `10` 次：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Internally, `timeit` uses `time.perf_counter` to measure the time taken. This
    is the default implementation since Python version 3.3\. For further details,
    check out the documentation ([https://docs.python.org/3/library/timeit.html](https://docs.python.org/3/library/timeit.html)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`timeit` 使用 `time.perf_counter` 来测量时间。这是自 Python 3.3 版本以来的默认实现。有关更多详细信息，请参阅文档（[https://docs.python.org/3/library/timeit.html](https://docs.python.org/3/library/timeit.html)）。
- en: Code profiling
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码分析
- en: The performance measurement techniques that we have seen so far work quite well,
    especially when you want to run benchmarks for the application. However, it is
    often cumbersome to implement these timers throughout your project to get a full
    execution profile. This is where the code profiling helps. It is a technique that
    analyzes a program while it is running and gathers some important statistics.
    For example, it reports the duration and frequency of various function calls within
    that program. This information can be used to identify the performance bottlenecks
    in the code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的性能测量技术工作得相当好，尤其是当你想要为应用程序运行基准测试时。然而，在整个项目中实现这些计时器以获取完整的执行配置文件通常很繁琐。这就是代码分析发挥作用的地方。这是一种在程序运行时分析程序并收集一些重要统计数据的技术。例如，它报告了该程序中各种函数调用的持续时间和频率。这些信息可用于识别代码中的性能瓶颈。
- en: The cProfile module
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: cProfile 模块
- en: 'Let''s see how to use `cProfile`, Python''s built-in module for code profiling.
    For illustration purposes, we will use the `profile_ex.py` file from the supporting
    code bundle. It has three simple functions that do some trivial tasks, as shown
    in the following screenshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `cProfile`，Python 的内置代码分析模块。为了说明目的，我们将使用支持代码包中的 `profile_ex.py` 文件。它包含三个执行一些简单任务的功能，如下面的截图所示：
- en: '![The cProfile module](img/B05034_07_08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![cProfile 模块](img/B05034_07_08.jpg)'
- en: 'The `cProfile` command can either be run from the command prompt or by importing
    it inside the module to be tested. Here is the output when run from the Command
    Prompt:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 命令可以从命令提示符运行，也可以通过导入要测试的模块内部来运行。以下是使用命令提示符运行时的输出：'
- en: '![The cProfile module](img/B05034_07_09.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![cProfile 模块](img/B05034_07_09.jpg)'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **IPython** interactive shell also provides a convenient magic command called
    `%prun`. With this, you can quickly profile a Python statement. For more information,
    check out [https://ipython.org/ipython-doc/3/interactive/magics.html](https://ipython.org/ipython-doc/3/interactive/magics.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**IPython**交互式外壳还提供了一个方便的魔法命令，称为`%prun`。使用它，你可以快速分析Python语句。更多信息，请查看[https://ipython.org/ipython-doc/3/interactive/magics.html](https://ipython.org/ipython-doc/3/interactive/magics.html)。'
- en: 'Let''s understand the output of this run:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来理解这次运行的输出：
- en: The first line of the output shows the total number of function calls monitored.
    A majority of these are due to `for loop` inside `test_2`. For each iteration,
    it calls the `append` function of the Python `list` datatype.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出的第一行显示了监控到的函数调用总数。其中大部分是由于`test_2`内部的`for`循环引起的。对于每次迭代，它都会调用Python `list`数据类型的`append`函数。
- en: On the same output line, it also reports the number of `primitive calls`. These
    are the function calls that do not involve **recursion**. The `test_3` function
    shows an example of recursion. To understand this better, run the code by printing
    the value of the input argument `condition`. In this case, there is only one recursive
    function call.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一输出行上，它还报告了`原始调用`的数量。这些是不涉及**递归**的函数调用。`test_3`函数展示了递归的一个例子。为了更好地理解这一点，通过打印输入参数`condition`的值来运行代码。在这种情况下，只有一个递归函数调用。
- en: The `ncalls` column indicates the number of function calls. If you add them
    up, the total number of calls becomes `10007`, same as the ones reported on the
    first line of the output. Notice that for `test_3`, it reports the function calls
    as `2/1`. It means that the function was called twice but one of the calls was
    recursive.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncalls`列表示函数调用的次数。如果你将它们加起来，总的调用次数变为`10007`，与输出第一行报告的相同。注意，对于`test_3`，它报告的函数调用为`2/1`。这意味着该函数被调用两次，但其中一次是递归调用。'
- en: The `tottime` column indicates the total time spent in a given function.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tottime`列表示在给定函数中花费的总时间。'
- en: The `percall` column records the quotient of the `totcall/ncalls` division.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`列记录了`totcall/ncalls`除法的商。'
- en: The time spent inside a particular function, including its sub-functions, is
    reported by `cumtime` (the cumulative time).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定函数内部（包括其子函数）花费的时间由`cumtime`（累积时间）报告。
- en: The `percall` column reports the `cumtime`/`primitive calls` quotient.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`列报告了`cumtime`/`原始调用`的商。'
- en: The last column is, essentially, the data related to the functions. It includes
    the built-in function calls, such as the `append` method of the Python `list`,
    and so on.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一列基本上是与函数相关的数据。它包括内置函数调用，例如Python `list`的`append`方法等。
- en: By default, the output is sorted by `standard name`. To understand the bottlenecks,
    this sorting order is not quite useful. Instead, you can sort by cumulative time,
    number of function calls, and so on. This is accomplished using the command-line
    option, `-s`. For a complete list of available sorting options, refer to [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，输出按`标准名称`排序。为了理解瓶颈，这种排序顺序并不十分有用。相反，你可以按累积时间、函数调用次数等排序。这可以通过命令行选项`-s`实现。有关可用排序选项的完整列表，请参阅[https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)。
- en: The following screenshot shows the output sorted by `tottime`. Observe that
    it spends the most time in the `test_2` function.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了按`tottime`排序的输出。观察发现，它花费了最多时间在`test_2`函数中。
- en: '![The cProfile module](img/B05034_07_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![cProfile模块](img/B05034_07_10.jpg)'
- en: 'Now that we know how to use `cProfile`, let''s use it to analyze the *Gold
    Hunt* problem. Run the original `goldhunt_inefficient.py` file with all the default
    options, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用`cProfile`，让我们用它来分析*黄金寻宝*问题。按照以下方式运行原始的`goldhunt_inefficient.py`文件，使用所有默认选项：
- en: '[PRE6]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It prints a lot of information in the terminal window as there are several of
    the internal function calls involved. Optionally, you can redirect `stdout` to
    a text file. To effectively analyze this data, Python provides a built-in module
    called `pstats`. Let's see how to use it in the following section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及多个内部函数调用，它会在终端窗口中打印大量信息。可选地，你可以将`stdout`重定向到文本文件。为了有效地分析这些数据，Python提供了一个内置模块，称为`pstats`。让我们在下一节中看看如何使用它。
- en: The pstats module
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pstats模块
- en: 'The `pstats` module can be used to further process the profiling data generated
    by `cProfile`. It gives you greater control over creating your reports as compared
    to the limited options provided by `cProfile`. The analysis of the data generated
    by `cProfile` is done using the `pstats.Stats` class. To make the `cProfile` output
    usable by `pstats`, we will need to write it to a file using the command-line
    option, `-o`, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`pstats`模块可以用于进一步处理由`cProfile`生成的分析数据。与`cProfile`提供的有限选项相比，它为您创建报告提供了更大的控制权。`cProfile`生成数据的分析是通过`pstats.Stats`类完成的。为了使`cProfile`的输出可供`pstats`使用，我们需要使用命令行选项`-o`将其写入文件，如下所示：'
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `profile_output` file, thus generated, is not human readable. While we
    can go on and feed this file to `pstats.Stats`, it is better to automate the whole
    process by stitching together these two utilities. Here is a simplified code that
    does this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此生成的`profile_output`文件不可读。虽然我们可以继续将此文件提供给`pstats.Stats`，但最好通过组合这两个实用程序来自动化整个过程。以下是一个简化的代码示例，实现了这一点：
- en: '![The pstats module](img/B05034_07_11.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![pstats模块](img/B05034_07_11.jpg)'
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提示**'
- en: '**Warning**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: This is a simplified example without any error checks! For example, the code
    does not check if the output file already exists. To make the code robust, add
    such checks and the `try…except` clauses wherever appropriate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个没有错误检查的简化示例！例如，代码没有检查输出文件是否已存在。为了使代码健壮，应在适当的地方添加此类检查和`try…except`语句。
- en: 'This code is also available as `profiling_goldhunt.py` in the supporting code
    bundle for this chapter. Let''s quickly review what this code does:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码也作为`profiling_goldhunt.py`包含在本章的支持代码包中。让我们快速回顾一下这段代码的功能：
- en: The main execution code shows a way to run `cProfile` using its `run` method.
    The first argument to `run` is the function (or statement) to be monitored, whereas
    the second argument is the filename where the profiling output is stored.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要执行代码展示了如何使用`cProfile`的`run`方法运行。`run`的第一个参数是要监控的函数（或语句），而第二个参数是存储分析输出的文件名。
- en: The `view_stats` function is where we use the functionality from `pstats`. This
    function takes the generated profiling output (`filname`) as the first argument.
    It is used while creating an instance of `pstats.Stats`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view_stats`函数是我们使用`pstats`功能的地方。该函数将生成的分析输出（`filname`）作为第一个参数。在创建`pstats.Stats`实例时使用。'
- en: The `strip_dirs` method of the `Stats` class is used to remove all leading path
    information strings from filenames. This reduces the clutter in the final output
    by just displaying the name of the file.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stats`类的`strip_dirs`方法用于从文件名中移除所有前导路径信息字符串。这通过仅显示文件名来减少最终输出的杂乱。'
- en: Using the `print_stats` method, we can impose some restrictions in the final
    output. In this example, it looks for the `goldhunt` string in the rightmost columns
    and displays the matching row, ignoring all others. Put in another way, it limits
    the information related to the function calls inside `goldhunt_inefficient.py`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`print_stats`方法，我们可以在最终输出中施加一些限制。在这个例子中，它查找最右侧列中的`goldhunt`字符串，并显示匹配的行，忽略所有其他行。换句话说，它限制了与`goldhunt_inefficient.py`内部函数调用相关的信息。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**注意**'
- en: The `pstats.Stats` class provides several other useful features. For example,
    the `print_callees` method prints a list of all the functions that were called
    by the function being monitored. For further details, check out the Python documentation
    ([https://docs.python.org/3/library/profile.html#pstats.Stats](https://docs.python.org/3/library/profile.html#pstats.Stats)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`pstats.Stats`类提供了其他一些有用的功能。例如，`print_callees`方法打印出被监控函数调用的所有函数的列表。有关更多详细信息，请参阅Python文档（[https://docs.python.org/3/library/profile.html#pstats.Stats](https://docs.python.org/3/library/profile.html#pstats.Stats)）。'
- en: 'This code can be run from the command prompt, as follows (it has a dependency
    on `goldhunt_inefficient.py` so put it in the same directory as this file):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以从命令提示符运行，如下所示（它依赖于`goldhunt_inefficient.py`，所以请将其放在与该文件相同的目录中）：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is the sample output of this run (only the output pertaining to the statistics
    is shown):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此运行过程的示例输出（仅显示与统计相关的输出）：
- en: '![The pstats module](img/B05034_07_12.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![pstats模块](img/B05034_07_12.jpg)'
- en: This is significantly less output and is restricted to the function calls from
    the program we wish to monitor. As indicated in the output, only `5` out of `19`
    function calls are listed. The list is sorted by the total internal time taken
    to execute the functions. The two functions, `find_coins` and `generate_random_points`,
    top the chart! Their order may vary depending on the values we choose for the
    `field_coins` and `search_radius` variables. But essentially, the code profiling
    has helped us identify the most time consuming code in our application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显著减少输出，并且仅限于我们希望监控的程序中的函数调用。如输出所示，只有`19`个函数调用中的`5`个被列出。列表按执行函数所花费的总内部时间排序。两个函数`find_coins`和`generate_random_points`位于榜首！它们的顺序可能取决于我们为`field_coins`和`search_radius`变量选择的值。但本质上，代码分析帮助我们识别了应用程序中最耗时的代码。
- en: '![The pstats module](img/B05034_07_13.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![pstats模块](img/B05034_07_13.jpg)'
- en: '| *Good question! It will certainly help if we can peep inside the function
    and see the line-by-line profiling output. Luckily, there is a tool that enables
    exactly this. Let''s review it next.* |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| *好问题！如果我们能查看函数内部并看到逐行分析输出，那当然会很有帮助。幸运的是，有一个工具可以实现这一点。让我们接下来回顾一下。* |'
- en: The line_profiler package
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`line_profiler`包'
- en: 'The `line_profiler` package is a third-party Python package that can be installed
    using `pip`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`line_profiler`包是一个第三方Python包，可以使用`pip`安装：'
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This package can be used to monitor the performance of a function, line by line.
    When you install the package, it also creates an executable `kernprof`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包可以用来逐行监控函数的性能。当你安装这个包时，它也会创建一个可执行的`kernprof`。
- en: On Linux, this executable is created at the same location as your Python executable.
    For example, on Linux, if Python is available as `/usr/bin/python`, this executable
    is created as `/usr/bin/kernprof` (or look for the `kernprof.py` script). On Windows
    OS, it should be created at the same location as `pip.exe`. Refer to [Chapter
    1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing Simple
    Applications* for the `pip.exe` path.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，这个可执行文件与您的Python可执行文件位于同一位置。例如，在Linux上，如果Python可用作`/usr/bin/python`，则此可执行文件创建为`/usr/bin/kernprof`（或查找`kernprof.py`脚本）。在Windows操作系统上，它应该与`pip.exe`位于同一位置。有关`pip.exe`路径，请参阅第1章，*开发简单应用程序*，*开发简单应用程序*。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'On Windows OS, if you encounter any error, such as **error: Unable to find
    vcvarsall.bat**, you will probably need to use Visual C++ Express. Check out [https://www.visualstudio.com/en-US/products/visual-studio-express-vs](https://www.visualstudio.com/en-US/products/visual-studio-express-vs)
    for more information.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统上，如果您遇到任何错误，例如**错误：无法找到vcvarsall.bat**，您可能需要使用Visual C++ Express。有关更多信息，请参阅[https://www.visualstudio.com/en-US/products/visual-studio-express-vs](https://www.visualstudio.com/en-US/products/visual-studio-express-vs)。
- en: 'Using this tool requires trivial changes to the code. All you need to do is
    add a `@profile` decorator above the function or method name, as shown in the
    following screenshot:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个工具需要对代码进行微小的修改。您需要做的只是在上面的函数或方法名上方添加一个`@profile`装饰器，如下面的截图所示：
- en: '![The line_profiler package](img/B05034_07_14.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![line_profiler包](img/B05034_07_14.jpg)'
- en: 'Then, run the tool using the `kernprof` command as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令运行工具：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `-v` or `--view` option displays the results of the profile output in the
    terminal window. The profiler also creates an output file, `goldhunt_inefficient.py.lprof`.
    The `-l` or `--line-by-line` option uses the line-by-line profiler from the `line_profiler`
    module.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v`或`--view`选项在终端窗口中显示配置文件输出的结果。分析器还会创建一个输出文件，`goldhunt_inefficient.py.lprof`。`-l`或`--line-by-line`选项使用来自`line_profiler`模块的逐行分析器。'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Be sure to remove the decorator `@profile` when you are not profiling the application
    using the `line_profiler`. In other words, remove it while running the application,
    as:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不使用`line_profiler`分析应用程序时，请务必删除装饰器`@profile`。换句话说，在运行应用程序时删除它，如下所示：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Otherwise, it will raise a `NameError` exception.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将引发`NameError`异常。
- en: The `line_profiler` output for the `find_coins` method is shown below.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了`find_coins`方法的`line_profiler`输出。
- en: As you can see, quite a bit of time is spent computing the distance between
    the points (gold coins) and the center of the search circle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，相当多的时间被花费在计算点（金币）与搜索圆心的距离上。
- en: '![The line_profiler package](img/B05034_07_15.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![line_profiler包](img/B05034_07_15.jpg)'
- en: Similarly, if you see the output for the `generate_random_point` function, the
    majority of the time is spent while creating a random combination of the `theta`
    angle and the `r` radius, which is used to define a point (a gold coin).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您看到`generate_random_point`函数的输出，大部分时间都花在创建一个随机的`theta`角度和`r`半径的组合上，这些组合用于定义一个点（一个金币）。
- en: Memory profiling
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存分析
- en: The profiling techniques we have covered so far aim at finding the runtime bottlenecks.
    Let's briefly discuss memory profiling, another important aspect of profiling.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所涵盖的剖析技术旨在找到运行时瓶颈。让我们简要讨论内存分析，这是剖析的另一个重要方面。
- en: The memory_profiler package
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分析器包
- en: 'For memory profiling, we will use a popular Python package called `memory_profiler`.
    It can be installed using `pip`. Here is how to install it on Linux from the command
    line:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内存分析，我们将使用一个流行的Python包，称为`memory_profiler`。它可以通过`pip`安装。以下是如何在Linux命令行中安装它的方法：
- en: '[PRE12]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The documentation highly recommends installing the `psutils` module. It also
    suggests that, in order for `memory_profiler` to work on Windows OS, you will
    need the `psutil` module. The `psutil` module can be installed using `pip`, as
    follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 文档强烈建议安装`psutils`模块。它还建议，为了使`memory_profiler`在Windows操作系统上工作，您将需要`psutil`模块。可以使用`pip`安装`psutil`模块，如下所示：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'For more information on `memory_profiler`, check out the following page: [https://pypi.python.org/pypi/memory_profiler](https://pypi.python.org/pypi/memory_profiler).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`memory_profiler`的更多信息，请查看以下页面：[https://pypi.python.org/pypi/memory_profiler](https://pypi.python.org/pypi/memory_profiler)。
- en: 'Just like `line_profiler`, the `memory_profiler` package uses the `@profile`
    decorator above the function name. Let''s add the decorator `@profile` just above
    the `generate_random_points` function, and then run the memory profiler on the
    `goldhunt_inefficient.py` file. The command to run this is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`line_profiler`一样，`memory_profiler`包在函数名上方使用`@profile`装饰器。让我们在`generate_random_points`函数上方添加装饰器`@profile`，然后对`goldhunt_inefficient.py`文件运行内存分析器。运行此命令的命令如下：
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here is the output of the memory profiler. It reports the line-by-line memory
    consumption. Note that the profiler prints the whole function, including the docstrings.
    For ease of illustration, part of the docstring is not shown.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是内存分析器的输出。它按行报告内存消耗。请注意，分析器打印了整个函数，包括文档字符串。为了便于说明，部分文档字符串没有显示。
- en: '![The memory_profiler package](img/B05034_07_16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![内存分析器包](img/B05034_07_16.jpg)'
- en: The line number in the code is shown in the first column. The second column,
    `Mem Usage`, tells us how much memory the Python interpreter consumes after executing
    that line number. The unit of the memory is **mebibyte** (**MiB**).The third column,
    `Increment`, gives the memory difference between the current line and the previous
    line. If the memory is released by the current line of code, then the `Increment`
    column shows a negative number. The last column shows the actual line of code.
    As can be seen from the `Increment` column, the memory is mainly consumed in the
    `for` loop. We will use the memory profiler in the next chapter to compare the
    memory efficiency of a **generator expression** and a **list comprehension**.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的行号显示在第一列。第二列`Mem Usage`告诉我们Python解释器执行该行号后消耗了多少内存。内存的单位是**梅比字节**（**MiB**）。第三列`Increment`给出了当前行与上一行之间的内存差异。如果当前行代码释放了内存，那么`Increment`列将显示负数。最后一列显示了实际的代码行。从`Increment`列可以看出，内存主要消耗在`for`循环中。我们将在下一章中使用内存分析器来比较生成器表达式和列表解析的内存效率。
- en: Algorithm efficiency and complexity
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算法效率和复杂度
- en: 'An algorithm is a set of instructions to solve a particular problem. In this
    context, an algorithm can be a function or even a simple operation that adds two
    numbers. Let''s understand two related terms: algorithm efficiency and algorithm
    complexity.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是一组解决特定问题的指令。在这个上下文中，算法可以是一个函数，甚至是一个简单的加法操作，用于将两个数字相加。让我们了解两个相关的术语：算法效率和算法复杂度。
- en: Algorithm efficiency
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法效率
- en: Algorithm efficiency indicates the computation resources consumed by an algorithm.
    Typically, the lower the resource consumption, the better the efficiency. The
    computational resources can mean several things. One can be talking about the
    runtime (CPU usage), the memory consumption (RAM or hard disk) or the network
    consumption, or a combination of these.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 算法效率表示算法消耗的计算资源。通常，资源消耗越低，效率越好。计算资源可以指很多种东西。一种可能是谈论运行时间（CPU使用率）、内存消耗（RAM或硬盘）或网络消耗，或者这些的组合。
- en: The application requirement determines which resource takes precedence over
    the others. For example, in a web application, the network usage can be more important
    than the disk space. For a scientific application, you might have all the memory
    you need but the runtime can be a pain in the neck, and so on. In this book, we
    will limit our discussion to the runtime efficiency only.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用需求决定了哪种资源比其他资源更重要。例如，在Web应用中，网络使用可能比磁盘空间更重要。对于科学应用，你可能需要所有的内存，但运行时间可能会很痛苦，等等。在这本书中，我们将只讨论运行效率。
- en: Algorithm complexity
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法复杂度
- en: Suppose you have a program (an algorithm) that processes some data in five minutes.
    If you increase the size of the data, how much time will the program need? The
    answer lies in the algorithm complexity. It tells us how well the algorithm will
    scale if you increase the size of the problem. In other words, the computational
    complexity influences the performance of the algorithm. In the next section, you
    will learn how to represent the computational complexity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个程序（一个算法）在五分钟内处理一些数据。如果你增加数据的大小，程序需要多少时间？答案在于算法复杂度。它告诉我们，如果你增加问题的大小，算法将如何扩展。换句话说，计算复杂度影响了算法的性能。在下一节中，你将学习如何表示计算复杂度。
- en: Big O notation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大O记号
- en: 'In simple terms, the big O or big Oh notation is a way to represent the computational
    complexity of an algorithm. Here, the O is the letter *O*, as in *order*, and
    not the number zero. The big O indicates an upper bound or the worst-case scenario
    of the complexity of an algorithm (details to follow in the next section). This
    concept can be better explained with an example. Let''s take a look at the following
    code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，大O或大O记号是一种表示算法计算复杂度的方法。在这里，O是字母*O*，表示*顺序*，而不是数字零。大O表示算法复杂度的上界或最坏情况（详细内容将在下一节中介绍）。这个概念可以通过一个例子来更好地解释。让我们看看以下代码：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's call this trivial code fragment an algorithm. It is a simple operation
    that appends a number to the `list` inside a `for` loop. Here, `num` represents
    the size of the input used by the algorithm. If you increase `num`, the algorithm
    will have to do more work inside the `for` loop. Increase it further, and the
    poor algorithm will have to do even more work. Thus, the time taken by the algorithm
    depends on the value of `num` and can be expressed as a growth function, *f(n)*.
    Here, *n* represents the size of the input that corresponds to `num` in this example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这段简单的代码片段称为算法。它是一个简单的操作，在`for`循环中将一个数字添加到`list`中。在这里，`num`代表算法使用的输入大小。如果你增加`num`，算法将不得不在`for`循环中做更多的工作。进一步增加，这个可怜的算法将不得不做更多的工作。因此，算法所需的时间取决于`num`的值，可以表示为一个增长函数，*f(n)*。在这里，*n*代表输入的大小，对应于这个例子中的`num`。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Making sense so far? You can also test this by measuring the execution time.
    To see a real difference, choose a larger value of `num`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止是否理解了？你也可以通过测量执行时间来测试这一点。为了看到真正的差异，请选择一个较大的`num`值。
- en: In this algorithm, the most time consuming piece is the `for` loop, and it will
    determine the overall runtime of the algorithm. Inside the `for` loop, each call
    to `x.append(i)` takes constant time, *t*, to finish. For a large value of `num`,
    the total time taken by the loop will be approximately *num*(t)*. Thus, the runtime
    efficiency of the whole algorithm relative to `num` is linear. In terms of the
    big O notation, this particular algorithm is said to have *O(n)* complexity.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，最耗时的部分是`for`循环，它将决定算法的整体运行时间。在`for`循环内部，每次调用`x.append(i)`都需要常数时间，*t*，来完成。对于较大的`num`值，循环的总时间将大约是*num*(t)*。因此，整个算法相对于`num`的运行效率是线性的。从大O记号的角度来看，这个特定的算法被认为是*O(n)*复杂度。
- en: Big O complexity classes
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大O复杂度类别
- en: 'Let''s review some big O complexity classes. The following chart annotates
    various complexity classes and shows how *f(n)* influences the running time of
    algorithms:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下大O复杂度类。以下图表注释了各种复杂度类，并显示了*f(n)*如何影响算法的运行时间：
- en: '![Big O complexity classes](img/B05034_07_17.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![大O复杂度类](img/B05034_07_17.jpg)'
- en: On the *y* axis, we have the *f(n)* function, and the *x* axis represents the
    input size, *n* (the `num` variable in the previous discussion). The plot compares
    some common functions that represent the time complexity of algorithms.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Y*轴上，我们有*f(n)*函数，而*x*轴代表输入大小，*n*（前一次讨论中的`num`变量）。这个图比较了一些表示算法时间复杂度的常见函数。
- en: It should be noted that the big O representation does not include the constants.
    So, even if two algorithms share the same big O complexity, they can clock a very
    different runtime performance. The circle marker in the plot shows a typical crossover
    point between two complexity functions. In this example, this is between *O(n)*
    and *O(n log n)*. As noted earlier, the individual algorithms representing these
    complexity functions will have different constant multipliers (not reflected in
    the big O notation). Tweaking those multipliers can change where this crossover
    happens.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，大O表示法不包括常数。因此，即使两个算法具有相同的大O复杂度，它们的运行性能也可能非常不同。图中的圆点标记显示了两个复杂度函数之间的典型交叉点。在这个例子中，这是在*O(n)*和*O(n
    log n)*之间。如前所述，代表这些复杂度函数的个别算法将具有不同的常数乘数（在大O表示法中未反映）。调整这些乘数可以改变这个交叉点发生的位置。
- en: Let's briefly review these notations now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要回顾一下这些符号。
- en: O(1) – constant time
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(1) – 常数时间
- en: Regardless of the value of the input size, the time taken by the algorithm remains
    constant. Getting the length of a Python list (`len(x)`, where `x` is the list)
    or the `append` list operation we saw earlier, are a few examples of *O(1)* complexity.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无论输入大小如何，算法所需的时间都保持不变。获取Python列表的长度（`len(x)`，其中`x`是列表）或我们之前看到的`append`列表操作，都是*O(1)*复杂度的几个例子。
- en: O(log n) – logarithmic
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(log n) – 对数复杂度
- en: The time required by the algorithm is proportional to the logarithm of the input
    size. One of the examples of logarithmic complexity is a **binary search algorithm**.
    It starts with inspecting the middle element of a sorted array. If the value being
    searched is lower than the middle element, the entire upper half, including this
    middle element, is eliminated from the search. We can do this because it is a
    **sorted array**. This process is repeated for the remaining half and it continues
    until we find the desired value.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 算法所需的时间与输入大小的对数成正比。对数复杂度的一个例子是**二分查找算法**。它从检查排序数组的中间元素开始。如果被搜索的值小于中间元素，则包括这个中间元素在内的整个上半部分将从搜索中排除。我们可以这样做，因为这是一个**排序数组**。这个过程会重复进行剩余的一半，直到我们找到所需的值。
- en: Confused? Let's see what Fairy is up to these days…
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我们看看仙女最近在忙些什么……
- en: '| *Fairy has lost her enchanted locket in a room full of treasure chests. These
    boxes are numbered 1 to 100 and are arranged in increasing order. In other words,
    the boxes are sorted and the locket is placed in one of them. She is trying to
    find it with the help of her magical wand. The wand knows that the locket is in,
    for instance, box number 82, but it won''t give a straight answer! It expects
    her to ask the right questions.**She is standing exactly in the middle of the
    room and in front of box 50\. Towards her left, she sees numbers 1 to 49; and
    towards the right, numbers 51 to 100, in that order.**She asks her wand, is the
    locket in box 50? The wand says "no". She further asks, is the number greater
    than 50 or less than 50? The wand answers "greater than 50".**With this answer,
    she ignores the boxes on the left side (1-49), including box 50, and stands in
    the middle of the group, to her right (51-100). Now, she has box 75 in front of
    her. She repeats the questions with box 75 as the reference. Each time, half of
    the remaining chests are eliminated. The search operation goes on until she finds
    her locket in box 82.* |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| *小仙子在一间满是宝箱的房间里丢失了她的魔法钥匙。这些箱子编号从1到100，并按顺序排列。换句话说，箱子已经排序，钥匙放在其中一个箱子里。她正试图在魔杖的帮助下找到它。魔杖知道钥匙在，例如，编号为82的箱子里，但它不会给出直接的答案！它期望她提出正确的问题。**她正站在房间的中间，面对着编号为50的箱子。向她的左边，她看到数字1到49；向她的右边，数字51到100，按此顺序排列。**她问魔杖，钥匙在编号为50的箱子里吗？魔杖说“不在”。她进一步问，数字是大于50还是小于50？魔杖回答“大于50”。**有了这个回答，她忽略了左侧的箱子（1-49），包括编号为50的箱子，然后站在她右边的中间位置（51-100）。现在，她面前是编号为75的箱子。她以编号为75的箱子为参考，重复提出问题。每次，剩余的箱子数量减半。搜索操作一直进行到她在编号为82的箱子里找到她的钥匙。*
    |'
- en: This is the binary search in a nutshell. You can find more information on Wikipedia
    ([https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)).
    In the worst case scenario, the time complexity of this search is *O(log n)*.
    Another way to look at the logarithmic complexity is as follows. For an exponential
    increase in the size of the problem *n*, the time taken by the algorithm increases
    linearly. As can be seen in the earlier chart, the *O(log n)* time complexity
    is better compared to the *O(n)* (linear-time) complexity, but not as good as
    *O(1)*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是二分查找的精髓。你可以在维基百科上找到更多信息（[https://en.wikipedia.org/wiki/Binary_search_algorithm](https://en.wikipedia.org/wiki/Binary_search_algorithm)）。在最坏的情况下，这种搜索的时间复杂度为*O(log
    n)*。另一种看待对数复杂度的方法是：对于问题规模*n*的指数增长，算法所需的时间线性增加。如前图表所示，*O(log n)*的时间复杂度比*O(n)*（线性时间）复杂度要好，但不如*O(1)*。
- en: O(n) – Linear time
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(n) – 线性时间
- en: We already saw an example where a `for` loop makes the algorithm of the *O(n)*
    complexity. Finding a min or max element in a Python list and copying a list or
    a dictionary are some other examples of this complexity.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个例子，其中`for`循环使得算法的复杂度为*O(n)*。在Python列表中查找最小或最大元素以及复制列表或字典都是这种复杂度的其他例子。
- en: O(n log n) – Log linear
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(n log n) – 对数线性
- en: An example of a log linear time complexity is a **quicksort algorithm**. Let's
    call Fairy one more time to get a better idea of the working of this algorithm.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对数线性时间复杂度的例子是**快速排序算法**。让我们再次请出小仙子，以便更好地了解这个算法的工作原理。
- en: '| *Fairy enters another treasure room and finds it extremely disorganized.
    The treasure chests are randomly scattered everywhere in the room. Not liking
    this, she decides to sort the chests in an increasing order of their value (or
    price). Initially, the chests are randomly placed, like this:**[5 3 2 4 9 7 8
    8 ]**Here, the number represents the value of each chest. Fairy starts picking
    a pivot chest, say with a value tag of 5\. She then rearranges the chests into
    three sections: (i) The ones with a value lower than 5 are on the left side of
    the pivot, (ii) the pivotal chest 5, (iii) and the values greater than 5 are on
    the right side. This is shown below:**[3 2 4 5 9 7 8 8 ]**Next, with 5 fixed to
    its position, she repeats the preceding procedure to the items on the left and
    right sides of 5\. For example, consider only the left side of 5:**[3 2 4]**The
    fairy chooses number 3 as a new pivot and arranges the values to the left and
    right of 3, as shown earlier. This rearrangement results in:**[2 3 4]**The process
    goes on until all the chests are sorted in the increasing order of the valuables,
    as shown below:**[2 3 4 5 7 8 8 9]* |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| *仙女进入另一个宝藏室，发现它极其杂乱。宝箱在房间里到处随意散落。不喜欢这种状况，她决定按照宝箱的价值（或价格）递增的顺序对它们进行排序。最初，宝箱是随机放置的，如下所示：**[5
    3 2 4 9 7 8 8]**。在这里，数字代表每个宝箱的价值。仙女开始挑选一个枢轴宝箱，比如说价值标签为 5 的宝箱。然后她将宝箱重新排列成三个部分：（i）价值低于
    5 的宝箱位于枢轴的左侧，（ii）枢轴宝箱 5，（iii）价值高于 5 的宝箱位于右侧。如下所示：**[3 2 4 5 9 7 8 8]**。将 5 固定在其位置后，她重复上述步骤对
    5 左右两侧的物品进行操作。例如，只考虑 5 的左侧：**[3 2 4]**。仙女选择数字 3 作为新的枢轴，并将 3 左右两侧的价值按照之前所示进行排列。这种重新排列的结果如下：**[2
    3 4]**。这个过程一直持续到所有宝箱按照价值递增的顺序排序，如下所示：**[2 3 4 5 7 8 8 9]* |'
- en: This is the basic quicksort operation and has the complexity of *O(n log n)*.
    As shown in the earlier chart, for a higher value of *n*, the *O(n log n)* complexity
    is expensive compared to *O(n)*, but it is much better than the quadratic complexity.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基本的快速排序操作，其复杂度为 *O(n log n)*。如图所示，对于较大的 *n* 值，与 *O(n)* 相比，*O(n log n)* 的复杂度较为昂贵，但它比二次复杂度要好得多。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It should be noted that *O(n log n)* is the **average-case** complexity of the
    quicksort algorithm. Refer to the section, *Upper bound (worst-case) of the complexity*,
    of this chapter to learn about average-case and worst-case complexities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，*O(n log n)* 是快速排序算法的 **平均情况** 复杂度。请参考本章的 *复杂度的上界（最坏情况）* 部分，了解平均情况和最坏情况复杂度。
- en: O(n²) – Quadratic
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(n²) – 二次方
- en: 'This represents the quadratic runtime complexity. The time required to run
    the program grows as square of the size of the input to the algorithm. Let''s
    extend the previous example to understand this further:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示二次运行时复杂度。程序运行所需的时间随着算法输入大小的平方增长。让我们扩展之前的例子来进一步理解这一点：
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is a nested `for` loop. Let *t* be the time it takes to append an element
    to the list. As mentioned earlier, a single append operation is of *O(1)* complexity.
    The inner `for` loop will take approximately *n*t* (or *num*t*) to execute. Since
    we have an outer `for` loop, the total time complexity becomes *n*(n*t)*. A classic
    example of this complexity is a **bubble sort algorithm** ([https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)).
    This algorithm sorts a list in an iterative manner, and it repeatedly swaps the
    adjacent elements of the list if these elements are placed in a wrong order.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个嵌套的 `for` 循环。设 *t* 为将一个元素添加到列表中所需的时间。如前所述，单个添加操作的时间复杂度为 *O(1)*。内层 `for`
    循环将大约需要 *n*t*（或 *num*t*）的时间来执行。由于我们有一个外层 `for` 循环，总的时间复杂度变为 *n*(n*t)*。这种复杂性的一个经典例子是
    **冒泡排序算法** ([https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort))。该算法以迭代方式对列表进行排序，并且如果列表中的相邻元素放置错误，则反复交换它们。
- en: O(n³) – cubic
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: O(n³) – 三次方
- en: This is a cubic complexity, which is worse than the quadratic complexity. A
    small increase in the problem size will result in a big increase in the runtime.
    Adding another outer `for` loop in the illustration on quadratic complexity will
    make it *O(n**3**)*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个三次方复杂度，比二次复杂度更差。问题规模的小幅增加将导致运行时间的显著增加。在二次复杂度的示意图中添加另一个外层 `for` 循环将使其变为 *O(n**3**)*。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is only a partial list of complexity classes. There are many more. For
    further information, check out [https://en.wikipedia.org/wiki/Big_O_notation](https://en.wikipedia.org/wiki/Big_O_notation).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个复杂度类别的部分列表。还有很多其他的。如需更多信息，请查看[https://en.wikipedia.org/wiki/Big_O_notation](https://en.wikipedia.org/wiki/Big_O_notation)。
- en: Upper bound of the complexity
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复杂度的上界
- en: 'Let''s revisit the statement we made earlier: "Big O notation indicates an
    upper bound or the worst-case scenario of the complexity of an algorithm". Quite
    a mouthful? An explanation is in order. We will reuse the illustration used in
    the discussion on the *O(n²)* complexity:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们之前做出的陈述：“大O符号表示算法复杂性的上界或最坏情况”。听起来很复杂？需要解释一下。我们将重用之前讨论*O(n²)*复杂度时使用的插图：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We already saw that a single `x.append(i)` operation is *O(1)*, the inner loop
    is *O(N)*, and the full nested `for` loop has the time complexity of *O(n²)*.
    Then why do we say that the complexity of the algorithm as a whole is *O(n²)*?
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，单个`x.append(i)`操作是*O(1)*，内部循环是*O(N)*，完整的嵌套`for`循环的时间复杂度是*O(n²)*。那么，为什么我们说整个算法的复杂度是*O(n²)*呢？
- en: If you look at the earlier chart that compared various complexities, *O(n²)*
    is the costliest among these three complexities and thus the most significant
    part of it. In other words, the algorithm complexity cannot get worse than *O(n²)*.
    Now, read the earlier statement on upper bounds one more time. The big O notation
    represents the worst-case scenario of the complexity of the algorithm. This is
    the reason why the big O complexity class for this algorithm is represented as
    *O(n²)*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看看之前比较各种复杂度的图表，*O(n²)*在这三种复杂度中成本最高，因此也是最重要的部分。换句话说，算法的复杂度不能比*O(n²)*更差。现在，再读一遍之前关于上界的陈述。大O符号代表算法复杂性的最坏情况。这就是为什么这个算法的大O复杂度类被表示为*O(n²)*。
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Average-case time complexity:**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均情况时间复杂度：**'
- en: Most of the time, an algorithm is analyzed by measuring its worst-case complexity.
    However, there are some problems where it makes practical sense to measure the
    **average-case time complexity**. Here, the amount of time taken to run the algorithm
    is averaged over all possible inputs. The quicksort algorithm we saw earlier is
    a classic example where average-case complexity is useful. It determines the real
    (or practical) efficiency of the algorithm. The average-case time complexity of
    this algorithm is *O(n log n),* whereas the worst-case complexity is *O(n²)*.
    For more information, check out [https://en.wikipedia.org/wiki/Average-case_complexity](https://en.wikipedia.org/wiki/Average-case_complexity).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，算法是通过测量其最坏情况复杂度来分析的。然而，有些问题测量平均情况时间复杂度是有实际意义的。在这里，运行算法所需的时间是所有可能输入的平均值。我们之前看到的快速排序算法就是一个平均情况复杂度有用的经典例子。它决定了算法的真实（或实际）效率。这个算法的平均情况时间复杂度是*O(n
    log n)*，而最坏情况复杂度是*O(n²)*。更多信息，请参阅[https://en.wikipedia.org/wiki/Average-case_complexity](https://en.wikipedia.org/wiki/Average-case_complexity)。
- en: Complexity for common data structures and algorithms
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见数据结构和算法的复杂度
- en: The following table summarizes the time complexity of a few frequently performed
    operations on some Python data structures. This is not an exhaustive list, for
    that, see the Python wiki ([https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)).
    It documents the time complexity of several other operations on these data structures.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了在Python数据结构上执行的一些常见操作的复杂度。这不是一个详尽的列表，更多内容请参阅Python维基百科（[https://wiki.python.org/moin/TimeComplexity](https://wiki.python.org/moin/TimeComplexity)）。它记录了这些数据结构上其他几个操作的复杂度。
- en: '![Complexity for common data structures and algorithms](img/B05034_07_23.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![常见数据结构和算法的复杂度](img/B05034_07_23.jpg)'
- en: The following table summarizes the time complexity of some common algorithms
    along with the Python functions that implement them. Note that the functions listed
    are from the NumPy library. Although the next chapter will introduce you to NumPy,
    we won't specifically talk about these functions in this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了某些常见算法的复杂度以及实现它们的Python函数。请注意，列出的函数来自NumPy库。尽管下一章将介绍NumPy，但我们不会在这本书中专门讨论这些函数。
- en: '![Complexity for common data structures and algorithms](img/B05034_07_24.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![常见数据结构和算法的复杂度](img/B05034_07_24.jpg)'
- en: The first algorithm listed in the preceding table is a binary search algorithm.
    This was already illustrated when we talked about the *O(log n)* or logarithmic
    complexity. The `numpy.searchsorted` function uses binary search to find array
    indices where the elements need to be inserted to maintain order. The remaining
    algorithms in this table are a few common sorting algorithms that put elements
    in a list in a specific order. We already talked about quicksort. To learn more
    about the other algorithms, refer to [https://en.wikipedia.org/wiki/Sorting_algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面表格中列出的第一个算法是二分查找算法。当我们讨论*O(log n)*或对数复杂度时，这已经被说明了。`numpy.searchsorted`函数使用二分查找来找到需要插入以保持顺序的数组索引。表中剩余的算法是一些常见的排序算法，它们将元素按特定顺序放入列表中。我们已经讨论了快速排序。要了解更多关于其他算法的信息，请参阅[https://en.wikipedia.org/wiki/Sorting_algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm)。
- en: Wrapping up the big O discussion
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束大O讨论
- en: 'Let''s summarize what you learned about the big O notation so far:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下到目前为止你学到的关于大O符号的知识：
- en: Big O enables us to compare different algorithms in terms of their time (or
    space) complexity. This helps us choose the right algorithm (if possible) or determine
    the strategy to implement changes that speed things up.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大O符号使我们能够从时间（或空间）复杂度的角度比较不同的算法。这有助于我们选择正确的算法（如果可能的话）或确定加快速度的实现策略。
- en: It gives us the growth rate of an algorithm, but it will not give us the absolute
    value of the runtime. For example, some algorithm A takes 10 minutes to execute.
    On the same machine, algorithm B takes 200 minutes to execute, and guess what—both
    algorithms have the same complexity, say *O(n)*. Although they have different
    execution times, they have one thing in common, the time taken linearly increases
    with their problem size.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它给我们提供了算法的增长率，但不会给出运行时间的绝对值。例如，某个算法A需要10分钟来执行。在相同的机器上，算法B需要200分钟来执行，猜猜看——这两个算法具有相同的复杂度，比如说*O(n)*。尽管它们的执行时间不同，但它们有一个共同点，即所需时间与问题规模线性增长。
- en: '![Wrapping up the big O discussion](img/B05034_07_18.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![结束大O讨论的图](img/B05034_07_18.jpg)'
- en: '| *Glad you brought that up! The big O notation indicates the worst-case scenario
    of an algorithm, and it rules other (less costly) complexity classes present in
    that algorithm. In other words, the worst-case complexity drives the performance
    of that algorithm.* |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| *很高兴你提到了这一点！大O符号表示算法的最坏情况，它决定了该算法中存在的其他（成本较低）复杂度类。换句话说，最坏情况复杂度决定了该算法的性能。*
    |'
- en: It is good to be aware of the complexity, especially when the problem size is
    large. For a very small problem, it may or may not make a huge difference. A good
    practice is to analyze the existing algorithm for the performance bottlenecks,
    and then see if it is worth revamping the algorithm for speedup. Weigh in the
    factors, such as the time you spend on changing the algorithm and its impact on
    the quality (bugs and testing) versus the long term benefit of the speedup accomplished.
    In a nutshell, choose the strategy that best fits your needs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题规模很大时，了解复杂度是很好的。对于非常小的问题，它可能或可能不会产生巨大差异。一个好的做法是分析现有算法的性能瓶颈，然后看看是否值得为了加速而重写算法。权衡因素，比如你花费在更改算法上的时间和它对质量（错误和测试）的影响，以及加速带来的长期利益。简而言之，选择最适合你需求的策略。
- en: It is also worth noting that sometimes you have to live with an algorithm with
    a certain complexity class. But that is not the end of the road. You can still
    implement techniques to speedup the code without changing its order of complexity.
    The performance improvement obtained will depend on the problem in hand. For example,
    you can parallelize the code or compute some parameters in advance to achieve
    speedup. Later in this book, we will cover basics of parallelization in Python.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有时你必须接受具有特定复杂度类的算法。但这并不是终点。你仍然可以实施技术来加快代码速度，而不改变其复杂度等级。性能提升将取决于具体问题。例如，你可以并行化代码或提前计算一些参数以实现加速。本书后面将介绍Python中并行化的基础知识。
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter was the first one in the series of three chapters based on performance.
    It laid the ground work to improve application performance. We learned how to
    record the runtime using the `time` module. We also saw how the `timeit` module
    can be used to measure the performance of small pieces of code. We took a practical
    problem where an application ran fine when working with a small input, but, as
    the input grew larger, it slowed down considerably. With this example, we learned
    how to identify the bottlenecks using `cProfile` and display the results using
    `pstats`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是该系列三个基于性能的章节中的第一个。它为提高应用程序性能奠定了基础。我们学习了如何使用`time`模块记录运行时间。我们还看到了如何使用`timeit`模块来测量小段代码的性能。我们解决了一个实际问题，即当处理小输入时，应用程序运行良好，但随着输入的增长，速度显著减慢。通过这个例子，我们学习了如何使用`cProfile`来识别瓶颈，并使用`pstats`来显示结果。
- en: We saw how the `line_profiler` module can help locate the time consuming statements
    inside a function. While most of the discussion was focused on the runtime performance,
    we briefly covered the `memory_profiler` module. This module enabled line-by-line
    analysis of memory consumption for the given functions. Finally, we learned about
    the big O notation that represents the computational complexity of an algorithm.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`line_profiler`模块如何帮助定位函数内部耗时语句。虽然大部分讨论都集中在运行时性能上，但我们简要介绍了`memory_profiler`模块。该模块允许对给定函数的内存消耗进行逐行分析。最后，我们学习了表示算法计算复杂度的大O表示法。
- en: Now that we have identified the performance bottlenecks, let's move on to the
    next chapter to improve the application performance.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了性能瓶颈，那么让我们继续到下一章，以提高应用程序的性能。
