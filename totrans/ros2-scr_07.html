<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor211" class="pcalibre calibre4 pcalibre1"/>5</h1>
			<h1 id="_idParaDest-113" class="calibre6"><a id="_idTextAnchor212" class="pcalibre calibre4 pcalibre1"/>Topics – Sending and Receiving Messages between Nodes</h1>
			<p class="calibre3">Now that you can write nodes, how can you make several nodes communicate with each other, and how can you interact with existing nodes in an application?</p>
			<p class="calibre3">There are three kinds of communication in ROS 2: topics, services, and actions. In this chapter, we will dive into ROS 2 topics.</p>
			<p class="calibre3">To understand how topics work, we will start with a real-life analogy. This will allow you to grasp the concept using existing and common knowledge. Then, you will dive into the code and write a publisher and a subscriber inside a node—first with existing interfaces, and then by building custom interfaces. You will also use ROS 2 tools such as the <strong class="source-inline1">ros2</strong> command line and <strong class="source-inline1">rqt_graph</strong> to introspect topics and unlock more functionalities.</p>
			<p class="calibre3">By the end of this chapter, you will be able to make your nodes communicate with each other using ROS 2 topics. You will learn by writing code and will be provided with an additional challenge at the end of this chapter.</p>
			<p class="calibre3">Topics are used everywhere in ROS 2. Whether you wish to create an application from scratch or use existing ROS plugins, you will have to use topics.</p>
			<p class="calibre3">We will use the code inside the <strong class="source-inline1">ch4</strong> folder in this book’s GitHub repository (<a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>) as a starting point. You can find the final code in the <strong class="source-inline1">ch5</strong> folder.</p>
			<p class="calibre3">In this chapter, we will cover the following topics:</p>
			<ul class="calibre9">
				<li class="calibre10">What is a ROS 2 topic?</li>
				<li class="calibre10">Writing a topic publisher</li>
				<li class="calibre10">Writing a topic subscriber</li>
				<li class="calibre10">Additional tools to handle topics</li>
				<li class="calibre10">Creating a custom interface for a topic</li>
				<li class="calibre10">Topic challenge – closed-loop control</li>
			</ul>
			<h1 id="_idParaDest-114" class="calibre6"><a id="_idTextAnchor213" class="pcalibre calibre4 pcalibre1"/><a id="_idTextAnchor214" class="pcalibre calibre4 pcalibre1"/>What is a ROS 2 topic?</h1>
			<p class="calibre3">You discovered the concept of topics through hands-on experiments in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>. With this, you should have<a id="_idIndexMarker241" class="pcalibre calibre4 pcalibre1"/> a basic intuition of how things work.</p>
			<p class="calibre3">I am now going to start from scratch again and explain topics—not by running code, but by using a real-life analogy that makes it easier to understand. We will build an example, step by step, and then recap the most important points.<a id="_idTextAnchor215" class="pcalibre calibre4 pcalibre1"/></p>
			<h2 id="_idParaDest-115" class="calibre6"><a id="_idTextAnchor216" class="pcalibre calibre4 pcalibre1"/>A publisher and a subscriber</h2>
			<p class="calibre3">For this analogy, I will use radio<a id="_idIndexMarker242" class="pcalibre calibre4 pcalibre1"/> transmitters and receivers. As this is a simplified example, not everything I’ll say about radio will be correct, but the point here is to understand ROS 2 topics.</p>
			<p class="calibre3">Let’s start with one radio transmitter. This radio transmitter will send some data at a given frequency. To make it easier for people to remember, this frequency is usually represented by a number, such as <em class="italic">98.7</em>. We can even think of <em class="italic">98.7</em> as a name. If you want to listen to the radio, you know you have to connect your device to <em class="italic">98.7</em>.</p>
			<p class="calibre3">In this case, we can <a id="_idIndexMarker243" class="pcalibre calibre4 pcalibre1"/>say that <em class="italic">98.7</em> is a topic. The radio transmitter is a <strong class="bold">publisher</strong> on this topic:</p>
			<div><div><img alt="Figure 5.1 – Radio transmitter publishing to the 98.7 topic" src="img/B22403_05_1.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Radio transmitter publishing to the 98.7 topic</p>
			<p class="calibre3">Now, let’s say you want to listen to that radio from your phone. You will ask your phone to connect to <em class="italic">98.7</em> to receive the data.</p>
			<p class="calibre3">With this analogy, the phone <a id="_idIndexMarker244" class="pcalibre calibre4 pcalibre1"/>is then a <strong class="bold">subscriber</strong> to the <em class="italic">98.7</em> topic.</p>
			<p class="calibre3">One important thing to note here is that both the radio transmitter and the phone must use the same type of frequency. For example, if the radio transmitter is using an AM signal, and if the phone is trying to decode an FM signal, it will not work.</p>
			<p class="calibre3">Similarly, with ROS 2 topics, both <a id="_idIndexMarker245" class="pcalibre calibre4 pcalibre1"/>the publisher and subscriber must use the same data type. This data type is called an <strong class="bold">interface</strong>.</p>
			<p class="calibre3">This is what defines <a id="_idIndexMarker246" class="pcalibre calibre4 pcalibre1"/>a topic: a <strong class="bold">name</strong> and <a id="_idIndexMarker247" class="pcalibre calibre4 pcalibre1"/>an interface:</p>
			<div><div><img alt="Figure 5.2 – Publisher and subscriber using the same interface" src="img/B22403_05_2.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Publisher and subscriber using the same interface</p>
			<p class="calibre3">With that, the communication is complete. The radio transmitter publishes an AM signal on the <em class="italic">98.7</em> topic. The phone subscribes to the <em class="italic">98.7</em> topic, decoding an AM sig<a id="_idTextAnchor217" class="pcalibre calibre4 pcalibre1"/>nal.</p>
			<h2 id="_idParaDest-116" class="calibre6"><a id="_idTextAnchor218" class="pcalibre calibre4 pcalibre1"/>Multiple publishers and subscribers</h2>
			<p class="calibre3">In real life, there won,t be just one device trying to listen to the radio. Let’s add a few more devices, each one subscribing to the <em class="italic">98.7</em> topic and decoding an AM signal:</p>
			<div><div><img alt="Figure 5.3 – Topic with multiple subscribers" src="img/B22403_05_3.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Topic with multiple subscribers</p>
			<p class="calibre3">As you can see, one topic can have several subscribers. Each subscriber will get the same data. On the other hand, we could also have several publishers for one topic.</p>
			<p class="calibre3">Imagine that there is<a id="_idIndexMarker248" class="pcalibre calibre4 pcalibre1"/> another radio transmitter, also publishing an AM signal to <em class="italic">98.7</em>. In this case, both the data from the first transmitter and the second transmitter are received by all listening devices:</p>
			<div><div><img alt="Figure 5.4 – Multiple publishers and subscribers" src="img/B22403_05_4.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Multiple publishers and subscribers</p>
			<p class="calibre3">The preceding figure shows boxes. Each box represents a node. Thus, we have two radio transmitter nodes, both containing a publisher to the <em class="italic">98.7</em> topic. We also have three nodes (phone, radio receiver, and car), each one containing a subscriber to <em class="italic">98.7</em>.</p>
			<p class="calibre3">Note that one subscriber is not aware of the other subscribers. When you listen to the radio on your phone, you have no idea who else is listening to the radio, and on what device.</p>
			<p class="calibre3">Also, the phone, the <a id="_idIndexMarker249" class="pcalibre calibre4 pcalibre1"/>radio receiver and the car are not aware of who is publishing on the radio. They only know they have to subscribe to <em class="italic">98.7</em>; they don’t know what’s behind it.</p>
			<p class="calibre3">On the other side, both radio transmitters are not aware of each other and of who is receiving the data. They just publish on the topic, regardless of who is listening. Thus, we say that topics are <strong class="bold">anonymous</strong>. Publishers and subscribers are not aware of other publishers and subscribers. They only publish or subscribe to a topic, using its name and interface.</p>
			<p class="calibre3">Any combination of publishers and subscribers is possible. For example, you could have two publishers on the topic and zero subscribers. In this case, the data is still correctly published, but no one receives it. Alternatively, you could have zero publishers and one or more subscribers. The subscribers will listen to the topic but will receive not<a id="_idTextAnchor219" class="pcalibre calibre4 pcalibre1"/>hing.</p>
			<h2 id="_idParaDest-117" class="calibre6"><a id="_idTextAnchor220" class="pcalibre calibre4 pcalibre1"/>Multiple publishers and subscribers inside one node</h2>
			<p class="calibre3">A node is not limited to <a id="_idIndexMarker250" class="pcalibre calibre4 pcalibre1"/>having just one publisher or one subscriber.</p>
			<p class="calibre3">Let’s add another radio to our example. We will name it <em class="italic">101.3</em>, and its data type is FM signal.</p>
			<p class="calibre3">The second radio transmitter is now publishing both on the <em class="italic">98.7</em> topic and the <em class="italic">101.3</em> topic, sending the appropriate type of data for each topic. Let’s also make the car listen to the <em class="italic">101.3</em> topic:</p>
			<div><div><img alt="Figure 5.5 – A node with two publishers" src="img/B22403_05_5.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.5 – A node with two publishers</p>
			<p class="calibre3">As you can see, the second radio transmitter can publish on several topics, so long as it uses the correct name and interface for each topic.</p>
			<p class="calibre3">Now, imagine that the car, while listening to the radio, is also sending its GPS coordinates to a remote<a id="_idIndexMarker251" class="pcalibre calibre4 pcalibre1"/> server. We could create a topic named <strong class="source-inline1">car_location</strong>, and the interface would contain a latitude and a longitude. The car node now contains one subscriber to the <em class="italic">98.7</em> topic, and one publisher to the <strong class="source-inline1">car_location</strong> topic:</p>
			<div><div><img alt="Figure 5.6 – A node with both a publisher and a subscriber" src="img/B22403_05_6.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.6 – A node with both a publisher and a subscriber</p>
			<p class="calibre3">In the preceding figure, I have also added another node for the server, represented by a computer. The server node will subscribe to the <strong class="source-inline1">car_location</strong> topic so that it can receive the GPS coordinates. Of course, both the publisher and subscriber are using the same interface (latitude and longitude).</p>
			<p class="calibre3">Thus, inside one node, you <a id="_idIndexMarker252" class="pcalibre calibre4 pcalibre1"/>can have any number of publishers and subscribers to different topics with different data types. A node can communicate with several nodes at the same<a id="_idTextAnchor221" class="pcalibre calibre4 pcalibre1"/> time.</p>
			<h2 id="_idParaDest-118" class="calibre6"><a id="_idTextAnchor222" class="pcalibre calibre4 pcalibre1"/>Wrapping things up</h2>
			<p class="calibre3">ROS 2 nodes can send messages to other nodes using topics.</p>
			<p class="calibre3">Topics are mostly used to send data streams. For example, you could create a hardware driver for a camera sensor, and publish images taken from the camera. Other nodes can then subscribe to the topic <a id="_idIndexMarker253" class="pcalibre calibre4 pcalibre1"/>and receive the images. You could also publish a stream of commands for a robot to move, and so on.</p>
			<p class="calibre3">There are many possibilities for when to use topics, and you will get to know more about them as you progress throughout this book.</p>
			<p class="calibre3">Here are some important points <a id="_idIndexMarker254" class="pcalibre calibre4 pcalibre1"/>about how topics work:</p>
			<ul class="calibre9">
				<li class="calibre10">A topic is defined by a name and an interface.</li>
				<li class="calibre10">A topic name must start with a letter and can be followed by other letters, numbers, underscores, tildes, and slashes. For the real-life analogy with radio, I used numbers with dots as topic names. Although it made the examples easier, this is not valid for ROS 2 topics. To make it valid, instead of <em class="italic">98.7</em>, we would have to create a topic named <code>radio_98_7</code>.</li>
				<li class="calibre10">Any publisher or subscriber to a topic must use the same interface.</li>
				<li class="calibre10">Publishers and subscribers are anonymous. They are not aware of each other; they just know they are publishing or subscribing to a topic.</li>
				<li class="calibre10">A node can contain several publishers and subscribers to different topics.</li>
			</ul>
			<p class="calibre3">Now, how do you create a publisher or a subscriber?</p>
			<p class="calibre3">You will do this by adding some code to your nodes. As you saw previously, you can write a Python node using <strong class="source-inline1">rclpy</strong> and a C++ node using <strong class="source-inline1">rclcpp</strong>. With those two libraries, you can create publishers and subscribers directly in you<a id="_idTextAnchor223" class="pcalibre calibre4 pcalibre1"/>r nodes.</p>
			<h1 id="_idParaDest-119" class="calibre6"><a id="_idTextAnchor224" class="pcalibre calibre4 pcalibre1"/>Writing a topic publisher</h1>
			<p class="calibre3">In this section, you’ll write your first ROS 2 publisher. To work on the core concepts, we will create a new ROS 2 application and build upon it in the following chapters. This application will be super <a id="_idIndexMarker255" class="pcalibre calibre4 pcalibre1"/>minimalistic so that we can focus on the concept we want to learn, nothing else.</p>
			<p class="calibre3">What we want to do for now is publish a number on a topic. This topic is new and we will <em class="italic">create</em> it. You don’t really create a topic—you create a publisher or a subscriber to that topic. This will automatically create the topic name, which will be registered on the graph.</p>
			<p class="calibre3">To write a publisher, we need a node. We could use the first node we created in the previous chapter, but the purpose of the node is not the same. Hence, we will create a new node named <strong class="source-inline1">number_publisher</strong>. In this node, we will create a publisher. As to the topic we want to publish to, we will have to choose a name and an interface.</p>
			<p class="calibre3">Now, let’s get started wit<a id="_idTextAnchor225" class="pcalibre calibre4 pcalibre1"/>h Python.</p>
			<h2 id="_idParaDest-120" class="calibre6"><a id="_idTextAnchor226" class="pcalibre calibre4 pcalibre1"/>Writing a Python publisher</h2>
			<p class="calibre3">To write a publisher, we<a id="_idIndexMarker256" class="pcalibre calibre4 pcalibre1"/> need to create a node; to create a node, we need a package. To <a id="_idIndexMarker257" class="pcalibre calibre4 pcalibre1"/>make things simple, let’s continue using the <strong class="source-inline1">my_py_p<a id="_idTextAnchor227" class="pcalibre calibre4 pcalibre1"/>kg</strong> package.</p>
			<h3 class="calibre8">Creating a node</h3>
			<p class="calibre3">Navigate inside the <strong class="source-inline1">my_py_pkg</strong> package, create<a id="_idIndexMarker258" class="pcalibre calibre4 pcalibre1"/> a Python file, and make it executable:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_py_pkg/my_py_pkg/
$ touch number_publisher.py
$ chmod +x number_publisher.py</pre>			<p class="calibre3">Now, open this file, use the node OOP template (given in <a href="B22403_04.xhtml#_idTextAnchor157" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 4</em></a>), and modify the required fields to give names that make sense:</p>
			<pre class="source-code">
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
class NumberPublisherNode(Node):
    def __init__(self):
        super().__init__("number_publisher")
def main(args=None):
    rclpy.init(args=args)
    node = NumberPublisherNode()
    rclpy.spin(node)
    rclpy.shutdown()
if __name__ == "__main__":
    main()</pre>			<p class="calibre3">Now that you have a <strong class="source-inline1">main()</strong> function and a <strong class="source-inline1">NumberPublisherNode</strong> class for your node, we can create <a id="_idTextAnchor228" class="pcalibre calibre4 pcalibre1"/><a id="_idIndexMarker259" class="pcalibre calibre4 pcalibre1"/>a publisher.</p>
			<h3 class="calibre8">Adding a publisher to the node</h3>
			<p class="calibre3">Where can we create a<a id="_idIndexMarker260" class="pcalibre calibre4 pcalibre1"/> publisher in this node? We will do that in the constructor.</p>
			<p class="calibre3">And before we write the code, we need to ask ourselves a question: what is the name and the interface for this topic?</p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Case 1</strong>: You’re publishing to a topic that already exists (other publishers or subscribers on that topic), and then you use the same name and interface</li>
				<li class="calibre10"><strong class="bold">Case 2</strong>: You create a publisher for a new topic (what we are doing now), and then you have to choose a name and interface</li>
			</ul>
			<p class="calibre3">For the name, let’s keep it simple and use <strong class="source-inline1">number</strong>. If we publish a number, we can expect to receive this number on a <strong class="source-inline1">number</strong> topic. If you were to publish a temperature, you could name the topic <strong class="source-inline1">temperature</strong>.</p>
			<p class="calibre3">For the interface, you<a id="_idIndexMarker261" class="pcalibre calibre4 pcalibre1"/> have two choices: use an existing interface or create a custom one. To get started, we will use an existing interface. To make this easier, I will just tell you what to use; you’ll learn how to find other interfaces yourself later.</p>
			<p class="calibre3">Let’s use <strong class="source-inline1">example_interfaces/msg/Int64</strong>. To get more details about what’s in the interface, we can run <strong class="source-inline1">ros2 interface show &lt;interface_name&gt;</strong> in the Terminal:</p>
			<pre class="console">
$ ros2 interface show example_interfaces/msg/Int64
# Some comments
int64 data</pre>			<p class="calibre3">Great—this is exactly what we need: an <strong class="source-inline1">int64</strong> number.</p>
			<p class="calibre3">Now that we have this information, let’s create the publisher. First, import the interface, and then create the publisher in the constructor:</p>
			<pre class="source-code">
import rclpy
from rclpy.node import Node
<strong class="bold1">from example_interfaces.msg import Int64</strong>
class NumberPublisherNode(Node):
    def __init__(self):
        super().__init__("number_publisher")
        <strong class="bold1">self.number_publisher_ = self.create_publisher(Int64, "number", 10)</strong></pre>			<p class="calibre3">To import the interface, we must specify the name of the package (<strong class="source-inline1">example_interfaces</strong>), then the folder name for topic messages (<strong class="source-inline1">msg</strong>), and finally the class for the interface (<strong class="source-inline1">Int64</strong>).</p>
			<p class="calibre3">To create the publisher, we must use the <strong class="source-inline1">create_publisher()</strong> method from the <strong class="source-inline1">Node</strong> class. Inheriting from this class gives us access to all ROS 2 functionalities. In this method, you have to provide three arguments:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>Int64</code> from the <code>example_interfaces</code> package.</li>
				<li class="calibre10"><code>number</code>.</li>
				<li class="calibre10"><code>10</code> every time.</li>
			</ul>
			<p class="calibre3">With this, we<a id="_idIndexMarker262" class="pcalibre calibre4 pcalibre1"/> now have a publisher on the <strong class="source-inline1">number</strong> topic. However, if you just run your code like this, nothing will happen. A publisher won’t publish automatically on a topic. You have to write the code for<a id="_idTextAnchor229" class="pcalibre calibre4 pcalibre1"/> that to happen.</p>
			<h3 class="calibre8">Publishing with a timer</h3>
			<p class="calibre3">A common<a id="_idIndexMarker263" class="pcalibre calibre4 pcalibre1"/> behavior in robotics is to do <em class="italic">X</em> action every <em class="italic">Y</em> seconds—for example, publish an image from a camera every <strong class="source-inline1">0.5</strong> seconds, or in this case, publish a number on a topic every <strong class="source-inline1">1.0</strong> second. As seen in <a href="B22403_04.xhtml#_idTextAnchor157" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 4</em></a>, to do this, you must implement a timer and a callback function.</p>
			<p class="calibre3">Modify the code inside the node so that you publish on the topic from a timer callback:</p>
			<pre class="source-code">
def __init__(self):
    super().__init__("number_publisher")
    self.number_ = 2
    self.number_publisher_ = self.create_publisher(Int64, "number", 10)
    self.number_timer_ = self.create_timer(1.0, self.publish_number)
    self.get_logger().info("Number publisher has been started.")
def publish_number(self):
    msg = Int64()
    msg.data = self.number_
    self.number_publisher_.publish(msg)</pre>			<p class="calibre3">After creating the publisher with <strong class="source-inline1">self.create_publisher()</strong>, we create a timer with <strong class="source-inline1">self.create_timer()</strong>. Here, we say that we want the <strong class="source-inline1">publish_number()</strong> method to <a id="_idIndexMarker264" class="pcalibre calibre4 pcalibre1"/>be called every <strong class="source-inline1">1.0</strong> second. This will happen when the node is spinning.</p>
			<p class="calibre3">On top of that, I also added a log at the end of the constructor to say that the node has been started. I usually do this as a best practice so that I can see when the node is fully initialized on the Terminal.</p>
			<p class="calibre3">In the <strong class="source-inline1">publish_number()</strong> method, we publish on the topic:</p>
			<ol class="calibre11">
				<li class="calibre10">We create an object from the <code>Int64</code> class. This is the interface—in other words, the message to send.</li>
				<li class="calibre10">This object contains a <code>data</code> field. How do we know this? We found this previously when we ran <code>ros2 interface show example_interfaces/msg/Int64</code>. Thus, we provide a number in the <code>data</code> field of the message. For simplicity, we specify the same number every time we run the callback function.</li>
				<li class="calibre10">We publish the message using the <code>publish()</code> method from the publisher.</li>
			</ol>
			<p class="calibre3">This code structure is super common in ROS 2. Any time you want to publish data from a sensor, you will write <a id="_idTextAnchor230" class="pcalibre calibre4 pcalibre1"/>something similar.</p>
			<h3 class="calibre8">Building the publisher</h3>
			<p class="calibre3">To try your code, you <a id="_idIndexMarker265" class="pcalibre calibre4 pcalibre1"/>need to install the node.</p>
			<p class="calibre3">Before we do this, since we’re using a new dependency (<strong class="source-inline1">example_interfaces</strong> package), we also need to<a id="_idIndexMarker266" class="pcalibre calibre4 pcalibre1"/> add one line to the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">my_py_pkg</strong> package:</p>
			<pre class="source-code">
&lt;depend&gt;rclpy&lt;/depend&gt;
<strong class="bold1">&lt;depend&gt;example_interfaces&lt;/depend&gt;</strong></pre>			<p class="calibre3">As you add more functionalities inside your package, you will add any other ROS 2 dependency here.</p>
			<p class="calibre3">To install the node, open the <strong class="source-inline1">setup.py</strong> file from the <strong class="source-inline1">my_py_pkg</strong> package and add a new line to create another executable:</p>
			<pre class="source-code">
entry_points={
    'console_scripts': [
        "test_node = my_py_pkg.my_first_node:main"<strong class="bold1">,</strong>
        <strong class="bold1">"number_publisher = my_py_pkg.number_publisher:main"</strong>
    ],
},</pre>			<p class="calibre3">Make sure you add a comma between each line; otherwise, you could encounter some strange errors when building the package.</p>
			<p class="calibre3">Here, we’ve created a new executable named <strong class="source-inline1">number_publisher</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This time, as you can see from this example, the node name, filename, and executable name are the same: <code>number_publisher</code>. This is a common thing to do. Just remember that those names represent three different things.</p>
			<p class="calibre3">Now, go to your workspace root directory and build the <strong class="source-inline1">my_py_pkg</strong> package:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build --packages-select my_py_pkg</pre>			<p class="calibre3">You can add <strong class="source-inline1">--symlink-install</strong> if you want to, so that you don’t need to run <strong class="source-inline1">colcon build</strong> every time <a id="_idIndexMarker267" class="pcalibre calibre4 pcalibre1"/>you modify the <strong class="source-inline1">n<a id="_idTextAnchor231" class="pcalibre calibre4 pcalibre1"/>umber_publisher</strong> node.</p>
			<h3 class="calibre8">Running the publisher</h3>
			<p class="calibre3">After the package has been built successfully, source your workspace and start the node:</p>
			<pre class="console">
$ source install/setup.bash # or source ~/.bashrc
$ ros2 run my_py_pkg number_publisher
[INFO] [1711526444.403883187] [number_publisher]: Number publisher has been started.</pre>			<p class="calibre3">The node is running, but<a id="_idIndexMarker268" class="pcalibre calibre4 pcalibre1"/> apart from the initial log, nothing is displayed. That’s normal—we didn’t ask the node to print anything else.</p>
			<p class="calibre3">How do we know that the publisher is working? We could write a subscriber node right away and see if we receive the messages. But before we do that, we can test the publisher directly from the Terminal.</p>
			<p class="calibre3">Open a new Terminal window and list all topics:</p>
			<pre class="console">
$ ros2 topic list
/number
/parameter_events
/rosout</pre>			<p class="calibre3">Here, you can find the <strong class="source-inline1">/</strong><strong class="source-inline1">number</strong> topic.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As you can see, there is an added leading slash in front of the topic name. We only wrote <code>number</code> in the code, not <code>/number</code>. This is because ROS 2 names (nodes, topics, and so on) are organized inside namespaces. Later, we will see that you can add a namespace to put all your topics or nodes inside the <code>/abc</code> namespace, for example. In this case, the topic name would be <code>/abc/number</code>. Here, as no namespace is provided, a leading slash is added to the name, even if we don’t provide it in the code. We could call this the <em class="italic">global</em> namespace.</p>
			<p class="calibre3">With the <strong class="source-inline1">ros2 topic echo &lt;topic_name&gt;</strong> command, you can subscribe to the topic directly from the<a id="_idIndexMarker269" class="pcalibre calibre4 pcalibre1"/> subscriber and see what’s being published. We will learn more about this command later in this chapter:</p>
			<pre class="console">
$ ros2 topic echo /number
data: 2
---
data: 2
---</pre>			<p class="calibre3">As you can see, we get one new message per second, which contains a <strong class="source-inline1">data</strong> field with a value of <strong class="source-inline1">2</strong>. This is exactly what we wanted to do in the code.</p>
			<p class="calibre3">With that, we’ve finished our first Python publishe<a id="_idTextAnchor232" class="pcalibre calibre4 pcalibre1"/>r. Let’s switch to C++.</p>
			<h2 id="_idParaDest-121" class="calibre6"><a id="_idTextAnchor233" class="pcalibre calibre4 pcalibre1"/>Writing a C++ publisher</h2>
			<p class="calibre3">Here, the process is the same as for Python. We will create a new node, and in this node, add a publisher <a id="_idIndexMarker270" class="pcalibre calibre4 pcalibre1"/>and a timer. In the timer callback function, we will create <a id="_idIndexMarker271" class="pcalibre calibre4 pcalibre1"/>a message and publish it.</p>
			<p class="calibre3">I will go a bit more quickly in this section as the explanations are the same. We will just focus on the specificities of the C++ syntax with ROS 2.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For everything related to C++ in this book, make sure you follow the explanations using the GitHub code on the side. I may not provide the full code, only the important snippets that are c<a id="_idTextAnchor234" class="pcalibre calibre4 pcalibre1"/>rucial for comprehension.</p>
			<h3 class="calibre8">Creating a node with a publisher and a timer</h3>
			<p class="calibre3">First, let’s create a new file for our <strong class="source-inline1">number_publisher</strong> node in the <strong class="source-inline1">my_cpp_pkg</strong> package:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_cpp_pkg/src/
$ touch number_publisher.cpp</pre>			<p class="calibre3">Open this file and write<a id="_idIndexMarker272" class="pcalibre calibre4 pcalibre1"/> the code for the node. You can start from the OOP template and add the publisher, timer, and callback function. The complete code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/ROS-2-from-Scratch" class="pcalibre calibre4 pcalibre1">https://github.com/PacktPublishing/ROS-2-from-Scratch</a>.</p>
			<p class="calibre3">I will now comment on a few important lines:</p>
			<pre class="source-code">
#include "rclcpp/rclcpp.hpp"
#include "example_interfaces/msg/int64.hpp"</pre>			<p class="calibre3">To include an interface for a topic, use <strong class="source-inline1">"&lt;package_name&gt;/msg/&lt;message_name&gt;.hpp"</strong>.</p>
			<p class="calibre3">Then, in the constructor, add the following:</p>
			<pre class="source-code">
number_publisher_ = this-&gt;create_publisher&lt;example_interfaces::msg::Int64&gt;("number", 10);</pre>			<p class="calibre3">In C++, we also use the <strong class="source-inline1">create_publisher()</strong> method from the <strong class="source-inline1">Node</strong> class. The syntax is a bit different since templates are used, but you can still find the topic interface, topic name, and queue size (as a reminder, you can set it to <strong class="source-inline1">10</strong> every time).</p>
			<p class="calibre3">The publisher is also declared as a private attribute in the class:</p>
			<pre class="source-code">
rclcpp::Publisher&lt;example_interfaces::msg::Int64&gt;::SharedPtr number_publisher_;</pre>			<p class="calibre3">As you can see, we use the <strong class="source-inline1">rclcpp::Publisher</strong> class, and as for many things in ROS 2, we use a shared pointer. For several common classes, ROS 2 provides<strong class="source-inline1">::SharedPtr</strong>, which would be the same thing as writing <strong class="source-inline1">std::shared_ptr&lt;the publisher&gt;</strong>.</p>
			<p class="calibre3">Let’s go back to the constructor:</p>
			<pre class="source-code">
number_timer_ = this-&gt;create_wall_timer(std::chrono::seconds(1), std::bind(&amp;NumberPublisherNode::publishNumber, this));
RCLCPP_INFO(this-&gt;get_logger(), "Number publisher has been started.");</pre>			<p class="calibre3">After creating the publisher, we<a id="_idIndexMarker273" class="pcalibre calibre4 pcalibre1"/> create a timer to call the <strong class="source-inline1">publishNumber</strong> method every <strong class="source-inline1">1.0</strong> second. Finally, we print a log so that we know that the constructor code has been executed:</p>
			<pre class="source-code">
void publishNumber()
{
    auto msg = example_interfaces::msg::Int64();
    msg.data = number_;
    number_publisher_-&gt;publish(msg);
}</pre>			<p class="calibre3">This is the callback method. As for Python, we create an object from the interface class, after which we fill any field from this interfa<a id="_idTextAnchor235" class="pcalibre calibre4 pcalibre1"/>ce and publish the message.</p>
			<h3 class="calibre8">Building and running the publisher</h3>
			<p class="calibre3">Once you’ve written the <a id="_idIndexMarker274" class="pcalibre calibre4 pcalibre1"/>node with the publisher, timer, and callback function, it’s time to build it.</p>
			<p class="calibre3">As we did for Python, open<a id="_idIndexMarker275" class="pcalibre calibre4 pcalibre1"/> the <strong class="source-inline1">package.xml</strong> file of the <strong class="source-inline1">my_cpp_pkg</strong> package and add one line for the dependency to <strong class="source-inline1">example_interfaces</strong>:</p>
			<pre class="source-code">
&lt;depend&gt;rclcpp&lt;/depend&gt;
<strong class="bold1">&lt;depend&gt;example_interfaces&lt;/depend&gt;</strong></pre>			<p class="calibre3">Then, open the <strong class="source-inline1">CMakeLists.txt</strong> file from the <strong class="source-inline1">my_cpp_pkg</strong> package and add the following lines:</p>
			<pre class="source-code">
find_package(rclcpp REQUIRED)
<strong class="bold1">find_package(example_interfaces REQUIRED)</strong>
add_executable(test_node src/my_first_node.cpp)
ament_target_dependencies(test_node rclcpp)
<strong class="bold1">add_executable(number_publisher src/number_publisher.cpp)</strong>
<strong class="bold1">ament_target_dependencies(number_publisher rclcpp example_interfaces)</strong>
install(TARGETS
  test_node
<strong class="bold1">  number_publisher</strong>
  DESTINATION lib/${PROJECT_NAME}/
)</pre>			<p class="calibre3">For any new dependency, we<a id="_idIndexMarker276" class="pcalibre calibre4 pcalibre1"/> need to add a new <strong class="source-inline1">find_package()</strong> line.</p>
			<p class="calibre3">Then, we create a<a id="_idIndexMarker277" class="pcalibre calibre4 pcalibre1"/> new executable. Note that we also provide <strong class="source-inline1">example_interfaces</strong> in the arguments of <strong class="source-inline1">ament_target_dependencies()</strong>. If you omit this, you will get an error during compilation.</p>
			<p class="calibre3">Finally, there’s no need to re-create the <strong class="source-inline1">install()</strong> block. Just add the executable in a new line, without any commas between the lines.</p>
			<p class="calibre3">Now, you can build, source, and run:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build --packages-select my_cpp_pkg
$ source install/setup.bash
$ ros2 run my_cpp_pkg number_publisher
[INFO] [1711528108.225880935] [number_publisher]: Number publisher has been started.</pre>			<p class="calibre3">The node containing the publisher is up and running. By using <strong class="source-inline1">ros2 topic list</strong> and <strong class="source-inline1">ros2 topic echo &lt;topic_name&gt;</strong>, you can find the topic and see what’s being published.</p>
			<p class="calibre3">Now that you’ve created a publisher and you know it’s working, it’s time to learn how to crea<a id="_idTextAnchor236" class="pcalibre calibre4 pcalibre1"/>te a subscriber for that topic.</p>
			<h1 id="_idParaDest-122" class="calibre6"><a id="_idTextAnchor237" class="pcalibre calibre4 pcalibre1"/>Writing a topic subscriber</h1>
			<p class="calibre3">To continue improving our <a id="_idIndexMarker278" class="pcalibre calibre4 pcalibre1"/>application, let’s create a new node that will subscribe to the <strong class="source-inline1">/number</strong> topic. Each number that’s received will be added to a counter. We want to print the counter every time it’s updated.</p>
			<p class="calibre3">As we did previously, let’s start the full explanations with Python, and then see th<a id="_idTextAnchor238" class="pcalibre calibre4 pcalibre1"/>e syntax specificities with C++.</p>
			<h2 id="_idParaDest-123" class="calibre6"><a id="_idTextAnchor239" class="pcalibre calibre4 pcalibre1"/>Writing a Python subscriber</h2>
			<p class="calibre3">You can find the complete <a id="_idIndexMarker279" class="pcalibre calibre4 pcalibre1"/>code for this Python node on GitHub. Many things we need to do here are identical to what we did previously, so I won’t fully <a id="_idIndexMarker280" class="pcalibre calibre4 pcalibre1"/>detail every step. Instead, we will focus on the most important things so <a id="_idTextAnchor240" class="pcalibre calibre4 pcalibre1"/>that we can write the subscriber.</p>
			<h3 class="calibre8">Creating a Python node with a subscriber</h3>
			<p class="calibre3">Create a new node<a id="_idIndexMarker281" class="pcalibre calibre4 pcalibre1"/> named <strong class="source-inline1">number_counter</strong> inside the <strong class="source-inline1">my_py_pkg</strong> package:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_py_pkg/my_py_pkg/
$ touch number_counter.py
$ chmod +x number_counter.py</pre>			<p class="calibre3">In this file, you can write the code for the node and add a subscriber. Here’s the explanation, step by step:</p>
			<pre class="source-code">
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
<strong class="bold1">from example_interfaces.msg import Int64</strong></pre>			<p class="calibre3">Since we want to create a subscriber to receive what we sent with the publisher, we need to use the same interface. Hence, we import <strong class="source-inline1">Int64</strong> as well. Then, we can create the subscriber:</p>
			<pre class="source-code">
class NumberCounterNode(Node):
    def __init__(self):
        super().__init__("number_counter")
        self.counter_ = 0
        <strong class="bold1">self.number_subscriber_ = self.create_subscription(Int64, "number", self.callback_number, 10)</strong>
       self.get_logger().info("Number Counter has been started.")</pre>			<p class="calibre3">As for publishers, we will create subscribers in the node’s constructor. Here, we use the <strong class="source-inline1">create_subscription()</strong> method<a id="_idIndexMarker282" class="pcalibre calibre4 pcalibre1"/> from the <strong class="source-inline1">Node</strong> class. With this method, you need to provide four arguments:</p>
			<ul class="calibre9">
				<li class="calibre10"><code>Int64</code>. This needs<a id="_idIndexMarker283" class="pcalibre calibre4 pcalibre1"/> to be the same for both the publisher and subscriber.</li>
				<li class="calibre10"><code>number</code>. This is the same name as for the publisher. Note that I don’t provide any additional slash here. This will be added automatically, so the topic name will become <code>/number</code>.</li>
				<li class="calibre10"><code>/number</code> topic, it will be received here, and we will be able to use it and process it inside the callback method (that we need to implement).</li>
				<li class="calibre10"><code>10</code> and forget about it for now.</li>
			</ul>
			<p class="calibre3">Now, let’s see the implementation for the callback method, which I named <strong class="source-inline1">callback_number</strong>:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a best practice, I recommend naming callback methods for topics <code>callback_&lt;topic&gt;</code>. By adding the <code>callback_</code> prefix, you make it clear that this method is a callback and shouldn’t be called directly in the code. This can prevent lots of errors in the future.</p>
			<pre class="source-code">
def callback_number(self, msg: Int64):
    self.counter_ += msg.data
    self.get_logger().info("Counter:  " + str(self.counter_))</pre>			<p class="calibre3">In a subscriber callback, you<a id="_idIndexMarker284" class="pcalibre calibre4 pcalibre1"/> receive the message directly in the parameters of the function. Since we know that <strong class="source-inline1">Int64</strong> contains a <strong class="source-inline1">data</strong> field, we can access it with <strong class="source-inline1">msg.data</strong>.</p>
			<p class="calibre3">Now, we add the received<a id="_idIndexMarker285" class="pcalibre calibre4 pcalibre1"/> number to a <strong class="source-inline1">counter_</strong> attribute and print the counter every time with a ROS 2 log.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a best practice, I have specified the <code>Int64</code> type for the <code>msg</code> argument of the method. This isn’t mandatory for Python code to work, but it adds an extra level of safety (we are sure that we should receive <code>Int64</code> and nothing else) and it can sometimes make your IDE work better with auto-completion.</p>
			<p class="calibre3">To finish the node, don’t forget to add the <strong class="source-inline1">main()</strong> func<a id="_idTextAnchor241" class="pcalibre calibre4 pcalibre1"/>tion after the <strong class="source-inline1">NumberCounterNode</strong> class.</p>
			<h3 class="calibre8">Running the Python subscriber</h3>
			<p class="calibre3">Now, to try the code, add a <a id="_idIndexMarker286" class="pcalibre calibre4 pcalibre1"/>new executable to the <strong class="source-inline1">setup.py</strong> file of your Python package:</p>
			<pre class="source-code">
entry_points={
    'console_scripts': [
        "test_node = my_py_pkg.my_first_node:main",
        "number_publisher = my_py_pkg.number_publisher:main"<strong class="bold1">,</strong>
        <strong class="bold1">"number_counter = my_py_pkg.number_counter:main"</strong>
    ],
},</pre>			<p class="calibre3">Then, build the<a id="_idIndexMarker287" class="pcalibre calibre4 pcalibre1"/> package and source the workspace (from now on, I will not write those commands every<a id="_idIndexMarker288" class="pcalibre calibre4 pcalibre1"/> time since they’re always the same).</p>
			<p class="calibre3">Now, run each node (<strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong>) in a different Terminal:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher
[INFO] [1711529824.816514561] [number_publisher]: Number publisher has been started.
$ ros2 run my_py_pkg number_counter
[INFO] [1711528797.363370081] [number_counter]: Number Counter has been started.
[INFO] [1711528815.739270510] [number_counter]: Counter:  2
[INFO] [1711528816.739186942] [number_counter]: Counter:  4
[INFO] [1711528817.739050485] [number_counter]: Counter:  6
[INFO] [1711528818.738992607] [number_counter]: Counter:  8</pre>			<p class="calibre3">As you can see, the <strong class="source-inline1">number_counter</strong> node adds <strong class="source-inline1">2</strong> to the counter every <strong class="source-inline1">1.0</strong> second. If you see this, then the publish/subscribe communication between your two nodes is working.</p>
			<p class="calibre3">You can start and stop the <strong class="source-inline1">number_publisher</strong> node and see that every time you start it, <strong class="source-inline1">number_counter</strong> contin<a id="_idTextAnchor242" class="pcalibre calibre4 pcalibre1"/>ues to add numbers from the current count.</p>
			<h2 id="_idParaDest-124" class="calibre6"><a id="_idTextAnchor243" class="pcalibre calibre4 pcalibre1"/>Writing a C++ subscriber</h2>
			<p class="calibre3">Let’s create <a id="_idIndexMarker289" class="pcalibre calibre4 pcalibre1"/>the <strong class="source-inline1">number_counter</strong> node in C++. The principle is the sa<a id="_idTextAnchor244" class="pcalibre calibre4 pcalibre1"/>me, so let’s just focus on the syntax <a id="_idIndexMarker290" class="pcalibre calibre4 pcalibre1"/>here.</p>
			<h3 class="calibre8">Creating a C++ node with a subscriber</h3>
			<p class="calibre3">Create a new file for<a id="_idIndexMarker291" class="pcalibre calibre4 pcalibre1"/> your node:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_cpp_pkg/src/
$ touch number_counter.cpp</pre>			<p class="calibre3">Open this file and write the code for the node (once again, the complete code is on GitHub).</p>
			<p class="calibre3">To create a subscriber in your node, run the following code:</p>
			<pre class="source-code">
number_subscriber_ = this-&gt;create_subscription&lt;example_interfaces::msg::Int64&gt;(
           "number",
           10,
           std::bind(&amp;NumberCounterNode::callbackNumber, this, _1));</pre>			<p class="calibre3">We find the same components as for Python (but in a different order): topic interface, topic name, queue size, and callback for received messages. For <strong class="source-inline1">_1</strong> to work, don’t forget to add <strong class="source-inline1">using namespace std::placeholders;</strong> before it.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Even if the <code>rclpy</code> and <code>rclcpp</code> libraries are supposed to be based on the same underlying code, there can still be some differences in the API. Don’t worry if the code sometimes doesn’t look the same between Python and C++.</p>
			<p class="calibre3">The subscriber object is declared as a private attribute:</p>
			<pre class="source-code">
rclcpp::Subscription&lt;example_interfaces::msg::Int64&gt;::SharedPtr number_subscriber_;</pre>			<p class="calibre3">We use the <strong class="source-inline1">rclcpp::Subscription</strong> class here, and once again, we create a shared pointer to that object.</p>
			<p class="calibre3">We then have the callback method, <strong class="source-inline1">callbackNumber</strong>:</p>
			<pre class="source-code">
void callbackNumber(const example_interfaces::msg::Int64::SharedPtr msg)
{
    counter_ += msg-&gt;data;
    RCLCPP_INFO(this-&gt;get_logger(), "Counter: %d", counter_);
}</pre>			<p class="calibre3">The message we receive in the callback is also a (<strong class="source-inline1">const</strong>) shared pointer. Hence, don’t forget to use <strong class="source-inline1">-&gt;</strong> when<a id="_idIndexMarker292" class="pcalibre calibre4 pcalibre1"/> accessing the <strong class="source-inline1">data</strong> field.</p>
			<p class="calibre3">In this callback, we add th<a id="_idTextAnchor245" class="pcalibre calibre4 pcalibre1"/>e<a id="_idIndexMarker293" class="pcalibre calibre4 pcalibre1"/> received number to the counter and print it.</p>
			<h3 class="calibre8">Running the C++ subscriber</h3>
			<p class="calibre3">Create a new<a id="_idIndexMarker294" class="pcalibre calibre4 pcalibre1"/> executable for that node. Open <strong class="source-inline1">CMakeLists.txt</strong> and add the<a id="_idIndexMarker295" class="pcalibre calibre4 pcalibre1"/> following code:</p>
			<pre class="source-code">
<strong class="bold1">add_executable(number_counter src/number_counter.cpp)</strong>
<strong class="bold1">ament_target_dependencies(number_counter rclcpp example_interfaces)</strong>
install(TARGETS
  test_node
  number_publisher
<strong class="bold1">  number_counter</strong>
  DESTINATION lib/${PROJECT_NAME}/
)</pre>			<p class="calibre3">Then, build <strong class="source-inline1">my_cpp_pkg</strong>, source the<a id="_idIndexMarker296" class="pcalibre calibre4 pcalibre1"/> workspace, and run both the publisher and the subscriber node in different Terminals. You shoul<a id="_idTextAnchor246" class="pcalibre calibre4 pcalibre1"/><a id="_idTextAnchor247" class="pcalibre calibre4 pcalibre1"/>d see a similar output<a id="_idIndexMarker297" class="pcalibre calibre4 pcalibre1"/> to what we had wi<a id="_idTextAnchor248" class="pcalibre calibre4 pcalibre1"/>th Python.</p>
			<h2 id="_idParaDest-125" class="calibre6"><a id="_idTextAnchor249" class="pcalibre calibre4 pcalibre1"/>Running the Python and C++ nodes together</h2>
			<p class="calibre3">We’ve just created a<a id="_idIndexMarker298" class="pcalibre calibre4 pcalibre1"/> publisher and subscriber for both Python and C++. The topic we use has the same name (<strong class="source-inline1">number</strong>) and interface (<strong class="source-inline1">example_interfaces/msg/Int64</strong>).</p>
			<p class="calibre3">If the topic is the same, it means that you could start the Python <strong class="source-inline1">number_publisher</strong> node with the C++ <strong class="source-inline1">number_counter</strong> node, for example.</p>
			<p class="calibre3">Let’s verify that:</p>
			<pre class="console">
$ ros2 run <strong class="bold1">my_py_pkg</strong> number_publisher
[INFO] [1711597703.615546913] [number_publisher]: Number publisher has been started.
$ ros2 run <strong class="bold1">my_cpp_pkg</strong> number_counter
[INFO] [1711597740.879160448] [number_counter]: Number Counter has been started.
[INFO] [1711597741.607444197] [number_counter]: Counter: 2
[INFO] [1711597742.607408224] [number_counter]: Counter: 4</pre>			<p class="calibre3">You can also try the opposite by running the C++ <strong class="source-inline1">number_publisher</strong> node with the Python <strong class="source-inline1">number_counter</strong> node.</p>
			<p class="calibre3">Why is it working? Simply because ROS 2 is language-agnostic. You could have any node written in any (supported) programming language, and this node could communicate with all the other nodes in the network, using topics and other ROS 2 communications.</p>
			<p class="calibre3">ROS 2 communications happen at a<a id="_idIndexMarker299" class="pcalibre calibre4 pcalibre1"/> lower level, using <strong class="bold">Data Distribution Service</strong> (<strong class="bold">DDS</strong>). This is the middleware part and is responsible for sending and receiving messages between nodes. When you write a Python or C++ node, you are using the same DDS functionality, with an API implemented in either <strong class="source-inline1">rclpy</strong> or <strong class="source-inline1">rclcpp</strong>.</p>
			<p class="calibre3">I will not go too far with this explanation as it’s quite advanced and not really in the scope of this book. If there is just one thing to remember from this, it’s that Python and C++ nodes can communicate with each other using ROS 2 communication features. You can create some <a id="_idIndexMarker300" class="pcalibre calibre4 pcalibre1"/>nodes in Python and other nodes in C++; just make<a id="_idIndexMarker301" class="pcalibre calibre4 pcalibre1"/> sure to use t<a id="_idTextAnchor250" class="pcalibre calibre4 pcalibre1"/>he same communication name and interface on both sides.</p>
			<h1 id="_idParaDest-126" class="calibre6"><a id="_idTextAnchor251" class="pcalibre calibre4 pcalibre1"/>Additional tools to handle topics</h1>
			<p class="calibre3">You’ve just written a bunch <a id="_idIndexMarker302" class="pcalibre calibre4 pcalibre1"/>of nodes containing publishers and subscribers. We will now explore how ROS 2 tools can help you do more things with topics.</p>
			<p class="calibre3">We will explore the following topics:</p>
			<ul class="calibre9">
				<li class="calibre10">Introspection with <code>rqt_graph</code></li>
				<li class="calibre10">Introspection and debugging with the <code>ros2 topic</code> command line</li>
				<li class="calibre10">Changing a topic <a id="_idTextAnchor252" class="pcalibre calibre4 pcalibre1"/>name when starting a node</li>
				<li class="calibre10">Replaying topic data with bags</li>
			</ul>
			<h2 id="_idParaDest-127" class="calibre6"><a id="_idTextAnchor253" class="pcalibre calibre4 pcalibre1"/>Introspecting topics with rqt_graph</h2>
			<p class="calibre3">We used <strong class="source-inline1">rqt_graph</strong> to visualize <a id="_idIndexMarker303" class="pcalibre calibre4 pcalibre1"/>nodes in <a href="B22403_03.xhtml#_idTextAnchor092" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 3</em></a>. Let’s run it again<a id="_idIndexMarker304" class="pcalibre calibre4 pcalibre1"/> and see how to introspect the publisher and subscriber we have just created.</p>
			<p class="calibre3">First, start both the <strong class="source-inline1">number_publisher</strong> and <strong class="source-inline1">number_counter</strong> nodes (from any package: <strong class="source-inline1">my_py_pkg</strong> or <strong class="source-inline1">my_cpp_pkg</strong>).</p>
			<p class="calibre3">Then, start <strong class="source-inline1">rqt_graph</strong> in another Terminal:</p>
			<pre class="console">
$ rqt_graph</pre>			<p class="calibre3">If needed, refresh the view a few times and select <strong class="bold">Nodes/Topics (all)</strong>. You can also uncheck the <strong class="bold">Dead sinks</strong> box and the <strong class="bold">Leaf topics</strong> box. This will allow you to see topics even if there is just one subscriber and no publisher, or one publisher and no subscriber:</p>
			<div><div><img alt="Figure 5.7 – The number topic on rqt_graph" src="img/B22403_05_7.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The number topic on rqt_graph</p>
			<p class="calibre3">There, we can see the <strong class="source-inline1">number_publisher</strong> node and the <strong class="source-inline1">number_counter</strong> node. In the middle, we have the <strong class="source-inline1">/number</strong> topic, and we can see which node is a publisher or a subscriber.</p>
			<p class="calibre3">The <strong class="source-inline1">rqt_graph</strong> package <a id="_idIndexMarker305" class="pcalibre calibre4 pcalibre1"/>can be extremely useful when debugging topics. Imagine that you run some nodes and you’re wondering why topic messages<a id="_idIndexMarker306" class="pcalibre calibre4 pcalibre1"/> are not received by a subscriber. Maybe those nodes are not using the same topic name. You can easily see this with <strong class="source-inline1">rqt_graph</strong>:</p>
			<div><div><img alt="Figure 5.8 – Topic name mismatch between publisher and subscriber" src="img/B22403_05_8.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Topic name mismatch between publisher and subscriber</p>
			<p class="calibre3">In this example, I made an intentional error in the topic name inside the publisher. Instead of <strong class="source-inline1">number</strong>, I have written <strong class="source-inline1">numberr</strong>. With <strong class="source-inline1">rqt_graph</strong>, I can see where the issu<a id="_idTextAnchor254" class="pcalibre calibre4 pcalibre1"/>e is. The two nodes are not <a id="_idIndexMarker307" class="pcalibre calibre4 pcalibre1"/>communicating with each <a id="_idIndexMarker308" class="pcalibre calibre4 pcalibre1"/>other.</p>
			<h2 id="_idParaDest-128" class="calibre6"><a id="_idTextAnchor255" class="pcalibre calibre4 pcalibre1"/>The ros2 topic command line</h2>
			<p class="calibre3">With <strong class="source-inline1">ros2 node</strong>, we get additional command-line tools for nodes. For topics, we will use <strong class="source-inline1">ros2 topic</strong>.</p>
			<p class="calibre3">If you run <strong class="source-inline1">ros2 topic -h</strong>, you’ll<a id="_idIndexMarker309" class="pcalibre calibre4 pcalibre1"/> see that there are quite a lot of commands. You already know some of them. Here, I will do a quick recap and explore a few more commands that can be useful when debugging topics.</p>
			<p class="calibre3">First, to list all topics, use <strong class="source-inline1">ros2 </strong><strong class="source-inline1">topic list</strong>:</p>
			<pre class="console">
$ ros2 topic list
/number
/parameter_events
/rosout</pre>			<p class="calibre3">As you can see, we get the <strong class="source-inline1">/number</strong> topic. You will also always get <strong class="source-inline1">/parameter_events</strong> and <strong class="source-inline1">/rosout</strong> (all ROS 2 logs are published on this topic).</p>
			<p class="calibre3">With <strong class="source-inline1">ros2 topic info &lt;topic_name&gt;</strong>, you can get the interface for the topic, as well as the number of publishers and subscribers for that topic:</p>
			<pre class="console">
$ ros2 topic info /number
Type: example_interfaces/msg/Int64
Publisher count: 1
Subscription count: 1</pre>			<p class="calibre3">Then, to go further and see the details for the interface, you can run the following command:</p>
			<pre class="console">
$ ros2 interface show example_interfaces/msg/Int64
# some comments
int64 data</pre>			<p class="calibre3">With this, we have all the information we need to create an additional publisher or subscriber to the topic.</p>
			<p class="calibre3">On top of that, we can also directly subscribe to the topic from the Terminal with <strong class="source-inline1">ros2 topic echo &lt;topic_name&gt;</strong>. That’s what we did just after writing the publisher so that we can make sure it’s working before we write any subscriber:</p>
			<pre class="console">
$ ros2 topic echo /number
data: 2
---
data: 2
---</pre>			<p class="calibre3">On the other hand, you can publish to a topic directly from the Terminal with <strong class="source-inline1">ros2 topic pub -r &lt;frequency&gt; &lt;topic_name&gt; &lt;interface&gt; &lt;message_in_json&gt;</strong>. To test this, stop all nodes, and start only the <strong class="source-inline1">number_counter</strong> node in one<a id="_idIndexMarker310" class="pcalibre calibre4 pcalibre1"/> Terminal. Apart from the first log, nothing will be printed. Then, run the following command in another Terminal:</p>
			<pre class="console">
$ ros2 topic pub -r 2.0 /number example_interfaces/msg/Int64 \"{data: 7}"
publisher: beginning loop
publishing #1: example_interfaces.msg.Int64(data=7)
publishing #2: example_interfaces.msg.Int64(data=7)</pre>			<p class="calibre3">This will publish on the <strong class="source-inline1">/number</strong> topic at <strong class="source-inline1">2.0</strong> Hertz (every <strong class="source-inline1">0.5</strong> seconds). When you run this, you’ll see some l<a id="_idTextAnchor256" class="pcalibre calibre4 pcalibre1"/>ogs on the <strong class="source-inline1">number_counter</strong> node, meaning that the messages have been received:</p>
			<pre class="console">
[INFO] [1711600360.459298369] [number_counter]: Counter: 7
[INFO] [1711600360.960216275] [number_counter]: Counter: 14
[INFO] [1711600361.459896877] [number_counter]: Counter: 21</pre>			<p class="calibre3">This way, you can test a subscriber without having to write a publisher first. Note that this only really works for topics with a simple interface. When the interface contains too many fields, it becomes too complicated to write everything on the Terminal.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Both <code>ros2 topic echo</code> and <code>ros2 topic pub</code> can save you lots of time, and it’s also great for collaborating with other people on a project. You could be responsible for writing a publisher, and someone <a id="_idIndexMarker311" class="pcalibre calibre4 pcalibre1"/>else would write a subscriber. With those command-line tools, both of you can make sure the topic communication is working. Then, when you run the two nodes t<a id="_idTextAnchor257" class="pcalibre calibre4 pcalibre1"/>ogether, you know that the data you send or receive is correct.</p>
			<h2 id="_idParaDest-129" class="calibre6"><a id="_idTextAnchor258" class="pcalibre calibre4 pcalibre1"/>Changing a topic name at runtime</h2>
			<p class="calibre3">In <a href="B22403_04.xhtml#_idTextAnchor157" class="pcalibre calibre4 pcalibre1"><em class="italic">Chapter 4</em></a>, you learned how to <a id="_idIndexMarker312" class="pcalibre calibre4 pcalibre1"/>change a node name at runtime—that is, by adding <strong class="source-inline1">--ros-args -r __node:=&lt;new_name&gt;</strong> after the <strong class="source-inline1">ros2 </strong><strong class="source-inline1">run</strong> command.</p>
			<p class="calibre3">So, for any additional argument you pass after <strong class="source-inline1">ros2 run</strong>, add <strong class="source-inline1">--ros-args</strong>, but only once.</p>
			<p class="calibre3">Then, you can also change a topic name at runtime. To do that, add another <strong class="source-inline1">-r</strong>, followed by <strong class="source-inline1">&lt;topic_name&gt;:=&lt;new_topic_name&gt;</strong>.</p>
			<p class="calibre3">For example, let’s rename our topic from <strong class="source-inline1">number</strong> to <strong class="source-inline1">my_number</strong>:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r number:=my_number</pre>			<p class="calibre3">Now, if we start the <strong class="source-inline1">number_counter</strong> node, to be able to receive the messages, we also need to modify the topic name:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_counter --ros-args -r number:=my_number</pre>			<p class="calibre3">With this, the communication will work, but this time using the <strong class="source-inline1">my_number</strong> topic.</p>
			<p class="calibre3">To make things a bit more interesting, let’s keep those two nodes running, and let’s run another publisher to this topic, using the same <strong class="source-inline1">number_publisher</strong> node. As you know, we can’t have two nodes running with the same name. Thus, we will have to rename both the node and the topic. In a third Terminal, run the following code:</p>
			<pre class="console">
$ ros2 run my_py_pkg number_publisher --ros-args -r \ __node:=number_publisher_2 -r number:=my_number</pre>			<p class="calibre3">After you run this, you’ll see that the <strong class="source-inline1">number_counter</strong> receives messages twice as fast since there are two nodes publishing one message every <strong class="source-inline1">1.0</strong> second.</p>
			<p class="calibre3">On top of that, let’s start <strong class="source-inline1">rqt_graph</strong>:</p>
			<div><div><img alt="Figure 5.9 – Two publishers and a subscriber, with a renamed topic" src="img/B22403_05_9.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Two publishers and a subscriber, with a renamed topic</p>
			<p class="calibre3">We’ll see that we have two nodes containing a publisher on the <strong class="source-inline1">my_number</strong> topic, and one node containing a subscriber.</p>
			<p class="calibre3">Changing topic names at runtime will be quite useful for you, especially when you want to run several existing<a id="_idIndexMarker313" class="pcalibre calibre4 pcalibre1"/> nodes that you can’t modify. Even if you can’t rewrite the code, you can modify the names at run<a id="_idTextAnchor259" class="pcalibre calibre4 pcalibre1"/>time. Now, let’s continue with the tools and explore ROS 2 bags.</p>
			<h2 id="_idParaDest-130" class="calibre6"><a id="_idTextAnchor260" class="pcalibre calibre4 pcalibre1"/>Replaying topic data with bags</h2>
			<p class="calibre3">Imagine this scenario: you’re<a id="_idIndexMarker314" class="pcalibre calibre4 pcalibre1"/> working on a mobile robot that’s supposed to perform in a certain way when navigating outside and while it’s raining.</p>
			<p class="calibre3">Now, this means you will need to run the robot in those conditions so that you can develop your application. There are a few problems: maybe you won’t have access to the robot every time, or you can’t take it outside, or it’s simply not raining every day.</p>
			<p class="calibre3">A solution to this is to use ROS 2 bags. Bags allow you to record a topic and replay it later. Thus, you can run the experiment once with the required conditions, and then replay the data just like it was recorded. With this data, you can develop your application.</p>
			<p class="calibre3">Let’s consider another <a id="_idIndexMarker315" class="pcalibre calibre4 pcalibre1"/>scenario: you work with a piece of hardware that isn’t stable yet. Most of the time, it doesn’t work properly. You could record a bag while the hardware is working fine, and then replay this bag to develop your application instead of running the hardware again and again and wasting time on this.</p>
			<p class="calibre3">To work with ROS 2 bags, you must use the <strong class="source-inline1">ros2 bag</strong> command-line tool. Let’s learn how to save and replay a topic with bags.</p>
			<p class="calibre3">First, stop all nodes and run the <strong class="source-inline1">number_publisher</strong> node only.</p>
			<p class="calibre3">We already know that the topic name is <strong class="source-inline1">/number</strong>. You can retrieve that with <strong class="source-inline1">ros2 topic list</strong> if needed. Then, in another Terminal, record the bag with <strong class="source-inline1">ros2 bag record &lt;list of topics&gt; -o &lt;bag_name&gt;</strong>. To make things more organized, I suggest that you create a <strong class="source-inline1">bags</strong> folder and record from within this folder:</p>
			<pre class="console">
$ mkdir ~/bags
$ cd ~/bags/
$ ros2 bag record /number -o bag1
...
[INFO] [1711602240.190476880] [rosbag2_recorder]: Subscribed to topic '/number'
[INFO] [1711602240.190542569] [rosbag2_recorder]: Recording...
[INFO] [1711602240.190729185] [rosbag2_recorder]: All requested topics are subscribed. Stopping discovery...</pre>			<p class="calibre3">At this point, the bag is recording and saving all incoming messages inside a database. Let it run for a few seconds, then stop it with <em class="italic">Ctrl</em> + <em class="italic">C</em>:</p>
			<pre class="console">
[INFO] [1711602269.786924027] [rosbag2_cpp]: Writing remaining messages from cache to the bag. It may take a while
[INFO] [1711602269.787416646] [rosbag2_recorder]: Event publisher thread: Exiting
[INFO] [1711602269.787547010] [rosbag2_recorder]: Recording stopped</pre>			<p class="calibre3">The <strong class="source-inline1">ros2 bag</strong> command will exit, and you’ll end up with a new directory named <strong class="source-inline1">bag1</strong>. In this directory, you will find a <strong class="source-inline1">.mcap</strong> file containing the recorded messages and a YAML file with more information. If you open this YAML file, you’ll see the recorded duration, number of recorded messages, and topics that were recorded.</p>
			<p class="calibre3">Now, you can replay the <a id="_idIndexMarker316" class="pcalibre calibre4 pcalibre1"/>bag, which means you’ll publish on the topic exactly like it was done when recording.</p>
			<p class="calibre3">Stop the <strong class="source-inline1">number_publisher</strong> node and replay the bag with <strong class="source-inline1">ros2 bag </strong><strong class="source-inline1">play &lt;path_to_bag&gt;</strong>:</p>
			<pre class="console">
$ ros2 bag play ~/bags/bag1/</pre>			<p class="calibre3">This will publish all the recorded messages, with the same duration as the recording. So, if you record for 3 minutes and 14 seconds, the bag will replay the topic for 3 minutes and 14 seconds. Then, the bag will exit, and you can play it again if you want.</p>
			<p class="calibre3">While the bag is playing, you can run your subscriber(s). You can do a quick test with <strong class="source-inline1">ros2 topic echo /number</strong> and see the data. You can also run your <strong class="source-inline1">number_counter</strong> node, and you will see that the messages are received.</p>
			<p class="calibre3">You are now able to save and replay a topic using ROS 2 bags. You can explore more advanced options with <strong class="source-inline1">ros2 </strong><strong class="source-inline1">bag -h</strong>.</p>
			<p class="calibre3">As you’ve seen, there are quite a few available tools for topics. Use these tools as often as possible to introspect, debug, and test your topics. They will save you lots of time when you’re developing your ROS 2 application.</p>
			<p class="calibre3">We’re almost done with topics. So far, all we’ve done is use exis<a id="_idTextAnchor261" class="pcalibre calibre4 pcalibre1"/>ting interfaces. Now, let’s learn how to create a custom interface.</p>
			<h1 id="_idParaDest-131" class="calibre6"><a id="_idTextAnchor262" class="pcalibre calibre4 pcalibre1"/>Creating a custom interface for a topic</h1>
			<p class="calibre3">When creating a publisher or subscriber for a topic, you know that you have to use a name and an interface.</p>
			<p class="calibre3">It’s quite easy to publish or subscribe<a id="_idIndexMarker317" class="pcalibre calibre4 pcalibre1"/> to an existing topic: you’ll find the name and interface using the <strong class="source-inline1">ros2</strong> command line, and use that in your code.</p>
			<p class="calibre3">Now, if you want to start a publisher or subscriber for a new topic, you will need to choose a name and interface by yourself:</p>
			<ul class="calibre9">
				<li class="calibre10"><strong class="bold">Name</strong>: No problem—it’s just a chain of characters</li>
				<li class="calibre10"><strong class="bold">Interface</strong>: You have two choices—using an existing interface that works with your topic or creating a new one</li>
			</ul>
			<p class="calibre3">Let’s try to apply the <a id="_idIndexMarker318" class="pcalibre calibre4 pcalibre1"/>ROS 2 philosophy of not reinventing the wheel. When you create a new topic, check if there is any existing interface that can match your needs. If so, then use it; don’t recreate it.</p>
			<p class="calibre3">First, you’ll learn where you can find existing interfaces. Then, you’ll learn how to create a new one.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It’s quite common to use the word <em class="italic">message</em> when talking about topic interfaces. I could have named this section <em class="italic">Creating a custom message</em>. In the following se<a id="_idTextAnchor263" class="pcalibre calibre4 pcalibre1"/>ction, when I talk about messages, I’m referring to topic interfaces.</p>
			<h2 id="_idParaDest-132" class="calibre6"><a id="_idTextAnchor264" class="pcalibre calibre4 pcalibre1"/>Using existing interfaces</h2>
			<p class="calibre3">Before you start a <a id="_idIndexMarker319" class="pcalibre calibre4 pcalibre1"/>new publisher or subscriber for a topic, take some <a id="_idIndexMarker320" class="pcalibre calibre4 pcalibre1"/>time to think about what kind of data you want to send or receiv<a id="_idTextAnchor265" class="pcalibre calibre4 pcalibre1"/>e. Then, check if an already existing interface contains what you need.</p>
			<h3 class="calibre8">Where to find interfaces</h3>
			<p class="calibre3">Just like nodes, interfaces are organized in packages. You can find the most common packages for ROS 2 interfaces here: <a href="https://github.com/ros2/common_interfaces" class="pcalibre calibre4 pcalibre1">https://github.com/ros2/common_interfaces</a>. Not all existing interfaces are listed here, but it’s already quite a lot. For other interfaces, a simple search on the internet<a id="_idIndexMarker321" class="pcalibre calibre4 pcalibre1"/> should bring you to the corresponding GitHub repository.</p>
			<p class="calibre3">In this common interfaces repository, you can find the <strong class="source-inline1">Twist</strong> message we used with Turtlesim, inside the <strong class="source-inline1">geometry_msgs</strong> package. As you can see, for topic interfaces, we then have an additional <strong class="source-inline1">msg</strong> folder, which contains all the message definitions for that package.</p>
			<p class="calibre3">Now, let’s say you want to create a driver node for a camera and publish the images to a topic. If you look inside the <strong class="source-inline1">sensor_msgs</strong> package, and then inside the <strong class="source-inline1">msg</strong> folder, you’ll find a file named <strong class="source-inline1">Image.msg</strong>. This <em class="italic">Image</em> message is probably suitable for your needs. It is al<a id="_idTextAnchor266" class="pcalibre calibre4 pcalibre1"/>so used by a lot of other people, so it will even make your life easier.</p>
			<h3 class="calibre8">Using an existing interface in your code</h3>
			<p class="calibre3">To use this message, make sure you’ve installed<a id="_idIndexMarker322" class="pcalibre calibre4 pcalibre1"/> the package that contains the message—in this case, <strong class="source-inline1">sensor_msgs</strong>. As a quick reminder, to install a ROS 2 package, you can run <strong class="source-inline1">sudo apt </strong><strong class="source-inline1">install ros-&lt;distro&gt;-&lt;package-name&gt;</strong>:</p>
			<pre class="console">
$ sudo apt install ros-jazzy-sensor-msgs</pre>			<p class="calibre3">Maybe the package was already installed. If not, source your environment again afterward. Then, you can find the details regarding the interface with <strong class="source-inline1">ros2 interface </strong><strong class="source-inline1">show &lt;interface&gt;</strong>:</p>
			<pre class="console">
$ ros2 interface show sensor_msgs/msg/Image</pre>			<p class="calibre3">To use this message in your code, just follow what we did in this chapter (with the <strong class="source-inline1">example_interfaces/msg/Int64</strong> message):</p>
			<ol class="calibre11">
				<li class="calibre10">In the <code>package.xml</code> file of the package where you write your nodes, add the dependency to the interface package.</li>
				<li class="calibre10">In your code, import the message and use it in your publisher or subscriber.</li>
				<li class="calibre10">For C++ only: Add the dependency to the interface package in the <code>CMakeLists.txt</code> file.</li>
			</ol>
			<p class="calibre3">We will see another example of this process very soon, just after we create our interface.</p>
			<p class="calibre3">At this point, you know <a id="_idIndexMarker323" class="pcalibre calibre4 pcalibre1"/>how to fi<a id="_idTextAnchor267" class="pcalibre calibre4 pcalibre1"/>nd and use existing messages in your code. But should you always do that?</p>
			<h3 class="calibre8">When not to use existing messages</h3>
			<p class="calibre3">For common use <a id="_idIndexMarker324" class="pcalibre calibre4 pcalibre1"/>cases, sensors, and actuators, you will probably find what you need. However, if the interface doesn’t match exactly what you want, you will have to create a new one.</p>
			<p class="calibre3">There are a few packages containing basic interfaces, such as <strong class="source-inline1">example_interfaces</strong>, or even <strong class="source-inline1">std_msgs</strong>. You could be tempted to use them in your code. As a best practice, it’s better to avoid it. Just read the comments from the message definitions to be sure of that:</p>
			<pre class="console">
$ ros2 interface show example_interfaces/msg/Int64
# This is an example message of using a primitive datatype, int64.
# If you want to test with this that's fine, but if you are deploying it into a system you should create a semantically meaningful message type.
# If you want to embed it in another message, use the primitive data type instead.
int64 data
$ ros2 interface show std_msgs/msg/Int64
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.
int64 data</pre>			<p class="calibre3">As you can see, the <strong class="source-inline1">std_msgs</strong> package is deprecated, and <strong class="source-inline1">example_interfaces</strong> is only recommended to make tests—which is what we’ve done in this chapter so far to help us learn various topics.</p>
			<p class="calibre3">As a general rule, if you <a id="_idIndexMarker325" class="pcalibre calibre4 pcalibre1"/>don’t find exactly what you need in the existing interface packages, then create <a id="_idTextAnchor268" class="pcalibre calibre4 pcalibre1"/>your own interface. It’s not hard to do and will always be the same process.</p>
			<h2 id="_idParaDest-133" class="calibre6"><a id="_idTextAnchor269" class="pcalibre calibre4 pcalibre1"/>Creating a new topic interface</h2>
			<p class="calibre3">You will now create your first <a id="_idIndexMarker326" class="pcalibre calibre4 pcalibre1"/>custom interface for a topic. We will see how to set a package up fo<a id="_idTextAnchor270" class="pcalibre calibre4 pcalibre1"/><a id="_idTextAnchor271" class="pcalibre calibre4 pcalibre1"/>r that, how to create and build the interface, and how to use it in our code.</p>
			<h3 class="calibre8">Creating and setting up an interfaces package</h3>
			<p class="calibre3">Before we create any <a id="_idIndexMarker327" class="pcalibre calibre4 pcalibre1"/>topic interface (message), we need to create a new package and set it up for building interfaces. As a best practice, in your application, you will have one package dedicated to<a id="_idIndexMarker328" class="pcalibre calibre4 pcalibre1"/> custom interfaces. This means that you create interfaces only in this package, and you keep this package only for interfaces—no nodes or other things, just interfaces. This will make it much <a id="_idIndexMarker329" class="pcalibre calibre4 pcalibre1"/>easier when you’re scaling the application and will help you avoid creating a dependency mess.</p>
			<p class="calibre3">A common practice when naming this interface package is to start with the name of your application or robot and add the <strong class="source-inline1">_interfaces</strong> suffix. So, if your robot is named <strong class="source-inline1">abc</strong>, you should use <strong class="source-inline1">abc_interfaces</strong>.</p>
			<p class="calibre3">We don’t have a robot for this example, so let’s just name the package <strong class="source-inline1">my_robot_interfaces</strong>.</p>
			<p class="calibre3">Create a new package with the <strong class="source-inline1">ament_cmake</strong> build type and no dependencies. You don’t even need to provide the build type since <strong class="source-inline1">ament_cmake</strong> is the one used by default. Navigate to the <strong class="source-inline1">src</strong> directory of your workspace and create this package:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/
$ ros2 pkg create my_robot_interfaces</pre>			<p class="calibre3">At this point, your workspace should contain three packages: <strong class="source-inline1">my_py_pkg</strong>, <strong class="source-inline1">my_cpp_pkg</strong>, and <strong class="source-inline1">my_robot_interfaces</strong>.</p>
			<p class="calibre3">We need to set this new package up and modify a few things so it can build messages. Go into the package, remove the <strong class="source-inline1">src</strong> and <strong class="source-inline1">include</strong> directories, and create a new <strong class="source-inline1">msg</strong> folder:</p>
			<pre class="console">
$ cd my_robot_interfaces/
$ rm -r src/ include/
$ mkdir msg</pre>			<p class="calibre3">Now, open the <strong class="source-inline1">package.xml</strong> file for this package. After <strong class="source-inline1">&lt;buildtool_depend&gt;ament_cmake&lt;/buildtool_depend&gt;</strong>, add the following three lines. I recommend <a id="_idIndexMarker330" class="pcalibre calibre4 pcalibre1"/>that you just copy and paste them so that you don’t make any mistakes:</p>
			<pre class="source-code">
&lt;build_depend&gt;rosidl_default_generators&lt;/build_depend&gt;
&lt;exec_depend&gt;rosidl_default_runtime&lt;/exec_depend&gt;
&lt;member_of_group&gt;rosidl_interface_packages&lt;/member_of_group&gt;</pre>			<p class="calibre3">With that, the <strong class="source-inline1">package.xml</strong> file is complete and you won’t have to do anything else with it for now. Open the <strong class="source-inline1">CMakeLists.txt</strong> file. After <strong class="source-inline1">find_package(ament_cmake REQUIRED)</strong>, and before <strong class="source-inline1">ament_package()</strong>, add the following lines (you can also<a id="_idIndexMarker331" class="pcalibre calibre4 pcalibre1"/> remove the <strong class="source-inline1">if(BUILD_TESTING)</strong> block):</p>
			<pre class="source-code">
find_package(rosidl_default_generators REQUIRED)
rosidl_generate_interfaces(${PROJECT_NAME}
  # we will add the name of our custom interfaces here
)
ament_export_dependencies(rosidl_default_runtime)</pre>			<p class="calibre3">There’s not much to understand about these lines you’re adding. They will find some dependencies (<strong class="source-inline1">rosidl</strong> packages) and prepare your package so that it can build interfaces.</p>
			<p class="calibre3">At this point, your package is ready and you can add new interfaces. You will only need<a id="_idTextAnchor272" class="pcalibre calibre4 pcalibre1"/> to do this setup phase once. At this point, adding a new interface is very quick.</p>
			<h3 class="calibre8">Creating and building a new topic interface</h3>
			<p class="calibre3">Let’s say we want to create a publisher to send some kind of hardware status for our robot, including the robot <a id="_idIndexMarker332" class="pcalibre calibre4 pcalibre1"/>version, internal temperature, a flag to know if the motors are ready, and a debug message.</p>
			<p class="calibre3">We’ve looked at existing interfaces<a id="_idIndexMarker333" class="pcalibre calibre4 pcalibre1"/> and nothing matches. How can you name this new interface? Here are the rules you have to follow:</p>
			<ul class="calibre9">
				<li class="calibre10">Use UpperCamelCase—for example, HardwareStatus</li>
				<li class="calibre10">Don’t write <code>Msg</code> or <code>Interface</code> in the name as this would add unnecessary redundancy</li>
				<li class="calibre10">Use <code>.msg</code> for the file extension</li>
			</ul>
			<p class="calibre3">Following these rules, create a new file named <strong class="source-inline1">HardwareStatus.msg</strong> in the <strong class="source-inline1">msg</strong> folder:</p>
			<pre class="console">
$ cd ~/ros2_ws/src/my_robot_interfaces/msg/
$ touch HardwareStatus.msg</pre>			<p class="calibre3">Inside this file, we can add the definition for the message. Here’s what you can use:</p>
			<ul class="calibre9">
				<li class="calibre10">Built-in types, such as <code>bool</code>, <code>byte</code>, <code>int64</code>, <code>float64</code>, and <code>string</code>, as well as arrays of those types. You can find the complete list here: <a href="https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types" class="pcalibre calibre4 pcalibre1">https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types</a>.</li>
				<li class="calibre10">Other existing messages, using the name of the package, followed by the name of the message —for example, <code>geometry_msgs/Twist</code> (don’t add the <code>msg</code> folder here).</li>
			</ul>
			<p class="calibre3">To make things simple here, we will start with only built-in types. Write the following inside the message file:</p>
			<pre class="source-code">
int64 version
float64 temperature
bool are_motors_ready
string debug_message</pre>			<p class="calibre3">For each field, we provide the data type, and then the name of the field.</p>
			<p class="calibre3">Now, how are we going to build this message? How can we get a Python or C++ class that we can include and use in <a id="_idIndexMarker334" class="pcalibre calibre4 pcalibre1"/>our code?</p>
			<p class="calibre3">To build the message, you <a id="_idIndexMarker335" class="pcalibre calibre4 pcalibre1"/>simply have to add one line to <strong class="source-inline1">CMakelists.txt</strong>, specifying the relative path to the message file:</p>
			<pre class="source-code">
rosidl_generate_interfaces(${PROJECT_NAME}
  <strong class="bold1">"msg/HardwareStatus.msg"</strong>
)</pre>			<p class="calibre3">For each new interface you build in this package, you will add one line inside the <strong class="source-inline1">rosidl_generate_interfaces()</strong> function. <em class="italic">Don’t add any commas between </em><em class="italic">the lines.</em></p>
			<p class="calibre3">Now, save all the files and build your new package:</p>
			<pre class="console">
$ cd ~/ros2_ws/
$ colcon build --packages-select my_robot_interfaces
Starting &gt;&gt;&gt; my_robot_interfaces
Finished &lt;&lt;&lt; my_robot_interfaces [4.00s]
Summary: 1 package finished [4.28s]</pre>			<p class="calibre3">The build system will take the interface definition you’ve written and use it to generate source code for Python and C++:</p>
			<div><div><img alt="Figure 5.10 – Build system for interfaces" src="img/B22403_05_10.jpg" class="calibre5"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Build system for interfaces</p>
			<p class="calibre3">Once you’ve built the package, make sure you source the environment. You should be able to see your interface from the Terminal (don’t forget to use auto-completion to build the command faster and be sure you have the correct name):</p>
			<pre class="console">
$ source ~/.bashrc
$ ros2 interface show my_robot_interfaces/msg/HardwareStatus
int64 version
float64 temperature
bool are_motors_ready
string debug_message</pre>			<p class="calibre3">If you see this, it means that<a id="_idIndexMarker336" class="pcalibre calibre4 pcalibre1"/> the build process succeeded. If you can’t see the interface in <a id="_idTextAnchor273" class="pcalibre calibre4 pcalibre1"/>the Terminal, then <a id="_idIndexMarker337" class="pcalibre calibre4 pcalibre1"/>you need to go back and check that you did all the steps correctly.</p>
			<h3 class="calibre8">Using your custom message in your code</h3>
			<p class="calibre3">Let’s say you want to use <a id="_idIndexMarker338" class="pcalibre calibre4 pcalibre1"/>your new interface in the <strong class="source-inline1">number_publisher</strong> node you created in this chapter, inside the <strong class="source-inline1">my_py_pkg</strong> package.</p>
			<p class="calibre3">First, open the <strong class="source-inline1">package.xml</strong> file from the <strong class="source-inline1">my_py_pkg</strong> package and add a dependency to <strong class="source-inline1">my_robot_interfaces</strong>:</p>
			<pre class="source-code">
&lt;depend&gt;rclpy&lt;/depend&gt;
&lt;depend&gt;example_interfaces&lt;/depend&gt;
<strong class="bold1">&lt;depend&gt;my_robot_interfaces&lt;/depend&gt;</strong></pre>			<p class="calibre3">Then, for Python, do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">Import the message by by adding the following import line in your code:<pre class="source-code">
from my_robot_interfaces.msg import HardwareStatus</pre></li>				<li class="calibre10">Create a publisher and specify the <code>HardwareStatus</code> interface.</li>
				<li class="calibre10">Create a message in your code, like so:<pre class="source-code">
msg = HardwareStatus()
msg.temperature = 34.5</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you’re using VS Code, the message might not be recognized after you import it. Close VS Code and open it again in a sourced environment. So, make sure the interface has been built correctly, then source the environment, and open VS code.</p>
			<p class="calibre3">If you want to use this<a id="_idIndexMarker339" class="pcalibre calibre4 pcalibre1"/> message in your C++ node from the <strong class="source-inline1">my_cpp_pkg</strong> package, add the dependency to <strong class="source-inline1">my_robot_interfaces</strong> in the <strong class="source-inline1">package.xml</strong> file of <strong class="source-inline1">my_cpp_package</strong>. Then, do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">Import the message by adding the following <code>include</code> line in your code:<pre class="source-code">
#include "my_robot_interfaces/msg/hardware_status.hpp"</pre></li>				<li class="calibre10">Create a publisher and specify the interface with <code>&lt;my_robot_interfaces::msg::</code><strong class="source-inline">
</strong><code>HardwareStatus&gt;</code>.</li>
				<li class="calibre10">Create a message in your code, like so:<pre class="source-code">
auto msg = my_robot_interfaces::msg::HardwareStatus();
msg.temperature = 34.5;</pre></li>			</ol>
			<p class="calibre3">When using VS code, the C++ include will not be recognized. You need to add a new line to the <strong class="source-inline1">c_cpp_properties.json</strong> file that was auto-generated (inside a <strong class="source-inline1">.vscode</strong> folder) when you started VS Code. You can find this file from VS Code using the explorer on the left. Then, in the <strong class="source-inline1">includePath</strong> array, add the following line:</p>
			<pre class="source-code">
"includePath": [
        "/opt/ros/jazzy/include/**",
        <strong class="bold1">"/home/&lt;user&gt;/ros2_ws/install/my_robot_interfaces/include/**"</strong>,
        "/usr/include/**"
    ],</pre>			<p class="calibre3">You can now create and use your custom interface for topics. As you’ve seen, first, check whether there’s any existing interface that matches your needs. If there is, don’t reinvent the wheel. If nothing matches perfectly, however, don’t hesitate to create your own interface. To do that, you must create a new package dedicated to interfaces. Once you’ve finished the setup <a id="_idIndexMarker340" class="pcalibre calibre4 pcalibre1"/>process for this package, you can add as many interfaces as you want.</p>
			<p class="calibre3">Before we wrap things up, I will give you an add<a id="_idTextAnchor274" class="pcalibre calibre4 pcalibre1"/>itional challenge so that you can practice the concepts that were covered in this chapter.</p>
			<h1 id="_idParaDest-134" class="calibre6"><a id="_idTextAnchor275" class="pcalibre calibre4 pcalibre1"/>Topic challenge – closed-loop control</h1>
			<p class="calibre3">Here’s a challenge for you so that you can continue practicing creating nodes, publishers, and subscribers. We will start a new ROS 2 project and improve it throughout the following chapters, as <a id="_idIndexMarker341" class="pcalibre calibre4 pcalibre1"/>we discover more concepts.</p>
			<p class="calibre3">I encourage you to read the instructions and take the time to complete this challenge before you check the solution. Practicing is the key to effective learning.</p>
			<p class="calibre3">I will not provide a full explanation of all the steps, just a few remarks on the important points. You can find the complete solution code on GitHub, for both Python and C++.</p>
			<p class="calibre3">Your challenge is to write a controller for the <strong class="source-inline1">turtlesim</strong> node. So far, we’ve just used simple and basic numbers to publish a<a id="_idTextAnchor276" class="pcalibre calibre4 pcalibre1"/>nd subscribe to topics. With this, you can practice as if you were working on a real robot.</p>
			<h2 id="_idParaDest-135" class="calibre6"><a id="_idTextAnchor277" class="pcalibre calibre4 pcalibre1"/>Challenge</h2>
			<p class="calibre3">The goal is simple: we want<a id="_idIndexMarker342" class="pcalibre calibre4 pcalibre1"/> to make the turtle move in a circle. On top of this, we also want to modify the velocity of the turtle, whether it’s on the right or left of the screen.</p>
			<p class="calibre3">To get the <em class="italic">X</em> coordinate of a turtle on the screen, you can subscribe to the <strong class="source-inline1">pose</strong> topic for that turtle. Then, finding the middle of the screen is easy: the minimum <em class="italic">X</em> value on the left is <strong class="source-inline1">0</strong>, and the maximum <em class="italic">X</em> value on the right is about <strong class="source-inline1">11</strong>. We will assume that the <em class="italic">X</em> coordinate for the middle of the screen is <strong class="source-inline1">5.5</strong>.</p>
			<p class="calibre3">You can then send a command velocity by publishing to the <strong class="source-inline1">cmd_vel</strong> topic for the turtle. To make the turtle move in a circle, you just have to publish constant values for the linear <em class="italic">X</em> and angular <em class="italic">Z</em> velocities. Use <strong class="source-inline1">1.0</strong> for both velocities if the turtle is on the left (<em class="italic">X</em> &lt; 5.5), and <strong class="source-inline1">2.0</strong> for both if the turtle is on the right.</p>
			<p class="calibre3">Follow these steps to<a id="_idIndexMarker343" class="pcalibre calibre4 pcalibre1"/> get started:</p>
			<ol class="calibre11">
				<li class="calibre10">Create a new package (let’s name it <code>turtle_controller</code>). You can decide to create either a Python or C++ package. If you do both, make sure you give each a different name.</li>
				<li class="calibre10">Inside this package, create a new node named <code>turtle_controller</code>.</li>
				<li class="calibre10">In the node’s constructor, add a publisher (command velocity) and a subscriber (pose).</li>
				<li class="calibre10">This is where it’s a bit different from before: instead of creating a timer and publishing from the timer callback, you can publish directly from the subscriber callback. The <code>turtlesim</code> node is constantly publishing on the <code>pose</code> topic. Publishing a command from the subscriber callback allows you to create some kind of closed-loop control. You can get the current <em class="italic">X</em> coordinate and send a different velocity command, depending on where the turtle is.</li>
			</ol>
			<p class="calibre3">To test your code, create an executable out of your code. Then, run <strong class="source-inline1">turtlesim</strong> in one Terminal and your node in another. You should<a id="_idTextAnchor278" class="pcalibre calibre4 pcalibre1"/> see the turtle drawing a circle, with a different velocity depending on where the turtle is.</p>
			<h2 id="_idParaDest-136" class="calibre6"><a id="_idTextAnchor279" class="pcalibre calibre4 pcalibre1"/>Solution</h2>
			<p class="calibre3">You can find the complete<a id="_idIndexMarker344" class="pcalibre calibre4 pcalibre1"/> code (for both Python and C++) and package organization on GitHub.</p>
			<p class="calibre3">Here are the most important steps for the Python node. The code starts with all the required import lines:</p>
			<pre class="source-code">
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from turtlesim.msg import Pose</pre>			<p class="calibre3">Here, we import <strong class="source-inline1">Twist</strong> from <strong class="source-inline1">geometry_msgs</strong> and <strong class="source-inline1">Pose</strong> from <strong class="source-inline1">turtlesim</strong>. You can find those interfaces by running <strong class="source-inline1">turtlesim_node</strong> and exploring topics with the <strong class="source-inline1">ros2 topic</strong> and <strong class="source-inline1">ros2 interface</strong> command-line tools.</p>
			<p class="calibre3">Then, we create a class for <a id="_idIndexMarker345" class="pcalibre calibre4 pcalibre1"/>our node, with a constructor:</p>
			<pre class="source-code">
class TurtleControllerNode(Node):
    def __init__(self):
        super().__init__("turtle_controller")
        self.cmd_vel_pub_ = self.create_publisher(Twist, "/turtle1/cmd_vel", 10)
        self.pose_sub_ = self.create_subscription(Pose, "/turtle1/pose", self.callback_pose, 10)</pre>			<p class="calibre3">As you can see, we just create a publisher and a subscriber. There’s no timer as we plan to use the publisher directly from the subscriber callback:</p>
			<pre class="source-code">
def callback_pose(self, pose: Pose):
    cmd = Twist()
    if pose.x &lt; 5.5:
        cmd.linear.x = 1.0
        cmd.angular.z = 1.0
    else:
        cmd.linear.x = 2.0
        cmd.angular.z = 2.0
    self.cmd_vel_pub_.publish(cmd)</pre>			<p class="calibre3">This is the subscriber callback. Whenever we receive a new <strong class="source-inline1">Pose</strong> message, we create a new command (a <strong class="source-inline1">Twist</strong> message). Then, depending on the current <em class="italic">X</em> coordinate of the turtle, we give different values for the velocity. Finally, we publish the new velocity command.</p>
			<p class="calibre3">That’s it for this challenge. It can be a bit challenging to understand how to start, but in the end, you can see that there is not so<a id="_idIndexMarker346" class="pcalibre calibre4 pcalibre1"/> much code to write. I encourage you to come back to this challenge in a few days and try again without loo<a id="_idTextAnchor280" class="pcalibre calibre4 pcalibre1"/>king at the solution. This way, you can check if you understood the concept of topics correctly.</p>
			<h1 id="_idParaDest-137" class="calibre6"><a id="_idTextAnchor281" class="pcalibre calibre4 pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, you worked on ROS 2 topics.</p>
			<p class="calibre3">Topics allow nodes to communicate with each other using a publish/subscribe mechanism. Topics are made for unidirectional data streams and are anonymous.</p>
			<p class="calibre3">You can write topic publishers and subscribers directly in your nodes by using <strong class="source-inline1">rclpy</strong> for Python and <strong class="source-inline1">rclcpp</strong> for C++.</p>
			<p class="calibre3">To write a publisher, you must do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">First, check what topic name and interface you must send. Import the interface into the code and create a publisher in the node’s constructor.</li>
				<li class="calibre10">To publish, you must create a message, fill in the different fields, and publish the message with your publisher.</li>
			</ol>
			<p class="calibre3">You can potentially publish a message from anywhere in the code. A common structure is to add a timer and publish from the timer callback. If it makes sense, you can also publish from a subscriber callback directly.</p>
			<p class="calibre3">To write a subscriber, you must do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">As for the publisher, you need to know what name and interface to receive. Import the interface and create a subscriber in the node’s constructor.</li>
				<li class="calibre10">When creating the subscriber, you will need to specify a callback function. It’s in this callback function that you can receive and process incoming messages.</li>
			</ol>
			<p class="calibre3">If you create a publisher or subscriber for a new topic and no interface matches your needs, you might need to create a custom interface. In this case, you must do the following:</p>
			<ol class="calibre11">
				<li class="calibre10">Create and configure a new package dedicated to interfaces for your robot or application.</li>
				<li class="calibre10">Add your topic interface inside the package and build the package.</li>
				<li class="calibre10">Now, you can use this custom interface in your publishers/subscribers, just like any other interface.</li>
			</ol>
			<p class="calibre3">To try a publisher or a subscriber, simply build the package where the node is, source the environment, and run the node. You can then use the <strong class="source-inline1">ros2</strong> command-line tools, as well as <strong class="source-inline1">rqt_graph</strong>, to introspect your application and solve potential issues.</p>
			<p class="calibre3">After topics, the next logical step is to learn about ROS 2 services. This is what we will cover in the following chapter.</p>
		</div>
	</body></html>