["```py\nclass Singleton(object):\n     def __new__(cls):\n       if not hasattr(cls, 'instance'):\n         cls.instance = super(Singleton, cls).__new__(cls)\n       return cls.instance\n\ns = Singleton()\nprint(\"Object created\", s)\n\ns1 = Singleton()\nprint(\"Object created\", s1)\n```", "```py\nclass Singleton:\n    __instance = None\n    def __init__(self):\n        if not Singleton.__instance:\n            print(\" __init__ method called..\")\n        else:\n            print(\"Instance already created:\", self.getInstance())\n    @classmethod\n    def getInstance(cls):\n        if not cls.__instance:\n            cls.__instance = Singleton()\n        return cls.__instance\n\ns = Singleton() ## class initialized, but object not created\nprint(\"Object created\", Singleton.getInstance()) # Object gets created here\ns1 = Singleton() ## instance already created\n```", "```py\nclass Borg:\n    __shared_state = {\"1\":\"2\"}\n    def __init__(self):\n        self.x = 1\n        self.__dict__ = self.__shared_state\n        pass\n\nb = Borg()\nb1 = Borg()\nb.x = 4\n\nprint(\"Borg Object 'b': \", b) ## b and b1 are distinct objects\nprint(\"Borg Object 'b1': \", b1)\nprint(\"Object State 'b':\", b.__dict__)## b and b1 share same state\nprint(\"Object State 'b1':\", b1.__dict__)\n```", "```py\nclass Borg(object):\n     _shared_state = {}\n     def __new__(cls, *args, **kwargs):\n       obj = super(Borg, cls).__new__(cls, *args, **kwargs)\n       obj.__dict__ = cls._shared_state\n       return obj\n```", "```py\nclass MyInt(type):\n    def __call__(cls, *args, **kwds):\n        print(\"***** Here's My int *****\", args)\n        print(\"Now do whatever you want with these objects...\")\n        return type.__call__(cls, *args, **kwds)\n\nclass int(metaclass=MyInt):\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\ni = int(4,5)\n```", "```py\nclass MetaSingleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(MetaSingleton, \\\n                cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Logger(metaclass=MetaSingleton):\n    pass\n\nlogger1 = Logger()\nlogger2 = Logger()\nprint(logger1, logger2)\n```", "```py\nimport sqlite3\nclass MetaSingleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(MetaSingleton, \\\n                cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\nclass Database(metaclass=MetaSingleton):\n  connection = None\n  def connect(self):\n    if self.connection is None:\n        self.connection = sqlite3.connect(\"db.sqlite3\")\n        self.cursorobj = self.connection.cursor()\n    return self.cursorobj\n\ndb1 = Database().connect()\ndb2 = Database().connect()\n\nprint (\"Database Objects DB1\", db1)\nprint (\"Database Objects DB2\", db2)\n```", "```py\nclass HealthCheck:\n    _instance = None\n    def __new__(cls, *args, **kwargs):\n        if not HealthCheck._instance:\n            HealthCheck._instance = super(HealthCheck, \\\n                cls).__new__(cls, *args, **kwargs)\n        return HealthCheck._instance\n    def __init__(self):\n        self._servers = []\n    def addServer(self):\n        self._servers.append(\"Server 1\")\n        self._servers.append(\"Server 2\")\n        self._servers.append(\"Server 3\")\n        self._servers.append(\"Server 4\")\n    def changeServer(self):\n        self._servers.pop()\n        self._servers.append(\"Server 5\")\n\nhc1 = HealthCheck()\nhc2 = HealthCheck()\n\nhc1.addServer()\nprint(\"Schedule health check for servers (1)..\")\nfor i in range(4):\n    print(\"Checking \", hc1._servers[i])\n\nhc2.changeServer()\nprint(\"Schedule health check for servers (2)..\")\nfor i in range(4):\n    print(\"Checking \", hc2._servers[i])\n```"]