- en: Chapter 4. Extending the Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a bit different from all the previous chapters because it focuses
    on external libraries that provide interaction between the Robot Framework and
    the other software over which Robot Framework runs. This is important as the integration
    with other leading software is the cornerstone of this framework. Therefore, we
    need to be aware of the various libraries that are present as well as know how
    to create a custom library for the framework if there is not any.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, all the examples have only used the `log` function present in the
    built-in library as this was the easiest way to demonstrate output on running
    the framework. While this was easy to understand, it didn't explain how acceptance
    testing is supposed to work in real world scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, various third-party libraries are covered, which extend the
    Robot Framework in myriad ways. Briefly put, the following would be covered in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Web application testing through Selenium
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging Selenium-based Robot Framework code through the REPL shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Java-based desktop applications through the Swing library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to image-based automation through Sikuli
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of a custom Robot Framework library for Sikuli
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of other libraries that assist in writing acceptance tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To demonstrate the integration with a third-party library, we will finally proceed
    with using the Sikuli tool to capture and replay the mouse and keyboard actions,
    and using image-based computer vision to create a fully-fledged acceptance testing
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Today, most of the commonly used software in use are present on the Web as it
    has become the common medium to interact with huge amount of users worldwide.
    Creation of a web-based solution is not only getting easier by the day (as new
    technologies are coming up and the old ones are getting matured, optimized, and
    obsolete), but the connectivity, ease of use, and sophistication for web application
    clients are also increasing. Thus, the web applications which interact with the
    world today have almost negligible lead time between their development and end
    user interaction. Acceptance testing thus becomes essential as changes in the
    software must be validated quickly to ensure basic correctness and existence of
    basic functionality before they go live into the production.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Selenium is a web browser automation tool that provides recording and playback
    facilities. It can be used to create simple scripts that can automate actions
    on browser and web pages by using various objects present in the browser. As it
    is a leading web browsing automation tool, there are various resources available
    for it. As a browser runner, various browsers have Selenium as a plugin/extension
    and can be installed within the browser itself. However, while running the custom
    examples, a Selenium-based server is required, which is present in an embedded
    JAR file that can be called directly. Originally, it came with a remote controller,
    which required a Selenium remote control server that managed browsers' web requests
    from the browsers. However, owing to the popular requests to simplify the development
    requirements, Selenium2 was created that used WebDriver to manage the browsers
    directly and perform operations, such as file upload and popup management directly
    from the browser. Through the use of WebDriver, the Selenium tests can be made
    more flexible and made to work in browsers that were not possible to be used by
    Selenium before.
  prefs: []
  type: TYPE_NORMAL
- en: The Robot Framework Selenium library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This library provides a bridge between the Robot Framework and the Selenium
    WebDriver engine. Through this, various Selenium commands can be issued directly
    from the Robot Framework test files. There exist separate libraries for Selenium1
    as well as Selenium2 and depending upon the Selenium version, one can choose an
    appropriate library. There is no need to despair though, as Selenium2 library
    is largely built upon the contents of the Selenium library. One thing to be noted
    is that if Selenium is running with a separate server (an embedded Jetty server),
    then remote control driver is needed, otherwise the WebDriver can easily be chosen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install this library, `pip` can be used and depending upon the set up, sudo/admin
    privileges may be required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The detailed documentation is present at [http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html](http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html),
    which can be quite handy while developing these applications.
  prefs: []
  type: TYPE_NORMAL
- en: Running web-based tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the example, a small website has been created using flask, which is a Python-based
    micro framework to create dynamic websites. To run the example, flask would be
    required at the local Python setup, which can be installed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing flask, traverse to the `flaskApp` directory via command line
    and run the demo website by running its main controller file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts up the flask on `localhost:5000`, and displays the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running web-based tests](img/3033OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On entering wrong username/password an error is displayed on the same page.
    Here, the contents of the form are not persisted and only the presence of an error
    message indicates that a wrong username/password combination has been tried previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the error when a wrong username/password combination
    is tried:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running web-based tests](img/3033OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The application redirects to the respective page if the login is successful,
    which also provides a confirmation text mentioning the successful login as well
    as provides a URL for logging again, if there is any need to do that again, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running web-based tests](img/3033OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the Selenium2Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To perform the same task through the Robot Framework, following test can be
    written with the help of `robotframework-selenium2 library`, which was discussed
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This test assumes that the Selenium browser is already set up. There are a
    few variables in use that are quite obvious by their names. The test code is explained
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On start of the test case, go to the specified URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the title of the page is `My Application.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the page contains the desired elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the valid user in the **Name** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the valid password in the **Password** text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instruct Selenium to click on the **Submit** button, the browser then issues
    the form action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, the browser is redirected to another page, the URL of which is
    checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see and run this full test, you are encouraged to check out the test code
    as well as view the Selenium library. Similarly, you can also assert contents
    in various pages for some specific text as a form of testing by using the `page
    should contain` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging through the REPL shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are starting with the Selenium library, you will face problems in setting
    up the entire Selenium setup. Thankfully, there is a tool that helps you run the
    test operations one at a time. This is known as the debug-library and is an REPL
    shell. **REPL** (**Read Evaluate Print Loop**) like any other console, only accepts
    a single line and presents its output before requiring the next line. This is
    quite similar to shells present in various other languages. Its source code is
    present at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/xyb/robotframework-debuglibrary](https://github.com/xyb/robotframework-debuglibrary)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install this on a machine running Python with its packaging manager, use
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing this, a command, `rfshell` is available. You can use it to
    perform basic operations and Selenium-specific tasks. The following screenshot
    shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging through the REPL shell](img/3033OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As soon as `exit` is entered in the shell, it exits and a report HTML file is
    generated at the `home` folder of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there is no log or XML file generated anywhere for this.
  prefs: []
  type: TYPE_NORMAL
- en: Testing desktop applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Acceptance testing can also be implemented in desktop-based applications, making
    the Robot Framework tests far more applicable rather than just catering to the
    needs of some specific problem or a framework alone.
  prefs: []
  type: TYPE_NORMAL
- en: Testing through objects – Java Swing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swing library is a fully featured library that can be used to test Java Swing-based
    applications. As this works on Java platform, this needs Jython runtime. To run
    an acceptance test over a swing application, two things are required in the `classpath`:'
  prefs: []
  type: TYPE_NORMAL
- en: Swing library JAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual swing application bundled as a JAR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On having the necessary files, the test can be used. The classpath can be set
    prior to the Jython command, or prefixed with the command itself like the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `swinglibrary` is version 1.6.0 and the system under test is bundled
    as `myApp.jar`, and the Robot Framework files are present in the `testsuites`
    folder. The application is then visible to the Robot Framework test file and can
    be accessed through its fully packaged Java Swing name. The settings table of
    the test scripts will require the `swinglibrary` to be loaded in order to provide
    all the Swing library specific keywords.
  prefs: []
  type: TYPE_NORMAL
- en: A Swing test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given the following application, the test will cover adding and deleting items
    to and from the given **Todo List**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A Swing test](img/3033OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just by looking at this Swing application, it is not distinguishable which text
    field, table, or any other UI element is talked about, so black box testing will
    not be successful in this case and we need some internals, such as various component
    names to interact with them. This might feel similar to Selenium as both the libraries
    provide object-based testing that requires knowledge of the internals of the system
    under test by the tests themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following is the test required to cover various use cases this UI has to offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be explained briefly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the Java application through the `Start Application` keyword using the fully
    qualified name of the Java application (that is, the package and the class name)
    which is needed to run the application from the JAR file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the correct window, which also ascertains that the application has the
    desired window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for other basic assumptions, such as the state of various elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform various UI operations through intuitively named keywords for the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After typing text and clicking on the **Add Todo** button, the `todolist` size
    should increase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, other operations for the UI can be performed. Like other external
    libraries, it is helpful to have its library documentation by the side while writing
    tests in this library.
  prefs: []
  type: TYPE_NORMAL
- en: Testing through images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers image-based testing, which is different from what has been
    covered so far. In image-based testing, the user interface is treated as a black
    box and no object internals of the applications are exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Sikuli
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sikuli is a leading tool that performs automation through computer vision,
    that is, recognition of images on the screen. As a human being, we can distinguish
    an object''s properties by looking at it, but this is not straightforward in case
    of computers as computers can only match binary or textual information. Thus,
    there is a need for computer vision or knowing if a given image is present on
    a larger screen or not. In simple sense, Sikuli uses the user-supplied screenshot
    images to perform action over various items and displays the generated script
    visually in the Sikuli IDE. Following is one such script to do a search:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sikuli](img/3033OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As is evident from the image, the script does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the Chrome browser icon exists on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the Chrome browser to open it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for the browser window to open up and display the URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [google.com](http://google.com) in the URL bar, which will open up the
    Google home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for the Google search buttons to show up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform the desired query in the appropriate text field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify the results obtained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Sikuli page should appear on the first page of results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, behind the scenes, the following Python script is generated in the
    folder where this Sikuli script is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Apart from this Python script (or its HTML equivalent), there exist various
    images that are referenced in the test. The important thing is that at runtime,
    Sikuli runs computer vision software at its core that determines whether it gets
    a match for the image in the screen and acts accordingly. There is absolutely
    no need for having any knowledge of internals of the software under test. While
    this might seem counterintuitive at first, the lack of control over components
    and objects is compensated through image-based testing that liberates the test
    from the system under test, and the tests can thus operate over a wide variety
    of software platforms, from different desktop applications, mobile emulators,
    mainframe terminals, web-based, and remote applications using only the contents
    displayed on the screen as a basis for its input and decision making ability,
    just like a human being which is performing manual automated acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom Sikuli library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Out of the box, the Robot Framework seems like a complex framework and creation
    of an external user library looks like a tedious task. However, there are times
    when requirements dictate the need of acceptance test solutions for this. Fortunately,
    open source solutions like Sikuli have an extensible application platform that
    is also very well documented. The custom integration of Sikuli with Robot Framework
    is created and demonstrated by *Mykhailo Moroz* ([http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html](http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html)).
    The approach used in this method is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use the Sikuli as a test validation engine, its API ([http://doc.sikuli.org/javadoc](http://doc.sikuli.org/javadoc))
    has to be exposed first, which can be done via a clever hack that uses the Python
    classes used internally in Sikuli. Since this will work in Jython environment,
    there is a need to have `sikuli-script.jar` in the classpath and create a wrapper
    around the Sikuli API in order to use various methods. The Sikuli API contains
    a `Screen` class that has various methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make these methods present in the `Screen` class global, these methods are
    manually pushed into the internal global directory and are overridden by customized
    individual methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This lookup is then used to pass the values from the customized methods into
    the native code that is present internally in the Sikuli engine. For instance,
    the `click` method can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This wrapper allows the creation of simple Python scripts that can run in Jython
    environment without requiring the Sikuli X test runner. As there is already `sikuli-script.jar`
    in the classpath, the tests so created can run without the Sikuli IDE, or in the
    headless mode.
  prefs: []
  type: TYPE_NORMAL
- en: As these scripts can run independently in the Jython environment, these can
    be run through Jybot that can employ various Robot Framework scripts that can
    call these script functions. This creates a solution to drive a collection of
    multiple Sikuli scripts as test cases in such an order that performs a large task
    through the collection of different small scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this example, we need to have the following prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: The Robot Framework installed correctly with the Jython runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sikuli is installed properly and `sikuli-home` environment variable points to
    its root folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following commands in the batch file runs the application by setting up
    the environment needed for all the softwares involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since, we are using different Sikuli scripts as different test cases, we will
    import these as custom tests in our Robot Framework test files, which are kept
    in the `testlib` folder in order to keep things simple in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `library` file is actually a customized Sikuli script written in Python
    that calls the Sikuli API to work as a headless Sikuli instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To make these tests image-based, you can call functions such as `click`, `validate`,
    `type`, and so on, with the path to the sample image file used as its input argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the `test` and `library` files, there is a `sikuliwrapper.py` file,
    which provides Sikuli methods into these library file invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, other Sikuli API calls can also be wrapped to provide an easy interface
    to the library file, which in turn is called by the Robot Framework test.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in case of image-based testing, failures should be descriptive. To
    do this, screenshot can be taken at the instance when something fails or succeeds,
    which requires you to create a custom logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the essential files required to properly run and log the Sikuli-based
    applications easily with the Robot Framework. The output can be viewed in the
    following example by opening notepad and running the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a custom Sikuli library](img/3033OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Other noteworthy libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various other libraries that extend the capabilities of the Robot
    Framework in areas that are not normally seen as candidates for acceptance tests,
    but will benefit from test automation, if done in the right way. Some of these
    libraries are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Testing network protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rambock is a test library that provides an easy way to test various network
    packets, protocols, and message templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/robotframework/Rammbock](https://github.com/robotframework/Rammbock)'
  prefs: []
  type: TYPE_NORMAL
- en: It allows you to specify the custom protocol, its client and servers; messages,
    and both the traditional as well as custom protocols can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suds is a lightweight. but dynamic SOAP Python client for consuming web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ombre42/robotframework-sudslibrary](https://github.com/ombre42/robotframework-sudslibrary)'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The database persistence and contents can be tested through the `robotframework-databaselibrary`.
    Here the database is queried to find out its state and perform things, such as
    running the SQL scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://franz-see.github.io/Robotframework-Database-Library](http://franz-see.github.io/Robotframework-Database-Library)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar library exists for interacting through JDBC, which is handy especially
    for databases that otherwise are not supported for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/ThomasJaspers/robotframework-dblibrary](https://github.com/ThomasJaspers/robotframework-dblibrary)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, a lot of external tools and libraries were discussed that extend
    the capabilities of the Robot Framework. First the web application testing was
    demonstrated through Selenium and its REPL shell that is handy to debug applications.
    Next, Java-based desktop application testing through the use of object-based testing
    was demonstrated. The Sikuli application and image-based testing was explained
    along with an in-depth case study which further explored the extensibility of
    its API to create a Robot Framework-friendly solution. Finally, some of the other
    popular libraries were listed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into test reporting operations to understand
    what the different outputs generated and how can we perform various desired operations
    with generated reports and customize test outputs.
  prefs: []
  type: TYPE_NORMAL
