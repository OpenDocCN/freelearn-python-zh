- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: Functions, Iterators, and Generators
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、迭代器和生成器
- en: The core of functional programming is the use of pure functions to map values
    from the input domain to the output range. Avoiding side effects reduces any dependence
    on variable assignment to maintain the state of a computation. We can’t purge
    the assignment statement from the Python language, but we can reduce our dependence
    on stateful objects. This means choosing among the available Python built-in functions
    and data structures to select those that don’t require stateful operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的核心是使用纯函数将输入域的值映射到输出范围。避免副作用可以减少对变量赋值以维护计算状态的任何依赖。我们无法从Python语言中删除赋值语句，但我们可以减少对有状态对象的依赖。这意味着在可用的Python内置函数和数据结构中选择那些不需要有状态操作的选择。
- en: 'This chapter will present several Python features from a functional viewpoint,
    as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从函数式视角介绍几个Python特性，如下所示：
- en: Pure functions, free of side effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数，无副作用
- en: Functions as objects that can be passed as arguments or returned as results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为可以作为参数传递或作为结果返回的对象
- en: The use of Python’s object-oriented suffix notation and prefix notation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的面向对象后缀和前缀表示法
- en: Using tuples as a way to create immutable objects, which avoid the confusion
    of state changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元组作为创建不可变对象的方法，从而避免状态变化的混淆
- en: Using iterable collections as our primary design tool for functional programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可迭代集合作为我们进行函数式编程的主要设计工具
- en: 'We’ll look at generators and generator expressions, since these are ways to
    work with collections of objects. As we noted in [Chapter 2](Chapter_02.xhtml#x1-340002),
    [Introducing Essential Functional Concepts](Chapter_02.xhtml#x1-340002), there
    are some boundary issues when trying to replace all generator expressions with
    recursions. Python imposes a recursion limit and doesn’t automatically handle
    Tail-Call Optimization (TCO): we must optimize recursions manually using a generator
    expression.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨生成器和生成器表达式，因为这些都是处理对象集合的方法。正如我们在[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本函数式概念](Chapter_02.xhtml#x1-340002)中提到的，在尝试用递归替换所有生成器表达式时，存在一些边界问题。Python强制执行递归限制，并且不会自动处理尾调用优化（TCO）：我们必须使用生成器表达式手动优化递归。
- en: 'We’ll write generator expressions that will perform the following tasks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写生成器表达式，以执行以下任务：
- en: Conversions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换
- en: Restructuring
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重组
- en: Complex calculations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂计算
- en: We’ll take a quick survey of many of the built-in Python collections and how
    we can work with collections while pursuing a functional paradigm. This may change
    our approach to working with lists, dicts, and sets. Writing functional Python
    encourages us to focus on tuples and immutable collections. In the next chapter,
    we’ll emphasize more functional ways to work with specific kinds of collections.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速浏览许多内置的Python集合以及如何在追求函数式范式的同时处理集合。这可能会改变我们处理列表、字典和集合的方法。编写函数式Python鼓励我们关注元组和不可变集合。在下一章中，我们将强调更多与特定类型集合一起工作的函数式方法。
- en: 3.1 Writing pure functions
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1 编写纯函数
- en: 'In [Chapter 2](Chapter_02.xhtml#x1-340002), [Introducing Essential Functional
    Concepts](Chapter_02.xhtml#x1-340002), we looked at pure functions. In this section,
    we’ll look at a common problem with non-functional programming: a function that
    has a reference to a global variable. When a global variable is assigned, the
    `global` statement will be used. When a global variable is read, however, this
    is called a free variable, and there’s no obvious marker in the Python code.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本函数式概念](Chapter_02.xhtml#x1-340002)中，我们探讨了纯函数。在本节中，我们将探讨非函数式编程中常见的一个问题：一个引用全局变量的函数。当全局变量被赋值时，将使用`global`语句。然而，当全局变量被读取时，这被称为自由变量，Python代码中没有任何明显的标记。
- en: 'Any references to values in the Python global namespace (using a free variable)
    is something we can rework into a proper parameter. In most cases, it’s quite
    easy. Here is an example that depends on a free variable:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对Python全局命名空间中值的引用（使用自由变量）都可以重新设计为一个合适的参数。在大多数情况下，这相当简单。以下是一个依赖于自由变量的示例：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After refactoring the function, we would need to change each reference to this
    function. This may have a ripple effect through a complex application. We’ll leave
    the refactoring as an exercise.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构函数后，我们需要更改对这个函数的每个引用。这可能会在复杂的应用程序中产生连锁反应。我们将重构作为练习留给读者。
- en: There are many internal Python objects that are stateful. Objects used for input
    and output are generally called file objects or file-like objects; these are examples
    of stateful objects in common use. See the `io` module for more information on
    file objects. We observe that some of the commonly used stateful objects in Python
    generally behave as context managers. In a few cases, stateful objects don’t completely
    implement the context manager interface; in these cases, there’s often a `close()`
    method. We can use the `contextlib.closing()` function to provide these objects
    with the proper context manager interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python中有许多内部对象是具有状态的。用于输入和输出的对象通常被称为文件对象或类似文件的对象；这些是常用状态对象的例子。有关文件对象的更多信息，请参阅`io`模块。我们观察到Python中一些常用的状态对象通常表现为上下文管理器。在少数情况下，状态对象并没有完全实现上下文管理器接口；在这些情况下，通常有一个`close()`方法。我们可以使用`contextlib.closing()`函数为这些对象提供适当的上下文管理器接口。
- en: 'A context manager provides a way to perform operations on entry to and exit
    from a block of code. The `with` statement uses a context manager to perform the
    entry operation, execute the indented block of code, and perform the exit operation.
    It’s important to note the exit operation is always performed, even if an exception
    is raised in the indented block of code. This makes for a tidy way to perform
    state-changing operations, making the code easier to reason about. In practice,
    it looks like the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器提供了一种在代码块进入和退出时执行操作的方法。`with`语句使用上下文管理器执行进入操作，执行缩进的代码块，并执行退出操作。需要注意的是，退出操作总是执行，即使缩进的代码块中抛出了异常。这为执行状态改变操作提供了一种整洁的方式，使代码更容易推理。在实践中，它看起来像以下示例：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The file is only open for writing inside the `with` statement. This makes it
    easier to see where state-changing operations are performed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 文件仅在`with`语句内部打开用于写入。这使得更容易看到状态改变操作在哪里执行。
- en: We can’t easily eliminate all stateful Python objects. Therefore, we must strike
    a balance between managing state while still exploiting the strengths of functional
    design. To this end, we should always use the `with` statement to encapsulate
    stateful file objects into a well-defined scope.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能轻易消除所有具有状态的Python对象。因此，我们必须在管理状态的同时，仍然利用函数式设计的优势。为此，我们应该始终使用`with`语句将具有状态的文件对象封装到定义良好的作用域中。
- en: Always use file objects in a `with` context. This defines a context in which
    state-changing operations will be performed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在`with`上下文中使用文件对象。这定义了一个在此上下文中将执行状态改变操作的环境。
- en: 'We should always avoid global file objects, global database connections, and
    the associated stateful object issues. A global file object is a common pattern
    for handling open files or databases. We may have a function as shown in the following
    example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终避免使用全局文件对象、全局数据库连接以及相关的状态对象问题。全局文件对象是处理打开文件或数据库的常见模式。我们可能有一个如下所示的函数：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function creates an easily overlooked pair of global variables. Other functions
    can use the `ifile` and `ofile` variables, hoping they properly refer to the global
    files, which are left open and will endure a difficult-to-understand series of
    state changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一对容易被忽视的全局变量。其他函数可以使用`ifile`和`ofile`变量，希望它们正确地引用了全局文件，这些文件被保留打开状态，并将经历一系列难以理解的状态变化。
- en: 'This is not a very functional design, and we need to avoid it. The files should
    be proper parameters to functions, and the open files should be nested in a `with`
    statement to ensure that their stateful behavior is handled properly. This is
    an important rewrite to change these variables from globals to formal parameters:
    it makes the file operations more visible.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个很好的函数式设计，我们需要避免它。文件应该是函数的适当参数，打开的文件应该嵌套在`with`语句中，以确保它们的状态行为得到适当处理。将变量从全局变量更改为正式参数是一个重要的重写：这使得文件操作更易于可见。
- en: 'The rewrite will involve locating every function using `ifile` or `ofile` as
    free variables. For example, we might have a function like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 重写将涉及定位每个使用`ifile`或`ofile`作为自由变量的函数。例如，我们可能有一个如下所示的函数：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We’ll need to make the `ifile` global variable reference into a parameter to
    this function. This will create ripples of change to the functions that call `next_line_with()`.
    This can become an extensive rewrite to identify and localize the state changes.
    This may lead to rethinking the design to replace a function like `next_line_with()`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将`ifile`全局变量引用转换为该函数的参数。这将给调用`next_line_with()`的函数带来一系列的变化。这可能需要对识别和定位状态变化进行广泛的修改。这可能导致重新思考设计，以替换像`next_line_with()`这样的函数。
- en: 'This context manager design pattern also applies to databases. A database connection
    object should generally be provided as a formal argument to an application’s functions.
    This is contrary to the way some popular web frameworks work: some frameworks
    rely on a global database connection in an effort to make the database a transparent
    feature of the application. This transparency obscures a dependency between a
    web operation and the database; it can make unit testing more complex than necessary.
    Additionally, a multithreaded web server may not benefit from sharing a single
    database connection: a connection pool is often better. This suggests that there
    are some benefits of a hybrid approach that uses functional design with a few
    isolated stateful features.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此上下文管理器设计模式也适用于数据库。数据库连接对象通常应作为正式参数提供给应用程序的函数。这与一些流行的Web框架的工作方式相反：一些框架依赖于全局数据库连接，试图使数据库成为应用程序的一个透明特性。这种透明性掩盖了Web操作与数据库之间的依赖关系；它可以使单元测试比必要的更复杂。此外，多线程Web服务器可能不会从共享单个数据库连接中受益：连接池通常更好。这表明，使用功能设计结合少量隔离的有状态特性的混合方法有一些好处。
- en: 3.2 Functions as first-class objects
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2 函数作为一等对象
- en: In [Chapter 2](Chapter_02.xhtml#x1-340002), [Introducing Essential Functional
    Concepts](Chapter_02.xhtml#x1-340002), we looked at ways in which Python functions
    are first-class objects. In Python, function objects have a number of attributes.
    The reference manual lists a number of special member names that apply to functions.
    Since functions are objects with attributes, we can extract the docstring or the
    name of a function, using special attributes such as `__doc__` or `__name__`.
    We can also extract the body of the function through the `__code__` attribute.
    In compiled languages, this introspection can be either impossible or quite complicated.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本功能概念](Chapter_02.xhtml#x1-340002)中，我们探讨了Python函数作为一等对象的方式。在Python中，函数对象具有许多属性。参考手册列出了适用于函数的许多特殊成员名称。由于函数是具有属性的对象，我们可以使用特殊属性如`__doc__`或`__name__`来提取函数的文档字符串或名称。我们还可以通过`__code__`属性提取函数体。在编译型语言中，这种内省可能是无法实现的，或者相当复杂。
- en: Additionally, a callable object helps us to create functions. We can consider
    the callable class definition as a higher-order function. We do need to be judicious
    in how we use the `__init__()` method of a callable object; we should avoid setting
    stateful class variables. One common application is to use an `__init__()` method
    to create objects that fit the Strategy design pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可调用对象帮助我们创建函数。我们可以将可调用类定义视为高阶函数。我们确实需要在如何使用可调用对象的`__init__()`方法上谨慎行事；我们应该避免设置有状态的类变量。一个常见应用是使用`__init__()`方法创建符合策略设计模式的对象。
- en: A class following the Strategy design pattern depends on other objects to provide
    an algorithm or parts of an algorithm. This allows us to inject algorithmic details
    at runtime, rather than compiling the details into the class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循策略设计模式的类依赖于其他对象来提供算法或算法的一部分。这允许我们在运行时注入算法细节，而不是将细节编译到类中。
- en: To focus on the overall design principles, we’ll look at a function that does
    a tiny computation. This computes one of the Mersenne prime numbers. See [https://www.mersenne.org/primes/](https://www.mersenne.org/primes/)
    for ongoing research into this topic.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了专注于整体设计原则，我们将查看一个执行微小计算的函数。这个函数计算梅森素数中的一个。有关此主题的持续研究，请参阅[https://www.mersenne.org/primes/](https://www.mersenne.org/primes/)。
- en: 'Here is an example of the definition of a callable object class with an embedded
    Strategy object:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个具有嵌入策略对象的可调用对象类的定义示例：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class uses `__init__()` to save a reference to another function, `algorithm`,
    as `self.pow2`. We’re not creating any stateful instance variables; the value
    of `self.pow2` isn’t expected to change. It’s a common practice to use a name
    like `_pow2` to suggest this attribute isn’t expected to be used by a client of
    this class. The `algorithm` parameter has a type hint of `Callable[[int],`` int]`,
    which describes a function that takes an integer argument and returns an integer
    value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此类使用`__init__()`来保存对另一个函数的引用，即`algorithm`作为`self.pow2`。我们不是创建任何有状态的实例变量；`self.pow2`的值预计不会改变。使用像`_pow2`这样的名称是常见的做法，以表明这个属性不应该被此类客户端使用。`algorithm`参数的类型提示为`Callable[[int],
    int]`，它描述了一个接受整数参数并返回整数值的函数。
- en: We’ve used the `Callable` type hint from the `collections.abc` module, where
    it is defined. An alias is available in the `typing` module, but since PEP 585
    was implemented, the use of the `typing.Callable` is deprecated. We’ll use a number
    of generic types from the `collections.abc` module throughout this chapter.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`collections.abc`模块中的`Callable`类型提示，其中它被定义。在`typing`模块中有一个别名，但由于PEP 585的实施，`typing.Callable`的使用已被弃用。我们将在本章中使用`collections.abc`模块中的多个泛型类型。
- en: 'The function given as a Strategy object must raise 2 to the given power. We
    can plug in any function that performs this computation. Three candidate objects
    that we can plug into this class are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的作为策略对象的函数必须将2提升到指定的幂。我们可以插入任何执行此计算的函数。可以插入此类的三个候选对象如下：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `shifty()` function raises 2 to the desired power using a left shift of
    the bits. The `multy()` function uses a naive recursive multiplication. The `faster()`
    function uses a divide and conquer strategy that will perform log [2](b) multiplications
    instead of b multiplications.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`shifty()`函数通过位左移来将2提升到所需的幂。`multy()`函数使用简单的递归乘法。`faster()`函数使用分治策略，将执行log
    [2](b)次乘法而不是b次乘法。'
- en: All three of these functions have identical function signatures. Each of them
    can be summarized as `Callable[[int],`` int]`, which matches the parameter, `algorithm`,
    of the `Mersenne1.__init__()` method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个函数具有相同的函数签名。每个都可以总结为`Callable[[int], int]`，这与`Mersenne1.__init__()`方法的参数`algorithm`相匹配。
- en: 'We can create instances of our `Mersenne1` class with an embedded Strategy
    algorithm, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用嵌入的策略算法创建`Mersenne1`类的实例，如下所示：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each of the resulting functions, `m1s()`, `m1m()`, and `m1f()`, is built from
    another function. The functions `shifty()`, `multy()`, and `faster()` are incorporated
    into resulting functions. This shows how we can define alternative functions that
    produce the same result but use different algorithms.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的每个函数，`m1s()`、`m1m()`和`m1f()`，都是由另一个函数构建的。函数`shifty()`、`multy()`和`faster()`被纳入结果函数中。这展示了我们可以定义产生相同结果但使用不同算法的替代函数。
- en: 'The callable objects created by this class behave as ordinary Python functions,
    as shown in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由此类创建的可调用对象表现得像普通的Python函数，如下例所示：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Python allows us to compute M[89] = 2^(89) − 1, since this doesn’t even come
    close to the recursion limits in Python. This is quite a large prime number, as
    it has 27 digits. In order to exceed the limits of the `multy()` function, we’d
    have to ask for the value of M[1,279], a number with 386 digits.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们计算M[89] = 2^(89) − 1，因为这个值甚至接近Python的递归限制。这是一个相当大的质数，因为它有27位。为了超过`multy()`函数的限制，我们需要请求M[1,279]的值，这是一个有386位的数字。
- en: 3.3 Using strings
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3 使用字符串
- en: Since Python strings are immutable, they’re an excellent example of functional
    programming objects. A Python `str` object has a number of methods, all of which
    produce a new string as the result. These methods are pure functions with no side
    effects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python字符串是不可变的，它们是函数式编程对象的绝佳例子。Python的`str`对象有多个方法，所有这些方法都会产生一个新的字符串作为结果。这些方法是纯函数，没有副作用。
- en: The syntax for methods is postfix, where most functions are prefix. This mixture
    of syntax styles means complex string operations can be hard to read when they’re
    co-mingled with conventional functions. For example, in this expression, `len(variable.title())`,
    the `title()` method is in postfix notation and the `len()` function is in prefix
    notation. (We touched on this in [Chapter 2](Chapter_02.xhtml#x1-340002), [Introducing
    Essential Functional Concepts](Chapter_02.xhtml#x1-340002), in the [Familiar territory](Chapter_02.xhtml#x1-430007)
    section.)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的语法是后缀的，而大多数函数是前缀的。这种语法风格的混合意味着当与常规函数混合时，复杂的字符串操作可能难以阅读。例如，在这个表达式 `len(variable.title())`
    中，`title()` 方法是后缀表示法，而 `len()` 函数是前缀表示法。（我们在[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本功能概念](Chapter_02.xhtml#x1-340002)，[熟悉领域](Chapter_02.xhtml#x1-430007)部分中提到了这一点。）
- en: When scraping data from a web page, we may have a function to clean the data.
    This could apply a number of transformations to a string to clean up the punctuation
    and return a `Decimal` object for use by the rest of the application. This will
    involve a mixture of prefix and postfix syntax.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当从网页抓取数据时，我们可能有一个用于清理数据的函数。这可能将一系列转换应用于字符串以清理标点，并返回一个 `Decimal` 对象供应用程序的其他部分使用。这将涉及前缀和后缀语法的混合使用。
- en: 'It could look like the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像以下代码片段：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function does two replacements on the string to remove `$` and `,` string
    values. The resulting string is used as an argument to the `Decimal` class constructor,
    which returns the desired object. If the input value is `None`, this is preserved;
    this is why the `str`` |`` None` type hint is used.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数对字符串进行两次替换以移除 `$` 和 `,` 字符串值。得到的字符串用作 `Decimal` 类构造函数的参数，该构造函数返回所需的对象。如果输入值为
    `None`，则将其保留；这就是为什么使用 `str` | `None` 类型提示的原因。
- en: 'To make the syntax look more consistent, we can consider defining our own prefix
    functions for the string methods, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使语法看起来更一致，我们可以考虑为字符串方法定义我们自己的前缀函数，如下所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This can allow us to use `Decimal(replace(replace(text,`` "$",`` ""),`` ",",`` ""))`
    with consistent-looking prefix syntax. It’s not clear whether this kind of consistency
    is a significant improvement over the mixed prefix and postfix notation. This
    may be an example of a foolish consistency.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以让我们使用 `Decimal(replace(replace(text, "$", ""), ",", ""))`，具有一致的看起来像前缀语法的样式。这种一致性是否比混合前缀和后缀表示法有显著改进还不清楚。这可能是愚蠢的一致性的一个例子。
- en: 'A slightly better approach may be to define a more meaningful prefix function
    to strip punctuation, such as the following code snippet:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微更好的方法可能是定义一个更有意义的用于去除标点的函数，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This function will recursively remove each of the characters from the `chars`
    variable. We can use it as `Decimal(remove(text,`` "$,"))` to make the intent
    of our string cleanup more clear.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将递归地移除 `chars` 变量中的每个字符。我们可以使用它作为 `Decimal(remove(text, "$,"))`，以使我们的字符串清理意图更清晰。
- en: 3.4 Using tuples and named tuples
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4 使用元组和命名元组
- en: Since Python tuples are immutable objects, they’re another excellent example
    of objects suitable for functional programming. A Python tuple has very few methods,
    so almost everything is done using prefix syntax. There are a number of use cases
    for tuples, particularly when working with list-of-tuple, tuple-of-tuple, and
    generator-of-tuple constructs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 元组是不可变对象，它们是适合函数式编程的对象的另一个极好例子。Python 元组方法很少，所以几乎所有的事情都是使用前缀语法完成的。元组有许多用途，尤其是在处理列表-元组、元组-元组和元组生成器结构时。
- en: 'The `typing.NamedTuple` class adds an essential feature to a tuple: names to
    use instead of cryptic index numbers. We can exploit named tuples to create objects
    that are accretions of data. This allows us to write pure functions based on stateless
    objects, yet keep data bound into tidy object-like packages. The `collections.namedtuple()`
    can also be used to define an immutable class of objects. This lacks a mechanism
    for providing type hints, making it less desirable than the `typing.NamedTuple`
    class.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.NamedTuple` 类为元组添加了一个基本特性：使用名称而不是神秘的索引数字。我们可以利用命名元组来创建数据累积的对象。这允许我们编写基于无状态对象的纯函数，同时将数据绑定到整洁的对象包中。`collections.namedtuple()`
    也可以用来定义不可变对象类。这缺少提供类型提示的机制，使其不如 `typing.NamedTuple` 类受欢迎。'
- en: The decision to use a tuple or `typing.NamedTuple` object is entirely a matter
    of convenience. As an example, consider working with a sequence of color values
    as a three-tuple of the form `(number,`` number,`` number)`. It’s not clear that
    these are in red, green, blue order. We have a number of approaches for making
    the tuple structure explicit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元组或`typing.NamedTuple`对象的决定完全是出于方便。例如，考虑将颜色值序列作为一个形式为`(number, number, number)`的三重元组处理。这些是否按红、绿、蓝的顺序排列并不明确。我们有几种方法可以使元组结构更明确。
- en: 'One purely functional approach to expose the triple structure is by creating
    functions to pick a three-tuple apart, as shown in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一种纯粹函数式的方法来暴露三元结构是通过创建函数来分解三重元组，如下面的代码片段所示：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Given a tuple, `item`, we can use `red(item)` to select the item that has the
    red component. This style is used in a number of purely functional languages;
    it has a structure that matches mathematical abstractions nicely.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个元组`item`，我们可以使用`red(item)`来选择具有红色成分的项。这种风格在许多纯粹函数式语言中使用；它具有与数学抽象相匹配的结构。
- en: 'In Python, it can sometimes help to provide a more formal type hint on each
    variable, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有时为每个变量提供更正式的类型提示可能会有所帮助，如下所示：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This defines a new type alias, `RGB`, as a four-tuple. The `redt()` function
    is provided with a type hint of `Callable[[RGB],`` int]` to indicate it should
    be considered to be a function that accepts an argument value of the `RGB` class
    and produces an integer result. This follows other styles of functional programming
    and adds type hints that can be checked by mypy.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个新的类型别名`RGB`，作为一个四重元组。`redt()`函数提供了一个类型提示`Callable[[RGB], int]`，表示它应该被视为一个接受`RGB`类参数值并产生整数结果的函数。这遵循了其他函数式编程风格，并添加了可以被mypy检查的类型提示。
- en: 'A somewhat better technique is to use Python’s `typing.NamedTuple` class. This
    uses a class definition instead of function definitions and looks like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一种稍微更好的技术是使用Python的`typing.NamedTuple`类。它使用类定义而不是函数定义，看起来如下所示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Color` class defines a tuple with specific names and type hints for each
    position within the tuple. This preserves the advantages of performance and immutability.
    It adds the ability for the mypy program to confirm that the tuple is used properly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`类定义了一个具有特定名称和类型提示的元组，这些提示针对元组中的每个位置。这保留了性能和不可变性的优势。它还增加了mypy程序确认元组被正确使用的功能。'
- en: This also means we’ll use `color.red` instead of `red(color)`. Using an attribute
    name to access a member of a tuple seems to add clarity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们将使用`color.red`而不是`red(color)`。使用属性名来访问元组的成员似乎增加了清晰度。
- en: There are a number of additional approaches for working with immutable tuples.
    We’ll look at all of these immutable class techniques in [Chapter 7](Chapter_07.xhtml#x1-1530007),
    [Complex Stateless Objects](Chapter_07.xhtml#x1-1530007).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理不可变元组方面，还有一些额外的处理方法。我们将在[第7章](Chapter_07.xhtml#x1-1530007)，[复杂无状态对象](Chapter_07.xhtml#x1-1530007)中查看所有这些不可变类技术。
- en: 3.5 Using generator expressions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5 使用生成器表达式
- en: We’ve shown some examples of generator expressions already in the [Lazy and
    eager evaluation](Chapter_02.xhtml#x1-400004) section of [Chapter 2](Chapter_02.xhtml#x1-340002),
    [Introducing Essential Functional Concepts](Chapter_02.xhtml#x1-340002). We’ll
    show some more later in this chapter. In this section, we’ll introduce some more
    generator techniques.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第2章](Chapter_02.xhtml#x1-340002)，[介绍基本函数式概念](Chapter_02.xhtml#x1-400004)的[懒加载和急加载评估](Chapter_02.xhtml#x1-400004)部分展示了生成器表达式的几个例子。在本章中我们还将展示更多。在本节中，我们将介绍一些更多的生成器技术。
- en: Python collections are described as iterable. We can use a `for` statement to
    iterate over the values. The key mechanism is the ability of a collection to create
    an iterator object to be used by the `for` statement. This concept generalizes
    to encompass a function that is an iterator over values. We call these generator
    functions. We can also write generator expressions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python集合被描述为可迭代的。我们可以使用`for`语句遍历值。关键机制是集合能够创建一个迭代器对象，该对象由`for`语句使用。这个概念可以推广到包括一个作为值迭代器的函数。我们称这些为生成器函数。我们也可以编写生成器表达式。
- en: It’s common to see generator expressions used to create the `list` or `dict`
    literals through list comprehension or a dictionary comprehension syntax. This
    is a list comprehension example, `[``x``**2` `for` `x` `in` `range``(10)``]`,
    a kind of list display. A list comprehension is one of several places in Python
    where generator expressions are used. In this example, the list literal `[]` characters
    wrap the generator expression, `x**2`` for`` x`` in`` range(10)`. This list comprehension
    creates a list object from the enclosed generator expression.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 常常看到生成器表达式用于通过列表推导式或字典推导式语法创建`list`或`dict`字面量。这是一个列表推导式示例，`[x**2 for x in range(10)]`，一种列表展示。列表推导式是Python中使用生成器表达式的好几个地方之一。在这个例子中，列表字面量`[]`字符包围了生成器表达式`x**2
    for x in range(10)`。这个列表推导式从包含的生成器表达式创建了一个列表对象。
- en: 'The underlying `x**2`` for`` x`` in`` range(10)` expression yields a sequence
    of values. These must be consumed by a client function. The `list()` function
    can consume the values. This means we have two ways to create a list object from
    a generator expression, as shown in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基础的`x**2 for x in range(10)`表达式产生一系列值。这些值必须由客户端函数消费。`list()`函数可以消费这些值。这意味着我们有两种方式从生成器表达式创建列表对象，如下面的示例所示：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are other kinds of comprehensions to create dictionaries and sets. When
    the enclosing characters are `{}`, this is a set comprehension. When the enclosing
    characters are `{}`, and there are `:` to separate keys and values, this is a
    dictionary comprehension. In this section, we’re going to focus on the generator
    expressions, separate from the specific kind of collection object they might create.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的推导式可以创建字典和集合。当包围字符是`{}`时，这是一个集合推导式。当包围字符是`{}`，并且有`:`来分隔键和值时，这是一个字典推导式。在本节中，我们将专注于生成器表达式，而不管它们可能创建的具体集合对象类型。
- en: A collection object and a generator expression have some similar behaviors because
    both are iterable. They’re not equivalent, as we’ll see in the following code.
    Using a display object has the disadvantage of creating a (potentially large)
    collection of objects. A generator expression is lazy and creates objects only
    as required; this can improve performance.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 集合对象和生成器表达式有一些相似的行为，因为两者都是可迭代的。但它们并不相同，正如我们将在下面的代码中看到的那样。使用显示对象的一个缺点是会创建一个（可能很大的）对象集合。生成器表达式是懒惰的，并且仅在需要时创建对象；这可以提高性能。
- en: 'We have to provide two important caveats on generator expressions, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须对生成器表达式提供以下两个重要注意事项：
- en: Generators have some of the same internal methods as lists. This means we can
    apply functions like `sorted()` and `iter()` to either generators or lists. An
    exception is the `len()` function, which needs to know the size of the collection
    and won’t work for a generator.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器有一些与列表相同的方法。这意味着我们可以将`sorted()`和`iter()`等函数应用于生成器或列表。一个例外是`len()`函数，它需要知道集合的大小，因此对生成器不起作用。
- en: Generators can be used only once. After that, they appear empty.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器只能使用一次。之后，它们看起来是空的。
- en: A generator function is a function that has a `yield` expression in it. This
    makes the function act as an iterator. Each individual `yield` value must be individually
    consumed by a client function. For a tutorial introduction, see [https://wiki.python.org/moin/Generators](https://wiki.python.org/moin/Generators).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数是一个包含`yield`表达式的函数。这使得函数表现得像一个迭代器。每个单独的`yield`值必须由客户端函数单独消费。有关教程介绍，请参阅[https://wiki.python.org/moin/Generators](https://wiki.python.org/moin/Generators)。
- en: Also, see [https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions](https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还请参阅[https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions](https://docs.python.org/3/howto/functional.html#generator-expressions-and-list-comprehensions)。
- en: 'We can use something like the following to create a sequence of possible prime
    numbers:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似以下的方法来创建可能的素数序列：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function iterates through 1,024 result values. It doesn’t compute them
    eagerly, however. It is lazy, and computes values as they’re requested. The built-in
    `next()` function is one way to consume values. Here’s an example of consuming
    values from a generator function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数遍历1,024个结果值。然而，它不会急于计算它们。它是懒惰的，只在需要时计算值。内置的`next()`函数是消费值的一种方式。以下是从生成器函数中消费值的示例：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When the `candidates()` function is evaluated, it creates a generator object,
    which is saved in the variable `c`. Each time we use `next(c)`, the generator
    function computes one more value and yields it. In this example, it will get a
    new value from the `range` object, and evaluate the `m1f()` function to compute
    a new value.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `candidates()` 函数被评估时，它创建了一个生成器对象，该对象被保存在变量 `c` 中。每次我们使用 `next(c)`，生成器函数计算一个额外的值并产生它。在这个例子中，它将从
    `range` 对象中获取一个新的值，并评估 `m1f()` 函数来计算一个新的值。
- en: 'The `yield`` from` expression extends the `yield` expression. This will consume
    values from some iterator, yielding each of the values it consumes. As a small
    example, consider the following function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield` 表达式扩展了 `yield` 表达式。这将消耗来自某个迭代器的值，并为它消耗的每个值产生。作为一个小的例子，考虑以下函数：'
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each time a value is requested, it will be produced by the `yield`` from` nested
    inside the `for` statement. This will yield `i` distinct values, one from each
    request. Since `i` is set by the containing `for` statement, this will be used
    to produce ever longer sequences of numbers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 每次请求一个值时，它将由嵌套在 `for` 语句中的 `yield` 产生。这将产生 `i` 个不同的值，每个请求一个。由于 `i` 是由包含的 `for`
    语句设置的，这将用于产生越来越长的数字序列。
- en: 'Here’s what the result looks like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是结果看起来像什么：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is a generator function that we’ll use for some more examples:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个我们将用于更多示例的生成器函数：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’re locating the prime factors of a number. If the number, `x`, is even, we’ll
    yield 2 and then recursively yield all prime factors of `x`` //`` 2`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找一个数字的质因子。如果数字 `x` 是偶数，我们将产生 2，然后递归地产生 `x` 除以 2 的所有质因子。
- en: For odd numbers, we’ll step through odd values greater than or equal to 3 to
    locate a candidate factor of the number. When we locate a factor, `i`, we’ll yield
    that factor, and then recursively yield all prime factors of `x`` //`` i`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于奇数，我们将遍历大于或等于 3 的奇数值以找到该数的候选因子。当我们找到因子 `i` 时，我们将产生该因子，然后递归地产生 `x` 除以 `i` 的所有质因子。
- en: In the event that we can’t locate a factor, the number, `x`, must be prime,
    so we can yield the number.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找不到因子，那么数字 `x` 必须是质数，因此我们可以产生该数字。
- en: We handle 2 as a special case to cut the number of iterations in half. All prime
    numbers, except 2, are odd.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 2 视为一个特殊情况以减少迭代次数的一半。除了 2 以外的所有质数都是奇数。
- en: We’ve used one important `for` statement in addition to recursion. This is an
    optimization, and it’s a teaser for the content of [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006). This optimization allows
    us to easily handle numbers that have as many as 1,000 factors. (As an example,
    2^(1,000), a number with 300 digits, will have 1,000 factors.) Since the `for`
    variable, `i`, is not used outside the indented body of the statement, the stateful
    nature of the `i` variable won’t lead to confusion if we make any changes to the
    body of the `for` statement.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们除了递归之外还使用了一个重要的 `for` 语句。这是一个优化，也是对 [第 6 章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)
    内容的一个预告。这个优化使我们能够轻松地处理具有多达 1,000 个因子的数字。（例如，2^(1,000)，一个有 300 位数的数字，将有 1,000 个因子。）由于
    `for` 变量 `i` 不会在语句缩进体外部使用，因此如果我们对 `for` 语句体进行任何更改，`i` 变量的有状态性质不会导致混淆。
- en: Because the function, as a whole, is a generator, the `yield`` from` statement
    is used to consume values from the recursive call and yield them to the caller.
    It provides an iterable sequence of values as a result.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为整个函数是一个生成器，所以使用 `yield` 表达式从递归调用中消耗值并将它们产生给调用者。它提供了一个值的可迭代序列作为结果。
- en: In a recursive generator function, be careful of the `return` statement.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归生成器函数中，请注意 `return` 语句。
- en: 'Do not use the following statement: `return`` recursive_iter(args)`. It returns
    only a generator object; it doesn’t evaluate the `recursive_iter()` function to
    return the generated values. Use any of the following alternatives:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用以下语句：`return recursive_iter(args)`。它只返回一个生成器对象；它不会评估 `recursive_iter()`
    函数以返回产生的值。使用以下任何一种替代方案：
- en: 'A `yield` expression:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield` 表达式：'
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A `yield`` from` expression:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield` 表达式：'
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A function that implements the `Iterator` protocol is often described as being
    a generator function. There is a separate `Generator` protocol, which extends
    the essential `Iterator` definition. We often find that functional Python programs
    can be structured around the generator expression construct. This tends to focus
    the design effort on functions and stateless objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了 `Iterator` 协议的函数通常被称为生成器函数。还有一个独立的 `Generator` 协议，它扩展了基本的 `Iterator` 定义。我们经常发现，函数式
    Python 程序可以围绕生成器表达式结构来构建。这往往使设计工作集中在函数和无状态对象上。
- en: 3.5.1 Exploring the limitations of generators
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.1 探索生成器的限制
- en: 'We noted that there are some limitations of generator expressions and generator
    functions. The limitations can be observed by executing the following command
    snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到生成器表达式和生成器函数有一些限制。这些限制可以通过执行以下命令片段来观察到：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the first example, we saw the generator function, `pfactors1()`, created
    a generator. The generator is lazy, and doesn’t have a proper value until we consume
    the results yielded by the generator. By itself, this isn’t a limitation; lazy
    evaluation is an important reason why generator expressions fit with functional
    programming in Python.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们看到了生成器函数 `pfactors1()` 创建了一个生成器。生成器是惰性的，直到我们消耗生成器产生的结果之前，它没有正确的值。本身这并不是一个限制；惰性评估是生成器表达式适合
    Python 函数式编程的重要原因之一。
- en: In the second example, we materialized a list object from the results yielded
    by the generator function. This is handy for seeing the output and writing unit
    test cases.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，我们从生成器函数产生的结果中实例化了一个列表对象。这对于查看输出和编写单元测试用例非常有用。
- en: 'In the third example, we saw one limitation of generator functions: there’s
    no `len()`. Because the generator is lazy, the size can’t be known until after
    all of the values are consumed.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个例子中，我们看到了生成器函数的一个限制：没有 `len()`。因为生成器是惰性的，大小只能在所有值都被消耗后才能知道。
- en: 'The other limitation of a generator object is that they can only be used once.
    For example, look at the following command snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象的其他限制是它们只能使用一次。例如，看看下面的命令片段：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first evaluation of the `sum()` function performed evaluation of the generator
    object, `result`. All of the values were consumed. The second evaluation of the
    `sum()` function found that the generator object was now empty. We can only consume
    the values of a generator object once.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()` 函数的第一次评估执行了对生成器对象 `result` 的评估，所有值都被消耗了。`sum()` 函数的第二次评估发现生成器对象现在是空的。我们只能消耗一次生成器对象的值。'
- en: The generator function, `pfactorsl()`, can produce an indefinite number of generator
    objects. In many cases, we’ll define generator functions that consume the results
    yielded by other generators. In these cases, we may not be able to trivially create
    generators, but must create a whole pipeline of generators.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数 `pfactorsl()` 可以产生不定数量的生成器对象。在许多情况下，我们将定义消耗其他生成器产生的结果的生成器函数。在这些情况下，我们可能不能简单地创建生成器，而必须创建一个完整的生成器管道。
- en: Generators have a stateful life in Python. While they’re very nice for some
    aspects of functional programming, they’re not quite perfect.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在 Python 中具有有状态的生命周期。虽然它们在函数式编程的一些方面非常出色，但它们并不完美。
- en: We can try to use the `itertools.tee()` function to overcome the once-only limitation.
    We’ll look at this in depth in [Chapter 8](Chapter_08.xhtml#x1-1700008), [The
    Itertools Module](Chapter_08.xhtml#x1-1700008). It’s not a great idea because
    it can consume a great deal of memory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用 `itertools.tee()` 函数来克服只能使用一次的限制。我们将在第 8 章 [《迭代工具模块》](Chapter_08.xhtml#x1-1700008)
    中深入探讨这一点。这不是一个好主意，因为它可能会消耗大量的内存。
- en: 'Here is a quick example of its usage:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个快速使用示例：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We created two clones of the parameter generator expression, `max_tee` and `min_tee`.
    We can consume these two clones to get maximum and minimum values from the iterable.
    Interestingly, because the two clones are used serially, this leads to consuming
    a great deal of memory to cache items. This specific example often works out better
    using a list object instead of using `tee()` to clone an iterator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了参数生成器表达式的两个克隆，`max_tee` 和 `min_tee`。我们可以消耗这两个克隆来从可迭代对象中获取最大和最小值。有趣的是，由于这两个克隆是串行使用的，这导致消耗大量内存来缓存项。这个特定的例子通常使用列表对象而不是使用
    `tee()` 来克隆迭代器会更好。
- en: Once consumed, a generator object will not provide any more values. When we
    want to compute multiple kinds of reductions—for example, sums and counts, or
    minimums and maximums—we need to design with this one-pass-only limitation in
    mind.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消耗完毕，生成器对象将不再提供任何值。当我们想要计算多种类型的简化——例如，总和和计数，或最小值和最大值——时，我们需要考虑到这个单次遍历的限制。
- en: 3.5.2 Combining generator expressions
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.5.2 组合生成器表达式
- en: The essence of functional programming comes from the ways we can easily combine
    generator expressions and generator functions to create very sophisticated composite
    processing sequences. When working with generator expressions, we can combine
    generators in several ways.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的本质在于我们能够轻松地组合生成器表达式和生成器函数，以创建非常复杂的复合处理序列。当与生成器表达式一起工作时，我们可以以几种方式组合生成器。
- en: One common way to combine generator functions is when we create a composite
    function. We may have a generator that computes `(f(x)`` for`` x`` in`` some_iterable)`.
    If we want to compute `g(f(x))`, we have several ways to combine two generators.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成器函数组合在一起的一个常见方式是在创建复合函数时。我们可能有一个生成器，它计算`(f(x) for x in some_iterable)`。如果我们想计算`g(f(x))`，我们有几种方法可以组合两个生成器。
- en: 'We can tweak the original generator expression as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调整原始生成器表达式，如下所示：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While technically correct, this defeats any idea of reuse. Rather than reusing
    an expression, we rewrote it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上正确，但这却违背了重用的任何想法。我们不是重用表达式，而是重新编写了它。
- en: 'We can also substitute one expression within another expression, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在另一个表达式中替换一个表达式，如下所示：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This has the advantage of allowing us to use simple substitution. We can revise
    this slightly to emphasize reuse, using the following commands:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，即允许我们使用简单的替换。我们可以稍微修改一下，以强调重用，使用以下命令：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This has the advantage of leaving the initial expression, `(f(x)`` for`` x`` in`` some_iterable)`,
    essentially unchanged. All we did was assign the expression to a variable without
    altering the syntax.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点，即初始表达式`(f(x) for x in some_iterable)`基本上保持不变。我们所做的只是将表达式赋给一个变量，而没有改变语法。
- en: The resulting composite function is also a generator expression, which is also
    lazy. This means that extracting the next value from `g_f_x` will extract one
    value from `f_x`, which will extract one value from the source `some_iterable`
    object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的复合函数也是一个生成器表达式，它也是惰性的。这意味着从`g_f_x`中提取下一个值将从一个`f_x`中提取一个值，而`f_x`将从一个源`some_iterable`对象中提取一个值。
- en: 3.6 Cleaning raw data with generator functions
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6 使用生成器函数清理原始数据
- en: One of the tasks that arise in exploratory data analysis is cleaning up raw
    source data. This is often done as a composite operation applying several scalar
    functions to each piece of input data to create a usable dataset.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索性数据分析中出现的任务之一是清理原始源数据。这通常是通过将几个标量函数应用于每条输入数据来创建一个可用的数据集的复合操作来完成的。
- en: 'Let’s look at a simplified set of data. This data is commonly used to show
    techniques in exploratory data analysis. It’s called Anscombe’s quartet, and it
    comes from the article Graphs in Statistical Analysis, by F. J. Anscombe, that
    appeared in American Statistician in 1973\. The following are the first few rows
    of a downloaded file with this dataset:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一组简化的数据。这些数据通常用于展示探索性数据分析中的技术。它被称为安斯康姆四重奏，它来自F. J. 安斯康姆在1973年发表在《美国统计学家》上的文章《统计分析中的图表》。以下是从下载的包含此数据集的文件中的前几行：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since the data is properly tab-delimited, we can use the `csv.reader()` function
    to iterate through the various rows. Sadly, we can’t trivially process this with
    the `csv` module. We have to do a little bit of parsing to extract the useful
    information from this file. We can define a function to iterate over the raw data
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据是正确制表的，我们可以使用`csv.reader()`函数遍历各种行。遗憾的是，我们无法用`csv`模块简单地处理这个问题。我们必须进行一些解析以从该文件中提取有用的信息。我们可以定义一个函数来遍历原始数据，如下所示：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We wrapped a file in a `csv.reader()` function to create an iterator over the
    rows of raw data. The `typing` module provides a handy definition, `TextIO`, for
    file objects that read (or write) string values. Each row is a list of text values.
    It can be helpful to define an additional type, `Row`` =`` list[str]`, to make
    this more explicit.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个文件包裹在`csv.reader()`函数中，以创建对原始数据行的迭代器。`typing`模块为读取（或写入）字符串值的文件对象提供了一个方便的定义，`TextIO`。每一行是一个文本值的列表。定义一个额外的类型`Row
    = list[str]`可以使这一点更加明确。
- en: 'We can use this `row_iter()` function in the following context:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下上下文中使用这个`row_iter()`函数：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While this will display useful information, the problem is the first three
    items in the resulting iterable aren’t data. The Anscombe’s quartet file starts
    with the following header rows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这将显示有用的信息，但问题是结果的可迭代对象中的前三个项目不是数据。Anscombe的四重奏文件以以下标题行开始：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need to filter these three non-data rows from the iterable. There are several
    possible approaches. Here is a function that will excise three expected title
    rows, validate they are the expected headers, and return an iterator over the
    remaining rows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从可迭代对象中过滤掉这三行非数据行。有几种可能的方法。以下是一个函数，它将移除预期的三个标题行，验证它们是预期的标题，并返回剩余行的迭代器：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function plucks three rows from the source data, an iterator. It asserts
    that each row has an expected value. If the file doesn’t meet these basic expectations,
    it’s a sign that the file was damaged or perhaps our analysis is focused on the
    wrong file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从源数据中提取三行，一个迭代器。它断言每一行都有一个预期的值。如果文件不符合这些基本预期，这可能是一个信号，表明文件已损坏，或者我们的分析可能集中在错误的文件上。
- en: 'Since both the `row_iter()` and the `head_split_fixed()` functions expect an
    iterator as an argument value, they can be combined, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`row_iter()`和`head_split_fixed()`函数都期望一个迭代器作为参数值，因此它们可以组合，如下所示：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’ve applied one iterator to the results of another iterator. In effect, this
    defines a composite function. We’re not done, of course; we still need to convert
    the string values to the float values, and we also need to pick apart the four
    parallel series of data in each row.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将一个迭代器应用于另一个迭代器的结果。实际上，这定义了一个复合函数。当然，我们还没有完成；我们仍然需要将字符串值转换为浮点值，并且我们还需要拆分每行中的四个并行数据系列。
- en: The final conversions and data extractions are more easily done with higher-order
    functions, such as `map()` and `filter()`. We’ll return to those in [Chapter 5](Chapter_05.xhtml#x1-1000005),
    [Higher-Order Functions](Chapter_05.xhtml#x1-1000005).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的转换和数据提取使用高阶函数，如`map()`和`filter()`，会更加容易。我们将在[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)中再次回到这些内容。
- en: 3.7 Applying generators to built-in collections
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.7 将生成器应用于内置集合
- en: 'We’ll now look at ways to apply generator expressions to a number of Python’s
    built-in collections. This section will cover the following topics:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨如何将生成器表达式应用于Python的许多内置集合。本节将涵盖以下主题：
- en: Generators for lists, dicts, and sets
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、字典和集合的生成器
- en: Working with stateful collections
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有状态集合
- en: Using the `bisect` module to create a mapping
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bisect`模块创建映射
- en: Using stateful sets
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有状态的集合
- en: Each of these looks at some specialized cases of Python collections and generator
    functions. In particular, we’ll look at ways to produce a collection, and consume
    the collection in later processing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容都关注Python集合和生成器函数的一些特定案例。特别是，我们将探讨如何生成一个集合，并在后续处理中消费这个集合。
- en: This is a lead-in to the next chapter, [Chapter 4](Chapter_04.xhtml#x1-740004),
    [Working with Collections](Chapter_04.xhtml#x1-740004), which covers the Python
    collections in considerably more detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为下一章[第4章](Chapter_04.xhtml#x1-740004)，[处理集合](Chapter_04.xhtml#x1-740004)的引入，该章节详细介绍了Python集合。
- en: 3.7.1 Generators for lists, dicts, and sets
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.1 列表、字典和集合的生成器
- en: A Python sequence object, such as a list, is iterable. However, it has some
    additional features. We can think of a list as a materialized iterable. We’ve
    used the `tuple()` function in several examples to collect the output of a generator
    expression or generator function into a single tuple object. We can use the `list()`
    function to materialize a sequence to create a list object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python序列对象，如列表，是可迭代的。然而，它还有一些额外的特性。我们可以将列表视为一个具体化的可迭代对象。我们在几个示例中使用了`tuple()`函数来收集生成器表达式或生成器函数的输出到一个单一的元组对象中。我们可以使用`list()`函数将序列具体化以创建列表对象。
- en: 'In Python, a list display, or list comprehension, offers simple syntax to materialize
    a generator: we add the `[]` brackets. This is ubiquitous to the point where the
    distinction between generator expression and list comprehension can be lost. We
    need to disentangle the idea of a generator expression from a list display that
    uses a generator expression.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，列表显示或列表推导提供了简单的语法来具体化生成器：我们添加`[]`括号。这一点非常普遍，以至于生成器表达式和列表推导之间的区别可能会消失。我们需要将生成器表达式的概念与使用生成器表达式的列表显示区分开来。
- en: 'The following is an example to enumerate the cases:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个枚举案例的示例：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The first example is the `range` object, which is a type of generator function.
    It doesn’t produce any values because it’s lazy.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是`range`对象，它是一种生成函数类型。它不产生任何值，因为它懒惰。
- en: The second example shows a list composed of a single instance of the generator
    function. The `[]` syntax creates a list literal of the `range()` object without
    consuming any values created by the iterator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例显示了一个由生成函数的单个实例组成的列表。`[]`语法创建了一个不消耗迭代器创建的任何值的`range()`对象的列表字面量。
- en: The third example shows a list comprehension built from a generator expression
    that includes a generator function. The function, `range(10)`, is evaluated by
    a generator expression, `x`` for`` x`` in`` range(10)`. The resulting values are
    collected into a list object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个示例显示了一个由包含生成函数的生成器表达式构建的列表推导式。函数`range(10)`由生成器表达式`x for x in range(10)`评估。结果值被收集到一个列表对象中。
- en: We can also use the `list()` function to build a list from an iterable or a
    generator expression. This also works for `set()`, `tuple()`, and `dict()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`list()`函数从可迭代对象或生成器表达式构建列表。这也适用于`set()`、`tuple()`和`dict()`。
- en: The `list(range(10))` function evaluates the generator object. The `[range(10)]`
    list literal does not evaluate the `range(10)` generator object.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`list(range(10))`函数评估生成器对象。`[range(10)]`列表字面量不评估`range(10)`生成器对象。'
- en: While there’s shorthand syntax for `list`, `dict`, and `set` using `[]` and
    `{}`, there’s no shorthand syntax for a tuple. To materialize a tuple, we must
    use the `tuple()` function. For this reason, it often seems most consistent to
    use the `list()`, `tuple()`, and `set()` functions as the preferred syntax.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`list`、`dict`和`set`可以使用`[]`和`{}`的简写语法，但元组没有简写语法。为了实现元组，我们必须使用`tuple()`函数。因此，通常最一致的做法是使用`list()`、`tuple()`和`set()`函数作为首选语法。
- en: 'In the data cleansing code in the previous section, we used a composite function
    to create a list of four tuples. The function looked as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的数据清洗代码中，我们使用一个复合函数创建了一个包含四个元组的列表。该函数看起来如下：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We assigned the results of the `get_rows()` composite function to a name, `data`.
    Each of these rows is a collection of four (x,y) pairs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`get_rows()`复合函数的结果分配给一个名称，`data`。每一行都是一个包含四个(x,y)对的集合。
- en: 'To extract one of the (x,y) pairs, we’ll need to do a little bit more processing
    to make this useful. First, we need to pick pairs of columns from the eight-tuple.
    Since the pairs are always adjacent, we can select a pair of columns with a slice
    operation of the form `row[2`` *`` n:`` 2`` *`` n`` +`` 2]`. The idea is that
    pair n is in positions 2 × n and 2 × n + 1\. The slice expression `2`` *`` n:`` 2`` *`` n`` +`` 2`
    includes the start element, `2`` *`` n`, and stops just before the stop element,
    `2`` *`` n`` +`` 2`. We can wrap this with a reusable function, as shown in the
    following definition:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取一个(x,y)对，我们需要进行一些额外的处理以使其变得有用。首先，我们需要从八元组中挑选出列对。由于这些对总是相邻的，我们可以通过以下形式的切片操作选择一列对：`row[2*n:2*n+2]`。其思路是，对n的配对位于2×n和2×n+1的位置。切片表达式`2*n:2*n+2`包括起始元素`2*n`，并在停止元素`2*n+2`之前停止。我们可以通过以下定义中的可重用函数来实现这一点：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This function picks two adjacent columns based on a number between 0 and 3\.
    It creates a tuple object from those two columns. The `cast()` function is a type
    hint to inform the mypy tool that the result will be a two-tuple where both items
    are strings. This is required because it’s difficult for the mypy tool to determine
    that the expression `tuple(row[n`` *`` 2:`` n`` *`` 2`` +`` 2])` will select exactly
    two elements from the row collection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据0到3之间的数字选择两个相邻的列。它从这两列创建一个元组对象。`cast()`函数是一个类型提示，用于通知mypy工具结果将是一个包含两个字符串元素的二元组。这是必需的，因为mypy工具很难确定表达式`tuple(row[n*2:n*2+2])`将正好从行集合中选择两个元素。
- en: This example uses a type variable, `SrcT`, to make a deeper claim about the
    transformation. Specifically, the type variable tells people reading the code
    (and tools like mypy) that the input object types will be the resulting object
    types. If the source is, for example, an iterable of lists of `str`, then `SrcT`` =`` str`,
    and the output will be an iterator over tuples with two `str` values.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用类型变量`SrcT`来对转换做出更深入的声明。具体来说，类型变量告诉阅读代码的人（以及像mypy这样的工具）输入对象类型将是结果对象类型。例如，如果源是一个包含`str`列表的可迭代对象，则`SrcT
    = str`，输出将是一个包含两个`str`值的元组的迭代器。
- en: 'We can use the `series()` function to extract collections from the source file
    as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`series()`函数从源文件中提取集合，如下所示：
- en: '[PRE37]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We applied the `tuple()` function to a composite function based on the `series()`,
    `head_split_fixed()`, and `row_iter()` functions. Each of these expressions will
    create an object that we can reuse in several other functions. We can then do
    analysis on subsets of the source data.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`tuple()`函数应用于基于`series()`、`head_split_fixed()`和`row_iter()`函数的复合函数。这些表达式中的每一个都将创建一个我们可以用于其他几个函数的对象。然后我们可以对源数据子集进行分析。
- en: 'The `series_I` sequence looks as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`series_I`序列如下所示：'
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The other three sequences are similar in structure. The values, however, are
    quite different.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个序列在结构上相似。然而，值却相当不同。
- en: The final thing we’ll need to do is create proper numeric values from the strings
    that we’ve accumulated so that we can compute some statistical summary values.
    We can apply the `float()` function conversion as the last step. There are many
    alternative places to apply the `float()` function, and we’ll look at some choices
    in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是从我们累积的字符串中创建适当的数值，以便我们可以计算一些统计摘要值。我们可以将`float()`函数转换作为最后一步。`float()`函数可以应用于许多不同的地方，我们将在[第5章](Chapter_05.xhtml#x1-1000005)，[高阶函数](Chapter_05.xhtml#x1-1000005)中探讨一些选择。
- en: To reduce memory use and increase performance, we prefer to use generator expressions
    and functions as much as possible. These iterate through collections in a lazy
    manner, computing values only when required. Since iterators can only be used
    once, we’re sometimes forced to materialize a collection as a tuple (or list)
    object. Materializing a collection costs memory and time, so we do it reluctantly.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少内存使用并提高性能，我们尽可能多地使用生成器表达式和函数。这些以懒方式遍历集合，仅在需要时计算值。由于迭代器只能使用一次，我们有时被迫将集合实体化为元组（或列表）对象。实体化集合会消耗内存和时间，所以我们很不情愿地这样做。
- en: Programmers familiar with Clojure can match Python’s lazy generators with the
    `lazy-seq` and `lazy-cat` functions. The idea is that we can specify a potentially
    infinite sequence, but only take values from it as needed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉Clojure的程序员可以将Python的懒生成器与`lazy-seq`和`lazy-cat`函数相匹配。其思想是我们可以指定一个可能无限长的序列，但只在其需要时从中取值。
- en: 3.7.2 Using stateful mappings
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.2 使用状态映射
- en: Python offers several stateful collections; the various mappings include the
    `dict` class and a number of related mappings defined in the `collections` module.
    We need to emphasize the stateful nature of these mappings and use them carefully.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几个状态集合；各种映射包括`dict`类和定义在`collections`模块中的许多相关映射。我们需要强调这些映射的状态性质，并谨慎使用它们。
- en: 'For our purposes, learning functional programming techniques in Python, there
    are two use cases for mapping: a stateful dictionary that accumulates a mapping
    and a frozen dictionary that can’t be updated. Python doesn’t provide an easy-to-use
    definition of an immutable mapping. We can use the abstract base class `Mapping`
    from the `collections.abc` module. We can also create an immutable `MappingProxyType`
    object from a mutable mapping. For more information, see the `types` module.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，学习Python中的函数式编程技术，映射有两种用例：一个累积映射的状态字典和一个无法更新的冻结字典。Python没有提供易于使用的不可变映射定义。我们可以使用来自`collections.abc`模块的抽象基类`Mapping`。我们还可以从一个可变映射创建不可变的`MappingProxyType`对象。更多信息，请参阅`types`模块。
- en: 'The stateful dictionary can be further decomposed into the following two typical
    use cases:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 状态字典可以进一步分解为以下两个典型用例：
- en: A dictionary built once and never updated. In this case, we want to exploit
    the hashed keys feature of the `dict` class to optimize performance. We can create
    a dictionary from any iterable sequence of `(key,`` value)` two-tuples using the
    expression `dict(sequence)`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性构建且从未更新的字典。在这种情况下，我们想利用`dict`类的哈希键特性来优化性能。我们可以使用表达式`dict(sequence)`从任何`(key,
    value)`二元组可迭序列创建字典。
- en: A dictionary built incrementally. This is an optimization we can use to avoid
    materializing and sorting a list object. We’ll look at this in [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006), where we’ll look at
    the `collections.Counter` class as a sophisticated reduction. Incremental building
    is particularly helpful for memoization. We’ll defer memoization until [Chapter 10](Chapter_10.xhtml#x1-21700010),
    [The Functools Module](Chapter_10.xhtml#x1-21700010).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步构建的字典。这是一种我们可以用来避免实例化和排序列表对象的优化。我们将在第 [6章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)
    中探讨，那里我们将探讨 `collections.Counter` 类作为一个复杂归约。逐步构建对于记忆化特别有帮助。我们将把记忆化推迟到第 [10章](Chapter_10.xhtml#x1-21700010)，[Functools
    模块](Chapter_10.xhtml#x1-21700010)。
- en: 'The first example, building a dictionary once, stems from an application with
    three operating phases: gather some input, create a `dict` object, and then process
    input based on the mappings in the dictionary. As an example of this kind of application,
    we may be doing some image processing and have a specific palette of colors, represented
    by names and `(R,`` G,`` B)` tuples. If we use the GNU Image Manipulation Program
    (GIMP) file format, the color palette may look like the following command snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子，一次性构建字典，源于一个有三个操作阶段的应用程序：收集一些输入，创建一个 `dict` 对象，然后根据字典中的映射处理输入。作为这类应用的例子，我们可能在进行一些图像处理，并有一个特定的调色板颜色，由名称和
    `(R, G, B)` 元组表示。如果我们使用 GNU 图像处理程序 (GIMP) 文件格式，调色板可能看起来像以下命令片段：
- en: '[PRE39]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The details of parsing this file are the subject of [Chapter 6](Chapter_06.xhtml#x1-1260006),
    [Recursions and Reductions](Chapter_06.xhtml#x1-1260006). What’s important is
    the results of the parsing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 解析此文件的详细信息是第 [6章](Chapter_06.xhtml#x1-1260006)，[递归和归约](Chapter_06.xhtml#x1-1260006)
    的主题。重要的是解析的结果。
- en: 'First, we’ll define a `typing.NamedTuple` class `Color` as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个 `typing.NamedTuple` 类 `Color`，如下所示：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Second, we’ll assume that we have a parser that produces an iterable of `Color`
    objects. If we materialized it as a tuple, it would look like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们假设我们有一个生成 `Color` 对象的可迭代序列的解析器。如果我们将其实例化为一个元组，它将看起来像以下这样：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To locate a given color name quickly, we will create a frozen dictionary from
    this sequence. This is not the only way to get fast lookups of a color by name.
    We’ll look at another option later.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速定位给定的颜色名称，我们将从这个序列创建一个冻结字典。这不是通过名称快速获取颜色查找的唯一方法。我们将在稍后探讨另一个选项。
- en: 'To create a mapping from an iterable sequence of tuples, we will use the `process(wrap(iterable))`
    design pattern. The following command shows how we can create the color name mapping:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个元组的可迭代序列创建映射，我们将使用 `process(wrap(iterable))` 设计模式。以下命令显示了我们可以如何创建颜色名称映射：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here are three three parts to the design pattern:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式有三个部分：
- en: The source iterable is the `palette`. We could formalize this with the hint
    `Iterable[Color]`.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源可迭代序列是 `palette`。我们可以用提示 `Iterable[Color]` 来正式化这一点。
- en: The wrap is the `(c.name,`` c)` expression to transform a `Color` object to
    a `tuple[str,`` Color]` pair.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wrap 是 `(c.name, c)` 表达式，用于将 `Color` 对象转换为 `tuple[str, Color]` 对。
- en: The process is the `dict()` function to create a mapping.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该过程是使用 `dict()` 函数创建映射。
- en: 'The resulting dictionary looks as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 结果字典看起来如下：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This can also be done using a dictionary comprehension. We leave that as an
    exercise for the reader.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以通过字典推导来完成。我们将这个作为练习留给读者。
- en: Now that we’ve materialized the mapping, we can use this `dict()` object in
    some later processing for repeated transformations from color name to `(R,`` G,`` B)`
    color numbers. The lookup will be blazingly fast because a dictionary does a rapid
    transformation from key to hash value followed by lookup in the dictionary.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实例化了映射，我们可以使用这个 `dict()` 对象在后续处理中进行重复的颜色名称到 `(R, G, B)` 颜色数字的转换。查找将非常快，因为字典会快速从键到哈希值进行转换，然后在该字典中进行查找。
- en: 3.7.3 Using the bisect module to create a mapping
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.3 使用 bisect 模块创建映射
- en: In the previous example, we created a `dict` object to achieve a fast mapping
    from a color name to a `Color` object. This isn’t the only choice; we can use
    the `bisect` module instead. Using the `bisect` module means that we have to create
    a sorted sequence, which we can then search. To be perfectly compatible with the
    dictionary implementation, we can use `collections.Mapping` as the base class.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个`dict`对象来实现从颜色名称到`Color`对象的快速映射。这并不是唯一的选择；我们可以使用`bisect`模块。使用`bisect`模块意味着我们必须创建一个排序序列，然后我们可以搜索它。为了与字典实现完全兼容，我们可以使用`collections.Mapping`作为基类。
- en: The `dict` class uses a hash computation to locate items almost immediately.
    However, this requires allocating a fairly large block of memory. The `bisect`
    mapping does a search, which doesn’t require as much memory, but performance cannot
    be described as immediate. The performance drops from O(1) to O(log n). While
    this is dramatic, the savings in memory can be critical for processing large collections
    of data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`类使用哈希计算来几乎立即定位项。然而，这需要分配相当大的内存块。`bisect`映射执行搜索，不需要那么多的内存，但性能不能描述为立即。性能从O(1)下降到O(log
    n)。虽然这很显著，但内存节省对于处理大量数据集合可能是关键的。'
- en: 'A static mapping class looks like the following command snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态映射类看起来像以下命令片段：
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This class extends the abstract superclass `collections.Mapping`. It provides
    an initialization and implementations for three functions missing from the abstract
    definition. The type of `tuple[str,`` Color]` defines a specific kind of two-tuple
    expected by this mapping.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了抽象超类`collections.Mapping`。它提供了初始化和三个抽象定义中缺失的函数的实现。`tuple[str, Color]`的类型定义了这个映射期望的特定类型的两个元组。
- en: The `__getitem__()` method uses the `bisect.bisect_left()` function to search
    the collection of keys. If the key is found, the appropriate value is returned.
    The `__iter__()` method returns an iterator, as required by the superclass. The
    `__len__()` method, similarly, provides the required length of the collection.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getitem__()`方法使用`bisect.bisect_left()`函数在键的集合中搜索。如果找到键，则返回相应的值。`__iter__()`方法返回一个迭代器，这是超类所要求的。同样，`__len__()`方法提供了集合所需的大小。'
- en: This class may not seem to embody too many functional programming principles.
    Our goal here is to support a larger application that minimizes the use of stateful
    variables. This class saves a static collection of key-value pairs. As an optimization,
    it materializes two objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可能看起来没有体现太多的函数式编程原则。我们的目标是支持一个更大的应用程序，该应用程序最小化了有状态变量的使用。这个类保存了一个静态的键值对集合。作为一个优化，它实现了两个对象。
- en: An application would create an instance of this class to perform relatively
    rapid lookups of values associated with keys. The superclass does not support
    updates to the object. The collection, as a whole, is stateless. It’s not as fast
    as the built-in `dict` class, but it uses less memory and, through the formality
    of being a subclass of the `Mapping` class, we can be assured that this object
    is not used to contain a processing state.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将创建此类的一个实例以执行与键相关联的值的相对快速查找。超类不支持对象的更新。整个集合是无状态的。它不如内置的`dict`类快，但占用的内存更少，并且通过作为`Mapping`类的子类，我们可以确保这个对象不会被用来包含处理状态。
- en: 3.7.4 Using stateful sets
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 3.7.4 使用有状态的集合
- en: 'Python offers several stateful collections, including the `set` collection.
    For our purposes, there are two use cases for a set:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几个有状态的集合，包括`set`集合。对于我们的目的，集合有两个用例：
- en: A stateful `set` that accumulates items
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个累积项目的有状态`set`
- en: '`frozenset`, which can be used to optimize searches for an item'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用来优化搜索项的`frozenset`
- en: We can create `frozenset` from an iterable in the same way we create a tuple
    object from an iterable, via a `frozenset(some_iterable)` expression; this will
    create a structure that has the advantage of a very fast `in` operator. This can
    be used in an application that gathers data, creates a set, and then uses a `frozenset`
    to match other data items against the set.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过与从可迭代对象创建元组对象相同的方式从可迭代对象创建`frozenset`，即通过`frozenset(some_iterable)`表达式；这将创建一个具有非常快速的`in`操作符优势的结构。这可以在一个收集数据、创建集合，然后使用`frozenset`来匹配其他数据项与集合的应用中使用。
- en: 'We may have a set of colors that we will use as a kind of chroma-key: we will
    use this color to create a mask that will be used to combine two images. Pragmatically,
    a single color isn’t appropriate, but a small set of very similar colors works
    best. In this case, we can examine each pixel of an image file to see if the pixel
    is in the chroma-key set or not. For this kind of processing, the chroma-key colors
    can be loaded into `frozenset` before processing the target images. The set lookup
    is extremely fast.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: As with mappings—specifically the `Counter` class—there are some algorithms
    that can benefit from a memoized set of values. Some functions benefit from memoization
    because a function is a mapping between domain values and range values, a job
    where mapping works well. A few algorithms benefit from a memoized set, which
    is stateful and grows as data is processed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We’ll return to memoization in [Chapter 10](Chapter_10.xhtml#x1-21700010), [The
    Functools Module](Chapter_10.xhtml#x1-21700010).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 3.8 Summary
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we looked again at writing pure functions free of side effects.
    We looked at generator functions and how we can use these as the backbone of functional
    programming to process collections of items. We also examined a number of the
    built-in collection classes to show how they’re used in the functional paradigm.
    While the general idea behind functional programming is to limit the use of stateful
    variables, the collection objects have a stateful implementation. For many algorithms,
    they’re often essential. Our goal is to be judicious in our use of Python’s non-functional
    features.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next two chapters, we’ll look at functions for processing collections.
    After that, we’ll look closely at higher-order functions: functions that accept
    functions as arguments as well as returning functions. In later chapters, we’ll
    look at techniques for defining our own higher-order functions. We’ll also look
    at the `itertools` and `functools` modules and their higher-order functions in
    later chapters.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 3.9 Exercises
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.1 Rewrite the some_function() function
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the [Writing pure functions](#x1-520001) section, a function was shown that
    relied on a global variable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a small application that sets the global variable and calls the function.
    The application can expand on the following example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: First, create a test suite for `some_function()` and `main()`. A `doctest` suite
    embedded in docstring is shown in the example.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Second, rewrite `some_function()` to make `global_adjustment` into a parameter.
    This will lead to revising `main()` and all of the test cases.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.2 Alternative Mersenne class definition
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The examples in the [Functions as first-class objects](#x1-530002) section show
    a `Mersenne1` class that accepts a function as a parameter to the `__init__()`
    method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to provide a plug-in Strategy function as part of the class
    definition.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'This would permit the following kinds of object definitions:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The use of `staticmethod()` is essential because the `shifty()` function does
    not expect the `self` argument when it is evaluated. It’s essential to make sure
    this function is understood as being ”static”—that is, not using a `self` parameter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.3 Alternative algorithm implementations
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following algorithm:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm 4: Imperative iteration ](img/Algo_3.1.JPG)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: 'Algorithm 4: Imperative iteration'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve seen in this chapter, there are three ways to write this in Python:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: As a `for` statement that updates stateful variables
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a generator expression
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a `map()` operation to apply the function
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write all three versions in Python.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'A test case is the following data:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![V ← {7.46,6.77,12.74,7.11,7.81,8.84,6.08,5.39,8.15,6.42,5.73} ](img/file32.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: 'And the following scaling function:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![ (v-−-7.5) f(v) = 2.031 ](img/file33.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: The computed value for m is approximately zero.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.4 Map and filter
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The built-in `map()` and `filter()` functions always have an equivalent generator
    expression. In order to have consistent-looking code, a project team is wrestling
    with the idea of insisting that all code use generator expressions, avoiding the
    built-in `map()` and `filter()` functions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Take the side of only using generator expressions and provide reasons for which
    this is advantageous.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take the side of only using built-in `map()` and `filter()` functions and provide
    reasons why this alternative might be advantageous.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In looking at the reasons for the first two parts of this exercise, is there
    a clearly articulated decision on which approach is better? If not, why not? If
    so, what rule should the team use?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3.9.5 Dictionary comprehension
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the [Using stateful mappings](#x1-620002) section, we built a mapping from
    a list of two-tuples. We can also build a mapping using a dictionary comprehension.
    Rewrite the expression `dict((c.name,`` c)`` for`` c`` in`` palette)` as a dictionary
    comprehension.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 3.9.6 Raw data cleanup
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A file, `Anscombe.txt`, is almost a valid CSV format file. The problem is there
    are three lines of useless text at the beginning. The lines are easy to recognize
    because applying the `float()` function to the values in those header rows will
    raise a `ValueError` exception.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Some team members suggest using a regular expression to examine the values
    to see if they are valid numbers. This can be called Look Before You Leap (LBYL):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队成员建议使用正则表达式来检查值是否有效数字。这可以称为“三思而后行”（LBYL）：
- en: '![Algorithm 4: Imperative iteration ](img/Algo_3.2.JPG)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![算法 4：命令式迭代](img/Algo_3.2.JPG)'
- en: 'Other team members suggest using a simpler `try:` statement to uncover the
    invalid non-numeric headers and discard them. This can be called Easier to Ask
    Forgiveness Than Permission (EAFP):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 其他团队成员建议使用更简单的 `try:` 语句来揭示无效的非数字标题并丢弃它们。这可以称为“请求原谅比请求许可更容易”（EAFP）：
- en: '![Algorithm 4: Imperative iteration ](img/Algo_3.3.JPG)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![算法 4：命令式迭代](img/Algo_3.3.JPG)'
- en: 'Both algorithms work. It’s instructive to implement each one in Python to compare
    them. Here are a few starting points for comparing the algorithms:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 两个算法都有效。将每个算法用 Python 实现，以便进行比较是有教育意义的。以下是比较算法的几个起点：
- en: The LBYL variant can rely entirely on generator expressions. However, it requires
    writing a regular expression that recognizes all possible floating-point values.
    Is this a responsibility that should be part of this application?
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LBYL 变体可以完全依赖于生成器表达式。然而，它需要编写一个能够识别所有可能的浮点值的正则表达式。这是否应该是这个应用程序的一部分责任？
- en: The EAFP variant needs a separate function to implement the `try:` statement
    processing. Otherwise, it seems amenable to also being written via generator expressions
    or the `map()` function.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EAFP 变体需要一个单独的函数来实现 `try:` 语句的处理。否则，它似乎也可以通过生成器表达式或 `map()` 函数来编写。
- en: After building the two variants, which seems to be more expressive of the purpose
    of filtering and acquiring data?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了两种变体之后，哪一种似乎更能表达过滤和获取数据的目的？
- en: Join our community Discord space
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
