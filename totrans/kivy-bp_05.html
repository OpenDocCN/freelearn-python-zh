<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Making a Remote Desktop App"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Making a Remote Desktop App</h1></div></div></div><p>To summarize the networking theme started in the previous chapter, let's build another client-server application—a Remote Desktop app. This <a id="id345" class="indexterm"/>time our app will solve a more complex practical task and communicate using a "real" application-level protocol.</p><p>Let's discuss the task at hand for a moment. First, the purpose: a typical remote desktop program allows users to access other computers remotely via local area network or the Internet. It is common to use such apps for ad hoc technical support or remote assistance, for example, by IT personnel in a big company.</p><p>Second, the terminology: the <span class="emphasis"><em>host</em></span> machine is the one being remotely controlled (running the remote-control server), and the <span class="emphasis"><em>client</em></span> is the system that controls the host. Remote system management is basically the process of user interaction with the host machine using another computer system (client) as a proxy.</p><p>So, this whole endeavor boils down to the following activities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collect relevant user input (such as mouse and keyboard events) on the client and apply it to the host</li><li class="listitem" style="list-style-type: disc">Send any relevant output (most commonly a screen capture, sometimes audio, and so on) from the host machine back to the client</li></ul></div><p>These two steps are performed repeatedly until the session ends and the connection between machines is closed.</p><p>The definition that we discussed earlier is very broad and many commercial packages compete on feature completeness, some even allow you to play video games remotely—with accelerated graphics and gaming controller input. We are going to limit the scope of our work so that the project can be completed within a reasonable time:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For the user input, only clicks (or taps, there is no difference in this context) are accepted and sent over.</li><li class="listitem" style="list-style-type: disc">For the output, just the screen capture is taken, because capturing sound and streaming it over the network can be way too challenging for a tutorial.</li><li class="listitem" style="list-style-type: disc">Only Windows hosts are supported. Any recent Windows version should be fine; Windows 7 or later is recommended. We assume desktop and not WinRT or Windows Phone. There are no such restrictions on the client, as it runs a portable Kivy app.</li></ul></div><p>The last point is unfortunate, but since every system uses different APIs to take screenshots and emulate clicks, we should start with the most popular one anyway. Support for other host systems can be added to the server later; this isn't overly complex <span class="emphasis"><em>per se</em></span>, just very platform-specific.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>Regarding the OS choice: if you don't use the Windows OS, no worries. This is the same as with Android earlier: you can easily run Windows inside a virtual machine. VirtualBox VM <a id="id346" class="indexterm"/>is a go-to solution for desktop virtualization, and it is freely available from the official website at <a class="ulink" href="https://www.virtualbox.org/">https://www.virtualbox.org/</a>.</p><p>On a Mac, Parallels is a better option in terms of usability and the operating system integration. The only possible downside is its hefty price tag.</p></div></div><p>In this chapter, we will cover the following topics of interest:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing an HTTP server in Python with the help of the Flask microframework</li><li class="listitem" style="list-style-type: disc">Taking screenshots using the<a id="id347" class="indexterm"/> <span class="strong"><strong>Python Imaging Library</strong></span> (<span class="strong"><strong>PIL</strong></span>)</li><li class="listitem" style="list-style-type: disc">Emulating clicks on Windows, utilizing the WinAPI functionality</li><li class="listitem" style="list-style-type: disc">Prototyping a simple JavaScript client and using it for testing</li><li class="listitem" style="list-style-type: disc">Finally, building a Kivy-based HTTP client app for our remote desktop server</li></ul></div><div class="section" title="The server"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>The server</h1></div></div></div><p>To<a id="id348" class="indexterm"/> simplify <a id="id349" class="indexterm"/>testing and possible future integration, we want to make our server talk a well-established application-level protocol this time. Let's use<a id="id350" class="indexterm"/>
<span class="strong"><strong> Hypertext Transfer Protocol</strong></span> (<span class="strong"><strong>HTTP</strong></span>); in addition to relative simplicity and ease of testing, it has at least two more valuable qualities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Abundance of libraries to support it, both server- and client-side. This is obviously a consequence of HTTP powering the Internet, the largest and most popular network to date.</li><li class="listitem" style="list-style-type: disc">Unlike many other protocols, for HTTP we can write a very simple proof-of-concept JavaScript client that runs inside a web browser. This isn't strictly related to the topic of the book, but may prove useful in a number of scenarios, especially when debugging.</li></ul></div><p>The library <a id="id351" class="indexterm"/>of choice that we'll utilize to build the server is Flask. There is another popular Python web framework, Django, that's also highly recommended. However, Django projects generally end up being more heavyweight, so we'll stick with Flask for this simplistic server.</p><p>To install <a id="id352" class="indexterm"/>Flask on the server, the following command is sufficient:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install Flask</strong></span>
</pre></div><p>If you don't have <code class="literal">pip</code> installed, try running the <code class="literal">easy_install pip</code> command first. Depending on your Python setup, you may need to run this from a privileged user having sufficient permissions.</p><p>On Windows, Python setup tends to be much more convoluted compared to Mac OS or Linux; please see the previous chapter for more extensive details on Python package management. Alternatively, you could jump straight to the official <a id="id353" class="indexterm"/>pip reference, found at <a class="ulink" href="https://pip.pypa.io/en/latest/installing.html">https://pip.pypa.io/en/latest/installing.html</a>. This document covers the installation of <code class="literal">pip</code> across all supported operating systems.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Note that, similar to the previous project we built (the Chat application from the previous chapter), Kivy framework doesn't have to be installed on the server. Our server-side code runs headless, without any user interface whatsoever—other than perhaps an occasional console output.</p></div></div><div class="section" title="The Flask web server"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>The Flask web server</h2></div></div></div><p>A <a id="id354" class="indexterm"/>web server<a id="id355" class="indexterm"/> is usually structured as a series of handlers bound to different URLs. Such binding is commonly called <span class="emphasis"><em>routing</em></span>. The goal of Flask, among the others, is to obviate this binding and make it easy to add new routes to a program.</p><p>The simplest, one-page Flask server (let's name it <code class="literal">server.py</code>) goes like this:</p><div class="informalexample"><pre class="programlisting">from flask import Flask
app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello, Flask'

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=7080, debug=True)</pre></div><p>In Flask, routing<a id="id356" class="indexterm"/> is designated with decorators such as <code class="literal">@app.route('/')</code>, which is perfect when you only have a small number of distinct URLs.</p><p>The <code class="literal">'/'</code> route<a id="id357" class="indexterm"/> is the server root; this is the default when you type a domain name into address bar. To open the trivial website we just wrote in your browser, just go to http://127.0.0.1:7080 on the same machine (don't forget to start the server first). When you do that, a <span class="strong"><strong>Hello, Flask</strong></span> message should appear, confirming that our toy HTTP server works.</p><div class="mediaobject"><img src="graphics/B01620_05_01.jpg" alt="The Flask web server"/><div class="caption"><p>A minimalistic website powered by Flask</p></div></div><p>Those not familiar with web servers may wonder about the strange argument to <code class="literal">app.run()</code>, the <span class="strong"><strong>0.0.0.0</strong></span> IP address. That's not a valid IP address that you can connect to, as it doesn't designate a network interface by itself (it is non-routable). In the context of a server, binding to this IP usually means that we want our app to listen on all IPv4 network interfaces—that is, respond to requests from all the available IP addresses that the machine has.</p><p>This is different from the default, localhost (or 127.0.0.1) setting: listening exclusively on the localhost IP allows connections from the same machine alone, therefore, this mode of operation can be helpful for debugging or testing. In this example, however, we use a more production-oriented setting, 0.0.0.0—this makes the machine accessible from the outside world (typically, the local area network). Note that this doesn't automatically bypass the router; it should work for your LAN, but may need additional configuration to be accessible globally.</p><p>Also, don't forget to allow the server through the firewall, as it takes precedence over application-level settings.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>
<span class="strong"><strong>Choice of port</strong></span>
</p><p>The port number by itself doesn't make much sense; what matters is that you use the same number in both server and client, be it a web browser or a Kivy app.</p><p>Be aware that on almost all systems, ports below 1024 can only be opened by a privileged user account (root or Administrator). Many ports in that range are already assigned to existing services anyway, so it's not advised to pick port numbers under 1024 for the specific needs of your application.</p><p>The default port for the HTTP protocol is 80, for example, <a class="ulink" href="http://www.w3.org/">http://www.w3.org/</a> is the same as <a class="ulink" href="http://www.w3.org:80/">http://www.w3.org:80/</a>, and usually you don't need to specify it.</p></div></div><p>You might <a id="id358" class="indexterm"/>notice that web development in Python is very easy—a Python script just a couple of lines long can get you up and running with a dynamic web server. Expectedly, not everything is this simple; some things aren't immediately available in the form of reusable library.</p><p>This can be viewed as a competitive advantage, by the way: if you're struggling with implementation of a non-trivial bit of functionality, chances are that not many instances of this thing exist, if at all, which makes your product more unique and competitive in the end.</p></div><div class="section" title="Advanced server functionality – taking screenshots"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Advanced server functionality – taking screenshots</h2></div></div></div><p>Once <a id="id359" class="indexterm"/>we have decided on a protocol and a server-side toolkit, our next challenges involve taking screenshots and simulating clicks that come from the client. Just a quick reminder: in this section, we will be covering only a Windows-specific implementation; adding Mac and Linux support is left as an exercise for the reader.</p><p>Luckily, the PIL has just the function we need; by calling <code class="literal">PIL.ImageGrab.grab()</code>, we get a screenshot of our Windows desktop as an RGB bitmap. All that's left is hooking it up to Flask so that the screenshot is properly served over HTTP.</p><p>We will use a fork of an old and basically unmaintained PIL module called <span class="strong"><strong>Pillow</strong></span>. By the way, Pillow<a id="id360" class="indexterm"/> is a great open source project used by many developers; if you're looking to contribute to Python userland, look no further. A good starting point will be the official Pillow <a id="id361" class="indexterm"/>documentation at <a class="ulink" href="http://pillow.readthedocs.org/">http://pillow.readthedocs.org/</a>.</p><p>Install the library exactly like you installed Flask:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>pip install Pillow</strong></span>
</pre></div><p>Pillow comes with binaries for Windows pre-packaged, so you don't need a compiler or a Visual Studio installed on your machine.</p><p>Now we're good to go. The following code demonstrates how to serve screenshots (or any other PIL bitmaps for that matter) from a Flask server:</p><div class="informalexample"><pre class="programlisting">from flask import send_file
from PIL import ImageGrab
from StringIO import StringIO

@app.route('/desktop.jpeg')
def desktop():
    screen = ImageGrab.grab()
    buf = StringIO()
    screen.save(buf, 'JPEG', quality=75)
    buf.seek(0)
    return send_file(buf, mimetype='image/jpeg')</pre></div><p>If you're <a id="id362" class="indexterm"/>not familiar with <code class="literal">StringIO</code>, it's a file-like object that is stored in memory and not written to disk. Such "virtual files" are useful when we need to use an API that expects a file object on a vanity data. In this example, we don't want to store a screenshot, which is temporary and not reusable by definition, in a physical file. The sheer overhead of continuously dumping data on disk isn't justified; it's usually much better (and way faster) to allocate a chunk of memory and immediately free it when the response is sent.</p><p>The rest of the code should be self-evident. We're getting a <code class="literal">screen</code> picture from a <code class="literal">PIL.ImageGrab.grab()</code> call, saving it using <code class="literal">screen.save()</code> to a lossy, low-quality JPEG file to save bandwidth, and finally sending the image to user with the MIME type of <code class="literal">'image/jpeg'</code>, so that it will be immediately recognized by web browsers as a picture of the correct type.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>In this situation, as in many others, low quality is actually a desirable property of the system; we're optimizing for throughput and round-trip speed, not for visual quality of each individual frame in a series.</p><p>The same goes for the connotation of low-quality code: it's actually great to be able to produce a quick and dirty prototype sometimes, for example, when fiddling with a new concept or doing market research.</p></div></div><p>Though it seems strange at first, the <code class="literal">buf.seek(0)</code> call is needed to <span class="emphasis"><em>rewind</em></span> the <code class="literal">StringIO</code> instance; otherwise, it's at the end of the data stream and won't yield anything to <code class="literal">send_file()</code>.</p><p>Now you can test the server implementation that we have so far by pointing your browser of choice at <code class="literal">http://127.0.0.1:7080/desktop.jpeg</code> and taking a peek on the Windows desktop of the machine where the <code class="literal">server.py</code> script is running. If the code works correctly, it should produce a picture as displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/B01620_05_02.jpg" alt="Advanced server functionality – taking screenshots"/><div class="caption"><p>Windows desktop, as seen by the Flask server (fragment)</p></div></div><p>An interesting<a id="id363" class="indexterm"/> part here is the route, <span class="strong"><strong>"desktop.jpeg"</strong></span>. Naming URLs after files became somewhat customary because ancient web server tools like<a id="id364" class="indexterm"/>
<span class="strong"><strong> Personal Home Page</strong></span> (<span class="strong"><strong>PHP</strong></span>), a toy programming language suitable for building simple dynamic sites, operated on physical files. This means that there was basically no concept of routing—you could just enter the name of the script in an address bar to run it on the server.</p><p>Obviously, this created gaping chasms in the web server security, including (but not limited to) remotely viewing system configuration files by entering, for example, <code class="literal">'/../../etc/passwd'</code> in place of a URL, and being able to upload and run malicious scripts serving as Trojans (backdoors) that are used to eventually seize control of the server.</p><p>Python web frameworks have mostly learned this lesson. While you can try and replicate such an insecure setup using Python, it is both non-trivial to do and strongly discouraged. Additionally, Python libraries usually don't come bundled with bad PHP-style configurations by default.</p><p>Today, serving actual files directly from the filesystem isn't unheard of, but is used mostly for static files. Still, we sometimes name dynamic routes as if they were files (<code class="literal">/index.html</code>, <code class="literal">/desktop.jpeg</code>, and so on) to convey the semantics of what kind of content users should expect from such URLs.</p></div><div class="section" title="Emulating clicks"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Emulating clicks</h2></div></div></div><p>With the <a id="id365" class="indexterm"/>screenshots part finished, the last non-trivial bit of functionality that we need to implement on the server is click emulation. For this we won't use an external library; we'll employ WinAPI (the underlying programming interface that powers, directly or indirectly, all Windows apps) instead, using the built-in Python <code class="literal">ctypes</code> module.</p><p>But first we need to get the click coordinates from the URL. Let's use regular <code class="literal">GET</code> parameters that look like this: <code class="literal">/click?x=100&amp;y=200</code>. This should be trivial to manually test in a browser, as opposed to POST and other HTTP methods that may require additional software to emulate.</p><p>A parser for simple URL arguments is built into Flask, and they can be accessed as shown in the next code snippet:</p><div class="informalexample"><pre class="programlisting">from flask import request

@app.route('/click')
def click():
    try:
        x = int(request.args.get('x'))
        y = int(request.args.get('y'))
    except TypeError:
        return 'error: expecting 2 ints, x and y'</pre></div><p>Error handling here, of all places, is recommended when prototyping, because it's very easy to forget or send malformed parameters, so we're checking for just that— the (in)ability to get numbers from <code class="literal">GET</code> request args. Responding with an obvious error message also helps debugging when (or if) you see this message, as it's completely obvious what's going on and where to look for the problem—in the code that passed arguments to <code class="literal">/click</code>.</p><p>After we have the coordinates for a click, an invocation of WinAPI is in order. We need two functions, both residing in <code class="literal">user32.dll</code>: the <code class="literal">SetCursorPos()</code> that moves the mouse pointer, and the <code class="literal">mouse_event()</code> that simulates a number of mouse-related events, for example, the mouse button being pressed or released.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>By the way, the <code class="literal">32</code> part in <code class="literal">user32.dll</code> isn't related to your system being 32- or 64-bit. The Win32 API first appeared in Windows NT, it predates the AMD64 (x86_64) architecture by at least 7 years and is called Win32 as opposed to an older, 16-bit WinAPI.</p></div></div><p>The first argument to <code class="literal">mouse_event()</code> is an event type, which is a C enum (in other words, a set of integer constants). Let's define these constants in our Python code for the sake of readability, as using literal <code class="literal">2</code> for <span class="strong"><strong>mouse down</strong></span> and <code class="literal">4</code> for <span class="strong"><strong>mouse up</strong></span> isn't very readable. This amounts to the following lines:</p><div class="informalexample"><pre class="programlisting">import ctypes
user32 = ctypes.windll.user32  # this is the user32.dll reference

MOUSEEVENTF_LEFTDOWN = 2
MOUSEEVENTF_LEFTUP = 4</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip31"/>Tip</h3><p>For the full reference on WinAPI functions and constants, please visit the <a id="id366" class="indexterm"/>
<span class="strong"><strong>Microsoft Developer Network</strong></span> (<span class="strong"><strong>MSDN</strong></span>) site, or more specifically the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SetCursorPos()</code>: <a class="ulink" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/ms648394%28v=vs.85%29.aspx</a></li><li class="listitem" style="list-style-type: disc"><code class="literal">mouse_event()</code>: <a class="ulink" href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx">http://msdn.microsoft.com/en-us/library/windows/desktop/ms646260%28v=vs.85%29.aspx</a></li></ul></div><p>It isn't feasible to reproduce this content here due to its size, and we won't use most of the available functionality anyway; WinAPI is all-encompassing and does more or less everything, usually in more than one way.</p></div></div><p>This is the fun<a id="id367" class="indexterm"/> part: we get to actually emulate clicks. (The first part of the function, where <code class="literal">x</code> and <code class="literal">y</code> are fetched from <code class="literal">GET</code> parameters, is unchanged.) The code is as follows:</p><div class="informalexample"><pre class="programlisting">@app.route('/click')
def click():
    try:
        x = int(request.args.get('x'))
        y = int(request.args.get('y'))
    except:
        return 'error'

    user32.SetCursorPos(x, y)
    user32.mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0)
    user32.mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0)
    return 'done'</pre></div><p>This does just what it says if you try reading the code aloud: the function moves the mouse to the desired position and then simulates the left mouse button click (with button press and release being two separate actions).</p><p>Now, you should be able to manually control the mouse cursor on the host machine. Try visiting a URL such as <code class="literal">http://127.0.0.1:7080/click?x=10&amp;y=10</code> and make sure there is something in the top-left corner of the screen. You'll notice how that item gets selected.</p><p>You can even perform a double-click if you refresh the page sufficiently fast. This may require that you run the browser on another machine; don't forget to substitute the real host IP instead of <code class="literal">127.0.0.1</code>.</p></div></div></div>
<div class="section" title="JavaScript client"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>JavaScript client</h1></div></div></div><p>In this section, we <a id="id368" class="indexterm"/>will briefly cover the<a id="id369" class="indexterm"/> development of a JavaScript remote desktop client mockup, which is feasible mostly because we use the HTTP protocol. This uncomplicated client will run in the browser and serve as a prototype of the Kivy remote desktop application that we're going to build next.</p><p>If you aren't familiar with JavaScript, don't worry; the language is very easy to get into and may even look similar to Python, depending on code style. We are also going to use <span class="strong"><strong>jQuery</strong></span>
<a id="id370" class="indexterm"/> for heavy lifting, such as DOM operations and AJAX calls.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip33"/>Tip</h3><p>In a production setting, jQuery usage may be frowned upon (and rightfully so), especially when aiming for a lean, high-performance codebase. However, for quick prototyping or vanity web apps, jQuery shines because it facilitates writing functioning, albeit suboptimal, code very quickly.</p></div></div><p>For a web app, we need to serve a complete HTML page instead of just <span class="strong"><strong>Hello, Flask</strong></span>. To do this, let's create the <code class="literal">index.html</code> file that resides in a folder named <code class="literal">static</code>, where Flask expects to find it:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;Remote Desktop&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src="//code.jquery.com/jquery-1.11.1.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            // code goes here
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The preceding listing is a very basic HTML5 document. It does nothing special at the moment: jQuery is loaded from the official CDN, but that's it—no moving parts yet.</p><p>To serve this new file from Flask, replace the <code class="literal">index()</code> function in <code class="literal">server.py</code> with the following code:</p><div class="informalexample"><pre class="programlisting">@app.route('/')
def index():
    return app.send_static_file('index.html')</pre></div><p>This works just like the <code class="literal">desktop()</code> function earlier, but reads a real file from disk this time.</p><div class="section" title="Endless loop of screenshots"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Endless loop of screenshots</h2></div></div></div><p>To start off, let's<a id="id371" class="indexterm"/> display a continuous screencast: our script is going to request a new screenshot every two seconds, and then show it to the user immediately. Since we're writing a web app, all complex stuff is actually handled by the browser: an <code class="literal">&lt;img&gt;</code> tag loads an image and displays it on the screen, with very little effort on our part.</p><p>Here is the algorithm for this functionality:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Remove the old <code class="literal">&lt;img&gt;</code> tag (if any)</li><li class="listitem">Add a new <code class="literal">&lt;img&gt;</code> tag</li><li class="listitem">Repeat after 2 seconds</li></ol></div><p>In JavaScript, this can be implemented as follows:</p><div class="informalexample"><pre class="programlisting">function reload_desktop() {
    $('img').remove()
    $('&lt;img&gt;', {src: '/desktop.jpeg?' +
                Date.now()}).appendTo('body')
}

setInterval(reload_desktop, 2000)</pre></div><p>There are two things here that may need some additional insight:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">$()</code> jQuery function<a id="id372" class="indexterm"/> selects elements on the page so that we can perform various operations on them, such as <code class="literal">.remove()</code> or <code class="literal">.insert()</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Date.now()</code> returns <a id="id373" class="indexterm"/>the current timestamp, namely, the number of milliseconds since January 1, 1970. We use this number to prevent caching. It will be different on every invocation; so when appended to the (otherwise constant) <code class="literal">/desktop.jpeg</code> URL, timestamp will make it unique, as far as the web browser is concerned.</li></ul></div><p>Let's also downscale the image so that it doesn't exceed our browser window's width and remove any margins. This is also very simple to achieve; just add this small stylesheet in the <code class="literal">&lt;head&gt;</code> section of the HTML document:</p><div class="informalexample"><pre class="programlisting">&lt;style&gt;
    body { margin: 0 }
    img { max-width: 100% }
&lt;/style&gt;</pre></div><p>Try resizing the browser window and notice how the image shrinks to fit.</p><div class="mediaobject"><img src="graphics/B01620_05_03.jpg" alt="Endless loop of screenshots"/><div class="caption"><p>Remote desktop viewed in the browser, scaled to the size of the browser window</p></div></div><p>You may also<a id="id374" class="indexterm"/> notice that the image flickers when reloading. This happens because we show <code class="literal">desktop.jpeg</code> to the user immediately, before it is fully loaded. Even more problematic than visual glitches is the fixed time frame for download, which we arbitrarily chose to be two seconds. In the case of slow network connections, users won't be able to complete the download and see the whole picture of their desktop.</p><p>We are going to address these problems in the Kivy implementation of the remote desktop client.</p></div><div class="section" title="Passing clicks to host"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Passing clicks to host</h2></div></div></div><p>This is<a id="id375" class="indexterm"/> the more interesting part: we are going to capture clicks on the <code class="literal">&lt;img&gt;</code> element and pass them to the server. This is achieved using <code class="literal">.bind()</code> on (counterintuitively) the <code class="literal">&lt;body&gt;</code> element. This is because we're constantly adding and removing the image, so any events that are bound to an image instance will be lost after the next refresh (and constantly rebinding them is just unnecessarily repetitive and wrong). The code listing is as follows:</p><div class="informalexample"><pre class="programlisting">function send_click(event) {
    var fac = this.naturalWidth / this.width
    $.get('/click', {x: 0|fac * event.clientX,
                     y: 0|fac * event.clientY})
}

$('body').on('click', 'img', send_click)</pre></div><p>In this code, we're calculating the "real" click coordinates first: the image may be shrunk to fit browser width, so we compute the ratio and multiply click position by that:</p><div class="mediaobject"><img src="graphics/7849OS_05_04.jpg" alt="Passing clicks to host"/></div><p>The <code class="literal">0|expression</code> syntax in JavaScript is a superior alternative to <code class="literal">Math.floor()</code>, as it is both faster and more concise. There are minor semantic differences too, but they aren't important at this point (if at all).</p><p>Now, utilizing<a id="id376" class="indexterm"/> the jQuery <code class="literal">$.get()</code> helper function, we send the result of the previous computation to the server. There is no processing of the server's response, since we're going to display a new screenshot in a moment anyway—if there was any effect to our last action, it will be reflected visually.</p><p>Using this trivial remote desktop client, we're already able to view the screen of the remote host, launch and control programs running on that machine. Now, let's re-implement this prototype in Kivy while improving it along the way, in particular, making it more suitable for use on mobile devices, adding scrolling and removing flicker.</p></div></div>
<div class="section" title="Kivy Remote Desktop app"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Kivy Remote Desktop app</h1></div></div></div><p>It's time <a id="id377" class="indexterm"/>to build a fully functional <a id="id378" class="indexterm"/>remote desktop client using Kivy. There are several things that we can reuse from the previous app, the Chat app from <a class="link" href="ch04.html" title="Chapter 4. Kivy Networking">Chapter 4</a>, <span class="emphasis"><em>Kivy Networking</em></span>. Conceptually, these apps are quite similar: they consist of two screens each, with one screen resembling a login form with server IP address. Let's capitalize on this similarity and reuse parts of the <code class="literal">chat.kv</code> file in our brand new <code class="literal">remotedesktop.kv</code>, in particular, the <code class="literal">ScreenManager</code> setup that is practically unchanged.</p><div class="section" title="The login form"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec67"/>The login form</h2></div></div></div><p>The<a id="id379" class="indexterm"/> following listing defines the login form. It is composed of three elements—field caption, input field itself, and a login button—positioned in a row at the top of the screen:</p><div class="informalexample"><pre class="programlisting">Screen:
    name: 'login'

    BoxLayout:
        orientation: 'horizontal'
        y: root.height - self.height

        Label:
            text: 'Server IP:'
            size_hint: (0.4, 1)

        TextInput:
            id: server
            text: '10.211.55.5'  # put your server IP here

        Button:
            text: 'Connect'
            on_press: app.connect()
            size_hint: (0.4, 1)</pre></div><p>There is<a id="id380" class="indexterm"/> just one input field this time, <span class="strong"><strong>Server IP</strong></span>. In fact, you can also enter the hostname if it's resolvable from the given machine, but let's stick to this naming as it is less ambiguous. A LAN may not have a DNS server, or it may be configured in a way that does not match users' expectations about hostnames.</p><div class="mediaobject"><img src="graphics/B01620_05_05.jpg" alt="The login form"/><div class="caption"><p>The simple and unambiguous login form</p></div></div><p>It's not that IP addresses are very user-friendly, but we don't have many options here—building an autodiscovery network service to avoid this, while very much desirable in real-world scenarios, can also be very convoluted (and probably deserves its own book anyway due to the sheer number of available techniques and possible caveats).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>You need to understand basic networking in order to address machines in complex scenarios such as connecting to a machine sitting behind router. As mentioned earlier, this is pretty much out of the scope of this work, but here are some quick tips:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It's considerably easier to test network apps when all of your machines are sitting in the same network (are connected to the same router, from the same side of the router topologically).</li><li class="listitem" style="list-style-type: disc">Taking the previous point to the extreme means running every test box inside a VM on the same physical machine. This way, you can emulate any network topology you want, without the hassle of rearranging physical wires every time you want to tweak something.</li><li class="listitem" style="list-style-type: disc">To see every IP address assigned to every network interface of a computer, run <code class="literal">ifconfig</code> (on a Mac or Linux machine) or <code class="literal">ipconfig</code> (Windows). Usually, your external (Internet) IP is not among those displayed in the output, but your local (LAN) network address is.</li></ul></div></div></div><p>There isn't <a id="id381" class="indexterm"/>much else to say about the login screen, as it consists entirely of building blocks that we've already discussed during the course of this book. Let's move on to the second screen, and ultimately to the source code powering the client-server engine.</p></div><div class="section" title="The remote desktop screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec68"/>The remote desktop screen</h2></div></div></div><p>This <a id="id382" class="indexterm"/>is the second and last screen in our application, the remote desktop screen. It will be scrollable in two dimensions, given a big enough screen size on the host machine. Since full HD (1080p and more) resolutions aren't uncommon in today's mobile devices, let alone desktop computers, it may so happen that we won't need any scrolling at all.</p><p>We can build a scrolling layout based on a similar principle as the chatroom pane from the Chat app that we've built in <a class="link" href="ch04.html" title="Chapter 4. Kivy Networking">Chapter 4</a>, <span class="emphasis"><em>Kivy Networking</em></span>. As said earlier, the scrolling will be two-dimensional; an additional difference is that we don't want any overscroll (bounce back) effects this time to avoid unnecessary confusion. We are presenting a (remote) desktop to the user, and the operating system's desktop usually doesn't have this feature.</p><p>The <code class="literal">remotedesktop.kv</code> code behind this screen is actually very concise. Let's examine how different parts of it contribute to the task at hand:</p><div class="informalexample"><pre class="programlisting">Screen:
    name: 'desktop'

    ScrollView:
        effect_cls: ScrollEffect

        Image:
            id: desktop
            nocache: True
            on_touch_down: app.send_click(args[1])
            size: self.texture_size
            size_hint: (None, None)</pre></div><p>To make scrolling work, we combine <code class="literal">ScrollView</code> with <code class="literal">Image</code>, which may become larger than the available screen space.</p><p>On <code class="literal">ScrollView</code>, we set <code class="literal">effect_cls: ScrollEffect</code> to disable overscroll; if you would like to leave the overscroll behavior intact, just remove this line. Since the <code class="literal">ScrollEffect</code> name isn't imported by default, we'll have to import it:</p><div class="informalexample"><pre class="programlisting">#:import ScrollEffect kivy.effects.scroll.ScrollEffect</pre></div><p>Setting the <code class="literal">size_hint</code> property of <code class="literal">Image</code> to <code class="literal">(None, None)</code> is crucial; otherwise, Kivy will scale the image to fit, which isn't desirable in this case. The <code class="literal">size_hint</code> property set to <code class="literal">None</code> means <span class="emphasis"><em>let me set the size manually</em></span>.</p><p>Then, we<a id="id383" class="indexterm"/> do just that, binding the <code class="literal">size</code> property to <code class="literal">self.texture_size</code>. With this setting, the image will be of the same size as a <code class="literal">desktop.jpeg</code> texture provided by the server (it depends on the host machine's physical desktop size, obviously, so we cannot hard-code it).</p><p>There is also the <code class="literal">nocache: True</code> property that instructs Kivy to never cache the desktop image that is temporary by definition.</p><p>Last but not least, an interesting property of <code class="literal">Image</code> is its <code class="literal">on_touch_down</code> handler. This time, we want to pass the exact coordinates and other properties of the touch event, and that's exactly what <code class="literal">args[1]</code> means. In case you're wondering, <code class="literal">args[0]</code> is the widget being clicked; in this case that's the image itself (we have just one <code class="literal">Image</code> instance, so there's no need to pass it to the event handler).</p></div><div class="section" title="Loop of screenshots in Kivy"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Loop of screenshots in Kivy</h2></div></div></div><p>Now we're <a id="id384" class="indexterm"/>going to assemble everything together in Python. As opposed to the JavaScript implementation, we don't get the image loading and related functionality entirely for free, so there will be a bit more code; still, it's pretty easy to implement these, while maintaining better control over the whole process, as you will see shortly.</p><p>In order to load images asynchronously, we're going to use the Kivy built-in class called <code class="literal">Loader</code>, from the <code class="literal">kivy.loader</code> module. The program flow will go like this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">When a user clicks or taps on <span class="strong"><strong>Connect</strong></span> on the login screen after filling the <span class="strong"><strong>Server IP</strong></span> field, the <code class="literal">RemoteDesktopApp.connect()</code> function is invoked.</li><li class="listitem">It passes control to <code class="literal">reload_desktop()</code>, the function that starts the image download from the <code class="literal">/desktop.jpeg</code> endpoint.</li><li class="listitem">When the image is loaded, <code class="literal">Loader</code> invokes <code class="literal">desktop_loaded()</code>, which puts the image on the screen and schedules the next call of <code class="literal">reload_desktop()</code>. Thus, we get an asynchronous endless loop retrieving screenshots from the host system.</li></ol></div><p>The image is put on the screen <span class="emphasis"><em>after</em></span> it was successfully loaded, so there will be no flickering this time like there was in the JavaScript prototype. (It's solvable in JS too, certainly, but that's not the goal of this write-up.)</p><p>Let's take a closer look at the aforementioned functions in <code class="literal">main.py</code>:</p><div class="informalexample"><pre class="programlisting">from kivy.loader import Loader

class RemoteDesktopApp(App):
    def connect(self):
        self.url = ('http://%s:7080/desktop.jpeg' %
                    self.root.ids.server.text)
        self.send_url = ('http://%s:7080/click?' %
                         self.root.ids.server.text)
        self.reload_desktop()</pre></div><p>We <a id="id385" class="indexterm"/>save <code class="literal">url</code> (the full location of <code class="literal">/desktop.jpeg</code> together with the server IP) and <code class="literal">send_url</code> (the location of <code class="literal">/click</code> endpoint to pass clicks to host), and then pass the execution to the <code class="literal">RemoteDesktopApp.reload_desktop()</code> function, which is also very brief:</p><div class="informalexample"><pre class="programlisting">def reload_desktop(self, *args):
    desktop = Loader.image(self.url, nocache=True)
    desktop.bind(on_load=self.desktop_loaded)</pre></div><p>In the preceding function, we start downloading the image. When it's complete, the freshly loaded image will be passed on to <code class="literal">RemoteDesktopApp.desktop_loaded()</code>.</p><p>Don't forget to disable the default aggressive caching by passing the <code class="literal">nocache=True</code> argument. Omitting this step will result in the <code class="literal">desktop.jpeg</code> image loading only once, because its URL stays the same. In JavaScript, we solved the same problem by appending <code class="literal">?timestamp</code> to the URL to make it unique, and we could certainly mimic such behavior in Python, but that's a hack. Kivy's way of specifying <code class="literal">nocache</code> is cleaner and more readable.</p><p>Here, you can observe the culmination of the image downloading procedure:</p><div class="informalexample"><pre class="programlisting">from kivy.clock import Clock

def desktop_loaded(self, desktop):
    if desktop.image.texture:
        self.root.ids.desktop.texture = \
            desktop.image.texture

    Clock.schedule_once(self.reload_desktop, 1)

    if self.root.current == 'login':
        self.root.current = 'desktop'</pre></div><p>This function receives the new image, <code class="literal">desktop</code>. Then, we proceed to replace the texture on screen with the freshly loaded one and schedule the next iteration of the screenshot loop to occur in a second.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip34"/>Tip</h3><p>The <code class="literal">Clock</code> object was discussed briefly in our first project (<a class="link" href="ch01.html" title="Chapter 1. Building a Clock App">Chapter 1</a>, <span class="emphasis"><em>Building a Clock App</em></span>). There, we used it to perform periodical actions by calling <code class="literal">schedule_interval()</code>, similar to <code class="literal">setInterval()</code> in JavaScript; in this case, we want a one-time invocation, <code class="literal">schedule_once()</code>, along the lines of <code class="literal">setTimeout()</code> in JS.</p></div></div><p>Now, it is<a id="id386" class="indexterm"/> time to switch screens from login to the remote desktop screen. The following screenshot summarizes what we have so far:</p><div class="mediaobject"><img src="graphics/B01620_05_06.jpg" alt="Loop of screenshots in Kivy"/><div class="caption"><p>A read-only (still unable to pass clicks back to host) Remote Desktop app</p></div></div></div><div class="section" title="Sending clicks"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Sending clicks</h2></div></div></div><p>The<a id="id387" class="indexterm"/> remote desktop viewer is ready and features scrolling and instant transition between frames (no flickering whatsoever). There is one last thing left to implement: sending clicks to host. For this, we will listen to the <code class="literal">on_touch_down</code> event on the image and pass the coordinates of touches to an event handler function, <code class="literal">send_click()</code>.</p><p>This is where it happens in <code class="literal">remotedesktop.kv</code>:</p><div class="informalexample"><pre class="programlisting">Screen:
    name: 'desktop'

    ScrollView:
        effect_cls: ScrollEffect

        Image:
            on_touch_down: <span class="strong"><strong>app.send_click(args[1])</strong></span>
            # The rest of the properties unchanged</pre></div><p>To put it in context, here is the Python counterpart in <code class="literal">class RemoteDesktopApp</code>:</p><div class="informalexample"><pre class="programlisting">def send_click(self, event):
    params = {'x': int(event.x),
              'y': int(self.root.ids.desktop.size[1] -
                       event.y)}
    urlopen(self.send_url + urlencode(params))</pre></div><p>We <a id="id388" class="indexterm"/>gather the click coordinates and feed them to the server via HTTP <code class="literal">GET</code> request using the network-related functions from the Python's standard library.</p><p>One major caveat here is the coordinate system: in Kivy, the <span class="emphasis"><em>y</em></span> axis is upwards, while it's usually downwards in Windows and elsewhere (for example, in browsers). To fix this, we subtract <code class="literal">event.y</code> from the desktop height.</p><p>Another slightly less problematic aspect is the use of Python's standard library across different Python versions: the <code class="literal">urllib[2]</code> module's structure was changed significantly in transition from Python 2 to Python 3.</p><p>To account for these changes, we can use the following way of doing imports:</p><div class="informalexample"><pre class="programlisting">try:  # python 2
    from urllib import <span class="strong"><strong>urlencode</strong></span>
except ImportError:  # python 3
    from urllib.parse import <span class="strong"><strong>urlencode</strong></span>

try:  # python 2
    from urllib2 import <span class="strong"><strong>urlopen</strong></span>
except ImportError:  # python 3
    from urllib.request import <span class="strong"><strong>urlopen</strong></span>
</pre></div><p>While not strikingly beautiful, this approach should help you with the Python upgrade, should you attempt it. (Targeting a fixed version of Python is also perfectly acceptable, by the way. In fact, many companies do just that at the time of this writing, including the very employer of Guido van Rossum, creator of the Python programming language.)</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>In this case, the Python standard library is perfectly fine; however, if at any time you find yourself writing repetitive, boring, and unimaginative HTTP-related code, consider using an excellent <span class="strong"><strong>Requests</strong></span> library<a id="id389" class="indexterm"/> by Kenneth Reitz instead. Visit <a class="ulink" href="http://python-requests.org/">http://python-requests.org/</a> for more information and examples. It's pretty amazing how concise and to the point its syntax is. Wholeheartedly recommended, this library is a work of art.</p></div></div></div><div class="section" title="What's next"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec71"/>What's next</h2></div></div></div><p>Now, you have a Remote Desktop app that mostly works as intended, especially over LAN or a fast Internet connection. As usual, there are many additional problems to solve and a lot of <a id="id390" class="indexterm"/>new features to implement if you're interested and willing to tackle with this topic some more:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Send mouse movement as a separate event. This may also apply to double clicks, drag and drop, and so on.</li><li class="listitem" style="list-style-type: disc">Try to account for network latency. If the user is on a slow connection, you can turn image quality further down on the server to compensate. Providing the user with a visual clue that something is happening in the background also helps.</li><li class="listitem" style="list-style-type: disc">Make the server cross-platform so that it runs on a Mac, Linux, and maybe even Android and Chrome OS.</li></ul></div><p>Also, remember that this is an industry-strong task. It is objectively hard to build such software, let alone make it flawless and blazing fast. Kivy helps a great deal on the UI side of things, facilitates image downloading and caching, but that's it.</p><p>So, don't worry if something doesn't work immediately as you implement it—trial and error is not at all uncommon in this case. At times, you just need to keep putting one foot in front of the other.</p><p>There is much to learn in the field of networking, and engineers knowledgeable in this field are few and valued highly, so it certainly pays off to dig into the topic of computers communicating with other computers.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Summary</h1></div></div></div><p>This constitutes the Remote Desktop app walkthrough. The resulting application can be actually used for simple tasks, for example, occasionally clicking on the <span class="strong"><strong>Play</strong></span> button in iTunes or closing a program. More demanding interactions, in particular administrative tasks, may require much more complex software.</p><p>We also built a Flask-powered web server capable of dynamically producing images and interacting with the host system. On top of it, we launched a "light" JavaScript version of the app featuring pretty much the same functionality. The morale of this story is that our Kivy app does not exist in isolation. Far from it, in fact: we've actually had a server together with the working prototype of a client app—all before writing even a single line of Kivy-related code.</p><p>As a general rule, it helps immensely to build your software in such an order so that you can test every part of it immediately. I'm not talking about <span class="strong"><strong>test-driven development</strong></span> (<span class="strong"><strong>TDD</strong></span>) here, as it's arguable whether full-fledged, exclusively test-driven programming helps the cause or not. But even just being able to fiddle with each piece of functionality as it comes together is infinitely more productive than writing a huge pile of code up front.</p><p>Finally, Kivy is well-equipped when it comes to networked GUI apps. For example, the Twisted integration that we used in the previous chapter, and the support for loading textures over the network—these things help immensely to build multi-user, Internet apps.</p><p>Now, let's jump to another topic altogether: Kivy game development.</p></div></body></html>