<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Design Strategy, Guidelines, and Best Practices</h1>
                </header>
            
            <article>
                
<p>In the today's digitalized world, the challenges are about interconnecting various heterogeneous devices with abundant software services available across the internet and intranets. The <strong>applicatio</strong><strong>n programmable interface</strong> (<strong>API</strong>) is one of the most promising software paradigms to address a<em>nything</em>, <em>anytime</em>, <em>anywhere</em>,<em> </em>and <em>any device,</em> which is the one substantial need of the digital world at the moment. This chapter discusses how APIs and API designs help to address those challenges and bridge the gaps.</p>
<p><span>This chapter discusses a few essential API design guidelines, such as consistency, standardization, reusability, and accessibility through REST interfaces, which could equip API designers with better thought processes for their API modeling.</span></p>
<p>The following are this chapter's objectives:</p>
<ul>
<li>Learning about REST API and its importance</li>
<li>Goals of RESTful API design</li>
<li>API designer roles and responsibilities</li>
<li>API design principles</li>
<li>RESTful API design rules</li>
</ul>
<p><span>Also, this chapter intends to introduce a few traits and constituents of better REST API implementations along with a few common, but avoidable, mistakes of API strategies.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>This chapter is primarily intended to introduce readers to various RESTful design concepts involving design strategies and best practices; we expect that readers already have a basic understanding of software design concepts, client-server architecture, and basic data exchange formats, such as JSON and XML.</p>
<p class="mce-root"/>
<p>We assume readers have a basic understanding of web architecture, HTTP methods, headers, and related client-server concepts. However, we strongly encourage our readers to refresh their knowledge of design principles such as SOLID, OO designs, enterprise integration, SOA, and microservice architecture fundamentals.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about REST API and its importance</h1>
                </header>
            
            <article>
                
<p>In the first chapter, we learned about RESTful principles such as client-server, statelessness, cacheable, and layered, and we'll recognize and apply those principles to the low-level yet functional APIs in this chapter. Also, we will learn RESTful API design strategies and best practices that can help us to meet the challenge of <em>any time</em><em><span class="IntenseQuoteChar">, anywhere, </span></em><span class="IntenseQuoteChar">and</span><em><span class="IntenseQuoteChar"> any device</span></em>.</p>
<p>Let's think of an example—assume you're going to an event, where along with other activities there will be a screening of the film <em>Solo</em> (the latest in the <em>Star Wars</em> series), and you know that some of your friends joining the party aren't familiar with <em>Star Wars</em> and the earlier sequels. So being a tech geek, you wanted to help your friends with a simple mobile application that can send search results to your WhatsApp group as messages with details about <em>Star Wars</em> characters, lists of films, starships, and so on; also it sends messages when any of your friends ask for any specific information.</p>
<p>But how can a standalone mobile application get data about <em>Star Wars</em>, how will it use WhatsApp to reply, how can we integrate three different systems (mobile, messaging, and data) and help your friends with their <em>Star Wars</em> queries?</p>
<p>Do we need to create a massive dataset of <em>Star Wars</em> by ourselves? How will the mobile app leverage WhatsApp messaging abilities to send star wars information? How can the message be a search string for our app? And we don't know yet how many more unknowns that we need to solve as part of the development.</p>
<p>And you think it would be great if the <em>Star Wars</em> dataset was readily available and searchable, and there should be an ability within WhatsApp to programmatically send messages to your friends.</p>
<p>After some research say we found the following list of items that gave us the confidence to build a mobile app within a short time:</p>
<ul>
<li>A readily available dataset about <em>Star Wars</em> at SWAPI (<a href="https://swapi.co/">https://swapi.co/</a>) that the app can leverage, and, not only that, it also exposes a mechanism that we can search and get responses, so we have a solution for the dataset/data store about star wars</li>
<li>WhatsApp also provides out-of-the-box messaging capabilities that your program can use to send the messages</li>
</ul>
<p>With the preceding information, let's <span><span>put the </span></span>following cues in sequence to visualize the app:</p>
<ol>
<li>A friend is asking about Beru on Whatsapp, and so the app picks it up.</li>
<li>The app uses <a href="https://swapi.co/api/people/?search=beru">https://swapi.co/api/people/?search=beru</a>.</li>
<li>The SWAPI REST API sends a response to the app's request. The app creates a text with details about Beru from the received response.</li>
<li>The app builds a <em>click chat</em> API request and sends the message to the group.</li>
<li><kbd>https://api.whatsapp.com/send?text=&lt;"Beru Whitesun Lars, born: '47BBY', she belongs to <em>Human</em> Species and from <em>Tatooine</em> Planet"&gt;</kbd>.</li>
<li>Your friend/groups receive the message—<kbd>Beru Whitesun Lars, born: "47BBY", she belongs to "Human" Species and from "Tatooine" Planet</kbd>.</li>
</ol>
<p>So, by having all necessary details about those REST APIs, you gain confidence to build a mobile app that helps you to send search results as a message to your WhatsApp group, and you are ready to rock the party. Interesting, isn't it?</p>
<p>So, now you know SWAPI and click chat (<a href="http://api.whatsapp.com">http://api.whatsapp.com</a>) are REST APIs and can be consumed by any applications as your mobile app consumes those APIs. With our example, can we say that the app is an attempt to address the digitization challenge of <em>any time, anywhere,</em> and<em> any device</em> with RESTful APIs?</p>
<p>Google Maps and Locations, Apple iTunes, Google Books, UK police forces (<a href="https://data.police.uk/api/forces">https://data.police.uk/api/forces</a>), sunrise and sunset timings (<a href="https://sunrise-sunset.org/api">https://sunrise-sunset.org/api</a>), and the British National Bibliography (<a href="http://bnb.data.bl.uk">http://bnb.data.bl.uk</a>) are few examples of public APIs.</p>
<p>The REST API examples that we have so far are more reading operations. However, in reality, the APIs can do a lot more, and we will show how well we can design RESTful APIs that can support <strong>create, read, update, and delete (CRUD</strong>) operations, pagination, filtering, sorting, searching, and much more as you read through this book.</p>
<p>We encourage you to get to know various publicly available APIs, their purpose, response formats, and so on as it will help you to understand and follow the further discussions in this chapter.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Goals of RESTful API design</h1>
                </header>
            
            <article>
                
<p>From the API examples that we've seen so far, you might have observed that they're straightforward, unambiguous, easy to consume, well-structured, and most importantly accessible with well-known and standardized HTTP methods.</p>
<p>By now, we have a fair understanding of the APIs, and that they are one of the best possible solutions for resolving many digitization challenges out of the box; with our earlier examples, we also know who is consuming those APIs. Now let's ponder how we can create such usable APIs and expose them for consumption. Are there any basic and necessary principles for designing APIs that we must take into account even before we delve into API design? What should the API allow the consumers to do with it? What do the consumers want to do with it? To answer our questions, we will need to understand the following API design goals:</p>
<ul>
<li><span>Affordance</span></li>
<li>Loosely coupled</li>
<li>Leverage existing web architecture</li>
</ul>
<p>Let's discuss them in a bit more detail.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Affordance</h1>
                </header>
            
            <article>
                
<p>Let's discuss a fundamental design concept called <strong>affordance</strong> as it can yield answers to the various questions that we had. Affordance means how an object and its properties are perceived by its design. Here it provides a clue about its operation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c8468786-89f1-446e-88ae-76bf0aecb188.png" style="width:15.67em;height:9.08em;"/></div>
<p>The preceding diagram helps us to understand what affordance is in the design world that we're talking about; among the switches that we see, the first one represents a swivel operation, and another indicates an upward and downward operation. So, by merely seeing those objects, we can perceive what it supports and how. In the case of API design, affordance undoubtedly plays a crucial role, and it is an essential aspect of our API designs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Loosely coupled</h1>
                </header>
            
            <article>
                
<p>As the whole purpose of an API is to connect heterogeneous clients with the same backend code, it's inevitable that APIs should be as independent as possible and as loosely coupled as possible with the calling clients.</p>
<p>In a loosely coupled design, APIs are independent, and modifications in one won't impact the operation of consumers. Within an API, the components get added, modified, or replaced. However, the loose coupling approach offers clients better flexibility and reusability of APIs while its elements are added, replaced, or changed.</p>
<p>Having a loosely coupled architecture in REST API server designs facilitates the client and server as both follow and respect common semantics. If the API modifies the meaning of its response, then the client needs to be aware of it and act on those new responses accordingly.</p>
<p>Well-designed APIs exhibit loose coupling and well-composed functionalities across service boundaries to maximize scalability factors.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leverage web architecture</h1>
                </header>
            
            <article>
                
<p>Since its invention by Sir Tim Berners-Lee in 1989, the fundamentals of the web remain as the foundations of all web architecture even today. As you all know, HTTP is the lifeline of the web architecture, and it powers every single client request, server response, and transfer of a document/content over all of the web. So, it is imperative that REST APIs should embrace its bursting power by building interfaces that can be consumed by any device or operating system.</p>
<p>RESTful APIs should use HTTP as a transport layer since the infrastructure, server and client libraries for HTTP are widely available already.</p>
<p>RESTful APIs should take advantage of HTTP methods, or verbs, such as <kbd>GET</kbd>, <kbd>PUT</kbd> and <kbd>POST</kbd> defined by the RFC 2616 protocol. </p>
<div class="packt_infobox">RFC 2616 (<a href="https://tools.ietf.org/html/rfc2616">https://tools.ietf.org/html/rfc2616</a>) defines Internet standards for HTTP (the application-level protocol for distributed, collaborative, and hypermedia information systems).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API designer roles and responsibilities </h1>
                </header>
            
            <article>
                
<p class="mce-root">Before we discuss API design goals, principles and practices, let's touch upon the primary roles of a software architect, solution architect, software designer, or anyone who's ready to take responsibility for designing RESTful APIs.</p>
<p>To produce successful APIs, an API designer should have or do the following:</p>
<ul>
<li>Be well-versed in REST fundamentals and API design best practices</li>
<li>Be acquainted with API design patterns to create a modern API design</li>
<li>Focus on the factors discussed in this chapter such as API design goals and best practices that can<span> </span>improve <span>the application </span>developer's experience</li>
<li>Translate the business domain into several APIs by having a clear understanding of the business vision and its functions</li>
<li>Closely work with API developers and help them with their day-to-day constraints and to deal with their existing legacy architecture</li>
<li>Set up feedback loops that involve developer feedback sessions, prototypes, beta users, release, and versioning</li>
<li>Use the feedback loops to incorporate acumens in their API design and move faster with API development</li>
<li>Create best-in-class documentation, reusable code libraries, sample codes, and tutorials</li>
</ul>
<p>Now that we understand the API designer's roles and responsibilities, let's move on to how one can design successful APIs with some of the industry API best practices in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API design best practices</h1>
                </header>
            
            <article>
                
<p>Let's think about who the consumers of any web service APIs are. Will it be another system, another software application, or an end-user? Mostly, the consumers of the APIs are another software application or another system itself. So, we can conclude that the customers of any API will be the app developers who give life to the software make it purposeful and usable by their programming codes. So the APIs are heavily dependent on the application developers or app developers.</p>
<p class="mce-root"/>
<p>So application developers should be the primary focus of API design, and for them to consume the APIs, there should be defined and accessible business functions. Please do remember that without any application developer or <span><span>app </span></span>developers ready to use the API, the API will cease to exist.</p>
<p>The following is a list of best practices used by API designers to produce APIs that app developers like to use:</p>
<ul>
<li><span>Keep APIs simple and easy to use—s</span>implified, friendly, and intuitive APIs always attract APP developers (clients for our API), get the best out of the APP developer, and make the APP developer's life more comfortable, less painful, and more productive.</li>
<li>Expose well-defined and <span>instantly recognizable</span> business functions.</li>
<li>Make APIs accessible with any standard web browsers—exposing APIs with existing web infrastructure (<span>HTTPs <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd> , and <kbd>DELETE</kbd></span>) and so accessible through a standard browser makes underlying APIs platform independent.</li>
<li>Abstract service internals and domain models—the best APIs expose only URIs and payloads and not the service internals or domain models. An example is <a href="https://www.googleapis.com/books/v1/volumes">https://www.googleapis.com/books/v1/volumes</a>.</li>
<li>Ensure RESTful API payloads don't have any traces of SOAP payloads as the clients are not the same (machines versus humans).</li>
<li>Be consistent—API implementations should be free from variation or contradiction; carry consistency across APIs by setting clear standards to help consumers with what to expect from the API, and implement similar behaviours such as searching and filtering (or pagination and limits) in the same way.</li>
<li>Implement the standard URL pattern—an example of the standard URL pattern is <kbd>/collection/item/collection/item</kbd> , and the <kbd>/collection</kbd> <span>can be books, dogs, events (plural), and so on.</span></li>
<li>Exercise standard terminology—following standard and meaningful elements in the URI is critical for API success. An example of standard terminology would be <kbd>bookId</kbd><span>,</span> <kbd>dogId</kbd> and <kbd>eventId</kbd><span>, and</span> not<span> </span><kbd>bId</kbd><span>,</span> <kbd>dId</kbd> and <kbd>eId</kbd><span>.</span></li>
<li>Be flexible—APIs are flexible to accept input from clients. An example would be <kbd>/planner/v1/tasks or /planner/v1/Tasks or /planner/v1/TASKS</kbd>; <span>lowercase, uppercase, or camel case in the preceding example should be acceptable and should behave in the same way</span>.</li>
<li>Be stable—incremental modifications to the APIs are inevitable, but it should be independent of the client applications. In other words, no forced amendments to the clients who consume the APIs that undergo modifications. Say, <kbd>/books/v1/volumes</kbd> involves no changes to the clients and provide additional benefits/defect fixes when the volume module goes through some changes.</li>
<li>There should be a clear handle for errors and error messages—API implementations shouldn't just provide better business functions; it is critical that it handles the errors and error messages well to help clients with useful and human-readable error messages, including diagnostic information that can be understood by the app developer, as error messages give hints and assist the APP developers to resolve issues that may otherwise result in an error.</li>
<li>Documentation—APIs are discoverable and documented, so publishing the API documentation is a must. API documentation includes a getting-started guide, sample codes, sample requests, sample responses, sample implementations, elaborate explanations about authentication and error handling, information about feedback avenues, and so forth.</li>
<li>Provide feedback and support mechanism for API users.</li>
</ul>
<p>Would it be good to have API design practices so you can jump-start the API design? No, not yet. We need to get to know about a few core API design principles, which we will review next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API design principles</h1>
                </header>
            
            <article>
                
<p><span>To create flexible, scalable, and secure APIs, an API designer needs a set of guidelines. We'll discuss the following essential principles:</span></p>
<ul>
<li><span>Ubiquitous web standards</span></li>
<li><span>API flexibility</span></li>
<li><span>API standardization</span></li>
<li><span>API optimization</span></li>
<li><span>API granularity</span></li>
<li><span>API sandbox or playground</span></li>
</ul>
<p><span>By doing so, we will be able to understand how following them will help us to design high-quality RESTful APIs.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Ubiquitous web standards</h1>
                </header>
            
            <article>
                
<p>As we discussed in the <em>Goals of RESTful API design</em> section, API designers should embrace the existing web standards and develop their API design and platforms, resulting in ubiquitous communication between the RESTful APIs and clients.</p>
<p class="mce-root">Let's ask ourselves a few questions that will help us to derive better design principles for our APIs:</p>
<ul>
<li>Who will be consuming our APIs?</li>
<li>What are the business functions that the API needs to support?</li>
<li>How granular should the API be?</li>
<li>Should APIs always stick to the existing web standards and provide consistency?</li>
</ul>
<p>The REST architecture style insists on embracing the existing web standards and so leveraging those standards should be the primary focus of any API design. The following diagram <span>depicts a few common web methods, namely, <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd> and <kbd>DELETE</kbd> , and the interactions with <strong>REST API</strong> by the clients:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0ce6ae6b-a64e-4f43-a11b-7917e3d422b0.png" style="width:35.00em;height:9.00em;"/></div>
<p>After web methods, there are few essential design aspects that APIs should adhere to, and they address the questions about standardization, consumers of API, and API consistency as well:</p>
<ul>
<li>Any application client should be able to use the API ideally without having to refer to much documentation</li>
<li>Use standard HTTP method call-outs, available on every language and platform, to make requests and retrieve information from APIs</li>
<li>Don't make any assumptions about the software development technologies used by consumer applications</li>
<li>Web protocol HTTP and responses such as JSON or ATOM help API clients to find a library that connects to any language or platform</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flexibility</h1>
                </header>
            
            <article>
                
<p>The data from the API should be independent of resources or methods. It implies REST API should handle multiple types of calls and return various data formats, even with some change in the structure representing hypermedia. In other words, the data of the API response isn't tied to the resources or methods.</p>
<p>The GitHub API summary representations and detailed representations may be examples of API flexibility. List of repository API <kbd>GET /orgs/myorg/repos</kbd> gets the summary representation, and single repository API <kbd>GET /repos/myorg/myhelloworld.rb</kbd> fetches the detailed description of the indicated repository.</p>
<p>The Salesforce API provides flexibility with its response formats, so API developers can serialize the data in either XML or JSON format.</p>
<p>GraphQL endpoint implementation for API developers is another best example of API flexibility. With GraphQL, developers can request the data that they want based on a predefined schema and so the API can respond according to the predefined schema:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b6bdcc86-0241-4d6b-b58e-0d93164f8be9.png" style="width:42.33em;height:14.58em;"/></div>
<p>The preceding screenshot reflects a sample GraphQL request (schema) for specific fields (book name and rating) and response with specified fields.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Granularity</h1>
                </header>
            
            <article>
                
<p><strong>Granularity</strong> is an essential principle of REST API design. As we understand business functions divided into many small actions are fine-grained, then business functions divided into large operations are coarse-grained. However, discussions about what level of granularity that needs to be in APIs may vary; we will get distinct suggestions and even end up in debates. Regardless, it is best to decide based on business functions and its use cases, as granularity decisions would undoubtedly vary on a case by case basis.</p>
<p>In some cases, calls across the network may be expensive and so, to minimize them a coarse-grained API may be the best fit, as each request from the client forces lot of work at the server side and, in fine-grained APIs, many calls are required to do the same amount of work at the client side.</p>
<p>Consider the following example. A service returns customer orders (say <em>n</em> orders) in a single call; this is a coarse-grained API in action. In case of fine-grained, it returns only the customer IDs, and for each customer ID, the client needs to make an additional request to get details, so <em>n+1</em> calls need to be made by the clients; these may be expensive round trips regarding its performance and response times over the network.</p>
<p>In a few other cases, APIs should be designed at the lowest practical level of granularity, because combining them is possible and allowed in ways that suit customer needs.</p>
<p>Now, check out this example, an electronic form submission may need to collect an address as well as, say, tax information. In this case, there are two functions one is a collection of the applicant's whereabouts, and another is a collection of tax details. Each task needs to be addressed with distinct API and requires a separate service because an address change is logically a different event and not related to tax time reporting, that is, why one needs to submit the tax information (again) for an address change.</p>
<p>Level of granularity should satisfy the specific needs of the business functions or use cases. While the goal is to minimize the calls across the network and for better performance, understanding the set of operations that API consumers require and how they would give a better idea of the right grained APIs in our designs is important.</p>
<p>Say internal services consumers for those who multiple calls to the API servers are acceptable and those APIs can be designed as fine-grained, and the external consumers and if they need to avoid several round-trips to the API then plan as coarse-grained.</p>
<p class="mce-root"/>
<p> </p>
<p>At times it may be appropriate that the API design supports both coarse-grained as well as fine-grained to give the flexibility for the API developers to choose the right APIs for their use cases.</p>
<p>The following points may serve as some basic guidelines for the readers to decide their API granularity levels in their API modelling:</p>
<ul>
<li>In general, consider services coarse-grained and APIs fine-grained.</li>
<li>Maintain a balance between the amount of response data and the number of resources required to provide that data will help to decide the granularity.</li>
<li>The types of performed operations on the data should also be considered as part of the design when defining the granularity.</li>
<li>Read requests are normally coarse-grained. Returning all information as required to render the page won't hurt as much as two separate API calls in some cases.</li>
<li>On the other hand, write requests must be fine-grained. Find out common operations clients need, and provide a specific API for that use case.</li>
<li>At times, you should use medium-grained, that is, neither fine-grained or coarse-grained. An example could be as seen in the following sample where the nested resources are within two levels deep.</li>
</ul>
<p>Consider the following snapshot that reflects a medium-grained API response:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a37e2d13-dd63-47a5-a15f-926d13d9be9b.png" style="width:24.00em;height:22.75em;"/></div>
<p>Let's conclude this section with a broad guideline that helps to determine the right service granularity—identify the vital business entities that the service impacts and model the life cycles accordingly; that is, there should be only one API operation for one business outcome.</p>
<p>The preceding guideline may lead to a number of API deployment units, and this can cause annoyances down the line. There are patterns, especially the API gateway, which brings a better orchestration with those numerous APIs. Orchestrating the APIs with optimized endpoints, request collapsing, and much more helps in addressing granularity challenges.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Optimized APIs</h1>
                </header>
            
            <article>
                
<p>This section discusses adopting better optimization for the API. There's no concept of one-size-fits-all. In the real world, multiple APIs may support the same service as that service might be serving different types of users and use cases. As we quoted earlier in this chapter, the API should be modeled after the design according to the use case it fulfils and not by the backend services or applications it exposes.</p>
<p>So optimization applies to a specific business request in a particular context. Let's take an example, a web service enables its mobile app consumers to clear electricity bills. In the context of the mobile, the constraints of mobile application should be our primary consideration, as a mobile app is sensitive to network latency, numerous network trips, the size of the data compared to a standard web application, and so on. So, our API design should focus on limiting the backend calls and minimize the size of the data returned.</p>
<p>Concerning granularity, let's consider the preceding example will consume few fine-grained independently invokable APIs. On the other hand, to make the payment, the app may need to use a coarse-grained API from another service (which, in turn, may have many fine-grained APIs). So, our mobile app can use a few other fine-grained APIs directly to fetch the due amount, get the user address, and access account details of the bank that the user wants to use to pay the outstanding amount, and may even need more fine-grained APIs to be incorporated in future and so on. So, designers should consider the layered or tiered approach that we discussed in <a href="ce158181-8265-4afb-b858-348cc775d6d8.xhtml">Chapter 1</a>, <em>Introduction to the Basics of RESTful Architecture,</em> to orchestrate and manage those fine-grained APIs.</p>
<p class="mce-root"/>
<p>So, API designs can expose fine-grained APIs for consumers who can access them directly, and coarse-grained services on top of them would support broader use cases, so that the service clients may decide to call the fine-grained APIs directly, or they may decide to use the coarse-grained APIs if they need the combined functionality of multiple fine-grained API calls.</p>
<div class="CDPAlignCenter CDPAlign"/>
<div class="CDPAlignCenter CDPAlign"><img src="assets/011d8264-421a-4d64-b8b2-6569b9ff24a3.png" style="width:47.00em;height:25.50em;"/></div>
<p>The preceding diagram depicts a logical structure of APIs with their granularities and how those APIs are consumed by the service clients, and it is an example of optimized APIs for the use case that we discussed earlier.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functionality</h1>
                </header>
            
            <article>
                
<p>This design principle suggests that the API design should support the full process of the life cycle as a single window. For instance, in an e-commerce site, when a consumer purchases an item, they shouldn't have to go to the bank portal to check their balance or to make a payment, and perhaps it should be integrated within that same e-commerce portal. The API used by the e-commerce portal should cover the full process of the life cycle. Partial, unbaked APIs severely affect the user experience.</p>
<p class="mce-root"/>
<p>Another aspect to think about for APIs is to provide full coverage in today's financial world; as the rapid expansion of services in cash management, automatic transfers, stock exchange orders, and so on are inevitable, APIs are the perfect solution for interconnecting these third-party services and banking services.</p>
<p>The same entity life cycle modelling approach that we saw earlier in the section to identify service granularity will also help us to understand which services are necessary to support the full business process life cycle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about unusual circumstances</h1>
                </header>
            
            <article>
                
<p>In the real world, there are some strange problems that can be solved only with specialized or proprietary technology. Those situations are unusual, and examples of those circumstances may arise in smart home platforms, IoT (fieldbus) implementations with standardized models for B2B, ebMS3/AS4 messaging, and so on.</p>
<p>There are always situations and cases in the pragmatic REST service world where API designers will land in unusual circumstances and need some trade-offs for their API design, for example, enhancing legacy applications to RESTful service scenarios. Practically it isn't feasible to migrate the whole legacy software, especially in the case of propitiatory codes, and we call them special situations. However, there are design principles and patterns such as domain-driven design patterns that come in handy in those particular situations. These unusual or unique situations also come under design principles, and they advise APIs to provide specialized technologies only for such cases where it is absolutely necessary to solve a specific problem and not just because the situation is complicated.</p>
<div class="packt_infobox"><strong>Applicability Statement 4</strong> (<strong>AS4</strong>) is an open standard protocol specification for the secure and payload-agnostic <strong>business-to-business</strong> (<strong>B2B</strong>) documents (OASIS ebMS) using web services. </div>
<div class="mce-root packt_tip packt_infobox">You're encouraged to refer the book <a href="https://www.packtpub.com/application-development/architectural-patterns">Architectural Patterns</a> published by Packt. It has one dedicated chapter about <strong>domain driven design</strong> (<strong>DDD</strong>) patterns and discusses many DDD patterns in detail.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Community standardization</h1>
                </header>
            
            <article>
                
<p>Following standards and naming conventions described by open consortiums make our APIs much more usable and interoperable. <strong>O<span>pen</span> Travel Alliance</strong> <span>(</span><strong>OTA</strong><span>) and</span> <strong>Open Geospatial Consortium</strong> <span>(</span><strong>OGC</strong><span>) are two examples of these consortiums.</span></p>
<p>The community standardization principle suggests that API implementations should be designed using industry standard information components when they are available. The iCalendar for calendar invites and events, vCard for the name and address information, and <strong>Keyhole Markup Language</strong> (<strong>KML</strong>) for geospatial data are a few examples of those well-defined standards our API can make the best use of.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">API playgrounds</h1>
                </header>
            
            <article>
                
<p>API providers should develop and expose an associated website/developer portal, for developers to quickly get on board with their APIs. It serves the new clients with documentation, forums, and self-service provisioning with secure API access keys.</p>
<p>APP developers learning about APIs and their offerings, not only with documentation but also with straightforward tools and techniques in an environment in which they can test and manipulate data in a controlled, monitored way, is of paramount importance and brings massive interest among developers to learn and use the APIs.</p>
<p>An interactive and in-browser API playground is one of the best ways for potential users to identify the API endpoints and test their code to experience the API behavior.</p>
<p>Sandboxes, virtualization, and API playgrounds are three different ways that API providers can attract app developers to play with the API functionalities.</p>
<p>An API sandbox is a controlled environment in a limited area with specific rules and provides simple API calls. Virtualization is a mirror image of the real API and offers APP developers production-like environments to do more accurate testing. API playgrounds provide greater capabilities than the sandboxes, yet unlike virtualization, they come as a limited and controlled system emulation. API playgrounds are most suitable for developers to test and get more datasets out of the API; at the same time, the API providers also have better control of those environments.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RESTful API design rules</h1>
                </header>
            
            <article>
                
<p>Now that we understand the roles and responsibilities of an API designer, the API design best practices, and the API design core principles, we can cover one more essential API design aspect called the <strong>rules of APIs</strong>. The best practices and design principles are guidelines that API designers try to incorporate in their API design. However, the rules of API need to be amended in the API design to make our APIs RESTful. So, this section is dedicated to RESTful API rules such as  the following:</p>
<ul>
<li>Use of Uniform Resource Identifiers</li>
<li>URI authority</li>
<li>Resource modelling</li>
<li>Resource archetypes</li>
<li>URI path</li>
<li>URI query</li>
<li>Metadata design rules (HTTP headers and returning error codes) and representations</li>
<li>Client concerns (versioning, security, and hypermedia processing)</li>
</ul>
<p>We're confident that having a clear understanding of these rules will move us closer to design and begin our journey towards delivering the finest RESTful APIs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about Uniform Resource Identifiers</h1>
                </header>
            
            <article>
                
<p>REST APIs should use <span><strong>Uniform Resource Identifiers</strong> (</span><strong>URIs</strong>) to represent their resources. The resource indications should be clear and straightforward so that they communicate the APIs resources crisp and clearly:</p>
<ul>
<li>A sample of a simple to understand URI is <kbd>https://xx.yy.zz/sevenwonders/tajmahal/india/agra</kbd>, as you may observe that the emphasized texts clearly indicates the intention or representation</li>
<li>A harder to understand URI is <kbd>https://xx.yy.zz/books/36048/9780385490627</kbd>; in this sample, the text after <em>books</em> is very hard for anyone to understand</li>
</ul>
<p>So having simple, understandable representation in the URI is critical in RESTful API design.</p>
<p class="mce-root"/>
<p>The following section deals with many such URI aspects for RESTful services.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URI formats</h1>
                </header>
            
            <article>
                
<p>As per RFC 3986, the syntax of the generic URI is <kbd>scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]</kbd> and following are the rules for API designs:</p>
<ul>
<li><strong>Use forward slash (<kbd>/</kbd>) separator</strong>: This is used to indicate the hierarchical relationship between resources, for example, <kbd>http://xx.yy.zz/shapes/polygons/quadrilaterals/squares</kbd>.</li>
<li><strong>Don't use a trailing forward slash</strong>: A trailing forward slash in the URI doesn't have any meaning and may create confusion, for example, <kbd>http://xx.yy.zz/shapes/polygons/</kbd> and  <kbd>http://api.examples.org/shapes/polygons</kbd> (note the trailing / at the end of the URI). REST API should neither expect trailing slash nor include them in the links that they provide to clients as responses.</li>
<li><strong>Use hyphens (</strong><kbd><em>-</em></kbd><strong>)</strong>: Hyphens improve the readability of URI names, paths, and segments, and help clients to scan and interpret easily, for example, <kbd>https://xx.yy.zz/seven-wonders/taj-mahal/india/agra</kbd> (note the hyphen segregates the space between seven wonders and Taj Mahal).</li>
<li><strong>Avoid underscores (</strong><kbd>_</kbd><strong>)</strong>: Designers should avoid _ (underscore) representation in the path, as the character <em>underscore</em> may be partially obscured or hidden while rendering on any visual cues due to computer fonts, for example, <kbd>https://xx.yy.zz/seven_wonders/taj_mahal/india/agra</kbd> (note that we can't make out the underscore as its made as a hyperlink). It should use hyphens instead <kbd>https://xx.yy.zz/seven-wonders/taj-mahal/india/agra</kbd> (with a hyphen, it's visible even if it is a hyperlink).</li>
<li><strong>Prefer all lowercase letters in a URI path</strong>: API designers should give preference to lowercase letters over any other representations, as RFC 3986 defines URIs as case sensitive except for the scheme and host components. Some examples include, <kbd>http://xx.yy.zz/shapes/polygons</kbd> and  <kbd>HTTP://XX.YY.ZZ/shapes/polygons</kbd> are the same, while <kbd>http://xx.yy.zz/shapes/polygons</kbd> and <kbd>HTTP://XX.YY.ZZ/SHAPES/Polygons</kbd> are <em>not</em> the same.</li>
<li><strong>Do not include file extensions</strong>: As you know, a dot (<kbd>.</kbd>) prefixed after the filename denotes its file types. However, a URI shouldn't use dots to represent any file extensions; instead, it should rely on media types communicated through a content-type header (refer to the <em>media types and media type design rules</em> section).</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">REST API URI authority</h1>
                </header>
            
            <article>
                
<p>As we've seen different rules for URIs in general, we will discuss the authority <em>(</em><kbd>scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]</kbd><em>)</em> portion of the REST API URI:</p>
<ul>
<li>Use consistent sub-domain names:
<ul>
<li>Consistent sub-domain names for an API include the following:
<ul>
<li>The top-level domain and the first sub-domain names indicate the service owner and an example could be <kbd>baseball.restfulapi.org</kbd></li>
<li>As you see in <kbd>http://api.baseball.restfulapi.org</kbd>, the API domain should have <kbd>api</kbd> as part of its sub-domain</li>
</ul>
</li>
<li>Consistent sub-domain names for a developer portal  include the following:
<ul>
<li>As we saw in the <em>API playgrounds</em> section, the API providers should have exposed sites for APP developers to test their APIs called a developer portal. So, by convention, the developer portal's sub-domain should have <kbd>developer</kbd> in it. An example of a sub-domain with the developer for a developer portal would be <kbd>http://developer.baseball.restfulapi.org</kbd><em>.</em></li>
</ul>
</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource modelling</h1>
                </header>
            
            <article>
                
<p>Resource modeling is one of the primary aspects for API designers as it helps to establish the API's fundamental concepts.</p>
<p>In an earlier section, we saw details about the URI; let's consider, in general, the URI path always convey REST resources, and each part of the URI is separated by a forward slash (<kbd>/</kbd>) to indicate a unique resource within it model's hierarchy.</p>
<p>Let's take the following sample URI designs:</p>
<ul>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers/memberstatus">https://api-test.lufthansa.com/v1/profiles/customers/memberstatus</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers/accountbalance">https://api-test.lufthansa.com/v1/profiles/customers/accountbalance</a></li>
</ul>
<p>Each resource separated by a forward slash indicates an addressable resource, as follows:</p>
<ul>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers">https://api-test.lufthansa.com/v1/profiles/customers</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles">https://api-test.lufthansa.com/v1/profiles</a></li>
<li><a href="https://api-test.lufthansa.com">https://api-test.lufthansa.com</a></li>
</ul>
<p>Customers, profiles, and APIs are all unique resources in the preceding individual URI models. So, resource modelling is a crucial design aspect, and API designers need to think about the API resource model before they move on to designing URI paths.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Resource archetypes</h1>
                </header>
            
            <article>
                
<p>Each service provided by the API is an archetype, and they indicate the structures and behaviors of REST API designs. Resource modelling should start with a few fundamental resource archetypes, and usually, the REST API is composed of four unique archetypes, as follows:</p>
<ul>
<li><strong>Document</strong>: The document is the base for a resource representation with a field and link-based structure. In the following, each sample URI represents unique document resources, and the first one is also called the doc-root or parent resource ( the API endpoint):
<ul>
<li><a href="https://api-test.lufthansa.com">https://api-test.lufthansa.com</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles">https://api-test.lufthansa.com/v1/profiles</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers">https://api-test.lufthansa.com/v1/profiles/customers</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers/accountbalance">https://api-test.lufthansa.com/v1/profiles/customers/accountbalance</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers/memberstatus">https://api-test.lufthansa.com/v1/profiles/customers/memberstatus</a></li>
</ul>
</li>
<li><strong>Collection</strong>: A collection is also a resource, and it is a directory of resources managed by the API providers or servers. If a collection allows creating a new resource, then the clients can add new resources to the collections. A collection resource decides the URIs of each contained or added resources. In the following, each URI sample found identifies a collection resource:
<ul>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers">https://api-test.lufthansa.com/v1/profiles/customers</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers/accountbalance">https://api-test.lufthansa.com/v1/profiles/customers/accountbalance</a></li>
<li><a href="https://api-test.lufthansa.com/v1/profiles/customers/memberstatus">https://api-test.lufthansa.com/v1/profiles/customers/memberstatus</a> <a href="https://api-test.lufthansa.com/v1/profiles/customers/memberstatus"/></li>
</ul>
</li>
<li><strong>Stores</strong>: A store is a resource repository managed by the client. The store allows the API client to put resources in, choose URIs for the resources that get added, get them out, and delete them when it decides. (URI stores never generate a new URI, and it is the client who chooses when resources initially get added.) Some of the following examples of interaction show a user of a client program of a cart- and song-management API inserting a document resource named carts and playlists respectively against his/her user ID denoted by <kbd>{id}</kbd>:
<ul>
<li><a href="http://api.example.com/cart-management/users/%7Bid%7D/carts">http://api.example.com/cart-management/users/{id}/carts</a></li>
<li><a href="http://api.example.com/song-management/users/%7Bid%7D/playlists">http://api.example.com/song-management/users/{id}/playlists</a></li>
</ul>
</li>
<li><strong>Controller</strong>: Controller resources are similar to executable methods, with parameters and return values. REST API relies on controller resources to perform application-specific actions that do not come under any of the CRUD methods. Controller names should always appear as the last segment in a URI path, with no child resources to follow them in the hierarchy:
<ul>
<li><kbd>POST /alerts/245245/resend</kbd> is an example of a controller resource that allows a client to resend an alert to a user</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URI path</h1>
                </header>
            
            <article>
                
<p>This section discusses rules relating to the design of meaningful URI paths (<kbd>scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]</kbd>) portion of the REST API URIs.</p>
<p>The following are the rules about URI paths:</p>
<ul>
<li>Use singular nouns for document names, for example, <a href="https://api-test.lufthansa.com/v1/profiles/customers/memberstatus">https://api-test.lufthansa.com/v1/profiles/customers/memberstatus</a>.</li>
<li>Use plural nouns for collections and stores:
<ul>
<li><strong>Collections</strong>: <a href="https://api-test.lufthansa.com/v1/profiles/customers">https://api-test.lufthansa.com/v1/profiles/customers</a></li>
<li><strong>Stores</strong>: <a href="https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces">https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/prefernces</a></li>
</ul>
</li>
<li>As controller names represent an action, use a verb or verb phrase for controller resources. An example would be <a href="https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset">https://api-test.lufthansa.com/v1/profiles/customers/memberstatus/reset</a>.</li>
<li>Do not use CRUD function names in URIs:
<ul>
<li><strong>Correct URI example</strong>: <kbd>DELETE /users/1234</kbd></li>
<li><strong>Incorrect URIs</strong>: <kbd>GET /user-delete?id=1234</kbd>, <kbd>GET /user-delete /1234</kbd>, <kbd>DELETE /user-delete /1234</kbd>, and <kbd>POST /users/1234/delete</kbd></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">URI query</h1>
                </header>
            
            <article>
                
<p>This section discusses rules relating to the design of the query (<kbd>scheme "://" authority "/" path [ "?" query ] [ "#" fragment ]</kbd><em>)</em> portion of the REST API URIs.</p>
<p>The query component of the URI also represents the unique identification of the resource, and following are the rules about URI queries:</p>
<ul>
<li>Use the query to filter collections or stores:
<ul>
<li>An example of the limit in the query: <kbd>https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40</kbd></li>
</ul>
</li>
<li>Use the query to paginate collection or store results:
<ul>
<li>An example with the offset in the query: <kbd>https://api.lufthansa.com/v1/operations/flightstatus/arrivals/ZRH/2018-05-21T06:30?limit=40&amp;offset=10</kbd></li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP interactions</h1>
                </header>
            
            <article>
                
<p>A REST API doesn't suggest any special transport layer mechanisms, and all it needs is basic Hyper Text Transfer Protocol and its methods to represent its resources over the web. We will touch upon how REST should utilize those basic HTTP methods in the upcoming sections.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Request methods</h1>
                </header>
            
            <article>
                
<p>The client specifies the intended interaction with well-defined semantic HTTP methods, such as <kbd>GET</kbd>, <kbd>POST</kbd>, <kbd>PUT</kbd>, <kbd>DELETE</kbd>, <kbd>PATCH</kbd>, <kbd>HEAD,</kbd> and <kbd>OPTIONS</kbd>. The following are the rules that an API designer should take into account when planning their design:</p>
<ul>
<li>Don't tunnel to other requests with the <kbd>GET</kbd> and <kbd>POST</kbd> methods</li>
<li>Use the <kbd>GET</kbd> method to retrieve a representation of a resource</li>
<li>Use the <kbd>HEAD</kbd> method to retrieve response headers</li>
<li>Use the <kbd>PUT</kbd> method to update and insert a stored resource</li>
<li>Use the <kbd>PUT</kbd> method to update mutable resources</li>
<li>Use the <kbd>POST</kbd> method to create a new resource in a collection</li>
<li>Use the <kbd>POST</kbd> method for controller's execution</li>
<li>Use the <kbd>DELETE</kbd> method to remove a resource from its parent</li>
<li>Use the <kbd>OPTIONS</kbd> method to retrieve metadata</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Response status codes</h1>
                </header>
            
            <article>
                
<p>HTTP specification defines standard status codes, and REST API can use the same status codes to deliver the results of a client request.</p>
<p> The status code categories and a few associated REST API rules are as follows so that the APIs can apply those rules according to the process status:</p>
<ul>
<li><strong>1xx: Informational</strong>: This provides protocol-level information</li>
<li><strong>2xx: Success</strong>: Client requests are accepted (successfully), as in the following examples:
<ul>
<li><kbd>200</kbd>: OK
<ul>
<li>Use for indicating client request success</li>
<li>Do not use to communicate the errors in the response body</li>
</ul>
</li>
<li><kbd>201</kbd>: Created
<ul>
<li>Apply for successful resource creation</li>
</ul>
</li>
<li><kbd>202</kbd>: Accepted
<ul>
<li>Use for reporting the successful asynchronous action</li>
</ul>
</li>
<li><kbd>204</kbd>: No content
<ul>
<li>When an API wants to send empty or no content in the response body</li>
</ul>
</li>
</ul>
</li>
<li><strong>3xx: Redirection</strong>: Client requests are redirected by the server to the different endpoints to fulfil the client request:
<ul>
<li><kbd>301</kbd>: Moved Permanently
<ul>
<li>Use for relocated resources</li>
</ul>
</li>
<li><kbd>302</kbd>: Found
<ul>
<li>Please note not to use <kbd>302</kbd>, as it would create confusion among the developers related to the initiation of automatic redirections from the client</li>
</ul>
</li>
<li><kbd>303</kbd>: See other
<ul>
<li>Apply to refer the client to a different URI (in place of <kbd>302</kbd>, it's recommended the API should use <kbd>303</kbd>)</li>
</ul>
</li>
<li><kbd>304</kbd>: Not modified
<ul>
<li>Use so that the client can preserve bandwidth</li>
<li>Use in conjunction with conditional HTTP requests</li>
</ul>
</li>
<li><kbd>307</kbd>: Temporarily redirect
<ul>
<li>Use to indicate to the clients to resubmit the request to another URI</li>
</ul>
</li>
</ul>
</li>
<li><strong>4xx: Client error</strong>: Errors at client side:
<ul>
<li><kbd>400</kbd>: Bad request
<ul>
<li>Can be used to indicate generic or nonspecific failures</li>
</ul>
</li>
<li><kbd>401</kbd>: Unauthorized
<ul>
<li>Apply for unauthorized access from the client side or problem with the client credentials</li>
</ul>
</li>
<li><kbd>403</kbd>: Forbidden
<ul>
<li>Use to forbid access regardless of the authorization state</li>
<li>Use to enforce application-level permission (allowed to access only a few resources and not all the resources)</li>
</ul>
</li>
<li><kbd>404</kbd>: Not found
<ul>
<li>Must use when client request doesn't map to any of the API resources</li>
</ul>
</li>
<li><kbd>405</kbd>: Method not allowed
<ul>
<li>Use when the client accesses unintended HTTP methods</li>
<li>Example read-only resource might only support <kbd>GET</kbd> and <kbd>HEAD</kbd> , and the client tried to use <kbd>PUT</kbd> or <kbd>DELETE</kbd></li>
<li>Please note that <kbd>405</kbd> response should be part of the Allow header <em>(Allow—<kbd>GET</kbd>. <kbd>POST</kbd>)</em></li>
</ul>
</li>
<li><kbd>406</kbd>: Not acceptable
<ul>
<li>Must use when the server can't serve the requested media type</li>
</ul>
</li>
<li><kbd>409</kbd>: Conflict
<ul>
<li>Use for client violation of a resource state</li>
<li>An example could be an API returns this error when the client tries to delete a non-empty store resource</li>
</ul>
</li>
<li><kbd>412</kbd>: Precondition failed
<ul>
<li>Use to support conditional operations. The client sends one or more preconditions in the request headers to indicate to the API to execute only those conditions that are satisfied; if not, the API should send a <kbd>412</kbd> error code.</li>
</ul>
</li>
<li><kbd>415</kbd>: Unsupported media type
<ul>
<li>Must be used when the API is not able to process the request's payload media type (indicated in the content-type request header)</li>
</ul>
</li>
</ul>
</li>
<li><strong>5xx: Server error</strong>: These relate to errors at server side:
<ul>
<li><kbd>500</kbd>: Internal server error
<ul>
<li>Use to report the API/server-side issues, and when it's certainly not the client's side fault</li>
</ul>
</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Metadata design</h1>
                </header>
            
            <article>
                
<p>This section looks at the rules for metadata designs, including HTTP headers and media types.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HTTP headers</h1>
                </header>
            
            <article>
                
<p>As you might already know, HTTP specifications have a set of standard headers, through which a client can get information about a requested resource, and carry the messages that indicate its representations and may serve as directives to control intermediary caches.</p>
<p>The following points suggest a few sets of rules conforming to the HTTP standard headers:</p>
<ul>
<li><strong>Should use content-type</strong>: Client and servers rely on this header to indicate how to process the message's body, as the value of the content-type specifies the form of the data contained in the request or response message body called <strong>media types</strong>.</li>
<li><strong>Should use content-length</strong>: The client should know the size of the message body that it is about to read. The other benefit is that the client gets to know how large the response body is that it needs to download, without needing to download the whole response by making a <kbd>HEAD</kbd> request.</li>
<li><strong>Should use last-modified in responses</strong>: The response should specify the timestamp when the representational state of the required resource was modified or updated so that the client and cache intermediaries can rely on this header to determine the freshness of their local copies of a resource's state representation. The last-modified header should be part of their requests.</li>
<li><strong>Should use ETag in responses</strong>: <strong>Entity tag</strong> (<strong><span>ETag</span></strong>) is an HTTP header that helps the client to identify a specific version of the resources they asked for. The server should always respond with the ETag as a header for the client <kbd>GET</kbd> requests. The value of the <span class="MsoIntenseEmphasis">ETag </span>is commonly a digest (hash value, for instance, MD5 hash) of the resource contents so that the server can identify whether the cached contents of the resources are different from the latest version of the resources. ETag differs from the <span class="MsoIntenseEmphasis">last-modified</span> header by the value (resource content as digest versus timestamp). This header value enables the client to choose whether or not to send the representation again by using <kbd>If-Non-Match</kbd> conditionals in the future <kbd>GET</kbd> requests. If the ETag value hasn't changed, then the client can decide to save time and bandwidth by not sending the representation again in their subsequent <kbd><span class="MsoIntenseEmphasis">GET</span></kbd> requests.</li>
<li><strong>Stores must support conditional <kbd>PUT</kbd> requests</strong>: REST API can support conditional <kbd>PUT</kbd> requests by relying on client requests with <kbd><span class="MsoIntenseEmphasis">If-Unmodified</span>-<span class="MsoIntenseEmphasis">Since</span></kbd>, and/or <kbd><span class="MsoIntenseEmphasis">If</span>-<span class="MsoIntenseEmphasis">Match</span></kbd> request headers. As the store resources use the <kbd>PUT</kbd> method for both inserts and updates, the REST API should know the client's intent of the <kbd>PUT</kbd> requests. <kbd>PUT</kbd> is the same as <kbd>POST</kbd> except <kbd>PUT</kbd> is *idempotent. Please note that HTTP supports conditional requests with the <kbd>GET</kbd>, <kbd>POST</kbd> , and <kbd>DELETE</kbd> methods; this is an essential pattern for allowing writable REST APIs to help collaboration among API clients.</li>
</ul>
<div class="packt_infobox">From a RESTful service standpoint, the idempotent of a service call means the calls that the client makes produce the same results for all calls; that is, multiple requests from the clients produce the same effect as a single request.<span> </span><span>Please note that the same result or behavior is on the server</span><span>. However, the response that the client receives may not be the same as the resource state may change between the requests.</span></div>
<ul>
<li><strong>Should use the location to specify the URI of newly created resources (through</strong> <kbd>PUT</kbd><strong>)</strong>: In response to the successful creation of resources through collections or stores, the API should provide the location (URI) of the newly created resource as a response header. The location header can be part of the status code <kbd>202</kbd> response to direct the clients about the status of their asynchronous call.</li>
<li><strong>Should leverage HTTP cache headers</strong>: This is to encourage caching, provide c<span class="MsoIntenseEmphasis">ache</span>-c<span class="MsoIntenseEmphasis">ontrol</span>, Expires, and date-response headers to leverage caching at various levels, such as the API server side, <strong>content delivery networks</strong> (<strong>CDN</strong>), or even at the client's network. Some examples are as follows:
<ul>
<li> <kbd>Cache-Control: max-age=90, must-revalidate</kbd> (<kbd>max-age</kbd> is in seconds)</li>
<li><kbd>For HTTP 1.0 based caches,</kbd><kbd>Date: Tue, 29 Apr 2018 08:12:31 GMT</kbd><kbd>Expires: Fri, 04 May 2018 16:00:00 GMT</kbd></li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">To discourage caching, add <span class="MsoIntenseEmphasis">cache-control</span> headers with <kbd>no-cache</kbd> and <kbd>no-store</kbd>, with the following:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>For HTTP 1.0 legacy caches</li>
<li>Add the <kbd><span class="MsoIntenseEmphasis">Pragma—no-cache</span></kbd> and <kbd>Expires—0</kbd> header values</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">However, unless necessary, REST API should always provoke caching of responses, maybe by shorter duration instead of using a no-cache directive. So the clients get faster responses for frequent access requests by fetching the short-lived response copies.</p>
<ul>
<li><strong>Should use expiration headers with</strong> <kbd>200</kbd> <strong>("OK") responses</strong>: Setting expiration caching headers in response to the successful <kbd>GET</kbd> and <kbd>HEAD</kbd> requests encourages caching at the client side. Please note that the <kbd>POST</kbd> method is also cacheable, and so don't treat this method as non-cacheable.</li>
<li><strong>May use expiration caching headers with 3xx and 4xx responses</strong>: In addition to status code <kbd>200</kbd> (<kbd>"OK": successful responses</kbd>), the APIs can include caching headers for <span class="MsoIntenseEmphasis">3xx</span> and <span class="MsoIntenseEmphasis">4xx</span> responses, also known as negative caching. It helps the REST API server with a reduction in loads due to some redirection and error triggers.</li>
<li><strong>Mustn't use custom HTTP headers: </strong>The primary purpose of custom HTTP headers is to provide additional information and troubleshooting tips for app developers; however, for some distinctive cases at the server side, it comes in handy unless those cases do not change the behavior of the HTTP methods. An example could be an API that makes use of the <span class="MsoIntenseEmphasis">X-cache</span> header to let app developers know whether the resource is delivered by the origin server or by the edge server. If the information that should go through a custom HTTP header is critical in that it needs an accurate interpretation of the request or response, then it is better for it to be included in the body of the request or response or in the URI used for that request.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Media types and media type design rules</h1>
                </header>
            
            <article>
                
<p>As you saw in the <em>Manipulation of Resources</em> section of <a href="ce158181-8265-4afb-b858-348cc775d6d8.xhtml">Chapter 1</a>, <em><span>Introduction to the Basics of RESTful Architecture,</span></em> media types help to identify the form of the data in a request or response message body, and the c<span class="MsoIntenseEmphasis">ontent-type</span> header value represents a media type also known as the <strong>Multipurpose Internet Mail Extensions</strong> (<strong>MIME</strong>) <span>type</span>.</p>
<p>Media type design influences many aspects of a REST API design, including hypermedia, opaque URIs, and different and descriptive media types so that app developers or clients can rely on the self-descriptive features of the REST API.</p>
<p>The following points discuss the rules of media type design in brief:</p>
<ul>
<li><strong>Uses application-specific media types</strong>: REST APIs treat the body of an HTTP request or response as part of an application-specific interaction. While the request or response body is built with languages such as JSON or XML, it typically has semantics that requires special processing beyond merely parsing the language's syntax. An example representation of such a REST API URI is <a href="https://swapi.co/api/planets/1" target="_blank">https://swapi.co/api/planets/1</a> that responds to the <kbd>GET</kbd> requests with a representation of the <em>Star Wars</em> planet resource that's formatted using JSON.</li>
<li><strong>Supports media type negotiations in case of multiple representations</strong>: The client may require different formats and schema by submitting the desired media type as part of the <kbd>Accept</kbd> header, so the API should allow the clients to get the response in the desired format.Following is an example representation of the media type negotiations from <kbd>developer.atlassian.com</kbd> for the following <kbd>Accept</kbd> header:</li>
</ul>
<pre style="padding-left: 90px">Content-Type: application/json<em><br/></em> Accept: application/json</pre>
<p>Observe the following curl execution:</p>
<pre>curl -i -u application_name:application_password --data '{"value": "my_password"}' http://testapi.com /crowd/rest/usermanagement/1/authentication?username=my_username --header 'Content-Type: application/json' --header 'Accept: application/json'  </pre>
<p> We can conclude the following:</p>
<ul>
<li>Support media type selection using a query parameter:
<ul>
<li>To support clients with simple links and debugging, REST APIs should support media type selection through a query parameter named accept, with a value format that mirrors that of the accept HTTP request header</li>
<li>An example is REST APIs should prefer a more precise and generic approach as following media type, using the <kbd>GET</kbd> <kbd>https://swapi.co/api/planets/1/?format=json</kbd> query parameter identification over the other alternatives</li>
</ul>
</li>
</ul>
<div class="packt_tip"><span>Windows OS users can use MobaXterm (<a href="https://mobaxterm.mobatek.net/">https://mobaxterm.mobatek.net/</a>) or any SSH clients that supports Unix commands. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Representations</h1>
                </header>
            
            <article>
                
<p>As we know, machine-readable description of a resource's current state with a request or response is a representation, and it can be in different formats. The following section discusses the rules for most common resource formats, such as JSON and hypermedia, and error types in brief.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Message body format</h1>
                </header>
            
            <article>
                
<p>REST API communications in the distributed environment are most often as a text-based format, and we will discuss the JSON text-format representation rules as follows:</p>
<ul>
<li>Use JSON for resource representation and it should be well-formed</li>
<li>You may use XML and other formats as well</li>
<li>Don't create additional envelopes or any custom transport wrappers and leverage only HTTP envelopes</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hypermedia representation</h1>
                </header>
            
            <article>
                
<p>As we have understood from <a href="ce158181-8265-4afb-b858-348cc775d6d8.xhtml">Chapter 1</a>, <em><span>Introduction to the Basics of RESTful Architecture</span></em>, REST API clients can programmatically navigate using a uniform link structure as a HATEOAS response, and following are a few rules related to hypermedia representations.</p>
<p>The following screenshot helps us to recollect from <a href="ce158181-8265-4afb-b858-348cc775d6d8.xhtml">Chapter 1</a>, <em>Introduction to the Basics of RESTful Architecture,</em> the HATEOAS representation:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/6e7bbc3f-121f-43b4-9a1f-aa646b7bd01c.png" style="width:40.00em;height:23.08em;"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Also, it can help us to relate to the following rules:</p>
<ul>
<li>Use a consistent form to represent links, link relations, and link announcements</li>
<li>Provide a self-linking representation in a response message body</li>
<li>Minimize the number of the advertised <em>entry point</em> or API URIs</li>
<li>Use links to advertise any resource actions in a state-sensitive manner</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Media type representation</h1>
                </header>
            
            <article>
                
<p>A <kbd>GET</kbd> request won't have a request body, and the response body is always a resource representation. So, for every client request, except for <kbd>GET</kbd> requests, the API should define the media type in the request body and response body. The API media type relates to features such as sorting, filtering, paginating, and linking. So, media type formats and schemas should be consistent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Errors representation</h1>
                </header>
            
            <article>
                
<p>Error status codes of HTTP methods (4xx and 5xx) can carry client-readable information in the response body. The following rules present consistent forms of errors and error responses:</p>
<ul>
<li>Errors and error responses should be consistent</li>
<li>Error types for generic and for common error conditions should also be consistent</li>
</ul>
<p class="mce-root"/>
<p>The following diagram depicts a sample JSON response and <span>addresses how errors and error codes predominate in API responses</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/65f87d9f-a696-4c8f-bbd0-dc4c60aa0534.png" style="width:35.58em;height:21.17em;"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client concerns</h1>
                </header>
            
            <article>
                
<p>As we know from the <em>API design best practices</em> section, the REST API clients in the REST API world are APP developers and REST APIs are designed to suit the needs of their client programs (APP developer code). This section deals with a set of REST API design principles to address common client concerns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Versioning</h1>
                </header>
            
            <article>
                
<p>A REST API is a collection of interlinked resources or resource models. The representational resources communicate their state through the versions. So versioning is one of the essential design principles, and we will look at the versioning of APIs before we state the rules for versioning.</p>
<p>APIs should be versioned (increase the major version) when it undergoes a breaking change; breaking changes include the following:</p>
<ul>
<li>Response data changes</li>
<li>Response type changes</li>
<li>Removing any part of the API</li>
</ul>
<p>APIs should undergo version changes even when it involves minor or non-breaking modifications, such as adding new endpoints or new response parameters. Minor versions help to track the APIs' small changes and assist in customer support, who may be receiving cached versions of data or may be experiencing other API issues. Following are a few of the rules about REST API versioning:</p>
<ul>
<li>Use new URIs to introduce new models or conceptions</li>
<li>Use schemas for managing representational form versions</li>
<li>Make use of ETags to manage representational state versions</li>
</ul>
<div class="packt_infobox">The general versioning practices follow schematic versioning (<a href="https://semver.org/">https://semver.org/</a>); however, the versioning practices in RESTful API attract lots of discussions, and please be aware that, as API designers, we may need to make decisions aligned with business needs and impacts. </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>REST APIs may expose resources that contain secure information intended to be revealed only to restricted clients, and the following rules help to secure resources:</p>
<ul>
<li>Use OAuth, an HTTP-based authorization protocol, to protect resources</li>
<li>Use API management solutions, such as reverse proxy, to protect resources</li>
</ul>
<p>We<span>'ve provided a sample implementation as an example in the next chapter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Response representation composition</h1>
                </header>
            
            <article>
                
<p>When REST APIs evolve with new features, the client may require new resources from its supporting REST API. However, for many practical reasons, the client may need new resources from the REST API. So a REST API can provide a measure to control the composition of its response representations. It's crucial that REST APIs maintain a consistent resource model design, so clients can benefit from the composite responses. The following two rules enable the client to tune the responses:</p>
<ul>
<li>It should support partial response by using the query component of a URI</li>
<li>It should embed linked resources by using the query component of a URI</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>For<span> examples, you may refer back the </span><em>URI query</em><span> section of this chapter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Processing hypermedia</h1>
                </header>
            
            <article>
                
<p>We discussed earlier two hypermedia structures, link and link relation. They help clients to process the response structure using a consistent algorithm.</p>
<p>The client should interact with a specific REST API response representation link. The following points discuss a simple flow:</p>
<ul>
<li>The client processing program starts by looking up the link using its relation's name, and interacts with the link lookup using the appropriate HTTP request method</li>
<li>The client code inspects the method field of the link's relation document resource and decides whether the content should be submitted in the request message body or not</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript clients</h1>
                </header>
            
            <article>
                
<p>It's most common that JavaScript clients wish to interact with REST APIs. However, there are restrictions imposed (sandboxed) by the web browsers same-origin, also known as <strong>same domain policy</strong>. It restricts the JavaScript client from accessing resources if the resources aren't from the same domain/own source. The URI scheme, host, and port components indicate whether the resource origin is from the same domain. The browsers impose the same-origin policy to prevent leaking of confidential user data.</p>
<p>However, in most cases, the REST API needs to provide multi-origin read/write access from JavaScript for its JavaScript clients, and we will see how the following rules enable such flexibility:</p>
<ul>
<li>Support multi-origin read access with <strong>JSON with padding</strong> (<strong>JSONP</strong>) from JavaScript</li>
<li>Support <strong>cross-origin resource sharing</strong> (<strong>CORS</strong>) to provide multi-origin read/write access from JavaScript</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>As part of design strategies, we looked at what an API is and its importance for connecting devices with various other devices and technologies in the digitization era. We examined a few essential API design characteristics, such as affordance, leveraging, and maximizing existing web infrastructure, along with API design goals, such as consistency, simplification, flexible yet stable APIs, and how it is essential for an API designer to focus on the APP developers—the consumers of the APIs.</p>
<p>We also briefly discussed the role of an API designer and how they need to follow design principles and rules, so that they can create better RESTful APIs. We concluded this chapter by giving the necessary rules for RESTful APIs, along with some dos and don'ts.</p>
<p>So, we've set a strong foundation and the path for you to get your hands on API programming in our next two chapters as they deal with hands-on REST API programs implementations, with various RESTful API design patterns and applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>We encourage readers to refer to <a href="https://www.packtpub.com/all">https://www.packtpub.com/all</a> for various reference materials and a vast collection of books on RESTful services and APIs.</p>


            </article>

            
        </section>
    </body></html>