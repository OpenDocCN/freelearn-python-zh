- en: 'Chapter 4. Tasklist II: Databases and AJAX'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will refactor our tasklist application. It will use a database
    engine on the server to store items and will use jQuery's AJAX functionality to
    dynamically update the contents of the web application. On the server side, we
    will learn how to use Python's bundled SQLite database engine. On the presentation
    side, we will encounter jQuery UI's event system and will learn how to react to
    mouse clicks.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn some benefits of using a database engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get familiar with SQLite, a database engine distributed with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a password database with SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to design and develop a database-driven tasklist application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a test framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to make a web application more responsive using AJAX calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how to implement interactive applications without`<form>` elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get on with it...
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of a database compared to a filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storing records on a filesystem as separate files might be simple but does
    have several drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: You have to define your own interface for accessing these files and parsing
    their contents. This is much more serious than it may sound because it compels
    you to develop and test a lot of specific functionality that you would otherwise
    get more or less for free from an existing library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing single files is much slower than selecting records from a table in
    a database. That might be workable as long as you know which record you want (as
    is the case in our tasklist application) but it certainly isn't workable when
    you want to select records based on the value of some attribute. This would necessitate
    opening each and every file and checking whether some attribute matches your criteria.
    On a data collection of hundreds of items or more, this would be prohibitively
    slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, it is difficult to implement transactions. If we want to guarantee that
    a set of actions will either be successful as a whole or will be rolled back if
    some part of it doesn't succeed, we will have to implement very sophisticated
    code ourselves if we want to use files on a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using files on a filesystem, it is a nuisance to define and maintain relations
    between records, and although our tasklist application is about as simple as it
    gets, almost any other application has more than one logical object and relations
    between them, so this is a serious issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a database engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many database engines available that can be accessed from Python,
    both commercial and open source (http://wiki.python.org/moin/DatabaseInterfaces).
    Choosing the right database is not a trivial task as it might not only depend
    on functional requirements, but also on performance, the available budget, and
    hard to define requirements like easy maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the applications we develop in this book, we have chosen to use the SQLite
    database engine ([http://www.sqlite.org](http://http://www.sqlite.org)) for a
    number of reasons. First, it is free and included in Python''s standard distribution.
    This is important for people writing books because it means that everyone who
    is able to run Python has access to the SQLite database engine as well. However,
    this is not a toy database: as a matter of fact, SQLite is a database that is
    used in many smartphones and high-profile applications like Firefox to store things
    like configurations and bookmarks. Furthermore, it is reliable and robust and,
    on top of that, quite fast.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It does have some drawbacks as well: first of all, it uses its own dialect
    of SQL (the language used to interact with the database) but to be fair, most
    database engines use their own dialect.'
  prefs: []
  type: TYPE_NORMAL
- en: More seriously, the focus of SQLite is on embedded systems, the most visible
    consequence of that is that it doesn't have facilities to limit user access to
    a subset of tables and columns. There is just a single file on the filesystem
    that holds the contents of the database and the access rights to the file are
    determined by the filesystem on which it resides.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final issue is not so much a drawback as a point of serious attention:
    SQLite does not enforce types. In many databases, the type defined for column
    determines rigidly what you can store in that column. When a column is defined
    as an INTEGER, the database engine, in general, won''t allow you to store a string
    or a boolean value, whereas, SQLite does. This isn''t as strange as it sounds
    once you compare it with the way Python manages variables. In Python, it is perfectly
    valid to define a variable and assign an integer to it, and later assign a string
    to the same variable. A variable in Python is just like a column in SQLite; it
    is just a pointer to a value and that value is not simply the value itself but
    also has an explicitly associated type.'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of availability, reliability, and a type system closely resembling
    Python's native way of dealing with values makes SQLite a very suitable database
    engine in many applications, although specific applications may have requirements
    that may be better served by other database engines, like PostgreSQL or MySQL.
    The latter might be an attractive alternative if your application will run on
    a web server that already provides MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Database-driven authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start designing a database-driven tasklist application, let''s first
    familiarize ourselves with SQLite in the context of a seemingly much simpler set
    of requirements: storing username/password combinations in a database and refactoring
    the Logon class to interact with this database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The functional requirements are deceptively simple: to verify whether a username/password
    combination is valid, all we have to do is verify that the username/password combination
    given is present in the table of usernames and passwords. Such a table consists
    of two columns, one named `username` and the other named `password`. As it is
    never a good idea to store a collection of passwords in plaintext, we encrypt
    the passwords with a hash function so even if the password database is compromised,
    the bad guys will have a difficult time retrieving the passwords. This means,
    of course, that we have to hash a given password with the same hash function before
    comparing it to the stored password for the username but that doesn''t add much
    complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: What does add complexity is the fact that CherryPy is multi-threaded, meaning
    that CherryPy consists of multiple lightweight processes accessing the same data.
    And although the developers of SQLite maintain the opinion that threads are evil
    ([http://www.sqlite.org/faq.html#q6](http://www.sqlite.org/faq.html#q6)), threads
    make perfect sense in situations where a lot of time in the application is spent
    on waiting. This certainly is the case in web applications that spend a lot of
    time waiting for network traffic to complete, even in this time of broadband connections.
    The most effective way of using this waiting time is to enable a different thread
    to serve another connection so more users might enjoy a better interactive experience.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Hash functions** (or Cryptographic hash functions to be more specific) convert
    any input string to an output string of limited length in such a way that it is
    very unlikely that two input strings that are different produce the same output.
    Also, conversion from input to output is a one way operation or at least it will
    cost a large amount of computing power to construct the input from the output.
    There are many useful hash functions known, the most popular ones are available
    in Python''s `hashlib` module. The specific hash function we use here is called
    `SHA1`.'
  prefs: []
  type: TYPE_NORMAL
- en: More about hashing can be found in the Python documentation at [http://docs.python.org/py3k/library/hashlib.html](http://docs.python.org/py3k/library/hashlib.html),
    or on Wikipedia at [http://en.wikipedia.org/wiki/Cryptographic_hash_function](http://en.wikipedia.org/wiki/Cryptographic_hash_function).
  prefs: []
  type: TYPE_NORMAL
- en: However, in SQLite, the connection object cannot be shared among threads. This
    doesn't mean that that we cannot use SQLite in a multi-threaded environment (despite
    the evilness of threads), but it does mean we have to make sure that if we want
    to access the same SQLite database from different threads, each thread must use
    a connection object that is exclusively created for that thread.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, it is quite easy to instruct CherryPy to call a function the moment
    it starts a new thread and let that function create a new connection to our database,
    as we will see in the next section. If we would employ many different threads,
    this might be wasteful because the connection objects use some memory, but with
    a few tens of threads this doesn't pose much of a problem (The default number
    of threads in CherryPy is 10 and can be configured with the `server.thread_pool`
    configuration option). If the memory consumption is a problem, there are alternative
    solutions available, for example, in the form of a separate worker thread that
    handles all database interaction or a small pool of such threads. A starting point
    for this might be [http://tools.cherrypy.org/wiki/Databases](http://tools.cherrypy.org/wiki/Databases).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action authentication using a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To illustrate how to use database-driven user authentication, run `logondbapp.py`.
    It will present you with a logon screen very similar to the one shown in the previous
    chapter. You may enter the built-in username/password combination of admin/admin,
    after which you will be presented with a welcoming page.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this mini application work with the database-driven version
    of user authentication, all we have to do is replace the reference to an instance
    of the Logon class to one of the `LogonDB` class, as highlighted in the following
    code (the full code is available as `logondbapp.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/logondbdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Another important difference with the previous implementation is the highlighted
    definition of a `connect()` function that should be called for each new thread
    that is started by CherryPy. It calls the `connect()` method of the `LogonDB`
    instance to create a database connection object unique for a given thread. We
    register this function with the `cherrypy.engine.subscribe()` function and make
    it call our `connect()` function at the start of each new thread CherryPy starts.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The database-centered version of our `Logon` class, `LogonDB` inherits a lot
    from `Logon`. Specifically, all HTML-related logic is reused. `LogonDB` does override
    the `__init__()` method to store a path to a database file and makes sure the
    database is initialized using the `initdb()` method, if it does not yet exist
    (highlighted). It also overrides the `checkpass()` method because this method
    must now verify the existence of a valid username/password pair against a database
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/logondb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the database consists of a single table `pwdb` that is defined
    in the highlighted line (and only if that table does not yet exist). The `pwdb`
    table consists of two columns, namely, `username` and `password`. By marking both
    columns as `not null`, we ensure that we cannot enter empty values in any of them.
    The `username` column is also marked as `unique` because a username may only occur
    once. This database schema of a single table can be depicted in the following
    diagram where each column has a header with a name and several lines that list
    the attributes of a certain column (as our database design gets more elaborate,
    we will rely more on these diagrams and less on a detailed expose of the SQL code):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pwdb |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Username | password |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| not nullunique | not null |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Anyone familiar with other dialects of SQL might have noticed that the column
    definitions lack any kind of type. This is deliberate: SQLite allows us to store
    any kind of value in a column, just as Python allows us to store any kind of value
    in a variable. The type of the value is directly associated with the value, not
    with the column or variable. SQLite does support the notion of affinity or preferred
    type and we will encounter that in other tables we will create in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides creating a table, if needed (in the `initdb()` method, highlighted),
    we also initialize it with a username/password combination of admin/admin if the
    admin username is not yet there. If it is, we leave it as it is because we do
    not want to reset an altered password, but we do want to make sure that there
    is an admin username present. This is accomplished by the `insert or ignore` statement
    because the `insert` of an `admin` username into a table that already contains
    one would fail because of the unique constraint. Adding the non standard or `ignore`
    clause will ignore such an occurrence, in other words, it will not insert a new
    record with a username of admin if it is already there.
  prefs: []
  type: TYPE_NORMAL
- en: The `insert` statement also illustrates that we store passwords not as plaintext,
    but as hashed values (that are extremely hard to convert back to plaintext again).
    The hash method we use here is SHA1 and is imported as `hash()` from Python's
    `hashlib` module. The conversion from plaintext is handled by the `_dohash()`
    static method (marked as private by leading underscore in its name but note that
    in Python, this is a convention only, as there really aren't any private methods).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way we store passwords in this example is still not safe enough for production
    environments, but implementing a more secure solution is out of scope for this
    book. I strongly suggest reading [http://www.aspheute.com/english/20040105.asp](http://www.aspheute.com/english/20040105.asp)
    for more on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: The `initdb()` method also takes care of creating an object that can be used
    to store data that is local to a thread with the `threading.local()` function.
    Because, normally, all data in threads is shared, we have to use this function
    to create a place to store a database connection object that is different for
    each thread. If we were to store such a connection object in a global variable,
    each thread would have access to the same database connection and this is not
    allowed in SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we store passwords as hashed values implies that checking username/password
    combinations necessarily involves converting a plaintext password as well before
    it can be checked for existence. This is implemented in the `checkpass()` method
    (highlighted). The password argument is converted with the `_dohash()` method
    before being passed to the `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL statement itself then counts the number of rows in the `pwdb` table
    that contain the given username and (hashed) password and retrieves the result.
    The result is a single row containing a single value, the number of matching rows.
    If this is one, we have a valid username/password combination, otherwise we don't.
    We do not discriminate between the cases where the username is unknown or whether
    there is more than a single row containing the same username. This is because
    the latter situation is unlikely to happen because of the `unique` constraint
    on the username column.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero adding new username/passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `LogonDB` class does not yet have a method to add a new username/password
    combination to the database. How would you implement one?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: You need to provide both an exposed method that offers a page with a
    form where one can enter a new username and password and a method that may act
    as an action attribute in a`<form>` element and that is passed the username and
    password as parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method has to check not only that the user is authenticated but
    also that the user that adds the new username/password is the admin, otherwise
    everyone could add new accounts! A sample implementation is already provided in
    `logondb.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Tasklist II storing tasks in a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen how we may use a database engine to store persistent data
    and how to access this data from a CherryPy application, let's apply this new
    knowledge to the tasklist application we designed in the previous chapter. Of
    course, there is more to an application than storing data and we will also revamp
    the user interface in order to make it more responsive and slightly simpler to
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Improving interactivity with AJAX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you look at the difference between applications that are standalone on
    a PC versus a web application, you might notice few differences at a first glance.
    However, if you look more closely, there is a major difference: In the standalone
    application when something changes in the display, only those onscreen elements
    are redrawn that are actually modified.'
  prefs: []
  type: TYPE_NORMAL
- en: In traditional web pages, this is completely different. Clicking a button that
    changes the sort order of a list, for example, might not only retrieve and redraw
    that list again, but would retrieve a complete page, including all side bars,
    navigation headers, advertisements, and what not.
  prefs: []
  type: TYPE_NORMAL
- en: If that unmodified content is slow to retrieve over the internet, the whole
    web page might feel sluggish, even more so if the whole webpage is waiting for
    the arrival of the last piece of information to display itself in its full glory.
    When web pages evolved to mimic applications, this difference in the interactive
    experience quickly became a nuisance and people started thinking about solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most prominent of those solutions is AJAX. It''s an abbreviation
    for asynchronous JavaScript and XML, that is, a method to retrieve data by using
    the browser''s built-in JavaScript capabilities. Nowadays, every browser supports
    AJAX and the jQuery library smoothes out most browser inconsistencies. The XML
    part in the name is no longer relevant as the data that might be retrieved with
    an AJAX call might be just about anything: besides XML and its close cousin HTML,
    **JavaScript Object Notation** (JSON) is a popular format to transmit data that
    might be processed even more simply than XML by the JavaScript interpreter in
    the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asynchronous bit in the AJAX name is still relevant, however: most AJAX
    calls that retrieve data return immediately without waiting for the result. However,
    they do call a function when the data retrieval is complete. This ensures that
    other parts of the application are not stalled and that the overall interactive
    experience of the web application can be improved.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action getting the time with AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enter the following code and run it. If you point your web browser to the familiar
    [http://localhost:8080](http://localhost:8080) address, you will see something
    similar to the picture below with the time changing every five seconds or so.
    (The code is also available as `timer.py)`
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action getting the time with AJAX](img/3746_4_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our small CherryPy application offers just two methods (both highlighted in
    the code). The `index()` method returns a minimalistic HTML page with some static
    text and a small piece of JavaScript that takes care of retrieving the current
    time from the server. It also features a `time()` method that simply returns the
    current time as plain text.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/timer.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The magic is in that small piece of JavaScript (highlighted). This script is
    executed once the static page is loaded and it calls the `setInterval()` method
    of the `window` object. The arguments to the `setInterval()` method are an anonymous
    function and a time interval in milliseconds. We set the time interval to five
    seconds. The function passed to `setInterval()` is called at the end of each interval.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we pass an anonymous function to `setInterval()` that relies
    on jQuery's `ajax()` function to retrieve the time. The `ajax()` function's only
    argument is an object that may contain numerous options. The `url` option tells
    which URL to use to retrieve the data from, in this case, the relative URL `time`
    (relative to the page that serves the content the script is embedded in, `/`,
    so it actually refers to `http://localhost:8080/time)`.
  prefs: []
  type: TYPE_NORMAL
- en: The `cache` option is set to `false` to prevent the browser from using a cached
    result when instructed to get the time URL it has seen already. This is ensured
    by the underlying JavaScript library by appending an extra `_` parameter (that
    is the name of this parameter which consists of a single underscore) to the URL.
    This extra parameter contains a random number, so the browser will regard each
    call as a call to a new URL. The `time()` method is defined to accept this parameter
    because otherwise CherryPy would raise an exception, but the contents of the parameter
    are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `success` option is set to a function that will be called when the data
    is successfully received. This function will receive three arguments when called:
    the data that was retrieved by the `ajax()` function, the status, and the original
    request object. We will only use the data here.'
  prefs: []
  type: TYPE_NORMAL
- en: We select the`<div>` element with the `time` ID and replace its contents by
    passing the data to its `html()` method. Note that even though the `time()` method
    just produces text, it could just as easily have returned text containing some
    markup this way.
  prefs: []
  type: TYPE_NORMAL
- en: We explicitly instructed the `ajax()` function not to cache the result of the
    query, but instead we could also decorate our `time()` method with CherryPy's
    `expires` tool. This would instruct the `time()` method to insert the correct
    http headers in response to instruct the browser not to cache the results. This
    is illustrated in the following code (available in `timer2.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `@cherrypy.tools.expires` decorator means we do not have to instruct
    the `ajax()` method not to cache the result, which gives us the option to use
    a shortcut method. The JavaScript code may then be rewritten to use jQuery''s
    `load()` method, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `load()` method is passed the URL where it will retrieve the data and, upon
    success, will replace the contents of the selected `DOMelement` with the data
    it received.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'jQuery provides many AJAX shortcut methods and all these methods share a common
    set of defaults that may be set using the `ajaxSetup()` function. For example,
    to make sure all AJAX methods will not cache any returned result, we could call
    it like this: `$.ajaxSetup({cache:false})`;'
  prefs: []
  type: TYPE_NORMAL
- en: Redesigning the Tasklist application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The tasklist application will consist of two parts: an authentication part
    for which we will reuse the `LogonDB` class and new `TaskApp` class. The `TaskApp`
    class will implement the methods necessary to deliver the page with an overview
    of all tasks for the authenticated user plus additional methods to respond to
    AJAX requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a filesystem, SQLite will be used to store the tasks for all users.
    Note that this is a separate database from the one used to store usernames and
    passwords. Such a setup allows us to keep the authentication functionality separate
    from other concerns, allowing for easier reuse. Once the user is authenticated,
    we do, of course, use his/her username to identify the tasks belonging to him/her.
  prefs: []
  type: TYPE_NORMAL
- en: Access to the task database will be encapsulated in a `tasklistdb` module. It
    provides classes and methods to retrieve, add, and modify tasks for a given user.
    It is not concerned with checking access permission, as this is the responsibility
    of the `TaskApp` class. You can picture this separation as a two layer model,
    the top layer checking user credentials and serving content, and the bottom layer
    actually interfacing with a database.
  prefs: []
  type: TYPE_NORMAL
- en: '![Redesigning the Tasklist application](img/3746OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Database design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The design of our task database (the database *schema)* is very straightforward.
    It consists of a single table, which contains columns to define a task.
  prefs: []
  type: TYPE_NORMAL
- en: '| Task |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| task_id | description | duedate | completed | user_id |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| integerprimary keyautoincrement |   |   |   |   |'
  prefs: []
  type: TYPE_TB
- en: Most columns do not have a specific type defined, as SQLite will let us store
    anything in a column. Furthermore, most columns do not have special constraints
    except for the `task_id` column that we designate to be the primary key. We do
    explicitly type the `task_id` column as an integer and designate it as `autoincrement`.
    This way, we do not have to set the value of this column explicitly, but a new
    unique integer will be inserted for us every time we add a new task to the table.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action creating the task database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let us take some time to familiarize with the steps necessary to create
    a new database from Python.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following code and run it (It is also available as `taskdb1.py)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/taskdb1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It will create a temporary database in memory and defines a task table. It also
    populates this table with a number of tasks using INSERT statements.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After establishing a connection to the database, the first task is to create
    the `task` table (highlighted). Here we use the `executescript()` method of the
    `connection` object, because this method allows us to pass more than one SQL statement
    in one go. Here our database schema consists of a single `create` statement so
    the `execute()` method would do just as well, but normally when creating a database,
    we create a number of tables and then passing all necessary SQL statements together
    is very convenient.
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the `create` statement, you may notice it features a `if not
    exists` clause. This is completely redundant in this example because a freshly
    opened in-memory database is always empty, but should our database reside on disk,
    it might contain all the tables we want already. Once we have created the table,
    we commit our changes to the database with the `commit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The second highlighted line shows how we may create an insert statement that
    will insert new records in the task table. The values we will insert are placeholders,
    each represented by a question mark. In the next four lines, we execute this insert
    statement and supply a tuple of values that will be inserted in place of those
    placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action retrieving information with select statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In SQL, the `select` statement can be used to retrieve records from a database.
    How would you express a query to retrieve all tasks belonging to the user john?
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: `select * from task where user_id = ''john''`'
  prefs: []
  type: TYPE_NORMAL
- en: We may implement this in Python as follows (only relevant lines shown, complete
    implementation is available as `taskdb2.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/tasktdb2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first line in the code is normally placed just after establishing a connection
    to the database and ensures that any row returned from a `fetchone()` or `fetchall()`
    method are not plain tuples, but `sqlite3.Row` objects. These objects behave just
    like tuples, but their fields can be indexed by the name of the column they represent
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The query is executed by passing it to the `execute()` method of the cursor
    attribute (highlighted) and the results are then retrieved with the `fetchall()`
    method that will return a list of tuples, each tuple representing a matching record,
    its elements equal to the columns. We print some of those elements by indexing
    the tuples with the column names we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `taskdb2.py` is run, the output will show a list of task records, each
    with a date and a description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pop quiz using variable selection criteria
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time we would like to pass the `user_id` to match as a variable.
    As we saw in the insert statements used in `taskdb1.py`, it is possible to construct
    a query using `?` as placeholders. This way, we could pass a variable containing
    a `user_id` to the execute method. How would you refactor the code to select all
    records for a user whose `user_id` is contained in the variable `username?`
  prefs: []
  type: TYPE_NORMAL
- en: TaskDB interfacing with the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we are ready to take on the real implementation of the database interface
    needed for the tasklist application.
  prefs: []
  type: TYPE_NORMAL
- en: The database interface layer will have to provide functionality to initialize
    a database and to provide thread-safe ways to create, retrieve, update, and delete
    tasks (collectively, often called **CRUD)** as well as list all tasks for a given
    user. The code to do this is contained in two classes, `Task` and `TaskDB` (both
    available in `tasklistdb.py). TaskDB` encapsulates the connection to the database
    and contains code to initialize the database as well as methods to retrieve a
    selection of tasks and to create new tasks. These tasks are implemented as instances
    of the `Task` class and a `Task` instance may be updated or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action connecting to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first have a look at the `TaskDB` class. It consists of a constructor
    `__init__()` that takes the filename where the database will reside as a parameter.
    It calls a private method to initialize this database, and like the `LogonDB`
    class, creates some storage to hold connection objects for each thread (highlighted).
    It also defines a `connect()` method that should be called once for each thread
    and stores a thread-specific connection object. It also sets the `row_factory`
    attribute of the connection to `sqlite3.Row`. This causes the tuples returned
    by, for example, `fetchall()` to have their fields named after the columns they
    represent. This makes sense as `t['user_id']` is a lot more self documenting than
    `t[1]`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/tasklistdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for the `__init__()` method did not initialize any table in the database
    itself, but delegated this to the `_initdb()` method. This method starts with
    an underscore so it is private by convention (but by convention only). It is meant
    to be called just from `__init__()` and initializes the database, if necessary.
    It opens a connection to the database and executes a multiline statement (highlighted).
    Here we use `create if not exists` to create the `task` table, but only if it
    is not already present. So if we start the application for the first time, the
    database will be completely empty and this statement will create a new table named
    task. If we start the application again later, this statement will not do anything.
    Before closing the connection, we commit our changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/tasklistdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Time for action storing and retrieving information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final part of the `TaskDB` class defines three methods, `create()` that
    will create a completely new `Task` instance, `retrieve()` that will fetch a task
    from the `task` table given a `task_id` and return it as a `Task` instance, and
    `list()` that will return a list of `task_ids` for a given user.
  prefs: []
  type: TYPE_NORMAL
- en: We separated `retrieve()` and `list()` because retrieving an object complete
    with all its attributes might be quite expensive and not always needed. For example,
    if we were to select a list with thousands of tasks, we would likely display them
    as a page of about twenty tasks each. If we were to retrieve complete information
    for all those tasks, we might have to wait a while, so we might choose to instantiate
    only a first page-full of them and fetch the rest on an as-needed basis as the
    users step through the pages. We will encounter this pattern a few more times
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The `create()` method itself simply passes on all parameters to the `Task` constructor
    together with the thread local storage that holds the database connection. It
    returns the resulting `Task` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `retrieve()` method takes the username and the ID of the task to retrieve.
    The username is taken as a sanity check, but not strictly necessary. If a record
    is found that matches both the `task_id` and the `username`, a `Task` instance
    is created and returned (highlighted). If no such record could be found, a `KeyError`
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The `list()` method returns a list of `task_ids` for a given user. It constructs
    this list from the list of tuples returned by taking the first (and only) item
    from each tuple (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/tasklistdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The constructor for `Task` takes a number of optional parameters together with
    a mandatory username and a `taskdb` parameter that point to the thread local data
    that holds the database connections. If the `duedate` parameter is not given,
    it assigns it the date of today (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The construction of Task instances in the previous code deserves a closer look.
    Based on the value of the `id` parameter, the constructor can do two things.
  prefs: []
  type: TYPE_NORMAL
- en: If the `id` is known, this `Task` instance is constructed based on data just
    retrieved from a database query so there is nothing more to be done as all parameters
    are already stored as instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: However, if `id` is not given (or `None)`, we apparently are creating a completely
    new `Task` that is not already present in the database. Therefore, we have to
    insert it into the task table using an `insert` statement (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: We do not pass a new `task_id` as a value to this `insert` statement, but one
    will be created for us because we defined the `task_id` column as `integer primary
    key autoincrement`. This generated number is available from the cursor's `lastrowid`
    attribute and we store that for later reuse. All this is quite SQLite-specific,
    for more information, refer to the information box.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only an `integer primary key` column can be defined as `autoincrement` and only
    an `integer primary key autoincrement` column will mapped to the internal `rowid`
    column (and that is not even a real column). All this is very useful, but also
    quite SQLite-specific. More information on this subject can be found on the SQLite
    FAQ at [http://www.sqlite.org/faq.html](http://www.sqlite.org/faq.html) and in
    the section on rowid in the SQL reference at [http://www.sqlite.org/lang_createtable.html#rowid](http://www.sqlite.org/lang_createtable.html#rowid).
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/tasklistdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Time for action updating and deleting information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating the record for a `Task` is all about constructing the correct `update`
    query. `update` will alter any records that match the conditions in the `where`
    clause. It will change only those columns mentioned in its `set` clause so we
    start by constructing this `set` clause (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: Joining a list of parameters and interpolating it into an SQL query might be
    a bit overdone but if we later want to add an extra attribute, this would be very
    simple (and our SQL query string now fits on a single line, making it a lot easier
    to read and typeset).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have executed the insert, we check the number of rows affected. This
    value is available as the `rowcount` attribute of the `cursor` object and should
    be `1` as we used the unique `task_id` to select the records. If it isn't `1`,
    something strange has happened and we roll back the insert and raise an exception.
    If it went well, we commit our changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/tasklistdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To delete a task with a given task ID, all we have to do is execute a `delete
    query` on the `task` table with an expression in the `where` clause that matches
    our `task_id`, just like we did for an update. We do check that our delete query
    affects a single record only (highlighted) and roll back otherwise. This shouldn't
    happen, but it is better to be safe than sorry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developing software without testing it is a little bit like driving a car with
    your eyes closed: if the road is straight you might get surprisingly far, but
    chances are you will crash within a few seconds. Testing, in other words, is good.'
  prefs: []
  type: TYPE_NORMAL
- en: It does take time, however, to test an application thoroughly, so it makes sense
    to automate the testing process as much as possible. If tests can be executed
    easily, it encourages developers to run these tests often. This is desirable when
    the implementation changes. It can also act as a sanity check just before a new
    release. So although writing serious tests may sometimes take about as long as
    writing the code itself, this is a solid investment, as it might prevent many
    unwelcome surprises if the code is changed or the environment in which the code
    is deployed is altered.
  prefs: []
  type: TYPE_NORMAL
- en: There are many aspects of an application that you might like to test, but not
    all lend themselves to automatic testing, like user interaction (although tools
    like Selenium can get you quite far. More information on this tool is available
    at [http://seleniumhq.org/)](http://seleniumhq.org/)). However, other parts are
    quite simple to automate.
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a `unittest` module that simplifies the task of repeatedly
    testing small functional units of code. The idea of unit testing is to isolate
    small chunks of code and define its expected behavior by asserting any number
    of expectations. If one of those assertions fails, the test fails. (There is much
    more to unit testing than can be fully covered in this book. Here we cover just
    the bare minimum to get a taste of the possibilities and we cover a few examples
    that are intended to give you enough information to understand the test suites
    supplied with the example code for this book. If you would like to read more on
    unit testing in Python, a good starting point would be *Python Testing* by *Daniel
    Arbuckle, Packt Publishing*, 978-1-847198-84-6).
  prefs: []
  type: TYPE_NORMAL
- en: Python's `unittest` module contains a number of classes and functions that enable
    us to write and run groups of tests and their associated assertions. For example,
    say we have a module called `factorial` that defines a function `fac()` to calculate
    a factorial.
  prefs: []
  type: TYPE_NORMAL
- en: A factorial of a number n is the product of all numbers from 1 to n inclusive.
    For example, `fac(4) = 4 * 3 * 2 * 1 = 24`. Zero is an exceptional case as the
    factorial of 0 = 1\. Factorials are only defined for integers >= 0, so we design
    our code to raise `ValueError` exceptions if the argument `n` is not an `int`
    or is negative (highlighted). The factorial itself is calculated recursively.
    If `n` is either zero or one, we return one, otherwise we return the factorial
    of `n` minus one times `n:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/factorial.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The code is available as `factorial.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action testing factorial.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The test suite to accompany `factorial.py` is called `test_factorial.py`. Run
    it and you should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Three tests were executed and apparently everything went ok.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code in `test_factorial.py` starts by importing both the module we want
    to test (factorial) and the `unittest` module. Then we define a single class named
    `Test` (highlighted) derived from `unittest.TestCase`. By deriving from this class,
    our class will be distinguishable as a test case to the test runner and will provide
    us with a number of **assertion** methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Test` class may consist of any number of methods. The ones with names
    starting with `test_` will be recognized as tests by the test runner. Because
    the names of failing tests will be printed, it is useful to give these tests sensible
    names reflecting their purpose. Here we define three such methods: `test_number(),
    test_zero()`, and `test_illegal()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/test_factorial.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`test_number()` tests a number of regular cases to see if our function returns
    something reasonable. In this case, we check three different numbers and use the
    `assertEquals()` method inherited from the `TestCase` class to check that the
    value calculated (passed as the second argument) equals the expected value (the
    first argument).'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_zero()` asserts that the special case of zero indeed returns 1\. It again
    uses the `assertEqual()` method to check whether the expected value (1) matches
    the value returned.'
  prefs: []
  type: TYPE_NORMAL
- en: '`test_illegal()` finally asserts that only positive arguments are accepted
    (or rather it asserts that negative values correctly raise a `ValueError` exception)
    and that arguments to `fac()` should be `int` or raise a `ValueError` as well.'
  prefs: []
  type: TYPE_NORMAL
- en: It utilizes the method `assertRaises()` provided by `TestCase. assertRaises()`
    will return an object that can be used as a context manager in a with statement.
    Effectively, it will catch any exception and check whether it is an expected one.
    If not, it will flag the test as failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods show a familiar pattern in unit testing: a fairly small number
    of tests check whether the unit behaves correctly in normal cases, while the bulk
    of the tests are often devoted to special cases (often referred to as edge cases).
    And, just as important, serious effort is spent on testing that illegal cases
    are correctly flagged as such.'
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we find in `test_factorial.py` is a call to `unittest.main()`,
    the test runner. It will look for any defined classes deriving from `TestCase`
    and run any method that starts with `test_`, tallying the results.
  prefs: []
  type: TYPE_NORMAL
- en: Now what have we gained?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we would change, for example, the implementation of `fac()` to something
    that does not use recursion like the following code, we could rapidly check that
    it behaves as expected by running `test_factorial.py` again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The special case handling remains the same, but the highlighted line shows that
    we now calculate the factorial with Python's `reduce()` function from the `functools`
    module. The `reduce()` function will apply a function to the first pair of items
    in a list and then again to the result of this and each remaining item. The product
    of all numbers in a list can be calculated by passing `reduce()` a function that
    will return the product of two arguments, in this case, our lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More on the `reduce()` function can be found in the documentation of the `functools`
    module, Python''s powerful functional programming library: [http://docs.python.org/py3k/library/functools.html](http://docs.python.org/py3k/library/functools.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz spotting the error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can you anticipate any errors in the previous code? Which test method will fail?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`test_number()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_zero()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_illegal()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action writing unit tests for tasklistdb.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run `test_tasklistdb.py` (provided in the code distribution for this chapter).
    The output should be a list of test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us look at one of the classes defined in `test_tasklistdb.py, DBentityTest.
    DBentityTest` contains a number of methods starting with `test_`. These are the
    actual tests and they verify whether some common operations like retrieving or
    deleting tasks behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/test_tasklistdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All these `test_` methods depend on an initialized database containing at least
    one task and an open connection to this database. Instead of repeating this setup
    for each test, `DBentityTest` contains the special method `setUp()` (highlighted)
    that removes any test database lingering around from a previous test and then
    instantiates a `TestDB` object. This will initialize the database with proper
    table definitions. Then it connects to this new database and creates a single
    task object. All tests now can rely upon their initial environment to be the same.
    The corresponding `tearDown()` method is provided to close the database connection
    and remove the database file.
  prefs: []
  type: TYPE_NORMAL
- en: The file that is used to store the temporary database is created with the `mkstemp()`
    function from Python's `tempfile` module and stored in the global variable database.
    (mkstemp() returns the number of the file handle of the opened as well, which
    is immediately used to close the file as we are only interested in the name of
    the file.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `test_list()` and `test_delete()` methods feature a new assertion: `assertListEqual()`.
    This assertion checks whether two lists have the same items (and in the same order,
    hence the `sorted()` calls). The `unittest` module contains a whole host of specialized
    assertions that can be applied for specific comparisons. Check Python''s online
    documentation for the `unittest` module for more details (http://docs.python.org/py3k/library/unittest.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the modules we develop in this book come bundled with a suite of unit
    tests. We will not examine those tests in any detail, but it might be educational
    to check some of them. You should certainly use them if you experiment with the
    code as that is exactly what they are for.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for AJAX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using AJAX to retrieve data not only has the potential to make the tasklist
    application more responsive, but it will also make it simpler. This is achieved
    because the HTML will be simpler as there will be no need for the many`<form>`
    elements we created to accommodate the various delete and done buttons. Instead,
    we will simply act on click events bound to buttons and call small methods in
    our CherryPy application. All these functions have to do is perform the action
    and return ok, whereas in the previous version of our application, we would have
    to return a completely new page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, apart from a number of`<script>` elements in the`<head>`, the core
    HTML in the body is rather short (the`<header>` element and the extra elements
    in the`<div>` element with a `taskheader` class are omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The`<div>` element containing the input fields and a submit button takes up
    most of the space. It structures the elements that make up the line that allows
    the user to add new tasks. The`<div>` element with the ID `items` will hold a
    list of tasks and will be initialized and managed by the JavaScript code using
    AJAX calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript code in `tasklistajax.js` serves a number of goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the list of items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling and enhancing UI elements with interactive widgets (like a `datepicker)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining and refreshing the list of tasks based on button clicks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a look at `tasklistajax.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/static/js/tasklistajax.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first line establishes the defaults for all AJAX calls that we will use.
    It makes sure that the browser will not cache any results.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the list of items once the page is loaded is done in the final
    highlighted line of code. It calls the `load()` method with a URL that will be
    handled by our application and will return a list of tasks. If the call to `load()`
    is successful, it will not only insert this data in the selected`<div>` element,
    but also call the function `itemmakeup()` passed to it as a second argument. That
    function, `itemmakeup()`, is defined in the beginning of the file. It will style
    any`<button>` element with a `done-button` or `del-button` class with a suitable
    icon. We do not add any event handlers to those buttons here, which is done elsewhere
    as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `sort` plugin to sort the items (highlighted), that is, we
    select any input field with the `duedate` class that are children of the`<div>`
    element with the ID `items` (we do not want to consider input fields that are
    part of the new item div for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'The sort plugin is available as sort.js and is based on code by James Padolsey:
    [http://james.padolsey.com/javascript/sorting-elements-with-jquery/](http://james.padolsey.com/javascript/sorting-elements-with-jquery/).
    The plugin will sort any list of HTML elements and takes two arguments. The first
    argument is a comparison function that will return either 1 or -1 and the second
    argument is a function that when given an element will return the element that
    should actually be moved around. This allows us to compare the values of child
    elements while swapping the parent elements they are contained in.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, here we compare the due dates. That is, the content of the selected`<input>`
    elements, as retrieved by their `val()` method, but we sort not the actual input
    fields but their parents, the`<div>` elements containing all elements that make
    up a task.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `itemmakeup()` makes sure any button marked with a `done` class is
    disabled as is any input element with that class to prevent completed tasks from
    being altered and changes any input element with an `editable-date` class into
    a datapicker widget to allow the user to choose a completion date before marking
    a task as done.
  prefs: []
  type: TYPE_NORMAL
- en: Click handlers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides styling elements, the `$(document).ready()` function adds click handlers
    to the add, done, and delete buttons (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: Only one add button is created when the page is created, so we can add a click
    handler with the `click()` method. However, new done and delete buttons may appear
    each time the list of items is refreshed. To ensure that freshly appearing buttons
    that match the same selection criteria receive the same event handler as the ones
    present now, we call the `live()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jQuery's `live()` method will make sure any event handler is attached to any
    element that matches some criterion, now or in the future. More on jQuery's event
    methods can be found at [http://api.jquery.com/category/events/](http://api.jquery.com/category/events/).
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the way we bind an event handler to a button, the actions associated
    with a click are similar for all buttons. We retrieve the data we want to pass
    to the server by selecting the appropriate input elements from among the button's
    siblings with the `siblings()` method. As each task is represented by its own`<div>`
    element in the list and the`<button>` and`<input>` elements are all children of
    that`<div>` element, so selecting sibling input elements only ensures that we
    refer to elements of a single task only.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better understanding of what we are selecting with the `siblings()`
    method, take a look at some of the (simplified) HTML that is generated for the
    list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So each`<div>` that represents a task contains a number of`<input>` elements
    and some`<button>` elements. The siblings of any`<button>` element are the elements
    within the same`<div>` (without the button itself).
  prefs: []
  type: TYPE_NORMAL
- en: When we have gathered the relevant data from the input elements, this data is
    then passed to a `get()` call. The `get()` function is another AJAX shortcut that
    will make an HTTP GET request to the URL given as its first argument (a different
    URL for each button type). The data passed to the `get()` function is appended
    to the GET request as parameters. Upon success, the function passed as the third
    argument to `get()` is called. This is the same `itemmakeup()` function that refreshes
    the list of items that was used when the page was first loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the JavaScript to implement the interactivity and the means to access the
    database in place, we still have to define a class that can act as a CherryPy
    application. It is available as `taskapp.py` and here we show the relevant bits
    only (Its `index()` method is omitted because it simply delivers the HTML shown
    earlier).
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/taskapp.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The constructor for `TaskApp` stores a reference to a `LogonDB` instance in
    order to be able to call its `checkauth()` method in exposed methods to authenticate
    a user. It also stores the `logoffpath`, a URL to a page that will end the user's
    session. The `dbpath` argument is the filename of the file that holds the tasklist
    database. It is used to create an instance of `TaskDB`, used in subsequent methods
    to access the data (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: The `connect()` method should be called for each new CherryPy thread and simply
    calls the corresponding method on the `TaskDB` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To service the AJAX calls of the application, `TaskApp` exposes four short
    methods: `list()` to generate a list of tasks, `add()` to add a new task, and
    `done()` and `delete()` to mark a task as done or to remove a task respectively.
    All take a dummy argument named `_` (a single underscore) that is ignored. It
    is added by the AJAX call in the browser to prevent caching of the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '`list()` is the longer one and starts out with authenticating the user making
    the request (highlighted). If the user is logged in, this will yield the username.
    This username is then passed as an argument to the `taskdb.list()` method to retrieve
    a list of task IDs belonging to this user.'
  prefs: []
  type: TYPE_NORMAL
- en: With each ID, a `Task` instance is created that holds all information for that
    task (highlighted). This information is used to construct the HTML that makes
    up the task as visualized on screen. Finally, all HTML of the individual tasks
    is joined and returned to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/taskapp.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The other methods are quite similar to each other. `add()` takes `description`
    and `duedate` as arguments and passes them together with the username it got after
    authentication of the user to the `create()` method of the `TaskDB` instance.
    It returns ''ok'' to indicate success. (Note that an empty string would do just
    as well: it''s the return code that matters, but this makes it more obvious to
    anyone reading the code).'
  prefs: []
  type: TYPE_NORMAL
- en: The `delete()` method (highlighted) has one relevant argument, `id`. This ID
    is used together with the username to retrieve a `Task` instance. This instance's
    `delete()` method is then called to remove this task from the database.
  prefs: []
  type: TYPE_NORMAL
- en: The `done()` method (highlighted) also takes an `id` argument together with
    `completed`. The latter either holds a date or is empty, in which case it is set
    to today's date. A `Task` instance is retrieved in the same manner as for the
    `delete()` method, but now its `completed` attribute is set with the contents
    of the argument of the same name and its `update()` method is called to synchronize
    this update with the database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/taskapp.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Time for action putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the requisite components in place (that is, `tasklistdb.py,
    taskapp.py`, and `tasklistajax.js)`, it is straightforward to put them together.
    If you run the code below (available as `tasklist.py)` and point your browser
    at [http://localhost:8080/](http://localhost:8080/), you will get a familiar looking
    login screen and after entering some credentials (username admin and password
    admin are configured by default) the resulting screen will look almost the same
    as the application we developed in the previous chapter, as illustrated in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action putting it all together](img/3746_4_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the CherryPy application, we need a root class that can act as the root
    of the tree of pages we serve the user. Again, we call this class simply `Root`
    and assign an instance of our `TaskApp` application to the task variable and an
    instance of the `LogonDB` application to the logon variable (highlighted in the
    code below). Together with the `index()` method, this will create a tree of pages
    looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If the user starts on the top-level page or on the logon page, he/she will be
    redirected to the `/task` page after successful authentication. Below the `/task`
    page are, of course, the other pages that implement the server side of the AJAX
    communications like, for example, `/task/add`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter4/tasklist.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Before the CherryPy application is started in the usual way by calling the `quickstart()`
    function, we first initialize the authentication database and create a function
    `connect()` (highlighted). This is the function we will register with CherryPy
    to execute each time CherryPy starts a new thread. The function will create a
    connection to the SQLite databases containing the authentication and tasklist
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero refreshing the itemlist on a regular basis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were to access your tasklist from home and keep the application open
    and later access it from, for example, your work, any changes made to the list
    from work wouldn't be visible at home unless you refreshed the page manually.
    This is because there is nothing implemented to refresh the list of tasks regularly;
    it is refreshed only after some action is initiated by clicking a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'How could you implement a regular refresh? Hint: in the first AJAX example,
    we encountered JavaScript''s `setInterval()` method. Can you devise a way to let
    it replace the contents of the`<div>` element containing the list of tasks using
    the `load()` method?'
  prefs: []
  type: TYPE_NORMAL
- en: An example implementation is available in `tasklistajax2.js`. You can either
    rename it to `tasklistajax.js` and run `tasklist.py` or run `tasklist2.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned a lot in this chapter about using a database to store persistent
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of using a database engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use SQLite, a database engine distributed with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a password database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design and develop a database-driven tasklist application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement unit tests with Python's `unittest` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make a web application more responsive using AJAX calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discussed how to make a web application respond to mouse clicks and
    request new data from the server without using`<form>` elements but using jQuery's
    `click()` and `live()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've made the first step in using a database, we're ready to create
    more elaborate databases designs, consisting of more than a single table, and
    look at the methods to define relations between these tables which is the topic
    of the next chapter.
  prefs: []
  type: TYPE_NORMAL
