- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internationalization and Localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications are usually not limited to one geographical region or only
    serve people from one linguistic domain. For example, a web application intended
    for users in Europe will be expected to support more than one European language,
    such as German, French, Italian, and Spanish, as well as English. This chapter
    will cover the basics of how to enable support for multiple languages in a Flask
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for a second language in any web application is a tricky affair.
    It increases the overhead a bit every time some change is made to the application,
    and this increases with the number of languages. There can be a number of things
    that need to be taken care of, apart from just changing the text, depending on
    the language. Some of the major things that need changing are currency, number,
    time, and date formatting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flask-Babel**, an extension that adds **internationalization** (**i18n**)
    and **localization** (**l10n**) support to any Flask application, provides a number
    of tools and techniques to make this process easy to implement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing lazy evaluation and the `gettext`/`ngettext` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the global language-switching action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, English is the language for applications built in Flask (and almost
    all web frameworks). In this recipe, we will add a second language to our application
    and add some translations for the display strings used in the application. The
    language displayed to the user will vary depending on the language that is currently
    set in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start with the installation of the `Flask-Babel` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This extension uses **Babel** and **pytz** to add i18n and l10n support to the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: We will use our catalog application from [*Chapter 5*](B19111_05.xhtml#_idTextAnchor273),
    *Web Forms* *with WTForms*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use French as the second language. Follow these steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the configuration part by creating an instance of the `Babel` class,
    using the `app` object in `my_app/__init__.py`. We will also specify all the languages
    that will be available here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Here, we used `en` and `fr` as the language codes. These refer to English (standard)
    and French (standard), respectively. If we intend to support multiple languages
    that are from the same standard language origin, but differ on the basis of region,
    such as English (US) and English (GB), then we should use codes such as `en-us`
    and `en-gb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The locale of the application depends on the output of the method that is provided
    while initializing the `babel` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding method gets the `accept_languages` header from the request and
    finds the language that best matches the languages we allow.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can change the language preferences of your browser to test the application’s
    behavior in another language.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, it used to be pretty easy to change the language preferences in the
    browser, but with the locale becoming more ingrained in the OS, it has become
    difficult to do so without changing the global locale of the OS. Hence, if you
    do not want to mess with the language preferences of the browser or your OS, simply
    return the expected language code from the `get_locale()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a file in the application folder called `babel.cfg`. The path
    of this file will be `my_app/babel.cfg`, and it will have the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the first two lines tell `Babel` about the filename patterns that are
    to be searched for marked translatable text.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In earlier versions of this book, I suggested loading a couple of extensions
    from Jinja2, namely, `jinja2.ext.autoescape` and `jinja2.ext.with_`. But as of
    version 3.1.0 of Jinja, these modules have got built-in support and, hence, there
    is no need to load them separately now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, mark some text that is intended to be translated as per the language.
    Let’s start with the first text we see when we start our application, which is
    in `home.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `_` is a shortcut for the `gettext` function provided by Babel to translate
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, run the following commands so that the marked text is actually
    available as translated text in our template when it is rendered in the browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command traverses the content of the files. This command matches
    the patterns in `babel.cfg` and picks out the texts that have been marked as translatable.
    All these texts are placed in the `my_app/messages.pot` file. The following is
    the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to create a `.po` file that will hold the translations
    for the texts to be translated into:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file is created in the specified folder, `my_app/translations`, as `fr/LC_MESSAGES/messages.po`.
    As we add more languages, more folders will be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add translations to the `messages.po` file. This can be performed manually,
    or we can use GUI tools such as Poedit ([http://poedit.net/](http://poedit.net/)).
    Using this tool, the translations will look as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Poedit screen while editing translations](img/B19111_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Poedit screen while editing translations
  prefs: []
  type: TYPE_NORMAL
- en: 'Manually editing `messages.po` will look as in the following code. Only one
    message translation is shown for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the `messages.po` file after the translations have been incorporated and
    run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a `messages.mo` file next to the `message.po` file, which will
    be used by the application to render the translated text.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the messages do not get compiled after running the preceding command.
    This is because the messages might be marked as fuzzy (starting with a `#` symbol).
    These need to be looked into by a human, and the `#` sign has to be removed if
    the message is OK to be updated by the compiler. To bypass this check, add an
    `-f` flag to the preceding `compile` command, as it will force everything to be
    compiled.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we run the application with French set as the primary language in the browser
    (or returned as the language of choice from the `get_locale()` method), the home
    page will look as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Home page in French](img/B19111_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Home page in French
  prefs: []
  type: TYPE_NORMAL
- en: If the primary language is set to a language other than French, then the content
    will be shown in English, which is the default language.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next time, if there is a need to update the translations in our `messages.po`
    file, we do not need to call the `init` command again. Instead, we can run an
    `update` command, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After this, run the `compile` command as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: It is often preferable to change the language of a website based on the user
    IP and location (determined from the IP). However, this is, in general, less recommended
    than using the accept-language header as we did in our application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to the *Implementing the global language-switching action* recipe later
    in this chapter, which allows the user to change the language directly from the
    application rather than doing it at the browser level.
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect of multiple languages is to be able to format the date,
    time, and currency accordingly. Babel also handles this pretty neatly. I urge
    you to try your hand at this. Refer to the Babel documentation, available at [http://babel.pocoo.org/en/latest/](http://babel.pocoo.org/en/latest/),
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing lazy evaluation and the gettext/ngettext functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy evaluation is an evaluation strategy that delays the evaluation of an expression
    until its value is needed; that is, it is a call-when-needed mechanism. In our
    application, there can be several instances of texts that are evaluated later
    while rendering the template. This usually happens when we have texts that are
    marked as translatable outside the request context, so we defer the evaluation
    of these until they are actually needed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with the application from the previous recipe. Now, we want the
    labels in the product and category creation forms to show the translated values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps in order to implement the lazy evaluation of translations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To mark all the field labels in the product and category forms as translatable,
    make the following changes to `my_app/catalog/models.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that all the field labels are enclosed within `_()` to be marked for
    translation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the `extract` and `update pybabel` commands to update the `messages.po`
    file, and then fill in the relevant translations and run the `compile` command.
    Refer to the previous recipe, *Adding a new language*, for details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the product creation page using the following link: `http://127.0.0.1:5000/product-create`.
    Does it work as expected? No! As most of us would have guessed by now, the reason
    for this behavior is that this text is marked for translation outside the request
    context.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To make this work, modify the `import` statement to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have more text to translate. Let’s say we want to translate the product
    creation flash message content, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To mark it as translatable, we cannot simply wrap the whole thing inside `_()`
    or `gettext()`. The `gettext()` function supports placeholders, which can be used
    as `%(name)s`. Using this, the preceding code will become something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The resulting translated text for this will be something like `La produit %(name)s
    a` `été créée`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be cases where we need to manage the translations based on the number
    of items, that is, singular or plural names. This is handled by the `ngettext()`
    method. Let’s take an example where we want to show the number of pages in our
    `products.html` template. For this, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the template will render `page` if there is only one page, and `pages`
    if there is more than one page.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is interesting to note how this translation appears in the `messages.po`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the product creation form at `http://127.0.0.1:5000/product-create`. The
    following screenshot shows how it would look with translation to French:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.3 – Form fields translated using l\uFEFFazy evaluation](img/B19111_09_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Form fields translated using lazy evaluation
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the global language-switching action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we saw that the language changes based on the current
    language preferences in the browser. Now, however, we want a mechanism where we
    can switch the language being used, irrespective of the language in the browser.
    In this recipe, we will understand how to handle changing the language at the
    application level.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start by modifying the application from the last recipe, *Implementing lazy
    evaluation and the gettext/ngettext functions*, to accommodate the changes to
    enable language switching. We will add an extra URL part to all our routes to
    allow us to add the current language. We can just change this language part in
    the URL in order to switch between languages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observe the following steps to understand how to implement language switching
    globally:'
  prefs: []
  type: TYPE_NORMAL
- en: First, modify all the URL rules to accommodate an extra URL part. `@catalog.route('/')`
    will become `@catalog.route('/<lang>/')`, and `@catalog.route('/home')` will become
    `@catalog.route('/<lang>/home')`. Similarly, `@catalog.route('/product-search/<int:page>')`
    will become `@catalog.route('/<lang>/product-search/<int:page>')`. The same needs
    to be done for all the URL rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add a function that will add the language passed in the URL to the global
    proxy object, `g`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will run before each request and add the current language to `g`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this will mean that all the `url_for()` calls in the application need
    to be modified so that an extra parameter called `lang` can be passed. Fortunately,
    there is an easy way out of this, which is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we first imported `url_for` from `flask` as `flask_url_for`.
    Then, we updated the application context processor to have the `url_for()` function,
    which is a modified version of `url_for()` provided by Flask in order to have
    `lang` as an extra parameter. Also, we used the same `url_for()` method that we
    used in our views.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, run the application as it is, and you will notice that all the URLs have
    a language part. The following two screenshots show what the rendered templates
    will look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'For English, the following screenshot shows what the home page looks like after
    opening `http://127.0.0.1:5000/en/home`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Home page in English](img/B19111_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Home page in English
  prefs: []
  type: TYPE_NORMAL
- en: 'For French, just change the URL to `http://127.0.0.1:5000/fr/home`, and the
    home page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Home page in French](img/B19111_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Home page in French
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more to l10n than just translating alphabetical languages. Different
    geographies follow different formats for numbers, decimals, currencies, and so
    on. For example, 1.5 million USD would be written as 1,5 Mio USD in Dutch, and
    123.56 in English would be written as 123,56 in French.
  prefs: []
  type: TYPE_NORMAL
- en: 'Babel makes it very easy to implement this kind of formatting. There is a whole
    suite of methods available for this purpose. Some examples follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You can read more about this at [https://babel.pocoo.org/en/latest/api/numbers.html#module-babel.numbers](https://babel.pocoo.org/en/latest/api/numbers.html#module-babel.numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Flask'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the web applications are built in Flask, the next question concerns how
    to test applications, followed by deployment, and finally, maintaining them. This
    final part of this book covers these important topics. This is where the book
    moves from being completely development-oriented to focusing on post-development
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to test an application by writing unit tests, which allow
    for the introspection of code that has been written and also preemptively identifies
    any issues that might creep into further development of features. Once the application
    is built, you will want to measure the performance of the application in terms
    of clear metrics. [*Chapter 10*](B19111_10.xhtml#_idTextAnchor502) deals with
    these topics, among others.
  prefs: []
  type: TYPE_NORMAL
- en: The next couple of chapters focus on various tools and techniques that can be
    leveraged to deploy a Flask web application on different platforms, ranging from
    cloud-native services to bare shell servers. You will read about how to use state-of-the-art
    technologies such as Docker and Kubernetes to effectively deploy your web applications.
  prefs: []
  type: TYPE_NORMAL
- en: A new chapter on GPT has been added, which talks about how to integrate this
    cutting-edge technology with Flask for some popular use cases, and how to make
    your applications future-ready with AI.
  prefs: []
  type: TYPE_NORMAL
- en: The final chapter is a collection of additional tips and tricks that can be
    used anywhere, based on specific use cases. There are many more such topics, but
    I have covered the ones that I have dealt with most frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19111_10.xhtml#_idTextAnchor502)*, Debugging, Error Handling,
    and Testing*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 11, Deployment and Post-Deployment*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19111_12.xhtml#_idTextAnchor675)*, Microservices and Containers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19111_13.xhtml#_idTextAnchor721)*, GPT with Flask*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19111_14.xhtml#_idTextAnchor758)*, Additional Tips and Tricks*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
