<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3.  Improving and Adding Authentication to an API With Django </h1></div></div></div><p>In this chapter, we will improve the RESTful API that we started in the previous chapter and also add authentication related security to it. We will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add unique constraints to the models</li><li class="listitem" style="list-style-type: disc">Update a single field for a resource with the <code class="literal">PATCH</code> method</li><li class="listitem" style="list-style-type: disc">Take advantage of pagination</li><li class="listitem" style="list-style-type: disc">Customize pagination classes</li><li class="listitem" style="list-style-type: disc">Understand authentication, permissions and throttling</li><li class="listitem" style="list-style-type: disc">Add security-related data to the models</li><li class="listitem" style="list-style-type: disc">Create a customized permission class for object-level permissions</li><li class="listitem" style="list-style-type: disc">Persist the user that makes a request</li><li class="listitem" style="list-style-type: disc">Configure permission policies</li><li class="listitem" style="list-style-type: disc">Set a default value for a new required field in migrations</li><li class="listitem" style="list-style-type: disc">Compose requests with the necessary authentication</li><li class="listitem" style="list-style-type: disc">Browse the API with authentication credentials</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Adding unique constraints to the models</h1></div></div></div><p>Our API has a few issues that we need to solve. Right now, it is possible to create many game categories with the same name. We shouldn't be able to do so, and therefore, we will make the necessary changes to the <code class="literal">GameCategory</code> model to add a unique constraint on the <code class="literal">name</code> field. We will also add a unique constraint on the <code class="literal">name</code> field for the <code class="literal">Game</code> and <code class="literal">Player</code> models. This way, we will learn the necessary steps to make changes to the constraints for many models and reflect the changes in the underlying database through migrations.</p><p>Make sure that you quit Django's development server. Remember that you just need to press <strong>
<em>Ctrl</em> + <em>C</em>
</strong> in the terminal or Command Prompt window in which it is running. Now, we will make changes to introduce unique constraints to the name field for the models that we use to represent and persist the game categories, games, and players. Open the <code class="literal">games/models.py</code>, file and replace the code that declares the <code class="literal">GameCategory</code>, <code class="literal">Game</code> and <code class="literal">Player</code> classes with the following code. The three lines that change are highlighted in the code listing. The code for the <code class="literal">PlayerScore</code> class remains the same. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_01</code> folder, as shown:</p><pre class="programlisting">class GameCategory(models.Model): 
 <strong>   name = models.CharField(max_length=200, unique=True)</strong> 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
 
 
class Game(models.Model): 
    created = models.DateTimeField(auto_now_add=True) 
  <strong>  name = models.CharField(max_length=200, unique=True)</strong> 
    game_category = models.ForeignKey( 
        GameCategory,  
        related_name='games',  
        on_delete=models.CASCADE) 
    release_date = models.DateTimeField() 
    played = models.BooleanField(default=False) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
 
 
class Player(models.Model): 
    MALE = 'M' 
    FEMALE = 'F' 
    GENDER_CHOICES = ( 
        (MALE, 'Male'), 
        (FEMALE, 'Female'), 
    ) 
    created = models.DateTimeField(auto_now_add=True) 
    <strong>name = models.CharField(max_length=50, blank=False, default='', unique=True)</strong> 
    gender = models.CharField( 
        max_length=2, 
        choices=GENDER_CHOICES, 
        default=MALE, 
    ) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
</pre><p>We just needed to add <code class="literal">unique=True</code> as one of the named arguments for <code class="literal">models.CharField</code>. This way, we indicate that the field must be unique and Django will create the necessary unique constraints for the fields in the underlying database tables.</p><p>Now, run the following Python script to generate the migrations that will allow us to synchronize the database with the unique constraints we added for the fields in the models:</p><pre class="programlisting">
<strong>python manage.py makemigrations games</strong>
</pre><p>The following lines show the output generated after running the previous command:</p><pre class="programlisting">
<strong>Migrations for 'games':</strong>
<strong>  0002_auto_20160623_2131.py:</strong>
<strong>    - Alter field name on game</strong>
<strong>    - Alter field name on gamecategory</strong>
<strong>    - Alter field name on player</strong>
</pre><p>The output indicates that the <code class="literal">gamesapi/games/migrations/0002_auto_20160623_2131.py</code> file includes the code to alter the field named <code class="literal">name</code> on <code class="literal">game</code>, <code class="literal">gamecategory</code>, and <code class="literal">player</code>. Note that the generated file name will be different in your configuration because it includes an encoded date and time. The following lines show the code for this file, which was automatically generated by Django. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_01</code> folder:</p><pre class="programlisting"># -*- coding: utf-8 -*- 
# Generated by Django 1.9.7 on 2016-06-23 21:31 
from __future__ import unicode_literals 
 
from django.db import migrations, models 
 
 
class Migration(migrations.Migration): 
 
    dependencies = [ 
        ('games', '0001_initial'), 
    ] 
 
    operations = [ 
        migrations.AlterField( 
            model_name='game', 
            name='name', 
            field=models.CharField(max_length=200, unique=True), 
        ), 
        migrations.AlterField( 
            model_name='gamecategory', 
            name='name', 
            field=models.CharField(max_length=200, unique=True), 
        ), 
        migrations.AlterField( 
            model_name='player', 
            name='name', 
            field=models.CharField(default='', max_length=50, unique=True), 
        ), 
    ] 
</pre><p>The code defines a subclass of the <code class="literal">django.db.migrations.Migration</code> class named <code class="literal">Migration</code> that defines an <code class="literal">operations</code> list with many <code class="literal">migrations.AlterField</code>. Each <code class="literal">migrations.AlterField</code> will alter the field in the the table for each of the related models.</p><p>Now, run the following Python script to apply all the generated migrations and execute the changes in the database tables:</p><pre class="programlisting">
<strong>python manage.py migrate</strong>
</pre><p>The following lines show the output generated after running the previous command. Note that the ordering for the migrations might be different in your configuration.</p><pre class="programlisting">
<strong>Operations to perform:</strong>
<strong>Operations to perform:</strong>
<strong>  Apply all migrations: admin, auth, contenttypes, games, sessions</strong>
<strong>Running migrations:</strong>
<strong>  Rendering model states... DONE</strong>
<strong>  Applying games.0002_auto_20160623_2131... OK</strong>
</pre><p>After we run the preceding command, we will have unique indexes on the name field for the <code class="literal">games_game</code>, <code class="literal">games_gamecategory</code>, and <code class="literal">games_player</code> tables in the PostgreSQL database. We can use the PostgreSQL command line or any other application that allows us to easily check the contents of the PostreSQL database to check the tables that Django updated. In case you decide to continue working with SQLite, use the commands or tools related to this database.</p><p>Now, we can launch Django's development server to compose and send HTTP requests. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <em>Developing RESTful APIs with Django:</em>
</p><pre class="programlisting">
<strong>python manage.py runserver</strong>
<strong>python manage.py runserver 0.0.0.0:8000</strong>
</pre><p>After we run any of the previous commands, the development server will start listening at port <code class="literal">8000</code>.</p><p>Now, we will compose and send an HTTP request to create a game category with a name that already exists: <code class="literal">'3D RPG'</code>:</p><pre class="programlisting">
<strong>http POST :8000/game-categories/ name='3D RPG'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"3D RPG"}'
    :8000/game-categories/</strong>
</pre><p>Django won't be able to persist a <code class="literal">GameCategory</code> instance whose <code class="literal">name</code> is equal to the specified value because it would violate the unique constraint added to the <code class="literal">name</code> field. Thus, we will receive a <code class="literal">400 Bad Request</code> status code in the response header and a message related to the value specified for <code class="literal">name</code> in the JSON body. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 400 Bad Request</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Sun, 26 Jun 2016 03:37:05 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "name": [</strong>
<strong>        "GameCategory with this name already exists."</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>After we have made the changes, we won't be able to add duplicate values for the <code class="literal">name</code> field in game categories, games, or players. This way, we can be sure that whenever we specify the name of any of these resources, we are going to reference the same unique resource.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Updating a single field for a resource with the PATCH method</h1></div></div></div><p>As we explained in <a class="link" href="ch02.html" title="Chapter 2.  Working with Class-Based Views and Hyperlinked APIs in Django">Chapter 2</a>, <em>Working with Class-Based Views and Hyperlinked </em>
<em>APIs in Django</em>, our API can update a single field for an existing resource, and therefore, we provide an implementation for the <code class="literal">PATCH</code> method. For example, we can use the <code class="literal">PATCH</code> method to update an existing game and set the value for its <code class="literal">played</code> field to <code class="literal">true</code>. We don't want to use the <code class="literal">PUT</code> method because this method is meant to replace an entire game. The <code class="literal">PATCH</code> method is meant to apply a delta to an existing game, and therefore, it is the appropriate method to just change the value of the <code class="literal">played</code> field.</p><p>Now, we will compose and send an HTTP request to update an existing game, specifically, to update the value of the <code class="literal">played</code> field and set it to <code class="literal">true</code> because we just want to update a single field, we will use the <code class="literal">PATCH</code> method instead of <code class="literal">PUT</code>. Make sure you replace <code class="literal">2</code> with the id or primary key of an existing game in your configuration:</p><pre class="programlisting">
<strong>http PATCH :8000/games/2/ played=true</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"played":"true"}'
    :8000/games/2/</strong>
</pre><p>The preceding command will compose and send a <code class="literal">PATCH</code> HTTP request with the specified JSON key-value pair. The request has a number after <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/(?P&lt;pk&gt;[0-9]+)/$'</code> and run the <code class="literal">patch</code> method for the <code class="literal">views.GameDetail</code> class-based view. Remember that the method is defined in the <code class="literal">RetrieveUpdateDestroyAPIView</code> superclass and it ends up calling the <code class="literal">update</code> method defined in <code class="literal">mixins.UpdateModelMixin</code>. If the <code class="literal">Game</code> instances with the updated value for the <code class="literal">played</code> field are valid and were successfully persisted in the database, the call to the method will return a <code class="literal">200 OK</code> status code and the recently updated <code class="literal">Game</code> serialized to JSON in the response body. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Sun, 26 Jun 2016 04:09:22 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": "3D RPG", </strong>
<strong>    "name": "PvZ Garden Warfare 4", </strong>
<strong>    "played": true, </strong>
<strong>    "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>    "url": "http://localhost:8000/games/2/"</strong>
<strong>}</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Taking advantage of pagination</h1></div></div></div><p>Our database has a few rows in each of the tables that persist the models we have defined. However, after we start working with our API in a real-life production environment, we will have thousands of player scores, players, games, and game categories, and therefore, we will have to deal with large result sets. We can take advantage of the pagination features available in Django REST Framework to make it easy to specify how we want large results sets to be split into individual pages of data.</p><p>First, we will compose and send HTTP requests to create 10 games that belong to one of the categories we have created: <code class="literal">2D mobile arcade</code>. This way, we will have a total of 12 games that persist in the database. We had 2 games and we will add 10 more:</p><pre class="programlisting">
<strong>http POST :8000/games/ name='Tetris Reloaded' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Puzzle Craft' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Blek' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Scribblenauts Unlimited' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Cut the Rope: Magic' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Tiny Dice Dungeon' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='A Dark Room' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Bastion' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Welcome to the Dungeon' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
<strong>http POST :8000/games/ name='Dust: An Elysian Tail' game_category='2D mobile arcade' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
</pre><p>The following are the equivalent <code class="literal">curl</code> commands:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Tetris Reloaded", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Puzzle Craft", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Blek", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Scribblenauts Unlimited", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Cut the Rope: Magic", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Tiny Dice Dungeon", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"A Dark Room", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Bastion", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Welcome to the Dungeon", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"Dust: An Elysian Tail", "game_category":"2D mobile arcade", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
</pre><p>The preceding commands will compose and send ten <code class="literal">POST</code> HTTP requests with the specified JSON key-value pairs. The request specifies <code class="literal">/games/</code>, and therefore, it will match <code class="literal">'^games/$'</code> and run the <code class="literal">post</code> method for the <code class="literal">views.GameList</code> class-based view.</p><p>Now, we have 12 games in our database. However, we don't want to retrieve the 12 games when we compose and send a <code class="literal">GET</code> HTTP request to <code class="literal">/games/</code>. We will configure one of the customizable pagination styles included in Django REST Framework to include a maximum of five resources in each individual page of data.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>Our API uses the generic views that work with the mixin classes that can handle paginated responses, and therefore, they will automatically take into account the pagination settings we configure in Django REST Framework.</p></div></div><p>Open the <code class="literal">gamesapi/settings.py</code> file and add the following lines that declare a dictionary named <code class="literal">REST_FRAMEWORK</code> with key-value pairs that configure the global pagination settings. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_02</code> folder:</p><pre class="programlisting">REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'rest_framework.pagination.LimitOffsetPagination', 
    'PAGE_SIZE': 5 
} 
</pre><p>The value for the <code class="literal">DEFAULT_PAGINATION_CLASS</code> settings key specifies a global setting with the default pagination class that the generic views will use to provide paginated responses. In this case, we will use the <code class="literal">rest_framework.pagination.LimitOffsetPagination</code> class, that provides a limit/offset-based style. This pagination style works with <code class="literal">limit</code> that indicates the maximum number of items to return and an <code class="literal">offset</code> that specifies the starting position of the query. The value for the <code class="literal">PAGE_SIZE</code> settings key specifies a global setting with the default value for the <code class="literal">limit</code>, also known as page size. We can specify a different limit when we perform the HTTP request by specifying the desired value in the <code class="literal">limit</code> query parameter. We can configure the class to have the maximum <code class="literal">limit</code> value in order to avoid the undesired huge result sets.</p><p>Now, we will compose and send an HTTP request to retrieve all the games, specifically the following HTTP <code class="literal">GET</code> method to <code class="literal">/games/</code>:</p><pre class="programlisting">
<strong>http GET :8000/games/</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET :8000/games/</strong>
</pre><p>The generic views will use the new settings that we added to enable the offset/limit pagination and the result will provide us the first 5 game resources (<code class="literal">results</code> key), the total number of games for the query (<code class="literal">count</code> key), and a link to the next (<code class="literal">next</code> key) and previous (<code class="literal">previous</code> key) pages. In this case, the resultset is the first page, and therefore, the link to the previous page (previous <code class="literal">key</code>) is <code class="literal">null</code>. We will receive a <code class="literal">200 OK</code> status code in the response header and the 5 games in the <code class="literal">results</code> array:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Fri, 01 Jul 2016 00:57:55 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "count": 12, </strong>
<strong>    "next": "http://localhost:8000/games/?limit=5&amp;offset=5", </strong>
<strong>    "previous": null, </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "A Dark Room", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/10/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Bastion", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/11/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Blek", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/6/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Cut the Rope: Magic", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/8/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Dust: An Elysian Tail", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/13/"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>In the preceding HTTP request, we didn't specify any value for either the limit or offset parameters. However, as we specified the default value of limit as 5 items in the global settings, the generic views use this configuration value and provide us with the first page. If we compose and send the following HTTP request to retrieve the first page of all the games by specifying <code class="literal">1</code> for the offset value, the API will provide the same results shown before:</p><pre class="programlisting">
<strong>http GET ':8000/games/?offset=0'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?offset=0'</strong>
</pre><p>If we compose and send the following HTTP request to retrieve the first page of all the games by specifying 0 for the offset value and 5 for the limit, the API will also provide the same results as shown earlier:</p><pre class="programlisting">
<strong>http GET ':8000/games/?limit=5&amp;offset=0'</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?limit=5&amp;offset=0'</strong>
</pre><p>Now, we will compose and send an HTTP request to retrieve the next page, that is, the second page for the games, specifically an HTTP <code class="literal">GET</code> method to <code class="literal">/games/</code> with the <code class="literal">offset</code> value set to <code class="literal">5</code>. Remember that the value for the next key returned in the JSON body of the previous result provides us with the URL to the next page:</p><pre class="programlisting">
<strong>http GET ':8000/games/?limit=5&amp;offset=5'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?limit=5&amp;offset=5'</strong>
</pre><p>The result will provide us the second set of the 5 game resource (<code class="literal">results</code> key), the total number of games for the query (<code class="literal">count</code> key), and a link to the next (<code class="literal">next</code> key) and previous (<code class="literal">previous</code> key) pages. In this case, the resultset is the second page, and therefore, the link to the previous page (previous <code class="literal">key</code>) is <code class="literal">http://localhost:8000/games/?limit=5</code>. We will receive a <code class="literal">200 OK</code> status code in the response header and the 5 games in the <code class="literal">results</code> array:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Fri, 01 Jul 2016 01:25:10 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "count": 12, </strong>
<strong>    "next": "http://localhost:8000/games/?limit=5&amp;offset=10", </strong>
<strong>    "previous": "http://localhost:8000/games/?limit=5", </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Puzzle Craft", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/5/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "3D RPG", </strong>
<strong>            "name": "PvZ Garden Warfare 4", </strong>
<strong>            "played": true, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/2/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Scribblenauts Unlimited", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/7/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "3D RPG", </strong>
<strong>            "name": "Superman vs Aquaman", </strong>
<strong>            "played": true, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/3/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Tetris Reloaded", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/4/"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>In the preceding HTTP request, we specified values for both the <code class="literal">limit</code> and <code class="literal">offset</code> parameters. However, as we specified the default value of <code class="literal">limit</code> in <code class="literal">5</code> items in the global settings, the following request will produce the same results than the previous request:</p><pre class="programlisting">
<strong>http GET ':8000/games/?offset=5'</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?offset=5'</strong>
</pre><p>Finally, we will compose and send an HTTP request to retrieve the last page, that is, the third page for the games, specifically an HTTP <code class="literal">GET</code> method to <code class="literal">/games/</code> with the <code class="literal">offset</code> value set to <code class="literal">10</code>. Remember that the value for the next key returned in the JSON body of the previous result provides us with the URL to the next page:</p><pre class="programlisting">
<strong>http GET ':8000/games/?limit=5&amp;offset=10'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?limit=5&amp;offset=10'</strong>
</pre><p>The result will provide us the last set with 2 game resources (<code class="literal">results</code> key), the total number of games for the query (<code class="literal">count</code> key), and a link to the next (<code class="literal">next</code> key) and previous (<code class="literal">previous</code> key) pages. In this case, the resultset is the last page, and therefore, the link to the next page (<code class="literal">next</code> key) is <code class="literal">null</code>. We will receive a <code class="literal">200 OK</code> status code in the response header and the 2 games in the <code class="literal">results</code> array:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Fri, 01 Jul 2016 01:28:13 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "count": 12, </strong>
<strong>    "next": null, </strong>
<strong>    "previous": "http://localhost:8000/games/?limit=5&amp;offset=5", </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Tiny Dice Dungeon", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/9/"</strong>
<strong>        }, </strong>
<strong>        {</strong>
<strong>            "game_category": "2D mobile arcade", </strong>
<strong>            "name": "Welcome to the Dungeon", </strong>
<strong>            "played": false, </strong>
<strong>            "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>            "url": "http://localhost:8000/games/12/"</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Customizing pagination classes</h1></div></div></div><p>The <code class="literal">rest_framework.pagination.LimitOffsetPagination</code> class that we are using to provide paginated responses declares a <code class="literal">max_limit</code> class attribute that defaults to <code class="literal">None</code>. This attribute allows us to indicate the maximum allowable limit that can be specified using the <code class="literal">limit</code> query parameter. With the default setting, there is no limit and we will be able to process requests that specify a value for <code class="literal">1000000</code> for the limit query parameter. We definitely don't want our API to be able to generate a response with a million player scores or players with a single request. Unluckily, there is no setting that allows us to change the value that the class assigns to the <code class="literal">max_limit</code> class attribute. Thus, we will create our customized version of the limit/offset pagination style provided by Django REST Framework.</p><p>Create a new Python file named <code class="literal">pagination.py</code> within the <code class="literal">games</code> folder and enter the following code which declares the new <code class="literal">LimitOffsetPaginationWithMaxLimit</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_03</code> folder:</p><pre class="programlisting">from rest_framework.pagination import LimitOffsetPagination 
 
 
class LimitOffsetPaginationWithMaxLimit(LimitOffsetPagination): 
    max_limit = 10 
</pre><p>The preceding lines declare the <code class="literal">LimitOffsetPaginationWithMaxLimit</code> class as a subclass of the <code class="literal">rest_framework.pagination.LimitOffsetPagination</code> class and overrides the value specified for the <code class="literal">max_limit</code> class attribute with <code class="literal">10</code>.</p><p>Open the <code class="literal">gamesapi/settings.py</code> file and replace the line that specified the value for the <code class="literal">DEFAULT_PAGINATION_CLASS</code> key in the dictionary named <code class="literal">REST_FRAMEWORK</code> with the highlighted line. The following lines show the new declaration of the dictionary named <code class="literal">REST_FRAMEWORK</code>. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_03</code> folder:</p><pre class="programlisting">REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'games.pagination.LimitOffsetPaginationWithMaxLimit', 
    'PAGE_SIZE': 5 
} 
</pre><p>Now, the generic views will use the recently declared <code class="literal">games.pagination.LimitOffsetPaginationWithMaxLimit</code> class, that provides a limit/offset based style with a maximum <code class="literal">limit</code> value equal to <code class="literal">10</code>. If a request specifies a value for limit higher than <code class="literal">10</code>, the class will use the maximum limit value, that is, 10, and we will never return more than <code class="literal">10</code> items in a paginated response.</p><p>Now, we will compose and send an HTTP request to retrieve the first page for the games, specifically an HTTP <code class="literal">GET</code> method to <code class="literal">/games/</code> with the <code class="literal">limit</code> value set to <code class="literal">10000</code>:</p><pre class="programlisting">
<strong>http GET ':8000/games/?limit=10000'</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX GET ':8000/games/?limit=10000'</strong>
</pre><p>The result will use a limit value equal to <code class="literal">10</code> instead of the indicated <code class="literal">10000</code> because we are using our customized pagination class. The result will provide us the first set with 10 game resources (<code class="literal">results</code> key), the total number of games for the query (<code class="literal">count</code> key), and a link to the next (<code class="literal">next</code> key) and previous (<code class="literal">previous</code> key) pages. In this case, the resultset is the first page, and therefore, the link to the next page (<code class="literal">next</code> key) is <code class="literal">http://localhost:8000/games/?limit=10&amp;offset=10</code>. We will receive a <code class="literal">200 OK</code> status code in the response header and the first <code class="literal">10</code> games in the <code class="literal">results</code> array. The following lines show the header and the first lines of the output:</p><pre class="programlisting">
<strong>HTTP/1.0 200 OK</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Fri, 01 Jul 2016 16:34:01 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "count": 12, </strong>
<strong>    "next": "http://localhost:8000/games/?limit=10&amp;offset=10", </strong>
<strong>    "previous": null, </strong>
<strong>    "results": [</strong>
<strong>        {</strong>
</pre><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>It is a good practice to configure a maximum limit to avoid generating huge responses.</p></div></div><p>Open a web browser and enter <code class="literal">http://localhost:8000/games/</code>. Replace localhost with the IP of the computer that is running the Django development server in case you use another computer or device to run the browser. The browsable API will compose and send a <code class="literal">GET</code> request to <code class="literal">/games/</code> and will display the results of its execution, that is, the headers and the JSON games list; since we have configured pagination, the rendered web page will include the default pagination template associated with the base pagination class we are using and will display the available page numbers at the upper-right corner of the web page. The following screenshot shows the rendered web page after entering the URL in a web browser with the resource description, <strong>Game List</strong>, and the three pages.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Understanding authentication, permissions and throttling</h1></div></div></div><p>Our current version of the API processes all the incoming requests without requiring any kind of authentication. Django REST Framework allows us to easily use different authentication schemes to identify the user that originated the request or the token that signed the request. Then, we can use these credentials to apply the permission and throttling policies that will determine whether the request must be permitted or not.</p><p>Similar to other configurations, we can set the authentication schemes globally and then override them if necessary in a class-based view or a function view. A list of classes specifies the authentication schemes. Django REST framework will use all the specified classes in the list to authenticate a request before running the code for the view. The first class in the list that generates a successful authentication, in case we specify more than one class, will be responsible for setting the values for the following two properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">request.user</code>: The user model instance. We will use an instance of the <code class="literal">django.contrib.auth.User</code> class, that is, a Django <code class="literal">User</code> instance, in our examples.</li><li class="listitem" style="list-style-type: disc"><code class="literal">request.auth</code>: Additional authentication information, such as an authentication token.</li></ul></div><p>After a successful authentication, we can use the <code class="literal">request.user</code> property in our class-based view methods that receive the <code class="literal">request</code> parameter to retrieve additional information about the user that generated the request.</p><p>Django REST Framework provides the following three authentication classes in the <code class="literal">rest_framework.authentication</code> module. All of them are subclasses of the <code class="literal">BaseAuthentication</code> class:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BasicAuthentication</code>: Provides an HTTP Basic authentication against username and password. If we use in production, we must make sure that the API is only available over HTTPS.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SessionAuthentication</code>: Works with Django's session framework for authentication.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TokenAuthentication</code>: Provides a simple token based authentication. The request must include the token generated for a user in the <code class="literal">Authorization</code> HTTP header with <code class="literal">"Token "</code> as a prefix for the token.</li></ul></div><p>First, we will use a combination of <code class="literal">BasicAuthentication</code> and <code class="literal">SessionAuthentication</code>. We could also take advantage of the <code class="literal">TokenAuthentication</code> class later. Make sure you quit the Django's development server. Remember that you just need to press <em>
<strong>Ctrl</strong>
</em> + <em>
<strong>C</strong>
</em> in the terminal or command-prompt window in which it is running.</p><p>Open the <code class="literal">gamesapi/settings.py</code> file and add the highlighted lines to the dictionary named <code class="literal">REST_FRAMEWORK</code> with a key-value pair that configures the global default authentication classes. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder, as shown:</p><pre class="programlisting">REST_FRAMEWORK = { 
    'DEFAULT_PAGINATION_CLASS': 
    'games.pagination.LimitOffsetPaginationWithMaxLimit', 
    'PAGE_SIZE': 5, 
   <strong> 'DEFAULT_AUTHENTICATION_CLASSES': ( 
        'rest_framework.authentication.BasicAuthentication', 
        'rest_framework.authentication.SessionAuthentication', 
        )</strong> 
} 
</pre><p>The value for the <code class="literal">DEFAULT_AUTHENTICATION_CLASSES</code> settings key specifies a global setting with a tuple of string whose values indicate the classes that we want to use for authentication.</p><p>Permissions use the authentication information included in the <code class="literal">request.user</code> and <code class="literal">request.auth</code> properties to determine whether the request should be granted or denied access. Permissions allow us to control which classes of users will be granted or denied access to the different features or parts of our API.</p><p>For example, we will use the permissions features in Django REST framework to allow the authenticated users to create games. Unauthenticated users will only be allowed read-only access to games. Only the user that created the game will be able to make changes to this game, and therefore, we will make the necessary changes in our API to make a game have an owner user. We will use predefined permission classes and a customized permission class to define the explained permission policies.</p><p>Throttling also determines whether the request must be authorized. Throttles control the rate of requests that users can make to our API. For example, we want to limit unauthenticated users to a maximum of 5 requests per hour. We want to restrict authenticated users to a maximum of 20 requests to the games related views per day.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Adding security-related data to the models</h1></div></div></div><p>We will associate a game with a creator or owner. Only the authenticated users will be able to create new games. Only the creator of a game will be able to update it or delete it. All the requests that aren't authenticated will only have read-only access to games.</p><p>Open the <code class="literal">games/models.py</code> file and replace the code that declares the <code class="literal">Game</code> class with the following code. The line that changes is highlighted in the code listing. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder.</p><pre class="programlisting">class Game(models.Model): 
   <strong> owner = models.ForeignKey( 
        'auth.User',  
        related_name='games', 
        on_delete=models.CASCADE)</strong> 
    created = models.DateTimeField(auto_now_add=True) 
    name = models.CharField(max_length=200, unique=True) 
    game_category = models.ForeignKey( 
        GameCategory,  
        related_name='games',  
        on_delete=models.CASCADE) 
    release_date = models.DateTimeField() 
    played = models.BooleanField(default=False) 
 
    class Meta: 
        ordering = ('name',) 
 
    def __str__(self): 
        return self.name 
</pre><p>The <code class="literal">Game</code> model declares a new <code class="literal">owner</code> field that uses the <code class="literal">django.db.models.ForeignKey</code> class to provide a many-to-one relationship to the <code class="literal">auth.User</code> model, specifically, to the <code class="literal">django.contrib.auth.User</code> model. This <code class="literal">User</code> model represents the users within the Django authentication system. The <code class="literal">'games'</code> value specified for the <code class="literal">related_name</code> argument creates a backwards relation from the <code class="literal">User</code> model to the <code class="literal">Game</code> model. This value indicates the name to be used for the relation from the related <code class="literal">User</code> object back to a <code class="literal">Game</code> object. This way, we will be able to access all the games owned by a specific user. Whenever we delete a user, we want all the games owned by this user to be deleted too, and therefore, we specified the <code class="literal">models.CASCADE</code> value for the <code class="literal">on_delete</code> argument.</p><p>Now, we will run the <code class="literal">createsuperuser</code> subcommand for <code class="literal">manage.py</code> to create the <code class="literal">superuser</code> for Django that we will use to easily authenticate our requests. We will create more users later:</p><pre class="programlisting">
<strong>python manage.py createsuperuser</strong>
</pre><p>The command will ask you for the <code class="literal">username</code> you want to use for the <code class="literal">superuser</code>. Enter the desired user name and press <strong>Enter</strong>. We will use <code class="literal">superuser</code> as the user name for this example. You will see a line similar to the following one:</p><pre class="programlisting">
<strong>Username (leave blank to use 'gaston'):</strong>
</pre><p>Then, the command will ask you for the e-mail address. Enter an e-mail address and press <em>Enter</em>:</p><pre class="programlisting">
<strong>Email address:</strong>
</pre><p>Finally, the command will ask you for the password for the new superuser. Enter your desired password and press <em>Enter</em>.</p><pre class="programlisting">
<strong>Password:</strong>
</pre><p>The command will ask you to enter the password again. Enter it and press <em>Enter</em>. If both entered passwords match, the superuser will be created:</p><pre class="programlisting">
<strong>Password (again): </strong>
<strong>Superuser created successfully.</strong>
</pre><p>Now, go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">serializers.py</code> file. Add the following code after the last line that declares the imports, before the declaration of the <code class="literal">GameCategorySerializer</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">from django.contrib.auth.models import User 
 
 
class UserGameSerializer(serializers.HyperlinkedModelSerializer): 
    class Meta: 
        model = Game 
        fields = ( 
            'url', 
            'name') 
 
 
class UserSerializer(serializers.HyperlinkedModelSerializer): 
    games = UserGameSerializer(many=True, read_only=True) 
 
    class Meta: 
        model = User 
        fields = ( 
            'url',  
            'pk', 
            'username', 
            'games') 
</pre><p>The <code class="literal">UserGameSerializer</code> class is a subclass of the <code class="literal">HyperlinkedModelSerializer</code> class. We use this new serializer class to serialize the games related to a user. This class declares a <code class="literal">Meta</code> inner class that declares two attributes: <code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the serializer, that is, the <code class="literal">Game</code> class. The <code class="literal">fields</code> attribute specifies a tuple of string whose values indicate the field names that we want to include in the serialization from the related model. We just want to include the URL and the game's name, and therefore, the code specified <code class="literal">'url'</code> and <code class="literal">'name'</code> as members of the tuple. We don't want to use the <code class="literal">GameSerializer</code> serializer class for the games related to a user because we want to serialize fewer fields, and therefore, we created the <code class="literal">UserGameSerializer</code> class.</p><p>The <code class="literal">UserSerializer</code> class is a subclass of the <code class="literal">HyperlinkedModelSerializer</code> class. This class declares a <code class="literal">Meta</code> inner class that declares two attributes-<code class="literal">model</code> and <code class="literal">fields</code>. The <code class="literal">model</code> attribute specifies the model related to the serializer, that is, the <code class="literal">django.contrib.auth.models.User</code> class.</p><p>The <code class="literal">UserSerializer</code> class declares a <code class="literal">games</code> attribute as an instance of the previously explained <code class="literal">UserGameSerializer</code> with <code class="literal">many</code> and <code class="literal">read_only</code> equal to <code class="literal">True</code> because it is a one-to-many relationship and it is read-only. We use the <code class="literal">games</code> name that we specified as the <code class="literal">related_name</code> string value when we added the <code class="literal">owner</code> field as a <code class="literal">models.ForeignKey</code> instance in the <code class="literal">Game</code> model. This way, the <code class="literal">games</code> field will provide us with an array of URLs and names for each game that belongs to the user.</p><p>We will make more changes to the <code class="literal">serializers.py</code> file in the <code class="literal">gamesapi/games</code> folder. We will add an <code class="literal">owner</code> field to the existing <code class="literal">GameSerializer</code> class. The following lines show the new code for the <code class="literal">GameSerializer</code> class. The new lines are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">class GameSerializer(serializers.HyperlinkedModelSerializer): 
    # We just want to display the owner username (read-only) 
    <strong>owner = serializers.ReadOnlyField(source='owner.username')</strong> 
    # We want to display the game cagory's name instead of the id 
    game_category = serializers.SlugRelatedField(queryset=GameCategory.objects.all(), slug_field='name') 
 
    class Meta: 
        model = Game 
        depth = 4 
        fields = ( 
                'url', 
                'owner', 
                'game_category', 
                'name', 
                'release_date', 
                'played') 
</pre><p>Now, the <code class="literal">GameSerializer</code> class declares an <code class="literal">owner</code> attribute as an instance of <code class="literal">serializers.ReadOnlyField</code> with <code class="literal">source</code> equal to <code class="literal">'owner.username'</code>. This way, we will serialize the value for the <code class="literal">username</code> field of the related <code class="literal">django.contrib.auth.User</code> hold in the <code class="literal">owner</code> field. We use the <code class="literal">ReadOnlyField</code> because the owner is automatically populated when an authenticated user creates a game, and therefore, it won't be possible to change the owner after a game has been created. This way, the <code class="literal">owner</code> field will provide us with the user name that created the game. In addition, we added <code class="literal">'owner'</code> to the field's string tuple.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Creating a customized permission class for object-level permissions</h1></div></div></div><p>Create a new Python file named <code class="literal">permissions.py</code> within the <code class="literal">games</code> folder and enter the following code that, declares the new <code class="literal">IsOwnerOrReadOnly</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">from rest_framework import permissions 
 
 
class IsOwnerOrReadOnly(permissions.BasePermission): 
    def has_object_permission(self, request, view, obj): 
        if request.method in permissions.SAFE_METHODS: 
            return True 
        else: 
            return obj.owner == request.user 
</pre><p>The <code class="literal">rest_framework.permissions.BasePermission</code> class is the base class from which all permission classes should inherit. The previous lines declare the <code class="literal">IsOwnerOrReadOnly</code> class as a subclass of the <code class="literal">BasePermission</code> class and overrides the <code class="literal">has_object_permission</code> method defined in the superclass that returns a <code class="literal">bool</code> value indicating whether the permission should be granted or not. If the HTTP verb specified in the request (<code class="literal">request.method</code>) is any of the three safe methods specified in <code class="literal">permission.SAFE_METHODS</code> (<code class="literal">GET</code>, <code class="literal">HEAD</code> , or <code class="literal">OPTIONS</code>), the <code class="literal">has_object_permission</code> method returns <code class="literal">True</code> and grants permission to the request. These HTTP verbs do not make changes to the related resources, and therefore, they are included in the <code class="literal">permissions.SAFE_METHODS</code> tuple of string.</p><p>If the HTTP verb specified in the request (<code class="literal">request.method</code>) is not any of the three safe methods, the code returns <code class="literal">True</code> and grants permission only when the <code class="literal">owner</code> attribute of the received <code class="literal">obj</code> (<code class="literal">obj.owner</code>) matches the user that created the request (<code class="literal">request.user</code>). This way, only the owner of the related resource will be granted permission to requests that include HTTP verbs that aren't safe.</p><p>We will use the new <code class="literal">IsOwnerOrReadOnly</code> permission class to make sure that only the game owners can make changes to an existing game. We will combine this permission class with the <code class="literal">rest_framework.permissions.IsAuthenticatedOrReadOnly</code> permission class that only allows read-only access to resources when the request is not authenticated as a user.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Persisting the user that makes a request</h1></div></div></div><p>We want to be able to list all the users and retrieve the details for a single user. We will create subclasses of the two following generic class views declared in <code class="literal">rest_framework.generics</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ListAPIView</code>: Implements the <code class="literal">get</code> method that retrieves a listing of a queryset</li><li class="listitem" style="list-style-type: disc"><code class="literal">RetrieveAPIView</code>: Implements the <code class="literal">get</code> method to retrieve a model instance</li></ul></div><p>Go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">views.py</code> file. Add the following code after the last line that declares the imports, before the declaration of the <code class="literal">GameCategoryList</code> class. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">from django.contrib.auth.models import User 
from games.serializers import UserSerializer 
from rest_framework import permissions 
from games.permissions import IsOwnerOrReadOnly 
 
 
class UserList(generics.ListAPIView): 
    queryset = User.objects.all() 
    serializer_class = UserSerializer 
    name = 'user-list' 
 
 
class UserDetail(generics.RetrieveAPIView): 
    queryset = User.objects.all() 
    serializer_class = UserSerializer 
    name = 'user-detail' 
</pre><p>Add the following highlighted lines to the ApiRoot class declared in the <code class="literal">views.py</code> file. Now, we will be able to navigate to the user-related views throughout the browsable API. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder.</p><pre class="programlisting">class ApiRoot(generics.GenericAPIView): 
    name = 'api-root' 
    def get(self, request, *args, **kwargs): 
        return Response({ 
            'players': reverse(PlayerList.name, request=request), 
            'game-categories': reverse(GameCategoryList.name, request=request), 
            'games': reverse(GameList.name, request=request), 
            'scores': reverse(PlayerScoreList.name, request=request), 
          <strong>  'users': reverse(UserList.name, request=request),</strong> 
            }) 
</pre><p>Go to the <code class="literal">gamesapi/games</code> folder and open the <code class="literal">urls.py</code> file. Add the following elements to the <code class="literal">urlpatterns</code> string list. The new strings define the URL patterns that specify the regular expressions that have to be matched in the request to run a specific method for the previously created class based-views in the <code class="literal">views.py</code> file: <code class="literal">UserList</code> and <code class="literal">UserDetail</code>. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">    url(r'^users/$', 
        views.UserList.as_view(), 
        name=views.UserList.name), 
    url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', 
        views.UserDetail.as_view(), 
        name=views.UserDetail.name), 
</pre><p>We have to add a line in the <code class="literal">urls.py</code> file in the <code class="literal">gamesapi</code> folder, specifically, the <code class="literal">gamesapi/urls.py</code> file. The file defines the root URL configurations and we want to include the URL patterns to allow the browsable API to display the login and logout views. The following lines show the new code for the <code class="literal">gamesapi/urls.py</code> file. The new line is highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">from django.conf.urls import url, include 
 
urlpatterns = [ 
    url(r'^', include('games.urls')), 
   <strong> url(r'^api-auth/', include('rest_fra</strong>mework.urls')) 
] 
</pre><p>We have to make changes to the <code class="literal">GameList</code> class-based view. We will override the <code class="literal">perform_create</code> method to populate the <code class="literal">owner</code> before a new <code class="literal">Game</code> instance is persisted in the database. The following lines show the new code for the <code class="literal">GameList</code> class in the <code class="literal">views.py</code> file. The new lines are highlighted. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">class GameList(generics.ListCreateAPIView): 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-list' 
    <strong>def perform_create(self, serializer): 
        # Pass an additional owner field to the create method 
        # To Set the owner to the user received in the request 
        serializer.save(owner=self.request.user)</strong>
</pre><p>The <code class="literal">GameList</code> class inherits the <code class="literal">perform_create</code> method from the <code class="literal">rest_framework.mixins.CreateModelMixin</code> class. Remember that the <code class="literal">generics.ListCreateAPIView</code> class inherits from <code class="literal">CreateModelMixin</code> class and other classes. The code for the overridden <code class="literal">perform_create</code> method passes an additional <code class="literal">owner</code> field to the create method by setting a value for the <code class="literal">owner</code> argument for the call to the <code class="literal">serializer.save</code> method. The code sets the owner attribute to the value of <code class="literal">self.request.user</code>, that is, to the user associated to the request. This way, whenever a new game is persisted, it will save the user associated to the request as its owner.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Configuring permission policies</h1></div></div></div><p>Now, we will configure permission policies for the class-based views related to games. We will override the value for the <code class="literal">permission_classes</code> class attribute for the <code class="literal">GameList</code> and <code class="literal">GameDetail</code> classes.</p><p>The following lines show the new code for the <code class="literal">GameList</code> class in the <code class="literal">views.py</code> file. The new lines are highlighted. Don't remove the code we added for the <code class="literal">perform_create</code> method for this class. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">class GameList(generics.ListCreateAPIView): 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-list' 
   <strong> permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        IsOwnerOrReadOnly, 
        )</strong>
</pre><p>The following lines show the new code for the <code class="literal">GameDetail</code> class in the <code class="literal">views.py</code> file. The new lines are highlighted. Don't remove the code we added for the <code class="literal">perform_create</code> method for this class. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">class GameDetail(generics.RetrieveUpdateDestroyAPIView): 
    queryset = Game.objects.all() 
    serializer_class = GameSerializer 
    name = 'game-detail' 
    permission_classes = ( 
        permissions.IsAuthenticatedOrReadOnly, 
        IsOwnerOrReadOnly) 
</pre><p>We added the same lines in the two classes. We have included the <code class="literal">IsAuthenticatedOrReadOnly</code> class and our previously created <code class="literal">IsOwnerOrReadOnly</code> permission class in the <code class="literal">permission_classes</code> tuple.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec40"/>Setting a default value for a new required field in migrations</h1></div></div></div><p>We have persisted many games in our database and added a new <code class="literal">owner</code> field for the games that is a required field. We don't want to delete all the existing games, and therefore, we will take advantage of some features in Django that make it easy for us to make the changes in the underlying database without losing the existing data.</p><p>Now, we need to retrieve the <code class="literal">id</code> for the <code class="literal">superuser</code> we have created to use it as the default owner for the existing games. Django will allow us to easily update the existing games to set the owner user for them.</p><p>Run the following commands to retrieve the <code class="literal">id</code> from the <code class="literal">auth_user</code> table for the row that whose username is equal to <code class="literal">'superuser'</code>. Replace <code class="literal">superuser</code> with the user name you selected for the previously created superuser. In addition, replace <code class="literal">user_name</code> in the command with the user name you used to create the PostgreSQL database and <code class="literal">password</code> with your chosen password for this database user. The command assumes that you are running PostgreSQL on the same computer in which you are running the command. In case you are working with a SQLite database, you can run the equivalent command in the PostgreSQL command line or a GUI-based tool to execute the same query.</p><pre class="programlisting">
<strong>psql --username=user_name --dbname=games --command="SELECT id FROM auth_user WHERE username = 'superuser';"</strong>
</pre><p>The following lines show the output with the value for <code class="literal">id</code>: 1</p><pre class="programlisting">
<strong>id </strong>
<strong>----</strong>
<strong>  1</strong>
<strong>(1 row)</strong>
</pre><p>Now, run the following Python script to generate the migrations that will allow us to synchronize the database with the new field we added to the Game model:</p><pre class="programlisting">
<strong>python manage.py makemigrations games</strong>
</pre><p>Django will display the following question:</p><pre class="programlisting">
<strong>You are trying to add a non-nullable field 'owner' to game without a default; we can't do that (the database needs something to populate existing rows).</strong>
<strong>Please select a fix:</strong>
<strong> 1) Provide a one-off default now (will be set on all existing rows)</strong>
<strong> 2) Quit, and let me add a default in models.py</strong>
<strong>Select an option: </strong>
</pre><p>We want to provide the one-off default that will be set on all existing rows, and therefore, enter <code class="literal">1</code> to select the first option and press <em>
<strong>Enter</strong>
</em>.</p><p>Django will display the following text asking us to enter the default value:</p><pre class="programlisting">
<strong>Please enter the default value now, as valid Python</strong>
<strong>The datetime and django.utils.timezone modules are available, so you can do e.g. timezone.now()</strong>
<strong>&gt;&gt;&gt;</strong>
</pre><p>Enter the value for the previously retrieved id, <code class="literal">1</code> in our example, and press Enter. The following lines show the output generated after running the preceding command:</p><pre class="programlisting">
<strong>Migrations for 'games':</strong>
<strong>  0003_game_owner.py:</strong>
<strong>    - Add field owner to game</strong>
</pre><p>The output indicates that the <code class="literal">gamesapi/games/migrations/0003_game_owner.py</code> file includes the code to add the field named <code class="literal">owner</code> to <code class="literal">game</code>. The following lines show the code for this file that was automatically generated by Django. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder:</p><pre class="programlisting">
<strong># -*- coding: utf-8 -*-</strong>
<strong># Generated by Django 1.9.7 on 2016-07-01 21:06</strong>
<strong>from __future__ import unicode_literals</strong>
<strong>from django.conf import settings</strong>
<strong>from django.db import migrations, models</strong>
<strong>import django.db.models.deletion</strong>
<strong>class Migration(migrations.Migration):</strong>
<strong>    dependencies = [</strong>
<strong>        migrations.swappable_dependency(settings.AUTH_USER_MODEL),</strong>
<strong>        ('games', '0002_auto_20160623_2131'),</strong>
<strong>    ]</strong>
<strong>    operations = [</strong>
<strong>        migrations.AddField(</strong>
<strong>            model_name='game',</strong>
<strong>            name='owner',</strong>
<strong>            field=models.ForeignKey(default=1, on_delete=django.db.models.deletion.CASCADE, related_name='games', to=settings.AUTH_USER_MODEL),</strong>
<strong>            preserve_default=False,</strong>
<strong>        ),</strong>
<strong>    ]</strong>
</pre><p>The code declares a subclass of the <code class="literal">django.db.migrations.Migration</code> class named <code class="literal">Migration</code> that defines an <code class="literal">operations</code> list with a <code class="literal">migrations.AddField</code> that will add the the owner field to the table related to the <code class="literal">game</code> model.</p><p>Now, run the following python script to apply all the generated migrations and execute the changes in the database tables:</p><pre class="programlisting">
<strong>python manage.py migrate</strong>
</pre><p>The following lines show the output generated after running the previous command. Note that the ordering for the migrations might be different in your configuration:</p><pre class="programlisting">
<strong>Operations to perform:</strong>
<strong>  Apply all migrations: admin, auth, contenttypes, games, sessions</strong>
<strong>Running migrations:</strong>
<strong>  Rendering model states... DONE</strong>
<strong>  Applying games.0003_game_owner... OK</strong>
</pre><p>After we run the previous command, we will have a new <code class="literal">owner_id</code> field added to the <code class="literal">games_game</code> table in the PostgreSQL database. The existing rows in the <code class="literal">games_game</code> table will use the default value we indicated Django to use for the new <code class="literal">owner_id</code> field. We can use the PostgreSQL command line or any other application that allows us to easily check the contents of the PostreSQL database to check the <code class="literal">games_game</code> table that Django updated. In case you decide to continue working with SQLite, use the commands or tools related to this database.</p><p>Run the following command to launch the interactive shell. Make sure you are within the <code class="literal">gamesapi</code> folder in the Terminal or Command Prompt:</p><pre class="programlisting">
<strong>python manage.py shell</strong>
</pre><p>You will notice that a line that says (<strong>InteractiveConsole</strong>) is displayed after the usual lines that introduce your default Python interactive shell. Enter the following code in the Python interactive to create another user that is not a superuser. We will use this user and the superuser to test our changes in the permissions policies. The code file for the sample is included in the <code class="literal">restful_python_chapter_03_04</code> folder, in the <code class="literal">users_test_01.py</code> file.</p><p>You can replace <code class="literal">kevin</code> with your desired user name, <code class="literal">kevin@eaxmple.com</code> with the e-mail and <code class="literal">kevinpassword</code> with the password you want to use for this user. However, take into account that we will be using these credentials in the following sections. Make sure you always replace the credentials with your own credentials:</p><pre class="programlisting">from django.contrib.auth.models import User 
user = User.objects.create_user('kevin', 'kevin@example.com', 'kevinpassword')  
user.save() 
</pre><p>Finally, quit the interactive console by entering the following command:</p><pre class="programlisting">quit() 
</pre><p>Now, we can launch Django's development server to compose and send HTTP requests. Execute any of the following two commands based on your needs to access the API in other devices or computers connected to your LAN. Remember that we analyzed the difference between them in <a class="link" href="ch01.html" title="Chapter 1. Developing RESTful APIs with Django">Chapter 1</a>, <em>Developing RESTful APIs with Django</em>:</p><pre class="programlisting">
<strong>python manage.py runserver</strong>
<strong>python manage.py runserver 0.0.0.0:8000</strong>
</pre><p>After we run any of the preceding commands, the development server will start listening at port <code class="literal">8000</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec41"/>Composing requests with the necessary authentication</h1></div></div></div><p>Now, we will compose and send an HTTP request to create a new game without authentication credentials:</p><pre class="programlisting">
<strong>http POST :8000/games/ name='The Last of Us' game_category='3D RPG' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
</pre><p>The following is the equivalent curl command:</p><pre class="programlisting">
<strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"The Last of Us", "game_category":"3D RPG", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
</pre><p>We will receive a <code class="literal">401 Unauthorized</code> status code in the response header and a detail message indicating that we didn't provide authentication credentials in the JSON body. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 401 Unauthorized</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Sun, 03 Jul 2016 22:23:07 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept, Cookie</strong>
<strong>WWW-Authenticate: Basic realm="api"</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "detail": "Authentication credentials were not provided."</strong>
<strong>}</strong>
</pre><p>If we want to create a new game, that is, to make a <code class="literal">POST</code> request to <code class="literal">/games/</code>, we need to provide authentication credentials using HTTP authentication. Now, we will compose and send an HTTP request to create a new game with authentication credentials, that is, with the <code class="literal">superuser</code> name and his password. Remember to replace <code class="literal">superuser</code> with the name you used for the <code class="literal">superuser</code> and <code class="literal">password</code> with the password you configured for this user:</p><pre class="programlisting">
<strong>http -a superuser:'password' POST :8000/games/ name='The Last of Us' game_category='3D RPG' played=false release_date='2016-06-21T03:02:00.776594Z'</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl --user superuser:'password' -iX POST -H "Content-Type: application/json" -d '{"name":"The Last of Us", "game_category":"3D RPG", "played": "false", "release_date": "2016-06-21T03:02:00.776594Z"}' :8000/games/</strong>
</pre><p>If the new <code class="literal">Game</code> with the superuser user as its owner was successfully persisted in the database, the function returns an <code class="literal">HTTP 201 Created</code> status code and the recently persisted <code class="literal">Game</code> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <code class="literal">Game</code> object in the JSON response:</p><pre class="programlisting">
<strong>HTTP/1.0 201 Created</strong>
<strong>Allow: GET, POST, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 04 Jul 2016 02:45:36 GMT</strong>
<strong>Location: http://localhost:8000/games/16/</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "game_category": "3D RPG", </strong>
<strong>    "name": "The Last of Us", </strong>
<strong>    "owner": "superuser", </strong>
<strong>    "played": false, </strong>
<strong>    "release_date": "2016-06-21T03:02:00.776594Z", </strong>
<strong>    "url": "http://localhost:8000/games/16/"</strong>
<strong>}</strong>
</pre><p>Now, we will compose and send an HTTP request to update the <code class="literal">played</code> field value for the previously created game with authentication credentials. However, in this case, we will use the other user we created in Django to authenticate the request. Remember to replace <code class="literal">kevin</code> with the name you used for the user and <code class="literal">kevinpassword</code> with the password you configured for this user. In addition, replace <code class="literal">16</code> with the id generated for the previously created game in your configuration. We will use the <code class="literal">PATCH</code> method.</p><pre class="programlisting">
<strong>http -a kevin:'kevinpassword' PATCH :8000/games/16/ played=true</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl --user kevin:'kevinpassword' -iX PATCH -H "Content-Type: application/json" -d '{"played": "true"}' :8000/games/16/</strong>
</pre><p>We will receive a <code class="literal">403 Forbidden</code> status code in the response header and a detail message indicating that we do not have permission to perform the action in the JSON body. The owner for the game we want to update is <code class="literal">superuser</code> and the authentication credentials for this request use a different user. Thus, the operation is rejected by the <code class="literal">has_object_permission</code> method in the <code class="literal">IsOwnerOrReadOnly</code> class. The following lines show a sample response:</p><pre class="programlisting">
<strong>HTTP/1.0 403 Forbidden</strong>
<strong>Allow: GET, PUT, PATCH, DELETE, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Date: Mon, 04 Jul 2016 02:59:15 GMT</strong>
<strong>Server: WSGIServer/0.2 CPython/3.5.1</strong>
<strong>Vary: Accept</strong>
<strong>X-Frame-Options: SAMEORIGIN</strong>
<strong>{</strong>
<strong>    "detail": "You do not have permission to perform this action."</strong>
<strong>}</strong>
</pre><p>If we compose and send an HTTP request with the same authentication credentials for the same resource with the <code class="literal">GET</code> method, we will be able to retrieve the game that the specified user doesn't own. It will work because <code class="literal">GET</code> is one of the safe methods and a user that is not the owner is allowed to read the resource. Remember to replace <code class="literal">kevin</code> with the name you used for the user and <code class="literal">kevinpassword</code> with the password you configured for this user. In addition, replace <code class="literal">16</code> with the id generated for the previously created game in your configuration:</p><pre class="programlisting">
<strong>http -a kevin:'kevinpassword' GET :8000/games/16/</strong>
</pre><p>The following is the equivalent <code class="literal">curl</code> command:</p><pre class="programlisting">
<strong>curl --user kevin:'kevinpassword' -iX GET :8000/games/16/</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec42"/>Browsing the API with authentication credentials</h1></div></div></div><p>Open a web browser and enter <code class="literal">http://localhost:8000/</code>. Replace localhost by the IP of the computer that is running the Django development server in case you use another computer or device to run the browser. The browsable API will compose and send a <code class="literal">GET</code> request to <code class="literal">/</code> and will display the results of its execution, that is, the Api Root. You will notice that there is a <strong>Log in</strong> hyperlink in the upper-right corner.</p><p>Click Log in and the browser will display the Django REST Framework login page. Enter <code class="literal">kevin</code> in username, <code class="literal">kevinpassword</code> in password, and click <strong>Log In</strong>. Remember to replace <code class="literal">kevin</code> with the name you used for the user and <code class="literal">kevinpassword</code> with the password you configured for this user. Now, you will be logged in as <code class="literal">kevin</code> and all the requests you compose and send through the browsable API will use this user. You will be redirected again to the <strong>Api Root</strong> and you will notice the <strong>Log In</strong> hyperlink is replaced with the username (<strong>kevin</strong>) and a drop-down menu that allows you to Log Out. The following screenshot shows the Api Root after we are logged in as <code class="literal">kevin</code>.</p><p>Click or tap on the URL on the right-hand side of <strong>users</strong>. In case you are browsing in localhost, the URL will be <code class="literal">http://localhost:8000/users/</code>. The Browsable API will render the web page for the <strong>Users List</strong>. The following lines show the JSON body with the first lines and the last lines with the results for the <code class="literal">GET</code> request to <code class="literal">localhost:8000/users/</code>.</p><p>The <code class="literal">games</code> array includes the URL and the name for each game that the user owns because the <code class="literal">UserGameSerializer</code> class is serializing the content for each game:</p><pre class="programlisting">
<strong>HTTP 200 OK</strong>
<strong>Allow: GET, HEAD, OPTIONS</strong>
<strong>Content-Type: application/json</strong>
<strong>Vary: Accept</strong>
<strong>{</strong>
<strong>    "count": 2,</strong>
<strong>    "next": null,</strong>
<strong>    "previous": null,</strong>
<strong>    "results": [</strong>
<strong>        {</strong>
<strong>            "url": "http://localhost:8000/users/1/",</strong>
<strong>            "pk": 1,</strong>
<strong>            "username": "superuser",</strong>
<strong>            "games": [</strong>
<strong>                {</strong>
<strong>                    "url": "http://localhost:8000/games/10/",</strong>
<strong>                    "name": "A Dark Room"</strong>
<strong>                },</strong>
<strong>                {</strong>
<strong>                    "url": "http://localhost:8000/games/11/",</strong>
<strong>                    "name": "Bastion"</strong>
<strong>                },</strong>
<strong>        ...</strong>
<strong>            ]</strong>
<strong>        },</strong>
<strong>        {</strong>
<strong>            "url": "http://localhost:8000/users/3/",</strong>
<strong>            "pk": 3,</strong>
<strong>            "username": "kevin",</strong>
<strong>            "games": []</strong>
<strong>        }</strong>
<strong>    ]</strong>
<strong>}</strong>
</pre><p>Click or tap on one of the URLs for the games listed as owned by the <code class="literal">superuser</code> user. The Browsable API will render the web page for the <strong>Game Detail</strong>. Click or tap on <strong>OPTIONS</strong> and the <strong>DELETE</strong> button will appear. Click or tap on <strong>DELETE</strong>. The web browser will display a confirmation dialog box. Click or tap on <strong>DELETE</strong>. We will receive a <code class="literal">403 Forbidden</code> status code in the response header and a detail message indicating that we do not have permission to perform the action in the JSON body.</p><p>The owner for the game we want to delete is <code class="literal">superuser</code> and the authentication credentials for this request use a different user, specifically, <code class="literal">kevin</code>. Thus, the operation is rejected by the <code class="literal">has_object_permission</code> method in the <code class="literal">IsOwnerOrReadOnly</code> class. The following screenshot shows a sample response:</p><p>
</p><div><img src="img/image_03_001.jpg" alt="Browsing the API with authentication credentials"/></div><p>
</p><div><div><h3 class="title"><a id="tip30"/>Tip</h3><p>We can also take advantage of other authentication plugins that Django REST Framework provides us. You can read more about all the possibilities that the framework provides us for authentication at <a class="ulink" href="http://www.django-rest-framework.org/api-guide/authentication/">http://www.django-rest-framework.org/api-guide/authentication/</a>
</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec43"/>Test your knowledge</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Which is the most appropriate HTTP method to update a single field for an existing resource:<div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">PUT</code></li><li class="listitem"><code class="literal">POST  </code></li><li class="listitem"><code class="literal">PATCH</code></li></ol></div><p>
</p></li><li class="listitem">Which of the following pagination classes provides a limit/offset based style in Django REST Framework:<div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">rest_framework.pagination.LimitOffsetPagination</code></li><li class="listitem"><code class="literal">rest_framework.pagination.LimitOffsetPaging</code></li><li class="listitem"><code class="literal">rest_framework.styles.LimitOffsetPagination</code></li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">rest_framework.authentication.BasicAuthentication</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Works with Django's session framework for authentication.</li><li class="listitem">Provides an HTTP Basic authentication against username and password.</li><li class="listitem">Provides a simple token based authentication.</li></ol></div><p>
</p></li><li class="listitem">The <code class="literal">rest_framework.authentication.SessionAuthentication</code> class:<div><ol class="orderedlist arabic"><li class="listitem">Works with Django's session framework for authentication.</li><li class="listitem">Provides an HTTP Basic authentication against username and password.</li><li class="listitem">Provides a simple token based authentication.</li></ol></div><p>
</p></li><li class="listitem">The value of which of the following settings keys specify a global setting with a tuple of string whose values indicate the classes that we want to use for authentication:<div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">DEFAULT_AUTH_CLASSES</code></li><li class="listitem"><code class="literal">AUTHENTICATION_CLASSES</code></li><li class="listitem"><code class="literal">DEFAULT_AUTHENTICATION_CLASSES</code></li></ol></div><p>
</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we improved the REST API in many ways. We added unique constraints to the model and updated the database, we made it easy to update single fields with the <code class="literal">PATCH</code> method and we took advantage of pagination.</p><p>Then, we started working with authentication, permissions, and throttling. We added security-related data to the models and we updated the database. We made numerous changes in the different pieces of code to achieve a specific security goal and we took advantage of Django REST Framework authentication and permissions features.</p><p>Now that we have built an improved and complex API that takes into account authentication and uses permission policies, we will use additional abstractions included in the framework, we will add throttling and tests, which is what we are going to discuss in the next chapter.</p></div></body></html>