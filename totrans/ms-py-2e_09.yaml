- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Documentation – How to Use Sphinx and reStructuredText
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档 – 如何使用 Sphinx 和 reStructuredText
- en: Documenting code can be both fun and useful! I will admit that many programmers
    have a strong dislike for documenting code and understandably so. Writing documentation
    can be a boring job and, traditionally, only others reap the benefits of that
    effort. The tools available for Python, however, make it almost trivial to generate
    useful and up-to-date documentation with little to no effort at all. Generating
    documentation has actually become so easy that I often create and generate documentation
    before using a Python package. Assuming it wasn’t available already, that is.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 记录代码可以既有趣又有用！我必须承认，许多程序员对记录代码有强烈的厌恶，这是可以理解的。编写文档可能是一项枯燥的工作，而且传统上，只有其他人能从这种努力中获得好处。然而，Python
    可用的工具几乎可以毫不费力地生成有用且最新的文档。实际上，生成文档已经变得如此简单，以至于我经常在开始使用 Python 包之前就创建和生成文档。假设它还没有可用的话。
- en: In addition to simple text documentation explaining what a function does, it
    is also possible to add metadata, such as type hints. These type hints can be
    used to make the arguments and return types of a function or class clickable in
    the documentation. But more importantly, many modern IDEs and editors, such as
    VIM, have plugins available that parse the type hints and use them for intelligent
    autocompletion. So if you type `'some_string.'`, your editor will automatically
    complete the specific attributes and methods of a string object, something that
    is traditionally only viable with statically typed languages such as Java, C,
    and C++.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的文本文档来解释函数的功能之外，还可以添加元数据，例如类型提示。这些类型提示可以用来使函数或类的参数和返回类型在文档中可点击。但更重要的是，许多现代
    IDE 和编辑器，如 VIM，都有可用的插件，这些插件解析类型提示并用于智能自动完成。所以如果你输入 `'some_string.'`，你的编辑器将自动完成字符串对象的特定属性和方法，这在传统上只有像
    Java、C 和 C++ 这样的静态类型语言中才是可行的。
- en: This chapter will explain the types of documentation available in Python and
    how easily a full set of documentation can be created. With the amazing tools
    that Python provides, you can have fully functioning documentation within minutes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释 Python 中可用的文档类型以及如何轻松创建完整的一套文档。有了 Python 提供的惊人工具，你可以在几分钟内拥有功能齐全的文档。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Type hinting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示
- en: The reStructuredText syntax
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reStructuredText 语法
- en: The Markdown syntax
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Markdown 语法
- en: Setting up documentation using Sphinx
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Sphinx 设置文档
- en: Sphinx-, Google-, and NumPy-style docstrings
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sphinx、Google 和 NumPy 风格的 docstrings
- en: Type hinting
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型提示
- en: Since Python 3.5, we’ve had a feature called type hinting, which is arguably
    one of the most useful additions to Python 3\. It allows you to specify the types
    of variables and return values, which means your editor will be able to give you
    smart autocompletion. This makes it useful for all Python programmers, regardless
    of level, and can make your life much easier when paired with a good editor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.5 以来，我们有一个名为类型提示的功能，这可以说是 Python 3 中最有用的添加之一。它允许你指定变量和返回值的类型，这意味着你的编辑器将能够提供智能自动完成。这使得它对所有
    Python 程序员都很有用，无论水平如何，并且与一个好的编辑器搭配使用时可以使你的生活变得更加容易。
- en: Basic example
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本示例
- en: 'Most editors are already smart enough to recognize basic types in regular variables
    such as these:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编辑器已经足够智能，可以识别这些常规变量中的基本类型：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It becomes a lot harder for an editor when, instead of `a = 123`, we have something
    like `a = some_function()`. In some cases, the return type of a function is obvious
    (i.e. `return True`), but if the return type depends on the input variables or
    is not consistent, it becomes much harder for the editor to understand what is
    happening.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不是有 `a = 123` 这样的代码，而是有 `a = some_function()` 这样的代码时，编辑器的工作会变得更加困难。在某些情况下，函数的返回类型是明显的（即
    `return True`），但如果返回类型依赖于输入变量或是不一致的，编辑器理解正在发生的事情就会变得非常困难。
- en: 'As the Zen of Python tells us, explicit is better than implicit. In the case
    of function return types, this is often the case and can be implemented with very
    little effort:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Python 的禅所说，明确优于隐晦。在函数返回类型的情况下，这通常是正确的，并且可以非常容易地实现：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'That works as expected. With a simple `-> type`, you can specify the function
    return type, which is automatically reflected in the `__annotations__`, which
    is also visible in the `help()`. And the arguments (and variables) can be type-specified
    using `name: type`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '这正如预期的那样工作。使用简单的 `-> type`，你可以指定函数的返回类型，这会自动反映在 `__annotations__` 中，这在 `help()`
    中也是可见的。并且可以使用 `name: type` 来指定参数（和变量）的类型。'
- en: In this case, you may notice that even though we specified the function to return
    an `int`, it can actually return a `float` as well, since Python only has type
    hints, not type constraints/enforcements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能注意到，尽管我们指定了函数返回一个 `int`，但实际上它也可以返回一个 `float`，因为 Python 只有类型提示，没有类型约束/强制。
- en: 'While basic types such as `int`, `float`, `str`, `dict`, `list`, and `set`
    can be specified with `variable: int` alone, for more advanced types, we need
    the `typing` module.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然基本类型如 `int`、`float`、`str`、`dict`、`list` 和 `set` 可以仅使用 `variable: int` 来指定，但对于更高级的类型，我们需要使用
    `typing` 模块。'
- en: 'Since Python 3.9, you can use `variable: list[int]`. For older versions of
    Python, you need to use `variable: typing.List[int]` for all collection types
    such as `dict`/`list`/`set` that require the getitem (`[]`) operator.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '由于 Python 3.9，你可以使用 `variable: list[int]`。对于 Python 的旧版本，你需要使用 `variable: typing.List[int]`
    来指定所有需要使用 `getitem (`[])` 操作符的集合类型，如 `dict`/`list`/`set`。'
- en: 'The `typing` module contains types such as `typing.Any` to allow everything,
    `typing.Optional` to allow for `None`, and `typing.Union` to specify multiple
    allowed types, which we will now demonstrate:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing` 模块包含如 `typing.Any` 允许一切，`typing.Optional` 允许 `None`，以及 `typing.Union`
    指定多个允许的类型，我们现在将演示这些：'
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With `typing.Union`, we can specify a list of types that apply. Similarly, an
    optional type can be specified using `typing.Optional[int]` to indicate that the
    type can be either `int` or `None`, effectively being equivalent to `typing.Union[int,
    None]`. Additionally, since Python 3.10 we can write this as `int` `|` `None`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `typing.Union`，我们可以指定一个类型列表，同样，可以使用 `typing.Optional[int]` 来指定一个可选类型，表示类型可以是
    `int` 或 `None`，这实际上等同于 `typing.Union[int, None]`。此外，从 Python 3.10 开始，我们可以将其写成
    `int` `|` `None`。
- en: Custom types
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义类型
- en: 'Since regular Python objects are their own type, you usually don’t even have
    to think about what type they are. Simply specify the object and it will work:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于常规 Python 对象是其自己的类型，你通常甚至不需要考虑它们的类型。只需指定对象，它就会工作：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But what would happen with circular definitions or other circumstances where
    you do not have the type available yet? In that case, you can work around the
    issue by specifying the type as a string:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果遇到循环定义或其他你还没有类型可用的情况呢？在这种情况下，你可以通过指定类型为字符串来解决这个问题：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Whenever possible, I would recommend against this method because it gives you
    no guarantee that the type can actually be resolved:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，我建议不要使用这种方法，因为它不能保证类型实际上可以被解决：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Naturally, this will only check whether the type actually exists. For proper
    type checking, we can use tools such as `mypy`, which will be covered in the next
    section. To make sure that your type checker can resolve the type, you can encase
    your imports in an `if typing.TYPE_CHECKING` block like so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这只会检查类型实际上是否存在。为了进行正确的类型检查，我们可以使用像 `mypy` 这样的工具，这将在下一节中介绍。为了确保你的类型检查器可以解析类型，你可以将你的导入放在一个
    `if typing.TYPE_CHECKING` 块中，如下所示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `typing.TYPE_CHECKING` constant is not normally set, but can be set by type
    checkers such as `mypy` to make sure all types are working correctly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.TYPE_CHECKING` 常量通常不会被设置，但可以被像 `mypy` 这样的类型检查器设置，以确保所有类型都正常工作。'
- en: 'In the examples above, we have seen custom classes as custom types, but what
    if we want to create a custom type out of an existing built-in type? That is also
    possible using `typing.NewType`, which creates a new type that behaves like the
    base type, but can be checked by static type checkers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们已经看到了自定义类作为自定义类型，但如果我们想从一个现有的内置类型创建一个自定义类型呢？这也是可能的，使用 `typing.NewType`
    创建一个新类型，它表现得像基类型，但可以被静态类型检查器检查：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we created a type called `Username`, which is treated as a subclass of
    `str` in this case.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `Username` 的类型，在这种情况下它被视为 `str` 的子类。
- en: Generics
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: In some cases, you don’t want to statically specify the type of a function,
    but make it depend on the input instead. For this reason, the Python type system
    supports generics. If you’re familiar with Java, C++, or C#, you might be familiar
    with them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你不想静态指定函数的类型，而是让它依赖于输入。因此，Python 类型系统支持泛型。如果你熟悉 Java、C++ 或 C#，你可能已经熟悉它们。
- en: Generics allow you to create a generic type whose only constraint is that it
    is the same in all cases. This means that if you specify a generic type as both
    the input and the output for a function, it will be assumed to be the same; if
    you input an `int` into a function, you will receive an `int`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许你创建一个泛型类型，其唯一约束是它在所有情况下都相同。这意味着如果你将泛型类型指定为函数的输入和输出，它将被假定是相同的；如果你将`int`输入到函数中，你将收到一个`int`。
- en: 'First, we need to specify a generic type and, after that, we can specify it
    as parameters for our functions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要指定一个泛型类型，然后我们才能将其指定为函数的参数：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, we created a generic type with the constraint that it needs to
    be either `int` or `str`. When the type checker runs, it will check if `a`, `b`,
    and the `return` value have the same type. This means that even though an `int`
    is valid for type `T`, if you make `a` a `str`, `b` and the output have to be
    `str` as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个泛型类型，其约束是它必须是`int`或`str`。当类型检查器运行时，它将检查`a`、`b`和`return`值是否有相同的类型。这意味着即使`int`对于类型`T`是有效的，如果你将`a`设为`str`，`b`和输出也必须是`str`。
- en: Type checking
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型检查
- en: Now that we know how to specify and create type hints, it’s time to run a type
    checker. The reference implementation for type checking is the `mypy` tool. It
    can thoroughly check your code and warn about potential problems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何指定和创建类型提示，是时候运行类型检查器了。类型检查的参考实现是`mypy`工具。它可以彻底检查你的代码，并警告潜在的问题。
- en: 'First, we need to install `mypy` – luckily, that’s easy enough with `pip`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装`mypy`——幸运的是，使用`pip`来做这件事很容易：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we will use `mypy` to check some of the earlier examples with a few errors
    added:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用`mypy`来检查一些之前带有错误的一些示例：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we hinted `base` to be an `int`, `2.5` is not a valid value since it
    is a `float`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们提示`base`为`int`，`2.5`不是一个有效的值，因为它是一个`float`：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now an example with a custom type:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个自定义类型的示例：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here we specified that `print_username()` should receive a `Username` type.
    Even though `Username` inherits `str`, it is not considered valid:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了`print_username()`应该接收一个`Username`类型。即使`Username`继承了`str`，它也不被认为是有效的：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Lastly, we will create a generic type:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个泛型类型：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since `to_string()` received an `int`, it should return an `int`, which is
    not the case. Let’s run `mypy` to see what’s wrong:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`to_string()`接收了一个`int`，它应该返回一个`int`，但这并不是情况。让我们运行`mypy`来看看哪里出了问题：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While writing code, `mypy` can save you a lot of debugging by warning you about
    incorrect type usage.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，`mypy`可以通过警告你关于不正确的类型使用来为你节省大量的调试时间。
- en: Python type interface files
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python类型接口文件
- en: Python type hint files (`.pyi`), also called stub files, are files that allow
    you to specify all type hints for a file without touching the original file. This
    is useful for libraries that you do not have write access to, or if you do not
    want to clutter your files with type hints.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型提示文件（`.pyi`），也称为存根文件，是允许你为文件指定所有类型提示而不修改原始文件的文件。这对于你无法写入的库或你不想在文件中添加类型提示的情况非常有用。
- en: 'The files use the regular Python syntax, but the functions are not meant to
    contain anything beyond stubs that only hint the types. An example stub for the
    `print_username()` function mentioned above could be:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件使用的是常规的Python语法，但函数并不打算包含任何除了仅提示类型的存根之外的内容。上面提到的`print_username()`函数的一个示例存根可能是：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The files are nothing special, but they can be especially useful when interacting
    with libraries that lack type hinting. If your regular file is named `test.py`,
    the `pyi` file would be named `test.pyi`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件没有什么特别之处，但它们在与缺少类型提示的库交互时特别有用。如果你的常规文件名为`test.py`，那么`pyi`文件将命名为`test.pyi`。
- en: Type hinting conclusion
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示结论
- en: Within this section, you have seen a few very basic examples of how type hinting
    can be applied and how the types can be checked. The Python `typing` module is
    still getting enhanced quite a lot and `mypy` has really extensive documentation
    that can be useful if you are applying this to your own code. Make sure to look
    at the documentation if you have any specific issues; it is high quality and very
    useful.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经看到了一些非常基本的示例，说明了如何应用类型提示以及如何检查类型。Python的`typing`模块仍在不断改进，`mypy`有非常详尽的文档，如果你在自己的代码中应用这些，可能会很有用。如果你有任何具体问题，请确保查看文档；它质量很高，非常实用。
- en: When it comes to using type hinting in your own projects, my suggestion is to
    use it wherever it enhances your workflow but not to go overboard. In many cases,
    your editor will be smart enough to figure out the arguments automatically, or
    it won’t really matter too much. But when passing along more advanced classes
    where you tend to forget the methods available for that class, it becomes a really
    useful feature. Having smart autocompletion can really save you a lot of time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在自己的项目中使用类型提示时，我的建议是只要它增强了你的工作流程就使用它，但不要过度使用。在许多情况下，你的编辑器足够智能，可以自动识别参数，或者这并不真的那么重要。但是，当传递更高级的类时，你可能会忘记该类的方法，这时它就成为一个非常有用的特性。拥有智能自动补全功能可以真正为你节省大量时间。
- en: Now that we have type hints covered, it is time to continue with documenting
    our code and the markup languages available for that task.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了类型提示，是时候继续记录我们的代码以及用于此任务的标记语言了。
- en: reStructuredText and Markdown
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reStructuredText和Markdown
- en: The **reStructuredText** format (also known as **RST**, **ReST**, or **reST**)
    was developed in 2002 as a language that implements enough markup to be usable,
    but is simple enough to be readable as plain text. These two features make it
    readable enough to use in code, yet still versatile enough to generate pretty
    and useful documentation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**reStructuredText**格式（也称为**RST**、**ReST**或**reST**）于2002年开发，作为一种实现足够标记以可用的语言，但足够简单以供纯文本阅读。这两个特性使得它足够易于在代码中使用，同时仍然足够灵活以生成美观且有用的文档。'
- en: The Markdown format is really similar to reStructuredText and largely comparable.
    While reStructuredText is slightly older (2012) than Markdown (2014), the Markdown
    format has gained a bit more popularity because it’s a bit simpler and less Python-focused.
    Both standards are excellent for writing text that is legible straightaway and
    can easily be converted to other formats such as HTML or PDF files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown格式与reStructuredText非常相似，在很大程度上可以比较。虽然reStructuredText比Markdown（2014年）稍早（2012年），但Markdown格式因其更简单且不那么以Python为中心而获得了更多的流行。这两个标准都非常适合编写易于阅读的文本，并且可以轻松转换为其他格式，如HTML或PDF文件。
- en: 'The main advantages of reST are:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: reST的主要优点是：
- en: A very extensive feature set
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非常广泛的功能集
- en: A strictly defined standard
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个严格定义的标准
- en: Easy extensibility
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展
- en: 'The main advantages of Markdown are:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown的主要优点是：
- en: It is less Python-centric, which caused it to gain more widespread adoption
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不那么以Python为中心，这导致它获得了更广泛的应用
- en: A more forgiving and less strict parser, which makes it easier to write
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更宽容且不那么严格的解析器，这使得编写更加容易
- en: The greatest thing about both reStructuredText and Markdown is that they are
    very intuitive to write and natively supported by most (social) coding platforms
    such as GitHub, GitLab, BitBucket, and PyPI.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText和Markdown最棒的地方在于它们非常直观易写，并且被大多数（社交）编码平台（如GitHub、GitLab、BitBucket和PyPI）原生支持。
- en: Even without knowing anything about the standard, you can easily write documentation
    in this style. However, more advanced techniques, such as images and links, do
    require some explanation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不了解任何关于标准的信息，你也能轻松地用这种风格编写文档。然而，更高级的技术，如图片和链接，确实需要一些解释。
- en: For Python documentation itself, reStructuredText is the most convenient standard
    since it’s well supported by tools such as Sphinx and docutils. For readme files
    on sites such as GitHub and the Python Package Index, the Markdown standard is
    generally better supported.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python文档本身，reStructuredText是最方便的标准，因为它得到了Sphinx和docutils等工具的良好支持。对于GitHub和Python包索引等网站上的readme文件，Markdown标准通常得到更好的支持。
- en: To easily convert between formats such as reStructuredText and Markdown, use
    the Pandoc tool, available at [https://pandoc.org/](https://pandoc.org/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要轻松地在reStructuredText和Markdown等格式之间进行转换，请使用Pandoc工具，该工具可在[https://pandoc.org/](https://pandoc.org/)找到。
- en: 'The basic syntax reads just like text and the next few paragraphs will show
    some of the more advanced features. However, let us start with a simple example
    demonstrating how simple a reStructuredText or Markdown file can be:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基本语法看起来就像文本，接下来的几段将展示一些更高级的功能。然而，让我们从一个简单的例子开始，展示reStructuredText或Markdown文件可以有多简单：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That’s how easy it is to convert the text of this chapter so far to reStructuredText
    or Markdown. The example above works in both. But for the Markdown file to look
    similar, we need to modify the headers slightly:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将本章到目前为止的文本转换为reStructuredText或Markdown有多简单。上面的例子在两者中都适用。但是为了让Markdown文件看起来相似，我们需要稍微修改一下标题：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following paragraphs will cover the following features:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的段落将涵盖以下功能：
- en: Inline markup (italic, bold, code, and links)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内联标记（斜体、粗体、代码和链接）
- en: Lists
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表
- en: Headers
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题
- en: Advanced links
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高级链接
- en: Images
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片
- en: Substitutions
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换
- en: Blocks containing code, math, and others
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含代码、数学和其他内容的块
- en: Getting started with reStructuredText
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用reStructuredText
- en: 'To quickly convert a reStructuredText file to HTML, we can use the `docutils` library.
    The `sphinx` library discussed later in this chapter actually uses the `docutils` library
    internally, but has some extra features that we won’t need initially. To get started,
    we just need to install `docutils`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速将reStructuredText文件转换为HTML，我们可以使用`docutils`库。本章后面讨论的`sphinx`库实际上内部使用`docutils`库，但它有一些我们最初不需要的额外功能。要开始，我们只需要安装`docutils`：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After that, we can easily convert reStructuredText into PDF, LaTeX, HTML, and
    other formats. For the examples in this paragraph, we’ll use the HTML format,
    which is easily generated using the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以轻松地将reStructuredText转换为PDF、LaTeX、HTML和其他格式。对于本段中的示例，我们将使用HTML格式，它可以通过以下命令轻松生成：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The reStructuredText language has two basic components:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText语言有两个基本组件：
- en: Roles that allow for **inline** modifications of the output, such as `:code:`,
    `:math:`, `:emphasis:`, and `:literal:`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许对输出进行**内联**修改的角色，例如`:code:`, `:math:`, `:emphasis:`, 和 `:literal:`.
- en: 'Directives that generate markup **blocks**, such as code samples with multiple
    lines. These look like this:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成标记**块**的指令，例如多行代码示例。它们看起来像这样：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Within pure reStructuredText, the directives are the most important, but we
    will see many uses for the roles in the section on *Sphinx roles* later in this
    chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯reStructuredText中，指令是最重要的，但我们将在本章后面的*Sphinx角色*部分看到角色的许多用途。
- en: Getting started with Markdown
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用Markdown
- en: 'To quickly convert a Markdown file to HTML we have many options available.
    But, because we are using Python, we will use the `markdown` package:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速将Markdown文件转换为HTML，我们有多种选择可用。但是，因为我们使用Python，我们将使用`markdown`包：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we can convert our file to HTML with the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令将我们的文件转换为HTML：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It should be noted that this converter only supports plain Markdown, not the
    GitHub flavored Markdown, which also supports code syntax highlighting.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，此转换器仅支持纯Markdown，不支持GitHub风格的Markdown，后者还支持代码语法高亮。
- en: The `grip` (GitHub Readme Instant Preview) Python package supports live rendering
    of GitHub flavored Markdown by using the GitHub servers and can be useful while
    writing Markdown.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`grip`（GitHub Readme Instant Preview）Python包通过使用GitHub服务器支持GitHub风格的Markdown的实时渲染，这在编写Markdown时可能很有用。'
- en: Inline markup
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联标记
- en: '**Inline markup** is the markup that is used within a regular line of text.
    Examples of these are emphasis, inline code examples, links, images, and bullet
    lists.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**内联标记**是在常规文本行中使用的标记。这些示例包括着重、内联代码示例、链接、图片和项目符号列表。'
- en: Within reStructuredText, these are implemented through roles, but often have
    useful shorthands. Instead of `:emphasis:'text'`, you can also use `*text*`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在reStructuredText中，这些通过角色实现，但通常有有用的简写。您可以使用`*text*`而不是`:emphasis:'text'`。
- en: Emphasis, for example, can be added by encapsulating the words between one or
    two asterisk signs. This sentence, for example, could add a little bit of `*emphasis*` by
    adding a single asterisk on both sides, or a lot of `**emphasis**` by adding two
    asterisks on both sides. There are many different inline markup directives so
    we will list only the most common ones. A full list can always be found through
    the reStructuredText home page at [https://docutils.sourceforge.io/docs/](https://docutils.sourceforge.io/docs/)
    and the Markdown home page at [https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax),
    respectively.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过将单词封装在一到两个星号之间来添加着重。例如，这个句子可以通过在两侧添加单个星号来添加一点`*着重*`，或者通过在两侧添加两个星号来添加很多`**着重**`。有许许多多的内联标记指令，所以我们只列出最常见的。完整的列表始终可以在reStructuredText主页[https://docutils.sourceforge.io/docs/](https://docutils.sourceforge.io/docs/)和Markdown主页[https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax)中找到。
- en: 'The following are some examples that work for both reST and Markdown:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些既适用于reST也适用于Markdown的示例：
- en: Emphasis (italic) text: `*emphasis for this phrase*`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着重（斜体）文本：`*这个短语的着重*`.
- en: Extra emphasis (bold) text: `**extra emphasis for this phrase**`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 额外的着重（粗体）文本：`**这个短语的额外着重**`.
- en: 'For lists without numbers, a simple dash with a space after it:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不带数字的列表，只需在后面加一个空格的简单破折号：
- en: '`- item 1`'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- 项目 1`'
- en: '`- item 2`'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`- 项目 2`'
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The space after the dash is required for reStructuredText to recognize the list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 破折号后面的空格对于 reStructuredText 识别列表是必需的。
- en: 'For lists with numbers, the number followed by a period and a space:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于带数字的列表，数字后面跟着一个句点和空格：
- en: '`1\. item 1`'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1. 项目 1`'
- en: '`2\. item 2`'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2. 项目 2`'
- en: For numbered lists, the period after the number is required.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于编号列表，数字后面的句点和空格是必需的。
- en: 'Interpreted text: These are domain-specific. Within Python documentation, the
    default role is code, which means that surrounding text with backticks will convert
    your code to use code tags, for example, `''if spam and eggs:''`.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释性文本：这些是特定领域的。在 Python 文档中，默认的角色是代码，这意味着用反引号包围的文本将被转换为使用代码标签，例如，`'if spam and
    eggs:'`。
- en: 'Inline literals: This is formatted with a monospace font, which makes it ideal
    for inline code. Just add two backticks to `''''add some code''''`. For Markdown,
    there is no noticeable difference between single and double backticks in output,
    but it can be used to escape single backticks: `''''some code '' with backticks''''`.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联字面量：这是使用等宽字体格式化的，这使得它非常适合内联代码。只需在 `''添加一些代码''` 中添加两个反引号即可。对于 Markdown，单引号和双引号在输出中没有明显的区别，但它可以用来转义单引号：`''some
    code ' with backticks''`。
- en: 'Escaping in reST can be done using a \, similar to escaping in Python: `''''some
    code \'' with backticks''''`.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 reST 中可以使用 \ 进行转义，类似于 Python 中的转义：`''some code \' with backticks''`。
- en: For reStructuredText, there are a few extra options using roles, similar to
    the interpreted text role we saw earlier. These roles can be set through role
    prefixes or suffixes depending on your preference; for example, `:math:'E=mc^2'` to
    show mathematical equations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 reStructuredText，有一些额外的选项可以使用角色，类似于我们之前看到的解释性文本角色。这些角色可以通过角色前缀或后缀根据你的偏好设置；例如，`':math:'E=mc^2'`
    用于显示数学方程式。
- en: References can be added through a trailing underscore. They can point to headers,
    links, labels, and more. The next section will cover more about these, but the
    basic syntax is simply `reference_`, or enclosed in backticks when the reference
    contains spaces – `'some reference link'_`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过尾随下划线添加引用。它们可以指向标题、链接、标签等。下一节将介绍更多关于这些的内容，但基本语法是简单的 `reference_`，或者当引用包含空格时用反引号包围
    – `'some reference link'_`。
- en: There are many more available, but these are the ones you will use the most
    when writing reStructuredText.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多更多可供选择，但当你编写 reStructuredText 时，你将最常使用这些。
- en: Headers
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题
- en: 'The headers are used to indicate the start of a document, section, chapter,
    or paragraph. It is therefore the first structure you need in a document. While not
    strictly needed, its usage is highly recommended as it serves several purposes:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 标题用于指示文档、章节、部分或段落的开始。因此，它是文档中你需要的第一种结构。虽然不是严格必需的，但它的使用被高度推荐，因为它有多个用途：
- en: The headers are consistently formatted according to their level.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题会根据其级别进行一致的格式化。
- en: A table of contents (TOC) tree can be generated from the headers.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以从标题生成目录树。
- en: All headers automatically function as labels, which means you can create links
    to them.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有标题自动作为标签使用，这意味着你可以创建指向它们的链接。
- en: The format required to make headers overlaps a little between reST and Markdown,
    but for clarity, we will cover them separately.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 标题所需的格式在 reST 和 Markdown 之间略有重叠，但为了清晰起见，我们将分别介绍。
- en: Headers with reStructuredText
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 reStructuredText 的标题
- en: When creating headers, consistency is one of the few constraints; the number
    of characters used is fairly arbitrary, as is the number of levels.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建标题时，一致性是少数约束之一；使用的字符数相当任意，级别数也是如此。
- en: 'Personally, I default to a simple system with a fixed-size header, but I recommend
    at least following the default of the Python documentation in terms of the parts,
    chapters, sections, subsections, subsubsections, and paragraphs, something along
    the lines of the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我默认使用一个具有固定大小的标题系统，但我建议至少遵循 Python 文档的默认部分、章节、部分、子部分、次子部分和段落的默认设置，大致如下：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This creates the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下输出：
- en: '![Headers](img/B15882_09_01.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![标题](img/B15882_09_01.png)'
- en: 'Figure 9.1: Headers with reStructuredText'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1：使用 reStructuredText 的标题
- en: 'That is just the common usage of the headers, but the main idea of reStructuredText
    is that you can use just about anything that feels natural to you, which means
    that you can use any of the following characters: `= - '' : '' " ~ ^ _ * + # <>`.
    It also supports both underlines and overlines, so if you prefer that, they are
    options as well:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是标题的常见用法，但 reStructuredText 的主要思想是你可以使用任何你觉得自然的东西，这意味着你可以使用以下任何字符：`= - ''
    : " ~ ^ _ * + # <>`。它还支持下划线和上划线，所以如果你更喜欢这样，它们也是选项之一：'
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While I try to keep the number of characters fixed to 78 characters as `PEP8`
    (*Chapter 3*, *Pythonic Syntax and Common Pitfalls*) recommends for Python, the
    number of characters used is mostly arbitrary, but it does have to be at least
    as long as the text of the header. This allows it to accept the following result:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我尽量保持字符数量固定为 78 个字符，如 `PEP8`（*第 3 章*，*Pythonic 语法和常见错误*）所建议的 Python，但使用的字符数量大多是任意的，但至少要和标题文本一样长。这允许它接受以下结果：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But not this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但不是这个：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Headers with Markdown
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Markdown 的标题
- en: 'With Markdown, you have several options for headers depending on what you feel
    like. Similar to reST, you can use the `=` and `–` characters to underline, but
    only those, and the length and blank lines after them do not matter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Markdown，你可以根据个人喜好选择多种标题选项。类似于 reST，你可以使用 `=` 和 `–` 字符进行下划线标记，但仅限这些，并且它们后面的长度和空白行并不重要：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you want more levels, you can use up to 6 levels by using the `#` prefix
    and optional suffixes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多级别，你可以通过使用 `#` 前缀和可选后缀最多使用 6 个级别：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This results in:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生：
- en: '![](img/B15882_09_02.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_09_02.png)'
- en: 'Figure 9.2: Headers in Markdown'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2：Markdown 中的标题
- en: As you can see, Markdown is slightly less flexible than reStructuredText when
    it comes to headers, but in most cases, it offers enough features to be perfectly
    usable.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Markdown 在标题方面比 reStructuredText 略显不灵活，但在大多数情况下，它提供的功能足够多，完全可以使用。
- en: Lists
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表
- en: 'The reStructuredText format has several styles of lists:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText 格式有几种列表样式：
- en: Enumerated
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列表项
- en: Bulleted
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目符号
- en: Options
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选项
- en: Definitions
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义
- en: The simplest forms of lists were already displayed in the introduction section,
    but it’s actually possible to use many different characters, such as letters,
    Roman numerals, and others, for enumeration. After demonstrating the basic list
    types, we will continue with the nesting of lists and structures, which makes
    them even more powerful. Care must be taken with the amount of whitespace, as
    one space too many can cause a structure to be recognized as regular text instead
    of a structure.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍部分已经展示了列表的最简单形式，但实际上可以使用许多不同的字符进行编号，如字母、罗马数字等。在演示了基本列表类型之后，我们将继续介绍列表和结构的嵌套，这使得它们更加强大。需要注意空白量的多少，因为过多的空格可能会导致结构被识别为普通文本而不是结构。
- en: Enumerated lists
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表项
- en: 'Enumerated lists are convenient for all sorts of enumerations. The basic premise
    for enumerated lists is an alphanumeric character followed by a period, a right
    parenthesis, or parentheses on both sides. Additionally, the `#` character functions
    as an automatic enumeration. For example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项对于各种列举都非常方便。列表项的基本前提是数字或字母字符后跟一个点、一个右括号或两侧的括号。此外，`#` 字符还充当自动编号。例如：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The output is perhaps a bit simpler than you would expect. The reason is that
    it depends on the output format. The following figure shows the rendered HTML
    output, which has no support for parentheses. If you output LaTeX, for example,
    the difference can be made visible.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能比你预期的要简单一些。原因是它取决于输出格式。以下图显示了渲染的 HTML 输出，它不支持括号。例如，如果你输出 LaTeX，差异可以变得明显。
- en: '![Enumerated list](img/B15882_09_03.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![列表项](img/B15882_09_03.png)'
- en: 'Figure 9.3: Enumerated lists generated with the HTML output format'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：使用 HTML 输出格式生成的列表项
- en: 'Markdown also supports enumerated lists, but it is a bit more limited in its
    options. It only supports regular numbered lists. It’s more convenient in how
    it supports them though; there is no need for explicit numbering, and repeating
    `1.` works without a problem:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown 也支持列表项，但在选项上略显有限。它只支持常规编号列表。不过，它在支持这些列表项方面更为方便；无需显式编号，重复 `1.` 也不会有问题：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Bulleted lists
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目符号列表
- en: 'If the order of the list is not relevant and you simply need a list of items
    without enumeration, then the bulleted list is what you should use. To create
    a simple list using bullets only, the bulleted items need to start with a `*`, `+`, `-`, `•`, ‣,
    or ⁃. This list is mostly arbitrary and can be modified by extending Sphinx or
    Docutils. For example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '如果列表的顺序不重要，你只需要一个不带编号的项目列表，那么你应该使用项目符号列表。要使用项目符号创建一个简单的列表，项目符号需要以 `*`、`+`、`-`、`•`、‣
    或 ⁃ 开始。这个列表主要是任意的，可以通过扩展 Sphinx 或 Docutils 来修改。例如：  '
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see in the following figure, with the HTML output, all bullets again
    look identical.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，在 HTML 输出中，所有项目符号再次看起来相同。
- en: When generating documentation as LaTeX (and consecutively, PDF or Postscript),
    these can differ.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成 LaTeX（以及随后 PDF 或 Postscript）格式的文档时，这些可能会有所不同。
- en: 'Since web-based documentation is by far the most common output format for Sphinx,
    we default to that output instead. The rendered HTML output is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于 Web 的文档是目前 Sphinx 最常见的输出格式，我们默认使用该格式。渲染的 HTML 输出如下：
- en: '![Bulleted list](img/B15882_09_04.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![项目符号列表](img/B15882_09_04.png)'
- en: 'Figure 9.4: Bulleted lists with HTML output'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：带有 HTML 输出的项目符号列表
- en: As you can see, all bulleted lists are rendered the same in this case. This
    is dependent on the renderer, however, so it’s a good idea to check the output
    to see if it matches your preference.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这种情况下，所有项目符号列表都被渲染为相同。然而，这取决于渲染器，所以检查输出是否与您的偏好相符是个好主意。
- en: Option lists
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项列表
- en: 'The `option` list is one meant specifically for documenting the command-line
    arguments of a program. The only special thing about the syntax is that the comma
    space is recognized as a separator for options:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`选项` 列表是专门用于记录程序命令行参数的。关于语法的特殊之处在于，逗号空格被识别为选项的分隔符：'
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following is the output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出结果如下：
- en: '![Option list](img/B15882_09_05.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![选项列表](img/B15882_09_05.png)'
- en: 'Figure 9.5: Option list'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：选项列表
- en: 'In Markdown, there is no support for option lists, but you can achieve similar
    results by creating a table:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Markdown 中，没有对选项列表的支持，但你可以通过创建表格来实现类似的效果：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that in most Markdown implementations, the headers for a table are required.
    But the header alignment as is done here is optional, and the following would
    render the same:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在大多数 Markdown 实现中，表格的标题是必需的。但此处所进行的标题对齐是可选的，以下方式也能达到相同的效果：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Definition lists (reST only)
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义列表（仅限 reST）
- en: 'The definition list is a bit more obscure than the other types of lists, since
    the actual structure consists of whitespace only. It’s therefore pretty straightforward
    to use, but not always as easy to identify in a file, and it is only supported
    by reST:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表比其他类型的列表稍微难以理解，因为其实际结构仅由空白字符组成。因此，它的使用相当直接，但在文件中不一定容易识别，并且仅由 reST 支持：
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the output:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出结果如下：
- en: '![Definition list](img/B15882_09_06.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![定义列表](img/B15882_09_06.png)'
- en: 'Figure 9.6: Definitions list'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6：定义列表
- en: The definition list is especially useful when explaining the meaning of certain
    keywords in your documentation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 定义列表在解释文档中某些关键词的含义时特别有用。
- en: Nested lists
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套列表
- en: 'Nesting items is actually not limited to lists and can be done with multiple
    types of blocks, but the idea is the same. You could nest a code block within
    a bulleted list, for example. Just be careful to keep the indenting at the correct
    level. If you don’t, it either won’t be recognized as a separate level or you
    will get an error:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 项目嵌套实际上不仅限于列表，还可以使用多种类型的块来实现，但基本思想是相同的。例如，你可以在项目符号列表中嵌套代码块。只需确保缩进级别正确。如果不这样做，它可能不会被识别为单独的级别，或者你会得到一个错误：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following figure shows the output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了输出结果：
- en: '![Nested lists](img/B15882_09_07.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![嵌套列表](img/B15882_09_07.png)'
- en: 'Figure 9.7: Nested lists'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7：嵌套列表
- en: For Markdown, the same kind of nesting is possible, as long as the right list
    types are used.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Markdown，只要使用正确的列表类型，就可以实现类似的嵌套。
- en: Links, references, and labels
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接、引用和标签
- en: The links syntax is quite different between Markdown and reStructuredText, but
    they offer similar features. Both support inline links and links using a list
    of references.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown 和 reStructuredText 之间的链接语法相当不同，但它们提供了类似的功能。两者都支持内联链接和使用参考列表的链接。
- en: 'The simplest links with protocols such as [http://python.org](http://python.org)
    will automatically be recognized by most parsers for both Markdown and reStructuredText.
    For custom labels, the syntax is a bit different:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的带有协议（如 [http://python.org](http://python.org)）的链接将被大多数 Markdown 和 reStructuredText
    解析器自动识别。对于自定义标签，语法略有不同：
- en: 'reStructuredText: `''Python <http://python.org>''_`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'reStructuredText: `''Python <http://python.org>''_`'
- en: 'Markdown: `[Python](http://python.org)`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Markdown: `[Python](http://python.org)`'
- en: Both of these are nice for simple links that won’t be repeated too often, but
    generally, it’s more convenient to attach labels to links so they can be reused
    and don’t clog up the text too much.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法对于不会经常重复的简单链接来说都很不错，但通常，将标签附加到链接上会更方便，这样它们就可以被重复使用，而且不会使文本过于拥挤。
- en: 'For example, refer to the following reStructuredText example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，参考以下 reStructuredText 示例：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now compare it with the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在比较以下内容：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Links, references, and labels](img/B15882_09_08.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![链接、引用和标签](img/B15882_09_08.png)'
- en: 'Figure 9.8: Link with a custom label'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8：带有自定义标签的链接
- en: 'And the Markdown equivalents:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 Markdown 的等效形式：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Using labels, you can easily have a list of references at a designated location
    without making the actual text harder to read.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签，你可以在指定位置轻松地有一个引用列表，而不会使实际文本难以阅读。
- en: 'For reStructuredText, these labels can be used for more than external links,
    however. Similar to the `GOTO` statements found in older programming languages,
    you can create labels and refer to them from other parts of the documentation:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 reStructuredText，这些标签不仅可以用于外部链接。类似于在旧编程语言中找到的 `GOTO` 语句，你可以创建标签并在文档的其他部分引用它们：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Within HTML or PDF output, this can be used to create a clickable link from
    anywhere in the text using the underscore links. Creating a clickable link to
    the label is as simple as having `label_` in the text.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML 或 PDF 输出中，这可以用来在文本的任何位置创建一个可点击的链接，使用下划线链接。创建一个指向标签的可点击链接就像在文本中包含 `label_`
    那样简单。
- en: Note that reStructuredText ignores case differences, so both uppercase and lowercase
    links work just fine. Even though we’re not likely to make this mistake, having
    the same label in a single document with only case differences results in an error,
    to make sure that duplicates never occur.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，reStructuredText 忽略大小写差异，因此大小写链接都可以正常工作。即使我们不太可能犯这个错误，但在单个文档中只有大小写差异的相同标签会导致错误，以确保不会发生重复。
- en: 'The usage of references in conjunction with the headers works in a very natural
    way; you can just refer to them as you normally would and add an underscore to
    make it a link:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将引用与标题结合使用的方式非常自然；你可以像平常一样引用它们，并添加一个下划线来使其成为链接：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Links, references, and labels](img/B15882_09_09.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![链接、引用和标签](img/B15882_09_09.png)'
- en: 'Figure 9.9: Links, labels, and references'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：链接、标签和引用
- en: For Markdown, you can partially get similar results depending on the renderer
    that is used. In the case of the GitHub parser, all headers are automatically
    converted to HTML anchors, so a header like `# Some header` can be linked to by
    using `[name of the link](#some-header)`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Markdown，根据所使用的渲染器，你可以部分地获得类似的结果。在 GitHub 解析器的情况下，所有标题都会自动转换为 HTML 锚点，因此一个像
    `# Some header` 这样的标题可以通过 `[链接名称](#some-header)` 来链接。
- en: 'While this method is convenient for simple cases, it comes with a number of
    drawbacks:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法对于简单情况来说很方便，但它带来了一些缺点：
- en: When the header changes, all links to it are broken
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当标题改变时，指向它的所有链接都会断开
- en: When multiple headers have the same name, only the first one can be linked to
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个标题具有相同的名称时，只有第一个可以被链接到
- en: Only headers can be linked to
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有标题可以被链接到
- en: Images
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图片
- en: Images is a feature that is implemented quite differently between reStructuredText
    and Markdown.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图片是 reStructuredText 和 Markdown 之间实现差异很大的一个功能。
- en: Images with reStructuredText
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: reStructuredText 中的图片
- en: 'In reStructuredText, the image directive looks very similar to the label syntax.
    They’re actually a bit different, but the pattern is quite similar. The image
    directive is just one of the many directives that are supported by reStructuredText.
    We will see more about that later on when we cover Sphinx and reStructuredText
    extensions. For the time being, it is enough to know that the directives start
    with two periods followed by a space, the name of the directive, and two colons:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在reStructuredText中，图片指令看起来与标签语法非常相似。它们实际上略有不同，但模式相当相似。图片指令只是reStructuredText支持的许多指令之一。我们将在介绍Sphinx和reStructuredText扩展时了解更多关于这一点。目前，只需知道指令以两个点和一个空格开始，后跟指令名称和两个冒号：
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the case of the image, the directive is called `image` of course:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片的情况下，指令被称为`image`当然：
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is the scaled output, as the actual image is much larger:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是缩放后的输出，因为实际图片要大得多：
- en: '![Images](img/B15882_09_10.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_09_10.png)'
- en: 'Figure 9.10: Image output with reStructuredText'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：使用reStructuredText的图片输出
- en: Note the double colon after the directives.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意指令后的双冒号。
- en: 'But how about specifying the size and other properties? The image directive
    has many other options (as do most other directives) that can be used: [https://docutils.sourceforge.io/docs/ref/rst/directives.html#images](https://docutils.sourceforge.io/docs/ref/rst/directives.html#images);
    they are mostly fairly obvious, however. To specify the width and height or the
    scale (in percent) of the image:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但如何指定大小和其他属性？图片指令有许多其他选项（大多数其他指令也是如此）可以用来：[https://docutils.sourceforge.io/docs/ref/rst/directives.html#images](https://docutils.sourceforge.io/docs/ref/rst/directives.html#images)；它们大多数相当明显。要指定图片的宽度和高度或缩放（以百分比表示）：
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following is the output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其输出：
- en: '![Images](img/B15882_09_11.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_09_11.png)'
- en: 'Figure 9.11: Scaled image with reStructuredText'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：使用reStructuredText缩放的图片
- en: The `scale` option uses the `width` and `height` options if available and falls
    back to the PIL (Python Imaging Library) or Pillow library to detect the image.
    If neither `width`/`height` nor PIL/Pillow are available, the `scale` option will
    be ignored silently.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale`选项如果可用，将使用`width`和`height`选项，并回退到PIL（Python Imaging Library）或Pillow库来检测图片。如果既没有`width`/`height`也没有PIL/Pillow可用，`scale`选项将被静默忽略。'
- en: 'In addition to the `image` directive, there is also the `figure` directive.
    The difference is that `figure` adds a caption to the image. Beyond that, the
    usage is the same as `image`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`image`指令外，还有一个`figure`指令。区别在于`figure`为图片添加了标题。除此之外，用法与`image`相同：
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Images](img/B15882_09_12.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_09_12.png)'
- en: 'Figure 9.12: Adding a figure caption with reStructuredText'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：使用reStructuredText添加图注
- en: Now, let’s compare what we’ve just seen with how to deal with images using Markdown.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们比较一下我们刚刚看到的与使用Markdown处理图片的方法。
- en: Images with Markdown
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Markdown中的图片
- en: 'The support for images in Markdown is similar to the support for links, but
    you need to add a `!` in front of it:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown对图片的支持与对链接的支持类似，但需要在前面添加一个`!`：
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As is the case with links, you can also use references:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就像链接一样，你也可以使用引用：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: However, changing other properties such as the size is not supported by most
    Markdown implementations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更改其他属性，如大小，大多数Markdown实现都不支持。
- en: Substitutions
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换
- en: When writing documentation, you will often have to use the same images and links
    over and over again. While you can add those inline, it is often very verbose,
    tedious, and hard to maintain.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写文档时，你经常会反复使用相同的图片和链接。虽然你可以直接添加它们，但这通常非常冗长、繁琐且难以维护。
- en: Within reStructuredText pages, we already have the internal labeling system
    that handles a lot of cases for us. For external links and images, however, we
    need to use one of the other reStructuredText features. With substitution definitions,
    you can shorten directives so they can easily be re-used. In the common Markdown
    implementations, there is no equivalent feature for this.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在reStructuredText页面内，我们已经有了一个内部标签系统，可以为我们处理很多情况。对于外部链接和图片，我们则需要使用reStructuredText的其他功能。通过替换定义，你可以缩短指令以便于重复使用。在常见的Markdown实现中，没有与此等效的功能。
- en: 'Let’s assume we have a logo that we use quite often within a bit of text. Instead
    of typing the entire `.. image:: <url>`, it would be very handy to have a shorthand
    to make it easier. That’s where the substitutions are very useful:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们有一个在文本中经常使用的标志。与其输入整个 `.. image:: <url>`，不如有一个简写来简化操作会非常方便。这正是替换非常有用的地方：'
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, you can use the pipe character to create and use substitutions
    anywhere in your text. As is usual in most languages, you can escape the character
    with a backslash (`\`) if you need to use a pipe outside of substitutions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以使用管道字符在文本的任何位置创建和使用替换。在大多数语言中，如果您需要在替换之外使用管道字符，可以使用反斜杠（`\`）来转义该字符。
- en: 'The output is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Substitutions](img/B15882_09_13.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![替换](img/B15882_09_13.png)'
- en: 'Figure 9.13: Rendered reStructuredText using a substitution for an image directive'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13：使用图像指令替换渲染的 reStructuredText
- en: 'These substitutions can be used with many directives, though they are particularly
    useful for outputting a variable in many places of a document. For example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这些替换可以与许多指令一起使用，尽管它们在文档的许多地方输出变量时特别有用。例如：
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is the output:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Substitutions](img/B15882_09_14.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![替换](img/B15882_09_14.png)'
- en: 'Figure 9.14: Rendered reStructuredText using a text substitution for an author’s
    name'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14：使用作者名称的文本替换渲染的 reStructuredText
- en: These types of substitutions are really useful while writing documentation because
    they make your reStructuredText files more readable, but they also allow you to
    change your entire documentation by updating a single variable. As opposed to
    a search/replace, which is generally an error-prone operation.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的替换在编写文档时非常有用，因为它们使您的 reStructuredText 文件更易于阅读，但它们还允许您通过更新单个变量来更改整个文档。与通常容易出错的搜索/替换操作相比。
- en: While writing this chapter, a substitution for `|rest|` to return `reStructuredText`
    would have been very useful.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本章时，如果有一个替换 `|rest|` 返回 `reStructuredText` 的方法将会非常有用。
- en: Blocks, code, math, comments, and quotes
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块、代码、数学、注释和引用
- en: When writing documentation, a common scenario is the need for blocks that contain
    different types of content, explanations with mathematical formulae, code examples,
    and more.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写文档时，一个常见的场景是需要包含不同类型内容的块，例如带有数学公式的解释、代码示例等。
- en: 'The usage of these directives is similar to the image directive. The following
    is an example of a code block:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的使用方式与图像指令类似。以下是一个代码块的示例：
- en: '[PRE51]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_15.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![块、代码、数学、注释和引用](img/B15882_09_15.png)'
- en: 'Figure 9.15: Code block output'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15：代码块输出
- en: 'This is one of the cases where Markdown is a bit simpler to use. With plain
    Markdown, a code block only requires indenting:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 Markdown 中使用起来相对简单的一个案例。使用纯 Markdown，代码块只需要缩进：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Or with the GitHub flavored Markdown with syntax highlighting:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用带有语法高亮的 GitHub 风格 Markdown：
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With reStructuredText you have more options, however. You can also display
    mathematical formulae using the LaTeX syntax. Here’s the fundamental theorem of
    calculus, for example:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 reStructuredText，您有更多选项。您还可以使用 LaTeX 语法显示数学公式。例如，这是微积分的基本定理：
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following is the output:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_16.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![块、代码、数学、注释和引用](img/B15882_09_16.png)'
- en: 'Figure 9.16: Mathematical formula output'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16：数学公式输出
- en: 'Commenting a bunch of text/commands is easily achieved by using the “empty”
    directive followed by an indent. Effectively, this means two dots, as is the case
    with any directive, but with the `directive::` bit omitted:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用“空”指令后跟缩进，可以轻松地注释大量文本/命令。实际上，这意味着任何指令中的两个点，但省略了 `directive::` 部分：
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_17.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![块、代码、数学、注释和引用](img/B15882_09_17.png)'
- en: 'Figure 9.17: Output (with hidden comments)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17：输出（带隐藏注释）
- en: 'With Markdown, you have no real method of adding comments, but you can use
    links as a hack around this limitation in a few limited cases:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Markdown，您没有真正的方法来添加注释，但在一些有限的案例中，您可以使用链接作为绕过这一限制的技巧：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: While this method works, it is still far from pretty, of course. Often, you
    are better off moving the contents to a separate scratch file, or removing the
    content instead of commenting it and using a version control system such as Git
    to retrieve the data if you need it later.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法是可行的，但当然还不够美观。通常，你最好将内容移动到单独的临时文件中，或者删除内容而不是注释它，并在需要时使用像 Git 这样的版本控制系统来检索数据。
- en: 'Quoting text is supported by both reStructuredText and Markdown, but the syntax
    conflicts. Within reStructuredText, you can create a block quote using indentation,
    which would result in code formatting in Markdown:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 引用文本在 reStructuredText 和 Markdown 中都受到支持，但语法冲突。在 reStructuredText 中，你可以通过缩进来创建一个块引用，这在
    Markdown 中会导致代码格式化：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The output is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_18.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![块、代码、数学、注释和引用](img/B15882_09_18.png)'
- en: 'Figure 9.18: Quoting text'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18：引用文本
- en: 'Within Markdown, the format is comparable to how text-based email clients generally
    quote replies:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Markdown 中，格式与基于文本的电子邮件客户端通常引用回复的方式相似：
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Conclusion
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: Both reStructuredText and Markdown are very useful languages for creating some
    documentation. A large portion of the syntax comes naturally when writing plain
    text notes. A full guide to all the intricacies of reST, however, could fill a
    separate book. The previous demonstrations should have given enough of an introduction
    to do at least 90 percent of the work you will need when documenting your projects.
    Beyond that, Sphinx will help a lot, as we will see in the next sections.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: reStructuredText 和 Markdown 都是创建文档非常有用的语言。大部分语法在编写纯文本笔记时自然出现。然而，关于 reST 所有复杂性的完整指南可能需要另一本书来解释。前面的演示应该已经提供了足够的介绍，足以完成你项目文档工作时至少
    90% 的工作。除此之外，Sphinx 将在接下来的章节中提供大量帮助。
- en: In general, I would suggest using reStructuredText for actual documentation
    because it has many more features than Markdown. However, Markdown is generally
    more convenient for the basic readme files on PyPI and GitHub, mainly because
    you can use the same readme file for both cases, and GitHub supports Markdown
    slightly better than reStructuredText.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我建议使用 reStructuredText 来编写实际的文档，因为它比 Markdown 具有更多的功能。然而，Markdown 通常更方便用于
    PyPI 和 GitHub 上的基本 README 文件，主要是因为你可以为这两种情况使用相同的 README 文件，而且 GitHub 对 Markdown
    的支持略好于 reStructuredText。
- en: The Sphinx documentation generator
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sphinx 文档生成器
- en: 'The Sphinx documentation generator was created in 2008 for the Python 2.6 release
    to replace the old LaTeX documentation for Python. It’s a generator that makes
    it almost trivial to generate documentation for programming projects, but even
    outside of the programming world, it can be easily used. Within programming projects,
    there is specific support for the following domains (programming languages):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 文档生成器是在 2008 年为 Python 2.6 版本创建的，用于替换 Python 的旧 LaTeX 文档。它是一个生成器，使得为编程项目生成文档变得几乎易如反掌，但即使在编程世界之外，它也可以轻松使用。在编程项目中，对以下领域（编程语言）有特定的支持：
- en: Python
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: C
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C
- en: C++
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C++
- en: JavaScript
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript
- en: reStructuredText
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reStructuredText
- en: Outside of these languages, there are extensions available for many other languages,
    such as CoffeeScript, MATLAB, PHP, Ruby Lisp, Go, and Scala. And if you’re simply
    looking for snippet code highlighting, the Pygments highlighter, which is used
    internally, supports over 120 languages and is easily extendible for new languages
    if needed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些语言之外，还有许多其他语言的扩展可用，例如 CoffeeScript、MATLAB、PHP、Ruby Lisp、Go 和 Scala。如果你只是寻找代码片段高亮显示，内部使用的
    Pygments 高亮器支持超过 120 种语言，并且如果需要，可以轻松扩展以支持新的语言。
- en: The most important advantage of Sphinx is that almost everything can be automatically
    generated from your source code. The result is that your documentation is always
    up to date.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 最重要的优势是几乎可以从你的源代码中自动生成几乎所有内容。结果是，你的文档总是最新的。
- en: Getting started with Sphinx
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Sphinx
- en: 'First of all, we have to make sure we install Sphinx. Even though the Python
    core documentation is written using Sphinx, it is still a separately maintained
    project and must be installed separately. Luckily, that’s easy enough using pip:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确保已经安装了 Sphinx。尽管 Python 的核心文档是用 Sphinx 编写的，但它仍然是一个独立维护的项目，必须单独安装。幸运的是，使用
    pip 来安装非常简单：
- en: '[PRE59]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After installing Sphinx, there are two ways of getting started with a project:
    the `sphinx-quickstart` script, and the `sphinx-apidoc` script.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Sphinx 后，有两种方式开始一个项目：`sphinx-quickstart` 脚本和 `sphinx-apidoc` 脚本。
- en: If you want to create and customize an entire Sphinx project, then I would recommend
    the `sphinx-quickstart` command, as it assists you in configuring a fully featured
    Sphinx project.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建和自定义整个 Sphinx 项目，那么我建议使用 `sphinx-quickstart` 命令，因为它可以帮助你配置一个功能齐全的 Sphinx
    项目。
- en: If you want to start quickly and generate some API documentation for an **existing**
    Python project, then `sphinx-apidoc` might be better suited since it takes a single
    command and no further input to create a project. After running it, you will have
    fully functioning documentation based on your Python source.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要快速开始并为现有的 Python 项目生成一些 API 文档，那么 `sphinx-apidoc` 可能更适合，因为它只需一个命令和没有进一步的输入就可以创建项目。运行后，你将拥有基于你的
    Python 源代码的完整功能文档。
- en: In the end, both are valid options for creating Sphinx projects, and personally
    I usually end up generating the initial configuration using `sphinx-quickstart` and
    call the `sphinx-apidoc` command every time I add a Python module to add the new
    module.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这两种方法都是创建 Sphinx 项目的有效选项，并且我个人通常使用 `sphinx-quickstart` 生成初始配置，每次添加 Python
    模块时都调用 `sphinx-apidoc` 命令来添加新模块。
- en: The `sphinx-apidoc` command does not overwrite any files by default, making
    it a safe operation to run repeatedly.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx-apidoc` 命令默认不会覆盖任何文件，这使得它可以安全地重复运行。'
- en: Using sphinx-quickstart
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 sphinx-quickstart
- en: The `sphinx-quickstart` script interactively asks you about the most important
    decisions in your Sphinx project. There is no need to worry about typos; the configuration
    is stored in a `conf.py` file and can be modified like a regular Python file.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx-quickstart` 脚本会交互式地询问你在 Sphinx 项目中最重要的决策。无需担心拼写错误；配置存储在 `conf.py` 文件中，可以像常规
    Python 文件一样进行修改。'
- en: 'Usage is easy enough. As a default, I would recommend creating the documentation
    in a separate `docs` directory, as is the convention for many projects. The output
    uses the following conventions:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法很简单。默认情况下，我建议在单独的 `docs` 目录中创建文档，这是许多项目的惯例。输出使用以下约定：
- en: Inline comments start with `#`
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联注释以 `#` 开头
- en: User input lines start with `>`
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户输入行以 `>` 开头
- en: Cropped output is indicated with `...` and all questions skipped in between
    use the default settings
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裁剪后的输出用 `...` 表示，并且所有跳过的中间问题都使用默认设置。
- en: 'Note the `docs` after the command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令后面的 `docs`：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should now populate your master file, `docs/index.rst`, and create other
    documentation source files. Use the Makefile to build the docs, like so:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该填充你的主文件 `docs/index.rst`，并创建其他文档源文件。使用 Makefile 来构建文档，如下所示：
- en: '[PRE61]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Where “`<builder>`" is one of the supported builders, for example, `html`,
    `latex`, or `linkcheck`. After running this, we should have a `docs` directory
    containing the Sphinx project. Let’s see what the command actually created for
    us:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 “`<builder>`" 是支持的构建器之一，例如，`html`、`latex` 或 `linkcheck`。运行此命令后，我们应该有一个包含
    Sphinx 项目的 `docs` 目录。让我们看看命令实际上为我们创建了什么：
- en: '[PRE62]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `_build`, `_static`, and `_templates` directories are initially empty and
    can be ignored for now. The `_build` directory is used to output the generated
    documentation, whereas the `_static` directory can be used to easily include custom
    CSS files and such. The `_templates` directory makes it possible to style the
    HTML output to your liking as well. Examples of these can be found in the Sphinx
    Git repository at [https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes](https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`_build`、`_static` 和 `_templates` 目录最初是空的，现在可以忽略。`_build` 目录用于输出生成的文档，而 `_static`
    目录可以用来轻松包含自定义 CSS 文件等。`_templates` 目录使得可以按你的喜好样式化 HTML 输出。这些示例可以在 Sphinx Git 仓库中找到，网址为
    [https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes](https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes)。'
- en: '`Makefile` and `make.bat` can be used to generate the documentation output. `Makefile` can
    be used for any operating system that supports the make utility, and `make.bat` is
    there to support Windows systems out of the box. Now let’s look at the `index.rst` source:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile` 和 `make.bat` 可以用来生成文档输出。`Makefile` 可以用于支持 make 工具的任何操作系统，而 `make.bat`
    则是为了直接支持 Windows 系统。现在让我们看看 `index.rst` 源文件：'
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We see the document title as expected, followed by `toctree` (table of contents
    tree; more about that later in this chapter), and the links to the indices and search. `toctree` automatically
    generates a tree out of the headers of all available documentation pages.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到预期的文档标题，然后是`toctree`（目录树；本章后面将详细介绍），以及索引和搜索的链接。`toctree`会自动从所有可用的文档页面的标题生成一个树状结构。
- en: The indices and tables are automatically generated Sphinx pages, which are very
    useful, but nothing we need to worry about in terms of settings.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和表格是自动生成的Sphinx页面，非常有用，但在设置方面我们无需担心。
- en: 'Now it’s time to generate the `HTML` output:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候生成`HTML`输出了：
- en: '[PRE64]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `make html` command generates the documentation for you and the result
    is placed in `_build/html/`. Just open `index.html` in your browser to see the
    results. You should now have something looking similar to the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`make html`命令为您生成文档，结果放置在`_build/html/`中。只需在浏览器中打开`index.html`即可查看结果。现在您应该看到以下类似的内容：'
- en: '![](img/B15882_09_19.png)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_09_19.png)'
- en: 'Figure 9.19: Viewing index.html'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：查看index.html
- en: With just that single command and by answering a few questions, we now have
    a documentation project with an index, search, and table of contents on all the
    pages.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 只需执行这个单一命令并回答几个问题，我们现在就有一个包含索引、搜索和目录的文档项目了。
- en: 'In addition to the HTML output, there are quite a few other formats supported
    by default, although some require external libraries to actually work:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 除了HTML输出外，还有许多默认支持的格式，尽管其中一些需要外部库才能实际工作：
- en: '[PRE65]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Using sphinx-apidoc
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sphinx-apidoc
- en: The `sphinx-apidoc` command is generally used together with `sphinx-quickstart`.
    It is possible to generate an entire project with the `--full` parameter, but
    it’s generally a better idea to generate the entire project using `sphinx-quickstart` and
    simply add the API documentation using `sphinx-apidoc`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`sphinx-apidoc`命令与`sphinx-quickstart`一起使用。可以使用`--full`参数生成整个项目，但通常更好的做法是使用`sphinx-quickstart`生成整个项目，然后简单地通过`sphinx-apidoc`添加API文档。
- en: To properly demonstrate the `sphinx-apidoc` command, we need some Python files,
    so we’ll create two files within a project called `apidoc_example`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确演示`sphinx-apidoc`命令，我们需要一些Python文件，因此我们将在一个名为`apidoc_example`的项目中创建两个文件。
- en: 'The first one is `apidoc_example/a.py`, containing a class called `A` with
    some methods:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`apidoc_example/a.py`，包含一个名为`A`的类和一些方法：
- en: '[PRE66]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, we have `apidoc_example/b.py` containing a `B` class that inherits `A`:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个包含继承自`A`类的`B`类的`apidoc_example/b.py`文件：
- en: '[PRE67]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now that we have our source files, it’s time to generate the actual API documentation:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了源文件，是时候生成实际的API文档了：
- en: '[PRE68]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This alone is not enough to include the API in the documentation. It needs
    to be added to `toctree`. Luckily, that’s as simple as adding modules to `toctree` in
    the `index.rst` file to look something like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不够，我们需要将API添加到`toctree`中。幸运的是，这就像在`index.rst`文件中将模块添加到`toctree`中一样简单，看起来如下所示：
- en: '[PRE69]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `toctree` directive is discussed in further detail later in this chapter.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分将更详细地讨论`toctree`指令。
- en: 'We also have to make sure that the modules can be imported, otherwise Sphinx
    won’t be able to read the Python files. To do that, we simply add the parent directory
    (as seen from the `docs` directory) to `sys.path`; this can be put anywhere in
    the `conf.py` file:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保模块可以被导入，否则Sphinx将无法读取Python文件。为了做到这一点，我们只需将父目录（从`docs`目录的视角看）添加到`sys.path`；这可以在`conf.py`文件的任何地方进行：
- en: '[PRE70]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Additionally, the `autodoc` module needs to be enabled in `conf.py`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，需要在`conf.py`中启用`autodoc`模块：
- en: '[PRE71]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now it’s time to generate the documentation again by using the `html` builder:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候再次使用`html`构建器生成文档了：
- en: '[PRE72]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Open the `docs/_build/index.html` file again. For the sake of brevity, the
    repeated parts of the document will be omitted from the screenshots. The cropped
    output is as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开`docs/_build/index.html`文件。为了简洁起见，文档的重复部分将从截图中被省略。裁剪后的输出如下：
- en: '![](img/B15882_09_20.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B15882_09_20.png)'
- en: 'Figure 9.20: Viewing the Contents'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：查看内容
- en: But it actually generated quite a bit more. When running the `sphinx-apidoc` command,
    it looks at all the Python modules in the specified directory recursively and
    generates an `rst` file for each of them. After generating all those files, it
    adds all of them to a file called `modules.rst`, which makes it easy to add them
    to your documentation.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上它生成了更多内容。当运行 `sphinx-apidoc` 命令时，它会递归地查看指定目录中的所有 Python 模块，并为每个模块生成一个 `rst`
    文件。在生成所有这些文件之后，它会将它们全部添加到一个名为 `modules.rst` 的文件中，这使得将它们添加到你的文档中变得很容易。
- en: 'The `modules.rst` file is really straight to the point; nothing more than a
    list of modules with the package name as the title:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules.rst` 文件非常直接明了；仅仅是一个以包名为标题的模块列表：'
- en: '[PRE73]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `apidoc_example` page output is as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`apidoc_example` 页面的输出如下：'
- en: '![](img/B15882_09_21.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_09_21.png)'
- en: 'Figure 9.21: The apidoc_example page'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.21：apidoc_example 页面
- en: 'The `apidoc_example.rst` file simply lists all the documented modules in `automodule`
    directives with a few settings:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`apidoc_example.rst` 文件简单地列出了所有在 `automodule` 指令中记录的模块，以及一些设置：'
- en: '[PRE74]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'But as you have seen in the previous screenshot, it does not include hidden
    or magic methods. By adding some extra arguments to the `automodule` directive,
    we can change this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你在之前的截图中所见，它不包括隐藏或魔法方法。通过向 `automodule` 指令添加一些额外的参数，我们可以改变这一点：
- en: '[PRE75]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'With these extra settings (`private-members`, `special-members`, and `inherited-members`),
    we get a lot of extra and arguably useful documentation:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些额外的设置（`private-members`、`special-members` 和 `inherited-members`），我们得到了很多额外且可能有用的文档：
- en: '![](img/B15882_09_22.png)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_09_22.png)'
- en: 'Figure 9.22: The updated apidoc_example page'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.22：更新后的 apidoc_example 页面
- en: Which of these settings are useful for you depends on your use case, of course.
    But it shows how easily we can generate full documentation for classes with barely
    any effort. And all references such as the bases and the overridden methods are
    clickable as well.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设置中有哪些对你有用取决于你的用例，当然。但它展示了我们如何轻松地为类生成完整的文档，几乎不需要任何努力。而且所有如基类和重写方法这样的引用都可以点击访问。
- en: New files won’t be added to your docs automatically. It is safe to rerun the `sphinx-apidoc` command
    to add the new files, but it won’t update your existing files. Even though the `--force` option
    can be used to force overwriting the files, within existing files I recommend
    manually editing them instead. As we will see in the next sections, there are
    quite a few reasons to manually modify the generated files afterward.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件不会自动添加到你的文档中。重新运行 `sphinx-apidoc` 命令可以添加新文件，但它不会更新现有的文件。尽管可以使用 `--force`
    选项强制覆盖文件，但我建议在现有文件中手动编辑它们。正如我们将在下一节中看到的，在生成文件之后手动修改它们有相当多的原因。
- en: Sphinx directives
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sphinx 指令
- en: Sphinx adds a few directives on top of the default ones in reStructuredText
    and an easy API to add new directives yourself. Most of them are generally not
    that relevant to modify but, as one would expect, Sphinx has pretty good documentation
    in case you need to know more about them.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 在 reStructuredText 的默认指令之上添加了一些指令，并提供了一个简单的 API 来添加新的指令。其中大部分通常并不需要修改，但正如预期的那样，Sphinx
    有相当好的文档，如果你需要了解更多关于它们的信息。
- en: 'We have already seen the labels, images, math, substitutions, code, and comment
    reST directives. But there are also quite a few Sphinx-specific directives. Most
    of them are not too important to talk about, but perhaps interesting to take a
    look at: [https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html](https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html).'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了标签、图像、数学、替换、代码和注释 reST 指令。但也有一些是 Sphinx 特有的指令。其中大部分并不是特别重要，但也许值得一看：[https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html](https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html)。
- en: 'We’ve already covered the most important one of all, the `autodoc` module,
    which is used by the `automodule` directive. There is another one that requires
    a tiny bit of coverage, however: the `toctree` directive. We have already seen
    it in use earlier, but it has a few interesting configuration options that are
    really useful for larger projects.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了最重要的一个，即 `autodoc` 模块，它是 `automodule` 指令所使用的。然而，还有一个需要稍微覆盖一下：`toctree`
    指令。我们之前已经看到过它的使用，但它有几个非常有趣的配置选项，对于大型项目来说非常有用。
- en: 'The `toctree` directive is one of the most important directives in Sphinx;
    it generates the table of contents tree. The `toctree` directive has a couple
    of options, but the most important one is probably `maxdepth`, which specifies
    how deep the tree needs to go. The top level of `toctree` has to be specified
    manually by specifying the files to be read, but beyond that, every level within
    a document (section, chapter, paragraph, and so on) can be another level in `toctree`,
    depending on the depth, of course. Even though the `maxdepth` option is optional,
    without it all the available levels will be shown, which is usually more than
    required. In most cases, a `maxdepth` of 2 is a good default value, which makes
    the basic example look like this:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`toctree` 指令是 Sphinx 中最重要的指令之一；它生成目录树。`toctree` 指令有几个选项，但最重要的可能是 `maxdepth`，它指定树需要深入到多深。`toctree`
    的顶层需要手动指定要读取的文件，但超出这个范围，文档中的每个级别（章节、段落等）都可以是 `toctree` 的另一个级别，当然这取决于深度。尽管 `maxdepth`
    选项是可选的，但没有它，所有可用的级别都会显示出来，这通常比所需的要多。在大多数情况下，`maxdepth` 的 2 是一个很好的默认值，这使得基本示例看起来像这样：'
- en: '[PRE76]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The items in `toctree` are the `.rst` files in the same directory without the
    extension. This can include subdirectories, in which case the directories are
    separated with a `.` (period):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`toctree` 中的项目是同一目录下的 `.rst` 文件，不包括扩展名。这可以包括子目录，在这种情况下，目录之间用 `.`（点）分隔：'
- en: '[PRE77]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Another very useful option is the `glob` option. It tells `toctree` to use
    the `glob` module in Python to automatically add all the documents matching a
    pattern. By simply adding a directory with a `glob` pattern, you can add all the
    files in that directory. This makes the `toctree` we had before as simple as:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的选项是 `glob` 选项。它告诉 `toctree` 使用 Python 中的 `glob` 模块自动添加所有匹配模式的文档。只需添加一个带有
    `glob` 模式的目录，你就可以添加该目录中的所有文件。这使得之前的 `toctree` 变得非常简单：
- en: '[PRE78]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If, for some reason, the document title is not as you would have liked, you
    can easily change the title to something customized:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，文档标题不是你期望的样子，你可以轻松地将标题更改为自定义的标题：
- en: '[PRE79]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Sphinx roles
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sphinx 作用域
- en: 'We have seen Sphinx directives, which are separate blocks. Now we will discuss
    Sphinx roles, which can be used inline. A role allows you to tell Sphinx how to
    parse some input. Examples of these roles are links, math, code, and markup. But
    the most important ones are the roles within the Sphinx domains for referencing
    other classes, even for external projects. Within Sphinx, the default domain is
    the Python one, so a role such as `:py:meth:` can be used as `:meth:` as well.
    These roles are really useful to link to different packages, modules, classes,
    methods, and other objects. The basic usage is simple enough. To link to a class,
    use the following:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Sphinx 指令，它们是独立的块。现在我们将讨论 Sphinx 作用域，它们可以内联使用。一个作用域允许你告诉 Sphinx 如何解析某些输入。这些作用域的例子包括链接、数学、代码和标记。但最重要的是，Sphinx
    作用域中的角色可以用于引用其他类，甚至外部项目。在 Sphinx 中，默认的作用域是 Python，所以像 `:py:meth:` 这样的角色也可以用作 `:meth:`。这些作用域对于链接到不同的包、模块、类、方法和其他对象非常有用。基本用法很简单。要链接到一个类，使用以下格式：
- en: '[PRE80]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Sphinx roles](img/B15882_09_23.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![Sphinx 作用域](img/B15882_09_23.png)'
- en: 'Figure 9.23: Linking to a class'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.23：链接到类
- en: The same goes for just about any other object, functions, exceptions, attributes,
    and so on. The Sphinx documentation offers a list of supported objects: [https://www.sphinx-doc.org/domains.html#cross-referencing-python-objects](https://www.sphinx-doc.org/domains.html#cross-referencing-python-objects).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎任何其他对象，函数、异常、属性等也是如此。Sphinx 文档提供了一个支持的对象列表：[https://www.sphinx-doc.org/domains.html#cross-referencing-python-objects](https://www.sphinx-doc.org/domains.html#cross-referencing-python-objects)。
- en: One of the nicer features of Sphinx is that these references can extend beyond
    your project. Similar to how we added a link to the class above, adding a reference
    to the `int` object in the standard Python documentation is easily possible using `:obj:'int'`.
    Adding references to your own projects in other documentation sets and on other
    websites is done in a similar fashion.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 的一个很好的特性是这些引用可以超出你的项目范围。类似于我们如何在上文中添加到类的链接，使用 `:obj:'int'` 可以轻松地添加到标准
    Python 文档中的 `int` 对象的引用。在其他的文档集和网站上添加你自己的项目的引用也是以类似的方式进行的。
- en: 'For inter-project links, you will need to enable the `intersphinx` module in
    `conf.py`:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 对于跨项目链接，你需要在 `conf.py` 中启用 `intersphinx` 模块：
- en: '[PRE81]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'After that, we need to tell `intersphinx` where it can find the documentation
    of the other projects by adding `intersphinx_mapping` to `conf.py`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要通过在`conf.py`中添加`intersphinx_mapping`来告诉`intersphinx`它可以在哪里找到其他项目的文档：
- en: '[PRE82]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now we can easily link to the documentation on the Sphinx home page:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地链接到斯芬克斯主页上的文档：
- en: '[PRE83]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The following is the output:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其输出：
- en: '![Sphinx roles](img/B15882_09_24.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![Sphinx roles](img/B15882_09_24.png)'
- en: 'Figure 9.24: Linking to another project'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：链接到另一个项目
- en: This links to [https://www.sphinx-doc.org/en/master/ext/intersphinx.html](https://www.sphinx-doc.org/en/master/ext/intersphinx.html).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这链接到[https://www.sphinx-doc.org/en/master/ext/intersphinx.html](https://www.sphinx-doc.org/en/master/ext/intersphinx.html)。
- en: Now that we know how to use Sphinx to generate documentation from our code,
    let’s enhance that documentation to be even more useful.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何使用Sphinx从我们的代码中生成文档，让我们增强这些文档，使其更加有用。
- en: Documenting code
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录代码
- en: 'There are currently three different documentation styles supported by Sphinx:
    the original Sphinx style and the more recent NumPy and Google styles. The differences
    between them are mainly in style, but it’s actually slightly more than that.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Sphinx支持三种不同的文档风格：原始的斯芬克斯风格、较新的NumPy和谷歌风格。它们之间的主要区别在于风格，但实际上还略有不同。
- en: 'The Sphinx style was developed using a bunch of reStructuredText roles, a very
    effective method, but it can be detrimental for readability when used a lot. You
    can probably tell what the following does, but it’s not the nicest syntax:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 斯芬克斯风格是通过使用一系列的reStructuredText角色开发的，这是一种非常有效的方法，但过度使用时可能会损害可读性。你可能能猜到以下代码的作用，但这并不是最优雅的语法：
- en: '[PRE84]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The Google style was (as the name suggests) developed by Google. The goal was
    to have a simple/readable format that works both as in-code documentation and
    is parseable for Sphinx. In my opinion, it comes closer to the original idea of
    reStructuredText, a format that’s very close to how you would document instinctively.
    This example has the same meaning as the Sphinx style example shown earlier:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其名称，谷歌风格是由谷歌开发的。目标是拥有一个简单/可读的格式，它既适用于代码文档，也适用于Sphinx的可解析性。在我看来，它更接近reStructuredText的原始理念，这是一种非常接近你本能地如何进行文档化的格式。以下示例与前面展示的斯芬克斯风格示例具有相同的意义：
- en: '[PRE85]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The NumPy style was created specifically for the NumPy project. The NumPy project
    has many functions, with a huge amount of documentation, and generally a lot of
    documentation per argument. It is slightly more verbose than the Google format,
    but quite easy to read as well:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy风格是专门为NumPy项目创建的。NumPy项目有许多函数，拥有大量的文档，并且通常每个参数都有很多文档。它比谷歌格式稍微冗长一些，但也很容易阅读：
- en: '[PRE86]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'With the type hint annotations introduced in Python 3.5, at least the argument
    type part of these syntaxes has become less useful. Since Sphinx 3.0 you can tell
    Sphinx to use the type hints instead of manually adding the type by adding this
    line to your Sphinx `conf.py`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Python 3.5中引入的类型提示注解，至少这些语法的参数类型部分已经变得不那么有用。从Sphinx 3.0开始，你可以通过在Sphinx `conf.py`中添加以下行来告诉Sphinx使用类型提示而不是手动添加类型：
- en: '[PRE87]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Documenting a class with the Sphinx style
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用斯芬克斯风格记录类
- en: 'First of all, let’s look at the traditional style, the Sphinx style. While
    it’s easy to understand what all the parameters mean, it’s a bit verbose, which
    reduces the readability somewhat. Nonetheless, the meaning is immediately clear
    and it is definitely not a bad style to use:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看传统的风格，即斯芬克斯风格。虽然理解所有参数的含义很容易，但它有点冗长，这多少降低了可读性。尽管如此，其含义立即清晰，并且绝对不是一种不好的使用风格：
- en: '[PRE88]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output looks like this:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '![](img/B15882_09_25.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15882_09_25.png)'
- en: 'Figure 9.25: The Sphinx style documentation'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：斯芬克斯风格文档
- en: This is a very useful output indeed, with documented functions, classes, and arguments.
    And, more importantly, the types are documented as well, resulting in a clickable
    link to the actual type. An added advantage of specifying the type is that many
    editors understand the documentation and will provide autocompletion based on
    the given types.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个非常有用的输出，其中记录了函数、类和参数。更重要的是，类型也得到了记录，从而生成了一个可点击的链接到实际类型。指定类型的额外优势是，许多编辑器理解这些文档，并将根据给定的类型提供自动完成功能。
- en: 'You might have also noticed that we specified the variable types both as documentation
    and using type hinting. While this is technically not needed, they apply to different
    parts of the documentation. The types shown in the function itself are done through
    type hinting: `eggs(number: int, cooked: bool) -> 13_sphinx_style.Eggs`. The `Parameters`
    and `Return type` are specified through the `:type` in the documentation.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能也注意到，我们既在文档中又通过类型提示指定了变量类型。虽然技术上不是必需的，但它们应用于文档的不同部分。函数本身显示的类型是通过类型提示完成的：`eggs(number:
    int, cooked: bool) -> 13_sphinx_style.Eggs`。`Parameters`和`Return type`是通过文档中的`:type`指定的。'
- en: To explain what’s actually happening here, Sphinx has a few roles within the
    docstrings that offer hints as to what we are documenting.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这里实际发生的事情，Sphinx在docstrings中有几个角色，它们提供了关于我们正在记录的内容的提示。
- en: The `param` role paired with a name sets the documentation for the parameter
    with that name. The `type` role paired with a name tells Sphinx the data type
    of the parameter. Both the roles are optional and the parameter simply won’t have
    any added documentation if they are omitted, but the `param` role is always required
    for any documentation to show. Simply adding the `type` role without the `param` role
    will result in no output whatsoever, so take note to always pair them.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 与名称配对的`param`角色设置了具有该名称的参数的文档。与名称配对的`type`角色告诉Sphinx参数的数据类型。这两个角色都是可选的，如果省略它们，参数将没有任何附加的文档，但`param`角色对于任何文档的显示总是必需的。仅添加`type`角色而不添加`param`角色将不会产生任何输出，所以请注意始终将它们配对。
- en: The `returns` role is similar to the `param` role with regards to documenting.
    While the `param` role documents a parameter, the `returns` role documents the
    returned object. They are slightly different, however. As opposed to the `param` role,
    the `returns` role is not dependent on the `rtype` role, or vice versa. They both
    work independently of each other, making it possible to use either or both of
    the roles.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`returns`角色在文档方面与`param`角色类似。虽然`param`角色记录了一个参数，但`returns`角色记录了返回的对象。然而，它们略有不同。与`param`角色不同，`returns`角色不依赖于`rtype`角色，反之亦然。它们两者都是独立工作的，这使得可以使用其中一个或两个角色。'
- en: The `rtype`, as you can expect, tells Sphinx (and several editors) what type of
    object is returned from the function. With the introduction of type hinting, however,
    the `rtype` role is pretty useless since you have an easier way of specifying
    the return type.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所期望的，`rtype`告诉Sphinx（以及几个编辑器）函数返回的对象类型。然而，随着类型提示的引入，`rtype`角色几乎变得毫无用处，因为你有一个更容易指定返回类型的方法。
- en: Documenting a class with the Google style
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Google风格记录一个类
- en: 'The Google style is just a more legible version of the Sphinx style documentation.
    It doesn’t actually support more or less, but it’s a lot more intuitive to use.
    Here’s the Google style version of the `Spam` class:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: Google风格只是Sphinx风格文档的一个更易读的版本。它实际上并不支持更多或更少，但它使用起来非常直观。以下是`Spam`类的Google风格版本：
- en: '[PRE89]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is easier on the eyes than the Sphinx style and has the same number of possibilities.
    For longer argument documentation, it’s less than convenient though. Just imagine
    how a multiline description of `number` would look. That is why the NumPy style
    was developed, providing a lot of documentation for its arguments.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 与Sphinx风格相比，这种风格对眼睛更友好，并且具有相同数量的可能性。对于较长的参数文档，这不太方便。想象一下`number`的多行描述会是什么样子。这就是为什么开发了NumPy风格，为它的参数提供了大量的文档。
- en: Documenting a class with the NumPy style
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NumPy风格记录一个类
- en: 'The NumPy style is meant for having a lot of documentation. Honestly, most people
    are too lazy for that, so for most projects it would not be a good fit. If you
    do plan to have extensive documentation of your functions and all their parameters,
    the NumPy style might be a good option for you. It’s a bit more verbose than the
    Google style, but it’s very legible, especially with more detailed documentation.
    The following is the NumPy version of the `Spam` class:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy风格旨在拥有大量的文档。说实话，大多数人太懒惰了，所以对于大多数项目来说，它可能不是一个好的选择。如果你计划对你的函数及其所有参数进行广泛的文档记录，NumPy风格可能是一个不错的选择。它比Google风格更冗长，但可读性非常好，尤其是在更详细的文档中。以下是`Spam`类的NumPy版本：
- en: '[PRE90]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: While the NumPy style definitely isn’t bad, it’s just very verbose. This example
    alone is about 1.5 times as long as the alternatives. So, for longer and more
    detailed documentation it’s a very good choice, but if you’re planning to have
    short documentation anyhow, just use the Google style instead.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 NumPy 风格绝对不是不好的，但它确实非常冗长。仅这个例子就比替代方案长1.5倍。因此，对于更长和更详细的文档来说，这是一个非常好的选择，但如果你的计划是无论如何都要有简短的文档，那么就使用
    Google 风格吧。
- en: Which style to choose
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择哪种风格
- en: For most projects, the Google style is the best choice since it is readable
    but not too verbose. If you are planning to use large amounts of documentation
    per parameter, then the NumPy style might be a good option as well.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目来说，Google 风格是最好的选择，因为它既易读又不过于冗长。如果您计划为每个参数使用大量的文档，那么 NumPy 风格也可能是一个不错的选择。
- en: The only reason for choosing the Sphinx style is legacy. Even though the Google
    style might be more legible, consistency is more important.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 Sphinx 风格的唯一原因就是历史遗留问题。尽管 Google 风格可能更易读，但一致性更为重要。
- en: Exercises
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: To practice a little with Python type hinting, it would be good to add some
    of this documentation to your own projects.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微练习一下 Python 类型提示，将一些此类文档添加到自己的项目中会很好。
- en: 'Some examples of less trivial type hints would be:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 一些不太平凡的类型提示示例包括：
- en: Dictionaries
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: Nested or even recursive types
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套或甚至是递归的类型
- en: Generating stubs for documenting external projects that don’t have type hinting
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为没有类型提示的外部项目生成存根以进行文档化
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_9.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在 GitHub 上找到：[https://github.com/mastering-python/exercises](Chapter_9.xhtml)。鼓励您提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned how to add, use, and test type hinting in
    your code using both the built-in types and your own custom types. You learned
    how to write Markdown and reStructuredText to document your projects and your
    code itself. Lastly, you learned how to use the Sphinx documentation generator
    to generate fully functioning documentation for your projects.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用内置类型和您自己的自定义类型在代码中添加、使用和测试类型提示。您学习了如何编写 Markdown 和 reStructuredText
    来文档化您的项目和代码本身。最后，您学习了如何使用 Sphinx 文档生成器为您的项目生成完整的文档。
- en: Documentation can help greatly in a project’s popularity, and bad documentation
    can kill productivity. I think there are few aspects of a library that have more
    impact on the usage by third parties than documentation. Thus, in many cases,
    documentation is a more important factor in deciding the usage of a project than
    the actual code quality. That’s why it is very important to always try to have
    good documentation available. Sphinx is a great help in this case because it makes
    it much easier to keep your documentation up to date and matching your code. The
    only thing worse than no documentation is incorrect and/or out-of-date documentation.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以极大地帮助项目的普及，而糟糕的文档会扼杀生产力。我认为在库中，没有哪个方面比文档对第三方使用的影响更大。因此，在许多情况下，文档在决定项目使用方面比实际代码质量更为重要。这就是为什么始终尝试保持良好的文档非常重要。在这种情况下，Sphinx
    是一个巨大的帮助，因为它使得保持文档与代码同步并更新变得容易得多。没有文档比不正确和/或过时的文档更糟糕。
- en: With Sphinx, it is easy to generate documentation. With just a few minutes of
    your time, you can have a fully functioning website with documentation available,
    or a PDF, or ePub, or one of the many other output formats. There really is no
    excuse for having no documentation anymore. And even if you don’t use the documentation
    that much yourself, offering type hints to your editor can help a lot with productivity
    as well. Making your editor smarter should always help with productivity. I, for
    one, have added type hints to several external projects simply to increase my
    productivity.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Sphinx，生成文档非常容易。只需几分钟的时间，您就可以拥有一个带有文档的完整功能网站，或者是一个 PDF、ePub，或者许多其他输出格式之一。现在没有文档真的没有借口了。即使您自己不太使用文档，向您的编辑器提供类型提示也可以大大提高生产力。使您的编辑器更智能始终有助于提高生产力。例如，我添加了类型提示到几个外部项目，仅仅是为了提高我的生产力。
- en: The next chapter will explain how code can be tested in Python and some part
    of the documentation will return there. Using `doctest`, it is possible to have
    example code, documentation, and tests in one.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释如何在 Python 中测试代码，文档的某些部分将返回那里。使用 `doctest`，可以将示例代码、文档和测试合并在一起。
- en: Join our community on Discord
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code156081100001293319171.png)'
