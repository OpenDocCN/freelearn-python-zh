- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation – How to Use Sphinx and reStructuredText
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documenting code can be both fun and useful! I will admit that many programmers
    have a strong dislike for documenting code and understandably so. Writing documentation
    can be a boring job and, traditionally, only others reap the benefits of that
    effort. The tools available for Python, however, make it almost trivial to generate
    useful and up-to-date documentation with little to no effort at all. Generating
    documentation has actually become so easy that I often create and generate documentation
    before using a Python package. Assuming it wasn’t available already, that is.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to simple text documentation explaining what a function does, it
    is also possible to add metadata, such as type hints. These type hints can be
    used to make the arguments and return types of a function or class clickable in
    the documentation. But more importantly, many modern IDEs and editors, such as
    VIM, have plugins available that parse the type hints and use them for intelligent
    autocompletion. So if you type `'some_string.'`, your editor will automatically
    complete the specific attributes and methods of a string object, something that
    is traditionally only viable with statically typed languages such as Java, C,
    and C++.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain the types of documentation available in Python and
    how easily a full set of documentation can be created. With the amazing tools
    that Python provides, you can have fully functioning documentation within minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reStructuredText syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Markdown syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up documentation using Sphinx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sphinx-, Google-, and NumPy-style docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Python 3.5, we’ve had a feature called type hinting, which is arguably
    one of the most useful additions to Python 3\. It allows you to specify the types
    of variables and return values, which means your editor will be able to give you
    smart autocompletion. This makes it useful for all Python programmers, regardless
    of level, and can make your life much easier when paired with a good editor.
  prefs: []
  type: TYPE_NORMAL
- en: Basic example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most editors are already smart enough to recognize basic types in regular variables
    such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It becomes a lot harder for an editor when, instead of `a = 123`, we have something
    like `a = some_function()`. In some cases, the return type of a function is obvious
    (i.e. `return True`), but if the return type depends on the input variables or
    is not consistent, it becomes much harder for the editor to understand what is
    happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Zen of Python tells us, explicit is better than implicit. In the case
    of function return types, this is often the case and can be implemented with very
    little effort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That works as expected. With a simple `-> type`, you can specify the function
    return type, which is automatically reflected in the `__annotations__`, which
    is also visible in the `help()`. And the arguments (and variables) can be type-specified
    using `name: type`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you may notice that even though we specified the function to return
    an `int`, it can actually return a `float` as well, since Python only has type
    hints, not type constraints/enforcements.
  prefs: []
  type: TYPE_NORMAL
- en: 'While basic types such as `int`, `float`, `str`, `dict`, `list`, and `set`
    can be specified with `variable: int` alone, for more advanced types, we need
    the `typing` module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Python 3.9, you can use `variable: list[int]`. For older versions of
    Python, you need to use `variable: typing.List[int]` for all collection types
    such as `dict`/`list`/`set` that require the getitem (`[]`) operator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `typing` module contains types such as `typing.Any` to allow everything,
    `typing.Optional` to allow for `None`, and `typing.Union` to specify multiple
    allowed types, which we will now demonstrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With `typing.Union`, we can specify a list of types that apply. Similarly, an
    optional type can be specified using `typing.Optional[int]` to indicate that the
    type can be either `int` or `None`, effectively being equivalent to `typing.Union[int,
    None]`. Additionally, since Python 3.10 we can write this as `int` `|` `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since regular Python objects are their own type, you usually don’t even have
    to think about what type they are. Simply specify the object and it will work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But what would happen with circular definitions or other circumstances where
    you do not have the type available yet? In that case, you can work around the
    issue by specifying the type as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever possible, I would recommend against this method because it gives you
    no guarantee that the type can actually be resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, this will only check whether the type actually exists. For proper
    type checking, we can use tools such as `mypy`, which will be covered in the next
    section. To make sure that your type checker can resolve the type, you can encase
    your imports in an `if typing.TYPE_CHECKING` block like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `typing.TYPE_CHECKING` constant is not normally set, but can be set by type
    checkers such as `mypy` to make sure all types are working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the examples above, we have seen custom classes as custom types, but what
    if we want to create a custom type out of an existing built-in type? That is also
    possible using `typing.NewType`, which creates a new type that behaves like the
    base type, but can be checked by static type checkers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we created a type called `Username`, which is treated as a subclass of
    `str` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, you don’t want to statically specify the type of a function,
    but make it depend on the input instead. For this reason, the Python type system
    supports generics. If you’re familiar with Java, C++, or C#, you might be familiar
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: Generics allow you to create a generic type whose only constraint is that it
    is the same in all cases. This means that if you specify a generic type as both
    the input and the output for a function, it will be assumed to be the same; if
    you input an `int` into a function, you will receive an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to specify a generic type and, after that, we can specify it
    as parameters for our functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we created a generic type with the constraint that it needs to
    be either `int` or `str`. When the type checker runs, it will check if `a`, `b`,
    and the `return` value have the same type. This means that even though an `int`
    is valid for type `T`, if you make `a` a `str`, `b` and the output have to be
    `str` as well.
  prefs: []
  type: TYPE_NORMAL
- en: Type checking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how to specify and create type hints, it’s time to run a type
    checker. The reference implementation for type checking is the `mypy` tool. It
    can thoroughly check your code and warn about potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install `mypy` – luckily, that’s easy enough with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will use `mypy` to check some of the earlier examples with a few errors
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we hinted `base` to be an `int`, `2.5` is not a valid value since it
    is a `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now an example with a custom type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we specified that `print_username()` should receive a `Username` type.
    Even though `Username` inherits `str`, it is not considered valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will create a generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `to_string()` received an `int`, it should return an `int`, which is
    not the case. Let’s run `mypy` to see what’s wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While writing code, `mypy` can save you a lot of debugging by warning you about
    incorrect type usage.
  prefs: []
  type: TYPE_NORMAL
- en: Python type interface files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python type hint files (`.pyi`), also called stub files, are files that allow
    you to specify all type hints for a file without touching the original file. This
    is useful for libraries that you do not have write access to, or if you do not
    want to clutter your files with type hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'The files use the regular Python syntax, but the functions are not meant to
    contain anything beyond stubs that only hint the types. An example stub for the
    `print_username()` function mentioned above could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The files are nothing special, but they can be especially useful when interacting
    with libraries that lack type hinting. If your regular file is named `test.py`,
    the `pyi` file would be named `test.pyi`.
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within this section, you have seen a few very basic examples of how type hinting
    can be applied and how the types can be checked. The Python `typing` module is
    still getting enhanced quite a lot and `mypy` has really extensive documentation
    that can be useful if you are applying this to your own code. Make sure to look
    at the documentation if you have any specific issues; it is high quality and very
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to using type hinting in your own projects, my suggestion is to
    use it wherever it enhances your workflow but not to go overboard. In many cases,
    your editor will be smart enough to figure out the arguments automatically, or
    it won’t really matter too much. But when passing along more advanced classes
    where you tend to forget the methods available for that class, it becomes a really
    useful feature. Having smart autocompletion can really save you a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have type hints covered, it is time to continue with documenting
    our code and the markup languages available for that task.
  prefs: []
  type: TYPE_NORMAL
- en: reStructuredText and Markdown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **reStructuredText** format (also known as **RST**, **ReST**, or **reST**)
    was developed in 2002 as a language that implements enough markup to be usable,
    but is simple enough to be readable as plain text. These two features make it
    readable enough to use in code, yet still versatile enough to generate pretty
    and useful documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The Markdown format is really similar to reStructuredText and largely comparable.
    While reStructuredText is slightly older (2012) than Markdown (2014), the Markdown
    format has gained a bit more popularity because it’s a bit simpler and less Python-focused.
    Both standards are excellent for writing text that is legible straightaway and
    can easily be converted to other formats such as HTML or PDF files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantages of reST are:'
  prefs: []
  type: TYPE_NORMAL
- en: A very extensive feature set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A strictly defined standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy extensibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main advantages of Markdown are:'
  prefs: []
  type: TYPE_NORMAL
- en: It is less Python-centric, which caused it to gain more widespread adoption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more forgiving and less strict parser, which makes it easier to write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The greatest thing about both reStructuredText and Markdown is that they are
    very intuitive to write and natively supported by most (social) coding platforms
    such as GitHub, GitLab, BitBucket, and PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: Even without knowing anything about the standard, you can easily write documentation
    in this style. However, more advanced techniques, such as images and links, do
    require some explanation.
  prefs: []
  type: TYPE_NORMAL
- en: For Python documentation itself, reStructuredText is the most convenient standard
    since it’s well supported by tools such as Sphinx and docutils. For readme files
    on sites such as GitHub and the Python Package Index, the Markdown standard is
    generally better supported.
  prefs: []
  type: TYPE_NORMAL
- en: To easily convert between formats such as reStructuredText and Markdown, use
    the Pandoc tool, available at [https://pandoc.org/](https://pandoc.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax reads just like text and the next few paragraphs will show
    some of the more advanced features. However, let us start with a simple example
    demonstrating how simple a reStructuredText or Markdown file can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s how easy it is to convert the text of this chapter so far to reStructuredText
    or Markdown. The example above works in both. But for the Markdown file to look
    similar, we need to modify the headers slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following paragraphs will cover the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline markup (italic, bold, code, and links)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advanced links
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Substitutions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blocks containing code, math, and others
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting started with reStructuredText
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly convert a reStructuredText file to HTML, we can use the `docutils` library.
    The `sphinx` library discussed later in this chapter actually uses the `docutils` library
    internally, but has some extra features that we won’t need initially. To get started,
    we just need to install `docutils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can easily convert reStructuredText into PDF, LaTeX, HTML, and
    other formats. For the examples in this paragraph, we’ll use the HTML format,
    which is easily generated using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The reStructuredText language has two basic components:'
  prefs: []
  type: TYPE_NORMAL
- en: Roles that allow for **inline** modifications of the output, such as `:code:`,
    `:math:`, `:emphasis:`, and `:literal:`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Directives that generate markup **blocks**, such as code samples with multiple
    lines. These look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within pure reStructuredText, the directives are the most important, but we
    will see many uses for the roles in the section on *Sphinx roles* later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Markdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To quickly convert a Markdown file to HTML we have many options available.
    But, because we are using Python, we will use the `markdown` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can convert our file to HTML with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that this converter only supports plain Markdown, not the
    GitHub flavored Markdown, which also supports code syntax highlighting.
  prefs: []
  type: TYPE_NORMAL
- en: The `grip` (GitHub Readme Instant Preview) Python package supports live rendering
    of GitHub flavored Markdown by using the GitHub servers and can be useful while
    writing Markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Inline markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Inline markup** is the markup that is used within a regular line of text.
    Examples of these are emphasis, inline code examples, links, images, and bullet
    lists.'
  prefs: []
  type: TYPE_NORMAL
- en: Within reStructuredText, these are implemented through roles, but often have
    useful shorthands. Instead of `:emphasis:'text'`, you can also use `*text*`.
  prefs: []
  type: TYPE_NORMAL
- en: Emphasis, for example, can be added by encapsulating the words between one or
    two asterisk signs. This sentence, for example, could add a little bit of `*emphasis*` by
    adding a single asterisk on both sides, or a lot of `**emphasis**` by adding two
    asterisks on both sides. There are many different inline markup directives so
    we will list only the most common ones. A full list can always be found through
    the reStructuredText home page at [https://docutils.sourceforge.io/docs/](https://docutils.sourceforge.io/docs/)
    and the Markdown home page at [https://daringfireball.net/projects/markdown/syntax](https://daringfireball.net/projects/markdown/syntax),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples that work for both reST and Markdown:'
  prefs: []
  type: TYPE_NORMAL
- en: Emphasis (italic) text: `*emphasis for this phrase*`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra emphasis (bold) text: `**extra emphasis for this phrase**`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For lists without numbers, a simple dash with a space after it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- item 1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- item 2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The space after the dash is required for reStructuredText to recognize the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For lists with numbers, the number followed by a period and a space:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1\. item 1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2\. item 2`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For numbered lists, the period after the number is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interpreted text: These are domain-specific. Within Python documentation, the
    default role is code, which means that surrounding text with backticks will convert
    your code to use code tags, for example, `''if spam and eggs:''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inline literals: This is formatted with a monospace font, which makes it ideal
    for inline code. Just add two backticks to `''''add some code''''`. For Markdown,
    there is no noticeable difference between single and double backticks in output,
    but it can be used to escape single backticks: `''''some code '' with backticks''''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Escaping in reST can be done using a \, similar to escaping in Python: `''''some
    code \'' with backticks''''`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For reStructuredText, there are a few extra options using roles, similar to
    the interpreted text role we saw earlier. These roles can be set through role
    prefixes or suffixes depending on your preference; for example, `:math:'E=mc^2'` to
    show mathematical equations.
  prefs: []
  type: TYPE_NORMAL
- en: References can be added through a trailing underscore. They can point to headers,
    links, labels, and more. The next section will cover more about these, but the
    basic syntax is simply `reference_`, or enclosed in backticks when the reference
    contains spaces – `'some reference link'_`.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more available, but these are the ones you will use the most
    when writing reStructuredText.
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The headers are used to indicate the start of a document, section, chapter,
    or paragraph. It is therefore the first structure you need in a document. While not
    strictly needed, its usage is highly recommended as it serves several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: The headers are consistently formatted according to their level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A table of contents (TOC) tree can be generated from the headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All headers automatically function as labels, which means you can create links
    to them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The format required to make headers overlaps a little between reST and Markdown,
    but for clarity, we will cover them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Headers with reStructuredText
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When creating headers, consistency is one of the few constraints; the number
    of characters used is fairly arbitrary, as is the number of levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Personally, I default to a simple system with a fixed-size header, but I recommend
    at least following the default of the Python documentation in terms of the parts,
    chapters, sections, subsections, subsubsections, and paragraphs, something along
    the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Headers](img/B15882_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: Headers with reStructuredText'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is just the common usage of the headers, but the main idea of reStructuredText
    is that you can use just about anything that feels natural to you, which means
    that you can use any of the following characters: `= - '' : '' " ~ ^ _ * + # <>`.
    It also supports both underlines and overlines, so if you prefer that, they are
    options as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'While I try to keep the number of characters fixed to 78 characters as `PEP8`
    (*Chapter 3*, *Pythonic Syntax and Common Pitfalls*) recommends for Python, the
    number of characters used is mostly arbitrary, but it does have to be at least
    as long as the text of the header. This allows it to accept the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But not this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Headers with Markdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With Markdown, you have several options for headers depending on what you feel
    like. Similar to reST, you can use the `=` and `–` characters to underline, but
    only those, and the length and blank lines after them do not matter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want more levels, you can use up to 6 levels by using the `#` prefix
    and optional suffixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: Headers in Markdown'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Markdown is slightly less flexible than reStructuredText when
    it comes to headers, but in most cases, it offers enough features to be perfectly
    usable.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reStructuredText format has several styles of lists:'
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bulleted
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Options
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Definitions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The simplest forms of lists were already displayed in the introduction section,
    but it’s actually possible to use many different characters, such as letters,
    Roman numerals, and others, for enumeration. After demonstrating the basic list
    types, we will continue with the nesting of lists and structures, which makes
    them even more powerful. Care must be taken with the amount of whitespace, as
    one space too many can cause a structure to be recognized as regular text instead
    of a structure.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerated lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Enumerated lists are convenient for all sorts of enumerations. The basic premise
    for enumerated lists is an alphanumeric character followed by a period, a right
    parenthesis, or parentheses on both sides. Additionally, the `#` character functions
    as an automatic enumeration. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The output is perhaps a bit simpler than you would expect. The reason is that
    it depends on the output format. The following figure shows the rendered HTML
    output, which has no support for parentheses. If you output LaTeX, for example,
    the difference can be made visible.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enumerated list](img/B15882_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: Enumerated lists generated with the HTML output format'
  prefs: []
  type: TYPE_NORMAL
- en: 'Markdown also supports enumerated lists, but it is a bit more limited in its
    options. It only supports regular numbered lists. It’s more convenient in how
    it supports them though; there is no need for explicit numbering, and repeating
    `1.` works without a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Bulleted lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the order of the list is not relevant and you simply need a list of items
    without enumeration, then the bulleted list is what you should use. To create
    a simple list using bullets only, the bulleted items need to start with a `*`, `+`, `-`, `•`, ‣,
    or ⁃. This list is mostly arbitrary and can be modified by extending Sphinx or
    Docutils. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the following figure, with the HTML output, all bullets again
    look identical.
  prefs: []
  type: TYPE_NORMAL
- en: When generating documentation as LaTeX (and consecutively, PDF or Postscript),
    these can differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since web-based documentation is by far the most common output format for Sphinx,
    we default to that output instead. The rendered HTML output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bulleted list](img/B15882_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: Bulleted lists with HTML output'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all bulleted lists are rendered the same in this case. This
    is dependent on the renderer, however, so it’s a good idea to check the output
    to see if it matches your preference.
  prefs: []
  type: TYPE_NORMAL
- en: Option lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `option` list is one meant specifically for documenting the command-line
    arguments of a program. The only special thing about the syntax is that the comma
    space is recognized as a separator for options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Option list](img/B15882_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: Option list'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Markdown, there is no support for option lists, but you can achieve similar
    results by creating a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in most Markdown implementations, the headers for a table are required.
    But the header alignment as is done here is optional, and the following would
    render the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Definition lists (reST only)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The definition list is a bit more obscure than the other types of lists, since
    the actual structure consists of whitespace only. It’s therefore pretty straightforward
    to use, but not always as easy to identify in a file, and it is only supported
    by reST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Definition list](img/B15882_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: Definitions list'
  prefs: []
  type: TYPE_NORMAL
- en: The definition list is especially useful when explaining the meaning of certain
    keywords in your documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Nested lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Nesting items is actually not limited to lists and can be done with multiple
    types of blocks, but the idea is the same. You could nest a code block within
    a bulleted list, for example. Just be careful to keep the indenting at the correct
    level. If you don’t, it either won’t be recognized as a separate level or you
    will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested lists](img/B15882_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: Nested lists'
  prefs: []
  type: TYPE_NORMAL
- en: For Markdown, the same kind of nesting is possible, as long as the right list
    types are used.
  prefs: []
  type: TYPE_NORMAL
- en: Links, references, and labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The links syntax is quite different between Markdown and reStructuredText, but
    they offer similar features. Both support inline links and links using a list
    of references.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest links with protocols such as [http://python.org](http://python.org)
    will automatically be recognized by most parsers for both Markdown and reStructuredText.
    For custom labels, the syntax is a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: 'reStructuredText: `''Python <http://python.org>''_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Markdown: `[Python](http://python.org)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these are nice for simple links that won’t be repeated too often, but
    generally, it’s more convenient to attach labels to links so they can be reused
    and don’t clog up the text too much.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, refer to the following reStructuredText example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now compare it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Links, references, and labels](img/B15882_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: Link with a custom label'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the Markdown equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using labels, you can easily have a list of references at a designated location
    without making the actual text harder to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reStructuredText, these labels can be used for more than external links,
    however. Similar to the `GOTO` statements found in older programming languages,
    you can create labels and refer to them from other parts of the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Within HTML or PDF output, this can be used to create a clickable link from
    anywhere in the text using the underscore links. Creating a clickable link to
    the label is as simple as having `label_` in the text.
  prefs: []
  type: TYPE_NORMAL
- en: Note that reStructuredText ignores case differences, so both uppercase and lowercase
    links work just fine. Even though we’re not likely to make this mistake, having
    the same label in a single document with only case differences results in an error,
    to make sure that duplicates never occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of references in conjunction with the headers works in a very natural
    way; you can just refer to them as you normally would and add an underscore to
    make it a link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Links, references, and labels](img/B15882_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: Links, labels, and references'
  prefs: []
  type: TYPE_NORMAL
- en: For Markdown, you can partially get similar results depending on the renderer
    that is used. In the case of the GitHub parser, all headers are automatically
    converted to HTML anchors, so a header like `# Some header` can be linked to by
    using `[name of the link](#some-header)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this method is convenient for simple cases, it comes with a number of
    drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: When the header changes, all links to it are broken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When multiple headers have the same name, only the first one can be linked to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only headers can be linked to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images is a feature that is implemented quite differently between reStructuredText
    and Markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Images with reStructuredText
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In reStructuredText, the image directive looks very similar to the label syntax.
    They’re actually a bit different, but the pattern is quite similar. The image
    directive is just one of the many directives that are supported by reStructuredText.
    We will see more about that later on when we cover Sphinx and reStructuredText
    extensions. For the time being, it is enough to know that the directives start
    with two periods followed by a space, the name of the directive, and two colons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of the image, the directive is called `image` of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the scaled output, as the actual image is much larger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/B15882_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: Image output with reStructuredText'
  prefs: []
  type: TYPE_NORMAL
- en: Note the double colon after the directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how about specifying the size and other properties? The image directive
    has many other options (as do most other directives) that can be used: [https://docutils.sourceforge.io/docs/ref/rst/directives.html#images](https://docutils.sourceforge.io/docs/ref/rst/directives.html#images);
    they are mostly fairly obvious, however. To specify the width and height or the
    scale (in percent) of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/B15882_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: Scaled image with reStructuredText'
  prefs: []
  type: TYPE_NORMAL
- en: The `scale` option uses the `width` and `height` options if available and falls
    back to the PIL (Python Imaging Library) or Pillow library to detect the image.
    If neither `width`/`height` nor PIL/Pillow are available, the `scale` option will
    be ignored silently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `image` directive, there is also the `figure` directive.
    The difference is that `figure` adds a caption to the image. Beyond that, the
    usage is the same as `image`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](img/B15882_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: Adding a figure caption with reStructuredText'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s compare what we’ve just seen with how to deal with images using Markdown.
  prefs: []
  type: TYPE_NORMAL
- en: Images with Markdown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The support for images in Markdown is similar to the support for links, but
    you need to add a `!` in front of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case with links, you can also use references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: However, changing other properties such as the size is not supported by most
    Markdown implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Substitutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing documentation, you will often have to use the same images and links
    over and over again. While you can add those inline, it is often very verbose,
    tedious, and hard to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Within reStructuredText pages, we already have the internal labeling system
    that handles a lot of cases for us. For external links and images, however, we
    need to use one of the other reStructuredText features. With substitution definitions,
    you can shorten directives so they can easily be re-used. In the common Markdown
    implementations, there is no equivalent feature for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have a logo that we use quite often within a bit of text. Instead
    of typing the entire `.. image:: <url>`, it would be very handy to have a shorthand
    to make it easier. That’s where the substitutions are very useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can use the pipe character to create and use substitutions
    anywhere in your text. As is usual in most languages, you can escape the character
    with a backslash (`\`) if you need to use a pipe outside of substitutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/B15882_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Rendered reStructuredText using a substitution for an image directive'
  prefs: []
  type: TYPE_NORMAL
- en: 'These substitutions can be used with many directives, though they are particularly
    useful for outputting a variable in many places of a document. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Substitutions](img/B15882_09_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Rendered reStructuredText using a text substitution for an author’s
    name'
  prefs: []
  type: TYPE_NORMAL
- en: These types of substitutions are really useful while writing documentation because
    they make your reStructuredText files more readable, but they also allow you to
    change your entire documentation by updating a single variable. As opposed to
    a search/replace, which is generally an error-prone operation.
  prefs: []
  type: TYPE_NORMAL
- en: While writing this chapter, a substitution for `|rest|` to return `reStructuredText`
    would have been very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks, code, math, comments, and quotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing documentation, a common scenario is the need for blocks that contain
    different types of content, explanations with mathematical formulae, code examples,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of these directives is similar to the image directive. The following
    is an example of a code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: Code block output'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the cases where Markdown is a bit simpler to use. With plain
    Markdown, a code block only requires indenting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Or with the GitHub flavored Markdown with syntax highlighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With reStructuredText you have more options, however. You can also display
    mathematical formulae using the LaTeX syntax. Here’s the fundamental theorem of
    calculus, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Mathematical formula output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Commenting a bunch of text/commands is easily achieved by using the “empty”
    directive followed by an indent. Effectively, this means two dots, as is the case
    with any directive, but with the `directive::` bit omitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: Output (with hidden comments)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With Markdown, you have no real method of adding comments, but you can use
    links as a hack around this limitation in a few limited cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: While this method works, it is still far from pretty, of course. Often, you
    are better off moving the contents to a separate scratch file, or removing the
    content instead of commenting it and using a version control system such as Git
    to retrieve the data if you need it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quoting text is supported by both reStructuredText and Markdown, but the syntax
    conflicts. Within reStructuredText, you can create a block quote using indentation,
    which would result in code formatting in Markdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Blocks, code, math, comments, and quotes](img/B15882_09_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.18: Quoting text'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within Markdown, the format is comparable to how text-based email clients generally
    quote replies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both reStructuredText and Markdown are very useful languages for creating some
    documentation. A large portion of the syntax comes naturally when writing plain
    text notes. A full guide to all the intricacies of reST, however, could fill a
    separate book. The previous demonstrations should have given enough of an introduction
    to do at least 90 percent of the work you will need when documenting your projects.
    Beyond that, Sphinx will help a lot, as we will see in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: In general, I would suggest using reStructuredText for actual documentation
    because it has many more features than Markdown. However, Markdown is generally
    more convenient for the basic readme files on PyPI and GitHub, mainly because
    you can use the same readme file for both cases, and GitHub supports Markdown
    slightly better than reStructuredText.
  prefs: []
  type: TYPE_NORMAL
- en: The Sphinx documentation generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Sphinx documentation generator was created in 2008 for the Python 2.6 release
    to replace the old LaTeX documentation for Python. It’s a generator that makes
    it almost trivial to generate documentation for programming projects, but even
    outside of the programming world, it can be easily used. Within programming projects,
    there is specific support for the following domains (programming languages):'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reStructuredText
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outside of these languages, there are extensions available for many other languages,
    such as CoffeeScript, MATLAB, PHP, Ruby Lisp, Go, and Scala. And if you’re simply
    looking for snippet code highlighting, the Pygments highlighter, which is used
    internally, supports over 120 languages and is easily extendible for new languages
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The most important advantage of Sphinx is that almost everything can be automatically
    generated from your source code. The result is that your documentation is always
    up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Sphinx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we have to make sure we install Sphinx. Even though the Python
    core documentation is written using Sphinx, it is still a separately maintained
    project and must be installed separately. Luckily, that’s easy enough using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing Sphinx, there are two ways of getting started with a project:
    the `sphinx-quickstart` script, and the `sphinx-apidoc` script.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create and customize an entire Sphinx project, then I would recommend
    the `sphinx-quickstart` command, as it assists you in configuring a fully featured
    Sphinx project.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to start quickly and generate some API documentation for an **existing**
    Python project, then `sphinx-apidoc` might be better suited since it takes a single
    command and no further input to create a project. After running it, you will have
    fully functioning documentation based on your Python source.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, both are valid options for creating Sphinx projects, and personally
    I usually end up generating the initial configuration using `sphinx-quickstart` and
    call the `sphinx-apidoc` command every time I add a Python module to add the new
    module.
  prefs: []
  type: TYPE_NORMAL
- en: The `sphinx-apidoc` command does not overwrite any files by default, making
    it a safe operation to run repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: Using sphinx-quickstart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sphinx-quickstart` script interactively asks you about the most important
    decisions in your Sphinx project. There is no need to worry about typos; the configuration
    is stored in a `conf.py` file and can be modified like a regular Python file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage is easy enough. As a default, I would recommend creating the documentation
    in a separate `docs` directory, as is the convention for many projects. The output
    uses the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: Inline comments start with `#`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User input lines start with `>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cropped output is indicated with `...` and all questions skipped in between
    use the default settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note the `docs` after the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now populate your master file, `docs/index.rst`, and create other
    documentation source files. Use the Makefile to build the docs, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Where “`<builder>`" is one of the supported builders, for example, `html`,
    `latex`, or `linkcheck`. After running this, we should have a `docs` directory
    containing the Sphinx project. Let’s see what the command actually created for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `_build`, `_static`, and `_templates` directories are initially empty and
    can be ignored for now. The `_build` directory is used to output the generated
    documentation, whereas the `_static` directory can be used to easily include custom
    CSS files and such. The `_templates` directory makes it possible to style the
    HTML output to your liking as well. Examples of these can be found in the Sphinx
    Git repository at [https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes](https://www.sphinx-doc.org/en/master/usage/theming.html#builtin-themes).
  prefs: []
  type: TYPE_NORMAL
- en: '`Makefile` and `make.bat` can be used to generate the documentation output. `Makefile` can
    be used for any operating system that supports the make utility, and `make.bat` is
    there to support Windows systems out of the box. Now let’s look at the `index.rst` source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We see the document title as expected, followed by `toctree` (table of contents
    tree; more about that later in this chapter), and the links to the indices and search. `toctree` automatically
    generates a tree out of the headers of all available documentation pages.
  prefs: []
  type: TYPE_NORMAL
- en: The indices and tables are automatically generated Sphinx pages, which are very
    useful, but nothing we need to worry about in terms of settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to generate the `HTML` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make html` command generates the documentation for you and the result
    is placed in `_build/html/`. Just open `index.html` in your browser to see the
    results. You should now have something looking similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_09_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.19: Viewing index.html'
  prefs: []
  type: TYPE_NORMAL
- en: With just that single command and by answering a few questions, we now have
    a documentation project with an index, search, and table of contents on all the
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the HTML output, there are quite a few other formats supported
    by default, although some require external libraries to actually work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Using sphinx-apidoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sphinx-apidoc` command is generally used together with `sphinx-quickstart`.
    It is possible to generate an entire project with the `--full` parameter, but
    it’s generally a better idea to generate the entire project using `sphinx-quickstart` and
    simply add the API documentation using `sphinx-apidoc`.
  prefs: []
  type: TYPE_NORMAL
- en: To properly demonstrate the `sphinx-apidoc` command, we need some Python files,
    so we’ll create two files within a project called `apidoc_example`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is `apidoc_example/a.py`, containing a class called `A` with
    some methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have `apidoc_example/b.py` containing a `B` class that inherits `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our source files, it’s time to generate the actual API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This alone is not enough to include the API in the documentation. It needs
    to be added to `toctree`. Luckily, that’s as simple as adding modules to `toctree` in
    the `index.rst` file to look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `toctree` directive is discussed in further detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have to make sure that the modules can be imported, otherwise Sphinx
    won’t be able to read the Python files. To do that, we simply add the parent directory
    (as seen from the `docs` directory) to `sys.path`; this can be put anywhere in
    the `conf.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, the `autodoc` module needs to be enabled in `conf.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it’s time to generate the documentation again by using the `html` builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `docs/_build/index.html` file again. For the sake of brevity, the
    repeated parts of the document will be omitted from the screenshots. The cropped
    output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_09_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.20: Viewing the Contents'
  prefs: []
  type: TYPE_NORMAL
- en: But it actually generated quite a bit more. When running the `sphinx-apidoc` command,
    it looks at all the Python modules in the specified directory recursively and
    generates an `rst` file for each of them. After generating all those files, it
    adds all of them to a file called `modules.rst`, which makes it easy to add them
    to your documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `modules.rst` file is really straight to the point; nothing more than a
    list of modules with the package name as the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apidoc_example` page output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_09_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.21: The apidoc_example page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `apidoc_example.rst` file simply lists all the documented modules in `automodule`
    directives with a few settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'But as you have seen in the previous screenshot, it does not include hidden
    or magic methods. By adding some extra arguments to the `automodule` directive,
    we can change this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'With these extra settings (`private-members`, `special-members`, and `inherited-members`),
    we get a lot of extra and arguably useful documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_09_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.22: The updated apidoc_example page'
  prefs: []
  type: TYPE_NORMAL
- en: Which of these settings are useful for you depends on your use case, of course.
    But it shows how easily we can generate full documentation for classes with barely
    any effort. And all references such as the bases and the overridden methods are
    clickable as well.
  prefs: []
  type: TYPE_NORMAL
- en: New files won’t be added to your docs automatically. It is safe to rerun the `sphinx-apidoc` command
    to add the new files, but it won’t update your existing files. Even though the `--force` option
    can be used to force overwriting the files, within existing files I recommend
    manually editing them instead. As we will see in the next sections, there are
    quite a few reasons to manually modify the generated files afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sphinx adds a few directives on top of the default ones in reStructuredText
    and an easy API to add new directives yourself. Most of them are generally not
    that relevant to modify but, as one would expect, Sphinx has pretty good documentation
    in case you need to know more about them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen the labels, images, math, substitutions, code, and comment
    reST directives. But there are also quite a few Sphinx-specific directives. Most
    of them are not too important to talk about, but perhaps interesting to take a
    look at: [https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html](https://www.sphinx-doc.org/en/master/usage/restructuredtext/directives.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already covered the most important one of all, the `autodoc` module,
    which is used by the `automodule` directive. There is another one that requires
    a tiny bit of coverage, however: the `toctree` directive. We have already seen
    it in use earlier, but it has a few interesting configuration options that are
    really useful for larger projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toctree` directive is one of the most important directives in Sphinx;
    it generates the table of contents tree. The `toctree` directive has a couple
    of options, but the most important one is probably `maxdepth`, which specifies
    how deep the tree needs to go. The top level of `toctree` has to be specified
    manually by specifying the files to be read, but beyond that, every level within
    a document (section, chapter, paragraph, and so on) can be another level in `toctree`,
    depending on the depth, of course. Even though the `maxdepth` option is optional,
    without it all the available levels will be shown, which is usually more than
    required. In most cases, a `maxdepth` of 2 is a good default value, which makes
    the basic example look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The items in `toctree` are the `.rst` files in the same directory without the
    extension. This can include subdirectories, in which case the directories are
    separated with a `.` (period):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very useful option is the `glob` option. It tells `toctree` to use
    the `glob` module in Python to automatically add all the documents matching a
    pattern. By simply adding a directory with a `glob` pattern, you can add all the
    files in that directory. This makes the `toctree` we had before as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If, for some reason, the document title is not as you would have liked, you
    can easily change the title to something customized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Sphinx roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen Sphinx directives, which are separate blocks. Now we will discuss
    Sphinx roles, which can be used inline. A role allows you to tell Sphinx how to
    parse some input. Examples of these roles are links, math, code, and markup. But
    the most important ones are the roles within the Sphinx domains for referencing
    other classes, even for external projects. Within Sphinx, the default domain is
    the Python one, so a role such as `:py:meth:` can be used as `:meth:` as well.
    These roles are really useful to link to different packages, modules, classes,
    methods, and other objects. The basic usage is simple enough. To link to a class,
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sphinx roles](img/B15882_09_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.23: Linking to a class'
  prefs: []
  type: TYPE_NORMAL
- en: The same goes for just about any other object, functions, exceptions, attributes,
    and so on. The Sphinx documentation offers a list of supported objects: [https://www.sphinx-doc.org/domains.html#cross-referencing-python-objects](https://www.sphinx-doc.org/domains.html#cross-referencing-python-objects).
  prefs: []
  type: TYPE_NORMAL
- en: One of the nicer features of Sphinx is that these references can extend beyond
    your project. Similar to how we added a link to the class above, adding a reference
    to the `int` object in the standard Python documentation is easily possible using `:obj:'int'`.
    Adding references to your own projects in other documentation sets and on other
    websites is done in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'For inter-project links, you will need to enable the `intersphinx` module in
    `conf.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to tell `intersphinx` where it can find the documentation
    of the other projects by adding `intersphinx_mapping` to `conf.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can easily link to the documentation on the Sphinx home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sphinx roles](img/B15882_09_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.24: Linking to another project'
  prefs: []
  type: TYPE_NORMAL
- en: This links to [https://www.sphinx-doc.org/en/master/ext/intersphinx.html](https://www.sphinx-doc.org/en/master/ext/intersphinx.html).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to use Sphinx to generate documentation from our code,
    let’s enhance that documentation to be even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are currently three different documentation styles supported by Sphinx:
    the original Sphinx style and the more recent NumPy and Google styles. The differences
    between them are mainly in style, but it’s actually slightly more than that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sphinx style was developed using a bunch of reStructuredText roles, a very
    effective method, but it can be detrimental for readability when used a lot. You
    can probably tell what the following does, but it’s not the nicest syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The Google style was (as the name suggests) developed by Google. The goal was
    to have a simple/readable format that works both as in-code documentation and
    is parseable for Sphinx. In my opinion, it comes closer to the original idea of
    reStructuredText, a format that’s very close to how you would document instinctively.
    This example has the same meaning as the Sphinx style example shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The NumPy style was created specifically for the NumPy project. The NumPy project
    has many functions, with a huge amount of documentation, and generally a lot of
    documentation per argument. It is slightly more verbose than the Google format,
    but quite easy to read as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'With the type hint annotations introduced in Python 3.5, at least the argument
    type part of these syntaxes has become less useful. Since Sphinx 3.0 you can tell
    Sphinx to use the type hints instead of manually adding the type by adding this
    line to your Sphinx `conf.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Documenting a class with the Sphinx style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, let’s look at the traditional style, the Sphinx style. While
    it’s easy to understand what all the parameters mean, it’s a bit verbose, which
    reduces the readability somewhat. Nonetheless, the meaning is immediately clear
    and it is definitely not a bad style to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15882_09_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.25: The Sphinx style documentation'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very useful output indeed, with documented functions, classes, and arguments.
    And, more importantly, the types are documented as well, resulting in a clickable
    link to the actual type. An added advantage of specifying the type is that many
    editors understand the documentation and will provide autocompletion based on
    the given types.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have also noticed that we specified the variable types both as documentation
    and using type hinting. While this is technically not needed, they apply to different
    parts of the documentation. The types shown in the function itself are done through
    type hinting: `eggs(number: int, cooked: bool) -> 13_sphinx_style.Eggs`. The `Parameters`
    and `Return type` are specified through the `:type` in the documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: To explain what’s actually happening here, Sphinx has a few roles within the
    docstrings that offer hints as to what we are documenting.
  prefs: []
  type: TYPE_NORMAL
- en: The `param` role paired with a name sets the documentation for the parameter
    with that name. The `type` role paired with a name tells Sphinx the data type
    of the parameter. Both the roles are optional and the parameter simply won’t have
    any added documentation if they are omitted, but the `param` role is always required
    for any documentation to show. Simply adding the `type` role without the `param` role
    will result in no output whatsoever, so take note to always pair them.
  prefs: []
  type: TYPE_NORMAL
- en: The `returns` role is similar to the `param` role with regards to documenting.
    While the `param` role documents a parameter, the `returns` role documents the
    returned object. They are slightly different, however. As opposed to the `param` role,
    the `returns` role is not dependent on the `rtype` role, or vice versa. They both
    work independently of each other, making it possible to use either or both of
    the roles.
  prefs: []
  type: TYPE_NORMAL
- en: The `rtype`, as you can expect, tells Sphinx (and several editors) what type of
    object is returned from the function. With the introduction of type hinting, however,
    the `rtype` role is pretty useless since you have an easier way of specifying
    the return type.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a class with the Google style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Google style is just a more legible version of the Sphinx style documentation.
    It doesn’t actually support more or less, but it’s a lot more intuitive to use.
    Here’s the Google style version of the `Spam` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This is easier on the eyes than the Sphinx style and has the same number of possibilities.
    For longer argument documentation, it’s less than convenient though. Just imagine
    how a multiline description of `number` would look. That is why the NumPy style
    was developed, providing a lot of documentation for its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a class with the NumPy style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The NumPy style is meant for having a lot of documentation. Honestly, most people
    are too lazy for that, so for most projects it would not be a good fit. If you
    do plan to have extensive documentation of your functions and all their parameters,
    the NumPy style might be a good option for you. It’s a bit more verbose than the
    Google style, but it’s very legible, especially with more detailed documentation.
    The following is the NumPy version of the `Spam` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: While the NumPy style definitely isn’t bad, it’s just very verbose. This example
    alone is about 1.5 times as long as the alternatives. So, for longer and more
    detailed documentation it’s a very good choice, but if you’re planning to have
    short documentation anyhow, just use the Google style instead.
  prefs: []
  type: TYPE_NORMAL
- en: Which style to choose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most projects, the Google style is the best choice since it is readable
    but not too verbose. If you are planning to use large amounts of documentation
    per parameter, then the NumPy style might be a good option as well.
  prefs: []
  type: TYPE_NORMAL
- en: The only reason for choosing the Sphinx style is legacy. Even though the Google
    style might be more legible, consistency is more important.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To practice a little with Python type hinting, it would be good to add some
    of this documentation to your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of less trivial type hints would be:'
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested or even recursive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating stubs for documenting external projects that don’t have type hinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_9.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to add, use, and test type hinting in
    your code using both the built-in types and your own custom types. You learned
    how to write Markdown and reStructuredText to document your projects and your
    code itself. Lastly, you learned how to use the Sphinx documentation generator
    to generate fully functioning documentation for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation can help greatly in a project’s popularity, and bad documentation
    can kill productivity. I think there are few aspects of a library that have more
    impact on the usage by third parties than documentation. Thus, in many cases,
    documentation is a more important factor in deciding the usage of a project than
    the actual code quality. That’s why it is very important to always try to have
    good documentation available. Sphinx is a great help in this case because it makes
    it much easier to keep your documentation up to date and matching your code. The
    only thing worse than no documentation is incorrect and/or out-of-date documentation.
  prefs: []
  type: TYPE_NORMAL
- en: With Sphinx, it is easy to generate documentation. With just a few minutes of
    your time, you can have a fully functioning website with documentation available,
    or a PDF, or ePub, or one of the many other output formats. There really is no
    excuse for having no documentation anymore. And even if you don’t use the documentation
    that much yourself, offering type hints to your editor can help a lot with productivity
    as well. Making your editor smarter should always help with productivity. I, for
    one, have added type hints to several external projects simply to increase my
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explain how code can be tested in Python and some part
    of the documentation will return there. Using `doctest`, it is possible to have
    example code, documentation, and tests in one.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code156081100001293319171.png)'
  prefs: []
  type: TYPE_IMG
