<html><head></head><body>
  <div id="_idContainer092">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-133" class="chapterTitle">Python Data Structures</h1>
    <p class="normal">In our examples so far, we've already seen many of the built-in Python data structures in action. You've probably also covered many of them in introductory books or tutorials. In this chapter, we'll discuss the object-oriented features of these data structures, when they should be used instead of a regular class, and when they should not be used. In particular, we'll be covering the following topics:</p>
    <ul>
      <li class="bullet">Tuples and named tuples</li>
      <li class="bullet">Dataclasses</li>
      <li class="bullet">Dictionaries</li>
      <li class="bullet">Lists and sets</li>
      <li class="bullet">Three types of queues</li>
    </ul>
    <p class="normal">This chapter's case study will revisit the data model for the <em class="italic">k</em>-nearest neighbors classifier. After looking at Python's sophisticated built-in data structure and class definitions, we can simplify some of the application class definitions.</p>
    <p class="normal">We'll start by looking at some of the foundational constructs. The <code class="Code-In-Text--PACKT-">object</code> class, specifically.</p>
    <h1 id="_idParaDest-134" class="title">Empty objects</h1>
    <p class="normal">Let's start with the most basic Python built-in, one that we've used implicitly many times already, the <a id="_idIndexMarker439"/>one (it turns out) we've extended in every class we have created: the <code class="Code-In-Text--PACKT-">object</code>. </p>
    <p class="normal">Technically, we can instantiate an <code class="Code-In-Text--PACKT-">object</code> without writing a subclass, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">o = </span><span class="hljs-con-built_in">object</span><span class="python">()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">o.x = </span><span class="hljs-con-number">5</span>
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in &lt;module&gt;
    AttributeError: 'object' object has no attribute 'x'  
</code></pre>
    <p class="normal">Unfortunately, as you can see, it's not possible to set any attributes on an <code class="Code-In-Text--PACKT-">object</code> that was instantiated directly. This isn't because the Python developers wanted to force us to write our own classes, or anything so sinister. They did this to save memory – a lot of memory. When Python allows an object to have arbitrary attributes, it takes a certain amount of system memory to keep track of what attributes each object has, for storing both the attribute name and its value. Even if no attributes are stored, memory is allocated to <a id="_idIndexMarker440"/>make it possible to add attributes. Given the dozens, hundreds, or thousands of objects (<em class="italic">every</em> class extends the <code class="Code-In-Text--PACKT-">object</code> class) in a typical Python program, this small amount of memory would quickly become a large amount of memory. So, Python disables arbitrary properties on <code class="Code-In-Text--PACKT-">object</code>, and several other built-ins, by default.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">It is possible to restrict arbitrary properties on our own classes using <code class="Code-In-Text--PACKT-">__slots__</code>. Slots are part of <em class="chapterRef">Chapter 12</em>, <em class="italic">Advanced Design Patterns</em>. We'll look at them as a way to save memory for objects that occur many, many times.</p>
    </div>
    <p class="normal">It is, however, trivial to create an empty object class of our own; we saw it in our earliest example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">MyObject</span><span class="hljs-con-class">:</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">pass</span><span class="python"> </span>
</code></pre>
    <p class="normal">In effect, <code class="Code-In-Text--PACKT-">class MyObject</code> is equivalent to <code class="Code-In-Text--PACKT-">class MyObject(object)</code>. As we've already seen, it's possible to set attributes on such classes as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">m = MyObject()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">m.x = </span><span class="hljs-con-string">"hello"</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">m.x</span>
'hello'  
</code></pre>
    <p class="normal">If we wanted to group an unknown number of attribute values together, we could store them in an empty object like this. The problem with this approach is the lack of an obvious schema that we can use to understand what attributes should be present and what types of values they'll have.</p>
    <p class="normal">A focus of this book is the way classes and objects should only be used when you want to specify <em class="italic">both</em> data and behaviors. Therefore, it is important to decide from the outset whether the data is purely data, or whether it is an object in disguise. Once that design decision is made, the rest of the design can grow from the seed concept.</p>
    <h1 id="_idParaDest-135" class="title">Tuples and named tuples</h1>
    <p class="normal">Tuples are objects that can store a specific number of other objects in sequence. They are <em class="italic">immutable</em>, meaning we can't add, remove, or replace objects on the fly. This may seem like a massive restriction, but the truth is, if you need to modify a tuple, you're using the <a id="_idIndexMarker441"/>wrong data type (usually, a <code class="Code-In-Text--PACKT-">list</code> would be more suitable). The primary <a id="_idIndexMarker442"/>benefit of tuples' immutability is a tuple of immutable objects (like strings and numbers and other tuples) has a hash value, allowing us to use them as keys in dictionaries, and members of a set. (A tuple that contains a mutable structure, like a list, set, or dict, isn't composed of immutable items, and doesn't have a hash value. We'll look closely at this distinction in the next section.)</p>
    <p class="normal">Instances of Python's built-in generic <code class="Code-In-Text--PACKT-">tuple</code> class are used to store data; behavior cannot be associated with a built-in tuple. If we require behavior to manipulate a tuple, we have to pass the tuple into a function (or method on another object) that performs the action. This is the subject of <em class="chapterRef">Chapter 8</em>, <em class="italic">The Intersection of Object-Oriented and Functional Programming</em>.</p>
    <p class="normal">Tuples overlap with the idea of coordinates or dimensions. A mathematical (x, y) pair or (r, g, b) color are examples of tuples; the order matters, a lot: the color (255, 0, 0) looks nothing like (0, 255, 0). The primary purpose of a tuple is to aggregate different pieces of data together into one container. </p>
    <p class="normal">We create a tuple by separating values with a comma. Usually, tuples are wrapped in parentheses to make them easy to read and to separate them from other parts of an expression, but this is not always mandatory. The following two assignments are identical (they record a stock, the current price, the 52-week high, and the 52-week low, for a rather profitable company):</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock = </span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">, </span><span class="hljs-con-number">137.98</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock2 = (</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">, </span><span class="hljs-con-number">137.98</span><span class="python">)</span>
</code></pre>
    <p class="normal">(When the first edition of this book was printed, this stock was trading around US$ 8 per share; the stock value has almost doubled with each edition of this book!)</p>
    <p class="normal">If we're grouping a tuple inside of some other object, such as a function call, list comprehension, or generator, the parentheses are required. Otherwise, it would be impossible for the interpreter to know whether it is a tuple or the next function parameter. For example, the following function accepts a tuple and a date, and returns a tuple of the date and the middle value between the stock's high and low value:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> datetime</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">middle</span><span class="hljs-con-function">(</span><span class="hljs-con-params">stock, date</span><span class="hljs-con-function">):</span>
<span class="hljs-con-meta">...</span> <span class="python">    symbol, current, high, low = stock</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> (((high + low) / </span><span class="hljs-con-number">2</span><span class="python">), date)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">middle((</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">, </span><span class="hljs-con-number">137.98</span><span class="python">), datetime.date(</span><span class="hljs-con-number">2020</span><span class="python">, </span><span class="hljs-con-number">12</span><span class="python">, </span><span class="hljs-con-number">4</span><span class="python">))</span>
(95.565, datetime.date(2020, 12, 4))
</code></pre>
    <p class="normal">In this example, a new four-tuple is created directly inside the function call. The items are separated by commas and the entire tuple is cuddled up inside parentheses. This tuple is then followed by a comma to separate it from the second argument, a <code class="Code-In-Text--PACKT-">datetime.date</code> object. When Python displays a tuple, it uses what's called the <strong class="keyword">canonical</strong> representation; this will always include <code class="Code-In-Text--PACKT-">()</code>'s, making the <code class="Code-In-Text--PACKT-">()</code>'s a common practice even when they're not – strictly – required. The <code class="Code-In-Text--PACKT-">return</code> statement, specifically, has redundant <code class="Code-In-Text--PACKT-">()</code>'s around the tuple it creates.</p>
    <p class="normal">The degenerate <a id="_idIndexMarker443"/>cases include a tuple with only one item, written like this <code class="Code-In-Text--PACKT-">(2.718,)</code>. The extra comma <a id="_idIndexMarker444"/>is required here. An empty tuple is <code class="Code-In-Text--PACKT-">()</code>. </p>
    <p class="normal">We can sometimes wind up with a statement like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a = </span><span class="hljs-con-number">42</span><span class="python">,</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a</span>
(42,)
</code></pre>
    <p class="normal">It's sometimes surprising that the variable <code class="Code-In-Text--PACKT-">a</code> will be a one-tuple. The trailing comma is what creates an expression list with a single item; this is the value of the tuple. The <code class="Code-In-Text--PACKT-">()</code>'s are required for two things: (1) to create an empty tuple or (2) to separate a tuple from other expressions. For example, the following creates nested tuples:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">b = (</span><span class="hljs-con-number">42</span><span class="python">, </span><span class="hljs-con-number">3.14</span><span class="python">), (</span><span class="hljs-con-number">2.718</span><span class="python">, </span><span class="hljs-con-number">2.618</span><span class="python">), </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">b</span>
((42, 3.14), (2.718, 2.618))
</code></pre>
    <p class="normal">The trailing commas in Python are politely ignored.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">middle()</code> function <a id="_idIndexMarker445"/>also illustrates <strong class="keyword">tuple unpacking</strong>. The first line inside the function unpacks the <code class="Code-In-Text--PACKT-">stock</code> parameter into four different variables. The tuple has to be exactly the same length as the number of variables, or it will raise an exception.</p>
    <p class="normal">Unpacking is a very useful feature in Python. A tuple groups related values together to make storing and passing them around simpler; the moment we need to access the pieces, we can unpack them into separate variables. Of course, sometimes we only need access to one of the variables in the tuple. We can use the same syntax that we use for other sequence types (lists and strings, for example) to access an individual value:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s = </span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">132.76</span><span class="python">, </span><span class="hljs-con-number">134.80</span><span class="python">, </span><span class="hljs-con-number">130.53</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">high = s[</span><span class="hljs-con-number">2</span><span class="python">]</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">high</span>
134.8
</code></pre>
    <p class="normal">We can even use slice notation to extract larger pieces of tuples, as demonstrated in the following:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s[</span><span class="hljs-con-number">1</span><span class="python">:</span><span class="hljs-con-number">3</span><span class="python">]</span>
(132.76, 134.8)
</code></pre>
    <p class="normal">These examples, while illustrating how flexible tuples can be, also demonstrate one of their major <a id="_idIndexMarker446"/>disadvantages: readability. How does someone reading this code know what is in position 2 of a specific tuple? They can guess, using the name of the variable <a id="_idIndexMarker447"/>we assigned it to, that it is <code class="Code-In-Text--PACKT-">high</code> of some sort, but if we had just accessed the tuple value in a calculation without assigning it, there would be no such indication. They would have to paw through the code to find where the tuple was packed or unpacked before they could discover what it does.</p>
    <p class="normal">Accessing tuple members directly is fine in some circumstances, but don't make a habit of it. The index values become what we might call<em class="italic"> magic numbers</em>: numbers that seem to come out of thin air with no apparent meaning within the code. This opacity is the source of many coding errors and leads to hours of frustrated debugging. Try to use tuples only when you know that all the values are going to be useful at once and it's normally going to be unpacked when it is accessed. Think of (x, y) coordinate pairs and (r, g, b) colors, where the number of items is fixed, the order matters, and the meaning is clear.</p>
    <p class="normal">One way to provide some useful documentation is to define numerous little helper functions. This can help to clarify the way a tuple is used. Here's an example.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">high</span><span class="hljs-con-function">(</span><span class="hljs-con-params">stock</span><span class="hljs-con-function">):</span>
<span class="hljs-con-meta">...</span> <span class="python">    symbol, current, high, low = stock</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> high</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">high(s)</span>
134.8
</code></pre>
    <p class="normal">We need to keep these helper functions collected together into a single namespace. Doing this causes <a id="_idIndexMarker448"/>us to suspect that a class is better than a tuple with a lot <a id="_idIndexMarker449"/>of helper functions. There are other alternatives to clarifying the contents of tuples, the most important of which is the <code class="Code-In-Text--PACKT-">typing.NamedTuple</code> class.</p>
    <h2 id="_idParaDest-136" class="title">Named tuples via typing.NamedTuple</h2>
    <p class="normal">So, what do we do when we want to group values together but know we're frequently going to <a id="_idIndexMarker450"/>need to access them individually? There are actually several options, including these:</p>
    <ul>
      <li class="bullet">We could use an empty <code class="Code-In-Text--PACKT-">object</code> instance, as discussed previously. We can assign arbitrary attributes to this object. But without a good definition of what's allowed and what types are expected, we'll have trouble understanding this. And we'll get a lot of <strong class="" style="font-style: italic;">mypy</strong> errors. </li>
      <li class="bullet">We could use a dictionary. This can work out nicely, and we can formalize the acceptable list of keys for the dictionary with the <code class="Code-In-Text--PACKT-">typing.TypedDict</code> hint. We'll touch on these in the case study for <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings, Serialization, and File Paths</em>.</li>
      <li class="bullet">We can use a <code class="Code-In-Text--PACKT-">@dataclass</code>, the subject of the next section in this chapter.</li>
      <li class="bullet">We can also provide names to the positions of a tuple. While we're at it, we can also define methods for these named tuples, making them super helpful.</li>
    </ul>
    <p class="normal">Named tuples are tuples with attitude. They are a great way to create an immutable grouping of data values. When we define a <strong class="keyword">named tuple</strong> we're creating a subclass of <code class="Code-In-Text--PACKT-">typing.NamedTuple</code>, based on a list of names and data types. We don't need to write an <code class="Code-In-Text--PACKT-">__init__()</code> method; it's created for us.</p>
    <p class="normal">Here's an example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> typing </span><span class="hljs-con-keyword">import</span><span class="python"> NamedTuple</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Stock</span><span class="hljs-con-class">(</span><span class="hljs-con-params">NamedTuple</span><span class="hljs-con-class">):</span>
<span class="hljs-con-meta">...</span> <span class="python">    symbol: </span><span class="hljs-con-built_in">str</span>
<span class="hljs-con-meta">...</span> <span class="python">    current: </span><span class="hljs-con-built_in">float</span>
<span class="hljs-con-meta">...</span> <span class="python">    high: </span><span class="hljs-con-built_in">float</span>
<span class="hljs-con-meta">...</span> <span class="python">    low: </span><span class="hljs-con-built_in">float</span>
</code></pre>
    <p class="normal">This new class will have a number of methods, including <code class="Code-In-Text--PACKT-">__init__()</code>, <code class="Code-In-Text--PACKT-">__repr__()</code>, <code class="Code-In-Text--PACKT-">__hash__()</code>, and <code class="Code-In-Text--PACKT-">__eq__()</code>. These will be based on the generic <code class="Code-In-Text--PACKT-">tuple</code> processing with the added benefit of names for the various items. There are more methods, including comparison operations. Here's how we can create a tuple of this class. It looks almost like creating a generic tuple:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Stock(</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">137.98</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">)</span>
</code></pre>
    <p class="normal">We can use keyword parameters to make things more clear:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s2 = Stock(</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, high=</span><span class="hljs-con-number">137.98</span><span class="python">, low=</span><span class="hljs-con-number">53.15</span><span class="python">)</span>
</code></pre>
    <p class="normal">The constructor must have exactly the correct number of arguments to create the tuple. Values can be passed in as positional or keyword arguments.</p>
    <p class="normal">It's important to recognize that the names are provided at the class level, but we are <strong class="" style="font-style: italic;">not</strong> actually creating class-level attributes. The class-level names are used to build the <code class="Code-In-Text--PACKT-">__init__()</code> method; each instance will have the expected names for the positions within the tuple. There's a clever metaclass-level transformation from what we wrote into the somewhat more complex definition of the resulting class with named, positional items. For more information on metaclasses, refer back to <em class="chapterRef">Chapter 6</em>, <em class="italic">Abstract Base Classes and Operator Overloading</em>.</p>
    <p class="normal">The resulting <a id="_idIndexMarker451"/>instance of our <code class="Code-In-Text--PACKT-">NamedTuple</code> subclass, <code class="Code-In-Text--PACKT-">Stock</code>, can then be packed, unpacked, indexed, sliced, and otherwise treated like a normal tuple, but we can also access individual attributes by name as if it were an object:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.high</span>
137.98
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s[</span><span class="hljs-con-number">2</span><span class="python">]</span>
137.98
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">symbol, current, high, low = s</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">current</span>
123.52
</code></pre>
    <p class="normal">Named tuples are perfect for many use cases. Like strings, tuples and named tuples are immutable, so we cannot modify an attribute once it has been set. For example, the current value of this company's stock has gone down since we started this discussion, but we can't set the new value, as can be seen in the following:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.current = </span><span class="hljs-con-number">122.25</span>
Traceback (most recent call last):
  ...
  File "&lt;doctest examples.md[27]&gt;", line 1, in &lt;module&gt;
    s2.current = 122.25
AttributeError: can't set attribute
</code></pre>
    <p class="normal">The immutability refers only to the attributes of the tuple itself. This can seem odd, but it's a consequence of the definitions of an immutable tuple. The tuple can contain mutable elements.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">t = (</span><span class="hljs-con-string">"Relayer"</span><span class="python">, [</span><span class="hljs-con-string">"Gates of Delirium"</span><span class="python">, </span><span class="hljs-con-string">"Sound Chaser"</span><span class="python">])</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">t[</span><span class="hljs-con-number">1</span><span class="python">].append(</span><span class="hljs-con-string">"To Be Over"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">t</span>
('Relayer', ['Gates of Delirium', 'Sound Chaser', 'To Be Over'])
</code></pre>
    <p class="normal">The object, <code class="Code-In-Text--PACKT-">t</code>, is a tuple, which means it's immutable. The tuple object contains two items. The value of <code class="Code-In-Text--PACKT-">t[0]</code> is a string, which is also immutable. The value of <code class="Code-In-Text--PACKT-">t[1]</code>, however, is a mutable list. The mutability of the list is not altered by the immutability of the object, <code class="Code-In-Text--PACKT-">t</code>, with which it's associated. A list is mutable, irrespective of context. The tuple, <code class="Code-In-Text--PACKT-">t</code>, is immutable, even if items within it are mutable.</p>
    <p class="normal">Because the example tuple, <code class="Code-In-Text--PACKT-">t</code>, contains a mutable list, it doesn't have a hash value. This shouldn't be surprising, either. The <code class="Code-In-Text--PACKT-">hash()</code> computation requires the hash from each item within <a id="_idIndexMarker452"/>the collection. Since the list value of <code class="Code-In-Text--PACKT-">t[1]</code> can't produce a hash, the tuple <code class="Code-In-Text--PACKT-">t</code> – as a whole – can't produce a hash, either.</p>
    <p class="normal">Here's what happens when we try:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">hash</span><span class="python">(t)</span>
Traceback (most recent call last):
  ...
  File "&lt;doctest examples.md[31]&gt;", line 1, in &lt;module&gt;
    hash(t)
TypeError: unhashable type: 'list'
</code></pre>
    <p class="normal">The presence of the unhashable list object means the tuple – as a whole – is also unhashable.</p>
    <p class="normal">We can create methods to compute derived values of the attributes of a named tuple. We can, for example, redefine our <code class="Code-In-Text--PACKT-">Stock</code> tuple to include the middle computation as a method (or a <code class="Code-In-Text--PACKT-">@property</code>):</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Stock</span><span class="hljs-con-class">(</span><span class="hljs-con-params">NamedTuple</span><span class="hljs-con-class">):</span>
<span class="hljs-con-meta">...</span> <span class="python">    symbol: </span><span class="hljs-con-built_in">str</span>
<span class="hljs-con-meta">...</span> <span class="python">    current: </span><span class="hljs-con-built_in">float</span>
<span class="hljs-con-meta">...</span> <span class="python">    high: </span><span class="hljs-con-built_in">float</span>
<span class="hljs-con-meta">...</span> <span class="python">    low: </span><span class="hljs-con-built_in">float</span>
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @property</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">middle</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">) -&gt; float:</span>
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> (self.high + self.low)/</span><span class="hljs-con-number">2</span>
</code></pre>
    <p class="normal">We can't change the state, but we can compute values derived from the current state. This lets us couple computations directly to the tuple holding the source data. Here's an object created with this definition of the <code class="Code-In-Text--PACKT-">Stock</code> class:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s = Stock(</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">137.98</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.middle</span>
95.565
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">middle()</code> method <a id="_idIndexMarker453"/>is now part of the class definition. The best part? The <strong class="" style="font-style: italic;">mypy</strong> tool can look over our shoulder to be sure the type hints <a id="_idIndexMarker454"/>all match up properly throughout our application.</p>
    <p class="normal">The state of a named tuple is fixed when the tuple is created. If we need to be able to change stored data, a <code class="Code-In-Text--PACKT-">dataclass</code> may be what we need instead. We'll look at those next.</p>
    <h1 id="_idParaDest-137" class="title">Dataclasses</h1>
    <p class="normal">Since Python 3.7, dataclasses let us define ordinary objects with a clean syntax for specifying <a id="_idIndexMarker455"/>attributes. They look – superficially – very similar to named tuples. This is a pleasant approach that makes it easy to understand how they work.</p>
    <p class="normal">Here's a <code class="Code-In-Text--PACKT-">dataclass</code> version of our <code class="Code-In-Text--PACKT-">Stock</code> example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> dataclasses </span><span class="hljs-con-keyword">import</span><span class="python"> dataclass</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@dataclass</span>
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Stock</span><span class="hljs-con-class">:</span>
<span class="hljs-con-meta">...</span> <span class="python">    symbol: </span><span class="hljs-con-built_in">str</span>
<span class="hljs-con-meta">...</span> <span class="python">    current: </span><span class="hljs-con-built_in">float</span>
<span class="hljs-con-meta">...</span> <span class="python">    high: </span><span class="hljs-con-built_in">float</span>
<span class="hljs-con-meta">...</span> <span class="python">    low: </span><span class="hljs-con-built_in">float</span>
</code></pre>
    <p class="normal">For this case, the definition is nearly identical to the <code class="Code-In-Text--PACKT-">NamedTuple</code> definition.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">dataclass</code> function is applied as a class decorator, using the <code class="Code-In-Text--PACKT-">@</code> operator. We encountered decorators in <em class="chapterRef">Chapter 6</em>, <em class="italic">Abstract Base Classes and Operator Overloading</em>. We'll dig into them deeply in <em class="chapterRef">Chapter 11</em>, <em class="italic">Common Design Patterns</em>. This class definition syntax isn't much less verbose than an ordinary class with <code class="Code-In-Text--PACKT-">__init__()</code>, but it gives us access to several additional <code class="Code-In-Text--PACKT-">dataclass</code> features.</p>
    <p class="normal">It's important to recognize that the names are provided at the class level, but are <strong class="" style="font-style: italic;">not</strong> actually creating class-level attributes. The class level names are used to build several methods, including the <code class="Code-In-Text--PACKT-">__init__()</code> method; each instance will have the expected attributes. The decorator transforms what we wrote into the more complex definition of a class with the expected attributes and parameters to <code class="Code-In-Text--PACKT-">__init__()</code>. </p>
    <p class="normal">Because dataclass <a id="_idIndexMarker456"/>objects can be stateful, mutable objects, there are a number of extra features available. We'll start with some basics. Here's an example of creating an instance of the <code class="Code-In-Text--PACKT-">Stock</code> dataclass.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s = Stock(</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">137.98</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">)</span>
</code></pre>
    <p class="normal">Once instantiated, the <code class="Code-In-Text--PACKT-">Stock</code> object can be used like any ordinary class. You can access and update attributes as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s</span>
Stock(symbol='AAPL', current=123.52, high=137.98, low=53.15)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.current</span>
123.52
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.current = </span><span class="hljs-con-number">122.25</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s</span>
Stock(symbol='AAPL', current=122.25, high=137.98, low=53.15)
</code></pre>
    <p class="normal">As with other objects, we can add attributes beyond those formally declared as part of the dataclass. This isn't always the best idea, but it's supported because this is an ordinary mutable object:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.unexpected_attribute = </span><span class="hljs-con-string">'allowed'</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s.unexpected_attribute</span>
'allowed'
</code></pre>
    <p class="normal">Adding attributes isn't available for frozen dataclasses, which we'll talk about later in this section. At first glance, it seems like dataclasses don't give many benefits over an ordinary class definition with an appropriate constructor. Here's an ordinary class that's similar to the dataclass:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">StockOrdinary</span><span class="hljs-con-class">:</span>
<span class="hljs-con-meta">...</span><span class="hljs-con-class">     </span><span class="hljs-con-keyword">def</span><span class="hljs-con-title"> __init__</span><span class="hljs-con-class">(self, name: </span><span class="hljs-con-built_in">str</span><span class="hljs-con-class">, current: </span><span class="hljs-con-built_in">float</span><span class="hljs-con-class">, high: </span><span class="hljs-con-built_in">float</span><span class="hljs-con-class">, low: </span><span class="hljs-con-meta">... </span><span class="hljs-con-built_in">float</span><span class="hljs-con-class">) -&gt; </span><span class="hljs-con-keyword">None</span><span class="hljs-con-class">:</span>
<span class="hljs-con-meta">...</span><span class="hljs-con-class">         self.name = name</span>
<span class="hljs-con-meta">...</span><span class="hljs-con-class">         self.current = current</span>
<span class="hljs-con-meta">...</span><span class="hljs-con-class">         self.high = high</span>
<span class="hljs-con-meta">...</span><span class="hljs-con-class">         self.low = low</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s_ord = StockOrdinary(</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">137.98</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">)</span>
</code></pre>
    <p class="normal">One obvious benefit to a dataclass is we only need to state the attribute names once, saving the repetition in the <code class="Code-In-Text--PACKT-">__init__()</code> parameters and body. But wait, that's not all! The dataclass also provides a much more useful string representation than we get from the implicit superclass, <code class="Code-In-Text--PACKT-">object</code>. By default, dataclasses include an equality comparison, also. This can be <a id="_idIndexMarker457"/>turned off in the cases where it doesn't make sense. The following example compares the manually built class to these dataclass features:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s_ord</span>
&lt;__main__.StockOrdinary object at 0x7fb833c63f10&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s_ord_2 = StockOrdinary(</span><span class="hljs-con-string">"AAPL"</span><span class="python">, </span><span class="hljs-con-number">123.52</span><span class="python">, </span><span class="hljs-con-number">137.98</span><span class="python">, </span><span class="hljs-con-number">53.15</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s_ord == s_ord_2</span>
False
</code></pre>
    <p class="normal">The class built manually has an awful default representation, and the lack of an equality test can make life difficult. We'd prefer the behavior of the <code class="Code-In-Text--PACKT-">Stock</code> class defined as a dataclass.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock2 = Stock(symbol=</span><span class="hljs-con-string">'AAPL'</span><span class="python">, current=</span><span class="hljs-con-number">122.25</span><span class="python">, high=</span><span class="hljs-con-number">137.98</span><span class="python">, low=</span><span class="hljs-con-number">53.15</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s == stock2</span>
True
</code></pre>
    <p class="normal">Class definitions decorated with <code class="Code-In-Text--PACKT-">@dataclass</code> also have many other useful features. For example, you can specify a default value for the attributes of a dataclass. Perhaps the market is currently closed and you don't know what the values for the day are:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">StockDefaults</span><span class="hljs-class">:</span>
    name: <span class="hljs-built_in">str</span>
    current: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>
    high: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>
    low: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>
</code></pre>
    <p class="normal">You can construct this class with just the stock name; the rest of the values will take on the defaults. But you can still specify values if you prefer, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">StockDefaults(</span><span class="hljs-con-string">"GOOG"</span><span class="python">)</span>
StockDefaults(name='GOOG', current=0.0, high=0.0, low=0.0)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">StockDefaults(</span><span class="hljs-con-string">"GOOG"</span><span class="python">, </span><span class="hljs-con-number">1826.77</span><span class="python">, </span><span class="hljs-con-number">1847.20</span><span class="python">, </span><span class="hljs-con-number">1013.54</span><span class="python">)</span>
StockDefaults(name='GOOG', current=1826.77, high=1847.2, low=1013.54)
</code></pre>
    <p class="normal">We saw earlier that dataclasses support equality comparison by default. If all the attributes compare as equal, then the dataclass objects as a whole also compare as equal. By default, dataclasses do not support other comparisons, such as less than or greater than, and they <a id="_idIndexMarker458"/>can't be sorted. However, you can easily add comparisons if you wish, demonstrated as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">order=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">StockOrdered</span><span class="hljs-class">:</span>
    name: <span class="hljs-built_in">str</span>
    current: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>
    high: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>
    low: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.0</span>
</code></pre>
    <p class="normal">It's okay to ask "Is that all that's needed?" The answer is yes. The <code class="Code-In-Text--PACKT-">order=True</code> parameter to the decorator leads to the creation of all of the comparison special methods. This change gives us the opportunity to sort and compare the instances of this class. It works like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock_ordered1 = StockOrdered(</span><span class="hljs-con-string">"GOOG"</span><span class="python">, </span><span class="hljs-con-number">1826.77</span><span class="python">, </span><span class="hljs-con-number">1847.20</span><span class="python">, </span><span class="hljs-con-number">1013.54</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock_ordered2 = StockOrdered(</span><span class="hljs-con-string">"GOOG"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock_ordered3 = StockOrdered(</span><span class="hljs-con-string">"GOOG"</span><span class="python">, </span><span class="hljs-con-number">1728.28</span><span class="python">, high=</span><span class="hljs-con-number">1733.18</span><span class="python">, low=</span><span class="hljs-con-number">1666.33</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock_ordered1 &lt; stock_ordered2</span>
False
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stock_ordered1 &gt; stock_ordered2</span>
True
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> pprint </span><span class="hljs-con-keyword">import</span><span class="python"> pprint</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pprint(</span><span class="hljs-con-built_in">sorted</span><span class="python">([stock_ordered1, stock_ordered2, stock_ordered3]))</span>
[StockOrdered(name='GOOG', current=0.0, high=0.0, low=0.0),
 StockOrdered(name='GOOG', current=1728.28, high=1733.18, low=1666.33),
 StockOrdered(name='GOOG', current=1826.77, high=1847.2, low=1013.54)]
</code></pre>
    <p class="normal">When the dataclass decorator receives the <code class="Code-In-Text--PACKT-">order=True</code> argument, it will, by default, compare the values based on each of the attributes in the order they were defined. So, in this case, it first compares the <code class="Code-In-Text--PACKT-">name</code> attribute values of the two objects. If those are the same, it compares the <code class="Code-In-Text--PACKT-">current</code> attribute values. If those are also the same, it will move on to <code class="Code-In-Text--PACKT-">high</code> and will even include <code class="Code-In-Text--PACKT-">low</code> if all the other attributes are equal. The rules follow the definition of a tuple: the order of definition is the order of comparison.</p>
    <p class="normal">Another interesting feature of dataclasses is <code class="Code-In-Text--PACKT-">frozen=True</code>. This creates a class that's similar to a <code class="Code-In-Text--PACKT-">typing.NamedTuple</code>. There are some differences in what we get as features. We'd need to use <code class="Code-In-Text--PACKT-">@dataclass(frozen=True, ordered=True)</code> to create structures. This leads to a question of "Which is better?", which – of course – depends on the details of a given use case. We haven't explored all of the optional features of dataclasses, like initialization-only fields and the <code class="Code-In-Text--PACKT-">__post_init__()</code> method. Some applications don't need all of these features, and a simple <code class="Code-In-Text--PACKT-">NamedTuple</code> may be adequate.</p>
    <p class="normal">There are a few <a id="_idIndexMarker459"/>other approaches. Outside the standard library, packages like <code class="Code-In-Text--PACKT-">attrs</code>, <code class="Code-In-Text--PACKT-">pydantic</code>, and <code class="Code-In-Text--PACKT-">marshmallow</code> provide attribute definition capabilities that are – in some ways – similar to dataclasses. Other packages outside the standard library offer additional features. See <a href="https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html"><span class="url">https://jackmckew.dev/dataclasses-vs-attrs-vs-pydantic.html</span></a> for a comparison.</p>
    <p class="normal">We've looked at two ways to create unique classes with specific attribute values, named tuples and dataclasses. It's often easier to start with dataclasses and add specialized methods. This can save us a bit of programming because some of the basics, like initialization, comparison, and string representations, are handled elegantly for us. </p>
    <p class="normal">It's time to look at Python's built-in generic collections, <code class="Code-In-Text--PACKT-">dict</code>, <code class="Code-In-Text--PACKT-">list</code>, and <code class="Code-In-Text--PACKT-">set</code>. We'll start by exploring dictionaries.</p>
    <h1 id="_idParaDest-138" class="title">Dictionaries</h1>
    <p class="normal">Dictionaries are incredibly useful containers that allow us to map objects directly to other objects. Dictionaries are <a id="_idIndexMarker460"/>extremely efficient at looking up a <strong class="keyword">value</strong>, given a specific <strong class="keyword">key</strong> object that maps to that value. The secret of the speed is using a <strong class="keyword">hash</strong> of the key to locate the value. Every immutable Python object has a numeric hash code; a relatively simple table is used to map the numeric hashes directly to values. This trick means a dictionary never searches the entire collection for a key; the key is transformed to a hash, which locates the associated value (almost) immediately.</p>
    <p class="normal">Dictionaries can be created either using the <code class="Code-In-Text--PACKT-">dict()</code> constructor or the <code class="Code-In-Text--PACKT-">{}</code> syntax shortcut. In practice, the latter format is almost always used. We can prepopulate a dictionary by separating the keys from the values using a colon and separating the key-value pairs using a comma.</p>
    <p class="normal">We can also create dictionaries using keyword parameters. We can use <code class="Code-In-Text--PACKT-">dict(current=1235.20, high=1242.54, low=1231.06)</code> to create the value <code class="Code-In-Text--PACKT-">{'current': 1235.2, 'high': 1242.54, 'low': 1231.06}</code>. This <code class="Code-In-Text--PACKT-">dict()</code> syntax overlaps with other constructors like dataclasses and named tuples. </p>
    <p class="normal">For example, in our stock application, we would most often want to look up prices by the stock symbol. We can create a dictionary that uses stock symbols as keys, and tuples (you could also use named tuples or dataclasses as values, of course) of current, high, and low as values, like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks = {</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"GOOG"</span><span class="python">: (</span><span class="hljs-con-number">1235.20</span><span class="python">, </span><span class="hljs-con-number">1242.54</span><span class="python">, </span><span class="hljs-con-number">1231.06</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"MSFT"</span><span class="python">: (</span><span class="hljs-con-number">110.41</span><span class="python">, </span><span class="hljs-con-number">110.45</span><span class="python">, </span><span class="hljs-con-number">109.84</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">}</span>
</code></pre>
    <p class="normal">As we've seen in <a id="_idIndexMarker461"/>previous examples, we can then look up values in the dictionary by requesting a key inside square brackets. If the key is not in the dictionary, it will raise a <code class="Code-In-Text--PACKT-">KeyError</code> exception, demonstrated as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks[</span><span class="hljs-con-string">"GOOG"</span><span class="python">]</span>
(1235.2, 1242.54, 1231.06)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks[</span><span class="hljs-con-string">"RIMM"</span><span class="python">]</span>
Traceback (most recent call last):
  ...
  File "&lt;doctest examples.md[56]&gt;", line 1, in &lt;module&gt;
    stocks.get("RIMM", "NOT FOUND")
KeyError: 'RIMM'
</code></pre>
    <p class="normal">We can, of course, catch the <code class="Code-In-Text--PACKT-">KeyError</code> and handle it. But we have other options. Remember, dictionaries are objects, even if their primary purpose is to hold other objects. As such, they have several behaviors associated with them. One of the most useful of these methods is the <code class="Code-In-Text--PACKT-">get</code> method; it accepts a key as the first parameter and an optional default value if the key doesn't exist:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(stocks.get(</span><span class="hljs-con-string">"RIMM"</span><span class="python">))</span>
None
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks.get(</span><span class="hljs-con-string">"RIMM"</span><span class="python">, </span><span class="hljs-con-string">"NOT FOUND"</span><span class="python">)</span>
'NOT FOUND'
</code></pre>
    <p class="normal">For even more control, we can use the <code class="Code-In-Text--PACKT-">setdefault()</code> method. If the key is in the dictionary, this method behaves just like the <code class="Code-In-Text--PACKT-">get()</code> method; it returns the value for that key. Otherwise, if the key is not in the dictionary, it will not only return the default value we supply in the method call (just like the <code class="Code-In-Text--PACKT-">get()</code> method does); it will also set the key to that same value. Another way to think of it is that <code class="Code-In-Text--PACKT-">setdefault()</code> sets a value in the dictionary only if that value has not previously been set. Then, it returns the value in the dictionary; either the one that was already there or the newly provided default value, as can be seen in the following:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks.setdefault(</span><span class="hljs-con-string">"GOOG"</span><span class="python">, </span><span class="hljs-con-string">"INVALID"</span><span class="python">)</span>
(1235.2, 1242.54, 1231.06)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks.setdefault(</span><span class="hljs-con-string">"BB"</span><span class="python">, (</span><span class="hljs-con-number">10.87</span><span class="python">, </span><span class="hljs-con-number">10.76</span><span class="python">, </span><span class="hljs-con-number">10.90</span><span class="python">))</span>
(10.87, 10.76, 10.9)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks[</span><span class="hljs-con-string">"BB"</span><span class="python">]</span>
(10.87, 10.76, 10.9)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">"GOOG"</code> stock was already in the dictionary, so when we tried to use <code class="Code-In-Text--PACKT-">setdefault()</code> to change it to an invalid value, it just returned the value already in the dictionary. The key <code class="Code-In-Text--PACKT-">"BB"</code> was not in the dictionary, so the <code class="Code-In-Text--PACKT-">setdefault()</code> method returned the default <a id="_idIndexMarker462"/>value and set the new value in the dictionary for us. We then check that the new stock is, indeed, in the dictionary.</p>
    <p class="normal">The type hints for dictionaries must include the type for the keys and the type for the values. Starting with Python 3.9, and <strong class="" style="font-style: italic;">mypy</strong> release 0.812, we describe this structure with a type hint of <code class="Code-In-Text--PACKT-">dict[str, tuple[float, float, float]]</code>; we can avoid importing the <code class="Code-In-Text--PACKT-">typing</code> module. Depending on your version of Python, you'll often need to use <code class="Code-In-Text--PACKT-">from __future__ import annotations</code> as the first line of code in your module; this includes the necessary language support to treat built-in classes as properly generic type annotations.</p>
    <p class="normal">Three other useful dictionary methods are <code class="Code-In-Text--PACKT-">keys()</code>, <code class="Code-In-Text--PACKT-">values()</code>, and <code class="Code-In-Text--PACKT-">items()</code>. The first two return iterators over all the keys and all the values in the dictionary. We can use these in <code class="Code-In-Text--PACKT-">for</code> loops if we want to process all the keys or values. We'll return to the universality of iterators in <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>. The <code class="Code-In-Text--PACKT-">items()</code> method is probably the most useful; it returns an iterator over tuples of <code class="Code-In-Text--PACKT-">(key, value)</code> pairs for every item in the dictionary. This works great with tuple unpacking in a <code class="Code-In-Text--PACKT-">for</code> loop to loop over associated keys and values. The following example does just that to print each stock in the dictionary with its current value:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> stock, values </span><span class="hljs-con-keyword">in</span><span class="python"> stocks.items():</span>
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{stock}</span><span class="hljs-con-string"> last value is </span><span class="hljs-con-subst">{values[</span><span class="hljs-con-number">0</span><span class="hljs-con-subst">]}</span><span class="hljs-con-string">"</span><span class="python">)</span>
<span class="hljs-con-meta">...</span>
GOOG last value is 1235.2
MSFT last value is 110.41
BB last value is 10.87
</code></pre>
    <p class="normal">Each key/value tuple is unpacked into two variables named <code class="Code-In-Text--PACKT-">stock</code> and <code class="Code-In-Text--PACKT-">values</code> (we could use any variable names we wanted, but these both seem appropriate) and then printed in a formatted string.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Notice that the stocks show up in the same order in which they were inserted. This was not true until Python 3.6, and was not a formal part of the language definition until Python 3.7. Before that, the <code class="Code-In-Text--PACKT-">dict</code> implementation used a different underlying data structure with a difficult-to-predict ordering. According to PEP 478, Python 3.5's final release was in September 2020, making this older, difficult-to-predict ordering fully obsolete. To preserve the ordering of keys, we used to be forced to use the <code class="Code-In-Text--PACKT-">OrderedDict</code> class in the <code class="Code-In-Text--PACKT-">collections</code> module, but that's no longer needed. </p>
    </div>
    <p class="normal">There are numerous ways to retrieve data from a dictionary once it has been instantiated: we can <a id="_idIndexMarker463"/>use square brackets as index syntax, the <code class="Code-In-Text--PACKT-">get()</code> method, the <code class="Code-In-Text--PACKT-">setdefault()</code> method, or iterate over the <code class="Code-In-Text--PACKT-">items()</code> method, among others.</p>
    <p class="normal">Finally, as you likely already know, we can set a value in a dictionary using the same indexing syntax we use to retrieve a value:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks[</span><span class="hljs-con-string">"GOOG"</span><span class="python">] = (</span><span class="hljs-con-number">1245.21</span><span class="python">, </span><span class="hljs-con-number">1252.64</span><span class="python">, </span><span class="hljs-con-number">1245.18</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">stocks[</span><span class="hljs-con-string">'GOOG'</span><span class="python">]</span>
(1245.21, 1252.64, 1245.18)
</code></pre>
    <p class="normal">To reflect a change in the GOOG stock, we can update the tuple value in the dictionary. We can use this index syntax to set a value for any key, regardless of whether the key is in the dictionary. If it is in the dictionary, the old value will be replaced with the new one; otherwise, a new key-value pair will be created.</p>
    <p class="normal">We've been using strings as dictionary keys, so far, but we aren't limited to string keys. It is common to use strings as keys, especially when we're storing data in a dictionary to gather it together (instead of using an object or dataclass with named properties). But we can also use tuples, numbers, or even objects we've defined ourselves as dictionary keys. The essential ingredient is a <code class="Code-In-Text--PACKT-">__hash__()</code> method, which immutable types offer. While we can even use different types of objects as keys in a single dictionary, this is difficult to describe to <strong class="" style="font-style: italic;">mypy</strong>. </p>
    <p class="normal">Here's an example of a dictionary with a variety of keys and values:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">random_keys = {} </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">random_keys[</span><span class="hljs-con-string">"astring"</span><span class="python">] = </span><span class="hljs-con-string">"somestring"</span><span class="python"> </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">random_keys[</span><span class="hljs-con-number">5</span><span class="python">] = </span><span class="hljs-con-string">"aninteger"</span><span class="python"> </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">random_keys[</span><span class="hljs-con-number">25.2</span><span class="python">] = </span><span class="hljs-con-string">"floats work too"</span><span class="python"> </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">random_keys[(</span><span class="hljs-con-string">"abc"</span><span class="python">, </span><span class="hljs-con-number">123</span><span class="python">)] = </span><span class="hljs-con-string">"so do tuples"</span><span class="python"> </span>
 
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AnObject</span><span class="hljs-con-class">:</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, avalue</span><span class="hljs-con-function">):</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">        self.avalue = avalue </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">my_object = AnObject(</span><span class="hljs-con-number">14</span><span class="python">) </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">random_keys[my_object] = </span><span class="hljs-con-string">"We can even store objects"</span><span class="python"> </span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">my_object.avalue = </span><span class="hljs-con-number">12</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">random_keys[[</span><span class="hljs-con-number">1</span><span class="python">,</span><span class="hljs-con-number">2</span><span class="python">,</span><span class="hljs-con-number">3</span><span class="python">]] = </span><span class="hljs-con-string">"we can't use lists as keys"</span><span class="python"> </span>
Traceback (most recent call last):
  ...
  File "&lt;doctest examples.md[72]&gt;", line 1, in &lt;module&gt;
    random_keys[[1,2,3]] = "we can't use lists as keys"
TypeError: unhashable type: 'list'
</code></pre>
    <p class="normal">This code shows <a id="_idIndexMarker464"/>several different types of keys we can supply to a dictionary. The data structure has a type hint of <code class="Code-In-Text--PACKT-">dict[Union[str, int, float, Tuple[str, int], AnObject], str]</code>. This is clearly terribly complex. Writing type hints for this can be bewildering, suggesting it's not the best approach.</p>
    <p class="normal">This example also shows one type of object that cannot be used as a key. We've already used lists extensively, and we'll be seeing many more details of them in the next section. Because lists are mutable – they can change at any time (by adding or removing items, for example) – they cannot hash to a single value.</p>
    <p class="normal">We can use code like the following to examine values in the dictionary. This works because the default behavior of a mapping is to iterate over the keys.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> key </span><span class="hljs-con-keyword">in</span><span class="python"> random_keys: </span>
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{key!r}</span><span class="hljs-con-string"> has value </span><span class="hljs-con-subst">{random_keys[key]!r}</span><span class="hljs-con-string">"</span><span class="python">) </span>
'astring' has value 'somestring'
5 has value 'aninteger'
25.2 has value 'floats work too'
('abc', 123) has value 'so do tuples'
&lt;__main__.AnObject object at ...&gt; has value 'We can even store objects'
</code></pre>
    <p class="normal">To be usable as a dictionary key, an object must be <strong class="keyword">hashable</strong>, that is, have a <code class="Code-In-Text--PACKT-">__hash__()</code> method to convert the object's state into a unique integer value for rapid lookup in a dictionary or set. The built-in <code class="Code-In-Text--PACKT-">hash()</code> function uses the <code class="Code-In-Text--PACKT-">__hash__()</code> method of the object's class. This hash is used to find values in a dictionary. For example, strings map to integers based on numeric codes for the characters in the string, while tuples combine hashes of the items inside the tuple. Any two objects that are considered equal (such as strings with the same characters or tuples with the same values) <strong class="" style="font-style: italic;">must</strong> also have the same hash value. Note that there is an asymmetry between equality and matching hash values. If two strings <a id="_idIndexMarker465"/>have the same hash value, they could still be unequal. Think of hash equality as an approximation for an equality test: if the hashes aren't equal, don't bother looking at the details. If the hashes are equal, invest the time in checking each attribute value or each item of the tuple, or each individual character of the string.</p>
    <p class="normal">Here's an example of two integers with the same hash value that are not actually equal: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">x = </span><span class="hljs-con-number">2020</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">y = </span><span class="hljs-con-number">2305843009213695971</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">hash</span><span class="python">(x) == </span><span class="hljs-con-built_in">hash</span><span class="python">(y)</span>
True
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">x == y</span>
False
</code></pre>
    <p class="normal">When we use these values as keys in a dictionary, a hash collision algorithm will keep them separated. The situation leads to a microscopic slowdown in these rare cases of hash collisions. This is why dictionary lookup isn't <strong class="keyword">always</strong> immediate: a hash collision might slow down access.</p>
    <p class="normal">The built-in mutable objects – including lists, dictionaries, and sets – cannot be used as dictionary keys. These mutable collections don't provide hash values. We can, however, create our own class of objects that are both mutable and provide a hash value; this is unsafe because a change to the object's state can make it difficult to find the key in the dictionary.</p>
    <p class="normal">We can go too far, of course. It is certainly possible to create a class with a mixture of mutable and immutable attributes and confine a customized hash computation to the mutable attributes. Because of the differences in behavior between the mutable and immutable features, this seems like it's really two objects that collaborate, not a single object with mutable <a id="_idIndexMarker466"/>and immutable features. We can use the immutable part for dictionary keys and keep the mutable part in the dictionary value.</p>
    <p class="normal">In contrast, there are no limits on the types of objects that can be used as dictionary values. We can use a string key that maps to a list value, for example, or we can have a nested dictionary as a value in another dictionary.</p>
    <h2 id="_idParaDest-139" class="title">Dictionary use cases</h2>
    <p class="normal">Dictionaries are <a id="_idIndexMarker467"/>extremely versatile and have numerous uses. Here are two major examples:</p>
    <ul>
      <li class="bullet">We can have dictionaries where all the values are different instances of objects with the same type. For example, our stock dictionary would have a type hint of <code class="Code-In-Text--PACKT-">dict[str, tuple[float, float, float]]</code>. The string key maps to a three-tuple of values. We use the stock symbol as an index to price details. If we had a more complex <code class="Code-In-Text--PACKT-">Stock</code> class, we might have a dictionary with <code class="Code-In-Text--PACKT-">dict[str, Stock]</code> as the type hint for an index into these objects.</li>
      <li class="bullet">The second design is to have each key represent some aspect or attribute of a single object; the values often have distinct types. We may, for example, represent a stock with <code class="Code-In-Text--PACKT-">{'name': 'GOOG', 'current': 1245.21, 'range': (1252.64, 1245.18)}</code>. This case clearly overlaps with named tuples, dataclasses, and objects in general. Indeed, there's a special type hint for this kind of dictionary, called a <code class="Code-In-Text--PACKT-">TypedDict</code>, that looks like a <code class="Code-In-Text--PACKT-">NamedTuple</code> type hint.</li>
    </ul>
    <p class="normal">This second example can be confusing; how do we decide how to represent attribute values of an object? We can rank the techniques like this.</p>
    <ol>
      <li class="numbered">For a lot of cases, dataclasses offer a number of helpful features with less code writing. They can be immutable, or mutable, giving us a wide range of options.</li>
      <li class="numbered">For cases where the data is immutable, a <code class="Code-In-Text--PACKT-">NamedTuple</code> can be slightly more efficient than a frozen dataclass by about 5% – not much. What tips the balance here is an expensive attribute computation. While a <code class="Code-In-Text--PACKT-">NamedTuple</code> can have properties, if the computation is very costly and the results are used frequently, it can help to compute it in advance, something a <code class="Code-In-Text--PACKT-">NamedTuple</code> isn't good at. Check out the documentation for dataclasses and their <code class="Code-In-Text--PACKT-">__post_init__()</code> method as a better choice in the rare case where it's helpful to compute an attribute value in advance.</li>
      <li class="numbered">Dictionaries are ideal when the complete set of keys isn't known in advance. When we're starting a design, we may have throwaway prototypes or proofs of concept using dictionaries. When we try to write unit tests and type hints, we may need to ramp up the formality. In some cases, the domain of possible keys is known, and a <code class="Code-In-Text--PACKT-">TypedDict</code> type hint makes sense as a way to characterize the valid keys and value types.</li>
    </ol>
    <p class="normal">Because of the similar syntax, it's relatively easy to try different designs to see which works better <a id="_idIndexMarker468"/>for the problem, which is faster, which is easier to test, and which uses less memory. Sometimes, all three converge and there's one best choice. More often, it's a trade-off.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Technically, most classes are implemented using dictionaries under the hood. You can see this by loading an object into the interactive interpreter and looking at the <code class="Code-In-Text--PACKT-">__dict__</code> special attribute, if it's present. When you access an attribute on an object using syntax like <code class="Code-In-Text--PACKT-">obj.attr_name</code>, this is effectively <code class="Code-In-Text--PACKT-">obj.__dict__['attr_name']</code> under the hood. It's actually a bit more complicated, involving <code class="Code-In-Text--PACKT-">__getattr__()</code> and <code class="Code-In-Text--PACKT-">__getattribute__()</code>, but you get the gist. Even dataclasses have a <code class="Code-In-Text--PACKT-">__dict__</code> attribute, which just goes to show how widely used dictionaries really are. They aren't universal, but they are common.</p>
    </div>
    <h2 id="_idParaDest-140" class="title">Using defaultdict</h2>
    <p class="normal">We've seen how to use the <code class="Code-In-Text--PACKT-">setdefault</code> method to set a default value if a key doesn't exist, but this can get a bit <a id="_idIndexMarker469"/>monotonous if we need to set a default value every time we look up a value. For example, if we're writing code that counts the number of times a letter occurs in a given sentence, we could do the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">letter_frequency</span><span class="hljs-function">(</span><span class="hljs-params">sentence: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; dict[str, int]:</span>
    frequencies: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = {}
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> sentence:
        frequency = frequencies.setdefault(letter, <span class="hljs-number">0</span>)
        frequencies[letter] = frequency + <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> frequencies
</code></pre>
    <p class="normal">Every time we access the dictionary, we need to check that it has a value already, and if not, set it to zero. When something like this needs to be done every time an empty key is requested, we can create a different version of a dictionary. The <code class="Code-In-Text--PACKT-">defaultdict</code>, defined in the <code class="Code-In-Text--PACKT-">collections</code> module, handles missing keys elegantly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">letter_frequency_2</span><span class="hljs-function">(</span><span class="hljs-params">sentence: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; defaultdict[str, int]:</span>
    frequencies: defaultdict[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = defaultdict(<span class="hljs-built_in">int</span>)
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> sentence:
        frequencies[letter] += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> frequencies
</code></pre>
    <p class="normal">This code looks odd: the <code class="Code-In-Text--PACKT-">defaultdict()</code> evaluation accepts a function, <code class="Code-In-Text--PACKT-">int</code>, in its constructor. We're not evaluating the <code class="Code-In-Text--PACKT-">int()</code> function; we're providing a reference to this function to <code class="Code-In-Text--PACKT-">defaultdict()</code>. Whenever a key is accessed that is not already in the dictionary, it calls that function, with no parameters, to create a default value. </p>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">defaultdict[str, int]</code> type hint is slightly wordier than the <code class="Code-In-Text--PACKT-">defaultdict()</code> evaluation itself. The <code class="Code-In-Text--PACKT-">defaultdict()</code> class only needs a function that will create default values. The type of the keys doesn't actually matter at runtime; any object with a <code class="Code-In-Text--PACKT-">__hash__()</code> method will work. When using <code class="Code-In-Text--PACKT-">defaultdict</code> as a type hint, though, it needs some additional details before we can be <strong class="" style="font-style: italic;">sure</strong> this will work. We need to provide both the type of the key – <code class="Code-In-Text--PACKT-">str</code>, in this example – and the type of object that will be associated with the key – <code class="Code-In-Text--PACKT-">int</code>, in this example.</p>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">frequencies</code> object uses the function <code class="Code-In-Text--PACKT-">int()</code> to create default values. This is the <a id="_idIndexMarker470"/>constructor for an integer object. Normally, integers are created as a literal, by typing an integer number into our code. If we do create an integer using the <code class="Code-In-Text--PACKT-">int()</code> constructor, it's often part of a conversion; for example, to convert a string of digits into an integer, like <code class="Code-In-Text--PACKT-">int("42")</code>. But if we call <code class="Code-In-Text--PACKT-">int()</code> without any arguments, it returns, conveniently, the number zero. In this code, if a letter doesn't exist in the <code class="Code-In-Text--PACKT-">defaultdict</code>, the number zero is created by the factory function and returned when we access it. Then, we add one to this number to indicate that we've found an instance of that letter and save the updated value back into the dictionary. The next time we find the same character, the new number will be returned and we can increment the value and save it back into the dictionary.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">defaultdict()</code> is useful for creating dictionaries of containers. If we want to create a dictionary of closing stock prices for the past 30 days, we could use a stock symbol as the key and store the prices in a <code class="Code-In-Text--PACKT-">list</code>; the first time we access the stock price, we would want to create an empty list. Simply pass the <code class="Code-In-Text--PACKT-">list</code> function into the <code class="Code-In-Text--PACKT-">defaultdict</code>, like this: <code class="Code-In-Text--PACKT-">defaultdict(list)</code>. The <code class="Code-In-Text--PACKT-">list()</code> function will be called every time a previously unknown key is accessed. We can do similar things with sets or even empty dictionaries if we want to use a subsidiary dictionary as the value for a key.</p>
    <p class="normal">Of course, we can also write our own functions and pass them into the <code class="Code-In-Text--PACKT-">defaultdict</code>. Suppose we want to create a <code class="Code-In-Text--PACKT-">defaultdict</code> where each key maps to a dataclass with information about that key. If we define our dataclass with default values, then our class name will work as a function without arguments. </p>
    <p class="normal">Consider this dataclass, <code class="Code-In-Text--PACKT-">Prices</code>, with all default values:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> dataclasses </span><span class="hljs-con-keyword">import</span><span class="python"> dataclass</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@dataclass</span>
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">Prices</span><span class="hljs-con-class">:</span>
<span class="hljs-con-meta">...</span> <span class="python">    current: </span><span class="hljs-con-built_in">float</span><span class="python"> = </span><span class="hljs-con-number">0.0</span>
<span class="hljs-con-meta">...</span> <span class="python">    high: </span><span class="hljs-con-built_in">float</span><span class="python"> = </span><span class="hljs-con-number">0.0</span>
<span class="hljs-con-meta">...</span> <span class="python">    low: </span><span class="hljs-con-built_in">float</span><span class="python"> = </span><span class="hljs-con-number">0.0</span>
<span class="hljs-con-meta">...</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">Prices() </span>
Prices(current=0.0, high=0.0, low=0.0)
</code></pre>
    <p class="normal">Since the class has default values for all attributes, we can use the class name without argument values <a id="_idIndexMarker471"/>and get a useful object. This means our class name will work as the argument to the <code class="Code-In-Text--PACKT-">defaultdict()</code> function:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">portfolio = collections.defaultdict(Prices)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">portfolio[</span><span class="hljs-con-string">"GOOG"</span><span class="python">]</span>
Prices(current=0.0, high=0.0, low=0.0)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">portfolio[</span><span class="hljs-con-string">"AAPL"</span><span class="python">] = Prices(current=</span><span class="hljs-con-number">122.25</span><span class="python">, high=</span><span class="hljs-con-number">137.98</span><span class="python">, low=</span><span class="hljs-con-number">53.15</span><span class="python">)</span>
</code></pre>
    <p class="normal">When we print <code class="Code-In-Text--PACKT-">portfolio</code>, we see how the default objects were saved in the dictionary:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> pprint </span><span class="hljs-con-keyword">import</span><span class="python"> pprint</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pprint(portfolio)</span>
defaultdict(&lt;class 'dc_stocks.Prices'&gt;,
            {'AAPL': Prices(current=122.25, high=137.98, low=53.15),
             'GOOG': Prices(current=0.0, high=0.0, low=0.0)})
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">portfolio</code> dictionary creates a default <code class="Code-In-Text--PACKT-">Prices</code> object for unknown keys. This works because the <code class="Code-In-Text--PACKT-">Prices</code> class had default values for all of the attributes.</p>
    <p class="normal">We can extend this even further. What if we want prices for stocks grouped by month? We want a dictionary with a key of the stock name. Within that we want dictionaries keyed by month. And within that inner dictionary, we want prices. This can be tricky because we want a default function that takes zero arguments and creates a <code class="Code-In-Text--PACKT-">defaultdict(Prices)</code> for us. We can define a one-line function:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">make_defaultdict</span><span class="hljs-con-function">():</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> collections.defaultdict(Prices)</span>
</code></pre>
    <p class="normal">We can also use a Python lambda form – a no-name, one expression function for this. A lambda can have parameters, but we don't need any. The single expression is the object we'd like created as a default.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">by_month = collections.defaultdict(</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">lambda</span><span class="python">: collections.defaultdict(Prices)</span>
<span class="hljs-con-meta">...</span> <span class="python">)</span>
</code></pre>
    <p class="normal">Now we can <a id="_idIndexMarker472"/>have nested <code class="Code-In-Text--PACKT-">defaultdict</code> dictionaries. When a key is missing, a proper default is built.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">by_month[</span><span class="hljs-con-string">"APPL"</span><span class="python">][</span><span class="hljs-con-string">"Jan"</span><span class="python">] = Prices(current=</span><span class="hljs-con-number">122.25</span><span class="python">, high=</span><span class="hljs-con-number">137.98</span><span class="python">, low=</span><span class="hljs-con-number">53.15</span><span class="python">)</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">by_month</code> collection's top-level key points to an internal dictionary. The internal dictionary has prices for each month. </p>
    <h3 id="_idParaDest-141" class="title">Counter</h3>
    <p class="normal">You'd think that <a id="_idIndexMarker473"/>algorithms could not get much simpler than using <code class="Code-In-Text--PACKT-">defaultdict(int)</code>. The <em class="italic">I want to count specific instances in an iterable</em> use case is common enough that the Python developers created a specific class for this exact purpose, simplifying things even further. The previous code that counts characters in a string can easily be calculated in a single line:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">letter_frequency_3</span><span class="hljs-function">(</span><span class="hljs-params">sentence: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; Counter[str]:</span>
    <span class="hljs-keyword">return</span> Counter(sentence)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Counter</code> object behaves like a beefed-up dictionary where the keys are the items being counted and the values are the quantities of such items. One of the most useful functions is the <code class="Code-In-Text--PACKT-">most_common()</code> method. It returns a list of <code class="Code-In-Text--PACKT-">(key,count)</code> tuples in descending order by the count. You can optionally pass an integer argument into <code class="Code-In-Text--PACKT-">most_common()</code> to request a list of only the most common elements. For example, you could write a simple polling application as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> collections</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">responses = [</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"vanilla"</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"chocolate"</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"vanilla"</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"vanilla"</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"caramel"</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"strawberry"</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"vanilla"</span><span class="python"> </span>
<span class="hljs-con-meta">...</span> <span class="python">]</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">favorites = collections.Counter(responses).most_common(</span><span class="hljs-con-number">1</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">name, frequency = favorites[</span><span class="hljs-con-number">0</span><span class="python">]</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">name</span>
'vanilla'
</code></pre>
    <p class="normal">Presumably, you'd get the responses from a database or by using a computer vision algorithm to count the kids who raised their hands. Here, we hardcoded the <code class="Code-In-Text--PACKT-">responses</code> object with literal <a id="_idIndexMarker474"/>values so that we can test the <code class="Code-In-Text--PACKT-">most_common()</code> method. This method always returns a list, even when we only asked for one element. The hint is effectively <code class="Code-In-Text--PACKT-">list[tuple[T, int]]</code> where <code class="Code-In-Text--PACKT-">T</code> is the type we're counting. In our example, where we're counting strings, the hint for the <code class="Code-In-Text--PACKT-">most_common()</code> method is <code class="Code-In-Text--PACKT-">list[tuple[str, int]]</code>. We only want the first item from a one-item list, so <code class="Code-In-Text--PACKT-">[0]</code> is required. We can then decompose the two-tuple into the value that was counted and the integer count.</p>
    <p class="normal">Speaking of lists, it's time to dig a little more deeply into Python's list collection.</p>
    <h1 id="_idParaDest-142" class="title">Lists</h1>
    <p class="normal">Python's generic list structure is integrated into a number of language features. We don't need to <a id="_idIndexMarker475"/>import them and rarely need to use method syntax to access their features. We can visit all the items in a list without explicitly requesting an iterator object, and we can construct a list (as with a dictionary) with very simple-looking syntax. Further, list comprehensions and generator expressions turn them into a veritable Swiss Army knife of computing functionality.</p>
    <p class="normal">If you don't know how to create or append to a list, how to retrieve items from a list, or what <em class="italic">slice notation</em> is, we direct you to the official Python tutorial, posthaste. It can be found online at <a href="http://docs.python.org/3/tutorial/"><span class="url">http://docs.python.org/3/tutorial/</span></a>. In this section, we'll move beyond the basics to cover when lists should be used, and their nature as objects.</p>
    <p class="normal">In Python, lists should normally be used when we want to store several instances of the <em class="italic">same</em> type of object; lists of strings or lists of numbers. We'll often use a type hint <code class="Code-In-Text--PACKT-">list[T]</code> to specify the type, <code class="Code-In-Text--PACKT-">T</code>, of object kept in the list, for example, <code class="Code-In-Text--PACKT-">list[int]</code> or <code class="Code-In-Text--PACKT-">list[str]</code>. </p>
    <p class="normal">(Remember that <code class="Code-In-Text--PACKT-">from __future__ import annotations</code> is required for this to work.) Lists must be used when we want to store items in some kind of order. Often, this is the order in which they were inserted, but they can also be sorted by other criteria.</p>
    <p class="normal">Lists are mutable, so items can be added, replaced, and removed from the list. This can be handy for reflecting the state of some more complex objects.</p>
    <p class="normal">Like dictionaries, Python lists use an extremely efficient and well-tuned internal data structure so we can worry about what we're storing, rather than how we're storing it. Python expands on <a id="_idIndexMarker476"/>lists to provide some specialized data structures for queues and stacks. Python doesn't make a distinction between lists based on arrays or lists that use links. Generally, the built-in list data structure can serve a wide variety of purposes.</p>
    <p class="normal">Don't use lists for collecting different attributes of individual items. Tuples, named tuples, dictionaries, and objects would all be more suitable for collecting different kinds of attribute values. Our first <code class="Code-In-Text--PACKT-">Stock</code> data examples at the beginning of the chapter stored current price, minimum price, and maximum price, each a different attribute with a distinct meaning in a single sequence. This isn't really ideal, and named tuples or dataclasses were clearly superior.</p>
    <p class="normal">Here's a rather convoluted counterexample that demonstrates how we could perform the frequency example using a list. It is much more complicated than the dictionary examples and illustrates the effect that choosing the right (or wrong) data structure can have on the readability (and performance) of our code. This is demonstrated as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> annotations
<span class="hljs-keyword">import</span> string
CHARACTERS = <span class="hljs-built_in">list</span>(string.ascii_letters) + [<span class="hljs-string">" "</span>]
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">letter_frequency</span><span class="hljs-function">(</span><span class="hljs-params">sentence: </span><span class="hljs-built_in">str</span><span class="hljs-function">) -&gt; list[tuple[str, int]]:</span>
    frequencies = [(c, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> CHARACTERS]
    <span class="hljs-keyword">for</span> letter <span class="hljs-keyword">in</span> sentence:
        index = CHARACTERS.index(letter)
        frequencies[index] = (letter, frequencies[index][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)
    non_zero = [
        (letter, count) 
        <span class="hljs-keyword">for</span> letter, count <span class="hljs-keyword">in</span> frequencies <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">0</span>
<span class="hljs-number">    </span>]
    <span class="hljs-keyword">return</span> non_zero
</code></pre>
    <p class="normal">This code starts with a list of possible characters. The <code class="Code-In-Text--PACKT-">string.ascii_letters</code> attribute provides a string of all the letters, lowercase and uppercase, in order. We convert this to a list and then use list concatenation (the <code class="Code-In-Text--PACKT-">+</code> operator causes two lists to be concatenated into one) to add one more character, a space. These are the available characters in our frequency list (the code would break if we tried to add a letter that wasn't in the list).</p>
    <p class="normal">The first line inside the function uses a list comprehension to turn the <code class="Code-In-Text--PACKT-">CHARACTERS</code> list into a list of tuples. Then, we loop over each of the characters in the sentence. We first look up the index of the character in the <code class="Code-In-Text--PACKT-">CHARACTERS</code> list, which we know has the same index in our frequencies list, since we created the second list from the first. We then update that index <a id="_idIndexMarker477"/>in the frequencies list by creating a new tuple, discarding the original one. Aside from garbage collection and memory waste concerns, this is rather difficult to read!</p>
    <p class="normal">Finally, we filter the list by examining each tuple and keeping only pairs where the count is greater than zero. This removes the letters we allocated space for but never saw.</p>
    <p class="normal">Besides being longer, the <code class="Code-In-Text--PACKT-">CHARACTERS.index(letter)</code> operation can be very slow. The worst case is to examine each of the characters in the list for a match. On average, it will search half the list. Compare this with a dictionary that does a hash computation and examines one item for a match. (Except in the case of a hash collision where there's a tiny probability of examining more than one and it has to handle hash collision with a second lookup.)</p>
    <p class="normal">The type hint describes the type of the objects in the list. We summarized it as <code class="Code-In-Text--PACKT-">list[tuple[str, int]]</code>. Each of the items in the resulting list will be a two-tuple. This lets <strong class="" style="font-style: italic;">mypy</strong> confirm that the operations respect the structure of the list overall and each tuple within the list.</p>
    <p class="normal">Like dictionaries, lists are objects, too. They have several methods that can be invoked upon them. Here are some common ones:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">append(element)</code> method adds an element to the end of the list</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">insert(index, element)</code> method inserts an item at a specific position</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">count(element)</code> method tells us how many times an element appears in the list</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">index()</code> method tells us the index of an item in the list, raising an exception if it can't find it</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">find()</code> method does the same thing but returns <code class="Code-In-Text--PACKT-">-1</code> instead of raising an exception for missing items</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">reverse()</code> method does exactly what it says – turns the list around</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">sort()</code> method has some rather intricate object-oriented behaviors, which we'll cover now</li>
    </ul>
    <p class="normal">There are a few <a id="_idIndexMarker478"/>more that are less commonly used. The complete list of methods is in the <em class="italic">Sequence Types</em> section <a id="_idIndexMarker479"/>of the Python Standard Library documentation: <a href="https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range"><span class="url">https://docs.python.org/3.9/library/stdtypes.html#sequence-types-list-tuple-range</span></a>.</p>
    <h2 id="_idParaDest-143" class="title">Sorting lists</h2>
    <p class="normal">Without any parameters, the <code class="Code-In-Text--PACKT-">sort()</code> method of a <code class="Code-In-Text--PACKT-">list</code> object will generally do as expected. If we have a <code class="Code-In-Text--PACKT-">list[str]</code> object, the <code class="Code-In-Text--PACKT-">sort()</code> method will place the items in alphabetical order. This <a id="_idIndexMarker480"/>operation is case sensitive, so all capital letters will be sorted before lowercase letters; that is, <code class="Code-In-Text--PACKT-">Z</code> comes before <code class="Code-In-Text--PACKT-">a</code>. If it's a list of numbers, they will be sorted in numerical order. If a list of tuples is provided, the list is sorted by considering the elements in the tuple in order. If a mixture containing unsortable items is supplied, the sort will raise a <code class="Code-In-Text--PACKT-">TypeError</code> exception.</p>
    <p class="normal">If we want to place objects of classes we've defined ourselves into a list and make those objects sortable, we have to do a bit more work. The special <code class="Code-In-Text--PACKT-">__lt__()</code> method, which stands for <em class="italic">less than</em>, must be defined on the class to make instances of that class comparable. The <code class="Code-In-Text--PACKT-">sort</code> method on the list will access this method on each object to determine where it goes in the list. This method should return <code class="Code-In-Text--PACKT-">True</code> if our class is somehow less than the passed parameter, and <code class="Code-In-Text--PACKT-">False</code> otherwise. </p>
    <p class="normal">Often, when we need comparisons like this, we'll use a dataclass. As discussed in the <em class="italic">Dataclasses</em> section, the <code class="Code-In-Text--PACKT-">@dataclass(order=True)</code> decorator will assure that all of the comparison methods are built for us. A named tuple also has the ordering operations defined by default.</p>
    <p class="normal">One tricky <a id="_idIndexMarker481"/>situation that arises with sorting is handling a data structure sometimes called a <strong class="keyword">tagged union</strong>. A union is a description of an object where attributes are not <strong class="keyword">always</strong> relevant. If an attribute's relevance depends on another attribute's value, this can be seen as a union of distinct subtypes with a tag to distinguish between the two types. </p>
    <p class="normal">Here's some example data, where a tag value, the <strong class="keyword">Data Source</strong> column, is required to decide how best to deal with the remaining columns. Some values of <strong class="keyword">Data Source</strong> tell us to use the timestamp, where as other values tell us to use the creation date.</p>
    <table id="table001-3" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Data Source</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Timestamp</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Creation Date</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Name, Owner, etc.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Local</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1607280522.68012</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">"Some File", etc.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Remote</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">"2020-12-06T13:47:52.849153"</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">"Another File", etc.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Local</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1579373292.452993</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">"This File", etc.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Remote</p>
          </td>
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">"2020-01-18T13:48:12.452993"</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">"That File", etc.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">How can we sort these into a single, coherent order? We'd like to have a single, consistent data type in our list, but the source data has two subtypes with a tag. </p>
    <p class="normal">A simple-seeming <code class="Code-In-Text--PACKT-">if row.data_source == "Local":</code> can work to distinguish values, but it can be confusing logic for <strong class="" style="font-style: italic;">mypy</strong> to work with. One or two <em class="italic">ad hoc</em> <code class="Code-In-Text--PACKT-">if</code> statements aren't too bad, but the design principle of throwing <code class="Code-In-Text--PACKT-">if</code> statements at the problem isn't very scalable.</p>
    <p class="normal">In this example, we can consider <strong class="keyword">Timestamp</strong> as the preferred representation. This means we only need to compute timestamps from the creation date string for the items where the <a id="_idIndexMarker482"/>data source is "Remote." In this example, either the float value or the string would sort into order properly. This happens to work out well because the string is in the carefully designed ISO format. If it was in American month-day-year format, it would require conversion to a timestamp to be useful.</p>
    <p class="normal">Converting all of the various input formats to Python's native <code class="Code-In-Text--PACKT-">datetime.datetime</code> objects is another choice. This has the advantage of being distinct from any of the input formats. While this is a little more work, it gives us more flexibility because we're not tied to a source data format that may change in the future. The concept is to make every variant input format convert to a single, common <code class="Code-In-Text--PACKT-">datetime.datetime</code> instance.</p>
    <p class="normal">What's central is treating the two subtypes as if they're a single class of objects. This doesn't always work out well. Often this is a design constraint that sneaks up on us when we have additional customers or additional sources of data.</p>
    <p class="normal">We'll start an implementation with a single type that supports both subtypes of data. This is not ideal, but it matches the source data and is often how we start tackling this kind of data. Here's <a id="_idIndexMarker483"/>the essential class definition:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, cast, Any
<span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass
<span class="hljs-keyword">import</span> datetime
<span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MultiItem</span><span class="hljs-class">:</span>
    data_source: <span class="hljs-built_in">str</span>
    timestamp: Optional[<span class="hljs-built_in">float</span>]
    creation_date: Optional[<span class="hljs-built_in">str</span>]
    name: <span class="hljs-built_in">str</span>
    owner_etc: <span class="hljs-built_in">str</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__lt__</span><span class="hljs-function">(</span><span class="hljs-params">self, other: Any</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">if</span> self.data_source == <span class="hljs-string">"Local"</span>:
            self_datetime = datetime.datetime.fromtimestamp(
                cast(<span class="hljs-built_in">float</span>, self.timestamp)
            )
        <span class="hljs-keyword">else</span>:
            self_datetime = datetime.datetime.fromisoformat(
                cast(<span class="hljs-built_in">str</span>, self.creation_date)
            )
        <span class="hljs-keyword">if</span> other.data_source == <span class="hljs-string">"Local"</span>:
            other_datetime = datetime.datetime.fromtimestamp(
                cast(<span class="hljs-built_in">float</span>, other.timestamp)
            )
        <span class="hljs-keyword">else</span>:
            other_datetime = datetime.datetime.fromisoformat(
                cast(<span class="hljs-built_in">str</span>, other.creation_date)
            )
        <span class="hljs-keyword">return</span> self_datetime &lt; other_datetime
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__lt__()</code> method compares an object of the <code class="Code-In-Text--PACKT-">MultiItem</code> class to another instance of the same class. Because there are two implicit subclasses, we have to check the tag attributes, <code class="Code-In-Text--PACKT-">self.data_source</code> and <code class="Code-In-Text--PACKT-">other.data_source</code>, to see which of the various combinations of fields we're dealing with. We'll do a conversion from a timestamp or a string into a common representation. Then we can compare the two common representations.</p>
    <p class="normal">The conversion processing is nearly duplicate code. Later in this section, we will look at refactoring this to remove the redundancy. The <code class="Code-In-Text--PACKT-">cast()</code> operations are required to make it clear to <strong class="" style="font-style: italic;">mypy</strong> that the item will not be <code class="Code-In-Text--PACKT-">None</code>. While we know the rules that match the tag (the <strong class="keyword">Data Source</strong> column) and the two kinds of values, those rules need to be stated in a way <strong class="" style="font-style: italic;">mypy</strong> can exploit them. The <code class="Code-In-Text--PACKT-">cast()</code> is how we tell <strong class="" style="font-style: italic;">mypy</strong> what the data will be at runtime; there's no processing that actually happens.</p>
    <p class="normal">Note that our application could have incomplete type hints and we could run with a bug and an object that's not an instance of <code class="Code-In-Text--PACKT-">MultiItem</code> could be compared with an instance of <code class="Code-In-Text--PACKT-">MultiItem</code>. This will likely result in a runtime error. The <code class="Code-In-Text--PACKT-">cast()</code> is a claim about the intent and the design, with no runtime impact. Because of Python's duck typing, some unexpected type <a id="_idIndexMarker484"/>that has the right attributes can be used and will work. Unit testing is essential even with careful type hints.</p>
    <p class="normal">The following output illustrates this class in action when it comes to sorting:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">mi_0 = MultiItem(</span><span class="hljs-con-string">"Local"</span><span class="python">, </span><span class="hljs-con-number">1607280522.68012</span><span class="python">, </span><span class="hljs-con-literal">None</span><span class="python">, </span><span class="hljs-con-string">"Some File"</span><span class="python">, </span><span class="hljs-con-string">"etc. 0"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">mi_1 = MultiItem(</span><span class="hljs-con-string">"Remote"</span><span class="python">, </span><span class="hljs-con-literal">None</span><span class="python">, </span><span class="hljs-con-string">"2020-12-06T13:47:52.849153"</span><span class="python">, </span><span class="hljs-con-string">"Another File"</span><span class="python">, </span><span class="hljs-con-string">"etc. 1"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">mi_2 = MultiItem(</span><span class="hljs-con-string">"Local"</span><span class="python">, </span><span class="hljs-con-number">1579373292.452993</span><span class="python">, </span><span class="hljs-con-literal">None</span><span class="python">, </span><span class="hljs-con-string">"This File"</span><span class="python">, </span><span class="hljs-con-string">"etc. 2"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">mi_3 = MultiItem(</span><span class="hljs-con-string">"Remote"</span><span class="python">, </span><span class="hljs-con-literal">None</span><span class="python">, </span><span class="hljs-con-string">"2020-01-18T13:48:12.452993"</span><span class="python">, </span><span class="hljs-con-string">"That File"</span><span class="python">, </span><span class="hljs-con-string">"etc. 3"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file_list = [mi_0, mi_1, mi_2, mi_3]</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file_list.sort()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> pprint </span><span class="hljs-con-keyword">import</span><span class="python"> pprint</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">pprint(file_list)</span>
[MultiItem(data_source='Local', timestamp=1579373292.452993, creation_date=None, name='This File', owner_etc='etc. 2'),
 MultiItem(data_source='Remote', timestamp=None, creation_date='2020-01-18T13:48:12.452993', name='That File', owner_etc='etc. 3'),
 MultiItem(data_source='Remote', timestamp=None, creation_date='2020-12-06T13:47:52.849153', name='Another File', owner_etc='etc. 1'),
 MultiItem(data_source='Local', timestamp=1607280522.68012, creation_date=None, name='Some File', owner_etc='etc. 0')]
</code></pre>
    <p class="normal">The comparison rules were applied among the various subtypes that were conflated into a single class definition. If the rules are more complex, however, this can become unwieldy.</p>
    <p class="normal">Only the <code class="Code-In-Text--PACKT-">__lt__()</code> method is required to implement to enable sorting. To be complete, the class may also implement the similar <code class="Code-In-Text--PACKT-">__gt__()</code>, <code class="Code-In-Text--PACKT-">__eq__()</code>, <code class="Code-In-Text--PACKT-">__ne__()</code>, <code class="Code-In-Text--PACKT-">__ge__()</code>, and <code class="Code-In-Text--PACKT-">__le__()</code> methods. This ensures all of the <code class="Code-In-Text--PACKT-">&lt;</code>, <code class="Code-In-Text--PACKT-">&gt;</code>, <code class="Code-In-Text--PACKT-">==</code>, <code class="Code-In-Text--PACKT-">!=</code>, <code class="Code-In-Text--PACKT-">&gt;=</code>, and <code class="Code-In-Text--PACKT-">&lt;=</code> operators also work properly. You can get <a id="_idIndexMarker485"/>this for free by implementing <code class="Code-In-Text--PACKT-">__lt__()</code> and <code class="Code-In-Text--PACKT-">__eq__()</code>, and then applying the <code class="Code-In-Text--PACKT-">@total_ordering</code> class decorator to supply the rest:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> total_ordering
<span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional, cast
<span class="hljs-keyword">import</span> datetime
<span class="hljs-meta">@total_ordering</span>
<span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MultiItem</span><span class="hljs-class">:</span>
    data_source: <span class="hljs-built_in">str</span>
    timestamp: Optional[<span class="hljs-built_in">float</span>]
    creation_date: Optional[<span class="hljs-built_in">str</span>]
    name: <span class="hljs-built_in">str</span>
    owner_etc: <span class="hljs-built_in">str</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__lt__</span><span class="hljs-function">(</span><span class="hljs-params">self, other: </span><span class="hljs-string">"MultiItem"</span><span class="hljs-function">) -&gt; bool:</span>
        Exercise: rewrite this to follow the example of __eq__.
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__eq__</span><span class="hljs-function">(</span><span class="hljs-params">self, other: </span><span class="hljs-built_in">object</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> self.datetime == cast(MultiItem, other).datetime
<span class="hljs-meta">    @property</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">datetime</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; datetime.datetime:</span>
        <span class="hljs-keyword">if</span> self.data_source == <span class="hljs-string">"Local"</span>:
            <span class="hljs-keyword">return</span> datetime.datetime.fromtimestamp(
                cast(<span class="hljs-built_in">float</span>, self.timestamp))
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> datetime.datetime.fromisoformat(
                cast(<span class="hljs-built_in">str</span>, self.creation_date))
</code></pre>
    <p class="normal">We didn't repeat the <code class="Code-In-Text--PACKT-">__lt__()</code> method body; we encourage the reader to rewrite it to look more like the <code class="Code-In-Text--PACKT-">__eq__()</code> method. When we provide some combination of <code class="Code-In-Text--PACKT-">&lt;</code> (or <code class="Code-In-Text--PACKT-">&gt;</code>) and <code class="Code-In-Text--PACKT-">=</code>, the <code class="Code-In-Text--PACKT-">@total_order</code> decorator can deduce the remaining logic operator implementations. For example, <img src="../Images/B17070_07_001.png" alt="" style="height: 1em;"/>. The implementation of <code class="Code-In-Text--PACKT-">__ge__(self, other)</code> is <code class="Code-In-Text--PACKT-">not self &lt; other</code>.</p>
    <p class="normal">Note that our class method definitions are (very) narrowly focused on comparing <code class="Code-In-Text--PACKT-">timestamp</code> and <code class="Code-In-Text--PACKT-">creation_date</code> attributes among these objects. The definitions of these methods are – perhaps – less than ideal because they reflect exactly one use case of comparison. We often have two possible designs:</p>
    <ul>
      <li class="bullet">Define the comparison operations narrowly, focused on a specific use case. In this example, we compare only the timestamps and ignore all other attributes. This is inflexible but can be made very efficient.</li>
      <li class="bullet">Define the comparison operations broadly, often only supporting <code class="Code-In-Text--PACKT-">__eq__()</code> and <code class="Code-In-Text--PACKT-">__ne__()</code> because there are too many alternative ordering comparisons that could be used. We extract individual attribute comparison rules outside the class and make them part of the sorting operation.</li>
    </ul>
    <p class="normal">The second design strategy requires us to localize the comparison as part of evaluating the <code class="Code-In-Text--PACKT-">sort()</code> method, instead of making the comparison a general part of the class. The <code class="Code-In-Text--PACKT-">sort()</code> method can take an optional <code class="Code-In-Text--PACKT-">key</code> argument. We use this to provide a "key extraction" function to the <code class="Code-In-Text--PACKT-">sort()</code> method. This argument to <code class="Code-In-Text--PACKT-">sort()</code> is a function that translates each <a id="_idIndexMarker486"/>object in a list into an object that can somehow be compared. In our case, we'd like a function to extract either the <code class="Code-In-Text--PACKT-">timestamp</code> or the <code class="Code-In-Text--PACKT-">creation_date</code> for comparison. It looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SimpleMultiItem</span><span class="hljs-class">:</span>
    data_source: <span class="hljs-built_in">str</span>
    timestamp: Optional[<span class="hljs-built_in">float</span>]
    creation_date: Optional[<span class="hljs-built_in">str</span>]
    name: <span class="hljs-built_in">str</span>
    owner_etc: <span class="hljs-built_in">str</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">by_timestamp</span><span class="hljs-function">(</span><span class="hljs-params">item: SimpleMultiItem</span><span class="hljs-function">) -&gt; datetime.datetime:</span>
    <span class="hljs-keyword">if</span> item.data_source == <span class="hljs-string">"Local"</span>:
        <span class="hljs-keyword">return</span> datetime.datetime.fromtimestamp(
            cast(<span class="hljs-built_in">float</span>, item.timestamp))
    <span class="hljs-keyword">elif</span> item.data_source == <span class="hljs-string">"Remote"</span>:
        <span class="hljs-keyword">return</span> datetime.datetime.fromisoformat(
            cast(<span class="hljs-built_in">str</span>, item.creation_date))
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f"Unknown data_source in </span><span class="hljs-subst">{item!r}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">Here's how we use this <code class="Code-In-Text--PACKT-">by_timestamp()</code> function to compare objects using <code class="Code-In-Text--PACKT-">datetime</code> objects from each <code class="Code-In-Text--PACKT-">SimpleMultiItem</code> object:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file_list.sort(key=by_timestamp)</span>
</code></pre>
    <p class="normal">We've divorced the sorting rules from the class, leading to a pleasant simplification. We can leverage this kind of design to provide other kinds of sorts. We might, for example, sort by name only. This is slightly simpler because no conversion is required: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file_list.sort(key=</span><span class="hljs-con-keyword">lambda</span><span class="python"> item: item.name)</span>
</code></pre>
    <p class="normal">We've created a lambda object, a tiny no-name function that takes an item as an argument and returns the value of <code class="Code-In-Text--PACKT-">item.name</code>. A lambda is a function, but it doesn't have a name, and it can't have any statements. It only has a single expression. If you need statements (for example a try/except clause) you need a conventional function definition outside the <code class="Code-In-Text--PACKT-">sort()</code> method arguments.</p>
    <p class="normal">There are a few <a id="_idIndexMarker487"/>sort key operations that are so common that the Python team has supplied them so you don't have to write them yourself. For example, it is common to sort a list of tuples by something other than the first item in the list. The <code class="Code-In-Text--PACKT-">operator.attrgetter</code> method can be used as a key to do this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> operator</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">file_list.sort(key=operator.attrgetter(</span><span class="hljs-con-string">"name"</span><span class="python">))</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">attrgetter()</code> function fetches a specific attribute from an object. When working with tuples or dictionaries, <code class="Code-In-Text--PACKT-">itemgetter()</code> can be used to extract a specific item by name or position. There's even a <code class="Code-In-Text--PACKT-">methodcaller()</code>, which returns the result of a method call on the object being sorted. Refer to the <code class="Code-In-Text--PACKT-">operator</code> module documentation for more information.</p>
    <p class="normal">There's rarely one single sort order for data objects. Providing the key function as part of the <code class="Code-In-Text--PACKT-">sort()</code> method lets us define a wide variety of sorting rules without creating complex class definitions.</p>
    <p class="normal">After looking at dictionaries and now lists, we can turn our attention to sets.</p>
    <h1 id="_idParaDest-144" class="title">Sets</h1>
    <p class="normal">Lists are extremely <a id="_idIndexMarker488"/>versatile tools that suit many container object applications. But they are not useful when we want to ensure that objects in a list are unique. For example, a song library may contain many songs by the same artist. If we want to sort through the library and create a list of all the artists, we would have to check the list to see whether we've added the artist already, before we add them again.</p>
    <p class="normal">This is where sets come in. Sets come from mathematics, where they represent an unordered group of unique items. We can try to add an item to a set five times, but the "is a member of a set" doesn't change after the first time we add it.</p>
    <p class="normal">In Python, sets can hold any hashable object, not just strings or numbers. Hashable objects implement the <code class="Code-In-Text--PACKT-">__hash__()</code> method; these are the same objects that can be used as keys in dictionaries; so again, mutable lists, sets, and dictionaries are out. Like mathematical sets, they can <a id="_idIndexMarker489"/>store only one copy of each object. If we're trying to create a list of song artists, we can create a set of string names and simply add them to the set. This example starts with a list of <code class="Code-In-Text--PACKT-">(song, artist)</code> tuples and creates a set of the artists:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">song_library = [</span>
<span class="hljs-con-meta">...</span> <span class="python">    (</span><span class="hljs-con-string">"Phantom Of The Opera"</span><span class="python">, </span><span class="hljs-con-string">"Sarah Brightman"</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">    (</span><span class="hljs-con-string">"Knocking On Heaven's Door"</span><span class="python">, </span><span class="hljs-con-string">"Guns N' Roses"</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">    (</span><span class="hljs-con-string">"Captain Nemo"</span><span class="python">, </span><span class="hljs-con-string">"Sarah Brightman"</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">    (</span><span class="hljs-con-string">"Patterns In The Ivy"</span><span class="python">, </span><span class="hljs-con-string">"Opeth"</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">    (</span><span class="hljs-con-string">"November Rain"</span><span class="python">, </span><span class="hljs-con-string">"Guns N' Roses"</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">    (</span><span class="hljs-con-string">"Beautiful"</span><span class="python">, </span><span class="hljs-con-string">"Sarah Brightman"</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">    (</span><span class="hljs-con-string">"Mal's Song"</span><span class="python">, </span><span class="hljs-con-string">"Vixy and Tony"</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">]</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">artists = </span><span class="hljs-con-built_in">set</span><span class="python">()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> song, artist </span><span class="hljs-con-keyword">in</span><span class="python"> song_library:</span>
<span class="hljs-con-meta">...</span> <span class="python">    artists.add(artist)</span>
</code></pre>
    <p class="normal">There is no built-in syntax for an empty set as there is for lists and dictionaries; we create a set using the <code class="Code-In-Text--PACKT-">set()</code> constructor. However, we can use the curly braces (borrowed from dictionary syntax) to create a set, so long as the set contains values. If we use colons to separate pairs of values, it's a dictionary, as in <code class="Code-In-Text--PACKT-">{'key': 'value', 'key2': 'value2'}</code>. If we just separate values with commas, it's a set, as in <code class="Code-In-Text--PACKT-">{'value', 'value2'}</code>.</p>
    <p class="normal">Items can be added individually to the set using the <code class="Code-In-Text--PACKT-">add()</code> method, and updated in bulk using the <code class="Code-In-Text--PACKT-">update()</code> method. If we run the script shown above, we see that the set works as advertised:</p>
    <pre class="programlisting code"><code class="hljs-code">{<span class="hljs-string">'Sarah Brightman'</span>, <span class="hljs-string">"Guns N' Roses"</span>, <span class="hljs-string">'Vixy and Tony'</span>, <span class="hljs-string">'Opeth'</span>}
</code></pre>
    <p class="normal">If you're paying attention to the output, you'll notice that the items are not printed in the order they were added to the sets. Indeed each time you run this, you may see the items in a different order.</p>
    <p class="normal">Sets are inherently unordered due to a hash-based data structure used for efficient access to the members. Because of this lack of ordering, sets cannot have items looked up by index. The primary purpose of a set is to divide the world into two groups: <em class="italic">things that are in the set</em>, and <em class="italic">things that are not in the set</em>. It is easy to check whether an item is in a set or to loop over the items in a set, but if we want to sort or order them, we have to convert the set to a list. This output shows all three of these activities:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-string">"Opeth"</span><span class="python"> </span><span class="hljs-con-keyword">in</span><span class="python"> artists</span>
True
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">alphabetical = </span><span class="hljs-con-built_in">list</span><span class="python">(artists)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">alphabetical.sort()</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">alphabetical</span>
["Guns N' Roses", 'Opeth', 'Sarah Brightman', 'Vixy and Tony']
</code></pre>
    <p class="normal">This output is <a id="_idIndexMarker490"/>highly variable; any one of the possible orderings could be used, depending on the hash randomization in use.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> artist </span><span class="hljs-con-keyword">in</span><span class="python"> artists:</span>
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">f"</span><span class="hljs-con-subst">{artist}</span><span class="hljs-con-string"> plays good music"</span><span class="python">)</span>
<span class="hljs-con-meta">...</span>
Sarah Brightman plays good music
Guns N' Roses plays good music
Vixy and Tony play good music
Opeth plays good music
</code></pre>
    <p class="normal">The primary <em class="italic">feature</em> of a set is uniqueness. Sets are often used to deduplicate data. Sets are also used to create combinations, including unions and differences between collections. Most of the methods on the set type operate on other sets, allowing us to efficiently combine or compare the items in two or more sets.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">union</code> method is the most common and easiest to understand. It takes a second set as a parameter and returns a new set that contains all elements that are in <em class="italic">either</em> of the two sets; if an element is in both original sets, it will only show up once in the new set. Union is like a logical <code class="Code-In-Text--PACKT-">or</code> operation. Indeed, the <code class="Code-In-Text--PACKT-">|</code> operator can be used on two sets to perform the union operation, if you don't like calling methods.</p>
    <p class="normal">Conversely, the <code class="Code-In-Text--PACKT-">intersection</code> method accepts a second set and returns a new set that contains only those elements that are in <em class="italic">both</em> sets. It is like a logical <code class="Code-In-Text--PACKT-">and</code> operation, and can also be referenced using the <code class="Code-In-Text--PACKT-">&amp;</code> operator.</p>
    <p class="normal">Finally, the <code class="Code-In-Text--PACKT-">symmetric_difference</code> method tells us what's left; it is the set of objects that are in one set or the other, but not in both. It uses the <code class="Code-In-Text--PACKT-">^</code> operator. The following example illustrates these methods by comparing some artists preferred by two different people:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">dusty_artists = {</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"Sarah Brightman"</span><span class="python">,</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"Guns N' Roses"</span><span class="python">,</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"Opeth"</span><span class="python">,</span>
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">"Vixy and Tony"</span><span class="python">,</span>
<span class="hljs-con-meta">...</span> <span class="python">}</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">steve_artists = {</span><span class="hljs-con-string">"Yes"</span><span class="python">, </span><span class="hljs-con-string">"Guns N' Roses"</span><span class="python">, </span><span class="hljs-con-string">"Genesis"</span><span class="python">}</span>
</code></pre>
    <p class="normal">Here are three <a id="_idIndexMarker491"/>examples of union, intersection, and symmetric difference:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(</span><span class="hljs-con-string">f"All: </span><span class="hljs-con-subst">{dusty_artists | steve_artists}</span><span class="hljs-con-string">"</span><span class="python">)</span>
All: {'Genesis', "Guns N' Roses", 'Yes', 'Sarah Brightman', 'Opeth', 'Vixy and Tony'}
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(</span><span class="hljs-con-string">f"Both: </span><span class="hljs-con-subst">{dusty_artists.intersection(steve_artists)}</span><span class="hljs-con-string">"</span><span class="python">)</span>
Both: {"Guns N' Roses"}
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(</span>
<span class="hljs-con-meta">...</span> <span class="python">   </span><span class="hljs-con-string">f"Either but not both: </span><span class="hljs-con-subst">{dusty_artists ^ steve_artists}</span><span class="hljs-con-string">"</span>
<span class="hljs-con-meta">...</span> <span class="python">)</span>
Either but not both: {'Genesis', 'Sarah Brightman', 'Opeth', 'Yes', 'Vixy and Tony'}
</code></pre>
    <p class="normal">The union, intersection, and symmetric difference methods are commutative. We can say <code class="Code-In-Text--PACKT-">dusty_artists.union(steve_artists)</code> or <code class="Code-In-Text--PACKT-">steve_artists.union(dusty_artists)</code> and get the same general result. The order of values will vary because of hash randomization, but the same items will be present in both sets.</p>
    <p class="normal">There are also methods that return different results depending on who is the caller and who is the argument. These methods include <code class="Code-In-Text--PACKT-">issubset</code> and <code class="Code-In-Text--PACKT-">issuperset</code>, which are the inverse of each other. Both return a <code class="Code-In-Text--PACKT-">bool</code>.</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">issubset</code> method returns <code class="Code-In-Text--PACKT-">True</code> if all of the items in the calling set are also in the set passed as an argument. We can use the <code class="Code-In-Text--PACKT-">&lt;= </code>operator for this, also.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">issuperset</code> method returns <code class="Code-In-Text--PACKT-">True</code> if all of the items in the argument are also in the calling set. Thus, <code class="Code-In-Text--PACKT-">s.issubset(t)</code>,<code class="Code-In-Text--PACKT-"> s &lt;= t</code>, <code class="Code-In-Text--PACKT-">t.issuperset(s)</code>, and <code class="Code-In-Text--PACKT-">t &gt;= s</code> are all identical.</li>
      <li class="bullet">They will both return <code class="Code-In-Text--PACKT-">True</code> if <code class="Code-In-Text--PACKT-">t</code> contains all the elements in <code class="Code-In-Text--PACKT-">s</code>. (The <code class="Code-In-Text--PACKT-">&lt;</code> and <code class="Code-In-Text--PACKT-">&gt;</code> operators are for proper subsets and proper supersets; there are no named methods for these operations.)</li>
    </ul>
    <p class="normal">Finally, the <code class="Code-In-Text--PACKT-">difference</code> method returns all the elements that are in the calling set, but not in the set passed as an argument. The <code class="Code-In-Text--PACKT-">difference</code> method can also be represented by the <code class="Code-In-Text--PACKT-">-</code> operator. The following code illustrates these methods in action:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">artists = {</span><span class="hljs-con-string">"Guns N' Roses"</span><span class="python">, </span><span class="hljs-con-string">'Vixy and Tony'</span><span class="python">, </span><span class="hljs-con-string">'Sarah Brightman'</span><span class="python">, </span><span class="hljs-con-string">'Opeth'</span><span class="python">}</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">bands = {</span><span class="hljs-con-string">"Opeth"</span><span class="python">, </span><span class="hljs-con-string">"Guns N' Roses"</span><span class="python">}</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">artists.issuperset(bands)</span>
True
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">artists.issubset(bands)</span>
False
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">artists - bands</span>
{'Sarah Brightman', 'Vixy and Tony'}
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">bands.issuperset(artists)</span>
False
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">bands.issubset(artists)</span>
True
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">bands.difference(artists)</span>
set()
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">difference</code> method, in the <a id="_idIndexMarker492"/>final expression, returns an empty set, since there are no items in <code class="Code-In-Text--PACKT-">bands</code> that are not in <code class="Code-In-Text--PACKT-">artists</code>. Looked at another way, we start with the value in <code class="Code-In-Text--PACKT-">bands</code> and then remove all the items from <code class="Code-In-Text--PACKT-">artists</code>. It may be helpful to think of as the expression <code class="Code-In-Text--PACKT-">bands - artists</code>.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">union</code>, <code class="Code-In-Text--PACKT-">intersection</code>, and <code class="Code-In-Text--PACKT-">difference</code> methods can all take multiple sets as arguments; they will return, as we might expect, the set that is created when the operation is called on all the parameters.</p>
    <p class="normal">So, the methods on sets clearly suggest that sets are meant to operate on other sets, and that they are not just containers. If we have data coming in from two different sources and need to quickly combine them in some way, so as to determine where the data overlaps or is different, we can use set operations to efficiently compare them. Or, if we have data incoming that may contain duplicates of data that has already been processed, we can use sets to compare the two and process only the new data.</p>
    <p class="normal">Finally, it is valuable to know that sets are much more efficient than lists when checking for membership using the <code class="Code-In-Text--PACKT-">in</code> keyword. If you use the <code class="Code-In-Text--PACKT-">value in container</code> syntax on a set or a list, it will return <code class="Code-In-Text--PACKT-">True</code> if one of the elements in <code class="Code-In-Text--PACKT-">container</code> is equal to <code class="Code-In-Text--PACKT-">value</code>, and <code class="Code-In-Text--PACKT-">False</code> otherwise. However, in a list, it will look at every object in the container until it finds the value, whereas in a set, it simply hashes the value and checks for membership. This means <a id="_idIndexMarker493"/>that a set will find the value in the same amount of time no matter how big the container is, but a list will take longer and longer to search for a value as the list contains more and more values.</p>
    <h1 id="_idParaDest-145" class="title">Three types of queues</h1>
    <p class="normal">We'll look at an application of the list structure to create a queue. A queue is a special kind of buffer, summarized as <strong class="keyword">First In First Out</strong> (<strong class="keyword">FIFO</strong>). The idea is to act as a temporary stash so one <a id="_idIndexMarker494"/>part of an application can write to the queue while another part consumes items from the queue.</p>
    <p class="normal">A database might <a id="_idIndexMarker495"/>have a queue of data to be written to disk. When our application performs an update, the local cache version of the data is updated so all other applications can see the change. The write to the disk, however, may be placed in a queue for a writer to deal with a few milliseconds later.</p>
    <p class="normal">When we're looking at files and directories, a queue can be a handy place to stash details of the directories so they can be processed later. We'll often represent a directory as the path from the root of the filesystem to the file of interest. We'll look at <code class="Code-In-Text--PACKT-">Path</code> objects in detail in <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings, Serialization, and File Paths</em>. The algorithm works like this:</p>
    <pre class="programlisting code"><code class="hljs-code">queue starts empty
Add the base directory to the queue
While the queue <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty:
    Pop the first item <span class="hljs-keyword">from</span> the queue
    If the item <span class="hljs-keyword">is</span> a file:
        Process the item
    Else <span class="hljs-keyword">if</span> the item <span class="hljs-keyword">is</span> a directory:
        For each sub-item <span class="hljs-keyword">in</span> the directory:
           Add this sub-item to the queue
</code></pre>
    <p class="normal">We can visualize this list-like structure as growing via an <code class="Code-In-Text--PACKT-">append()</code> and shrinking via <code class="Code-In-Text--PACKT-">pop(0)</code>. It would look like this:</p>
    <figure class="mediaobject"><img src="../Images/B17070_07_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.1: Queue concept</p>
    <p class="normal">The idea is for <a id="_idIndexMarker496"/>the queue to grow and shrink: each directory grows the queue and each file shrinks the queue. Eventually, all the files and directories have been processed and the queue is empty. The original order is preserved by the FIFO rule.</p>
    <p class="normal">We have several ways to implement a queue in Python:</p>
    <ol>
      <li class="numbered" value="1">List using the <code class="Code-In-Text--PACKT-">pop()</code> and <code class="Code-In-Text--PACKT-">append()</code> methods of a list.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">collections.deque</code> structure, which supports <code class="Code-In-Text--PACKT-">popleft()</code> and <code class="Code-In-Text--PACKT-">append()</code> methods. A "deque" is a Double-Ended Queue. This is an elegant queue implementation that's faster than a simple list for the specific operations of appending and popping.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">queue</code> module provides a queue often used for multithreading, but it can also be used for our single thread to examine a directory tree. This uses <code class="Code-In-Text--PACKT-">get()</code> and <code class="Code-In-Text--PACKT-">put()</code> methods. Since this structure is designed for concurrency, it locks the data structure to assure that each change is atomic and can't be interrupted by other threads. For a non-concurrent application, the locking overhead is a performance penalty we can avoid. This is the subject of <em class="chapterRef">Chapter 14</em>, <em class="italic">Concurrency</em>.</li>
    </ol>
    <p class="normal">The <code class="Code-In-Text--PACKT-">heapq</code> module also provides a queue, but it does some extra processing that's irrelevant to this specific example. It keeps items in priority order, not the order they were put into the queue, breaking the FIFO expectation. We'll use this in <em class="chapterRef">Chapter 8</em>, in the <em class="italic">Functions are objects, too</em> section.</p>
    <p class="normal">Each of these implementations is slightly different. This suggests we want to create handy wrapper <a id="_idIndexMarker497"/>classes around them to provide a uniform interface. We can create class definitions like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ListQueue</span><span class="hljs-class">(</span><span class="hljs-params">List[Path]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">put</span><span class="hljs-function">(</span><span class="hljs-params">self, item: Path</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.append(item)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; Path:</span>
        <span class="hljs-keyword">return</span> self.pop(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">empty</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self) == <span class="hljs-number">0</span>
</code></pre>
    <p class="normal">This shows the three essential operations for a queue. We can put something into the queue, appending it to the end. We can get something from the queue, removing the item at the head of the queue. Finally, we can ask if the queue is empty. We've layered this on a list class by extending it to add three new methods: <code class="Code-In-Text--PACKT-">put()</code>,<code class="Code-In-Text--PACKT-"> get()</code>, and <code class="Code-In-Text--PACKT-">empty()</code>.</p>
    <p class="normal">Next is a slightly different implementation. The <code class="Code-In-Text--PACKT-">typing.Deque</code> type hint is the wrapper around the <code class="Code-In-Text--PACKT-">collections.deque</code> class. A recent change to Python changed the underlying <code class="Code-In-Text--PACKT-">collections.deque</code> class, removing the need for a special hint.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Deque
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">DeQueue</span><span class="hljs-class">(</span><span class="hljs-params">Deque[Path]</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">put</span><span class="hljs-function">(</span><span class="hljs-params">self, item: Path</span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.append(item)
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; Path:</span>
        <span class="hljs-keyword">return</span> self.popleft()
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">empty</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; bool:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self) == <span class="hljs-number">0</span>
</code></pre>
    <p class="normal">It's hard to see the distinction between this implementation and the generic list implementation. It turns out the <code class="Code-In-Text--PACKT-">popleft()</code> method is a higher-speed version of <code class="Code-In-Text--PACKT-">pop(0)</code> in a conventional list. Otherwise, this looks very similar to the list-based implementation.</p>
    <p class="normal">Here's a final version that uses the <code class="Code-In-Text--PACKT-">queue</code> module. This <code class="Code-In-Text--PACKT-">queue</code> module's implementation uses locks to prevent the data structure from being damaged by concurrent access across multiple threads. It's generally opaque to us, except as a tiny performance cost.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> queue
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> TYPE_CHECKING
<span class="hljs-keyword">if</span> TYPE_CHECKING:
    BaseQueue = queue.Queue[Path]  <span class="hljs-comment"># for mypy.</span>
<span class="hljs-keyword">else</span>:
    BaseQueue = queue.Queue  <span class="hljs-comment"># used at runtime.</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ThreadQueue</span><span class="hljs-class">(</span><span class="hljs-params">BaseQueue</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">This implementation <a id="_idIndexMarker498"/>works because we decided to use the <code class="Code-In-Text--PACKT-">Queue</code> class interface as the template for the other two classes. This meant we didn't have to do any real work to implement this class; this design was the overall target for the other class designs.</p>
    <p class="normal">The type hints, however, are rather complex-looking. The <code class="Code-In-Text--PACKT-">queue.Queue</code> class definition is also a generic type hint. When the code is being examined by <strong class="" style="font-style: italic;">mypy</strong>, the <code class="Code-In-Text--PACKT-">TYPE_CHECKING</code> variable is <code class="Code-In-Text--PACKT-">True</code>, and we need to provide a parameter to the generic type. When the <code class="Code-In-Text--PACKT-">TYPE_CHECKING</code> variable is <code class="Code-In-Text--PACKT-">False</code>, we're not using <strong class="" style="font-style: italic;">mypy</strong>, and the class name (without any additional parameters) is all that's needed to define a queue at runtime.</p>
    <p class="normal">These three classes are similar with respect to the three defined methods. We could define an abstract base class for them. Or we could provide the following type hint:</p>
    <pre class="programlisting code"><code class="hljs-code">PathQueue = Union[ListQueue, DeQueue, ThreadQueue]
</code></pre>
    <p class="normal">This <code class="Code-In-Text--PACKT-">PathQueue</code> type hint summarizes all three types, allowing us to define an object of any of these three classes to use for the final implementation choice.</p>
    <p class="normal">The question of "which is better" is answered by the standard response of "it depends on what you need to do." </p>
    <ul>
      <li class="bullet">For single-threaded applications, the <code class="Code-In-Text--PACKT-">collections.deque</code> is ideal; it's designed for this purpose.</li>
      <li class="bullet">For multi-threaded applications, the <code class="Code-In-Text--PACKT-">queue.Queue</code> is required to provide a data structure that can be read and written by multiple concurrent threads. We'll return to this in <em class="chapterRef">Chapter 14</em>, <em class="italic">Concurrency</em>.</li>
    </ul>
    <p class="normal">While we can often leverage a built-in structure, like the generic <code class="Code-In-Text--PACKT-">list</code> class, for a wide variety of purposes, it may not be ideal. The other two implementations offer advantages over the built-in list. Python's standard library, and the broader ecosystem of external packages <a id="_idIndexMarker499"/>available through the Python Package Index (PYPI), can provide improvements over generic structures. What's important is having a specific improvement before searching high and low for a "perfect" package. In our example, the performance difference between the <code class="Code-In-Text--PACKT-">deque</code> and the <code class="Code-In-Text--PACKT-">list</code> is small. The time is dominated by the OS work required to gather the raw data. For a large file system, perhaps spanning multiple hosts, the difference will add up.</p>
    <p class="normal">Python's object-orientation gives us the latitude to explore design alternatives. We should feel free to try more than one solution to a problem as a way to better understand the problem, and arrive at an acceptable solution.</p>
    <h1 id="_idParaDest-146" class="title">Case study</h1>
    <p class="normal">In this chapter's case study, we'll revisit our design, leveraging Python's <code class="Code-In-Text--PACKT-">@dataclass</code> definitions. This holds some potential for streamlining our design. We'll be looking at some choices and limitations; this will lead us to explore some difficult engineering trade-offs, where there isn't one obvious best approach.</p>
    <p class="normal">We'll also look at immutable <code class="Code-In-Text--PACKT-">NamedTuple</code> class definitions. These objects have no internal state changes, leading to the possibility of some design simplifications. This will also change our design to make less use of inheritance and more use of composition.</p>
    <h2 id="_idParaDest-147" class="title">Logical model</h2>
    <p class="normal">Let's review the design <a id="_idIndexMarker500"/>we have so far for our <code class="Code-In-Text--PACKT-">model.py</code> module. This shows the hierarchy of <code class="Code-In-Text--PACKT-">Sample</code> class definitions, used to reflect the various ways samples are used:</p>
    <figure class="mediaobject"><img src="../Images/B17070_07_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.2: Class diagram so far</p>
    <p class="normal">The various <code class="Code-In-Text--PACKT-">Sample</code> classes are a very good fit with the dataclass definition. These objects have a number of attributes, and the methods built automatically seem to fit the behaviors we want. Here's the revised <code class="Code-In-Text--PACKT-">Sample</code> class, implemented as a <code class="Code-In-Text--PACKT-">@dataclass</code> instead of being built entirely by hand:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> dataclasses <span class="hljs-keyword">import</span> dataclass, asdict
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Optional
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Sample</span><span class="hljs-class">:</span>
    sepal_length: <span class="hljs-built_in">float</span>
    sepal_width: <span class="hljs-built_in">float</span>
    petal_length: <span class="hljs-built_in">float</span>
    petal_width: <span class="hljs-built_in">float</span>
</code></pre>
    <p class="normal">We've used the <code class="Code-In-Text--PACKT-">@dataclass</code> decorator to create a class from the supplied attribute type hints. We can use the resulting <code class="Code-In-Text--PACKT-">Sample</code> class like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> model </span><span class="hljs-con-keyword">import</span><span class="python"> Sample</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">x = Sample(</span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-number">4</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">x</span>
Sample(sepal_length=1, sepal_width=2, petal_length=3, petal_width=4)
</code></pre>
    <p class="normal">This example shows how we create instances of a class defined with the <code class="Code-In-Text--PACKT-">@dataclass</code> decorator. Note that a representation function, <code class="Code-In-Text--PACKT-">__repr__()</code>, was automatically created for us; it displays a useful level of detail, as shown in the example above. This is very pleasant. It almost feels like cheating!</p>
    <p class="normal">Here are the definitions for some more of the <code class="Code-In-Text--PACKT-">Sample</code> class hierarchy.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">KnownSample</span><span class="hljs-class">(</span><span class="hljs-params">Sample</span><span class="hljs-class">):</span>
    species: <span class="hljs-built_in">str</span>
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestingKnownSample</span><span class="hljs-class">(</span><span class="hljs-params">KnownSample</span><span class="hljs-class">):</span>
    classification: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TrainingKnownSample</span><span class="hljs-class">(</span><span class="hljs-params">KnownSample</span><span class="hljs-class">):</span>
    <span class="hljs-string">"""Note: no classification instance variable available."""</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">This seems to cover the user stories described in <em class="chapterRef">Chapter 1</em>, <em class="italic">Object-Oriented Design</em>, and expanded in <em class="chapterRef">Chapter 4</em>, <em class="italic">Expecting the Unexpected</em>. We can provide training data, test the classifier, and handle the classification of unknown samples. We didn't have to write very much code and we get a lot of useful features.</p>
    <p class="normal">We do have a potential problem, however. While we are permitted to set a classification attribute on a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> instance, this doesn't seem to be a great idea. Here's an example, where we create a sample to be used for training, and then also set a classification attribute.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> model </span><span class="hljs-con-keyword">import</span><span class="python"> TrainingKnownSample</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1 = TrainingKnownSample(</span>
<span class="hljs-con-meta">...</span> <span class="python">    sepal_length=</span><span class="hljs-con-number">5.1</span><span class="python">, sepal_width=</span><span class="hljs-con-number">3.5</span><span class="python">, petal_length=</span><span class="hljs-con-number">1.4</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">    petal_width=</span><span class="hljs-con-number">0.2</span><span class="python">, species=</span><span class="hljs-con-string">"Iris-setosa"</span><span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1</span>
TrainingKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa')
# This is undesirable...
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1.classification = </span><span class="hljs-con-string">"wrong"</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1</span>
TrainingKnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa')
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1.classification</span>
'wrong'
</code></pre>
    <p class="normal">Generally, Python doesn't stop us from creating a new attribute, like <code class="Code-In-Text--PACKT-">classification</code>, in an object. This behavior could be the source of hidden bugs. (A good unit test will often expose these bugs.) Note the additional attribute is not reflected in the <code class="Code-In-Text--PACKT-">__repr__()</code> method processing or <code class="Code-In-Text--PACKT-">__eq__()</code> method comparisons for this class. It's not a serious problem. In later sections, we'll address it using frozen dataclasses as well as the <code class="Code-In-Text--PACKT-">typing.NamedTuple</code> class.</p>
    <p class="normal">The remaining classes <a id="_idIndexMarker501"/>in our model don't enjoy the same huge benefit from being implemented as dataclasses as the <code class="Code-In-Text--PACKT-">Sample</code> classes did. When a class has a lot of attributes, and few methods, then the <code class="Code-In-Text--PACKT-">@dataclass</code> definition is a big help.</p>
    <p class="normal">Another class to benefit the most from the <code class="Code-In-Text--PACKT-">@dataclass</code> treatment is the <code class="Code-In-Text--PACKT-">Hyperparameter</code> class. Here's the first part of the definition, with the method body omitted:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Hyperparameter</span><span class="hljs-class">:</span>
    <span class="hljs-string">"""A specific tuning parameter set with k and a distance algorithm"""</span>
    k: <span class="hljs-built_in">int</span>
    algorithm: Distance
    data: weakref.ReferenceType[<span class="hljs-string">"TrainingData"</span>]
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">classify</span><span class="hljs-function">(</span><span class="hljs-params">self, sample: Sample</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-string">"""The k-NN algorithm"""</span>
        ... 
</code></pre>
    <p class="normal">This reveals an interesting feature that is made available when we use <code class="Code-In-Text--PACKT-">from __future__ import annotations</code>. Specifically, the value of <code class="Code-In-Text--PACKT-">weakref.ReferenceType["TrainingData"]</code>has two distinct goals:</p>
    <ul>
      <li class="bullet">The <strong class="" style="font-style: italic;">mypy</strong> tool uses this to check type references. We must provide a qualifier, <code class="Code-In-Text--PACKT-">weakref.ReferenceType["TrainingData"]</code>. This uses a string as a forward reference to the yet-undefined <code class="Code-In-Text--PACKT-">TrainingData</code> class.</li>
      <li class="bullet">When evaluated at runtime by the <code class="Code-In-Text--PACKT-">@dataclass</code> decorator to build a class definition, the additional type qualifier isn't used.</li>
    </ul>
    <p class="normal">We've omitted <a id="_idIndexMarker502"/>the details of the <code class="Code-In-Text--PACKT-">classify()</code> method. We'll examine some alternative implementations in <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>.</p>
    <p class="normal">We haven't seen all the features of dataclasses. In the next section, we'll freeze them to help spot the kind of bug where a piece of training data is used for testing purposes.</p>
    <h2 id="_idParaDest-148" class="title">Frozen dataclasses</h2>
    <p class="normal">The general case for dataclasses is to create mutable objects. The state of an object can be changed by assigning new values to the attributes. This isn't always a desirable feature, and we can make a dataclass immutable.</p>
    <p class="normal">We can describe <a id="_idIndexMarker503"/>the UML diagram of the design by adding a stereotype of <code class="Code-In-Text--PACKT-">«Frozen»</code>. This notation can help to remind us of the implementation choice of making the object immutable. We must also respect an important rule of frozen dataclasses: an extension via inheritance must also be frozen.</p>
    <p class="normal">The definition of the frozen <code class="Code-In-Text--PACKT-">Sample</code> objects must be kept separate from the mutable objects that are part of processing an unknown or testing sample. This splits our design into two families of classes:</p>
    <ul>
      <li class="bullet">A small hierarchy of immutable classes, specifically <code class="Code-In-Text--PACKT-">Sample</code> and <code class="Code-In-Text--PACKT-">KnownSample</code></li>
      <li class="bullet">Some associated classes that leverage these frozen classes</li>
    </ul>
    <p class="normal">The related classes for testing samples, training samples, and unknown samples form a loose collection of classes with nearly identical methods and attributes. We can call this a "paddling" of related classes. This comes from the duck typing rule: "When I see a bird that walks like a duck and quacks like a duck, I call that bird a duck." Objects created from classes with the same attributes and methods are interchangeable, even though they lack a common abstract superclass.</p>
    <p class="normal">We can describe this revised design with a diagram like this:</p>
    <figure class="mediaobject"><img src="../Images/B17070_07_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.3: Revised class diagram with frozen classes</p>
    <p class="normal">Here's the <a id="_idIndexMarker504"/>change to the <code class="Code-In-Text--PACKT-">Sample</code> class hierarchy. It's relatively minor and easy to overlook the <code class="Code-In-Text--PACKT-">frozen=True</code> in a few places:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Sample</span><span class="hljs-class">:</span>
    sepal_length: <span class="hljs-built_in">float</span>
    sepal_width: <span class="hljs-built_in">float</span>
    petal_length: <span class="hljs-built_in">float</span>
    petal_width: <span class="hljs-built_in">float</span>
<span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">KnownSample</span><span class="hljs-class">(</span><span class="hljs-params">Sample</span><span class="hljs-class">):</span>
    species: <span class="hljs-built_in">str</span>
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestingKnownSample</span><span class="hljs-class">:</span>
    sample: KnownSample
    classification: Optional[<span class="hljs-built_in">str</span>] = <span class="hljs-literal">None</span>
<span class="hljs-meta">@dataclass(</span><span class="hljs-params">frozen=</span><span class="hljs-literal">True</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TrainingKnownSample</span><span class="hljs-class">:</span>
    <span class="hljs-string">"""Cannot be classified."""</span>
    sample: KnownSample
</code></pre>
    <p class="normal">When we create an instance of a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> or <code class="Code-In-Text--PACKT-">TestingKnownSample</code>, we have to respect <a id="_idIndexMarker505"/>the composition of these objects: there's a frozen <code class="Code-In-Text--PACKT-">KnownSample</code> object inside each of these classes. The following example shows one way to create a composite object.</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> model_f </span><span class="hljs-con-keyword">import</span><span class="python"> TrainingKnownSample, KnownSample</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1 = TrainingKnownSample(</span>
<span class="hljs-con-meta">...</span> <span class="python">    sample=KnownSample(</span>
<span class="hljs-con-meta">...</span> <span class="python">        sepal_length=</span><span class="hljs-con-number">5.1</span><span class="python">, sepal_width=</span><span class="hljs-con-number">3.5</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">        petal_length=</span><span class="hljs-con-number">1.4</span><span class="python">, petal_width=</span><span class="hljs-con-number">0.2</span><span class="python">, species=</span><span class="hljs-con-string">"Iris-setosa"</span>
<span class="hljs-con-meta">...</span> <span class="python">    )</span>
<span class="hljs-con-meta">...</span> <span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1</span>
TrainingKnownSample(sample=KnownSample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2, species='Iris-setosa'))
</code></pre>
    <p class="normal">This nested construction of a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> instance containing a <code class="Code-In-Text--PACKT-">KnownSample</code> object is explicit. It exposes the immutable <code class="Code-In-Text--PACKT-">KnownSample</code> object.</p>
    <p class="normal">The frozen design has a very pleasant consequence for detecting subtle bugs. The following example shows the exception raised by improper use of a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1.classification = </span><span class="hljs-con-string">"wrong"</span>
Traceback (most recent call last):
<span class="hljs-con-meta">...</span> <span class="python">details omitted</span>
dataclasses.FrozenInstanceError: cannot assign to field 'classification'
</code></pre>
    <p class="normal">We can't accidentally introduce a bug that changes a training instance.</p>
    <p class="normal">We get one more bonus feature that makes it easier to spot duplicates when allocating instances to the training set. The frozen versions of the <code class="Code-In-Text--PACKT-">Sample</code> (and <code class="Code-In-Text--PACKT-">KnownSample</code>) classes produce a consistent <code class="Code-In-Text--PACKT-">hash()</code> value. This makes it easier to locate duplicate values by examining the subset of items with a common hash value.</p>
    <p class="normal">Appropriate <a id="_idIndexMarker506"/>use of <code class="Code-In-Text--PACKT-">@dataclass</code> and <code class="Code-In-Text--PACKT-">@dataclass(frozen=True)</code> can be a big help in implementing object-oriented Python. These definitions provide a rich set of features with minimal code.</p>
    <p class="normal">One other technique available to us is similar to the frozen dataclass, the <code class="Code-In-Text--PACKT-">typing.NamedTuple</code>. We'll look at this next.</p>
    <h2 id="_idParaDest-149" class="title">NamedTuple classes</h2>
    <p class="normal">Using <code class="Code-In-Text--PACKT-">typing.NamedTuple</code> is somewhat similar to using <code class="Code-In-Text--PACKT-">@dataclass(frozen=True)</code>. There are some significant differences in the implementation details, however. In particular, the <code class="Code-In-Text--PACKT-">typing.NamedTuple</code> class does not support inheritance in the most obvious way. This leads <a id="_idIndexMarker507"/>us to a design based around composition of objects in the <code class="Code-In-Text--PACKT-">Sample</code> class hierarchy. With inheritance, we're often extending a base class to add features. With composition, we're often building multi-part objects of several different classes.</p>
    <p class="normal">Here's the definition of <code class="Code-In-Text--PACKT-">Sample</code> as <code class="Code-In-Text--PACKT-">NamedTuple</code>. It looks similar to the <code class="Code-In-Text--PACKT-">@dataclass</code> definition. The definition of <code class="Code-In-Text--PACKT-">KnownSample</code>, however, must change dramatically:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Sample</span><span class="hljs-class">(</span><span class="hljs-params">NamedTuple</span><span class="hljs-class">):</span>
    sepal_length: <span class="hljs-built_in">float</span>
    sepal_width: <span class="hljs-built_in">float</span>
    petal_length: <span class="hljs-built_in">float</span>
    petal_width: <span class="hljs-built_in">float</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">KnownSample</span><span class="hljs-class">(</span><span class="hljs-params">NamedTuple</span><span class="hljs-class">):</span>
    sample: Sample
    species: <span class="hljs-built_in">str</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">KnownSample</code> class is a composite, built from a <code class="Code-In-Text--PACKT-">Sample</code> instance, plus the species assigned when the data was loaded initially. Since these are both subclasses of <code class="Code-In-Text--PACKT-">typing.NamedTuple</code>, the values are immutable.</p>
    <p class="normal">We've shifted from inheritance to composition in our design. Here are the two concepts, side by side:</p>
    <figure class="mediaobject"><img src="../Images/B17070_07_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 7.4: Inheritance-based versus composition-based class designs</p>
    <p class="normal">The differences can be easy to overlook in the diagram:</p>
    <ul>
      <li class="bullet">Using an <strong class="keyword">inheritance-focused</strong> design, a <code class="Code-In-Text--PACKT-">KnownSample</code> instance is a <code class="Code-In-Text--PACKT-">Sample</code> instance. It has five attributes: all four attributes inherited from the <code class="Code-In-Text--PACKT-">Sample</code> class plus one attribute unique to the <code class="Code-In-Text--PACKT-">KnownSample</code> subclass.</li>
      <li class="bullet">Using a <strong class="keyword">composition-focused</strong> design, a <code class="Code-In-Text--PACKT-">KnownSample_C</code> instance is composed of a <code class="Code-In-Text--PACKT-">Sample</code> instance and a species classification. It has two attributes.</li>
    </ul>
    <p class="normal">As we've seen, both designs will work. The choice is difficult and often revolves around the number and the <a id="_idIndexMarker508"/>complexity of the methods that are inherited from the superclass. In this example, there are no methods of importance to the application defined in the <code class="Code-In-Text--PACKT-">Sample</code> class.</p>
    <p class="normal">The inheritance versus composition design decision represents a difficult choice with no single, right answer. The decision is often helped by a nuanced understanding of whether a subclass truly is a member of the superclass or not. Metaphorically, we often ask if an Apple is a Fruit to help understand narrower subclasses and generic superclasses. The problem we have is that an Apple can also be a Dessert, confounding what seemed to be a simple decision with additional details. </p>
    <p class="normal">Don't forget, an Apple (as applesauce) may be part of the Main Course, also. This kind of complication can make an "is-a" question harder to answer. In our case, the "is-a" relationship between samples, known samples, unknown samples, testing, and training samples may not be the best path forward. We seem to have multiple roles (i.e., testing, training, to-be-classified) that are associated with each sample, and there may only be two subclasses of <code class="Code-In-Text--PACKT-">Sample</code>, known and unknown.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">TestingKnownSample</code> and <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> class definitions follow the duck typing rule. They have similar attributes and can be used interchangeably in many cases.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TestingKnownSample</span><span class="hljs-class">:</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">        self, sample: KnownSample, classification: Optional[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span>
<span class="hljs-params">    </span><span class="hljs-function">) -&gt; </span><span class="hljs-keyword">None</span><span class="hljs-function">:</span>
        self.sample = sample
        self.classification = classification
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__repr__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">) -&gt; str:</span>
        <span class="hljs-keyword">return </span>(
<span class="hljs-string">            f"</span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-string">(sample=</span><span class="hljs-subst">{self.sample!r}</span><span class="hljs-string">," </span>
<span class="hljs-string">            f"classification=</span><span class="hljs-subst">{self.classification!r}</span><span class="hljs-string">)"</span>
<span class="hljs-string">        </span>)
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">TrainingKnownSample</span><span class="hljs-class">(</span><span class="hljs-params">NamedTuple</span><span class="hljs-class">):</span>
    sample: KnownSample
</code></pre>
    <p class="normal">In this case, both <code class="Code-In-Text--PACKT-">TestingKnownSample</code> and <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> are composite objects that contain a <code class="Code-In-Text--PACKT-">KnownSample</code> object. The primary difference is the presence (or absence) of an additional <a id="_idIndexMarker509"/>attribute, the <code class="Code-In-Text--PACKT-">classification</code> value.</p>
    <p class="normal">Here's an example of creating a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> and trying (erroneously) to set the classification:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> model_t </span><span class="hljs-con-keyword">import</span><span class="python"> TrainingKnownSample, KnownSample, Sample</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1 = TrainingKnownSample(</span>
<span class="hljs-con-meta">...</span> <span class="python">    sample=KnownSample(</span>
<span class="hljs-con-meta">...</span> <span class="python">        sample=Sample(sepal_length=</span><span class="hljs-con-number">5.1</span><span class="python">, sepal_width=</span><span class="hljs-con-number">3.5</span><span class="python">, </span>
<span class="hljs-con-meta">...</span> <span class="python">        petal_length=</span><span class="hljs-con-number">1.4</span><span class="python">, petal_width=</span><span class="hljs-con-number">0.2</span><span class="python">),</span>
<span class="hljs-con-meta">...</span> <span class="python">        species=</span><span class="hljs-con-string">"Iris-setosa"</span>
<span class="hljs-con-meta">...</span> <span class="python">    ),</span>
<span class="hljs-con-meta">...</span> <span class="python">)</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1</span>
TrainingKnownSample(sample=KnownSample(sample=Sample(sepal_length=5.1, sepal_width=3.5, petal_length=1.4, petal_width=0.2), species='Iris-setosa'))
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">s1.classification = </span><span class="hljs-con-string">"wrong"</span>
Traceback (most recent call last):
<span class="hljs-con-meta">...</span>
AttributeError: 'TrainingKnownSample' object has no attribute 'classification'
</code></pre>
    <p class="normal">The code reflects <a id="_idIndexMarker510"/>the composite-of-composite design. A <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> instance contains a <code class="Code-In-Text--PACKT-">KnownSample</code> object, which contains a <code class="Code-In-Text--PACKT-">Sample</code> object. The example shows that we cannot add a new attribute to a <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> instance.</p>
    <h2 id="_idParaDest-150" class="title">Conclusion</h2>
    <p class="normal">Up to now, we've seen a total of four ways to address object-oriented design and implementation.</p>
    <ul>
      <li class="bullet">In previous chapters, we've looked at creating objects "from scratch," writing all the method definitions ourselves. We've emphasized inheritance among the classes in the <code class="Code-In-Text--PACKT-">Sample</code> class hierarchy.</li>
      <li class="bullet">In this chapter, we've seen a stateful class definition using <code class="Code-In-Text--PACKT-">@dataclass</code>. This supports inheritance among the classes in the <code class="Code-In-Text--PACKT-">Sample</code> class hierarchy.</li>
      <li class="bullet">We've also seen a stateless (or immutable) definition using <code class="Code-In-Text--PACKT-">@dataclass(frozen=True)</code>. This tends to discourage some aspects of inheritance and favor composition.</li>
      <li class="bullet">Finally, we've looked at stateless (or immutable) definitions using <code class="Code-In-Text--PACKT-">NamedTuple</code>. This must be designed using composition. This preliminary overview of these classes makes the design seem quite simple. We'll return to this in <em class="chapterRef">Chapter 8</em>, <em class="italic">The Intersection of Object-Oriented and Functional Programming</em>.</li>
    </ul>
    <p class="normal">We have a lot of flexibility in Python. It's important to look at the choices from the viewpoint of our future self trying to add or alter features. It helps to follow the SOLID design principles and focus on Single Responsibility and Interface Segregation to isolate and encapsulate our class definitions.</p>
    <h1 id="_idParaDest-151" class="title">Recall</h1>
    <p class="normal">We've explored a variety of built-in Python data structures in this chapter. Python lets us do a great deal of object-oriented programming without the overheads of numerous, potentially confusing, class definitions. We can rely on a number of built-in classes where they fit our problem. </p>
    <p class="normal">In this chapter, we looked at the following:</p>
    <ul>
      <li class="bullet">Tuples and named tuples let us leverage a simple collection of attributes. We can extend the <code class="Code-In-Text--PACKT-">NamedTuple</code> definition to add methods when those are necessary.</li>
      <li class="bullet">Dataclasses provide sophisticated collections of attributes. A variety of methods can be provided for us, simplifying the code we need to write.</li>
      <li class="bullet">Dictionaries are an essential feature, used widely in Python. There are many places where keys are associated with values. The syntax for using the built-in dictionary class makes it easy to use. </li>
      <li class="bullet">Lists and sets are also first-class parts of Python; our applications can make use of these. </li>
      <li class="bullet">We also looked at three types of queues. These are more specialized structures with more focused patterns of access than a generic list object. The idea of specialization and narrowing the domain of features can lead to performance improvements, also, making the concept widely applicable.</li>
    </ul>
    <p class="normal">Additionally, in the case study, we looked at ways to use these built-in classes to define our data samples used for testing and training.</p>
    <h1 id="_idParaDest-152" class="title">Exercises</h1>
    <p class="normal">The best way to learn how to choose the correct data structure is to do it wrong a few times (intentionally or accidentally!). Take some code you've recently written, or write some new code that uses a list. Try rewriting it using some different data structures. Which ones make more sense? Which ones don't? Which have the most elegant code?</p>
    <p class="normal">Try this with a few different pairs of data structures. You can look at examples you've done for previous chapter exercises. Are there objects with methods where you could have used dataclasses, <code class="Code-In-Text--PACKT-">namedtuple</code>, or <code class="Code-In-Text--PACKT-">dict</code> instead? Attempt both and see. Are there dictionaries that could have been sets because you don't really access the values? Do you have lists that check for duplicates? Would a set suffice? Or maybe several sets? Would one of the queue implementations be more efficient? Is it useful to restrict the API to the top of a stack rather than allowing random access to the list?</p>
    <p class="normal">Have you written any container objects recently that you could improve by inheriting a built-in and overriding some of the <em class="italic">special</em> double-underscore methods? You may have to do some research (using <code class="Code-In-Text--PACKT-">dir</code> and <code class="Code-In-Text--PACKT-">help</code>, or the Python library reference) to find out which methods need overriding. </p>
    <p class="normal">Are you sure inheritance is the correct tool to apply; could a composition-based solution be more effective? Try both (if it's possible) before you decide. Try to find different situations where each method is better than the other.</p>
    <p class="normal">If you were familiar with the various Python data structures and their uses before you started this chapter, you may have been bored. But if that is the case, there's a good chance you use data structures too much! Look at some of your old code and rewrite it to use more self-made classes. Carefully consider the alternatives and try them all out; which one makes for the most readable and maintainable system?</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">MultiItem</code> example in this section started with a clunky-looking <code class="Code-In-Text--PACKT-">__lt__()</code> method. The second version had a slightly nicer <code class="Code-In-Text--PACKT-">__eq__()</code> method. Rewrite <code class="Code-In-Text--PACKT-">__lt__()</code> to follow the design pattern of <code class="Code-In-Text--PACKT-">__eq__()</code>.</p>
    <p class="normal">The bigger problem with the original class design was trying to handle the variety of subtypes and their optional fields. The presence of an optional attribute is a suggestion that – perhaps – there are distinct classes struggling to separate from each other. What happens if we distinguish between two closely related but distinct classes: <code class="Code-In-Text--PACKT-">LocalItem</code> (which uses <code class="Code-In-Text--PACKT-">timestamp</code>) and <code class="Code-In-Text--PACKT-">RemoteItem</code> (which uses <code class="Code-In-Text--PACKT-">created_date</code>). We can define a common type hint as a <code class="Code-In-Text--PACKT-">Union[LocalItem, RemoteItem]</code>. If each class has a property like <code class="Code-In-Text--PACKT-">creation_datetime</code> that computes a <code class="Code-In-Text--PACKT-">datetime.datetime</code> object, would processing be simpler? Build the two classes; create some test data. How does it look to separate the two subtypes?</p>
    <p class="normal">Always critically evaluate your code and design decisions. Make a habit of reviewing old code and take note of whether your understanding of <em class="italic">good design</em> has changed since you wrote it. Software design has a large aesthetic component, and like artists with oil on canvas, we all have to find the style that suits us best.</p>
    <h1 id="_idParaDest-153" class="title">Summary</h1>
    <p class="normal">We've covered several built-in data structures and attempted to understand how to choose one for specific applications. Sometimes, the best thing we can do is create a new class of objects, but often, one of the built-ins provides exactly what we need. When it doesn't, we can always use inheritance or composition to adapt them to our use cases. We can even override special methods to completely change the behavior of built-in syntaxes.</p>
    <p class="normal">In the next chapter, we'll discuss how to integrate the object-oriented and not-so-object-oriented aspects of Python. Along the way, we'll discover that it's more object-oriented than it looks at first sight!</p>
  </div>
</body></html>