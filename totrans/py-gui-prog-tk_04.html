<html><head></head><body>
  <div id="_idContainer071">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-79" class="chapterTitle">Organizing Our Code with Classes</h1>
    <p class="normal">Things are going great with your data entry form! Your boss and coworkers and excited to see the progress you've made and are already coming up with some ideas of what other features could be added. This makes you a little nervous, to be honest! While they see a professional-looking form, you know that the code underneath is getting bulky and repetitive. You've got some warts in there too, like a global variable and a very cluttered global namespace. Before you start adding more features, you'd like to get a handle on this code and start breaking it down into some manageable chunks. For this, you'll need to create <strong class="keyword">classes</strong>.</p>
    <p class="normal">In this chapter, we'll cover the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">A primer on Python classes</em>, we'll review how to create Python classes and subclasses.</li>
      <li class="bullet">In <em class="italic">Using classes with Tkinter</em>, we'll discover ways to utilize classes effectively in Tkinter code.</li>
      <li class="bullet">In <em class="italic">Rewriting our application using classes</em>, we'll apply these techniques to the ABQ Data Entry application.</li>
    </ul>
    <h1 id="_idParaDest-80" class="title">A primer on Python classes</h1>
    <p class="normal">While the concept of a class is simple enough on the surface, classes bring with them a number of terms and concepts that confuse many beginners. In this section, we'll discuss the advantages of using classes, explore the different features<a id="_idIndexMarker215"/> of classes, and review the syntax for creating classes in Python.</p>
    <h2 id="_idParaDest-81" class="title">The advantages of using classes</h2>
    <p class="normal">Many beginners<a id="_idIndexMarker216"/> and even intermediate Python coders avoid or dismiss the use of classes in Python; unlike functions or variables, classes do not have obvious uses in short, simple scripts. As our application code grows, however, classes become an indispensable tool for organizing our code into manageable units. Let's look at some ways classes can help us build cleaner code.</p>
    <h3 id="_idParaDest-82" class="title">Classes are an integral part of Python</h3>
    <p class="normal">A class is essentially a blueprint<a id="_idIndexMarker217"/> for creating an <strong class="keyword">object</strong>. What is an object? In Python, <em class="italic">everything</em> is an object: integers, strings, floats, lists, dictionaries, Tkinter widgets, and even functions are all objects. Each of these types of objects is defined by a class. You can see this easily at a Python prompt if you use the <code class="Code-In-Text--PACKT-">type</code> command, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(<span class="hljs-con-string">'hello world'</span>)
&lt;class 'str'&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(1)
&lt;class 'int'&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">type</span>(<span class="hljs-con-built_in">print</span>)
&lt;class 'builtin_function_or_method'&gt;
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">type</code> function shows you what class was used to construct<a id="_idIndexMarker218"/> the object in question. When an object is built from a particular class, we say it is an <strong class="keyword">instance</strong> of that class.</p>
    <div class="note">
      <p class="Information-Box--PACKT-"><em class="italic">Instance</em> and <em class="italic">object</em> are often used interchangeably, because every object is an instance of some class.</p>
    </div>
    <p class="normal">Because everything in Python is a class, creating our own classes allows us to work with custom objects using the same syntax we use with built-in objects.</p>
    <h3 id="_idParaDest-83" class="title">Classes make relationships between data and functions explicit</h3>
    <p class="normal">Often, in code, we have a set of data that all relates to the same thing. For example, in a multiplayer game, you might have variables for each player's score, health, or progress. Functions that operate on these variables would need to be sure to operate on the variables that refer to the same player. Classes would allow us to create an explicit relationship between these variables and the functions that operate on them, so that we can more easily keep them organized as a unit.</p>
    <h3 id="_idParaDest-84" class="title">Classes help create reusable code</h3>
    <p class="normal">Classes are a great tool for reducing code redundancy. Suppose we have a set of forms that have similar behavior<a id="_idIndexMarker219"/> on submission, but different input fields. Using class inheritance, we can create a base form with the desired common behaviors; then, we can derive the individual form classes from that, only having to implement what is unique in each form.</p>
    <h2 id="_idParaDest-85" class="title">Syntax of class creation</h2>
    <p class="normal">Creating a class<a id="_idIndexMarker220"/> is very similar to creating a function, except that we use the <code class="Code-In-Text--PACKT-">class</code> keyword, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Banana</span><span class="hljs-class">:</span>
  <span class="hljs-string">"""A tasty tropical fruit"""</span>
  <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">Note that we've also included a <strong class="keyword">docstring</strong>, which is used by Python tools (such as the built-in <code class="Code-In-Text--PACKT-">help</code> function) to generate<a id="_idIndexMarker221"/> documentation about the class. Class names in Python traditionally use <strong class="keyword">Pascal Case</strong>, meaning the first letter of each word is capitalized; sometimes, third-party<a id="_idIndexMarker222"/> libraries will use other conventions, however.</p>
    <p class="normal">Once we have defined a class, we can create instances of the class by calling it, just like a function:</p>
    <pre class="programlisting code"><code class="hljs-code">my_banana = Banana()
</code></pre>
    <p class="normal">In this case, <code class="Code-In-Text--PACKT-">my_banana</code> is an object that is an instance of the <code class="Code-In-Text--PACKT-">Banana</code> class. Of course, a more useful class will have some things defined<a id="_idIndexMarker223"/> inside the class body; specifically, we can define <strong class="keyword">attributes</strong> and <strong class="keyword">methods</strong>, which are collectively known as <strong class="keyword">members</strong>.</p>
    <h3 id="_idParaDest-86" class="title">Attributes and methods</h3>
    <p class="normal">Attributes<a id="_idIndexMarker224"/> are simply variables, and they can be either <strong class="keyword">class attributes</strong> or <strong class="keyword">instance attributes</strong>. A class attribute<a id="_idIndexMarker225"/> is defined in the top scope of the class body, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Banana</span><span class="hljs-class">:</span>
  <span class="hljs-string">"""A tasty tropical fruit"""</span>
  food_group = <span class="hljs-string">'fruit'</span>
  colors = [
    <span class="hljs-string">'green'</span>, <span class="hljs-string">'green-yellow'</span>, <span class="hljs-string">'yellow'</span>,
    <span class="hljs-string">'brown spotted'</span>, <span class="hljs-string">'black'</span>
  ]
</code></pre>
    <p class="normal">Class attributes<a id="_idIndexMarker226"/> are shared by all instances of the class, and are usually used for setting defaults, constants, and other read-only values.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that unlike class names, member names, by convention, use <strong class="keyword">snake case</strong>, where lowercase words<a id="_idIndexMarker227"/> are separated by underscores.</p>
    </div>
    <p class="normal">Instance attributes store values specific to a single instance of the class; to create one, we need access to an instance. We could do it like this:</p>
    <pre class="programlisting code"><code class="hljs-code">my_banana = Banana()
my_banana.color = <span class="hljs-string">'yellow'</span>
</code></pre>
    <p class="normal">However, it would be more ideal if we could define some instance attributes inside our class definition, instead of doing it externally like that. In order to do so, we need a reference to the instance<a id="_idIndexMarker228"/> of the class inside the class definition. This can be done with an <strong class="keyword">instance method</strong>.</p>
    <p class="normal">Methods<a id="_idIndexMarker229"/> are simply functions attached to the class. An instance method is a method<a id="_idIndexMarker230"/> that automatically receives a reference to the instance as its first argument. We can define one like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Banana</span><span class="hljs-class">:</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">peel</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    self.peeled = <span class="hljs-literal">True</span>
</code></pre>
    <p class="normal">As you can see, defining an instance method is simply defining a function inside the class body. The first argument that this function will receive is a reference to the instance of the class; it can be called anything you like, but by long-standing Python convention, we name it <code class="Code-In-Text--PACKT-">self</code>. Inside the function, <code class="Code-In-Text--PACKT-">self</code> can be used to do operations on the instance, such as assigning an instance attribute.</p>
    <p class="normal">Note that the instance (<code class="Code-In-Text--PACKT-">self</code>) also has access to class attributes (for example, <code class="Code-In-Text--PACKT-">self.colors</code>), as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">set_color</span><span class="hljs-function">(</span><span class="hljs-params">self, color</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Set the color of the banana"""</span>
    <span class="hljs-keyword">if</span> color <span class="hljs-keyword">in</span> self.colors:
      self.color = color
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f'A banana cannot be </span><span class="hljs-subst">{color}</span><span class="hljs-string">!'</span>)
</code></pre>
    <p class="normal">When we use an instance method, we do not<a id="_idIndexMarker231"/> explicitly pass <code class="Code-In-Text--PACKT-">self</code>; it's passed implicitly, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">my_banana = Banana()
my_banana.set_color(<span class="hljs-string">'green'</span>)
my_banana.peel()
</code></pre>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The implicit passing of <code class="Code-In-Text--PACKT-">self</code> often leads to confusing error messages when you pass the wrong number of arguments. For example, if you called <code class="Code-In-Text--PACKT-">my_banana.peel(True)</code>, you'd get an exception saying that one argument was expected but two were passed. From your point of view, you only passed one argument, but the method got two because the instance reference was automatically added.</p>
    </div>
    <p class="normal">In addition to instance methods, classes can have <strong class="keyword">class methods</strong> and <strong class="keyword">static methods</strong>. Unlike instance methods, these<a id="_idIndexMarker232"/> methods do not have access to the instance of the class and cannot read<a id="_idIndexMarker233"/> or write instance attributes.</p>
    <p class="normal">Class methods are created using a <strong class="keyword">decorator</strong> just before the method<a id="_idIndexMarker234"/> definition, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="code-highlight"><strong class="hljs-title-slc">@classmethod</strong></span>
  <span class="hljs-keyword">def</span> <span class="hljs-title">check_color</span>(cls, color):
    <span class="hljs-string">"""Test a color string to see if it is valid."""</span>
    <span class="hljs-keyword">return</span> color <span class="hljs-keyword">in</span> cls.colors
 <code style="font-weight: bold;" class="codeHighlighted"> </code><span class="code-highlight"><strong class="hljs-title-slc">@classmethod</strong></span>
  <span class="hljs-keyword">def</span> <span class="hljs-title">make_greenie</span>(cls):
    <span class="hljs-string">"""Create a green banana object"""</span>
    banana = cls()
    banana.set_color(<span class="hljs-string">'green'</span>)
    <span class="hljs-keyword">return</span> banana
</code></pre>
    <p class="normal">Just as an instance method is implicitly passed a reference to the instance, a class method is implicitly passed a reference to the class as the first argument. Once again, you can call that argument anything you like, but conventionally it is called <code class="Code-In-Text--PACKT-">cls</code>. Class methods are usually used for interaction with class variables. For example, in the <code class="Code-In-Text--PACKT-">check_color()</code> method above, the method needs a reference to the class variable <code class="Code-In-Text--PACKT-">colors</code>. Class methods are also used as convenience functions for geneating specifically configured instances of the class; for example, the <code class="Code-In-Text--PACKT-">make_greenie()</code> method above uses its class reference to create instances of <code class="Code-In-Text--PACKT-">Banana</code> with the color pre-set to <code class="Code-In-Text--PACKT-">green</code>.</p>
    <p class="normal">A <strong class="keyword">static method</strong> is also a function that's attached to the class, but it does not get any implicit arguments, and the code<a id="_idIndexMarker235"/> within the method has no access to the class or instance. Just like the class methods, we use a decorator to define a static method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="code-highlight"><strong class="hljs-title-slc">@staticmethod</strong></span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">estimate_calories</span><span class="hljs-function">(</span><span class="hljs-params">num_bananas</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Given `num_bananas`, estimate the number of calories"""</span>
    <span class="hljs-keyword">return</span> num_bananas * <span class="hljs-number">105</span>
</code></pre>
    <p class="normal">Static methods are often used for defining algorithms or utility functions used internally by the class.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Class and static methods can be called on the class itself; for example, we could call <code class="Code-In-Text--PACKT-">Banana.estimate_calories()</code> or <code class="Code-In-Text--PACKT-">Banana.check_color()</code> without actually creating an instance of <code class="Code-In-Text--PACKT-">Banana</code>. Instance methods, however, <em class="italic">must</em> be called on an instance of the class. It would make no sense to call <code class="Code-In-Text--PACKT-">Banana.set_color()</code> or <code class="Code-In-Text--PACKT-">Banana.peel()</code>, since these methods are meant to operate on an instance. Instead, we should create an instance and call those methods on it (for example, <code class="Code-In-Text--PACKT-">my_banana.peel()</code>).</p>
    </div>
    <h3 id="_idParaDest-87" class="title">Magic attributes and methods</h3>
    <p class="normal">All Python objects automatically get<a id="_idIndexMarker236"/> a set of attributes called <strong class="keyword">magic attributes</strong> and a set of methods called <strong class="keyword">magic methods</strong>, also called special methods or <em class="italic">dunder methods</em>, because they are indicated<a id="_idIndexMarker237"/> by double underscores around the attribute or method<a id="_idIndexMarker238"/> name ("dunder" is a portmanteau of "double under").</p>
    <p class="normal">Magic attributes generally store metadata about the object. For example, the <code class="Code-In-Text--PACKT-">__class__</code> attribute of any object stores a reference to the object's class:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(my_banana.__class__)
&lt;class '__main__.Banana'&gt;
</code></pre>
    <p class="normal">Magic methods define how a Python object responds to operators (like <code class="Code-In-Text--PACKT-">+</code>, <code class="Code-In-Text--PACKT-">%</code>, or <code class="Code-In-Text--PACKT-">[]</code>) or built-in functions (like <code class="Code-In-Text--PACKT-">dir()</code> or <code class="Code-In-Text--PACKT-">setattr()</code>). For example, the <code class="Code-In-Text--PACKT-">__str__()</code> method defines what an object returns when passed to the <code class="Code-In-Text--PACKT-">str()</code> function (either explicitly or implicitly, by being passed to <code class="Code-In-Text--PACKT-">print()</code>, for example):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Banana</span><span class="hljs-class">:</span>
  <span class="hljs-comment"># ....</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__str__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-comment"># "Magic Attributes" contain metadata about the object</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">f'A </span><span class="hljs-subst">{self.color}</span><span class="hljs-string"> </span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-string">'</span>
</code></pre>
    <p class="normal">Here, we're not only<a id="_idIndexMarker239"/> accessing the instance's <code class="Code-In-Text--PACKT-">color</code> attribute, but using the <code class="Code-In-Text--PACKT-">__class__</code> attribute<a id="_idIndexMarker240"/> to retrieve its class, and then using the class object's <code class="Code-In-Text--PACKT-">__name__</code> attribute to get the class name.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">As confusing as it is, the <em class="italic">class</em> is also an <em class="italic">object</em>. It's an instance of the <code class="Code-In-Text--PACKT-">type</code> class. Remember, everything in Python is an object, and all objects are instances of some class.</p>
    </div>
    <p class="normal">Thus, when a <code class="Code-In-Text--PACKT-">Banana</code> object is printed, it looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> my_banana = Banana()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> my_banana.set_color(<span class="hljs-con-string">'yellow'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(my_banana)
A yellow Banana
</code></pre>
    <p class="normal">By far the most important magic method is the <strong class="keyword">initializer</strong> method, <code class="Code-In-Text--PACKT-">__init__()</code>. This method is executed whenever<a id="_idIndexMarker241"/> we call the class object to create an instance, and the arguments we define for it become the arguments we can pass in when creating the instance. For example:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, color=</span><span class="hljs-string">'green'</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.check_color(color):
      <span class="hljs-keyword">raise</span> ValueError(
        <span class="hljs-string">f'A </span><span class="hljs-subst">{self.__class__.__name__}</span><span class="hljs-string"> cannot be </span><span class="hljs-subst">{color}</span><span class="hljs-string">'</span>
      )
    self.color = color
</code></pre>
    <p class="normal">Here, we've created the initializer with an optional argument called <code class="Code-In-Text--PACKT-">color</code>, allowing us to set the <code class="Code-In-Text--PACKT-">Banana</code> object's color value when creating the object. Thus, we can create a new <code class="Code-In-Text--PACKT-">Banana</code> like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> my_new_banana = Banana(<span class="hljs-con-string">'green'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(my_new_banana)
A green Banana
</code></pre>
    <p class="normal">Ideally, any instance attributes used in the class should be created within <code class="Code-In-Text--PACKT-">__init__()</code>, so that we can ensure they exist for all instances of the class. For example, we should create our <code class="Code-In-Text--PACKT-">peeled</code> attribute like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, color=</span><span class="hljs-string">'green'</span><span class="hljs-function">):</span>
    <span class="hljs-comment"># ...</span>
    <span class="code-highlight"><strong class="hljs-slc">self.peeled = </strong><strong class="hljs-literal-slc">False</strong></span>
</code></pre>
    <p class="normal">If we didn't define<a id="_idIndexMarker242"/> this attribute here, it would not exist until the <code class="Code-In-Text--PACKT-">peel()</code> method is called. Code looking<a id="_idIndexMarker243"/> for the value of <code class="Code-In-Text--PACKT-">my_banana.peel</code> before that method was called would raise an exception.</p>
    <p class="normal">Ultimately, the initializer should leave the object in a state where it is ready to be used by the program.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">In other object-oriented<a id="_idIndexMarker244"/> languages, the method that sets up a class object is known as the <strong class="keyword">constructor</strong>, which not only initializes the new object but returns it as well. Sometimes, Python developers will casually refer to <code class="Code-In-Text--PACKT-">__init__()</code> as a constructor. However, the actual constructor method for Python objects is <code class="Code-In-Text--PACKT-">__new__()</code>, which we generally leave untouched in Python classes.</p>
    </div>
    <h3 id="_idParaDest-88" class="title">Public, private, and protected members</h3>
    <p class="normal">Classes are a powerful tool for <em class="italic">abstraction</em> – that is, taking a complicated object or process and providing a simple, high-level interface to the rest of the application. To help them do that, Python programmers use some naming conventions to distinguish between public, private, and protected members:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Public members</strong> are those intended to be read or called<a id="_idIndexMarker245"/> by code outside the class. They use ordinary member names.</li>
      <li class="bullet"><strong class="keyword">Protected members</strong> are meant only for use inside the class or its subclasses. They are prefixed<a id="_idIndexMarker246"/> with a single underscore.</li>
      <li class="bullet"><strong class="keyword">Private members</strong> are meant only for use<a id="_idIndexMarker247"/> within the class. They're prefixed with double underscores.</li>
    </ul>
    <p class="normal">Python does not actually enforce any distinction between public, protected, and private members; these are merely conventions that are understood by other programmers to indicate which parts of the class can be accessed externally, and which ones are part of the internal implementation and not meant for use outside the class. </p>
    <p class="normal">Python <em class="italic">will</em> assist in enforcing private members by automatically changing their names to <code class="Code-In-Text--PACKT-">_classname__member_name</code>.</p>
    <p class="normal">For example, let's add this code to the <code class="Code-In-Text--PACKT-">Banana</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">  __ripe_colors = [<span class="hljs-string">'yellow'</span>, <span class="hljs-string">'brown spotted'</span>]
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_is_ripe</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Protected method to see if the banana is ripe."""</span>
    <span class="hljs-keyword">return</span> self.color <span class="hljs-keyword">in</span> self.__ripe_colors
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">can_eat</span><span class="hljs-function">(</span><span class="hljs-params">self, must_be_ripe=</span><span class="hljs-literal">False</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Check if I can eat the banana."""</span>
    <span class="hljs-keyword">if</span> must_be_ripe <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> self._is_ripe():
      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
    <p class="normal">Here, <code class="Code-In-Text--PACKT-">__ripe_colors</code> is a private attribute. If you tried to access <code class="Code-In-Text--PACKT-">my_banana.__ripe_colors</code>, Python would raise an <code class="Code-In-Text--PACKT-">AttributeError</code> exception because it has implicitly renamed this property to <code class="Code-In-Text--PACKT-">my_banana._Banana__ripe_colors</code>. The method <code class="Code-In-Text--PACKT-">_is_ripe()</code> is a protected member but, unlike the private member, Python does not alter its name. It could be executed as <code class="Code-In-Text--PACKT-">my_banana._is_ripe()</code>, but programmers using your class would understand that this method is meant for internal use and not to be relied upon in external code. Instead, the <code class="Code-In-Text--PACKT-">can_eat()</code> method, which is public, should be called.</p>
    <p class="normal">There are a variety of reasons why you'd want to indicate a member as private or protected, but in general, it's because the member is part of some internal process and would be either meaningless, unreliable, or lacking in context for use in outside code.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Although the words <em class="italic">private</em> and <em class="italic">protected</em> seem to indicate a security feature, that is not their intention, and using them does not provide any security to the class. The intention is simply to distinguish the public interface of the class (which outside code should use) from the internal machinery of the class (which should be left alone).</p>
    </div>
    <h2 id="_idParaDest-89" class="title">Inheritance and subclasses</h2>
    <p class="normal">Building our own classes<a id="_idIndexMarker248"/> is a powerful tool indeed, but since everything<a id="_idIndexMarker249"/> in Python is an object built from a class, wouldn't it be nice if we could take<a id="_idIndexMarker250"/> one of those existing classes and simply alter it to fit our needs? That way, we wouldn't have to start from scratch every time.</p>
    <p class="normal">Fortunately, we can! When we create a class, Python allows us to derive it from an existing class, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">RedBanana</span><span class="hljs-class">(</span><span class="hljs-params">Banana</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""Bananas of the red variety"""</span>
  <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">We've created<a id="_idIndexMarker251"/> the class <code class="Code-In-Text--PACKT-">RedBanana</code> as a <strong class="keyword">child class</strong> or <strong class="keyword">subclass</strong> of <code class="Code-In-Text--PACKT-">Banana</code>. <code class="Code-In-Text--PACKT-">Banana</code> is<a id="_idIndexMarker252"/> known as the <strong class="keyword">parent class</strong> or <strong class="keyword">superclass</strong> in this case. Initially, <code class="Code-In-Text--PACKT-">RedBanana</code> is an exact copy<a id="_idIndexMarker253"/> of <code class="Code-In-Text--PACKT-">Banana</code> and will behave<a id="_idIndexMarker254"/> identically, but we can modify<a id="_idIndexMarker255"/> it by simply defining<a id="_idIndexMarker256"/> members, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">RedBanana</span><span class="hljs-class">(</span><span class="hljs-params">Banana</span><span class="hljs-class">):</span>
  colors = [<span class="hljs-string">'green'</span>, <span class="hljs-string">'orange'</span>, <span class="hljs-string">'red'</span>, <span class="hljs-string">'brown'</span>, <span class="hljs-string">'black'</span>]
  botanical_name = <span class="hljs-string">'red dacca'</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">set_color</span><span class="hljs-function">(</span><span class="hljs-params">self, color</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">if</span> color <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.colors:
      <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f'A Red Banana cannot be </span><span class="hljs-subst">{color}</span><span class="hljs-string">!'</span>)
</code></pre>
    <p class="normal">Specifying existing members, like <code class="Code-In-Text--PACKT-">colors</code> and <code class="Code-In-Text--PACKT-">set_color</code>, will mask the superclass versions of those members. Thus, calling <code class="Code-In-Text--PACKT-">set_color()</code> on a <code class="Code-In-Text--PACKT-">RedBanana</code> instance will call the <code class="Code-In-Text--PACKT-">RedBanana</code> version of the method, which, in turn, will consult the <code class="Code-In-Text--PACKT-">RedBanana</code> version of <code class="Code-In-Text--PACKT-">colors</code> when <code class="Code-In-Text--PACKT-">self.colors</code> is referenced. We can also add new members, such as the <code class="Code-In-Text--PACKT-">botanical_name</code> a ttribute, which will only exist in the subclass.</p>
    <p class="normal">In some cases, we might want our subclass method to add to the superclass method, but still execute the code in the superclass version of the method. We could copy the superclass code into our subclass code, but there's a better way: using <code class="Code-In-Text--PACKT-">super()</code>.</p>
    <p class="normal">Inside an instance method, <code class="Code-In-Text--PACKT-">super()</code> gives us a reference to the superclass version of our instance, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">peel</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().peel()
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'It looks like a regular banana inside!'</span>)
</code></pre>
    <p class="normal">In this case, calling <code class="Code-In-Text--PACKT-">super().peel()</code> causes the code in <code class="Code-In-Text--PACKT-">Banana.peel()</code> to be executed on our <code class="Code-In-Text--PACKT-">RedBanana</code> instance. Then, we can add additional code to our subclass version of <code class="Code-In-Text--PACKT-">peel()</code>.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">As you'll see in the next section, <code class="Code-In-Text--PACKT-">super()</code> is often used in the <code class="Code-In-Text--PACKT-">__init__()</code> method to run the superclass's initializer. This is especially true for Tkinter GUI classes, which do a lot of critical external setup in their initializer methods. </p>
    </div>
    <p class="normal">There is much more to Python classes<a id="_idIndexMarker257"/> than we have discussed here, including<a id="_idIndexMarker258"/> the concept of <strong class="keyword">multiple inheritance</strong>, which we<a id="_idIndexMarker259"/> will learn about in <em class="chapterRef">Chapter 5</em>, <em class="italic">Reducing User Error with Validation and Automation</em>. What we've learned<a id="_idIndexMarker260"/> so far, however, is more than enough to apply to our Tkinter code. Let's see how classes can help us in a GUI context.</p>
    <h1 id="_idParaDest-90" class="title">Using classes with Tkinter</h1>
    <p class="normal">GUI frameworks and object-oriented code go hand in hand. While Tkinter, more than most frameworks, allows<a id="_idIndexMarker261"/> you to create GUIs using procedural programming, we miss out on a great deal of organizational power in doing so. Although we'll find many ways<a id="_idIndexMarker262"/> to use classes in our Tkinter code throughout this book, we'll look at three primary ways of using them here:</p>
    <ul>
      <li class="bullet">Improving or expanding Tkinter classes for more power</li>
      <li class="bullet">Creating <strong class="keyword">compound widgets</strong> to save repetitive typing</li>
      <li class="bullet">Organizing our application into self-contained <strong class="keyword">comp</strong><strong class="keyword">onents</strong></li>
    </ul>
    <h2 id="_idParaDest-91" class="title">Improving Tkinter classes</h2>
    <p class="normal">Let's face it: some Tkinter objects<a id="_idIndexMarker263"/> are a little lacking in functionality. We can fix that by subclassing Tkinter classes and making our own improved versions. For instance, while we've seen that Tkinter control variable classes are useful, hey are limited<a id="_idIndexMarker264"/> to string, integer, double, and Boolean types. What if we wanted the functionality of these<a id="_idIndexMarker265"/> variables, but for more complex objects like dictionaries or lists? We can, with subclassing and some help from JSON.</p>
    <div class="note">
      <p class="Information-Box--PACKT-"><strong class="keyword">JavaScript Object Notation</strong> (<strong class="keyword">JSON</strong>) is a standardized format for representing lists, dictionaries, and other compound<a id="_idIndexMarker266"/> objects as strings. The Python standard library comes with a <code class="Code-In-Text--PACKT-">json</code> library, which allows us to convert such objects to string format and back again. We'll use JSON more in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating Menus with Menu and Tkinter Dialogs</em>.</p>
    </div>
    <p class="normal">Open a new script called <code class="Code-In-Text--PACKT-">tkinter_classes_demo.py</code>, and let's begin with some imports, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># tkinter_classes_demo.py</span>
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
<span class="hljs-keyword">import</span> json
</code></pre>
    <p class="normal">In addition to Tkinter, we've imported the standard library <code class="Code-In-Text--PACKT-">json</code> module. This module contains two functions that we'll use to implement our variable:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">json.dumps()</code> takes a Python object like a list, dictionary, string, int, or float, and returns a string in JSON format.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">json.loads()</code> takes a JSON string and returns a Python object like a list, dict, or string, depending on what was stored in the JSON string.</li>
    </ul>
    <p class="normal">Begin the new variable class by creating a subclass of <code class="Code-In-Text--PACKT-">tk.StringVar</code> called <code class="Code-In-Text--PACKT-">JSONVar</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">JSONVar</span><span class="hljs-class">(</span><span class="hljs-params">tk.StringVar</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""A Tk variable that can hold dicts and lists"""</span>
</code></pre>
    <p class="normal">To make our <code class="Code-In-Text--PACKT-">JSONVar</code> work, we need to intercept the <code class="Code-In-Text--PACKT-">value</code> argument wherever it is passed to the object and convert it into a JSON string using the <code class="Code-In-Text--PACKT-">json.dumps()</code> method. The first such place is in <code class="Code-In-Text--PACKT-">__init__()</code>, which we'll override like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>
    kwargs[<span class="hljs-string">'value'</span>] = json.dumps(kwargs.get(<span class="hljs-string">'value'</span>)
    <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
</code></pre>
    <p class="normal">Here, we're simply retrieving the <code class="Code-In-Text--PACKT-">value</code> argument from the keywords and converting it into a string using <code class="Code-In-Text--PACKT-">json.dumps()</code>. The converted string will overwrite the <code class="Code-In-Text--PACKT-">value</code> argument, which will then be passed to the superclass initializer. In the event that a <code class="Code-In-Text--PACKT-">value</code> argument isn't provided (remember, it is an optional argument), <code class="Code-In-Text--PACKT-">kwargs.get()</code> will return <code class="Code-In-Text--PACKT-">None</code>, which will be converted into a JSON <code class="Code-In-Text--PACKT-">null</code> value.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">When overriding methods in a class you didn't write, it's always a good idea to include <code class="Code-In-Text--PACKT-">*args</code> and <code class="Code-In-Text--PACKT-">**kwargs</code> to catch any arguments that you don't explicitly list. That way, the method will continue to allow all the arguments that the superclass version did, but you won't have to explicitly enumerate them all.</p>
    </div>
    <p class="normal">The next place we need<a id="_idIndexMarker267"/> to intercept the value is in the <code class="Code-In-Text--PACKT-">set()</code> method, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">set</span><span class="hljs-function">(</span><span class="hljs-params">self, value, *args, **kwargs</span><span class="hljs-function">):</span>
    string = json.dumps(value)
    <span class="hljs-built_in">super</span>().<span class="hljs-built_in">set</span>(string, *args, **kwargs)
</code></pre>
    <p class="normal">Once again, we've intercepted<a id="_idIndexMarker268"/> the <code class="Code-In-Text--PACKT-">value</code> argument and converted it into a JSON string before passing it to the superclass version of <code class="Code-In-Text--PACKT-">set()</code>.</p>
    <p class="normal">Last of all, let's fix <code class="Code-In-Text--PACKT-">get()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>
    string = <span class="hljs-built_in">super</span>().get(*args, **kwargs)
    <span class="hljs-keyword">return</span> json.loads(string)
</code></pre>
    <p class="normal">Here, we've done the opposite of the other two methods: first, we got the string from the superclass, and then converted it back into an object using <code class="Code-In-Text--PACKT-">json.loads()</code>. With that done, we're ready! What we now have is a variable that can store and retrieve a list or dictionary, just like any other Tkinter variable.</p>
    <p class="normal">Let's test it out:</p>
    <pre class="programlisting code"><code class="hljs-code">root = tk.Tk()
var1 = JSONVar(root)
var1.<span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])
var2 = JSONVar(root, value={<span class="hljs-string">'a'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">15</span>})
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Var1: "</span>, var1.get()[<span class="hljs-number">1</span>])
<span class="hljs-comment"># Should print 2</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Var2: "</span>, var2.get()[<span class="hljs-string">'b'</span>])
<span class="hljs-comment"># Should print 15</span>
</code></pre>
    <p class="normal">As you can see, subclassing Tkinter<a id="_idIndexMarker269"/> objects opens up a whole new range of possibilities<a id="_idIndexMarker270"/> for our code. We'll apply this same concept to widget classes both later in this chapter and more extensively in <em class="chapterRef">Chapter 5</em>, <em class="italic">Reducing User Error with Validation and Automation</em><em class="chapterRef">.</em> First, though, let's look at two more ways we can use classes with Tkinter code.</p>
    <h2 id="_idParaDest-92" class="title">Creating compound widgets</h2>
    <p class="normal">Many GUIs (particularly data entry forms) contain patterns that require a lot of repetitive boilerplate<a id="_idIndexMarker271"/> code. For example, input widgets usually have an accompanying label to tell the user what they need to enter. This often requires<a id="_idIndexMarker272"/> several lines of code to create and configure each object and add them to the form. We can not only save time, but ensure better consistency of output by creating a reusable <strong class="keyword">compound widget</strong> that combines both into a single class.</p>
    <p class="normal">Let's combine an input widget and label by creating a <code class="Code-In-Text--PACKT-">LabelInput</code> class, starting with this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># tkinter_classes_demo.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LabelInput</span><span class="hljs-class">(</span><span class="hljs-params">tk.Frame</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""A label and input combined together"""</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">tk.Frame</code> widget, a bare widget with nothing on it, is an ideal class to subclass for a compound widget. After starting our class definition, the next thing we need to do is think through all the pieces of data our widget will need, and make sure those can be passed into the <code class="Code-In-Text--PACKT-">__init__()</code> method.</p>
    <p class="normal">For a basic widget, the minimal set of arguments might look like this:</p>
    <ul>
      <li class="bullet">The parent widget</li>
      <li class="bullet">The text for the label</li>
      <li class="bullet">The type of input widget to use</li>
      <li class="bullet">A dictionary of arguments to pass to the input widget</li>
    </ul>
    <p class="normal">Let's implement that in our <code class="Code-In-Text--PACKT-">LabelInput</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-function">    </span><span class="hljs-params">self, parent, label, inp_cls, </span>
<span class="hljs-params">    inp_args, *args, **kwargs</span>
<span class="hljs-params">  </span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(parent, *args, **kwargs)
    self.label = tk.Label(self, text=label, anchor=<span class="hljs-string">'w'</span>)
    self.<span class="hljs-built_in">input</span> = inp_cls(self, **inp_args)
</code></pre>
    <p class="normal">The first thing we do here is call the superclass<a id="_idIndexMarker273"/> initializer so that the <code class="Code-In-Text--PACKT-">Frame</code> widget can be constructed. Note that we pass along the <code class="Code-In-Text--PACKT-">parent</code> argument, since that will be the parent widget of the <code class="Code-In-Text--PACKT-">Frame</code> itself; the parent widget for the <code class="Code-In-Text--PACKT-">Label</code> and input widget is <code class="Code-In-Text--PACKT-">self</code> – that is, the <code class="Code-In-Text--PACKT-">LabelInput</code> object itself.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Don't confuse "parent class" and "parent widget." "Parent class" refers to the superclass<a id="_idIndexMarker274"/> from which our subclass inherits its members. "Parent widget" refers to the widget (of a probably unrelated class) to which our widget<a id="_idIndexMarker275"/> is attached. To help avoid confusion, we'll stick to the super/subclass terminology in this book when speaking of class inheritance.</p>
    </div>
    <p class="normal">After creating our <code class="Code-In-Text--PACKT-">label</code> and <code class="Code-In-Text--PACKT-">input</code> widgets, we can arrange them on the <code class="Code-In-Text--PACKT-">Frame</code> however we wish; for example, we might want<a id="_idIndexMarker276"/> labels next to the input, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.columnconfigure(<span class="hljs-number">1</span>, weight=<span class="hljs-number">1</span>)
    self.label.grid(sticky=tk.E + tk.W)
    self.<span class="hljs-built_in">input</span>.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>, sticky=tk.E + tk.W)
</code></pre>
    <p class="normal">Or, we might prefer labels above our input widgets, as implemented here:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.columnconfigure(<span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)
    self.label.grid(sticky=tk.E + tk.W)
    self.<span class="hljs-built_in">input</span>.grid(sticky=tk.E + tk.W)
</code></pre>
    <p class="normal">In either case, if we create all the inputs on our form using a <code class="Code-In-Text--PACKT-">LabelInput</code>, we have the power to change the layout of <em class="italic">the entire form</em> using only three lines of code. We could conceivably add an initializer argument to configure the layout individually for each instance as well.</p>
    <p class="normal">Let's see this class in action. Since our <code class="Code-In-Text--PACKT-">inp_args</code> argument is going to be expanded directly into our call to the <code class="Code-In-Text--PACKT-">inp_cls</code> initializer, we can populate it with any arguments we'd like our input widget to receive, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># tkinter_classes_demo.py</span>
li1 = LabelInput(root, <span class="hljs-string">'Name'</span>, tk.Entry, {<span class="hljs-string">'bg'</span>: <span class="hljs-string">'red'</span>})
li1.grid()
</code></pre>
    <p class="normal">We can even pass in a variable to bind to the widget:</p>
    <pre class="programlisting code"><code class="hljs-code">age_var = tk.IntVar(root, value=<span class="hljs-number">21</span>)
li2 = LabelInput(
  root, <span class="hljs-string">'Age'</span>, tk.Spinbox,
  {<span class="hljs-string">'textvariable'</span>: age_var, <span class="hljs-string">'from_'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'to'</span>: <span class="hljs-number">150</span>}
)
li2.grid()
</code></pre>
    <p class="normal">The compound widget saves us a few lines of code, but more importantly, it raises our input form code to a higher-level description<a id="_idIndexMarker277"/> of what's going on. Instead of being full of details about how each label is placed in relation to each widget, we can think about the form in terms of these larger components.</p>
    <h2 id="_idParaDest-93" class="title">Building encapsulated components</h2>
    <p class="normal">Creating compound widgets is useful for structures we plan to reuse in our application, but the same concept<a id="_idIndexMarker278"/> can be applied beneficially to larger pieces of our application, even if they only appear once. </p>
    <p class="normal">Doing so allows<a id="_idIndexMarker279"/> us to attach methods to the components of our application to build self-contained units of functionality that are more easily managed.</p>
    <p class="normal">For example, let's create a <code class="Code-In-Text--PACKT-">MyForm</code> class to hold a simple form:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># tkinter_classes_demo.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MyForm</span><span class="hljs-class">(</span><span class="hljs-params">tk.Frame</span><span class="hljs-class">):</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, parent, data_var, *args, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(parent, *args, **kwargs)
    self.data_var = data_var
</code></pre>
    <p class="normal">Just as we did with the compound wiget, we've subclassed <code class="Code-In-Text--PACKT-">tk.Frame</code> and defined a new initializer method. The <code class="Code-In-Text--PACKT-">parent</code>, <code class="Code-In-Text--PACKT-">*args</code>, and <code class="Code-In-Text--PACKT-">**kwargs</code> arguments will get passed on to the superclass's initializer, but we'll also take a <code class="Code-In-Text--PACKT-">data_var</code> argument, which will be an instance of our new <code class="Code-In-Text--PACKT-">JSONVar</code> type. We'll use this argument to communicate the form data back out of the form.</p>
    <p class="normal">Next, we'll create some internal control variables to bind to our form widgets:</p>
    <pre class="programlisting code"><code class="hljs-code">    self._<span class="hljs-built_in">vars</span> = {
      <span class="hljs-string">'name'</span>: tk.StringVar(self),
      <span class="hljs-string">'age'</span>: tk.IntVar(self, value=<span class="hljs-number">2</span>)
    }
</code></pre>
    <p class="normal">As we've already seen in our data entry application, keeping our form data variables in a dictionary will make it simple to extract data from them later. Rather than using a global variable, however, we've created<a id="_idIndexMarker280"/> the dictionary as a protected<a id="_idIndexMarker281"/> instance variable by adding it to <code class="Code-In-Text--PACKT-">self</code> and prefixing it with an underscore. That's because this dictionary is meant for our form's internal use only.</p>
    <p class="normal">Now, let's put our <code class="Code-In-Text--PACKT-">LabelInput</code> class to work to create the actual widgets for our form:</p>
    <pre class="programlisting code"><code class="hljs-code">    LabelInput(
      self, <span class="hljs-string">'Name'</span>, tk.Entry,
      {<span class="hljs-string">'textvariable'</span>: self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'name'</span>]}
    ).grid(sticky=tk.E + tk.W)
    LabelInput(
      self, <span class="hljs-string">'Age'</span>, tk.Spinbox,
      {<span class="hljs-string">'textvariable'</span>: self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'age'</span>], <span class="hljs-string">'from_'</span>: <span class="hljs-number">10</span>, <span class="hljs-string">'to'</span>: <span class="hljs-number">150</span>}
    ).grid(sticky=tk.E + tk.W)
</code></pre>
    <p class="normal">You can see that <code class="Code-In-Text--PACKT-">LabelInput</code> has trimmed our GUI-building code considerably! Now, let's add a submit button for our form:</p>
    <pre class="programlisting code"><code class="hljs-code">    tk.Button(self, text=<span class="hljs-string">'Submit'</span>, command=self._on_submit).grid()
</code></pre>
    <p class="normal">The submit button is configured to call a protected instance method named <code class="Code-In-Text--PACKT-">_on_submit</code>. This shows us a powerful feature of using classes for our GUI components: by binding our button to an instance method, that method will have access to all the other instance members. For example, it can access our <code class="Code-In-Text--PACKT-">_vars</code> dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_on_submit</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    data = { key: var.get() <span class="hljs-keyword">for</span> key, var <span class="hljs-keyword">in</span> self._<span class="hljs-built_in">vars</span>.items() }
    self.data_var.<span class="hljs-built_in">set</span>(data)
</code></pre>
    <p class="normal">Without using a class, we would have had to rely on global variables, such as we did in the <code class="Code-In-Text--PACKT-">data_entry_app.py</code> application we wrote in <em class="chapterRef">Chapter 3</em>, <em class="italic">Creating Basic Forms with Tkinter and Ttk Widgets</em>. Instead, our callback method needs only the implicitly passed <code class="Code-In-Text--PACKT-">self</code> object to have access to all the<a id="_idIndexMarker282"/> objects that it needs. In this case, we're using a <strong class="keyword">dictionary comprehension</strong> to extract all the data frm our widgets and, then storing the resulting dictionary in our <code class="Code-In-Text--PACKT-">JSONVar</code> object.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">A dictionary comprehension is similar to a list comprehension, but creates a dictionary instead; the syntax is <code class="Code-In-Text--PACKT-">{ key: value for expression in iterator }</code>. For example, if you wanted to create a dictionary of numbers with their squares, you could write <code class="Code-In-Text--PACKT-">{ n: n**2 for n in range(100) }</code>.</p>
    </div>
    <p class="normal">Thus, whenever the submit<a id="_idIndexMarker283"/> button is clicked, the <code class="Code-In-Text--PACKT-">data_var</code> object will be<a id="_idIndexMarker284"/> updated with the current contents of the input widgets.</p>
    <h3 id="_idParaDest-94" class="title">Subclassing Tk</h3>
    <p class="normal">We can extend this concept<a id="_idIndexMarker285"/> of component building all the way up to our top window, the <code class="Code-In-Text--PACKT-">Tk</code> object. By subclassing <code class="Code-In-Text--PACKT-">Tk</code> and building our other application components in their own classes, we can compose our application's layout and behavior in a high-level way.</p>
    <p class="normal">Let's try this with our current demo script:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># tkinter_classes_demo.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Application</span><span class="hljs-class">(</span><span class="hljs-params">tk.Tk</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""A simple form application"""</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
</code></pre>
    <p class="normal">Remember that the <code class="Code-In-Text--PACKT-">Tk</code> object is not just our top-level window, but also represents the core of our application itself. Therefore we've named our subclass <code class="Code-In-Text--PACKT-">Application</code> to indicate that it represents the foundation of our entire application. Our initializer method begins with the obligatory call to <code class="Code-In-Text--PACKT-">super().__init__()</code>, passing along any arguments to the <code class="Code-In-Text--PACKT-">Application.__init__()</code> method.</p>
    <p class="normal">Next, we'll create some variables to keep track of the data in our application:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.jsonvar = JSONVar(self)
    self.output_var = tk.StringVar(self)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">JSONVar</code>, as you might expect, will be passed into our <code class="Code-In-Text--PACKT-">MyForm</code> object to handle its data. The <code class="Code-In-Text--PACKT-">output_var</code> is just a <code class="Code-In-Text--PACKT-">StringVar</code> we'll use to display some output. Let's next add some widgets to our window:</p>
    <pre class="programlisting code"><code class="hljs-code">    tk.Label(self, text=<span class="hljs-string">'Please fill the form'</span>).grid(sticky=<span class="hljs-string">'ew'</span>)
    MyForm(self, self.jsonvar).grid(sticky=<span class="hljs-string">'nsew'</span>)
    tk.Label(self, textvariable=self.output_var).grid(sticky=<span class="hljs-string">'ew'</span>)
    self.columnconfigure(<span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)
    self.rowconfigure(<span class="hljs-number">1</span>, weight=<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">Here, we've added a simple<a id="_idIndexMarker286"/> header label for the form, a <code class="Code-In-Text--PACKT-">MyForm</code> object, and another label to display the output. We've also configured the frame so that the first (and only) column expands into the extra space, and the second row (the one containing the form) expands into extra vertical space.</p>
    <p class="normal">Since a submission of <code class="Code-In-Text--PACKT-">MyForm</code> updates the <code class="Code-In-Text--PACKT-">JSONVar</code> object we passed to it, we'll need a way to execute a submission-handling callback<a id="_idIndexMarker287"/> whenever the variable contents are changed. We can do this by setting a <strong class="keyword">trace</strong> on <code class="Code-In-Text--PACKT-">jsonvar</code>, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.jsonvar.trace_add(<span class="hljs-string">'write'</span>, self._on_data_change)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">trace_add()</code> method can be used on any Tkinter vaiable (or variable subclass) to execute a callback function whenever a variable-related event occurs. Let's take a moment to examine it in more detail</p>
    <p class="normal">The first argument to <code class="Code-In-Text--PACKT-">trace_add()</code> specifies the event that the trace will trigger on; it can be one of the following:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">read</code>: The variable value is read (by a <code class="Code-In-Text--PACKT-">get()</code> call, for example).</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">write</code>: The variable value is modified (by a <code class="Code-In-Text--PACKT-">set()</code> call, for example).</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">unset</code>: The variable is deleted.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">array</code>: This is an artifact of Tcl/Tk, not really meaningful in Python, but still valid syntax. You will likely never use it.</li>
    </ul>
    <p class="normal">The second argument specifies a callback for the event, which, in this case, is the instance method <code class="Code-In-Text--PACKT-">_on_data_change()</code>, which will be triggered whenever <code class="Code-In-Text--PACKT-">jsonvar</code> is updated. We'll handle it like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_on_data_change</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>
    data = self.jsonvar.get()
    output = <span class="hljs-string">''</span>.join([
    <span class="hljs-string">f'</span><span class="hljs-subst">{key}</span><span class="hljs-string"> = </span><span class="hljs-subst">{value}</span><span class="hljs-string">\n'</span>
    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> data.items()
    ])
    self.output_var.<span class="hljs-built_in">set</span>(output)
</code></pre>
    <p class="normal">This method simply iterates through<a id="_idIndexMarker288"/> the values in the dictionary retrieved from <code class="Code-In-Text--PACKT-">jsonvar</code>, and then joins them together into a single formatted string. Finally, the formatted string is passed into <code class="Code-In-Text--PACKT-">output_var</code>, which will update the label at the bottom of the main window to display our values from the form. In a real application, you might save the retrieved data to a file or use them as parameters to a batch operation, for example.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">When should you use<a id="_idIndexMarker289"/> an instance variable (for example, <code class="Code-In-Text--PACKT-">self.jsonvar</code>), and when should you use regular variables (for example, <code class="Code-In-Text--PACKT-">data</code>), in an instance method? Regular variables<a id="_idIndexMarker290"/> in a method are <strong class="keyword">local</strong> in their scope, meaning they are destroyed as soon as the method returns. In addition, they cannot be referenced by other methods in the class. Instance variables stay in scope for the lifetime of the instance itself, and are available for any other instance method to read or write. In the case of the <code class="Code-In-Text--PACKT-">Application</code> class, the <code class="Code-In-Text--PACKT-">data</code> variable was only needed inside the <code class="Code-In-Text--PACKT-">_on_data_change()</code> method, whereas <code class="Code-In-Text--PACKT-">jsonvar</code> needed to be accessed in both <code class="Code-In-Text--PACKT-">__init__()</code> and <code class="Code-In-Text--PACKT-">_on_datachange()</code>.</p>
    </div>
    <p class="normal">Since we've subclassed <code class="Code-In-Text--PACKT-">Tk</code>, we should no longer start our script with the line <code class="Code-In-Text--PACKT-">root = tk.Tk()</code>. Make sure to delete that line, and also to delete the previous lines of the code that reference <code class="Code-In-Text--PACKT-">root</code>. Instead, we'll execute our application like this:</p>
    <pre class="programlisting code"><code class="hljs-code">if __name__ == "__main__":
  app = Application()
  app.mainloop()
</code></pre>
    <p class="normal">Note that these lines, our class definitions, and our imports are the only top-level code we're executing. That cleans up our global scope considerably, isolating the finer details of our code to a more limited scope.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">In Python, <code class="Code-In-Text--PACKT-">if __name__ == "__main__":</code> is a common idiom to check if a script is being run directly, such as when we type <code class="Code-In-Text--PACKT-">python3 tkinter_classes_demo.py</code> at a command prompt. If we were to import this file as a module into another Python script, this check would be false and the code inside the block would not be run. It's a good practice to put your program's main execution code below this check so that you can safely reuse your classes and functions in larger applications.</p>
    </div>
    <h1 id="_idParaDest-95" class="title">Rewriting our application using classes</h1>
    <p class="normal">Now that we've learned<a id="_idIndexMarker291"/> these techniques for using classes<a id="_idIndexMarker292"/> in our code, let's apply it to our ABQ Data Entry application. We'll start with a fresh file called <code class="Code-In-Text--PACKT-">data_entry_app.py</code> and add in our import statements, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># data_entry_app.py</span>
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path
<span class="hljs-keyword">import</span> csv
<span class="hljs-keyword">import</span> tkinter <span class="hljs-keyword">as</span> tk
<span class="hljs-keyword">from</span> tkinter <span class="hljs-keyword">import</span> ttk
</code></pre>
    <p class="normal">Now, let's see how we can apply some class-based techniques to rewrite a cleaner version of our application code.</p>
    <h2 id="_idParaDest-96" class="title">Adding a StringVar to the Text widget</h2>
    <p class="normal">One annoyance we discovered<a id="_idIndexMarker293"/> in creating our application was that the <code class="Code-In-Text--PACKT-">Text</code> widget does not allow the use of a <code class="Code-In-Text--PACKT-">StringVar</code> to store its content, requiring us to treat it differently than all our other<a id="_idIndexMarker294"/> widgets. There <em class="italic">is</em> a good reason for this: the Tkinter <code class="Code-In-Text--PACKT-">Text</code> widget<a id="_idIndexMarker295"/> is far more than just a multi-line <code class="Code-In-Text--PACKT-">Entry</code> widget, capable of containing rich text, images, and other things that a lowly <code class="Code-In-Text--PACKT-">StringVar</code> cannot store. That said, we're not using any of those features, so it would be better for us to have a more limited <code class="Code-In-Text--PACKT-">Text</code> widget that can be bound to a variable.</p>
    <p class="normal">Let's create a subclass called <code class="Code-In-Text--PACKT-">BoundText</code> to solve this problem; start with this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BoundText</span><span class="hljs-class">(</span><span class="hljs-params">tk.Text</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""A Text widget with a bound variable."""</span>
</code></pre>
    <p class="normal">Our class needs to add three things to the <code class="Code-In-Text--PACKT-">Text</code> class:</p>
    <ul>
      <li class="bullet">It needs to allow us to pass in a <code class="Code-In-Text--PACKT-">StringVar</code>, which it will be bound to.</li>
      <li class="bullet">It needs to update the widget contents whenever the variable is updated; for example, if it were loaded in from a file<a id="_idIndexMarker296"/> or changed by another widget.</li>
      <li class="bullet">It needs to update the variable<a id="_idIndexMarker297"/> contents whenever the widget is updated; for example, when<a id="_idIndexMarker298"/> the user types or pastes content into the widget.</li>
    </ul>
    <h3 id="_idParaDest-97" class="title">Passing in a variable</h3>
    <p class="normal">We'll begin by overriding the initializer to allow a control variable to be<a id="_idIndexMarker299"/> passed in:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, textvariable=</span><span class="hljs-literal">None</span><span class="hljs-params">, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
    self._variable = textvariable
</code></pre>
    <p class="normal">In keeping with Tkinter convention, we'll use the <code class="Code-In-Text--PACKT-">textvariable</code> argument to pass in the <code class="Code-In-Text--PACKT-">StringVar</code> object. Having passed the remaining arguments to <code class="Code-In-Text--PACKT-">super().__init__()</code>, we store the variable as a protected member of the class.</p>
    <p class="normal">Next, if the user has provided a variable, we'll go ahead and insert its contents into the widget (this takes care of any default value assigned to the variable):</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> self._variable:
      self.insert(<span class="hljs-string">'1.0'</span>, self._variable.get())
</code></pre>
    <p class="normal">Note that, if a variable was not passed in, <code class="Code-In-Text--PACKT-">textvariable</code> (and consequently <code class="Code-In-Text--PACKT-">self._variable</code>) will be <code class="Code-In-Text--PACKT-">None</code>.</p>
    <h3 id="_idParaDest-98" class="title">Synchronizing the widget to the variable</h3>
    <p class="normal">The next thing we<a id="_idIndexMarker300"/> need to do is bind modifications of the control variable to an instance method that will update the widget.</p>
    <p class="normal">Still working in the <code class="Code-In-Text--PACKT-">__init__()</code> method, let's add a trace inside the <code class="Code-In-Text--PACKT-">if</code> block we just created, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> self._variable:
      self.insert(<span class="hljs-string">'1.0'</span>, self._variable.get())
      <span class="code-highlight"><strong class="hljs-slc">self._variable.trace_add('write', self._set_content)</strong></span>
</code></pre>
    <p class="normal">The callback for our trace is a protected member function called <code class="Code-In-Text--PACKT-">_set_content()</code>, which will update the content of the widget with the contents of the variable. Let's go ahead and create that callback:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_set_content</span><span class="hljs-function">(</span><span class="hljs-params">self, *_</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Set the text contents to the variable"""</span>
    self.delete(<span class="hljs-string">'1.0'</span>, tk.END)
    self.insert(<span class="hljs-string">'1.0'</span>, self._variable.get())
</code></pre>
    <p class="normal">First, note that the argument list of our callback includes <code class="Code-In-Text--PACKT-">*_</code>. This notation simply wraps up any positional<a id="_idIndexMarker301"/> arguments passed to the function in a variable called <code class="Code-In-Text--PACKT-">_</code> (underscore). A single underscore, or series of underscores, is a conventional way of naming Python variables that we need to provide but don't intend to use. In this case, we're using it to consume any additional arguments that Tkinter will pass to this function when it calls it in response to an event. You'll see this same technique used in other callback methods whenever we intend to bind them to Tkinter events.</p>
    <p class="normal">Inside the method, we'll simply modify the widget contents using its <code class="Code-In-Text--PACKT-">delete()</code> and <code class="Code-In-Text--PACKT-">insert()</code> methods.</p>
    <h3 id="_idParaDest-99" class="title">Synchronizing the variable to the widget</h3>
    <p class="normal">Updating the variable<a id="_idIndexMarker302"/> when the widget is modified is slightly more involved. We need to find an event that will fire whenever the <code class="Code-In-Text--PACKT-">Text</code> widget is edited to bind to our callback. We could use the <code class="Code-In-Text--PACKT-">&lt;Key&gt;</code> event, which fires whenever a key is pressed, but it won't capture mouse-based edits such as a paste operation. The <code class="Code-In-Text--PACKT-">Text</code> widget does, however, have a <code class="Code-In-Text--PACKT-">&lt;&lt;Modified&gt;&gt;</code> event that is emitted when it is first modified.</p>
    <p class="normal">We can start with that; add another line to the end of our <code class="Code-In-Text--PACKT-">if</code> statement in <code class="Code-In-Text--PACKT-">__init__()</code>, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> self._variable:
      self.insert(<span class="hljs-string">'1.0'</span>, self._variable.get())
      self._variable.trace_add(<span class="hljs-string">'write'</span>, self._set_content)
      <code style="font-weight: bold;" class="codeHighlighted">self.bind('&lt;&lt;Modified&gt;&gt;', self._set_var)</code>
</code></pre>
    <p class="normal">Rather unintuitively, though, <code class="Code-In-Text--PACKT-">&lt;&lt;Modified&gt;&gt;</code> only fires the first time the widget is modified. After that, we'll need to reset the event by changing the widget's modified flag. We can do this using the <code class="Code-In-Text--PACKT-">Text</code> widget's <code class="Code-In-Text--PACKT-">edit_modified()</code> method, which also allows us to retrieve the state of the modified flag.</p>
    <p class="normal">To see how this will work, let's write the <code class="Code-In-Text--PACKT-">_set_var()</code> callback:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_set_var</span><span class="hljs-function">(</span><span class="hljs-params">self, *_</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Set the variable to the text contents"""</span>
    if self.edit_modified():
      content = self.get('1.0', 'end-1chars')
      self._variable.set(content)
      self.edit_modified(False)
</code></pre>
    <p class="normal">In this method, we begin by checking if the widget has been modified by calling <code class="Code-In-Text--PACKT-">edit_modified()</code>. If it has, we'll retrieve the content using the widget's <code class="Code-In-Text--PACKT-">get()</code> method. Notice that the ending<a id="_idIndexMarker303"/> index for get is <code class="Code-In-Text--PACKT-">end-1chars</code>. This means "one character before the end of the content." Recall that the <code class="Code-In-Text--PACKT-">Text</code> widget's <code class="Code-In-Text--PACKT-">get()</code> method automatically appends a newline to the end of the content, so by using this index, we can eliminate the extra newline.</p>
    <p class="normal">After retrieving the contents of the widget, we need to reset the modified flag by passing <code class="Code-In-Text--PACKT-">False</code> into the <code class="Code-In-Text--PACKT-">edit_modified()</code> method. That way, it is ready to fire the <code class="Code-In-Text--PACKT-">&lt;&lt;Modified&gt;&gt;</code> event the next time the user interacts with the widget.</p>
    <h2 id="_idParaDest-100" class="title">Creating a more advanced LabelInput()</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">LabelInput</code> class we created earlier under <em class="italic">Creating compound widgets</em> seems useful, but if we want<a id="_idIndexMarker304"/> to use it in our program, it's going<a id="_idIndexMarker305"/> to require some more fleshing out.</p>
    <p class="normal">Let's start, once again, with our class definition and initializer method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># data_entry_app.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">LabelInput</span><span class="hljs-class">(</span><span class="hljs-params">tk.Frame</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""A widget containing a label and input together."""</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span>
<span class="hljs-params">    self, parent, label, var, input_class=ttk.Entry,</span>
<span class="hljs-params">    input_args=</span><span class="hljs-literal">None</span><span class="hljs-params">, label_args=</span><span class="hljs-literal">None</span><span class="hljs-params">, **kwargs</span>
<span class="hljs-params">  </span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(parent, **kwargs)
    input_args = input_args <span class="hljs-keyword">or</span> {}
    label_args = label_args <span class="hljs-keyword">or</span> {}
    self.variable = var
    self.variable.label_widget = self
</code></pre>
    <p class="normal">As before, we've got arguments for the parent widget, label text, input class, and input arguments. Since every widget we want to use can now have a variable bound to it, we'll also go ahead and accept that as a required argument, and we'll add an optional argument for a dictionary of arguments to pass to the label widget, should we need that. We're defaulting <code class="Code-In-Text--PACKT-">input_class</code> to <code class="Code-In-Text--PACKT-">ttk.Entry</code>, since we have several of those.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Note that the default values for the <code class="Code-In-Text--PACKT-">input_args</code> and <code class="Code-In-Text--PACKT-">label_args</code> arguments are <code class="Code-In-Text--PACKT-">None</code>, and that we make them dictionaries inside the method if they are <code class="Code-In-Text--PACKT-">None</code>. Why not just use empty dictionaries as default arguments? In Python, default arguments are evaluated when the function definition is first run. This means that a dictionary object created in the function signature will be the same object every time the function is run, rather than a fresh, empty dictionary each time. Since we want a fresh, empty dictionary each time, we create the dictionaries inside the function body rather than the argument list. The same holds for lists and other mutable objects. </p>
    </div>
    <p class="normal">Inside the<a id="_idIndexMarker306"/> method, we call <code class="Code-In-Text--PACKT-">super().__init__()</code> as usual, and then ensure that <code class="Code-In-Text--PACKT-">input_args</code> and <code class="Code-In-Text--PACKT-">label_args</code> are dictionaries. Finally, we'll save the <code class="Code-In-Text--PACKT-">input_var</code> to an instance variable, and save the label widget<a id="_idIndexMarker307"/> itself as a property of the variable object. Doing this means we won't have to store references to our <code class="Code-In-Text--PACKT-">LabelInput</code> objects; we can just access them through the variable object if we need to.</p>
    <p class="normal">Next, it's time to set up the label, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> input_class <span class="hljs-keyword">in</span> (ttk.Checkbutton, ttk.Button):
      input_args[<span class="hljs-string">"text"</span>] = label
    <span class="hljs-keyword">else</span>:
      self.label = ttk.Label(self, text=label, **label_args)
      self.label.grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>, sticky=(tk.W + tk.E))
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">Checkbutton</code> and <code class="Code-In-Text--PACKT-">Button</code> widgets have a label built into them, so we don't want to have a separate label hanging around. Instead, we'll just set the <code class="Code-In-Text--PACKT-">text</code> argument of the widget to whatever is passed in. (<code class="Code-In-Text--PACKT-">Radiobutton</code> objects also have a label built in, but we'll handle those slightly differently, as you'll see in a moment). For all other widgets, we'll add a <code class="Code-In-Text--PACKT-">Label</code> widget to the first row and column of the <code class="Code-In-Text--PACKT-">LabelInput</code>.</p>
    <p class="normal">Next, we need to set up the input arguments so that the input's control variable will be passed in with the correct argument name:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> input_class <span class="hljs-keyword">in</span> (
      ttk.Checkbutton, ttk.Button, ttk.Radiobutton
    ):
      input_args[<span class="hljs-string">"variable"</span>] = self.variable
    <span class="hljs-keyword">else</span>:
      input_args[<span class="hljs-string">"textvariable"</span>] = self.variable
</code></pre>
    <p class="normal">Recall that button classes use <code class="Code-In-Text--PACKT-">variable</code> as the argument name, while all others use <code class="Code-In-Text--PACKT-">textvariable</code>. By handling this inside the class, we won't need to worry about that distinction when building our form.</p>
    <p class="normal">Now, let's set up the input widget. Most widgets will be simple to set up, but for <code class="Code-In-Text--PACKT-">Radiobutton</code>, we need to do something different. We need to create a <code class="Code-In-Text--PACKT-">Radiobutton</code> widget for each possible value<a id="_idIndexMarker308"/> that's passed in (using the <code class="Code-In-Text--PACKT-">values</code> key in <code class="Code-In-Text--PACKT-">input_args</code>). Remember that we link the buttons by having them share the same variable, which we'll do here.</p>
    <p class="normal">We'll add it like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> input_class == ttk.Radiobutton:
      self.<span class="hljs-built_in">input</span> = tk.Frame(self)
      <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> input_args.pop(<span class="hljs-string">'values'</span>, []):
        button = ttk.Radiobutton(
          self.<span class="hljs-built_in">input</span>, value=v, text=v, **input_args
        )
        button.pack(
          side=tk.LEFT, ipadx=<span class="hljs-number">10</span>, ipady=<span class="hljs-number">2</span>, expand=<span class="hljs-literal">True</span>, fill=<span class="hljs-string">'x'</span>
        )
</code></pre>
    <p class="normal">First, we create a <code class="Code-In-Text--PACKT-">Frame</code> object<a id="_idIndexMarker309"/> to hold the buttons; then, for each value passed into <code class="Code-In-Text--PACKT-">values</code>, we add a <code class="Code-In-Text--PACKT-">Radiobutton</code> widget to the <code class="Code-In-Text--PACKT-">Frame</code> layout. Note that we call the <code class="Code-In-Text--PACKT-">pop()</code> method to get the <code class="Code-In-Text--PACKT-">values</code> item from the <code class="Code-In-Text--PACKT-">input_args</code> dict. <code class="Code-In-Text--PACKT-">dict.pop()</code> is nearly identical to <code class="Code-In-Text--PACKT-">dict.get()</code>, returning the value of the given key if it exists, or the second argument if it does not. The difference is that <code class="Code-In-Text--PACKT-">pop()</code> also deletes the retrieved item from the dictionary. We're doing this because <code class="Code-In-Text--PACKT-">values</code> isn't a valid argument for <code class="Code-In-Text--PACKT-">Radiobutton</code>, so we need to remove it before passing <code class="Code-In-Text--PACKT-">input_args</code> to the <code class="Code-In-Text--PACKT-">Radiobutton</code> initializer. The remaining items in <code class="Code-In-Text--PACKT-">input_args</code> should be valid keyword arguments to the widget.</p>
    <p class="normal">In the case of non-<code class="Code-In-Text--PACKT-">Radiobutton</code> widgets, it's pretty straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">else</span>:
      self.<span class="hljs-built_in">input</span> = input_class(self, **input_args)
</code></pre>
    <p class="normal">We simply call whatever <code class="Code-In-Text--PACKT-">input_class</code> class has been passed in with the <code class="Code-In-Text--PACKT-">input_args</code>. Now that we have <code class="Code-In-Text--PACKT-">self.input</code> created, we just need to add it to the <code class="Code-In-Text--PACKT-">LabelInput</code> layout:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.<span class="hljs-built_in">input</span>.grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>, sticky=(tk.W + tk.E))
    self.columnconfigure(<span class="hljs-number">0</span>, weight=<span class="hljs-number">1</span>)
</code></pre>
    <p class="normal">The final call to <code class="Code-In-Text--PACKT-">columnconfigure</code> tells the <code class="Code-In-Text--PACKT-">LabelWidget</code> widget to fill its entire width with column <code class="Code-In-Text--PACKT-">0</code>.</p>
    <p class="normal">One convenient thing we can do when creating our own widgets (either a custom subclass or compound widget) is to set some reasonable defaults for the geometry layout. For example, we're going to want all our <code class="Code-In-Text--PACKT-">LabelInput</code> widgets to stick to the left- and right-hand sides of their container<a id="_idIndexMarker310"/> so that they fill the maximum width available. Rather than having to pass in <code class="Code-In-Text--PACKT-">sticky=(tk.E + tk.W)</code> every single time we position a <code class="Code-In-Text--PACKT-">LabelInput</code> widget, let's make it the default, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">grid</span><span class="hljs-function">(</span><span class="hljs-params">self, sticky=(tk.E + tk.W), **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Override grid to add default sticky values"""</span>
    <span class="hljs-built_in">super</span>().grid(sticky=sticky, **kwargs)
</code></pre>
    <p class="normal">We've overridden <code class="Code-In-Text--PACKT-">grid</code> and simply<a id="_idIndexMarker311"/> passed on the arguments to the superclass version but added a default for <code class="Code-In-Text--PACKT-">sticky</code>. We can still override it if needed, but it will save us a lot of clutter to make that default.</p>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">LabelInput</code> is fairly robust now; time to put it to work!</p>
    <h2 id="_idParaDest-101" class="title">Creating a form class</h2>
    <p class="normal">Now that our building blocks are ready, it's time to build the major components of our application. Breaking the application<a id="_idIndexMarker312"/> into sensible components requires some thinking about what might constitute<a id="_idIndexMarker313"/> a reasonable division of responsibilities. Initially, it seems like our application could be broken into two components: the data entry form and the root application itself. But which features go where?</p>
    <p class="normal">One reasonable assessment might be as follows:</p>
    <ul>
      <li class="bullet">The data entry form itself should contain all the widgets, of course. It should also hold the Save and Reset buttons, since these make no sense being separate from the form.</li>
      <li class="bullet">The application title and status bar belong at a universal level, since they will apply to all parts of the application. File saving could go with the form, but it also has to interact with some application-level items like the status bar or <code class="Code-In-Text--PACKT-">records_saved</code> variable. It's a tricky call, but we'll put it with the application object for now.</li>
    </ul>
    <p class="normal">Let's begin by building our data entry form class, <code class="Code-In-Text--PACKT-">DataRecordForm</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># data_entry_app.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">DataRecordForm</span><span class="hljs-class">(</span><span class="hljs-params">ttk.Frame</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""The input form for our widgets"""</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
</code></pre>
    <p class="normal">As always, we begin by subclassing <code class="Code-In-Text--PACKT-">Frame</code> and calling the superclass's initializer method. We don't really need<a id="_idIndexMarker314"/> to add any custom arguments<a id="_idIndexMarker315"/> at this point.</p>
    <p class="normal">Now, let's create a dictionary to hold all our variable objects:</p>
    <pre class="programlisting code"><code class="hljs-code">    self._<span class="hljs-built_in">vars</span> = {
      <span class="hljs-string">'Date'</span>: tk.StringVar(),
      <span class="hljs-string">'Time'</span>: tk.StringVar(),
      <span class="hljs-string">'Technician'</span>: tk.StringVar(),
      <span class="hljs-string">'Lab'</span>: tk.StringVar(),
      <span class="hljs-string">'Plot'</span>: tk.IntVar(),
      <span class="hljs-string">'Seed Sample'</span>: tk.StringVar(),
      <span class="hljs-string">'Humidity'</span>: tk.DoubleVar(),
      <span class="hljs-string">'Light'</span>: tk.DoubleVar(),
      <span class="hljs-string">'Temperature'</span>: tk.DoubleVar(),
      <span class="hljs-string">'Equipment Fault'</span>: tk.BooleanVar(),
      <span class="hljs-string">'Plants'</span>: tk.IntVar(),
      <span class="hljs-string">'Blossoms'</span>: tk.IntVar(),
      <span class="hljs-string">'Fruit'</span>: tk.IntVar(),
      <span class="hljs-string">'Min Height'</span>: tk.DoubleVar(),
      <span class="hljs-string">'Max Height'</span>: tk.DoubleVar(),
      <span class="hljs-string">'Med Height'</span>: tk.DoubleVar(),
      <span class="hljs-string">'Notes'</span>: tk.StringVar()
    }
</code></pre>
    <p class="normal">This is just straight out of our data dictionary. Note that, thanks to our <code class="Code-In-Text--PACKT-">BoundText</code> class, we can assign a <code class="Code-In-Text--PACKT-">StringVar</code> object to Notes. Now, we're ready to start adding widgets to our GUI. In the current version of our application, we added a <code class="Code-In-Text--PACKT-">LabelFrame</code> widget for each section of the application using a chunk of code like this:</p>
    <pre class="programlisting code"><code class="hljs-code">r_info = ttk.LabelFrame(drf, text=<span class="hljs-string">'Record Information'</span>)
r_info.grid(sticky=(tk.W + tk.E))
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):
  r_info.columnconfigure(i, weight=<span class="hljs-number">1</span> )
</code></pre>
    <p class="normal">This code was repeated for each frame, with only a change to the variable name and label text. To avoid this repetition, we can abstract this process into an instance method. Let's create a method that can add a new label frame for us; add this code just above the <code class="Code-In-Text--PACKT-">__init__()</code> definition:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_add_frame</span><span class="hljs-function">(</span><span class="hljs-params">self, label, cols=</span><span class="hljs-number">3</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Add a LabelFrame to the form"""</span>
    frame = ttk.LabelFrame(self, text=label)
    frame.grid(sticky=tk.W + tk.E)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(cols):
      frame.columnconfigure(i, weight=<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> frame
</code></pre>
    <p class="normal">This method simply redefines<a id="_idIndexMarker316"/> the earlier code in a generic way, so we can just pass in the label text and, optionally, a number<a id="_idIndexMarker317"/> of columns. Scroll back down to where we were in the <code class="Code-In-Text--PACKT-">DataRecordForm.__init__()</code> method, and let's put this method to use by making a Record Information section, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    r_info = self._add_frame(<span class="hljs-string">"Record Information"</span>)
</code></pre>
    <p class="normal">Now that we have our frame, let's give <code class="Code-In-Text--PACKT-">LabelInput</code> a try and start building the first section of the form, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">    LabelInput(
      r_info, <span class="hljs-string">"Date"</span>, var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Date'</span>]
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>)
    LabelInput(
      r_info, <span class="hljs-string">"Time"</span>, input_class=ttk.Combobox,
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Time'</span>],
      input_args={<span class="hljs-string">"values"</span>: [<span class="hljs-string">"8:00"</span>, <span class="hljs-string">"12:00"</span>, <span class="hljs-string">"16:00"</span>, <span class="hljs-string">"20:00"</span>]}
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>)
    LabelInput(
      r_info, <span class="hljs-string">"Technician"</span>,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Technician'</span>]
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">As you can see, <code class="Code-In-Text--PACKT-">LabelInput</code> has saved us a lot of redundant clutter already!</p>
    <p class="normal">Let's continue with the second line:</p>
    <pre class="programlisting code"><code class="hljs-code">    LabelInput(
      r_info, <span class="hljs-string">"Lab"</span>, input_class=ttk.Radiobutton,
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Lab'</span>],
      input_args={<span class="hljs-string">"values"</span>: [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>]}
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>)
    LabelInput(
      r_info, <span class="hljs-string">"Plot"</span>, input_class=ttk.Combobox,
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Plot'</span>],
      input_args={<span class="hljs-string">"values"</span>: <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">21</span>))}
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>)
    LabelInput(
      r_info, <span class="hljs-string">"Seed Sample"</span>,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Seed Sample'</span>]
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">Remember that to use <code class="Code-In-Text--PACKT-">RadioButton</code> widgets with <code class="Code-In-Text--PACKT-">LabelInput</code>, we need to pass in a list of values to the input<a id="_idIndexMarker318"/> arguments, just as we do for <code class="Code-In-Text--PACKT-">Combobox</code>. Having<a id="_idIndexMarker319"/> finished the <code class="Code-In-Text--PACKT-">Record Information</code> section, let's continue with the next section, <code class="Code-In-Text--PACKT-">Environmental Data</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">    e_info = self._add_frame(<span class="hljs-string">"Environment Data"</span>)
    LabelInput(
      e_info, <span class="hljs-string">"Humidity (g/m³)"</span>,
      input_class=ttk.Spinbox,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Humidity'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0.5</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">52.0</span>, <span class="hljs-string">"increment"</span>: <span class="hljs-number">.01</span>}
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>)
    LabelInput(
      e_info, <span class="hljs-string">"Light (klx)"</span>, input_class=ttk.Spinbox,
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Light'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">100</span>, <span class="hljs-string">"increment"</span>: <span class="hljs-number">.01</span>}
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>)
    LabelInput(
      e_info, <span class="hljs-string">"Temperature (°C)"</span>,
      input_class=ttk.Spinbox,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Temperature'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">4</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">40</span>, <span class="hljs-string">"increment"</span>: <span class="hljs-number">.01</span>}
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">2</span>)
    LabelInput(
      e_info, <span class="hljs-string">"Equipment Fault"</span>,
      input_class=ttk.Checkbutton,  
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Equipment Fault'</span>]
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>, columnspan=<span class="hljs-number">3</span>)
</code></pre>
    <p class="normal">Again, we have added<a id="_idIndexMarker320"/> and configured a <code class="Code-In-Text--PACKT-">LabelFrame</code> using<a id="_idIndexMarker321"/> our <code class="Code-In-Text--PACKT-">_add_frame()</code> method, populating it with the four <code class="Code-In-Text--PACKT-">LabelInput</code> widgets.</p>
    <p class="normal">Now, let's add the <code class="Code-In-Text--PACKT-">Plant Data</code> sections:</p>
    <pre class="programlisting code"><code class="hljs-code">    p_info = self._add_frame(<span class="hljs-string">"Plant Data"</span>)
    LabelInput(
      p_info, <span class="hljs-string">"Plants"</span>, input_class=ttk.Spinbox,
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Plants'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">20</span>}
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">0</span>)
    LabelInput(
      p_info, <span class="hljs-string">"Blossoms"</span>, input_class=ttk.Spinbox,
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Blossoms'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">1000</span>}
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">1</span>)
    LabelInput(
      p_info, <span class="hljs-string">"Fruit"</span>, input_class=ttk.Spinbox,
      var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Fruit'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">1000</span>}
    ).grid(row=<span class="hljs-number">0</span>, column=<span class="hljs-number">2</span>)
    LabelInput(
      p_info, <span class="hljs-string">"Min Height (cm)"</span>,
      input_class=ttk.Spinbox,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Min Height'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">"increment"</span>: <span class="hljs-number">.01</span>}
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">0</span>)
    LabelInput(
      p_info, <span class="hljs-string">"Max Height (cm)"</span>,
      input_class=ttk.Spinbox,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Max Height'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">"increment"</span>: <span class="hljs-number">.01</span>}
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">1</span>)
    LabelInput(
      p_info, <span class="hljs-string">"Median Height (cm)"</span>,
      input_class=ttk.Spinbox,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Med Height'</span>],
      input_args={<span class="hljs-string">"from_"</span>: <span class="hljs-number">0</span>, <span class="hljs-string">"to"</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">"increment"</span>: <span class="hljs-number">.01</span>}
    ).grid(row=<span class="hljs-number">1</span>, column=<span class="hljs-number">2</span>)
</code></pre>
    <p class="normal">We're almost done; let's add our <code class="Code-In-Text--PACKT-">Notes</code> section next:</p>
    <pre class="programlisting code"><code class="hljs-code">    LabelInput(
      self, <span class="hljs-string">"Notes"</span>,
      input_class=BoundText,  var=self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Notes'</span>],
      input_args={<span class="hljs-string">"width"</span>: <span class="hljs-number">75</span>, <span class="hljs-string">"height"</span>: <span class="hljs-number">10</span>}
    ).grid(sticky=tk.W, row=<span class="hljs-number">3</span>, column=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">Here, we're taking<a id="_idIndexMarker322"/> advantage of our <code class="Code-In-Text--PACKT-">BoundText</code> object<a id="_idIndexMarker323"/> so we can attach a variable. Otherwise, this looks like all the other calls to <code class="Code-In-Text--PACKT-">LabelInput</code>.</p>
    <p class="normal">Now, it's time for the buttons:</p>
    <pre class="programlisting code"><code class="hljs-code">    buttons = tk.Frame(self)
    buttons.grid(sticky=tk.W + tk.E, row=<span class="hljs-number">4</span>)
    self.savebutton = ttk.Button(
      buttons, text=<span class="hljs-string">"Save"</span>, command=self.master._on_save)
    self.savebutton.pack(side=tk.RIGHT)
    self.resetbutton = ttk.Button(
      buttons, text=<span class="hljs-string">"Reset"</span>, command=self.reset)
    self.resetbutton.pack(side=tk.RIGHT)
</code></pre>
    <p class="normal">As before, we've added our button widgets on a <code class="Code-In-Text--PACKT-">Frame</code>. This time, though, we're going to pass in some instance methods as callback commands for the buttons. The <code class="Code-In-Text--PACKT-">Reset</code> button will get an instance method we'll define in this class, but since we decided that saving a file was the application object's responsibility, we're binding the <code class="Code-In-Text--PACKT-">Save</code> button to an instance method on the parent object (accessed through this object's <code class="Code-In-Text--PACKT-">master</code> attribute).</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Binding GUI objects directly to commands on other objects is not a good way to approach the problem of inter-object communication, but for now it will do the job. In <em class="chapterRef">Chapter 6</em>, <em class="italic">Planning for the Expansion of Our Application</em>, we'll learn a more elegant way to accomplish this. </p>
    </div>
    <p class="normal">That wraps up our <code class="Code-In-Text--PACKT-">__init__()</code> method, but we're going to need a couple more methods on this class before we're done. First, we need to implement the <code class="Code-In-Text--PACKT-">reset()</code> method that handles our form reset; it will look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">reset</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Resets the form entries"""</span>
    <span class="hljs-keyword">for</span> var <span class="hljs-keyword">in</span> self._<span class="hljs-built_in">vars</span>.values():
      <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(var, tk.BooleanVar):
        var.<span class="hljs-built_in">set</span>(<span class="hljs-literal">False</span>)
      <span class="hljs-keyword">else</span>:
        var.<span class="hljs-built_in">set</span>(<span class="hljs-string">''</span>)
</code></pre>
    <p class="normal">Essentially, we just need to set all our variables to an empty string. In the case of <code class="Code-In-Text--PACKT-">BooleanVar</code> objects, though, this will raise an exception, so we need to set it to <code class="Code-In-Text--PACKT-">False</code> to uncheck our checkbox.</p>
    <p class="normal">Finally, we need a method<a id="_idIndexMarker324"/> that will allow the application object<a id="_idIndexMarker325"/> to retrieve data from the form so that it can save the data. In keeping with Tkinter convention, we'll call this method <code class="Code-In-Text--PACKT-">get()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    data = <span class="hljs-built_in">dict</span>()
    fault = self._<span class="hljs-built_in">vars</span>[<span class="hljs-string">'Equipment Fault'</span>].get()
    <span class="hljs-keyword">for</span> key, variable <span class="hljs-keyword">in</span> self._<span class="hljs-built_in">vars</span>.items():
      <span class="hljs-keyword">if</span> fault <span class="hljs-keyword">and</span> key <span class="hljs-keyword">in</span> (<span class="hljs-string">'Light'</span>, <span class="hljs-string">'Humidity'</span>, <span class="hljs-string">'Temperature'</span>):
        data[key] = <span class="hljs-string">''</span>
      <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">try</span>:
          data[key] = variable.get()
        <span class="hljs-keyword">except</span> tk.TclError:
          message = <span class="hljs-string">f'Error in field: </span><span class="hljs-subst">{key}</span><span class="hljs-string">.  Data was not saved!'</span>
          <span class="hljs-keyword">raise</span> ValueError(message)
    <span class="hljs-keyword">return</span> data
</code></pre>
    <p class="normal">The code here is very similar to the data retrieval code in the <code class="Code-In-Text--PACKT-">on_save()</code> function of our previous version of the application, with a couple of differences. First, we're retrieving data from <code class="Code-In-Text--PACKT-">self._vars</code> rather than a global variables dictionary. Secondly, in the event of an error, we're creating an error message and re-raising a <code class="Code-In-Text--PACKT-">ValueError</code> rather than directly updating the GUI. We'll have to make sure that code that calls this method is written to handle a <code class="Code-In-Text--PACKT-">ValueError</code> exception. Finally, rather than saving the data as we did in the previous version of the application, we're merely returning it.</p>
    <p class="normal">That completes the form class! Now all that remains is to code an application to keep it in.</p>
    <h2 id="_idParaDest-102" class="title">Creating an application class</h2>
    <p class="normal">Our application class is going<a id="_idIndexMarker326"/> to handle application-level functionality as well as being our top-level window. GUI-wise, it needs to contain:</p>
    <ul>
      <li class="bullet">A title label</li>
      <li class="bullet">An instance of our <code class="Code-In-Text--PACKT-">DataRecordForm</code> class</li>
      <li class="bullet">A status bar</li>
    </ul>
    <p class="normal">It will also need a method to save the data in the form to a CSV.</p>
    <p class="normal">Let's begin our class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Application</span><span class="hljs-class">(</span><span class="hljs-params">tk.Tk</span><span class="hljs-class">):</span>
  <span class="hljs-string">"""Application root window"""</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, *args, **kwargs</span><span class="hljs-function">):</span>
    <span class="hljs-built_in">super</span>().__init__(*args, **kwargs)
</code></pre>
    <p class="normal">Nothing new here, except that now we're subclassing <code class="Code-In-Text--PACKT-">Tk</code> instead of <code class="Code-In-Text--PACKT-">Frame</code>.</p>
    <p class="normal">Let's set up some window parameters:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.title(<span class="hljs-string">"ABQ Data Entry Application"</span>)
    self.columnconfigure(0, weight=1)
</code></pre>
    <p class="normal">As with the procedural version of the program, we've set the window title and configured the first column of the grid to expand. Now, we'll create the title label:</p>
    <pre class="programlisting code"><code class="hljs-code">    ttk.Label(
      self, text=<span class="hljs-string">"ABQ Data Entry Application"</span>,
      font=(<span class="hljs-string">"TkDefaultFont"</span>, <span class="hljs-number">16</span>)
    ).grid(row=<span class="hljs-number">0</span>)
</code></pre>
    <p class="normal">Nothing is really different here, except note that the parent object is now <code class="Code-In-Text--PACKT-">self</code> – there isn't going to be a <code class="Code-In-Text--PACKT-">root</code> object anymore; <code class="Code-In-Text--PACKT-">self</code> is our <code class="Code-In-Text--PACKT-">Tk</code> instance inside this class.</p>
    <p class="normal">Let's create a record form:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.recordform = DataRecordForm(self)
    self.recordform.grid(row=1, padx=10, sticky=(tk.W + tk.E))
</code></pre>
    <p class="normal">Despite the size and complexity of <code class="Code-In-Text--PACKT-">DataRecordForm</code>, adding it to the application is just like adding any other widget.</p>
    <p class="normal">Now, for the status bar:</p>
    <pre class="programlisting code"><code class="hljs-code">    self.status = tk.StringVar()
    ttk.Label(
      self, textvariable=self.status
    ).grid(sticky=(tk.W + tk.E), row=<span class="hljs-number">2</span>, padx=<span class="hljs-number">10</span>)
</code></pre>
    <p class="normal">Again, this is just like the procedural version, except that our <code class="Code-In-Text--PACKT-">status</code> variable is an instance variable. This means<a id="_idIndexMarker327"/> it will be accessible to any of the methods in our class.</p>
    <p class="normal">Finally, let's create a protected instance variable to hold the number of records saved:</p>
    <pre class="programlisting code"><code class="hljs-code">    self._records_saved = <span class="hljs-number">0</span>
</code></pre>
    <p class="normal">With <code class="Code-In-Text--PACKT-">__init__()</code> finished up, we can now write the last method: _<code class="Code-In-Text--PACKT-">on_save()</code>. This method will be very close to the procedural function we wrote previously:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> _</span><span class="hljs-title">on_save</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Handles save button clicks"""</span>
    datestring = datetime.today().strftime(<span class="hljs-string">"%Y-%m-%d"</span>)
    filename = <span class="hljs-string">"abq_data_record_{}.csv"</span>.<span class="hljs-built_in">format</span>(datestring)
    newfile = <span class="hljs-keyword">not</span> Path(filename).exists()
    try:
      data = self.recordform.get()
    except ValueError as e:
      self.status.set(str(e))
      return
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">'a', newline=''</span>) <span class="hljs-keyword">as</span> fh:
      csvwriter = csv.DictWriter(fh, fieldnames=data.keys())
      <span class="hljs-keyword">if</span> newfile:
        csvwriter.writeheader()
      csvwriter.writerow(data)
    self._records_saved += <span class="hljs-number">1</span>
    self.status.<span class="hljs-built_in">set</span>(
      <span class="hljs-string">"{} records saved this session"</span>.<span class="hljs-built_in">format</span>(self._records_saved))
    self.recordform.reset()
</code></pre>
    <p class="normal">Once again, this function generates the filename using the current date, and then opens the file in append mode. This time, though, we can get our data by simply calling <code class="Code-In-Text--PACKT-">self.recordform.get()</code>, which abstracts the process of getting data from its variables. Remember that we do have to handle <code class="Code-In-Text--PACKT-">ValueError</code> exceptions in case there is bad data in the form, which we've done here. In the case of bad data, we simply display the error in the status bar and exit before the method attempts to save the data. If there is no exception, the data is saved, so we increment the <code class="Code-In-Text--PACKT-">_records_saved</code> attribute and update the status.</p>
    <p class="normal">The final thing we need<a id="_idIndexMarker328"/> to make this application run is to create an instance of our <code class="Code-In-Text--PACKT-">Application</code> object and start its <code class="Code-In-Text--PACKT-">mainloop</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
  app = Application()
  app.mainloop()
</code></pre>
    <p class="normal">Note that, other than our class definitions and module imports, these two lines are the only ones being executed in the top-level scope. Also, because <code class="Code-In-Text--PACKT-">Application</code> takes care of building the GUI and other objects, we can execute it and the <code class="Code-In-Text--PACKT-">mainloop()</code> call together at the end of the application using the <code class="Code-In-Text--PACKT-">if __name__ == "__main__"</code> guard.</p>
    <h1 id="_idParaDest-103" class="title">Summary</h1>
    <p class="normal">In this chapter, you learned to take advantage of the power of Python classes. You learned to create your own classes, to define attributes and methods, and the function of magic methods. You also learned how to extend the functionality of existing classes with subclassing. </p>
    <p class="normal">We explored how these techniques can be applied powerfully to Tkinter classes, to extend their functionality, build compound widgets, and organize our application into components.</p>
    <p class="normal">In the next chapter, we'll learn about Tkinter's validation features, and further employ subclassing to make our widgets more intuitive and robust. We'll also learn how to automate input to save users time and ensure consistent data entry.</p>
  </div>
</body></html>