<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Extending Our GUI with the wxPython Library</h1></div></div></div><p>In this chapter, we will enhance our Python GUI by using the wxPython library.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to install the wxPython library</li><li class="listitem" style="list-style-type: disc">How to create our GUI in wxPython</li><li class="listitem" style="list-style-type: disc">Quickly adding controls using wxPython</li><li class="listitem" style="list-style-type: disc">Trying to embed a main wxPython app in a main tkinter app</li><li class="listitem" style="list-style-type: disc">Trying to embed our tkinter GUI code into wxPython</li><li class="listitem" style="list-style-type: disc">How to use Python to control two different GUI frameworks</li><li class="listitem" style="list-style-type: disc">How to communicate between the two connected GUIs</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Introduction</h1></div></div></div><p>In this chapter, we will introduce another Python GUI toolkit that currently does not ship with Python. It is <a id="id396" class="indexterm"/>called wxPython.</p><p>There are two <a id="id397" class="indexterm"/>versions of this library. The original is called Classic while<a id="id398" class="indexterm"/> the newest is called by its development project code name, Phoenix.</p><p>In this book, we are solely programming using Python 3, and because the new Phoenix project is aimed at supporting Python 3, this is the version of wxPython we are using in this chapter.</p><p>First, we will create a simple wxPython GUI, and then we will try to connect both the tkinter-based GUIs we developed in this book with the new wxPython library.</p><div><div><h3 class="title"><a id="note122"/>Note</h3><p>wxPython is a Python binding to wxWidgets.</p><p>The w in wxPython stands for the Windows OS and the x stands for Unix-based operating systems such as Linux and OS X.</p></div></div><p>If <a id="id399" class="indexterm"/>things don't work out using these two GUI toolkits in unison, we will attempt to use Python to solve any problems and then we will use <strong>Inter Process Communication</strong> (<strong>IPC</strong>) within Python to make sure that our Python code works as we want it to work.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>How to install the wxPython library</h1></div></div></div><p>The <a id="id400" class="indexterm"/>wxPython library does not ship with Python, so, in order to use it, we first have to install it.</p><p>This recipe will show us where and how to find the right version to install to match both the installed version of Python and the operating system we are running.</p><div><div><h3 class="title"><a id="note123"/>Note</h3><p>The wxPython third-party library has been around for more than 17 years, which indicates that it is a robust library.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec215"/>Getting ready</h2></div></div></div><p>In order to use wxPython with Python 3, we have to install the wxPython Phoenix version.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec216"/>How to do it...</h2></div></div></div><p>When<a id="id401" class="indexterm"/> searching online for wxPython, we will probably find the official website at <a class="ulink" href="http://www.wxpython.org">www.wxpython.org</a>.</p><div><img src="img/B04829_09_01.jpg" alt="How to do it..."/></div><p>If we click on the download link for MS Windows, we can see several Windows installers, all of which are for Python 2.x only.</p><div><img src="img/B04829_09_02.jpg" alt="How to do it..."/></div><p>To use <a id="id402" class="indexterm"/>wxPython with Python 3, we have to install the wxPython/Phoenix library. We <a id="id403" class="indexterm"/>can find the installer at the snapshot-builds link:</p><p>
<a class="ulink" href="http://wxpython.org/Phoenix/snapshot-builds/">http://wxpython.org/Phoenix/snapshot-builds/</a>
</p><p>From here, we can select the wxPython/Phoenix version that matches both our versions of Python and our OS. I am using Python 3.4 running on a 64-bit Windows 7 OS.</p><div><img src="img/B04829_09_03.jpg" alt="How to do it..."/></div><p>The Python wheel (<code class="literal">.whl</code>) installer package has a numbering scheme.</p><p>For us, the most important part of this scheme is that we are installing the wxPython/Phoenix build that is for Python 3.4 (the cp34 in the installer name) and for the Windows 64-bit OS (the win_amd64 part of the installer name).</p><div><img src="img/B04829_09_04.jpg" alt="How to do it..."/></div><p>After successfully downloading the wxPython/Phoenix package, we can now navigate to the directory where it resides and install this package using pip.</p><div><img src="img/B04829_09_05.jpg" alt="How to do it..."/></div><p>We <a id="id404" class="indexterm"/>have a new folder called <code class="literal">wx</code> in our Python <code class="literal">site-packages</code> folder.</p><div><img src="img/B04829_09_06.jpg" alt="How to do it..."/></div><div><div><h3 class="title"><a id="note124"/>Note</h3><p>
<code class="literal">wx</code> is the folder name the wxPython/Phoenix library installed into. We will import this module into our Python code.</p></div></div><p>We can verify that our installation worked by executing this simple demo script from the official <a id="id405" class="indexterm"/>wxPython/Phoenix website. The link to the official website is <a class="ulink" href="http://wxpython.org/Phoenix/docs/html/">http://wxpython.org/Phoenix/docs/html/</a>.</p><div><pre class="programlisting">import wx
app = wx.App()
frame = wx.Frame(None, -1, "Hello World")
frame.Show()
app.MainLoop()</pre></div><p>Running the preceding Python 3 script creates the following GUI using wxPython/Phoenix.</p><div><img src="img/B04829_09_07.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec217"/>How it works...</h2></div></div></div><p>In this<a id="id406" class="indexterm"/> recipe, we successfully installed the correct version of the wxPython toolkit, which we can use with Python 3. We found the Phoenix project for this GUI toolkit, which is the current and active development line. Phoenix will replace the Classic wxPython toolkit in time and is especially aimed at working well with Python 3.</p><p>After successfully installing the wxPython/Phoenix toolkit, we then created a GUI using this toolkit in only five lines of code.</p><div><div><h3 class="title"><a id="note125"/>Note</h3><p>We previously achieved the same results by using tkinter.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>How to create our GUI in wxPython</h1></div></div></div><p>In<a id="id407" class="indexterm"/> this recipe, we will start to create our Python GUIs using <a id="id408" class="indexterm"/>the wxPython GUI toolkit.</p><p>We will first recreate several of the widgets we previously created using tkinter, which ships with Python.</p><p>Then, we will explore some of the widgets the wxPython GUI toolkit offers, which are harder to create using tkinter.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec218"/>Getting ready</h2></div></div></div><p>The previous recipe showed you how to install the correct version of wxPython that matches both your version of Python and the OS you are running.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec219"/>How to do it...</h2></div></div></div><p>A good <a id="id409" class="indexterm"/>place to start exploring the wxPython GUI toolkit is by going to the following URL: <a class="ulink" href="http://wxpython.org/Phoenix/docs/html/gallery.html">http://wxpython.org/Phoenix/docs/html/gallery.html</a>
</p><p>This webpage displays many wxPython widgets. By clicking on any of them, we are taken to their documentation, which is a very nice and helpful feature to quickly learn about a wxPython control.</p><div><img src="img/B04829_09_08.jpg" alt="How to do it..."/></div><p>The <a id="id410" class="indexterm"/>following screenshot shows the documentation for a <a id="id411" class="indexterm"/>wxPython button widget.</p><div><img src="img/B04829_09_09.jpg" alt="How to do it..."/></div><p>We can very quickly create a working window that comes with a title, a menu bar, and also a status bar. This status bar displays the text of a menu item when hovering the mouse over it. This can be achieved by writing the following code:</p><div><pre class="programlisting"># Import wxPython GUI toolkit
import wx

# Subclass wxPython frame
class GUI(wx.Frame):
    def __init__(self, parent, title, size=(200,100)):
        # Initialize super class
        wx.Frame.__init__(self, parent, title=title, size=size)
        
        # Change the frame background color 
        self.SetBackgroundColour('white')
        
        # Create Status Bar
        self.CreateStatusBar() 

        # Create the Menu
        menu= wx.Menu()

        # Add Menu Items to the Menu
        menu.Append(wx.ID_ABOUT, "About", "wxPython GUI")
        menu.AppendSeparator()
        menu.Append(wx.ID_EXIT,"Exit"," Exit the GUI")

        # Create the MenuBar
        menuBar = wx.MenuBar()

        # Give the MenuBar a Title
        menuBar.Append(menu,"File") 
        
        # Connect the MenuBar to the frame
        self.SetMenuBar(menuBar)  
        
        # Display the frame
        self.Show()

# Create instance of wxPython application
app = wx.App()

# Call sub-classed wxPython GUI increasing default Window size
GUI(None, "Python GUI using wxPython", (300,150))

# Run the main GUI event loop
app.MainLoop()</pre></div><p>This<a id="id412" class="indexterm"/> creates the following GUI, which is written in Python <a id="id413" class="indexterm"/>using the wxPython library.</p><div><img src="img/B04829_09_10.jpg" alt="How to do it..."/></div><p>In the <a id="id414" class="indexterm"/>previous code, we inherited from <code class="literal">wx.Frame</code>. In the<a id="id415" class="indexterm"/> following code, we inherit from <code class="literal">wx.Panel</code> and we pass in <code class="literal">wx.Frame</code> to the <code class="literal">__init__()</code> method of our class.</p><div><div><h3 class="title"><a id="note126"/>Note</h3><p>In wxPython, the top-level GUI window is called a frame. There cannot be a wxPython GUI without a frame and the frame has to be created as part of a wxPython application.</p><p>We create both the application and the frame at the bottom of our code.</p></div></div><p>In order to add widgets to our GUI, we have to attach them to a panel. The parent of the panel is the frame (our top-level window) and the parent of the widgets we place into the panel is the panel.</p><p>The following code adds a multiline textbox widget to a panel whose parent is a frame. We also add a button widget to the panel widget, which, when clicked, prints out some text to the textbox.</p><p>Here is the complete code:</p><div><pre class="programlisting">import wx               # Import wxPython GUI toolkit
class GUI(wx.Panel):    # Subclass wxPython Panel
    def __init__(self, parent):

        # Initialize super class
        wx.Panel.__init__(self, parent)

        # Create Status Bar
        parent.CreateStatusBar() 
        
        # Create the Menu
        menu= wx.Menu()

        # Add Menu Items to the Menu
        menu.Append(wx.ID_ABOUT, "About", "wxPython GUI")
        menu.AppendSeparator()
        menu.Append(wx.ID_EXIT,"Exit"," Exit the GUI")

        # Create the MenuBar
        menuBar = wx.MenuBar()
        
        # Give the Menu a Title
        menuBar.Append(menu,"File") 
        
        # Connect the MenuBar to the frame
        parent.SetMenuBar(menuBar)  
        
        # Create a Print Button
        button = wx.Button(self, label="Print", pos=(0,60))

        # Connect Button to Click Event method 
        self.Bind(wx.EVT_BUTTON, self.printButton, button)

        # Create a Text Control widget 
        self.textBox = wx.TextCtrl(
self, size=(280,50), style=wx.TE_MULTILINE)
        
    def printButton(self, event):
        self.textBox.AppendText(
"The Print Button has been clicked!") 
                       

app = wx.App()      # Create instance of wxPython application
frame = wx.Frame(None, title="Python GUI using wxPython", size=(300,180))     # Create frame
GUI(frame)          # Pass frame into GUI
frame.Show()        # Display the frame
app.MainLoop()      # Run the main GUI event loop</pre></div><p>Running<a id="id416" class="indexterm"/> the preceding code and clicking our wxPython button<a id="id417" class="indexterm"/> widget results in the following GUI output:</p><div><img src="img/B04829_09_11.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec220"/>How it works...</h2></div></div></div><p>We<a id="id418" class="indexterm"/> have created our own GUI in this recipe using the mature <a id="id419" class="indexterm"/>wxPython GUI toolkit. In only a few lines of Python code, we were able to create a fully functional GUI that comes with <code class="literal">Minimize</code>, <code class="literal">Maximize</code>, and <code class="literal">Exit</code> buttons. We added a menu bar, a multi-line text-control, and a button. We also created a status bar that displays text when we select a menu item. We placed all these widgets into a Panel container widget.</p><p>We hooked up the button to print to the text control.</p><p>When hovering over a menu item, some text gets displayed in the status bar.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec85"/>Quickly adding controls using wxPython</h1></div></div></div><p>In this<a id="id420" class="indexterm"/> recipe, we will recreate the GUI we originally<a id="id421" class="indexterm"/> created earlier in this book with tkinter , but this time, we will be using the wxPython library. We will see how easy and quick it is to use the wxPython GUI toolkit to create our own Python GUIs.</p><p>We will not recreate the entire functionality we created in previous chapters. For example, we will not internationalize our wxPython GUI nor connect it to a MySQL database. We will recreate the visual aspects of the GUI and add some functionality.</p><div><div><h3 class="title"><a id="note127"/>Note</h3><p>Comparing different libraries gives us the choice of which toolkits to use for our own Python GUI development and we can combine several of those toolkits in our own Python code.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec221"/>Getting ready</h2></div></div></div><p>Ensure you have the wxPython module installed to follow this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec222"/>How to do it...</h2></div></div></div><p>First, we <a id="id422" class="indexterm"/>create our Python <code class="literal">OOP</code> class as we did before <a id="id423" class="indexterm"/>using tkinter, but this time we inherit from and extend the <code class="literal">wx.Frame</code> class. For clarity reasons, we no longer call our class <code class="literal">OOP</code> but instead rename it as <code class="literal">MainFrame</code>.</p><div><div><h3 class="title"><a id="note128"/>Note</h3><p>In wxPython, the main GUI window is called a Frame.</p></div></div><p>We also create a callback method that closes the GUI when we click the <code class="literal">Exit</code> Menu Item and declare a light-gray <code class="literal">tuple</code> as the background color for our GUI.</p><div><pre class="programlisting">import wx
BACKGROUNDCOLOR = (240, 240, 240, 255)

class MainFrame(wx.Frame):
    def __init__(self, *args, **kwargs):
        wx.Frame.__init__(self, *args, **kwargs)
        
        self.createWidgets()
        self.Show()

    def exitGUI(self, event):     # callback
        self.Destroy()

    def createWidgets(self):   
        self.CreateStatusBar()      # wxPython built-in method
        self.createMenu()
       self.createNotebook()</pre></div><p>Next, we add a tabbed control to our GUI by creating an instance of the wxPython <code class="literal">Notebook</code> class and assign it as the parent to our own custom class named <code class="literal">Widgets</code>.</p><p>The <code class="literal">notebook</code> class instance variable has <code class="literal">wx.Panel</code> as its parent.</p><div><pre class="programlisting">    def createNotebook(self):
        panel = wx.Panel(self)
        notebook = wx.Notebook(panel)
        widgets = Widgets(notebook) # Custom class explained below
        notebook.AddPage(widgets, "Widgets")
        notebook.SetBackgroundColour(BACKGROUNDCOLOR) 
        # layout
        boxSizer = wx.BoxSizer()
        boxSizer.Add(notebook, 1, wx.EXPAND)
        panel.SetSizerAndFit(boxSizer)  </pre></div><div><div><h3 class="title"><a id="note129"/>Note</h3><p>In wxPython, the tabbed widget is named <code class="literal">Notebook</code>, just as in tkinter.</p></div></div><p>Every <code class="literal">Notebook</code> widget <a id="id424" class="indexterm"/>needs to have a parent<a id="id425" class="indexterm"/> and, in order to lay out widgets in the <code class="literal">Notebook</code> in wxPython, we use different kinds of sizers.</p><div><div><h3 class="title"><a id="note130"/>Note</h3><p>wxPython sizers are layout managers similar to tkinter's grid layout manager.</p></div></div><p>Next, we add controls to our Notebook page. We do this by creating a separate class that inherits from <code class="literal">wx.Panel</code>.</p><div><pre class="programlisting">class Widgets(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent)
        self.createWidgetsFrame()
        self.addWidgets()
        self.layoutWidgets()</pre></div><p>We modularize our GUI code by breaking it into small methods, following Python OOP programming best practices, which keeps our code manageable and understandable.</p><div><pre class="programlisting">    #------------------------------------------------------
    def createWidgetsFrame(self):
        self.panel = wx.Panel(self)
        staticBox = wx.StaticBox( self.panel, -1, "Widgets Frame" )    
        self.statBoxSizerV = wx.StaticBoxSizer(staticBox, 
                                               wx.VERTICAL)
    #-----------------------------------------------------
    def layoutWidgets(self):         
        boxSizerV = wx.BoxSizer( wx.VERTICAL )
        boxSizerV.Add( self.statBoxSizerV, 1, wx.ALL )
        self.panel.SetSizer( boxSizerV )
        boxSizerV.SetSizeHints( self.panel )
                        
    #------------------------------------------------------
    def addWidgets(self):
        self.addCheckBoxes()        
        self.addRadioButtons()
        self.addStaticBoxWithLabels()</pre></div><div><div><h3 class="title"><a id="note131"/>Note</h3><p>When using wxPython StaticBox widgets, in order to successfully lay them out, we use a combination of a <code class="literal">StaticBoxSizer</code> and a regular <code class="literal">BoxSizer</code>. The wxPython StaticBox is very similar to the tkinter LabelFrame widget.</p></div></div><p>Embedding a <code class="literal">StaticBox</code> within another <code class="literal">StaticBox</code> is straightforward in tkinter, but using<a id="id426" class="indexterm"/> wxPython is a little non-intuitive. One way to<a id="id427" class="indexterm"/> make it work is shown as follows:</p><div><pre class="programlisting">    def addStaticBoxWithLabels(self):
        boxSizerH = wx.BoxSizer(wx.HORIZONTAL)
        staticBox = wx.StaticBox( self.panel, -1, 
"Labels within a Frame" )
        staticBoxSizerV = wx.StaticBoxSizer( staticBox, wx.VERTICAL )
        boxSizerV = wx.BoxSizer( wx.VERTICAL )
        staticText1 = wx.StaticText( self.panel, -1,
"Choose a number:" )
        boxSizerV.Add( staticText1, 0, wx.ALL)
        staticText2 = wx.StaticText( self.panel, -1,"Label 2")
        boxSizerV.Add( staticText2, 0, wx.ALL )
        #------------------------------------------------------
        staticBoxSizerV.Add( boxSizerV, 0, wx.ALL )
        boxSizerH.Add(staticBoxSizerV)
        #------------------------------------------------------
        boxSizerH.Add(wx.TextCtrl(self.panel))
        # Add local boxSizer to main frame
        self.statBoxSizerV.Add( boxSizerH, 1, wx.ALL )</pre></div><p>First, we create a horizontal <code class="literal">BoxSizer</code>. Next, we create a vertical <code class="literal">StaticBoxSizer</code> because we want to arrange two labels in a vertical layout in this frame.</p><p>In order to arrange another widget to the right of the embedded <code class="literal">StaticBox</code>, we have to assign both the embedded <code class="literal">StaticBox</code> with its children controls and the next widget to the horizontal <code class="literal">BoxSizer</code> and then assign this <code class="literal">BoxSizer</code>, which now contains both our embedded <code class="literal">StaticBox</code> and our other widgets, to the main <code class="literal">StaticBox</code>.</p><p>Does this sound confusing?</p><p>You have to just experiment with these sizers to get a feel for how to use them. Start with the code for this recipe and comment out some code, or modify some x and y coordinates to see the effects.</p><p>It is also good to read the official wxPython documentation to learn more.</p><div><div><h3 class="title"><a id="note132"/>Note</h3><p>The important thing is knowing where in the code to add to the different sizers in order to achieve the layout we wish.</p></div></div><p>In<a id="id428" class="indexterm"/> order to create the second <code class="literal">StaticBox</code> below the<a id="id429" class="indexterm"/> first, we create separate <code class="literal">StaticBoxSizers</code> and assign them to the same panel.</p><div><pre class="programlisting">class Widgets(wx.Panel):
    def __init__(self, parent):
        wx.Panel.__init__(self, parent)
        self.panel = wx.Panel(self)
        self.createWidgetsFrame()
        self.createManageFilesFrame()
        self.addWidgets()
        self.addFileWidgets()
        self.layoutWidgets()
        
    #----------------------------------------------------------
    def createWidgetsFrame(self):
        staticBox = wx.StaticBox( 
self.panel, -1, "Widgets Frame", size=(285, -1) )   
        self.statBoxSizerV = wx.StaticBoxSizer(
staticBox, wx.VERTICAL)   
    
    #----------------------------------------------------------
    def createManageFilesFrame(self):
        staticBox = wx.StaticBox( 
self.panel, -1, "Manage Files", size=(285, -1) )   
        self.statBoxSizerMgrV = wx.StaticBoxSizer(
staticBox, wx.VERTICAL)

    #----------------------------------------------------------
    def layoutWidgets(self):         
        boxSizerV = wx.BoxSizer( wx.VERTICAL )
        boxSizerV.Add( self.statBoxSizerV, 1, wx.ALL )
        boxSizerV.Add( self.statBoxSizerMgrV, 1, wx.ALL )
        
        self.panel.SetSizer( boxSizerV )
        boxSizerV.SetSizeHints( self.panel )

    #----------------------------------------------------------
    def addFileWidgets(self):   
        boxSizerH = wx.BoxSizer(wx.HORIZONTAL)
        boxSizerH.Add(wx.Button(
self.panel, label='Browse to File...'))   
        boxSizerH.Add(wx.TextCtrl(
self.panel, size=(174, -1), value= "Z:\\" ))
        
        boxSizerH1 = wx.BoxSizer(wx.HORIZONTAL)
        boxSizerH1.Add(wx.Button(
self.panel, label='Copy File To:    ')) 
        boxSizerH1.Add(wx.TextCtrl(
self.panel, size=(174, -1), value= "Z:\\Backup" ))    
        
        boxSizerV = wx.BoxSizer(wx.VERTICAL)
        boxSizerV.Add(boxSizerH)
        boxSizerV.Add(boxSizerH1)        
        
        self.statBoxSizerMgrV.Add( boxSizerV, 1, wx.ALL )</pre></div><p>The <a id="id430" class="indexterm"/>following code instantiates the main event<a id="id431" class="indexterm"/> loop which runs our wxPython GUI program.</p><div><pre class="programlisting">#======================
# Start GUI
#======================
app = wx.App()
MainFrame(None, title="Python GUI using wxPython", size=(350,450))
app.MainLoop()</pre></div><p>The final result of our wxPython GUI looks like this:</p><div><img src="img/B04829_09_12.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec223"/>How it works...</h2></div></div></div><p>We <a id="id432" class="indexterm"/>design and lay out our wxPython GUI in several classes.</p><p>Once <a id="id433" class="indexterm"/>we have done this in the bottom section of our Python module, we create an instance of the wxPython application. Next, we instantiate our wxPython GUI code.</p><p>After that, we call the main GUI event loop that executes all of our Python code running within this application process. This displays our wxPython GUI.</p><div><div><h3 class="title"><a id="note133"/>Note</h3><p>Whatever code we place between the creation of the app and calling its main event loop becomes our wxPython GUI.</p><p>It might take some time to really get used to the wxPython library and its API, but once we understand how to use it, this library is really fun and a powerful <a id="id434" class="indexterm"/>tool to build our own<a id="id435" class="indexterm"/> Python GUIs. There also is a visual <a id="id436" class="indexterm"/>designer tool that can be used with wxPython: <a class="ulink" href="http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view">http://www.cae.tntech.edu/help/programming/wxdesigner-getting-started/view</a>
</p></div></div><p>This recipe used OOP to learn how to use the wxPython GUI toolkit.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec86"/>Trying to embed a main wxPython app in a main tkinter app</h1></div></div></div><p>Now that <a id="id437" class="indexterm"/>we have created the same GUI <a id="id438" class="indexterm"/>using both the Python's built-in tkinter library as well as the wxPython wrapper of the wxWidgets library, we really do need to combine the GUIs we created using these technologies.</p><div><div><h3 class="title"><a id="note134"/>Note</h3><p>Both the wxPython and the tkinter libraries have their own advantages. In online <a id="id439" class="indexterm"/>forums such as <a class="ulink" href="http://stackoverflow.com/">http://stackoverflow.com/</a>, we often see questions such as, which one is better? Which GUI toolkit should I use? This suggests that we have to make an "either-or" decision. We do not have to make such a decision.</p></div></div><p>One of the main challenges in doing so is that each GUI toolkit has to have its own event loop.</p><p>In this recipe, we will try to embed a simple wxPython GUI by calling it from our tkinter GUI.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec224"/>Getting ready</h2></div></div></div><p>We will reuse the tkinter GUI we built in a previous recipe in <a class="link" href="ch01.html" title="Chapter 1. Creating the GUI Form and Adding Widgets">Chapter 1</a>, <em>Creating the GUI Form and Adding Widgets</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec225"/>How to do it...</h2></div></div></div><p>We are starting from a simple tkinter GUI that looks like this:</p><div><img src="img/B04829_09_13.jpg" alt="How to do it..."/></div><p>Next, we <a id="id440" class="indexterm"/>will try to invoke a simple wxPython<a id="id441" class="indexterm"/> GUI, which we created in a previous recipe in this chapter.</p><p>This is the entire code to do this in a simple, non-OOP way:</p><div><pre class="programlisting">#===========================================================
import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext

win = tk.Tk()    
     
win.title("Python GUI")
aLabel = ttk.Label(win, text="A Label")
aLabel.grid(column=0, row=0)    
ttk.Label(win, text="Enter a name:").grid(column=0, row=0)
name = tk.StringVar()
nameEntered = ttk.Entry(win, width=12, textvariable=name)
nameEntered.grid(column=0, row=1)
ttk.Label(win, text="Choose a number:").grid(column=1, row=0)
number = tk.StringVar()
numberChosen = ttk.Combobox(win, width=12, textvariable=number)
numberChosen['values'] = (1, 2, 4, 42, 100)
numberChosen.grid(column=1, row=1)
numberChosen.current(0)
scrolW  = 30
scrolH  =  3
scr = scrolledtext.ScrolledText(win, width=scrolW, height=scrolH, wrap=tk.WORD)
scr.grid(column=0, sticky='WE', columnspan=3)
nameEntered.focus()  

#===========================================================
def wxPythonApp():
    import wx
    app = wx.App()
    frame = wx.Frame(None, -1, "wxPython GUI", size=(200,150))
    frame.SetBackgroundColour('white')
    frame.CreateStatusBar()
    menu= wx.Menu()
    menu.Append(wx.ID_ABOUT, "About", "wxPython GUI")
    menuBar = wx.MenuBar()
    menuBar.Append(menu,"File") 
    frame.SetMenuBar(menuBar)     
    frame.Show()
    app.MainLoop()
    
action = ttk.Button(win, text="Call wxPython GUI", command= wxPythonApp ) 
action.grid(column=2, row=1)
    
#======================
# Start GUI
#======================
win.mainloop()</pre></div><p>Running <a id="id442" class="indexterm"/>the preceding code starts a wxPython GUI <a id="id443" class="indexterm"/>from our tkinter GUI after clicking the tkinter <code class="literal">Button</code> control.</p><p> </p><div><img src="img/B04829_09_14.jpg" alt="How to do it..."/></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec226"/>How it works...</h2></div></div></div><p>The important part is that we placed the entire wxPython code into its own function, which we named <code class="literal">def wxPythonApp()</code>.</p><p>In the callback function for the button click-event, we simply call this code.</p><div><div><h3 class="title"><a id="note135"/>Note</h3><p>One<a id="id444" class="indexterm"/> thing to note is that <a id="id445" class="indexterm"/>we have to close the wxPython GUI before we can continue using the tkinter GUI.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec87"/>Trying to embed our tkinter GUI code into wxPython</h1></div></div></div><p>In <a id="id446" class="indexterm"/>this recipe, we will go in the opposite direction to the previous recipe and try to call our tkinter GUI code from within a wxPython GUI.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec227"/>Getting ready</h2></div></div></div><p>We will reuse some of the wxPython GUI code we created in a previous recipe in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec228"/>How to do it...</h2></div></div></div><p>We will start from a simple wxPython GUI, which looks like this:</p><div><img src="img/B04829_09_15.jpg" alt="How to do it..."/></div><p>Next, we will try to invoke a simple tkinter GUI.</p><p>This is<a id="id447" class="indexterm"/> the entire code to do this in a simple, non-OOP way:</p><div><pre class="programlisting">#=============================================================
def tkinterApp():
    import tkinter as tk
    from tkinter import ttk
    win = tk.Tk()    
    win.title("Python GUI")
    aLabel = ttk.Label(win, text="A Label")
    aLabel.grid(column=0, row=0)    
    ttk.Label(win, text="Enter a name:").grid(column=0, row=0)
    name = tk.StringVar()
    nameEntered = ttk.Entry(win, width=12, textvariable=name)
    nameEntered.grid(column=0, row=1)
    nameEntered.focus()  
    def buttonCallback():
        action.configure(text='Hello ' + name.get())
    action = ttk.Button(win, text="Print", command=buttonCallback)
    action.grid(column=2, row=1)
    win.mainloop()

#=============================================================
import wx
app = wx.App()
frame = wx.Frame(None, -1, "wxPython GUI", size=(200,180))
frame.SetBackgroundColour('white')
frame.CreateStatusBar()
menu= wx.Menu()
menu.Append(wx.ID_ABOUT, "About", "wxPython GUI")
menuBar = wx.MenuBar()
menuBar.Append(menu,"File") 
frame.SetMenuBar(menuBar) 
textBox = wx.TextCtrl(frame, size=(180,50), style=wx.TE_MULTILINE)

def tkinterEmbed(event):
    tkinterApp()

button = wx.Button(frame, label="Call tkinter GUI", pos=(0,60)) 
frame.Bind(wx.EVT_BUTTON, tkinterEmbed, button)
frame.Show()

#======================
# Start wxPython GUI
#======================
app.MainLoop()</pre></div><p>Running the preceding code starts a tkinter GUI from our wxPython GUI after clicking the wxPython <code class="literal">Button</code> widget. We can then enter text into the tkinter textbox. By clicking its button, the <a id="id448" class="indexterm"/>button text gets updated with the name.</p><div><img src="img/B04829_09_16.jpg" alt="How to do it..."/></div><p>After starting the tkinter event loop, the wxPython GUI is still responsive because we can type into the <code class="literal">TextCtrl</code> widget while the tkinter GUI is up and running.</p><div><div><h3 class="title"><a id="note136"/>Note</h3><p>In the previous recipe, we could not use our tkinter GUI until we had closed the wxPython GUI. Being aware of this difference can help our design decisions if we want to combine the two Python GUI technologies.</p></div></div><p>We can also create several tkinter GUI instances by clicking the wxPython GUI button several times. We cannot, however, close the wxPython GUI while any tkinter GUIs are still running. We have to close them first.</p><div><img src="img/B04829_09_17.jpg" alt="How to do it..."/></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec229"/>How it works...</h2></div></div></div><p>In this<a id="id449" class="indexterm"/> recipe we went in the opposite direction to the previous recipe by first creating a GUI using wxPython and then, from wit-hin it, creating several GUI instances built using tkinter.</p><p>The wxPython GUI remained responsive while one or more tkinter GUIs were running. However, clicking the tkinter button only updated its button text in the first instance.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec88"/>How to use Python to control two different GUI frameworks</h1></div></div></div><p>In this <a id="id450" class="indexterm"/>recipe, we will <a id="id451" class="indexterm"/>explore ways to control the tkinter and wxPython GUI frameworks from Python. We have already used the Python threading module to keep our GUI responsive in the previous chapter, so here we will attempt to use the same approach.</p><p>We will see that things don't always work in a way that would be intuitive.</p><p>However, we will improve our tkinter GUI from being unresponsive while we invoke an instance of the wxPython GUI from within it.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec230"/>Getting ready</h2></div></div></div><p>This recipe will extend a previous recipe from this chapter in which we tried to embed a main wxPython GUI into our tkinter GUI.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec231"/>How to do it...</h2></div></div></div><p>When we created an instance of a wxPython GUI from our tkinter GUI, we could no longer use the tkinter GUI controls until we closed the one instance of the wxPython GUI. Let's improve on this now.</p><p>Our first <a id="id452" class="indexterm"/>attempt might be <a id="id453" class="indexterm"/>to use threading from the tkinter button callback function.</p><p>For example, our code might look like this:</p><div><pre class="programlisting">def wxPythonApp():
    import wx
    app = wx.App()
    frame = wx.Frame(None, -1, "wxPython GUI", size=(200,150))
    frame.SetBackgroundColour('white')
    frame.CreateStatusBar()
    menu= wx.Menu()
    menu.Append(wx.ID_ABOUT, "About", "wxPython GUI")
    menuBar = wx.MenuBar()
    menuBar.Append(menu,"File") 
    frame.SetMenuBar(menuBar)     
    frame.Show()
    app.MainLoop()

def tryRunInThread():
    runT = Thread(target=wxPythonApp)
    runT.setDaemon(True)    
    runT.start()
    print(runT)
    print('createThread():', runT.isAlive())    
        
action = ttk.Button(win, text="Call wxPython GUI", command=tryRunInThread)</pre></div><p>At first, this seems to be working, which would be intuitive as the tkinter controls are no longer disabled and we can create several instances of the wxPython GUI by clicking the button. We can also type into and select the other tkinter widgets.</p><div><img src="img/B04829_09_18.jpg" alt="How to do it..."/></div><p>However, once <a id="id454" class="indexterm"/>we try to<a id="id455" class="indexterm"/> close the GUIs, we get an error from wxWidgets, and our Python executable crashes.</p><div><img src="img/B04829_09_19.jpg" alt="How to do it..."/></div><p>In order to avoid this, instead of trying to run the entire wxPython application in a thread, we can <a id="id456" class="indexterm"/>change the code to<a id="id457" class="indexterm"/> make only the wxPython <code class="literal">app.MainLoop</code> run in a thread.</p><div><pre class="programlisting">def wxPythonApp():
    import wx
    app = wx.App()
    frame = wx.Frame(None, -1, "wxPython GUI", size=(200,150))
    frame.SetBackgroundColour('white')
    frame.CreateStatusBar()
    menu= wx.Menu()
    menu.Append(wx.ID_ABOUT, "About", "wxPython GUI")
    menuBar = wx.MenuBar()
    menuBar.Append(menu,"File") 
    frame.SetMenuBar(menuBar)     
    frame.Show()

    runT = Thread(target=app.MainLoop)
    runT.setDaemon(True)    
    runT.start()
    print(runT)
    print('createThread():', runT.isAlive())

action = ttk.Button(win, text="Call wxPython GUI", command=wxPythonApp) 
action.grid(column=2, row=1)</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec232"/>How it works...</h2></div></div></div><p>We first tried to run the entire wxPython GUI application in a thread, but this did not work as the wxPython main event loop expects to be the main thread of the application.</p><p>We found a workaround for this by only running the wxPython <code class="literal">app.MainLoop</code> in a thread, which tricks it into believing it is the main thread.</p><p>One side-effect of this approach is that we can no longer individually close all of the wxPython GUI instances. At least one of them only closes when we close the wxPython GUI which created the threads as daemons.</p><p>I am not quite sure why this is. Intuitively, one might expect to be able to close all daemon threads without having to wait for the main thread that created them to close first.</p><p>It possibly has to do with a reference counter not having been set to zero while our main thread is still running.</p><p>On a pragmatic level, this is how it currently works.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec89"/>How to communicate between the two connected GUIs</h1></div></div></div><p>In the <a id="id458" class="indexterm"/>previous recipes, we found ways to connect a wxPython GUI with a tkinter GUI, invoking one from the other and vice versa.</p><p>While both GUIs were successfully running at the same time, they did not really communicate with each other as they were only launching one another.</p><p>In this recipe, we will explore ways to make the two GUIs talk to each other.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec233"/>Getting ready</h2></div></div></div><p>Reading one of the previous recipes might be a good preparation for this recipe.</p><p>In this recipe, we will use a slightly modified GUI code compared to the previous recipe, but most of the basic GUI-building code is the same.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec234"/>How to do it...</h2></div></div></div><p>In the previous recipes, one of our main challenges was how to combine two GUI technologies that were designed to be the one-and-only GUI toolkit for an application. We found various simple ways to combine them.</p><p>We will again launch the wxPython GUI from a tkinter GUI main event loop and start the wxPython GUI in its own thread that runs within the tkinter process.</p><p>In order to do this, we will use a shared global multiprocessing Python queue.</p><div><div><h3 class="title"><a id="note137"/>Note</h3><p>While it is often best to avoid global data in this recipe, they are a practical solution and Python globals are really only global in the module they have been declared in.</p></div></div><p>Here is the Python code that makes the two GUIs communicate with each other to a certain degree. In order to save space, this is not pure OOP code.</p><p>We are also not showing the creation code for all of the widgets. That code is the same as in previous recipes.</p><div><pre class="programlisting"># Ch09_Communicate.py
import tkinter as tk
from tkinter import ttk
from threading import Thread

win = tk.Tk()       
win.title("Python GUI")   


from multiprocessing import Queue
sharedQueue = Queue()
dataInQueue = False

def putDataIntoQueue(data):
    global dataInQueue
    dataInQueue =  True
    sharedQueue.put(data)
    
def readDataFromQueue():
    global dataInQueue
    dataInQueue = False
    return sharedQueue.get() 
#===========================================================
import wx               
class GUI(wx.Panel):    
    def __init__(self, parent):
        wx.Panel.__init__(self, parent)
        parent.CreateStatusBar() 
        button = wx.Button(self, label="Print", pos=(0,60))
        self.Bind(wx.EVT_BUTTON, self.writeToSharedQueue, button)
   
    #--------------------------------------------------------
    def writeToSharedQueue(self, event):
        self.textBox.AppendText(
                        "The Print Button has been clicked!\n") 
        putDataIntoQueue('Hi from wxPython via Shared Queue.\n')
        if dataInQueue: 
            data = readDataFromQueue()
            self.textBox.AppendText(data)
            
            text.insert('0.0', data) # insert data into GUI

#============================================================
def wxPythonApp():
        app = wx.App()
        frame = wx.Frame(
            None, title="Python GUI using wxPython", size=(300,180))
        GUI(frame)          
        frame.Show()        
        runT = Thread(target=app.MainLoop)
        runT.setDaemon(True)    
        runT.start()
        print(runT)
        print('createThread():', runT.isAlive())
#============================================================
action = ttk.Button(win, text="Call wxPython GUI", command=wxPythonApp) 
action.grid(column=2, row=1)

#======================
# Start GUI
#======================
win.mainloop()</pre></div><p>Running <a id="id459" class="indexterm"/>the preceding code first creates the tkinter part of the program and, when we click the button in this GUI, it runs the wxPython GUI. Both are running at the same time as before, but this time, there is an extra level of communication between the two GUIs.</p><div><img src="img/B04829_09_20.jpg" alt="How to do it..."/></div><p>The tkinter GUI is shown on the left-hand side of the preceding screenshot and, by clicking the <strong>Call wxPython GUI</strong> button, we invoke an instance of the wxPython GUI. We can create several instances by clicking the button several times.</p><div><div><h3 class="title"><a id="note138"/>Note</h3><p>All of the created GUIs remain responsive. They do not crash nor freeze.</p></div></div><p>Clicking<a id="id460" class="indexterm"/> the <strong>Print</strong> button on any of the wxPython GUI instances writes one sentence to its own <code class="literal">TextCtrl</code> widget and then writes another line to itself as well as to the tkinter GUI. You will have to scroll up to see the first sentence in the wxPython GUI.</p><div><div><h3 class="title"><a id="note139"/>Note</h3><p>The way this works is by using a module-level queue and a tkinter <code class="literal">Text</code> widget</p></div></div><p>One important element to note is that we create a thread to run the wxPython <code class="literal">app.MainLoop</code>, as we did in the previous recipe.</p><div><pre class="programlisting">def wxPythonApp():
        app = wx.App()
        frame = wx.Frame(
None, title="Python GUI using wxPython", size=(300,180))
        GUI(frame)          
        frame.Show()        
        runT = Thread(target=app.MainLoop)
        runT.setDaemon(True)    
        runT.start()</pre></div><p>We create a class that inherits from <code class="literal">wx.Panel</code> and name it <code class="literal">GUI</code>. We then instantiate an instance of this class in the preceding code.</p><p>We create a button click-event callback method in this class, which then calls the procedural code that was written above it. Because of this, the class has access to the functions and can write to the shared queue.</p><div><pre class="programlisting">    #------------------------------------------------------
    def writeToSharedQueue(self, event):
        self.textBox.AppendText(
"The Print Button has been clicked!\n") 
        putDataIntoQueue('Hi from wxPython via Shared Queue.\n')
        if dataInQueue: 
            data = readDataFromQueue()
            self.textBox.AppendText(data)
            text.insert('0.0', data) # insert data into tkinter</pre></div><p>We first check if the data has been placed in the shared queue in the preceding method and, if that is the case, we then print the common data to both GUIs.</p><div><div><h3 class="title"><a id="note140"/>Note</h3><p>The <code class="literal">putDataIntoQueue()</code> line places data into the queue and <code class="literal">readDataFromQueue()</code> reads it back out saving it in the <code class="literal">data</code> variable.</p><p>
<code class="literal">text.insert('0.0', data)</code> is the line that writes this data into the tkinter GUI from the <strong>Print</strong> button's wxPython callback method.</p></div></div><p>Following are the procedural functions (not methods, for they are not bound) that are being called in the code and that make it work.</p><div><pre class="programlisting">from multiprocessing import Queue
sharedQueue = Queue()
dataInQueue = False

def putDataIntoQueue(data):
    global dataInQueue
    dataInQueue =  True
    sharedQueue.put(data)
    
def readDataFromQueue():
    global dataInQueue
    dataInQueue = False
    return sharedQueue.get()</pre></div><p>We are using a simple Boolean flag named <code class="literal">dataInQueue</code> to communicate when the data is available in the queue.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec235"/>How it works...</h2></div></div></div><p>In this recipe, we have successfully combined the two GUIs we created in a similar fashion, but previously standalone and not talking to each other. However, in this recipe, we connected them further by making one GUI launch another and, via a simple multiprocessing Python queue mechanism, we were able to make them communicate with each other, writing data from a shared queue into both GUIs.</p><p>There are many very advanced and complicated technologies available to connect different processes, threads, pools, locks, pipes, TCP/IP connections, and so on.</p><p>In the Pythonic spirit, we found a simple solution that works for us. Once our code becomes more complicated, we might have to refactor it, but this is a good beginning.</p></div></div></div>
</body></html>