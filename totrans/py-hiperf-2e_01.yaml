- en: Benchmarking and Profiling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试和分析
- en: Recognizing the slow parts of your program is the single most important task
    when it comes to speeding up your code. Luckily, in most cases, the code that
    causes the application to slow down is a very small fraction of the program. By
    locating those critical sections, you can focus on the parts that need improvement
    without wasting time in micro-optimization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 识别程序中的慢速部分是加快代码速度时最重要的任务。幸运的是，在大多数情况下，导致应用程序变慢的代码只是程序的一小部分。通过定位这些关键部分，你可以专注于需要改进的部分，而无需在微优化上浪费时间。
- en: '**Profiling** is the technique that allows us to pinpoint the most resource-intensive
    spots in an application. A **profiler** is a program that runs an application
    and monitors how long each function takes to execute, thus detecting the functions
    in which your application spends most of its time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**是允许我们定位应用程序中最资源密集的部分的技术。**分析器**是一个运行应用程序并监控每个函数执行时间的程序，从而检测应用程序花费最多时间的函数。'
- en: Python provides several tools to help us find these bottlenecks and measure
    important performance metrics. In this chapter, we will learn how to use the standard
    `cProfile` module and the `line_profiler` third-party package.  We will also learn
    how to profile an application's memory consumption through the  `memory_profiler`
    tool. Another useful tool that we will cover is *KCachegrind*, which can be used to
    graphically display the data produced by various profilers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了几个工具来帮助我们找到这些瓶颈并测量重要的性能指标。在本章中，我们将学习如何使用标准的 `cProfile` 模块和第三方包 `line_profiler`。我们还将学习如何通过
    `memory_profiler` 工具分析应用程序的内存消耗。我们还将介绍另一个有用的工具 *KCachegrind*，它可以用来图形化显示各种分析器产生的数据。
- en: '**Benchmarks** are small scripts used to assess the total execution time of
    your application. We will learn how to write benchmarks and how to accurately
    time your programs.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**基准测试**是用于评估应用程序总执行时间的脚本。我们将学习如何编写基准测试以及如何准确测量程序的时间。'
- en: 'The list of topics we will cover in this chapter is as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题列表如下：
- en: General principles of high performance programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能编程的一般原则
- en: Writing tests and benchmarks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试和基准测试
- en: The Unix `time` command
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix 的 `time` 命令
- en: The Python `timeit` module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 的 `timeit` 模块
- en: Testing and benchmarking with `pytest`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pytest` 进行测试和基准测试
- en: Profiling your application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析你的应用程序
- en: The `cProfile` standard tool
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cProfile` 标准工具'
- en: Interpreting profiling results with KCachegrind
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 KCachegrind 解释分析结果
- en: '`line_profiler` and  `memory_profiler` tools'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`line_profiler` 和 `memory_profiler` 工具'
- en: Disassembling Python code through the `dis` module
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 `dis` 模块反汇编 Python 代码
- en: Designing your application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计你的应用程序
- en: 'When designing a performance-intensive program, the very first step is to write
    your code without bothering with small optimizations:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计一个性能密集型程序时，第一步是编写你的代码，不要担心小的优化：
- en: '"Premature optimization is the root of all evil."'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “过早优化是万恶之源。”
- en: - **Donald Knuth**
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: - **唐纳德·克努特**
- en: In the early development stages, the design of the program can change quickly
    and may require large rewrites and reorganizations of the code base. By testing
    different prototypes without the burden of optimization, you are free to devote
    your time and energy to ensure that the program produces correct results and that
    the design is flexible. After all, who needs an application that runs fast but
    gives the wrong answer?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期开发阶段，程序的设计可能会迅速变化，可能需要大量重写和组织代码库。通过在无需优化的负担下测试不同的原型，你可以自由地投入时间和精力来确保程序产生正确的结果，并且设计是灵活的。毕竟，谁需要运行速度快但给出错误答案的应用程序？
- en: 'The mantras that you should remember when optimizing your code are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当优化代码时你应该记住的咒语如下：
- en: '**Make it run**: We have to get the software in a working state, and ensure
    that it produces the correct results. This exploratory phase serves to better understand
    the application and to spot major design issues in the early stages.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**让它运行**：我们必须让软件处于工作状态，并确保它产生正确的结果。这个探索阶段有助于更好地理解应用程序并在早期阶段发现主要的设计问题。'
- en: '**Make it right**: We want to ensure that the design of the program is solid.
    Refactoring should be done before attempting any performance optimization. This
    really helps separate the application into independent and cohesive units that
    are easier to maintain.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正确地做**：我们希望确保程序的设计是稳固的。在尝试任何性能优化之前应该进行重构。这实际上有助于将应用程序分解成独立且易于维护的单元。'
- en: '**Make it fast**: Once our program is working and is well structured, we can
    focus on performance optimization. We may also want to optimize memory usage if
    that constitutes an issue.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使其快速**：一旦我们的程序运行良好且结构合理，我们就可以专注于性能优化。如果内存使用成为问题，我们可能还想优化内存使用。'
- en: In this section, we will write and profile a *particle simulator* test application.
    The **simulator** is a program that takes some particles and simulates their movement
    over time according to a set of laws that we impose. These particles can be abstract
    entities or correspond to physical objects, for example, billiard balls moving
    on a table, molecules in gas, stars moving through space, smoke particles, fluids
    in a chamber, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写并分析一个 *粒子模拟器* 测试应用程序。**模拟器**是一个程序，它接受一些粒子，并根据我们施加的一组定律模拟它们随时间的变化。这些粒子可以是抽象实体，也可以对应于物理对象，例如在桌面上移动的台球、气体中的分子、在空间中移动的恒星、烟雾粒子、室内的流体等等。
- en: Computer simulations are useful in fields such as Physics, Chemistry, Astronomy,
    and many other disciplines. The applications used to simulate systems are particularly
    performance-intensive and scientists and engineers spend an inordinate amount
    of time optimizing these codes. In order to study realistic systems, it is often
    necessary to simulate a very high number of bodies and every small increase in
    performance counts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机模拟在物理学、化学、天文学和其他许多学科领域都很有用。用于模拟系统的应用程序特别注重性能，科学家和工程师花费大量时间优化这些代码。为了研究现实系统，通常需要模拟大量的物体，并且任何小的性能提升都至关重要。
- en: In our first example, we will simulate a system containing particles that constantly
    rotate around a central point at various speeds, just like the hands of a clock.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将模拟一个包含粒子围绕中心点以不同速度不断旋转的系统，就像时钟的指针一样。
- en: 'The necessary information to run our simulation will be the starting positions
    of the particles, the speed, and the rotation direction. From these elements,
    we have to calculate the position of the particle in the next instant of time.
    An example system is shown in the following figure. The origin of the system is
    the `(0, 0)` point, the position is indicated by the **x**, **y** vector and the
    velocity is indicated by the **vx**, **vy** vector:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的模拟所需的信息将是粒子的起始位置、速度和旋转方向。从这些元素中，我们必须计算出粒子在下一时刻的位置。以下图示了一个示例系统。系统的原点是 `(0,
    0)` 点，位置由 **x**、**y** 向量表示，速度由 **vx**、**vy** 向量表示：
- en: '![](img/B06440_01_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06440_01_01.png)'
- en: 'The basic feature of a circular motion is that the particles always move perpendicular
    to the direction connecting the particle and the center. To move the particle,
    we simply change the position by taking a series of very small steps (which correspond
    to advancing the system for a small interval of time) in the direction of motion,
    as shown in the following figure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 圆周运动的基本特征是粒子始终沿着连接粒子和中心的连线垂直移动。要移动粒子，我们只需沿着运动方向采取一系列非常小的步骤（这相当于在很短的时间间隔内推进系统）来改变位置，如下图所示：
- en: '![](img/B06440_01_02.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06440_01_02.png)'
- en: 'We will start by designing the application in an object-oriented way. According
    to our requirements, it is natural to have a generic `Particle` class that stores
    the particle positions, `x` and `y`, and their angular velocity, `ang_vel`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先以面向对象的方式设计应用程序。根据我们的要求，自然有一个通用的 `Particle` 类来存储粒子的位置 `x` 和 `y` 以及它们的角速度
    `ang_vel`：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that we accept positive and negative numbers for all the parameters (the
    sign of `ang_vel` will simply determine the direction of rotation).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们接受所有参数的正负数（`ang_vel` 的符号将简单地确定旋转方向）。
- en: Another class, called `ParticleSimulator`, will encapsulate the laws of motion
    and will be responsible for changing the positions of the particles over time.
    The `__init__` method will store a list of `Particle` instances and the `evolve`
    method will change the particle positions according to our laws.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类，称为 `ParticleSimulator`，将封装运动定律，并负责随时间改变粒子的位置。`__init__` 方法将存储 `Particle`
    实例的列表，而 `evolve` 方法将根据我们的定律改变粒子位置。
- en: 'We want the particles to rotate around the position corresponding to the `x=0`
    and `y=0` coordinates, at a constant speed. The direction of the particles will
    always be perpendicular to the direction from the center (refer to the first figure
    of this chapter). To find the direction of the movement along the *x* and *y*
    axes (corresponding to the Python `v_x` and `v_y` variables), it is sufficient
    to use these formulae:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望粒子围绕对应于 *x=0* 和 *y=0* 坐标的点以恒定速度旋转。粒子的方向始终垂直于从中心的方向（参考本章第一图）。为了找到沿 *x* 和
    *y* 轴的运动方向（对应于 Python 的 `v_x` 和 `v_y` 变量），可以使用以下公式：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we let one of our particles move, after a certain time *t*, it will reach
    another position following a circular path. We can approximate a circular trajectory
    by dividing the time interval, *t*, into tiny time steps, *dt*, where the particle
    moves in a straight line tangentially to the circle. The final result is just
    an approximation of a circular motion. In order to avoid a strong divergence,
    such as the one illustrated in the following figure, it is necessary to take very
    small time steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让我们的一个粒子运动，经过一定的时间 *t*，它将沿着圆形路径到达另一个位置。我们可以通过将时间间隔，*t*，划分为微小的时步，*dt*，来近似圆形轨迹，其中粒子沿着圆的切线方向直线运动。最终结果只是圆形运动的近似。为了避免强烈的发散，例如以下图中所示，必须采取非常小的时间步长：
- en: '![](img/B06440_01_03.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06440_01_03.png)'
- en: 'In a more schematic way, we have to carry out the following steps to calculate
    the particle position at time *t*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以更简化的方式，我们必须执行以下步骤来计算时间 *t* 时的粒子位置：
- en: Calculate the direction of motion ( `v_x` and `v_y`).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算运动方向（`v_x` 和 `v_y`）。
- en: Calculate the displacement (`d_x` and `d_y`), which is the product of time step,
    angular velocity, and direction of motion.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算位移（`d_x` 和 `d_y`），这是时间步长、角速度和运动方向的乘积。
- en: Repeat steps 1 and 2 for enough times to cover the total time *t*.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 1 和 2，直到覆盖总时间 *t*。
- en: 'The following code shows the full `ParticleSimulator` implementation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了完整的 `ParticleSimulator` 实现：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can use the `matplotlib` library to visualize our particles. This library
    is not included in the Python standard library, and it can be easily installed
    using the `pip install matplotlib` command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `matplotlib` 库来可视化我们的粒子。这个库不包括在 Python 标准库中，并且可以使用 `pip install matplotlib`
    命令轻松安装。
- en: Alternatively, you can use the Anaconda Python distribution ([https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/))
    that includes `matplotlib` and most of the other third-party packages used in
    this book. Anaconda is free and is available for Linux, Windows, and Mac.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用包含 `matplotlib` 和本书中使用的其他大多数第三方包的 Anaconda Python 发行版（[https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/））。Anaconda
    是免费的，并且适用于 Linux、Windows 和 Mac。
- en: To make an interactive visualization, we will use the `matplotlib.pyplot.plot`
    function to display the particles as points and the `matplotlib.animation.FuncAnimation`
    class to animate the evolution of the particles over time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作交互式可视化，我们将使用 `matplotlib.pyplot.plot` 函数显示粒子作为点，并使用 `matplotlib.animation.FuncAnimation`
    类来动画化粒子随时间的变化。
- en: 'The `visualize` function takes a particle `ParticleSimulator` instance as an
    argument and displays the trajectory in an animated plot. The steps necessary
    to display the particle trajectory using the `matplotlib` tools are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`visualize` 函数接受一个 `ParticleSimulator` 实例作为参数，并在动画图中显示轨迹。使用 `matplotlib` 工具显示粒子轨迹的必要步骤如下：'
- en: Set up the axes and use the `plot` function to display the particles. `plot`
    takes a list of *x* and *y* coordinates.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置坐标轴并使用 `plot` 函数显示粒子。`plot` 函数接受一个 *x* 和 *y* 坐标列表。
- en: Write an initialization function, `init`, and a function, `animate`, that updates
    the *x* and *y *coordinates using the `line.set_data` method.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个初始化函数，`init`，和一个函数，`animate`，使用 `line.set_data` 方法更新 *x* 和 *y* 坐标。
- en: Create a `FuncAnimation` instance by passing the `init` and `animate` functions
    plus the `interval` parameters, which specify the update interval, and `blit`,
    which improves the update rate of the image.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传递 `init` 和 `animate` 函数以及 `interval` 参数（指定更新间隔）和 `blit`（提高图像更新率）来创建一个 `FuncAnimation`
    实例。
- en: 'Run the animation with `plt.show()`:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `plt.show()` 运行动画：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To test things out, we define a small function, `test_visualize`, that animates
    a system of three particles rotating in different directions. Note that the third
    particle completes a round three times faster than the others:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们定义了一个小函数`test_visualize`，它使一个由三个粒子组成的系统以不同的方向旋转。请注意，第三个粒子的旋转速度比其他粒子快三倍：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `test_visualize` function is helpful to graphically understand the system
    time evolution. In the following section, we will write more test functions to
    properly verify program correctness and measure performance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_visualize` 函数有助于图形化地理解系统时间演变。在下一节中，我们将编写更多的测试函数，以正确验证程序正确性和测量性能。'
- en: Writing tests and benchmarks
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试和基准测试
- en: Now that we have a working simulator, we can start measuring our performance
    and tune-up our code so that the simulator can handle as many particles as possible.
    As a first step, we will write a test and a benchmark.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可工作的模拟器，我们可以开始测量我们的性能并调整我们的代码，以便模拟器可以处理尽可能多的粒子。作为第一步，我们将编写一个测试和一个基准测试。
- en: We need a test that checks whether the results produced by the simulation are
    correct or not. Optimizing a program commonly requires employing multiple strategies;
    as we rewrite our code multiple times, bugs may easily be introduced. A solid
    test suite ensures that the implementation is correct at every iteration so that
    we are free to go wild and try different things with the confidence that, if the
    test suite passes, the code will still work as expected.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个测试来检查模拟产生的结果是否正确。优化程序通常需要采用多种策略；随着我们多次重写代码，错误可能很容易被引入。一个稳固的测试套件确保在每次迭代中实现都是正确的，这样我们就可以自由地尝试不同的事情，并充满信心地认为，如果测试套件通过，代码仍然会按预期工作。
- en: 'Our test will take three particles, simulate them for 0.1 time units, and compare
    the results with those from a reference implementation. A good way to organize
    your tests is using a separate function for each different aspect (or unit) of
    your application. Since our current functionality is included in the `evolve`
    method, our function will be named `test_evolve`. The following code shows the
    `test_evolve` implementation. Note that, in this case, we compare floating point
    numbers up to a certain precision through the `fequal` function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试将使用三个粒子，模拟0.1时间单位，并将结果与参考实现的结果进行比较。组织测试的一个好方法是为应用程序的每个不同方面（或单元）使用一个单独的函数。由于我们当前的功能包含在`evolve`方法中，我们的函数将命名为`test_evolve`。以下代码显示了`test_evolve`的实现。请注意，在这种情况下，我们通过`fequal`函数比较浮点数，直到一定的精度：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A test ensures the correctness of our functionality but gives little information
    about its running time.  A benchmark is a simple and representative use case that
    can be run to assess the running time of an application. Benchmarks are very useful
    to keep score of how fast our program is with each new version that we implement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 测试确保了我们的功能正确性，但关于其运行时间提供的信息很少。基准测试是一个简单且具有代表性的用例，可以运行以评估应用程序的运行时间。基准测试对于跟踪我们程序每个新版本的运行速度非常有用。
- en: 'We can write a representative benchmark by instantiating a thousand `Particle`
    objects with random coordinates and angular velocity, and feed them to a `ParticleSimulator`
    class. We then let the system evolve for 0.1 time units:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实例化具有随机坐标和角速度的千个`Particle`对象，并将它们提供给`ParticleSimulator`类来编写一个代表性的基准测试。然后，我们让系统演变0.1时间单位：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Timing your benchmark
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量基准测试的时间
- en: 'A very simple way to time a benchmark is through the Unix `time` command. Using
    the `time` command, as follows, you can easily measure the execution time of an
    arbitrary process:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Unix `time` 命令可以非常简单地测量基准测试的时间。使用`time`命令，如下所示，你可以轻松地测量任意进程的执行时间：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `time` command is not available for Windows. To install Unix tools, such
    as `time`, on Windows you can use the `cygwin` shell, downloadable from the official
    website ([http://www.cygwin.com/](http://www.cygwin.com/)). Alternatively, you
    can use similar PowerShell commands, such as `Measure-Command` ([https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command](https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command)),
    to measure execution time.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`命令在Windows上不可用。要在Windows上安装Unix工具，如`time`，您可以使用从官方网站下载的`cygwin` shell（[http://www.cygwin.com/](http://www.cygwin.com/)）。或者，您可以使用类似的PowerShell命令，如`Measure-Command`（[https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command](https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command)），来测量执行时间。'
- en: 'By default, `time` displays three metrics:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`time`显示三个指标：
- en: '`real`: The actual time spent running the process from start to finish, as
    if it was measured by a human with a stopwatch'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`: 从开始到结束运行进程的实际时间，就像用秒表测量的一样'
- en: '`user`: The cumulative time spent by all the CPUs during the computation'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`: 所有CPU在计算过程中花费的累积时间'
- en: '`sys`: The cumulative time spent by all the CPUs during system-related tasks,
    such as memory allocation'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys`: 所有CPU在系统相关任务（如内存分配）上花费的累积时间'
- en: Note that sometimes `user` + `sys` might be greater than `real`, as multiple
    processors may work in parallel.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有时`user` + `sys`可能大于`real`，因为多个处理器可能并行工作。
- en: '`time` also offers richer formatting options. For an overview, you can explore
    its manual (using the `man time` command). If you want a summary of all the metrics
    available, you can use the `-v` option.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`还提供了更丰富的格式化选项。要了解概述，你可以查看其手册（使用`man time`命令）。如果你想要所有可用指标的摘要，可以使用`-v`选项。'
- en: The Unix `time` command is one of the simplest and more direct ways to benchmark
    a program. For an accurate measurement, the benchmark should be designed to have
    a long enough execution time (in the order of seconds) so that the setup and tear-down
    of the process is small compared to the execution time of the application. The
    `user` metric is suitable as a monitor for the CPU performance, while the `real`
    metric also includes the time spent in other processes while waiting for I/O operations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Unix的`time`命令是衡量程序性能最简单和最直接的方法之一。为了进行准确的测量，基准测试应该设计得足够长，执行时间（以秒为单位）足够长，这样与应用程序执行时间相比，进程的设置和拆除时间就很小。`user`指标适合作为CPU性能的监控指标，而`real`指标还包括在等待I/O操作时花费在其他进程上的时间。
- en: Another convenient way to time Python scripts is the `timeit` module. This module
    runs a snippet of code in a loop for *n* times and measures the total execution
    times. Then, it repeats the same operation *r* times (by default, the value of
    *r* is `3`) and records the time of the best run. Due to this timing scheme, `timeit` is
    an appropriate tool to accurately time small statements in isolation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方便计时Python脚本的方法是`timeit`模块。该模块将代码片段在循环中运行*n*次，并测量总执行时间。然后，它重复相同的操作*r*次（默认情况下，*r*的值为`3`）并记录最佳运行时间。由于这种计时方案，`timeit`是准确计时独立小语句的合适工具。
- en: The `timeit` module can be used as a Python package, from the command line or
    from *IPython*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit`模块可以用作Python包，从命令行或从*IPython*使用。'
- en: IPython is a Python shell design that improves the interactivity of the Python
    interpreter. It boosts tab completion and many utilities to time, profile, and
    debug your code. We will use this shell to try out snippets throughout the book.
    The IPython shell accepts **magic commands**--statements that start with a `%`
    symbol--that enhance the shell with special behaviors. Commands that start with
    `%%` are called **cell magics**, which can be applied on multi-line snippets (termed
    as **cells**).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: IPython是一种改进Python解释器交互性的Python shell设计。它增强了tab补全和许多用于计时、分析和调试代码的实用工具。我们将使用这个shell在整本书中尝试代码片段。IPython
    shell接受**魔法命令**--以`%`符号开始的语句，这些语句增强了shell的特殊行为。以`%%`开始的命令称为**单元魔法**，它可以应用于多行代码片段（称为**单元**）。
- en: IPython is available on most Linux distributions through `pip` and is included
    in Anaconda.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: IPython在大多数Linux发行版中通过`pip`提供，并包含在Anaconda中。
- en: You can use IPython as a regular Python shell (`ipython`), but it is also available
    in a Qt-based version (`ipython qtconsole`) and as a powerful browser-based interface
    (`jupyter notebook`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用IPython作为常规Python shell（`ipython`），但它也提供基于Qt的版本（`ipython qtconsole`）和强大的基于浏览器的界面（`jupyter
    notebook`）。
- en: 'In IPython and command-line interfaces, it is possible to specify the number
    of loops or repetitions with the `-n` and `-r` options. If not specified, they
    will be automatically inferred by `timeit`. When invoking `timeit` from the command
    line, you can also pass some setup code, through the `-s` option, which will execute
    before the benchmark. In the following snippet, the IPython command line and Python
    module version of `timeit` are demonstrated:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在IPython和命令行界面中，可以使用`-n`和`-r`选项指定循环或重复的次数。如果没有指定，它们将由`timeit`自动推断。从命令行调用`timeit`时，你也可以通过`-s`选项传递一些设置代码，这将执行基准测试之前。在以下代码片段中，演示了IPython命令行和Python模块版本的`timeit`：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that while the command line and IPython interfaces automatically infer
    a reasonable number of loops `n`, the Python interface requires you to explicitly
    specify a value through the `number` argument.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然命令行和IPython接口会自动推断一个合理的循环次数`n`，但Python接口需要你通过`number`参数显式指定一个值。
- en: Better tests and benchmarks with pytest-benchmark
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pytest-benchmark进行更好的测试和基准测试
- en: The Unix `time` command is a versatile tool that can be used to assess the running
    time of small programs on a variety of platforms. For larger Python applications
    and libraries, a more comprehensive solution that deals with both testing and
    benchmarking is `pytest`, in combination with its `pytest-benchmark` plugin.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Unix的`time`命令是一个多功能的工具，可以用来评估各种平台上小型程序的运行时间。对于更大的Python应用程序和库，一个更全面的解决方案，它同时处理测试和基准测试的是`pytest`，结合其`pytest-benchmark`插件。
- en: In this section, we will write a simple benchmark for our application using
    the `pytest` testing framework. For the interested reader, the `pytest` documentation,
    which can be found at [http://doc.pytest.org/en/latest/,](http://doc.pytest.org/en/latest/)
    is the best resource to learn more about the framework and its uses.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`pytest`测试框架为我们的应用程序编写一个简单的基准测试。对于感兴趣的读者，可以在[http://doc.pytest.org/en/latest/](http://doc.pytest.org/en/latest/)找到的`pytest`文档是了解框架及其用途的最佳资源。
- en: You can install `pytest` from the console using the `pip install pytest` command.
    The benchmarking plugin can be installed, similarly, by issuing the `pip install
    pytest-benchmark` command.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pip install pytest`命令从控制台安装`pytest`。同样，可以通过发出`pip install pytest-benchmark`命令来安装基准测试插件。
- en: 'A testing framework is a set of tools that simplifies writing, executing, and
    debugging tests and provides rich reports and summaries of the test results. When
    using the `pytest` framework, it is recommended to place tests separately from
    the application code. In the following example, we create the `test_simul.py` file,
    which contains the `test_evolve` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架是一组工具，它简化了编写、执行和调试测试的过程，并提供丰富的测试结果报告和总结。当使用`pytest`框架时，建议将测试代码与应用程序代码分开。在下面的示例中，我们创建了`test_simul.py`文件，其中包含`test_evolve`函数：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The  `pytest` executable can be used from the command line to discover and
    run tests contained in Python modules. To execute a specific test, we can use
    the `pytest path/to/module.py::function_name` syntax. To execute `test_evolve`, 
    we can type the following command in a console to obtain simple but informative
    output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`可执行文件可以从命令行使用，以发现和运行包含在Python模块中的测试。要执行特定的测试，我们可以使用`pytest path/to/module.py::function_name`语法。要执行`test_evolve`，我们可以在控制台中输入以下命令以获得简单但信息丰富的输出：'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have a test in place, it is possible for you to execute your test as
    a benchmark using the `pytest-benchmark` plugin. If we change our `test` function
    so that it accepts an argument named `benchmark`, the `pytest` framework will
    automatically pass the `benchmark` resource as an argument (in `pytest` terminology,
    these resources are called *fixtures*). The benchmark resource can be called by
    passing the function that we intend to benchmark as the first argument, followed
    by the additional arguments. In the following snippet, we illustrate the edits
    necessary to benchmark the `ParticleSimulator.evolve` function:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了测试，就可以使用`pytest-benchmark`插件将测试作为基准来执行。如果我们修改`test`函数，使其接受一个名为`benchmark`的参数，`pytest`框架将自动将`benchmark`资源作为参数传递（在`pytest`术语中，这些资源被称为*fixtures*）。可以通过传递我们打算基准测试的函数作为第一个参数，然后是额外的参数来调用基准资源。在下面的代码片段中，我们展示了基准测试`ParticleSimulator.evolve`函数所需的编辑：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To run the benchmark, it is sufficient to rerun the `pytest test_simul.py::test_evolve` command.
    The resulting output will contain detailed timing information regarding the `test_evolve`
    function, as shown:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行基准测试，只需重新运行`pytest test_simul.py::test_evolve`命令即可。生成的输出将包含有关`test_evolve`函数的详细计时信息，如下所示：
- en: '![](img/B06440_01_04.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B06440_01_04.png)'
- en: For each test collected, `pytest-benchmark` will execute the benchmark function
    several times and provide a statistic summary of its running time. The output
    shown earlier is very interesting as it shows how running times vary between runs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个收集到的测试，`pytest-benchmark`将多次执行基准函数，并提供其运行时间的统计总结。前面显示的输出非常有趣，因为它显示了运行时间在不同运行之间的变化。
- en: In this example, the benchmark in `test_evolve` was run `34` times (column `Rounds`),
    its timings ranged between `29` and `41` ms (`Min` and `Max`), and the `Average`
    and `Median` times were fairly similar at about `30` ms, which is actually very
    close to the best timing obtained. This example demonstrates how there can be
    substantial performance variability between runs, and that when taking timings
    with one-shot tools such as `time`, it is a good idea to run the program multiple
    times and record a representative value, such as the minimum or the median.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`test_evolve`中的基准测试运行了`34`次（`Rounds`列），其时间在`29`到`41`毫秒（`Min`和`Max`）之间，`Average`和`Median`时间大约在`30`毫秒，这实际上非常接近获得的最佳时间。这个例子展示了运行之间可能会有很大的性能变化，并且当使用`time`等单次工具进行计时的时候，多次运行程序并记录一个代表性值，如最小值或中位数，是一个好主意。
- en: '`pytest-benchmark` has many more features and options that can be used to take
    accurate timings and analyze the results. For more information, consult the documentation
    at [http://pytest-benchmark.readthedocs.io/en/stable/usage.html](http://pytest-benchmark.readthedocs.io/en/stable/usage.html).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest-benchmark`有许多更多功能和选项，可用于进行准确的计时和分析结果。有关更多信息，请参阅[http://pytest-benchmark.readthedocs.io/en/stable/usage.html](http://pytest-benchmark.readthedocs.io/en/stable/usage.html)上的文档。'
- en: Finding bottlenecks with cProfile
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cProfile查找瓶颈
- en: After assessing the correctness and timing the execution time of the program,
    we are ready to identify the parts of the code that need to be tuned for performance.
    Those parts are typically quite small compared to the size of the program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估程序的正确性和计时执行时间后，我们就可以确定需要调整性能的代码部分。这些部分通常与程序的大小相比非常小。
- en: 'Two profiling modules are available through the Python standard library:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库中提供了两个分析模块：
- en: '**The** `profile` **module**: This module is written in pure Python and adds
    a significant overhead to the program execution. Its presence in the standard
    library is because of its vast platform support and because it is easier to extend.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`profile`**模块：这个模块是用纯Python编写的，会给程序执行增加显著的开销。它在标准库中的存在是因为它具有广泛的平台支持，并且更容易扩展。'
- en: '**The** `cProfile` **module**: This is the main profiling module, with an interface
    equivalent to `profile`. It is written in C, has a small overhead, and is suitable
    as a general purpose profiler.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`cProfile`**模块：这是主要的分析模块，其接口与`profile`相当。它用C语言编写，开销小，适合作为通用分析器。'
- en: 'The `cProfile` module can be used in three different ways:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile`模块可以用三种不同的方式使用：'
- en: From the command line
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行
- en: As a Python module
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Python模块
- en: With IPython
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IPython
- en: '`cProfile` does not require any change in the source code and can be executed
    directly on an existing Python script or function. You can use `cProfile` from
    the command line in this way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile`不需要对源代码进行任何修改，可以直接在现有的Python脚本或函数上执行。您可以从命令行这样使用`cProfile`：'
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will print a long output containing several profiling metrics of all of
    the functions called in the application. You can use the `-s` option to sort the
    output by a specific metric. In the following snippet ,the output is sorted by
    the `tottime` metric, which will be described here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出包含应用程序中所有调用函数的多个分析指标的冗长输出。您可以使用`-s`选项按特定指标排序输出。在下面的代码片段中，输出按`tottime`指标排序，这里将对其进行描述：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The data produced by `cProfile` can be saved in an output file by passing the
    `-o` option. The format that `cProfile` uses is readable by the `stats` module
    and other tools. The usage of the  `-o` option is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递`-o`选项将`cProfile`生成数据保存到输出文件。`cProfile`使用的格式可由`stats`模块和其他工具读取。`-o`选项的使用方法如下：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The usage of cProfile as a Python module requires invoking the `cProfile.run` function
    in the following way:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将`cProfile`作为Python模块使用需要以以下方式调用`cProfile.run`函数：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can also wrap a section of code between method calls of a `cProfile.Profile`
    object, as shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在`cProfile.Profile`对象的方法调用之间包裹一段代码，如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`cProfile` can also be used interactively with IPython. The `%prun` magic command
    lets you profile an individual function call, as illustrated:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile`也可以与IPython交互式使用。`%prun`魔法命令允许您分析单个函数调用，如下所示：'
- en: '![](img/Screenshot-from-2017-05-14-20-02-26.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/Screenshot-from-2017-05-14-20-02-26.png)'
- en: 'The `cProfile` output is divided into five columns:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile`输出分为五个列：'
- en: '`ncalls`: The number of times the function was called.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncalls`：函数被调用的次数。'
- en: '`tottime`: The total time spent in the function without taking into account
    the calls to other functions.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tottime`：函数中不考虑对其他函数的调用所花费的总时间。'
- en: '`cumtime`: The time in the function including other function calls.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumtime`：函数中包括其他函数调用所花费的时间。'
- en: '`percall`: The time spent for a single call of the function--it can be obtained
    by dividing the total or cumulative time by the number of calls.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`：函数单次调用所花费的时间——可以通过将总时间或累积时间除以调用次数来获得。'
- en: '`filename:lineno`: The filename and corresponding line numbers. This information
    is not available when calling C extensions modules.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename:lineno`：文件名和相应的行号。当调用C扩展模块时，此信息不可用。'
- en: The most important metric is `tottime`, the actual time spent in the function
    body excluding subcalls, which tell us exactly where the bottleneck is.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的指标是`tottime`，即不包括子调用的函数体实际花费的时间，这告诉我们瓶颈的确切位置。
- en: Unsurprisingly, the largest portion of time is spent in the `evolve` function.
    We can imagine that the loop is the section of the code that needs performance
    tuning.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，大部分时间都花在了`evolve`函数上。我们可以想象，循环是代码中需要性能调优的部分。
- en: '`cProfile` only provides information at the function level and does not tell
    us which specific statements are responsible for the bottleneck. Fortunately,
    as we will see in the next section, the  `line_profiler` tool is capable of providing
    line-by-line information of the time spent in the function.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile`只提供函数级别的信息，并不告诉我们哪些具体的语句是瓶颈所在。幸运的是，正如我们将在下一节中看到的，`line_profiler`工具能够提供函数中逐行花费的时间信息。'
- en: Analyzing the `cProfile` text output can be daunting for big programs with a
    lot of calls and subcalls. Some visual tools aid the task by improving navigation
    with an interactive, graphical interface.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有大量调用和子调用的程序，分析`cProfile`文本输出可能会令人望而却步。一些可视化工具通过改进交互式图形界面来辅助任务。
- en: KCachegrind is a **Graphical User Interface (GUI)** useful to analyze the profiling
    output emitted by `cProfile`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind是一个用于分析`cProfile`生成的分析输出的**图形用户界面(GUI)**。
- en: KCachegrind is available in the Ubuntu 16.04 official repositories. The Qt port,
    QCacheGrind, can be downloaded for Windows from [http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/). Mac
    users can compile QCacheGrind using Mac Ports ([http://www.macports.org/](http://www.macports.org/))
    by following the instructions present in the blog post at [http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html](http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind可在Ubuntu 16.04官方仓库中找到。Qt端口，QCacheGrind，可以从[http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/)下载到Windows上。Mac用户可以通过遵循博客文章中的说明来使用Mac
    Ports编译QCacheGrind（[http://www.macports.org/](http://www.macports.org/)），该博客文章位于[http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html](http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html)。
- en: KCachegrind can't directly read the output files produced by `cProfile`. Luckily,
    the `pyprof2calltree` third-party Python module is able to convert the `cProfile`
    output file into a format readable by KCachegrind.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind不能直接读取`cProfile`生成的输出文件。幸运的是，第三方Python模块`pyprof2calltree`能够将`cProfile`输出文件转换为KCachegrind可读的格式。
- en: You can install `pyprof2calltree` from the Python Package Index using the command
    `pip install pyprof2calltree`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令`pip install pyprof2calltree`从Python包索引安装`pyprof2calltree`。
- en: 'To best show the KCachegrind features, we will use another example with a more
    diversified structure. We define a `recursive` function, `factorial`, and two
    other functions that use `factorial`, named `taylor_exp` and `taylor_sin`. They
    represent the polynomial coefficients of the Taylor approximations of `exp(x)`
    and `sin(x)`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地展示KCachegrind的功能，我们将使用一个具有更复杂结构的另一个示例。我们定义了一个`recursive`函数，名为`factorial`，以及两个使用`factorial`的其他函数，分别命名为`taylor_exp`和`taylor_sin`。它们代表了`exp(x)`和`sin(x)`的泰勒近似的多项式系数：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To access profile information, we first need to generate the `cProfile` output
    file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问配置文件信息，我们首先需要生成`cProfile`输出文件：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can convert the output file with `pyprof2calltree` and launch KCachegrind:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`pyprof2calltree`转换输出文件并启动KCachegrind：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了输出：
- en: '![](img/Screenshot-from-2017-01-14-15-29-36.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/Screenshot-from-2017-01-14-15-29-36.png)'
- en: 'The preceding screenshot shows the KCachegrind user interface. On the left,
    we have an output fairly similar to `cProfile`. The actual column names are slightly
    different: Incl. translates to `cProfile` module''s `cumtime` and Self translates
    to `tottime`. The values are given in percentages by clicking on the Relative
    button on the menu bar. By clicking on the column headers, you can sort them by
    the corresponding property.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了KCachegrind用户界面。在左侧，我们有一个与`cProfile`相当输出的输出。实际的列名略有不同：Incl.对应于`cProfile`模块的`cumtime`，Self对应于`tottime`。通过在菜单栏上点击相对按钮，以百分比的形式给出值。通过点击列标题，您可以按相应的属性排序。
- en: On the top right, a click on the Callee Map tab will display a diagram of the
    function costs. In the diagram, the time percentage spent by the function is proportional
    to the area of the rectangle. Rectangles can contain sub-rectangles that represent
    subcalls to other functions. In this case, we can easily see that there are two
    rectangles for the `factorial` function. The one on the left corresponds to the
    calls made by `taylor_exp` and the one on the right to the calls made by `taylor_sin`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角，点击调用图标签将显示函数成本的图表。在图表中，函数花费的时间百分比与矩形的面积成正比。矩形可以包含表示对其他函数子调用的子矩形。在这种情况下，我们可以很容易地看到有两个矩形表示`factorial`函数。左边的对应于`taylor_exp`的调用，右边的对应于`taylor_sin`的调用。
- en: 'On the bottom right, you can display another diagram, the *call graph*, by
    clicking on the Call Graph tab. A call graph is a graphical representation of
    the calling relationship between the functions; each square represents a function
    and the arrows imply a calling relationship. For example, `taylor_exp` calls `factorial` 500
    times, and `taylor_sin` calls factorial 250 times. KCachegrind also detects recursive
    calls: `factorial` calls itself 187250 times.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在右下角，您可以通过点击调用图标签显示另一个图表，即*调用图*。调用图是函数之间调用关系的图形表示；每个方块代表一个函数，箭头表示调用关系。例如，`taylor_exp`调用`factorial`
    500次，而`taylor_sin`调用`factorial` 250次。KCachegrind还检测递归调用：`factorial`调用自身187250次。
- en: You can navigate to the Call Graph or the Caller Map tab by double-clicking
    on the rectangles; the interface will update accordingly, showing that the timing
    properties are relative to the selected function. For example, double-clicking
    on `taylor_exp` will cause the graph to change, showing only the contribution
    of `taylor_exp` to the total cost.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过双击矩形导航到调用图或调用者图标签；界面将相应更新，显示时间属性相对于所选函数。例如，双击`taylor_exp`将导致图表更改，仅显示`taylor_exp`对总成本的贡献。
- en: '**Gprof2Dot** ([https://github.com/jrfonseca/gprof2dot](https://github.com/jrfonseca/gprof2dot))
    is another popular tool used to produce call graphs. Starting from output files
    produced by one of the supported profilers, it will generate a `.dot` diagram
    representing the call graph.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gprof2Dot** ([https://github.com/jrfonseca/gprof2dot](https://github.com/jrfonseca/gprof2dot))是另一个流行的工具，用于生成调用图。从支持的剖析器产生的输出文件开始，它将生成一个表示调用图的`.dot`图表。'
- en: Profile line by line with line_profiler
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用line_profiler逐行分析
- en: Now that we know which function we have to optimize, we can use the `line_profiler`
    module that provides information on how time is spent in a line-by-line fashion.
    This is very useful in situations where it's difficult to determine which statements
    are costly. The `line_profiler` module is a third-party module that is available
    on the Python Package Index and can be installed by following the instructions
    at [https://github.com/rkern/line_profiler](https://github.com/rkern/line_profiler).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了要优化的函数，我们可以使用`line_profiler`模块，该模块以逐行的方式提供关于时间花费的信息。这在难以确定哪些语句成本高昂的情况下非常有用。`line_profiler`模块是一个第三方模块，可在Python包索引上找到，并可通过遵循[https://github.com/rkern/line_profiler](https://github.com/rkern/line_profiler)上的说明进行安装。
- en: 'In order to use `line_profiler`, we need to apply a `@profile` decorator to
    the functions we intend to monitor. Note that you don''t have to import the `profile`
    function from another module as it gets injected in the global namespace when
    running the `kernprof.py` profiling script. To produce profiling output for our
    program, we need to add the `@profile` decorator to the `evolve` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`line_profiler`，我们需要将`@profile`装饰器应用到我们打算监控的函数上。请注意，您不需要从另一个模块导入`profile`函数，因为它在运行`kernprof.py`分析脚本时被注入到全局命名空间中。为了为我们程序生成分析输出，我们需要将`@profile`装饰器添加到`evolve`函数上：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `kernprof.py` script will produce an output file and will print the result
    of the profiling on the standard output. We should run the script with two options:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernprof.py` 脚本将生成一个输出文件，并将分析结果打印到标准输出。我们应该使用以下两个选项来运行脚本：'
- en: '`-l` to use the `line_profiler` function'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l` 用于使用 `line_profiler` 函数'
- en: '`-v` to immediately print the results on screen'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v` 用于立即在屏幕上打印结果'
- en: 'The usage of `kernprof.py` is illustrated in the following line of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernprof.py` 的使用在以下代码行中说明：'
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It is also possible to run the profiler in an IPython shell for interactive
    editing. You should first load the `line_profiler` extension that will provide
    the `lprun` magic command. Using that command, you can avoid adding the `@profile`
    decorator:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在 IPython shell 中运行分析器以进行交互式编辑。首先，你需要加载 `line_profiler` 扩展，它将提供 `lprun` 魔法命令。使用该命令，你可以避免添加
    `@profile` 装饰器：
- en: '![](img/Screenshot-from-2017-05-14-19-59-35.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/Screenshot-from-2017-05-14-19-59-35.png)'
- en: 'The output is quite intuitive and is divided into six columns:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相当直观，分为六个列：
- en: '`Line #`: The number of the line that was run'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行号`：运行的行号'
- en: '`Hits`: The number of times that line was run'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`击中次数`：该行被运行的次数'
- en: '`Time`: The execution time of the line in microseconds (`Time`)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`时间`：该行的执行时间，以微秒为单位（`时间`）'
- en: '`Per Hit`: Time/hits'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`每次击中`：时间/击中次数'
- en: '`% Time`: Fraction of the total time spent executing that line'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`% 时间`：执行该行所花费的总时间的比例'
- en: '`Line Contents`: The content of the line'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行内容`：该行的内容'
- en: By looking at the percentage column, we can get a pretty good idea of where
    the time is spent. In this case, there are a few statements in the `for` loop
    body with a cost of around 10-20 percent each.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看百分比列，我们可以很好地了解时间花费在哪里。在这种情况下，`for` 循环体中有几个语句，每个语句的成本约为 10-20%。
- en: Optimizing our code
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化我们的代码
- en: Now that we have identified where exactly our application is spending most of
    its time, we can make some changes and assess the change in performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了应用程序大部分时间花在了哪里，我们可以进行一些更改并评估性能的变化。
- en: 'There are different ways to tune up our pure Python code. The way that produces
    the most remarkable results is to improve the *algorithms* used. In this case,
    instead of calculating the velocity and adding small steps, it will be more efficient
    (and correct as it is not an approximation) to express the equations of motion
    in terms of radius, `r`, and angle, `alpha`, (instead of `x` and `y`), and then
    calculate the points on a circle using the following equation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以调整我们的纯 Python 代码。产生最显著结果的方法是改进所使用的**算法**。在这种情况下，我们不再计算速度并添加小步骤，而是更有效（并且正确，因为它不是近似）用半径
    `r` 和角度 `alpha`（而不是 `x` 和 `y`）来表示运动方程，然后使用以下方程计算圆上的点：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another way lies in minimizing the number of instructions. For example, we can
    precalculate the `timestep * p.ang_vel` factor that doesn't change with time.
    We can exchange the loop order (first we iterate on particles, then we iterate
    on time steps) and put the calculation of the factor outside the loop on the particles.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过最小化指令的数量。例如，我们可以预先计算 `timestep * p.ang_vel` 因子，该因子不随时间变化。我们可以交换循环顺序（首先迭代粒子，然后迭代时间步），并将因子的计算放在循环外的粒子上进行。
- en: 'The line-by-line profiling also showed that even simple assignment operations
    can take a considerable amount of time. For example, the following statement takes
    more than 10 percent of the total time:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 行内分析还显示，即使是简单的赋值操作也可能花费相当多的时间。例如，以下语句占用了超过 10% 的总时间：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can improve the performance of the loop by reducing the number of assignment
    operations performed. To do that, we can avoid intermediate variables by rewriting
    the expression into a single, slightly more complex statement (note that the right-hand
    side gets evaluated completely before being assigned to the variables):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过减少执行的操作数来提高循环的性能。为此，我们可以通过将表达式重写为单个稍微复杂一些的语句来避免中间变量（注意，右侧在赋值给变量之前会被完全评估）：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This leads to the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下代码：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'After applying the changes, we should verify that the result is still the same
    by running our test. We can then compare the execution times using our benchmark:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改后，我们应该通过运行我们的测试来验证结果是否仍然相同。然后我们可以使用我们的基准来比较执行时间：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we obtained only a modest increment in speed by making a pure
    Python micro-optimization.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过进行纯 Python 微优化只获得了速度的适度提升。
- en: The dis module
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`dis` 模块'
- en: Sometimes it's not easy to estimate how many operations a Python statement will
    take. In this section, we will dig into the Python internals to estimate the performance
    of individual statements. In the CPython interpreter, Python code is first converted
    to an intermediate representation, the **bytecode**, and then executed by the
    Python interpreter.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时很难估计Python语句将执行多少操作。在本节中，我们将深入研究Python内部机制以估计单个语句的性能。在CPython解释器中，Python代码首先被转换为中间表示形式，即**字节码**，然后由Python解释器执行。
- en: 'To inspect how the code is converted to bytecode, we can use the `dis` Python
    module (`dis` stands for disassemble). Its usage is really simple; all that is
    needed is to call the `dis.dis` function on the `ParticleSimulator.evolve` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查代码如何转换为字节码，我们可以使用`dis` Python模块（`dis`代表反汇编）。它的使用非常简单；所需做的就是调用`dis.dis`函数对`ParticleSimulator.evolve`方法进行操作：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will print, for each line in the function, a list of bytecode instructions.
    For example, the `v_x = (-p.y)/norm` statement is expanded in the following set
    of instructions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出函数中每一行的字节码指令列表。例如，`v_x = (-p.y)/norm`语句在以下指令集中展开：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`LOAD_FAST` loads a reference of the `p` variable onto the stack and `LOAD_ATTR`
    loads the `y` attribute of the item present on top of the stack. The other instructions,
    `UNARY_NEGATIVE` and `BINARY_TRUE_DIVIDE`, simply do arithmetic operations on
    top-of-stack items. Finally, the result is stored in `v_x` (`STORE_FAST`).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOAD_FAST`将`p`变量的引用加载到栈上，`LOAD_ATTR`将栈顶元素的`y`属性加载到栈上。其他指令，如`UNARY_NEGATIVE`和`BINARY_TRUE_DIVIDE`，在栈顶元素上执行算术运算。最后，结果存储在`v_x`中（`STORE_FAST`）。'
- en: By analyzing the `dis` output, we can see that the first version of the loop
    produces `51` bytecode instructions while the second gets converted into `35`
    instructions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析`dis`输出，我们可以看到第一个版本的循环产生了`51`条字节码指令，而第二个版本被转换为`35`条指令。
- en: The `dis` module helps discover how the statements get converted and serves
    mainly as an exploration and learning tool of the Python bytecode representation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`dis`模块有助于发现语句是如何转换的，主要用作Python字节码表示的探索和学习工具。'
- en: To improve our performance even further, we can keep trying to figure out other
    approaches to reduce the amount of instructions. It's clear, however, that this
    approach is ultimately limited by the speed of the Python interpreter and it is
    probably not the right tool for the job. In the following chapters, we will see
    how to speed up interpreter-limited calculations by executing fast specialized
    versions written in a lower level language (such as C or Fortran).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高我们的性能，我们可以继续尝试找出其他方法来减少指令的数量。然而，很明显，这种方法最终受限于Python解释器的速度，可能不是完成这项工作的正确工具。在接下来的章节中，我们将看到如何通过执行用较低级别语言（如C或Fortran）编写的快速专用版本来加快解释器受限的计算速度。
- en: Profiling memory usage with memory_profiler
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`memory_profiler`分析内存使用
- en: In some cases, high memory usage constitutes an issue. For example, if we want
    to handle a huge number of particles, we will incur a memory overhead due to the
    creation of many `Particle` instances.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，高内存使用量构成一个问题。例如，如果我们想要处理大量的粒子，由于创建了大量的`Particle`实例，我们将产生内存开销。
- en: The `memory_profiler` module summarizes, in a way similar to `line_profiler`,
    the memory usage of the process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory_profiler`模块以一种类似于`line_profiler`的方式总结了进程的内存使用情况。'
- en: The `memory_profiler` package is also available on the Python Package Index.
    You should also install the `psutil` module ([https://github.com/giampaolo/psutil](https://github.com/giampaolo/psutil))
    as an optional dependency that will make `memory_profiler` considerably faster.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory_profiler`包也可在Python包索引中找到。您还应该安装`psutil`模块（[https://github.com/giampaolo/psutil](https://github.com/giampaolo/psutil)），作为可选依赖项，这将使`memory_profiler`运行得更快。'
- en: Just like `line_profiler`, `memory_profiler` also requires the instrumentation
    of the source code by placing a `@profile` decorator on the function we intend
    to monitor. In our case, we want to analyze the `benchmark` function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`line_profiler`一样，`memory_profiler`也要求通过在我们要监控的函数上放置`@profile`装饰器来对源代码进行仪器化。在我们的例子中，我们想要分析`benchmark`函数。
- en: 'We can slightly change `benchmark` to instantiate a considerable amount (`100000`)
    of `Particle` instances and decrease the simulation time:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微修改`benchmark`，实例化大量的`Particle`实例（例如`100000`个），并减少模拟时间：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use `memory_profiler` from an IPython shell through the `%mprun` magic
    command as shown in the following screenshot:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下截图所示的`%mprun`魔法命令从IPython shell中使用`memory_profiler`：
- en: '![](img/Screenshot-from-2017-05-14-19-53-49.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screenshot-from-2017-05-14-19-53-49.png)'
- en: It is possible to run `memory_profiler` from the shell using the `mprof run`
    command after adding the `@profile` decorator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了`@profile`装饰器后，可以使用`mprof run`命令从shell中运行`memory_profiler`。
- en: From the `Increment` column, we can see that 100,000 `Particle` objects take
    `23.7 MiB` of memory.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Increment`列中，我们可以看到100,000个`Particle`对象占用`23.7 MiB`的内存。
- en: 1 MiB (mebibyte) is equivalent to  1,048,576 bytes. It is different from 1 MB
    (*megabyte*), which is equivalent to 1,000,000 bytes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 1 MiB（兆字节）相当于1,048,576字节。它与1 MB（兆字节）不同，1 MB相当于1,000,000字节。
- en: 'We can use `__slots__` on the `Particle` class to reduce its memory footprint.
    This feature saves some memory by avoiding storing the variables of the instance
    in an internal dictionary. This strategy, however, has a drawback--it prevents
    the addition of attributes other than the ones specified in `__slots__` :'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Particle`类上使用`__slots__`来减少其内存占用。这个特性通过避免在内部字典中存储实例变量来节省一些内存。然而，这种策略有一个缺点——它阻止了添加`__slots__`中未指定的属性：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now rerun our benchmark to assess the change in memory consumption,
    the result is displayed in the following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以重新运行我们的基准测试来评估内存消耗的变化，结果如下截图所示：
- en: '![](img/Screenshot-from-2017-05-14-19-45-34.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Screenshot-from-2017-05-14-19-45-34.png)'
- en: By rewriting the `Particle` class using `__slots__`, we can save about `10 MiB`
    of memory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`__slots__`重写`Particle`类，我们可以节省大约`10 MiB`的内存。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the basic principles of optimization and applied
    those principles to a test application. When optimizing, the first thing to do
    is test and identify the bottlenecks in the application. We saw how to write and
    time a benchmark using the `time` Unix command, the Python `timeit` module, and
    the full-fledged `pytest-benchmark` package. We learned how to profile our application
    using `cProfile`, `line_profiler`, and `memory_profiler`, and how to analyze and
    navigate the profiling data graphically with KCachegrind.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了优化的基本原理，并将这些原理应用于一个测试应用。在优化时，首先要做的是测试并确定应用中的瓶颈。我们看到了如何使用`time` Unix命令、Python的`timeit`模块以及完整的`pytest-benchmark`包来编写和计时基准测试。我们学习了如何使用`cProfile`、`line_profiler`和`memory_profiler`来分析我们的应用，以及如何使用KCachegrind图形化地分析和导航分析数据。
- en: In the next chapter, we will explore how to improve performance using algorithms
    and data structures available in the Python standard library. We will cover scaling,
    sample usage of several data structures, and learn techniques such as caching
    and memoization.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用Python标准库中可用的算法和数据结构来提高性能。我们将涵盖扩展、几个数据结构的示例用法，并学习诸如缓存和记忆化等技术。
