<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. The Factory Pattern – Building Factories to Create Objects</h1></div></div></div><p class="calibre6">In the previous chapter, you learned about Singleton design patterns—what they are and how they are used in the real world along with the Python implementation. The Singleton design pattern is one of the Creational design patterns. In this chapter, we move ahead and learn about another creational pattern, the Factory pattern.</p><p class="calibre6">The Factory pattern<a id="id87" class="calibre1"/> is arguably the most used design pattern. In this chapter, we will understand the concept of Factory and go through the Simple Factory pattern. You will then learn about the Factory method pattern and Abstract Factory pattern with a UML diagram, real-world scenarios, and Python v3.5 implementations. We'll also compare the Factory method and Abstract Factory method.</p><p class="calibre6">In this chapter, we will cover the following topics in brief:</p><div><ul class="itemizedlist"><li class="listitem">Understanding the Simple Factory design pattern</li><li class="listitem">Discussing the Factory method and Abstract Factory method and their differences</li><li class="listitem">Implementing real-world scenarios with the Python code implementation</li><li class="listitem">Discussing the advantages and disadvantages of the patterns and their comparisons</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec24" class="calibre1"/>Understanding the Factory pattern</h1></div></div></div><p class="calibre6">In<a id="id88" class="calibre1"/> object-oriented programming, the term factory means a class that is responsible for creating objects of other types. Typically, the class that acts as a factory has an object and methods associated with it. The client calls this method with certain parameters; objects of desired types are created in turn and returned to the client by the factory.</p><p class="calibre6">So the question here really is, why do we need a factory when the client can directly create an object? The answer is, a factory provides certain advantages that are listed here:</p><div><ul class="itemizedlist"><li class="listitem">The first advantage is loose coupling in which <a id="id89" class="calibre1"/>object creation can be independent of the class implementation.</li><li class="listitem">The client need not be aware of the class that creates the object which, in turn, is utilized by the client. It is only necessary to know the interface, methods, and parameters that need to be passed to create objects of the desired type. This simplifies implementations for the client.</li><li class="listitem">Adding another class to the factory to create objects of another type can be easily done without the client changing the code. At a minimum, the client needs to pass just another parameter.</li><li class="listitem">The factory can also reuse the existing objects. However, when the client does direct object creation, this always creates a new object.</li></ul></div><p class="calibre6">Let's consider the situation of a manufacturing company that manufactures toys—cars or dolls. Let's say that a machine in the company is currently manufacturing toy cars. Then, the CEO of the company feels that there is an urgent need to manufacture dolls based on the demand in the market. This situation calls for the Factory pattern. In this case, the machine becomes the interface and the CEO is the client. The CEO is only bothered about the object (or the toy) to be manufactured and knows the interface—the machine—that can create the object.</p><p class="calibre6">There are three variants of the Factory pattern:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre7">Simple Factory pattern</strong>: This allows<a id="id90" class="calibre1"/> interfaces to create <a id="id91" class="calibre1"/>objects without exposing the object creation logic.</li><li class="listitem"><strong class="calibre7">Factory method pattern</strong>: This<a id="id92" class="calibre1"/> allows interfaces to <a id="id93" class="calibre1"/>create objects, but defers the decision to the subclasses to determine the class for object creation.</li><li class="listitem"><strong class="calibre7">Abstract Factory pattern</strong>: An <a id="id94" class="calibre1"/>Abstract Factory <a id="id95" class="calibre1"/>is an interface to create related objects without specifying/exposing their classes. The pattern provides objects of another factory, which internally creates other objects.</li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec25" class="calibre1"/>The Simple Factory pattern</h1></div></div></div><pre>Animal</code>. <code class="email">Animal</code> is an abstract base class (<code class="email">ABCMeta</code> is Python's special metaclass to make a class <code class="email">Abstract</code>) and has the <code class="email">do_say()</code> method. We create two products (<code class="email">Cat</code> and <code class="email">Dog</code>) from the Animal interface and implement <code class="email">do_say()</code> with appropriate sounds that these animals make. <code class="email">ForestFactory</code> is a factory that has the <code class="email">make_sound()</code> method. Based on the type of argument passed by the client, an appropriate Animal instance is created at runtime and the right sound is printed out:</pre><div><pre class="programlisting">from abc import ABCMeta, abstractmethod

class Animal(metaclass = ABCMeta):
    @abstractmethod
    def do_say(self):
        pass

class Dog(Animal):
    def do_say(self):
        print("Bhow Bhow!!")

class Cat(Animal):
    def do_say(self):
        print("Meow Meow!!")


## forest factory defined
class ForestFactory(object):
    def make_sound(self, object_type):
        return eval(object_type)().do_say()

## client code
if __name__ == '__main__':
    ff = ForestFactory()
    animal = input("Which animal should make_sound Dog or Cat?")
    ff.make_sound(animal)</pre></div><pre></div><p class="calibre15"> </pre></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec26" class="calibre1"/>The Factory Method pattern</h1></div></div></div><p class="calibre6">The following points <a id="id102" class="calibre1"/>help us understand the factory method<a id="id103" class="calibre1"/> pattern:</p><div><ul class="itemizedlist"><li class="listitem">We define an interface to create objects, but instead of the factory being responsible for the object creation, the responsibility is deferred to the subclass that decides the class to be instantiated.</li><li class="listitem">The Factory method creation is through inheritance and not through instantiation.</li><li class="listitem">The Factory method makes the design more customizable. It can return the same instance or subclass rather than an object of a certain type (as in the simple factory method).<div><img src="img/00011.jpeg" alt="The Factory Method pattern" class="calibre14"/><div><p class="calibre18">A UML diagram for the Factory method</p></div></div><p class="calibre19"> </p></li></ul></div><p class="calibre6">In the preceding <a id="id104" class="calibre1"/>UML diagram, we have an abstract class, <code class="email">Creator</code>, that<a id="id105" class="calibre1"/> contains <code class="email">factoryMethod()</code>. The <code class="email">factoryMethod()</code>  method has the responsibility of creating objects of a certain type. The <code class="email">ConcreteCreator</code> class has <code class="email">factoryMethod()</code> that implements the <code class="email">Creator</code> abstract class, and this method can change the created object at runtime. <code class="email">ConcreteCreator</code> creates <code class="email">ConcreteProduct</code> and makes sure that the object it creates implements the <code class="email">Product</code> class and provides implementation for all the methods in the <code class="email">Product</code> interface.</p><p class="calibre6">In brief, <code class="email">factoryMethod()</code> of the <code class="email">Creator</code> interface and the <code class="email">ConcreteCreator</code> class decides which subclass of Product to create. Thus, the Factory method pattern defines an interface to create an object, but defers the decision ON which class to instantiate to its subclasses.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec27" class="calibre1"/>Implementing the Factory Method</h2></div></div></div><p class="calibre6">Let's take a real-world <a id="id106" class="calibre1"/>scenario to understand the Factory method implementation. Consider that we would like to create profiles of different types on social networks such as LinkedIn and Facebook for a person or company. Now, each of these profiles would have certain sections. In LinkedIn, you would have a section on patents that an individual has filed or publications s/he has written. On Facebook, you'll see sections in an album of pictures of your recent visit to a holiday place. Additionally, in both these profiles, there'd be a common section on personal information. So, in brief, we want to create profiles of different types with the right sections being added to the profile.</p><p class="calibre6">Let's now take a look at the implementation. In the following code example, we will start by defining the <code class="email">Product</code> interface. We will create a <code class="email">Section</code> abstract class that defines how a section will be. We will keep it very simple and provide an abstract method, <code class="email">describe()</code>.</p><p class="calibre6">We now create multiple <code class="email">ConcreteProduct</code> classes, <code class="email">PersonalSection</code>, <code class="email">AlbumSection</code>, <code class="email">PatentSection</code>, and <code class="email">PublicationSection</code>. These classes implement the <code class="email">describe()</code> abstract method and print their respective section names: </p><div><pre class="programlisting">from abc import ABCMeta, abstractmethod


class Section(metaclass=ABCMeta):
    @abstractmethod
    def describe(self):
        pass


class PersonalSection(Section):
    def describe(self):
        print("Personal Section")


class AlbumSection(Section):
    def describe(self):
        print("Album Section")


class PatentSection(Section):
    def describe(self):
        print("Patent Section")


class PublicationSection(Section):
    def describe(self):
        print("Publication Section")</pre></div><p class="calibre6">We create<a id="id107" class="calibre1"/> a <code class="email">Creator</code> abstract class that is named <code class="email">Profile</code>. The <code class="email">Profile [Creator]</code> abstract class provides a factory method, <code class="email">createProfile()</code>. The <code class="email">createProfile()</code> method should be implemented by <code class="email">ConcreteClass</code> to actually create the profiles with appropriate sections. The <code class="email">Profile</code> abstract class is not aware of the sections that each profile should have. For example, a Facebook profile should have personal information and album sections. So we will let the subclass decide this.</p><p class="calibre6">We create two <code class="email">ConcreteCreator</code> classes, <code class="email">linkedin</code> and <code class="email">facebook</code>. Each of these classes implement the <code class="email">createProfile()</code> abstract method that actually creates (instantiates) multiple sections (<code class="email">ConcreteProducts</code>) at runtime:</p><div><pre class="programlisting">class Profile(metaclass=ABCMeta):
    def __init__(self):
        self.sections = []
        self.createProfile()
    @abstractmethod
    def createProfile(self):
        pass
    def getSections(self):
        return self.sections
    def addSections(self, section):
        self.sections.append(section)


class linkedin(Profile):
    def createProfile(self):
        self.addSections(PersonalSection())
        self.addSections(PatentSection())
        self.addSections(PublicationSection())


class facebook(Profile):
    def createProfile(self):
        self.addSections(PersonalSection())
        self.addSections(AlbumSection())</pre></div><p class="calibre6">We finally write client code that determines which <code class="email">Creator</code> class to instantiate in order to create a profile of the desired choice:</p><div><pre class="programlisting">if __name__ == '__main__':
    profile_type = input("Which Profile you'd like to create? [LinkedIn or FaceBook]")
    profile = eval(profile_type.lower())()
    print("Creating Profile..", type(profile).__name__)
    print("Profile has sections --", profile.getSections())</pre></div><pre></div><p class="calibre15"> </pre></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec28" class="calibre1"/>Advantages of the Factory method pattern</h2></div></div></div><p class="calibre6">As you have<a id="id109" class="calibre1"/> now learned the Factory method pattern and how to implement Factory methods, let's see the advantages of the Factory method pattern:</p><div><ul class="itemizedlist"><li class="listitem">It brings in a lot of flexibility and makes the code generic, not being tied to a certain class for instantiation. This way, we're dependent on the interface (Product) and not on the <code class="email">ConcreteProduct</code> class.</li><li class="listitem">There's loose coupling, as the code that creates the object is separate from the code that uses it. The client need not bother about what argument to pass and which class to instantiate. The addition of new classes is easy and involves low maintenance.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec27" class="calibre1"/>The Abstract Factory pattern</h1></div></div></div><p class="calibre6">The <a id="id110" class="calibre1"/>main objective <a id="id111" class="calibre1"/>of the Abstract Factory pattern is to provide an interface to create families of related objects without specifying the concrete class. While the factory method defers the creation of the instance to the subclasses, the goal of Abstract Factory method is to create families of related objects:</p><div><img src="img/00013.jpeg" alt="The Abstract Factory pattern" class="calibre14"/><div><p class="calibre18">A UML Diagram for the Abstract Factory pattern</p></div></div><p class="calibre15"> </p><p class="calibre6">As shown in the<a id="id112" class="calibre1"/> diagram, <code class="email">ConcreteFactory1</code> and <code class="email">ConcreteFactory2</code> are created<a id="id113" class="calibre1"/> from the <code class="email">AbstractFactory</code> interface. This interface has methods to create multiple products.</p><p class="calibre6">
<code class="email">ConcreteFactory1</code> and <code class="email">ConcreteFactory2</code> implement AbstractFactory and create instances of <code class="email">ConcreteProduct1</code>, <code class="email">ConcreteProduct2</code>, <code class="email">AnotherConcreteProduct1</code>, and <code class="email">AnotherConcreteProduct2</code>.</p><p class="calibre6">
<code class="email">ConcreteProduct1</code> and <code class="email">ConcreteProduct2</code> are in turn created from the <code class="email">AbstractProduct</code> interface, and <code class="email">AnotherConcreteProduct1</code> and <code class="email">AnotherConcreteProduct2</code> are created from the <code class="email">AnotherAbstractProduct</code> interface.</p><p class="calibre6">In effect, Abstract Factory patterns make sure that the client is isolated from the creation of objects but allowed to use the objects created. The client has the ability to access objects only through an interface. If products of one family are to be used, Abstract Factory pattern helps the client use the objects from one/ family at a time. For example, if an application under development is supposed to be platform-independent, then it needs to abstract dependencies such as OS, file system calls, among others. Abstract Factory pattern takes care of creating the required services for the entire platform so that the client doesn't have to create platform objects directly.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec29" class="calibre1"/>Implementing the Abstract Factory pattern</h2></div></div></div><p class="calibre6">Consider the case of <a id="id114" class="calibre1"/>your favorite pizza place. It serves multiple types of pizzas, right? Wait, hold on, I know you want to order one right away, but let's just get back to the example for now!</p><p class="calibre6">Now, imagine that we create a pizza store where you are served with delicious Indian and American pizzas. For this, we first create an abstract base class, <code class="email">PizzaFactory</code> (<code class="email">AbstractFactory</code> in the preceding UML diagram). The <code class="email">PizzaFactory</code> class has two abstract methods, <code class="email">createVegPizza()</code> and <code class="email">createNonVegPizza()</code>, that need to be implemented by <code class="email">ConcreteFactory</code>. In this example, we create two concrete factories, namely, <code class="email">IndianPizzaFactory</code> and <code class="email">USPizzaFactory</code>. Look at the following code implementation for the concrete factories:</p><div><pre class="programlisting">from abc import ABCMeta, abstractmethod


class PizzaFactory(metaclass=ABCMeta):
    
    @abstractmethod
    def createVegPizza(self):
        pass
    
    @abstractmethod
    def createNonVegPizza(self):
        pass

class IndianPizzaFactory(PizzaFactory):
    
    def createVegPizza(self):
        return DeluxVeggiePizza()
    
    def createNonVegPizza(self):
        return ChickenPizza()


class USPizzaFactory(PizzaFactory):
    
    def createVegPizza(self):
        return MexicanVegPizza()
    
    def createNonVegPizza(self):
        return HamPizza()</pre></div><p class="calibre6">Now, let's move ahead and define <code class="email">AbstractProducts</code>. In the following code, we create two abstract classes, <code class="email">VegPizza</code> and <code class="email">NonVegPizza</code> (<code class="email">AbstractProduct</code> and <code class="email">AnotherAbstractProduct</code> in the preceding UML diagram]. They individually have a method defined, <code class="email">prepare()</code> and <code class="email">serve()</code>.</p><p class="calibre6">The thought process<a id="id115" class="calibre1"/> here is that vegetarian pizzas are prepared with an appropriate crust, vegetables, and seasoning, and nonvegetarian pizzas are served with nonvegetarian toppings on top of vegetarian pizzas.</p><p class="calibre6">We then define <code class="email">ConcreteProducts</code> for each of the <code class="email">AbstractProducts</code>. Now, in this case, we create <code class="email">DeluxVeggiePizza</code> and <code class="email">MexicanVegPizza</code> and implement the <code class="email">prepare()</code> method. <code class="email">ConcreteProducts1</code> and <code class="email">ConcreteProducts2</code> would represent these classes from the UML diagram.</p><p class="calibre6">Later, we define <code class="email">ChickenPizza</code> and <code class="email">HamPizza</code> and implement the <code class="email">serve()</code> method—these represent <code class="email">AnotherConcreteProducts1</code> and <code class="email">AnotherConcreteProducts2</code>:</p><div><pre class="programlisting">class VegPizza(metaclass=ABCMeta):
    @abstractmethod
    def prepare(self, VegPizza):
        pass

class NonVegPizza(metaclass=ABCMeta):
    @abstractmethod
    def serve(self, VegPizza):
        pass

class DeluxVeggiePizza(VegPizza):
    def prepare(self):
        print("Prepare ", type(self).__name__)

class ChickenPizza(NonVegPizza):
    def serve(self, VegPizza):
        print(type(self).__name__, " is served with Chicken on ", type(VegPizza).__name__)

class MexicanVegPizza(VegPizza):
    def prepare(self):
        print("Prepare ", type(self).__name__)

class HamPizza(NonVegPizza):
    def serve(self, VegPizza):
        print(type(self).__name__, " is served with Ham on ", type(VegPizza).__name__)</pre></div><p class="calibre6">When an end user approaches <code class="email">PizzaStore</code> and asks for an American nonvegetarian pizza, <code class="email">USPizzaFactory</code> is responsible for preparing the vegetarian pizza as the base and serving the <a id="id116" class="calibre1"/>nonvegetarian pizza with ham on top!</p><div><pre class="programlisting">class PizzaStore:
    def __init__(self):
        pass
    def makePizzas(self):
        for factory in [IndianPizzaFactory(), USPizzaFactory()]:
            self.factory = factory
            self.NonVegPizza = self.factory.createNonVegPizza()
            self.VegPizza = self.factory.createVegPizza()
            self.VegPizza.prepare()
            self.NonVegPizza.serve(self.VegPizza)


pizza = PizzaStore()
pizza.makePizzas()</pre></div><p class="calibre6">The following is the output of the preceding code example:</p><div><img src="img/00014.jpeg" alt="Implementing the Abstract Factory pattern" class="calibre14"/></div><p class="calibre15"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec28" class="calibre1"/>The Factory method versus Abstract Factory method</h1></div></div></div><p class="calibre6">Now that you have learned<a id="id117" class="calibre1"/> the Factory method and <a id="id118" class="calibre1"/>Abstract Factory method, let's see the comparison of the two:</p><div><table border="1" class="blockquote1"><colgroup class="calibre20"><col class="calibre21"/><col class="calibre21"/></colgroup><thead class="calibre22"><tr class="calibre23"><th valign="bottom" class="calibre24">
<p class="calibre10">Factory method</p>
</th><th valign="bottom" class="calibre24">
<p class="calibre10">Abstract Factory method</p>
</th></tr></thead><tbody class="calibre25"><tr class="calibre23"><td valign="top" class="calibre9">
<p class="calibre10">This exposes a method to the client to create the objects</p>
</td><td valign="top" class="calibre9">
<p class="calibre10">Abstract Factory method contains one or more factory methods to create a family of related objects</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre9">
<p class="calibre10">This uses inheritance and subclasses to decide which object to create</p>
</td><td valign="top" class="calibre9">
<p class="calibre10">This uses composition to delegate responsibility to create objects of another class</p>
</td></tr><tr class="calibre23"><td valign="top" class="calibre9">
<p class="calibre10">The factory method is used to create one product</p>
</td><td valign="top" class="calibre9">
<p class="calibre10">Abstract Factory method is about creating families of related products</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec29" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">In this chapter, you learned about the Factory design pattern and the context in which it's used. We understood the basics of the Factory, and how it is effectively used in software architecture.</p><p class="calibre6">We looked at Simple Factory, where an appropriate instance is created at runtime based on the type of the argument passed by the client.</p><p class="calibre6">We also discussed the Factory method pattern, which is a variation of Simple Factory. In this pattern, we defined an interface to create objects, but the creation of objects is deferred to the subclass.</p><p class="calibre6">We went on to explore the Abstract Factory method, which provides an interface to create families of related objects without specifying the concrete class.</p><p class="calibre6">We also worked out a real-world Python implementation for all the three patterns, and compared the Factory method with Abstract Factory method.</p><p class="calibre6">At the end of this chapter, we're now ready to take the next step and study other types of patterns, so stay tuned.</p></div></body></html>