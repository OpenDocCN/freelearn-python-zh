- en: Chapter 4. Documentation and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the focus was on developing the code and getting the first release
    out the door. We have not talked about another vital aspect of application development,
    the documentation and coding standards. Although the code base is still quite
    manageable, before it is too late, we should learn techniques to improve code
    readability. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the basics of the **reStructuredText** (**RST**) format and how
    to use it for writing docstrings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to create HTML documentation for the code using the **Sphinx**
    document generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Covering some important coding standards for writing the Python code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Pylint** to evaluate how well we are doing in following these guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can guess from the preceding topics, we are taking a short break from
    coding to learn these very important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Documentation and Best Practices](img/B05034_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *If you are well aware of the code, you might find documentation unnecessary.
    But imagine you are assigned a different project that has a big code base with
    very little documentation. How will you feel? Of course, you will have to review
    the code anyway to get familiar with it. But your productivity will take a blow
    if it is not well documented. The time you spend understanding such code also
    depends on how well it has been written. This is where the coding standard aspect
    comes into the picture.* |'
  prefs: []
  type: TYPE_TB
- en: In summary, never ignore coding standards and documentation. Make sure you follow
    these guidelines while the code is being developed. It is also important to maintain
    the documentation and not to over document. Let's start by learning techniques
    to create good documentation for a Python project.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are, broadly, three levels of documentation. At the top, you have project-
    or **distribution-level documentation**. It is intended to give high-level information
    on a project, such as installation instructions, licensing terms, and so on. In
    [Chapter 3](ch03.html "Chapter 3. Modularize, Package, Deploy!"), *Modularize,
    Package, Deploy!*, you already had a flavor of this documentation. We created
    the `README` and `LICENSE` files to go along with the distribution. Additionally,
    you can add more files to make the documentation comprehensive, such as `INSTALL`,
    `TODO`, `RELEASENOTES`, `CREDITS`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The second level is the **API-level documentation**. It summarizes how a function,
    method, class, or module should be used. Python docstrings, which we will learn
    next, are used to generate API-level documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The third level of documentation is in the form of **code comments**. Such comments
    help explain how a piece of code works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sphinx** is a document generation tool for Python that is used to create
    project- and API-level documentations. In this chapter, we will use Sphinx to
    create API-level documentation from the docstrings. But, before jumping into this
    topic, let''s first understand what docstrings in Python are.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Python Enhancement Proposals (PEPs)** provide a way to propose and document
    various design standards for the Python language. There are several PEPs, and
    each one is identified by a permanent number. For example, *PEP 8*, *PEP 257*,
    *PEP 287*, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '*PEP 257* documents the guidelines to write docstrings, whereas *PEP 287* provides
    information on the reStructuredText docstring format (more on the reStructuredText
    format later in the chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is not to repeat what is already documented by these
    PEPs. We will refer to these guidelines whenever appropriate in the sections to
    follow. For a comprehensive understanding of these and other PEPs, check out [https://www.python.org/dev/peps](https://www.python.org/dev/peps).
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A docstring or document string is a string literal used to describe a class,
    method, function, or module. The purpose of a docstring is to briefly describe
    features of the code. It is different than a comment that elaborates details on
    the internal working of a piece of code. It can be accessed using the built-in
    attribute, `__doc__`. Let''s write an example to illustrate this concept. Open
    the Python interpreter and write the following trivial function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what the `__doc__` attribute for this function stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__doc__` attribute for the function is an empty string as we have not
    written any documentation for this function. Now let''s write a docstring for
    the function and print this attribute again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `__doc__` attribute now shows the docstring for the function. As can be
    seen, a docstring is represented differently than a comment. It is surrounded
    by triple double quotes (recommended style), `"""Return a special number"""`,
    or triple single quotes, `'''Return a special number'''`, and is written as the
    first statement of that class, method, function, or module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PEP 257**'
  prefs: []
  type: TYPE_NORMAL
- en: The simple example shown in the previous code is that of a single-line docstring.
    Similarly, you can have multi-line docstrings. Review the PEP 257 convention ([https://www.python.org/dev/peps/pep-0257](https://www.python.org/dev/peps/pep-0257))
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: To generate effective documentation using Sphinx, the docstring should be written
    in a markup language known as reStructuredText. Let's understand the basics of
    this format next.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to reStructuredText
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**reStructuredText** (**RST**), defines a simple markup syntax, mainly for
    Python documentation. It is a part of the Python documentation processing system
    called **docutils** ([http://docutils.sourceforge.net/index.html](http://docutils.sourceforge.net/index.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**RST**'
  prefs: []
  type: TYPE_NORMAL
- en: Does this sound familiar? In [Chapter 3](ch03.html "Chapter 3. Modularize, Package,
    Deploy!"), *Modularize, Package, Deploy*, without much elaboration, we created
    a `README` file with the RST format. In that chapter, refer to the section *Prepare
    the distribution* for more information. This section will give you a bare minimum
    introduction to the RST syntax. For further reading, comprehensive documentation
    is available at [http://docutils.sourceforge.net/rst.html](http://docutils.sourceforge.net/rst.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's review some of the most frequently used features of RST.
  prefs: []
  type: TYPE_NORMAL
- en: Section headings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To distinguish a section title from the rest of the text, it is decorated with
    an underline created using any one of the non-alpha numeric characters, such as
    `~~~~`, `====`, `–---`, or `####`. The decorated underline should be of the same
    length (or longer) as the heading text, as shown in the following example header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, dashes (`---`) are used to decorate the heading. Suppose this is considered
    as the *Heading 1* style in the document; any subsequent use of this decorator
    will result in the same style. In the following screenshot, the RST syntax is
    shown in the left column; the right column shows how it will be displayed in a
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Section headings](img/B05034_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Try it yourself!**'
  prefs: []
  type: TYPE_NORMAL
- en: You can use online RST editors, such as [http://rst.ninjs.org](http://rst.ninjs.org),
    to quickly test how your RST file will be processed.
  prefs: []
  type: TYPE_NORMAL
- en: Paragraphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a paragraph, simply write one. When done, leave at least one blank
    line at the end of it. Also, if you indent a paragraph in the RST file, it will
    appear as an indented block in the browser. Here is the RST syntax to write two
    paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, use any online RST editor and see how it will appear in a web
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Text styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can apply a different text style inside a paragraph or to the body text.
    Decorate the text with double asterisks to make it appear bold, for example, `**bold_text**`.
    Similarly, a single asterisk decoration, `*italics_text*`, is used for *italics*
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Code snippets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RST provides various directives to process formatted document blocks. The `code-block`
    directive is specified with syntax, for example, `.. code-block::`. Note that
    there is a space between the word `code-block` and the two preceding dots. The
    `code-block` directive can be specified along with the code language to construct
    a literal block. In the sample RST shown next, we have specified Python as the
    code language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The argument to the `code-block` directive is specified as `python`. It tells
    the document generator that it is Python syntax. Additionally, note that there
    should be a blank line after the directive before writing the actual code. You
    can also use the `code` directive, `.. code::`, to represent a piece of code.
    For the syntax highlighting, a Python package called **Pygments** is required.
    We'll talk more on this later, when we learn about the Sphinx document generator.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical equations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `math` directive is used to write mathematical equation. Note that you
    need to leave a blank space before and after the mathematical equation block.
    The following syntax (the left column) is one way to represent a mathematical
    formula. The right column shows how it will be displayed in a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mathematical equations](img/B05034_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bullets and numbering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bullets can be added using any of the following characters: `*`, `+`, or `-`.
    It is required to have at least one blank line, immediately before the first bullet
    and immediately after the last bullet item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can specify a numbered list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Key things to remember**'
  prefs: []
  type: TYPE_NORMAL
- en: The RST syntax requires you to leave blank lines between different style blocks.
    For example, when you write a code snippet, a mathematical equation, or a paragraph,
    you need one blank line before and after these documentation blocks. RST is indentation
    sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Dosctrings using RST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To generate nice-looking documentation for our application, we need to first
    write docstrings in the RST format. The *PEP 287* proposes guidelines to write
    docstrings using the RST format. For a comprehensive description, check out [https://www.python.org/dev/peps/pep-0287](https://www.python.org/dev/peps/pep-0287).
    Here, we will discuss some of the most important things to remember when you write
    docstrings. To illustrate the concept, let's write a docstring for the `wargame/hut.py`
    module. The documentation is also provided in the supplementary code for the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code screenshot has a sample class-level docstring for the `Hut`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dosctrings using RST](img/B05034_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review this syntax now:'
  prefs: []
  type: TYPE_NORMAL
- en: The documentation standard recommends a one-line summary separated by a blank
    line before the next descriptive block.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:arg` fields describe the input arguments for this class, as given in the
    `__init__` method. You can also use the `:param` field for this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `:ivar` field is used to describe the instance variables for the class.
    You can, optionally, specify the type of the instance variable on the same line,
    for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When Sphinx generates the HTML documentation, the instance variable type will
    be displayed next to its name. It will also try to create a link to that type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `.. seealso::` field directive is used to reference anything related to
    this class that you feel is important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `:py:meth:` field is used for cross-referencing methods. Note that the method
    name should be bound by the back quotes (symbol `` ` ``).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observe that we have not written any docstring for the `__init__` method. The
    guidelines suggest that you either write a docstring for the class or for its
    `__init__` method. For simplicity, let's follow the style just illustrated, where
    the docstring is written at the class level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Sphinx generates the documentation, by default, it ignores the docstring
    for the `__init__` method. You can change this default behavior using the `autodoc-skip-member`
    event inside `conf.py`. For more information, check out [http://sphinx-doc.org/ext/autodoc.html#skipping-members](http://sphinx-doc.org/ext/autodoc.html#skipping-members).
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx-generated HTML documentation for the `Hut` class will appear as shown
    in the following screenshot. You will learn how to create such documentation shortly!
  prefs: []
  type: TYPE_NORMAL
- en: '![Dosctrings using RST](img/B05034_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What was just presented should serve as a basic example. There is a lot more
    that you can do with RST and Sphinx. The following table lists some of the most
    commonly used features (directives, information fields, and syntax) to write docstrings.
    Use these fields in the same way as illustrated in the preceding example. For
    comprehensive documentation, visit the Sphinx website ([http://sphinx-doc.org](http://sphinx-doc.org)).
  prefs: []
  type: TYPE_NORMAL
- en: '| Information field or directive | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `:param` | Parameter description. |'
  prefs: []
  type: TYPE_TB
- en: '| `:arg` | Used to describe input arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `:key` | Keyword description. |'
  prefs: []
  type: TYPE_TB
- en: '| `:type` | Type of the parameter or argument, for example, `int`, `string`,
    and so on. You can also use the alternate syntax, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `:ivar` or `:var` | Any variable description. Generally used for instance
    variables. |'
  prefs: []
  type: TYPE_TB
- en: '| `:vartype` | Variable type description. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`:py:meth:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:py:func:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:py:class:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`:py:attr:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Syntax to cross-reference a Python method, function, class, or attribute
    receptively. For example, `` :py:meth:`MyClassA.method_a` `` will be shown as
    `MyClassA.method_a()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `.. code::` | Any code samples can be included here. The section under this
    directive is processed as a code block by the Sphinx document generator. |'
  prefs: []
  type: TYPE_TB
- en: '| `.. todo::` | Use this directive to list the TODO items. |'
  prefs: []
  type: TYPE_TB
- en: '| `.. note::` | Document anything worthy of mentioning using the notes directive.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.. warning::` | Directive to write warnings in the docstring. The warning
    block will be generally rendered with a light red background. |'
  prefs: []
  type: TYPE_TB
- en: '| `.. seealso::` | Use this directive to reference anything (a method, a function,
    and so on) related to the code for which you are writing the docstring. |'
  prefs: []
  type: TYPE_TB
- en: Docstring formatting styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we will only use the default RST format to write the docstrings.
    Various projects follow their own convention to write docstrings. Many of these
    styles are compatible with the Sphinx document generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Google Python Style Guide* ([https://google.github.io/styleguide/pyguide.html](https://google.github.io/styleguide/pyguide.html))
    will be briefly discussed here. This style is widely used because of the simplicity
    it offers. It will become obvious when you see the following code screenshot.
    It is the same docstring we wrote for the `Hut` class, rewritten using the *Google
    Python Style Guide*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docstring formatting styles](img/B05034_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this to work with Sphinx, you need to install **napoleon**, an extension
    for Sphinx. It is essentially a pre-processor that parses and converts the Google
    style docstrings into the RST format. Check out [https://pypi.python.org/pypi/sphinxcontrib-napoleon/](https://pypi.python.org/pypi/sphinxcontrib-napoleon/)
    for installation instructions for napoleon. Examples on the Google Python documentation
    style can be found on the napoleon documentation page, [http://sphinxcontrib-napoleon.readthedocs.org](http://sphinxcontrib-napoleon.readthedocs.org).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Numpy** style of documentation is another popular style used within the
    Python community. It is also supported by the napoleon extension. Check out [http://sphinxcontrib-napoleon.readthedocs.org](http://sphinxcontrib-napoleon.readthedocs.org)
    for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically creating docstring stubs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is bit of an advanced topic, mainly because it needs some background in
    using command-line tools such as **patch**.
  prefs: []
  type: TYPE_NORMAL
- en: In many situations, you do not even have the basic docstrings written for the
    functions, methods, and classes. Or, you might be following a Google docstring
    style but now you would like to switch to a different one, say a basic RST style.
    The open source tool **pyment** is meant for such scenarios. It can be used to
    create or update docstrings and also to convert between some common formatting
    styles, such as RST, Google docstring, and **numpydoc**.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read it again…the tool's name is "pyment" and not "payment" (not to be confused
    with the Python package `Pygment`). This tool is available on GitHub ([https://github.com/dadadel/pyment](https://github.com/dadadel/pyment)).
    It was not available on the PyPi website at the time this chapter was written.
    So you might not be able to install it using the pip `$pip install pyment` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As pyment is not available using pip, the installation instructions are different.
    Follow the install instructions on the GitHub project homepage ([https://github.com/dadadel/pyment](https://github.com/dadadel/pyment)).
    The alternative install instructions, which do not require the use of Git, are
    provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the ZIP archive of pyment from the project homepage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract this ZIP file to some folder, for example, `pyment-master`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the command prompt and execute the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last command should install pyment in the same directory where you have
    the Python executable. Depending on where your Python is installed, you may need
    to execute the preceding command as an administrator. After the installation,
    run this tool from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This generates a patch file called `hut.py.patch` where the basic docstring
    stubs are written.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, it is important to note that pyment will only create a basic docstring
    stub. It is our responsibility to fill in the blanks. Put another way, we should
    further improve these docstrings by writing the appropriate summary of the function
    or method—a one-liner on what each input argument (if any) does and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you are expected to merge this patch with the main file, `hut.py`. On
    Linux, use the following `patch` command (check out [https://en.wikipedia.org/wiki/Patch_(Unix)](https://en.wikipedia.org/wiki/Patch_(Unix))
    for more details) to merge the generated docstrings with the main file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Windows users**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `patch` command described here is a Unix command. On Windows, patching
    a file might not be straightforward. Here are a few options that can be used to
    apply a patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gnu utilities for win32**: This will also install a bunch of other utility
    tools commonly seen on the Unix platform. Use the `patch.exe` executable to apply
    patches. You can check out these utilities at ([http://unxutils.sourceforge.net](http://unxutils.sourceforge.net)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**python-patch**: Check out this cross-platform Python utility at [https://github.com/techtonik/python-patch](https://github.com/techtonik/python-patch).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TortoiseMerge**: It is a GUI tool used to apply patches ([https://tortoisesvn.net/docs/release/TortoiseMerge_en/tmerge-dug.html](https://tortoisesvn.net/docs/release/TortoiseMerge_en/tmerge-dug.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, the `hut.py` module should show the basic docstring stubs. We have
    developed a basic understanding on creating docstrings. Let's take the documentation
    to the next level using Sphinx.
  prefs: []
  type: TYPE_NORMAL
- en: Generating documentation with Sphinx
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sphinx is the *de facto* standard document generation tool for Python. Do not
    confuse it with a docstring. A docstring is something you write to summarize the
    behavior of an object. For example, a class docstring typically lists instance
    variables and public methods depending on your project's documentation guideline.
  prefs: []
  type: TYPE_NORMAL
- en: Sphinx uses such docstrings, or any RST file, to create nice-looking documentation.
    It can generate documentation in various output formats, such as HTML, PDF, and
    so on. Let's follow a step-by-step approach to generate API documentation in HTML
    format with Sphinx.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Installing Sphinx using pip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sphinx can be installed using pip, as shown in the following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pip is the package manager used to install Python packages. Refer to [Chapter
    1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing Simple
    Applications* for more information on pip.
  prefs: []
  type: TYPE_NORMAL
- en: This creates four executable scripts, `sphinx-autogen`, `sphinx-apidoc`, `sphinx-build`,
    and `sphinx-quickstart`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Linux, these executable are placed at the same location as your Python executable.
    For instance, if Python is available as `/usr/bin/python`, Sphinx executables
    can be accessed from the same location. On Windows OS, the Sphinx executables
    are put in the `Scripts` directory. It is the same directory where you have `pip.exe`.
    Refer to [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing
    Simple Applications* for further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'For syntax highlighting the code, Sphinx uses a tool called **Pygments** ([http://pygments.org](http://pygments.org)).
    Install this package using pip, if it is not already provided in your Python distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 – cd to the source directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 3](ch03.html "Chapter 3. Modularize, Package, Deploy!"), *Modularize,
    Package, Deploy*, we created a Python package by the name of `wargame`, containing
    all the modules. Open a terminal window and `cd` to this directory. The directory
    contents are shown in the following screenshot of the terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 – cd to the source directory](img/B05034_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 – Running sphinx-quickstart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As the name suggests, this script will get you started with Sphinx. It sets
    up a directory where the documentation files will be placed and also creates a
    default configuration file, `conf.py`. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this tool, it will ask you several questions to complete the basic
    setup. Choose the default answers for most of the questions by pressing the *return*
    key on Mac or *Enter* key for other systems. We will customize the answers for
    a few questions, shown next. The first prompt asks for the directory to place
    the documentation in. We will create a new directory called `docs` for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The last answer enables the `autodoc` extension of Sphinx. This extension will
    help us create the documentation from the docstrings created earlier. Leave the
    rest of the questions with the default answers. In the end, `sphinx-quickstart`
    prints the following summary information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – Running sphinx-quickstart](img/B05034_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The directory structure created by this script is shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 – Running sphinx-quickstart](img/B05034_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The generated `Makefile` (Linux/Mac) and `make.bat` (Windows OS) will be used
    in the final section of this topic, *Step 6 – Building the documentation*. The
    `docs/source` directory is where we need to put all the RST files (or the documentation
    source files). By default, it creates an empty `index.rst` file. It also contains
    a file, `conf.py`, which will be discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – Updating conf.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `sphinx-quickstart` script creates a build configuration file, `conf.py`.
    Here, it is located at `docs/source/conf.py`. This is the file where all the customization
    for Sphinx is defined. For example, you can specify which Sphinx extensions to
    use while generating the documentation. In the previous step, we enabled the `autodoc`
    extension to include the documentation from docstrings. It is represented in `conf.py`
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To take care of some warnings related to the `.. todo::` directive, add the
    following to the `extensions` list (you can also specify this during `sphinx-quickstart`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to make a small change in this file. As our source code is not
    in the `docs` directory, we will need to add an appropriate path to avoid import
    errors while generating the documentation. Uncomment the following line of code.
    You should find this line immediately after the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need specify the full path to the directory containing the `wargame`
    package on your system. An example is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 – Running sphinx-apidoc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, it is time to create the documentation source files (RST files) using
    the `sphinx-apidoc` tool. This tool uses the `autodoc` extension to extract the
    documentation from the docstrings. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the terminal window, run the following commands (make sure you are in the
    `docs` directory, using `cd`, before running the following command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-o` argument specifies the output directory where the generated RST files
    will be placed. In this case, the output directory is the directory by the name
    of `source`. This is a counterintuitive name, but remember that the `source` directory
    is where we keep the documentation source files. In the next step, these files
    will be used to create the final output (such as HTML files). The second argument
    represents the directory path where we have the Python code. In this case, the
    directory path is specified relative to the current working directory. Alternatively,
    you can also specify the full path, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The command-line output after running this tool is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 5 – Running sphinx-apidoc](img/B05034_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an exercise, review the auto-generated file, `source/wargame.rst`. It contains
    the `automodule` directive of the `autodoc` extension. For further details, refer
    to the Sphinx documentation ([http://sphinx-doc.org/ext/autodoc.html](http://sphinx-doc.org/ext/autodoc.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Step 6 – Building the documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous step created all the raw material we will need to create nice-looking
    documentation! There are two ways to create HTML documentation. The first option
    makes use of the `sphinx-build` tool and the other option uses the `Makefile`
    we created earlier. Let's discuss these options next.
  prefs: []
  type: TYPE_NORMAL
- en: Using sphinx-build
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `sphinx-build` tool makes it trivial to generate the final documentation.
    Run the following command while it is still in the `docs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the source directory where we have all the RST files,
    and the second argument is the directory where the final HTML documentation will
    be created. Open the `docs/build/index.html` file in a web browser and navigate
    through the links to view the documentation!
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sphinx-build](img/B05034_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using Makefile
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An alternative to `sphinx-build` is to use the `Makefile` (or `make.bat`) created
    in *Step 3 – Running sphinx-quickstart*. On Linux, type the following commands
    (first move to the `docs/source` directory using `cd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command creates HTML documentation in the `docs/build` directory.
    If you are using Windows OS, use `make.bat`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have learned how to write good documentation, let's proceed further
    and see what guidelines should you follow while writing your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Python coding standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding standards serve as guidelines to write good quality code. Complying with
    these standards can have a significant impact on code readability, and in general
    on the life of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PEP 8 Style Guide for Python Code**'
  prefs: []
  type: TYPE_NORMAL
- en: The *PEP 8* convention provides a style guide for writing Python code. If you
    are working on a project that follows its own set of coding conventions, rather
    than enforcing the *PEP 8* standards, you should adhere to the project-specific
    conventions. What matters the most is consistency. For any new project, you are
    strongly recommended to use the *PEP 8* style guide. In this section, we will
    cover a bare minimum set of guidelines that you should be aware of. For a comprehensive
    overview, check out [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists some of the important guidelines documented in *PEP
    8* to write Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| PEP 8 Style Guide For Python Code | Details |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Use four spaces per indentation level | This can be set as a preference in
    most Python editors. |'
  prefs: []
  type: TYPE_TB
- en: '| Use spaces instead of tabs for indenting | Mixed use of tabs and spaces is
    not allowed in Python 3\. Most editors have an option to convert tabs to spaces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Limit maximum line length to 79 characters | This may vary across projects.
    Some projects follow a limit of 80 characters. The illustrations in this book
    use an 80-column limit. Most editors will give you an option to draw a line at
    a specified column that serves as a visual indication. |'
  prefs: []
  type: TYPE_TB
- en: '| Put all `import` statements at the top of the file | Don''t put `import`
    statements inside the class or function bodies. Bring those out and put them at
    the top. |'
  prefs: []
  type: TYPE_TB
- en: '| One `import` statement per line | An exception to this guideline is that,
    if you are importing multiple objects from a single module, it is OK to use a
    single import for all. The following imports are acceptable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Module names | Try to keep these short. They should be all lowercase. For
    example:`attackoftheorcs.py` |'
  prefs: []
  type: TYPE_TB
- en: '| Class names | Use **UpperCamelCase** with the first letter of every word
    capitalized. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function and method names | These should be in all lowercase; use underscores
    if it improves readability. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Avoid the following style: `showGameMission` (**lowerCamelCase**). Use such
    names only if you are working on a project that uses this convention. This might
    surprise you if you are coming from a different programming background, such as
    C++. Using underscores in the method and function names is the Pythonic way. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| Comparing with `None` | Always compare a variable against `None` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Never compare it like this:`if my_var == None` OR `my_var != None` |
  prefs: []
  type: TYPE_NORMAL
- en: '| Exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: When catching an exception, specify the exception type instead of just using
    the bare `except` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Exception` class to derive exceptions instead of using the `BaseException`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid writing a lot of code inside a single `try` clause; doing so makes it
    difficult to isolate the bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Refer to [Chapter 2](ch02.html "Chapter 2. Dealing with Exceptions"), *Dealing
    with Exceptions*, which discusses some of these guidelines. |'
  prefs: []
  type: TYPE_TB
- en: '| Public and non-public attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-public attributes should have a leading underscore.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in doubt, make attributes non-public.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| As discussed in[Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*, Python does not enforce any rule to make non-public
    attributes inaccessible to the outside world. However, a good practice is to refrain
    from using non-public attributes outside the scope. If you are unsure whether
    it should be scoped as public or non-public, as a starter, make it non-public.
    Later, change it to a public attribute if necessary. Refer to [Chapter 5,](ch05.html
    "Chapter 5. Unit Testing and Refactoring") *Unit Testing and Refactoring*, where
    we discuss the testing strategies for a non-public method, `_occupy_huts`. |'
  prefs: []
  type: TYPE_TB
- en: As mentioned earlier, this is just a representative sample of the comprehensive
    *PEP 8* guidelines. Read the *PEP 8* documentation for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Code analysis – How well are we doing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will talk about tools that help to detect coding standard
    violations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code analysis – How well are we doing?](img/B05034_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '| *Good to have you back, Sir Foo! You''ve been awfully quiet, hope you are
    following along. You* *have raised a valid concern. Developers might get overwhelmed
    while trying to adhere to so many guidelines. Initially, it could appear like
    a challenge but practice should make you perfect. That said, there is still a
    likelihood that you will forget a guideline. Luckily, there are tools available
    that not only detect coding standard violations, but also inspect the code for
    errors. Some tools also try to reformat the code to adhere to coding standards.
    Let''s learn that next.* |'
  prefs: []
  type: TYPE_TB
- en: Code analysis using IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some popular Python **integrated development environments** (**IDEs**) were
    listed in [Chapter 1](ch01.html "Chapter 1. Developing Simple Applications"),
    *Developing Simple Applications*. Before looking at any of the inspection tools
    discussed next, start with your IDE. Many IDEs come well equipped with code inspection
    and reformatting tools. For example, PyCharm Community Edition has excellent support
    for code inspections. The following screenshot shows some options offered under
    the **Code** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code analysis using IDE](img/B05034_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using an IDE with a good code analysis tool has a major advantage. It can help
    you detect the problems as you write the code. The tool can continuously monitor
    the code for common coding violations and show a visual indication of the error
    or warning next to the code. Typically, this indication appears just how a spellchecker
    shows spelling mistakes in a word processor. These timely indications help immensely
    in addressing common coding mistakes right when they occur.
  prefs: []
  type: TYPE_NORMAL
- en: Pylint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pylint** is a tool that inspects the code for errors and also warns you about
    coding standard violations. It is integrated with several IDEs (check out [http://docs.pylint.org/ide-integration](http://docs.pylint.org/ide-integration)
    for a list of IDEs and editors where Pylint is either available or can be installed
    as a plugin). We will see how to use Pylint as a command-line tool. First, install
    it using pip—depending on your Python installation, you might need administrative
    access in order to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs `pylint` (or `pylint.exe` on Windows) at the same location where
    you have Python executable. Now, you should be able to use this tool from the
    command line. On Linux, the syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Where `module_name.py` is the file you want to check for errors and coding style
    problems. When you run `pylint` from the command line, it prints a detailed report
    of the analysis. This report has information on coding style, warnings, errors,
    and refactoring needs. In the end, it rates your code on a scale out of 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also customize the default settings to fit to your project needs. This
    is done using a configuration file. On Linux, run the following command in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This creates a default template for your Pylint configuration and saves it in
    your `$HOME` directory (`~/.pylintrc`). Even on Windows OS, this file can be created
    in your user's home directory Alternatively, you can specify the `PYLINTRC` environment
    variable, which holds the complete path to the file.
  prefs: []
  type: TYPE_NORMAL
- en: Pylint in action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is time for some action. Run the Pylint code analysis on the `wargame/hut.py`
    file. Recall that in an earlier section, *Dosctrings using RST*, we added a class-level
    docstring. That's pretty much the documentation we have for this file. Pylint
    will not like this so be prepared to get beaten up!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The last command prints a detailed report on the command line. Let''s see what
    we have got. The following screenshot shows the final report—the code has been
    rated **5.00** out of **10** points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pylint in action](img/B05034_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That''s pretty bad! Let''s look at where we can improve by reviewing the report
    Pylint has generated. In the report, it complains about an `import` error. Well,
    there is nothing wrong with the imports. Clearly, it is missing the Python directory
    `PATH`. This can be fixed by editing the `.pythonrc` file. Look for a commented
    line that reads `init-hook` (it should appear near the beginning of the file).
    Uncomment it and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `/path/to/wargame` with the actual path on your system to the `wargame`
    directory. With this change, rerun Pylint on this file. The new evaluation is
    shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pylint in action](img/B05034_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not bad! Just fixing the import error has already improved the score by **2.50**
    points. Let's review the generated report one more time. At the beginning of the
    report, Pylint lists all the issues present in the file. In this case, it complains
    about missing docstrings for the module and the methods of the class. The other
    thing it is not happy about is the `import` statement, `from __future__ import
    print_function`, as the first line of the module.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**PEP 236 convention**'
  prefs: []
  type: TYPE_NORMAL
- en: Although the `__future__` `import` statement must appear as the first line,
    the exception to this rule is a module docstring. A module docstring can be written
    before writing a `__future__` `import` statement. Review the *PEP 236* convention
    ([https://www.python.org/dev/peps/pep-0236](https://www.python.org/dev/peps/pep-0236))
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily fix both these issues. A reworked module docstring along with
    the rearranged `__future__ import` statement is shown in the following code screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pylint in action](img/B05034_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see how are we doing by running Pylint again after this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pylint in action](img/B05034_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yey! We have got full points for this module! Follow the similar process to
    improve the rest of the code. As an exercise, add the docstrings for the class
    methods. You can also download `wargame/hut.py` from the supplementary material
    for this chapter, which already has all the docstrings written.
  prefs: []
  type: TYPE_NORMAL
- en: PEP8 and AutoPEP8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**pep8** is another tool that inspects the code to check whether it confirms
    to the *PEP 8* coding style guide. It can be installed using pip as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To know how to use pep8, visit the project page ([https://pypi.python.org/pypi/pep8](https://pypi.python.org/pypi/pep8)).
    There is another handy tool called **autopep8** that will automatically reformat
    the code to confirm to the style recommended by *PEP 8* guidelines. This tool
    can also be installed using pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that this tool requires pep8 to be installed. Check out [https://pypi.python.org/pypi/autopep8](https://pypi.python.org/pypi/autopep8)
    for more information and usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to document code, use Sphinx to generate documentation,
    and analyze the code using tools such as Pylint. Here is an exercise that covers
    these three aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the code illustrated in [Chapter 3](ch03.html "Chapter 3. Modularize,
    Package, Deploy!"), *Modularize, Package, Deploy* (you can also use your own Python
    code instead).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write docstrings for this code (be sure to write docstrings at module, class,
    and method/function levels). You can use the default RST format to write the docstring
    or choose the *Google Python Style Guide*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate an HTML documentation using Sphinx.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run code analysis, using Pylint or any other tool, to fix coding errors and
    style problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The supporting code for this chapter is already documented to an extent. You
    can use this code as a reference and also try to improve the existing documentation
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned how to document the code using the RST format. The chapter introduced
    the Sphinx document generator that was used to create an HTML documentation for
    our application code. You also learned about some important Python coding standards
    that helped improve readability. Finally, we saw how to check our application
    code for errors and style violations using code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, you wish your code fully confirms to the coding convention.
    Often, that is not the case for various reasons, ranging from new team members
    to tight project deadlines. Sometimes, to make it compliant with the coding standards,
    you will need to refactor it at a later stage. While doing so, you will also need
    to make sure no functionality gets broken. This is accomplished by writing unit
    tests. We will study these inter-related aspects in the next chapter.
  prefs: []
  type: TYPE_NORMAL
