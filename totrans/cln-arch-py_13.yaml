- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing Observability: Monitoring and Verification'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we established Clean Architecture’s core principles through
    our task management system. We built domain entities, implemented use cases, and
    created both CLIs and web interfaces that demonstrate how Clean Architecture’s
    boundaries enable clean separation between our core business logic and external
    concerns. While these boundaries make our system more maintainable, they serve
    another crucial purpose. They make our system more observable and its architectural
    integrity more verifiable.
  prefs: []
  type: TYPE_NORMAL
- en: Through our task management system, we’ll demonstrate how Clean Architecture
    transforms system observability from a cross-cutting concern into a structured
    capability. Because our system is built with clear architectural layers and explicit
    interfaces, monitoring becomes a natural extension of our existing structure.
    This same organization that simplifies monitoring also enables continuous verification,
    helping ensure our system maintains its architectural integrity as it evolves.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand how to implement effective observability
    in Clean Architecture systems and how to verify architectural boundaries remain
    intact over time. You’ll learn practical techniques for detecting and preventing
    architectural drift, helping ensure your systems maintain their clean structure
    even as requirements and teams evolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding observability in Clean Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing cross-boundary instrumentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining architectural integrity through monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, most code examples in the chapter are
    only partially implemented. Complete versions of all examples can be found in
    the book’s accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding observability boundaries in Clean Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Clean Architecture’s explicit layer perimeters provide natural points for system
    observation which is a significant advantage that many teams overlook. While layered
    architectures can introduce complexity, these same divisions that help manage
    dependencies also enable systematic monitoring and observability. Let’s first
    explore how Clean Architecture’s fundamental principles create opportunities for
    better system instrumentation, setting the foundation for the practical implementations
    we’ll explore later. By understanding these concepts, you’ll see how Clean Architecture
    makes systems not only more maintainable but also more observable.
  prefs: []
  type: TYPE_NORMAL
- en: Natural observation points in Clean Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clean Architecture’s layered structure naturally creates strategic points for
    system observation. Before exploring these observation points, let’s understand
    what we mean by observability in software systems. Modern observability combines
    logging, metrics, and request tracing to provide a complete picture of system
    behavior. In traditional systems where these concerns cut across all components,
    implementing comprehensive monitoring often becomes an exercise in working around
    tangled dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clean Architecture transforms this complexity into clarity by providing consistent
    observation points at each layer transition. Consider how information flows through
    our task management system: when a user creates a task through the web interface,
    we can observe the request as it moves through our architectural layers, from
    initial HTTP handling, through business operations, to final persistence. Each
    layer boundary provides specific insight:'
  prefs: []
  type: TYPE_NORMAL
- en: Our web interface tracks incoming requests and their transformations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases monitor business operations and their outcomes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain entities capture state changes and business rule applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure components measure resource utilization and external interactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This systematic approach ensures we have visibility into every crucial aspect
    of our system’s behavior while maintaining clean separation between technical
    and business concerns. This transforms not just monitoring but our entire approach
    to system maintenance. When investigating issues or analyzing performance, we
    know exactly where to look for relevant information. As we’ll see in the following
    sections, this same structured approach that enables monitoring also provides
    the foundation for verifying our architectural integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding observability in Clean Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having seen how Clean Architecture provides natural observation points, let’s
    explore how to effectively leverage these points in practice. While previous chapters
    focused on establishing core architectural principles, real-world systems require
    observability from the start. Early instrumentation proves crucial. Without it,
    debugging becomes more challenging, performance issues go undetected, and understanding
    system behavior across different environments becomes nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how this plays out in our task management system. *Figure 10.1* shows
    how a seemingly simple operation like task completion involves multiple architectural
    transitions, each providing distinct observability needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Task completion flow with observation points](img/B31577_10_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Task completion flow with observation points'
  prefs: []
  type: TYPE_NORMAL
- en: The figure illustrates how monitoring concerns naturally align with our architectural
    layers. At each transition, we capture specific aspects of system behavior, from
    technical metrics at our outer boundaries to business operations in our core layers.
    This systematic approach ensures we maintain comprehensive visibility while respecting
    Clean Architecture’s separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: A layered monitoring approach provides clear benefits. When investigating issues,
    we can trace operations through our system with precision. If a customer reports
    intermittent task completion failures, we can follow the operation from web request
    through business logic to identify exactly where things went wrong. Performance
    bottlenecks become easier to locate since we know which layer is handling each
    aspect of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Each layer contributes what it knows best. Web interfaces track request handling,
    use cases monitor business operations, and infrastructure captures technical metrics.
    By respecting these natural divisions, we maintain clean separation between business
    and technical concerns while ensuring comprehensive visibility into our system’s
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: These monitoring principles translate directly into implementation patterns.
    In our task management system, we’ll use Python’s standard logging framework to
    implement this layered observability. We’ll see how Clean Architecture’s boundaries
    guide us toward simple yet effective monitoring solutions that maintain architectural
    integrity while providing the insights our system needs.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing cross-boundary instrumentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s translate our understanding of Clean Architecture’s observability benefits
    into practical implementation. Modern web frameworks such as Flask provide their
    own logging infrastructure, which can tempt developers into tightly coupling business
    operations with framework-specific logging. We’ll see how to work effectively
    with these framework mechanisms while keeping our core business logic framework-independent.
    Through a careful implementation of structured logging and request tracing, we’ll
    demonstrate patterns that maintain Clean Architecture’s boundaries while delivering
    comprehensive system observability.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding framework coupling in logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned, web frameworks often provide their own logging infrastructure.
    Flask, for instance, encourages direct use of its application logger (`app.logger`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While convenient, this approach creates problematic coupling between our business
    operations and framework-specific logging. Using Flask’s `app.logger` would require
    making the Flask application object accessible throughout our codebase which is
    a serious violation of Clean Architecture’s Dependency Rule. Inner layers would
    need to reach out to the Framework layer just to perform logging, creating exactly
    the kind of outward dependency that Clean Architecture aims to prevent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, Clean Architecture guides us toward framework-independent logging
    that respects architectural boundaries. Consider how our task creation use case
    should log operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach offers several Clean Architecture benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Use cases remain unaware of logging implementation details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging statements document business operations naturally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can change logging infrastructure without modifying business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framework-specific logging stays at system edges where it belongs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s implement this clean logging approach systematically, starting with the
    proper separation of framework and application logging concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing structured logging patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen, Clean Architecture requires that infrastructure concerns, including
    logging implementation details, remain isolated in outer layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our implementation, we’ve chosen structured JSON logging. This is a common
    practice that enables precise log processing and analysis. Each log entry becomes
    a JSON object with consistent fields, making it easier to search, filter, and
    analyze log data programmatically. While we’ll demonstrate JSON formatting, the
    patterns we establish would work equally well with other logging formats: you
    could adapt the formatter implementation without touching any code in the inner
    layers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We organize our logging infrastructure to maintain clean architectural boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Logging files in the Frameworks and Drivers layer](img/B31577_10_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Logging files in the Frameworks and Drivers layer'
  prefs: []
  type: TYPE_NORMAL
- en: 'This organization keeps logging configuration where it belongs: in the Frameworks
    and Drivers layer. The separation between framework logs (`access.log`) and application
    logs (`app.log`) demonstrates how we maintain clean boundaries even in our log
    output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This separation serves two key Clean Architecture objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation of concerns**: Each layer logs what it knows best. Flask handles
    HTTP request logging in its standard format, while our application captures business
    operations in structured JSON. This clean separation means each type of log can
    evolve independently, using formats and fields appropriate to its purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework independence**: Our core application logging remains completely
    unaware of Flask or any other web framework. We could switch to a different framework,
    or even add new interfaces such as a REST API, while our business operation logging
    continues unchanged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need a way to format our application logs that supports structured data
    while remaining independent of any framework opinions. Our `JsonFormatter` handles
    this responsibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The formatter encapsulates all JSON formatting logic in a single component,
    demonstrating the Single Responsibility Principle in action. Each log entry includes
    essential context like `timestamp` and log `level`, while remaining completely
    unaware of web frameworks or other external concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Since Python’s logging mechanism directly attaches the extra parameter keys
    to the `LogRecord` instance, we use a dedicated `context` namespace to prevent
    collisions with `LogRecord`'s built-in attributes (like `name`, `args`). This
    simple namespacing strategy lets us safely include structured data with each log
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our formatter handling the structure of individual log messages, we now
    need to configure how these messages flow through our system. This configuration
    determines which logs go where, maintaining our clean separation between framework
    and application logging. For clarity, we’ll use the Python logger’s `dictConfig`
    to establish these paths, starting with our formatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define two formatters: our custom JSON formatter for application logs
    and a simple format for framework logs. This separation lets each type of log
    maintain its appropriate structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we configure handlers that direct logs to their appropriate destinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each handler connects a log destination with its appropriate formatter, maintaining
    our clean separation between framework and application concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we wire everything together with logger configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `todo_app` logger captures all application-level operations through our
    JSON formatter, writing them to `app.log`. Meanwhile, Flask’s built-in Werkzeug
    logger remains untouched, recording HTTP requests in standard format to `access.log`.
    By keeping these logging streams separate, we maintain clean boundaries between
    framework and business concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration gets activated early in our application startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we see the main file for the web app; the CLI will be identical except
    for `app_context="CLI"`.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, this configuration means any code in our application can simply
    use Python’s standard logging module without knowing about JSON formatting, file
    handlers, or any other implementation details. These concerns remain properly
    contained within our Infrastructure layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our logging infrastructure in place, let’s see how Clean Architecture’s
    separation of concerns translates into practical benefit. Our task creation use
    case demonstrates how business operations can be clearly logged without any awareness
    of framework specifics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our application, we see this in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31577_10_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While we’ve chosen to display both log streams in the console for development
    convenience, each type of log is properly separated into its designated file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a computer code  Description automatically generated](img/B31577_10_4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we view the formatted *create new task* log statement, we see the injection
    of the `context` attribute of the log statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Through this implementation, we’ve seen how Clean Architecture guides us to
    pragmatic solutions for common infrastructure concerns. By isolating logging configuration
    in our outermost layer, we enable each part of our system to log appropriately
    while maintaining proper architectural boundaries. Framework logs and business
    operations remain cleanly separated, yet both contribute to a comprehensive view
    of system behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Building cross-boundary observability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we’ve seen how Clean Architecture’s explicit boundaries
    provide crucial benefits, from isolating business logic and maintaining testability
    to enabling interface flexibility and framework independence. However, these same
    boundaries that keep our system maintainable can make it challenging to trace
    operations as they flow through our layers.
  prefs: []
  type: TYPE_NORMAL
- en: While structured logging provides insight into individual operations, tracking
    requests across these architectural boundaries requires additional infrastructure.
    Let’s extend our task management system to implement cross-boundary tracing while
    maintaining these clean separations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens when a user creates a task through our web interface,
    an operation that crosses multiple architectural boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: A web request arrives at our Flask route handler
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The request flows through our task controller
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The controller invokes our use case
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The use case coordinates with repositories
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the result flows back through these layers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Without correlation between these events, debugging and monitoring become challenging.
    Our solution is straightforward but powerful: we’ll generate a unique identifier
    (trace ID) for each request and include this ID in every log statement related
    to that request. This allows us to follow a request’s journey through all layers
    of our system, from the initial web request to database operations and back.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this tracing, we’ll need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create `infrastructure/logging/trace.py` to manage trace ID generation and storage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend our logging configuration in `infrastructure/logging/config.py` to include
    trace IDs in log formats
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Flask middleware in `infrastructure/web/middleware.py` to set trace IDs
    for incoming requests
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we’ve built our logging infrastructure following Clean Architecture
    principles, no changes are needed to application code. Trace IDs will automatically
    flow through our existing logging calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our approach mapped out, let’s start with the foundation: the trace ID
    management itself. This infrastructure, while living entirely in our outer layer,
    will enable visibility across all architectural boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `set_trace_id` function establishes a unique identifier for each request
    in our system. While it accepts an optional existing ID parameter (primarily used
    for testing or specialized integrations), in normal operation each request receives
    a new `UUID`. This ensures that every operation in our system can be traced independently,
    regardless of whether it originated from our CLI, web UI, or other entry points.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why** `ContextVar`**?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We use Python’s `ContextVar` because it provides thread-safe storage that works
    across async boundaries. While the specific implementation mechanism isn’t crucial
    to Clean Architecture, choosing the right tools helps maintain clean boundaries.
    For more details on context variables, see Python’s documentation: [https://docs.python.org/3/library/contextvars.html](https://docs.python.org/3/library/contextvars.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With trace ID management in place, we next need to ensure our logging configuration
    includes the trace ID in log formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our logging configuration ensures trace IDs are included with every log message,
    regardless of the log format. For framework logs, we add trace IDs to the standard
    format using Python’s built-in logging pattern syntax `(%(trace_id)s)`. Our JSON
    formatter automatically includes trace IDs in structured output. This consistency
    means we can follow operations across all log sources, while each logging stream
    maintains its appropriate format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, our web middleware ensures each request gets a trace ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This middleware ensures every web request receives a unique trace ID. Though
    it can accept an existing ID through the `X-Trace-ID` header (useful for testing),
    it typically generates a new `UUID` for each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate this tracing, we integrate the middleware when creating our Flask
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Recall that `web_main.py` calls `create_web_app`, and thus this setup ensures
    that every request flowing through our system gets traced. This ID is then available
    throughout request processing and included in response headers for debugging purposes.
    The trace ID connects all log entries related to processing that specific request,
    from initial receipt through final response.
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a computer code  Description automatically generated](img/B31577_10_5.png)'
  prefs: []
  type: TYPE_IMG
- en: Each request through our system is assigned a unique trace ID, allowing us to
    follow that specific operation across architectural boundaries. As shown above,
    the trace ID `abc-123-xyz` appears in both framework and application logs, connecting
    all events related to this single task creation request. This tracing enables
    us to understand exactly what happened during any given request, from initial
    HTTP handling through business operations to final response.
  prefs: []
  type: TYPE_NORMAL
- en: Our logging and tracing implementation demonstrates how Clean Architecture’s
    boundaries enable comprehensive system observability without compromising architectural
    principles. Yet implementing these patterns is only half the challenge; we must
    also ensure these boundaries remain intact as our system evolves. Next, we’ll
    explore how to actively verify our architectural integrity through automated checks
    and fitness functions.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying architectural integrity through fitness functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As systems evolve, maintaining architectural integrity becomes increasingly
    challenging. Even teams committed to Clean Architecture’s principles can inadvertently
    introduce changes that compromise their systems’ carefully crafted boundaries.
    This risk has led architects to develop *fitness functions* which are automated
    tests that verify that architectural principles are correctly implemented and
    detect any drift from those principles over time.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of architectural fitness functions, introduced by Neal Ford, Rebecca
    Parsons, and Patrick Kua in their book *Building Evolutionary Architectures*,
    provides a systematic approach to maintaining architectural integrity. Just as
    unit tests verify code behavior, fitness functions verify architectural characteristics.
    By detecting violations early in the development process (an approach known as
    *shift left*), these tests help teams maintain Clean Architecture’s principles
    in an automated manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'While comprehensive architectural validation frameworks exist, Python enables
    us to implement effective verification in a simpler, more pragmatic way using
    the language’s built-in capabilities. Through our architectural verification approach,
    we’ll focus on two key aspects: ensuring our source structure maintains Clean
    Architecture’s layered organization, and detecting any violations of the fundamental
    Dependency Rule that requires dependencies to only flow inward. These complementary
    checks help teams maintain architectural integrity as systems evolve.'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying layer structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by defining our expected architectural structure. While every team’s
    specific implementation of Clean Architecture may vary slightly, the core principle
    of explicit layer organization remains constant. We can capture our particular
    interpretation in a simple configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration serves as our architectural contract, by defining how we
    expect our codebase directories to be organized. Your team might choose different
    layer names or add additional organizational rules, but the principle remains
    the same: Clean Architecture requires explicit, well-defined layers with clear
    responsibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our structure defined, we can implement verification tests that ensure
    our codebase maintains this organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple check enforces a fundamental Clean Architecture principle: our
    source code must be explicitly organized into well-defined layers. The `ArchitectureConfig`
    class allows us to customize these tests to your particular preferences. We’re
    specifically examining the top-level folders within `todo_app`, ensuring they
    match our expected architectural structure. This isn’t about the contents of these
    folders (we’ll get to that with dependency checking), but rather verifying the
    basic organizational foundation of our Clean Architecture implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a common scenario: a team is adding email notification capabilities
    to the task management system. A new developer, not yet familiar with Clean Architecture,
    creates a new notifications folder at the root level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A close-up of a text  Description automatically generated](img/B31577_10_6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This seemingly innocent organization choice represents the start of architectural
    drift. The notifications code should live in the Infrastructure layer since it’s
    an external concern. By creating a new top-level folder, we’ve:'
  prefs: []
  type: TYPE_NORMAL
- en: Created confusion about where notification-related code belongs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Started bypassing Clean Architecture’s explicit layering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a precedent for creating new top-level folders when developers are unsure
    about proper placement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our simple structural check catches this early (literally within seconds if
    tests are run on the developer’s machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This warning prompts the new developer to properly integrate the notification
    code into the Infrastructure layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B31577_10_7.png)'
  prefs: []
  type: TYPE_IMG
- en: These simple structural checks catch architectural drift before it can compromise
    system maintainability. However, proper structure is only part of Clean Architecture’s
    requirements. We must also ensure that dependencies between these layers flow
    in the right direction. Let’s examine how to verify Clean Architecture’s fundamental
    Dependency Rule.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing dependency rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our layer structure verified, we must ensure that these layers interact
    correctly according to Clean Architecture’s principles. The most fundamental of
    these is the Dependency Rule, which states that dependencies must only point inward
    toward more central layers. Even a small violation of this rule can compromise
    the architectural integrity we’ve carefully built.
  prefs: []
  type: TYPE_NORMAL
- en: Building on our structural verification, let’s examine how to detect violations
    of the Dependency Rule. This rule is crucial for maintaining a clean separation
    of concerns, yet it can be subtly violated during development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Dependency Rule verification takes a direct approach, examining Python
    import statements to ensure they only flow inward through our architectural layers.
    While more sophisticated static analysis tools exist (see *Further reading*),
    this straightforward implementation catches the most common violations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This test implementation leverages Python’s built-in `ast` module to analyze
    import statements in our Domain layer code. It works by:'
  prefs: []
  type: TYPE_NORMAL
- en: Recursively finding all Python files in the Domain layer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing each file into an Abstract Syntax Tree (AST)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Walking the AST to find Import and `ImportFrom` nodes
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checking each import to ensure it doesn’t reference outer layers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While more complex static analysis is possible, this focused check effectively
    catches the most critical dependency violations, which are those that would compromise
    our core Domain layer’s independence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a real-world scenario: a developer is implementing task completion
    notifications. They notice that the `NotificationService` in the Infrastructure
    layer already has the logic they need. Instead of following Clean Architecture’s
    patterns, they take a shortcut that violates our fundamental Dependency Rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This change might seem innocent because it gets the job done. However, it creates
    exactly the kind of outward dependency that Clean Architecture prohibits. Our
    domain entity now depends directly on an infrastructure component, meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: The Task entity can no longer be tested without `NotificationService`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t change notification implementations without modifying domain code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ve created a precedent for mixing infrastructure concerns with domain logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our dependency check catches this violation immediately during testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The error message clearly identifies:'
  prefs: []
  type: TYPE_NORMAL
- en: The file containing the violation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which architectural rule was broken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to fix it (Domain layer can’t import from infrastructure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These simple but powerful verifications help teams maintain alignment with
    Clean Architecture’s principles as systems evolve. While we’ve focused on two
    fundamental checks (structural organization and dependency rules), teams can expand
    this approach to verify other architectural characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface conformance**: Verify that interface adapters properly implement
    their declared contracts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository implementations**: Confirm that repository implementations properly
    extend their abstract bases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer-specific rules**: Add custom rules for how each layer should structure
    and expose its components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key is starting with focused, high-impact checks that verify your most crucial
    architectural boundaries. You can then evolve these fitness functions alongside
    your architecture, adding verification for new patterns and constraints as your
    system grows.
  prefs: []
  type: TYPE_NORMAL
- en: By catching structural and dependency violations early, we prevent the gradual
    erosion of architectural boundaries that can occur during rapid development. While
    these checks can’t replace architectural understanding, they provide immediate,
    actionable feedback when architectural rules are violated, thereby helping teams
    build and preserve clean, maintainable systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored how Clean Architecture’s explicit boundaries
    enable systematic monitoring and verification of our systems. Through our task
    management system, we’ve demonstrated how to implement effective observability
    while maintaining architectural integrity. We’ve seen how Clean Architecture transforms
    monitoring from a cross-cutting concern into a natural part of our system’s structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented several key observability patterns that demonstrate Clean Architecture’s
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Framework-independent logging that respects architectural boundaries while enabling
    comprehensive system visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-boundary request tracing that maintains clean separation between technical
    and business concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated architectural verification that helps teams maintain Clean Architecture’s
    principles as systems evolve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, we’ve seen how Clean Architecture’s careful attention to boundaries
    makes our systems not just maintainable but also observable and verifiable. By
    organizing our logging and monitoring infrastructure according to Clean Architecture
    principles, we create systems that are easier to understand, debug, and maintain
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 11*](Chapter_11.xhtml#_idTextAnchor250), we’ll explore how to apply
    Clean Architecture principles to existing systems, showing how these same boundaries
    and patterns can guide the transformation of legacy codebases into clean, maintainable
    architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Python Logging Cookbook* ([https://docs.python.org/3/howto/logging-cookbook.html](https://docs.python.org/3/howto/logging-cookbook.html)).
    A collection of logging related code recipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Evolutionary Architectures* ([https://www.oreilly.com/library/view/building-evolutionary-architectures/9781491986356/](https://www.oreilly.com/library/view/building-evolutionary-architectures/9781491986356/)).
    Excellent software architecture book where the term *Fitness Function* was first
    coined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PyTestArch* ([https://github.com/zyskarch/pytestarch](https://github.com/zyskarch/pytestarch)).
    Open-source framework enabling you to define architectural rules in code and run
    as tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
