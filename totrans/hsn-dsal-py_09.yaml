- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Graphs and Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图和算法
- en: Graphs are a non-linear data structure, in which the problem is represented
    as a network by connecting a set of nodes with edges, like a telephone network
    or social network. For example, in a graph, nodes can represent different cities
    while the links between them represent edges. Graphs are one of the most important
    data structures; they are used to solve many computing problems, especially when
    the problem is represented in the form of objects and their connection, e.g. to
    find out the shortest path from one city to another city. Graphs are useful data
    structures for solving real-world problems in which the problem can be represented
    as a network-like structure. In this chapter, we will be discussing the most important
    and popular concepts related to graphs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图是非线性数据结构，其中问题通过连接一组节点和边来表示为一个网络，例如电话网络或社交网络。例如，在图中，节点可以代表不同的城市，而它们之间的链接代表边。图是最重要的数据结构之一；它们用于解决许多计算问题，尤其是在问题以对象及其连接的形式表示时，例如找出从一个城市到另一个城市的最短路径。图是解决可以表示为网络结构现实世界问题的有用数据结构。在本章中，我们将讨论与图相关的重要和流行概念。
- en: 'In this chapter, we will learn about the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下概念：
- en: The concept of the graph data structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据结构的概念
- en: How to represent a graph and traverse it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何表示图并遍历它
- en: Different operations and their implementation on graphs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图上的不同操作及其实现
- en: First, we will be looking into the different types of graphs.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨不同类型的图。
- en: Graphs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: A graph is a set of a finite number of vertices (also known as nodes) and edges,
    in which the edges are the links between vertices, and each edge in a graph joins
    two distinct nodes. Moreover, a graph is a formal mathematical representation
    of a network, i.e. a graph **G** is an ordered pair of a set **V** of vertices
    and a set **E** of edges, given as `G = (V, E)` in formal mathematical notation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个图是由有限数量的顶点（也称为节点）和边组成的一组，其中边是顶点之间的链接，图中每条边连接两个不同的节点。此外，图是网络的正式数学表示，即图**G**是一个顶点集合**V**和边集合**E**的有序对，在正式数学符号中表示为`G
    = (V, E)`。
- en: 'An example of a graph is shown in *Figure 9.1*:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.1*中显示了一个图的示例：'
- en: '![](img/B17217_09_01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_01.png)'
- en: 'Figure 9.1: An example of a graph'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：一个图的示例
- en: 'The graph `G = (V, E)` in *Figure 9.1* can be described as below:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.1*中的图`G = (V, E)`可以描述如下：'
- en: '`V = {A, B, C, D, E}`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V = {A, B, C, D, E}`'
- en: '`E = {{A, B}, {A, C}, {B, C}, {B, D}, {C, D}, {D, D}, {B, E}, {D, E}}`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`E = {{A, B}, {A, C}, {B, C}, {B, D}, {C, D}, {D, D}, {B, E}, {D, E}}`'
- en: '`G = (V, E)`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G = (V, E)`'
- en: 'Let’s discuss some of the important definitions of a graph:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些图的重要定义：
- en: '**Node or vertex**: A point or node in a graph is called a vertex. In the preceding
    diagram, the vertices or nodes are **A**, **B**, **C**, **D**, and **E** and are
    denoted by a dot.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点或顶点**：图中一个点或节点称为顶点。在前面的图中，顶点或节点是**A**、**B**、**C**、**D**和**E**，并用点表示。'
- en: '**Edge**: This is a connection between two vertices. The line connecting **A**
    and **B** is an example of an edge.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边**：这是两个顶点之间的连接。连接**A**和**B**的线是一个边的示例。'
- en: '**Loop**: When an edge from a node is returned to itself , that edge forms
    a loop, e.g. **D** node.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环**：当一个节点的边返回到自身时，该边形成一个环，例如**D**节点。'
- en: '**Degree of a vertex/node**: The total number of edges that are incidental
    on a given vertex is called the degree of that vertex. For example, the degree
    of the **B** vertex in the previous diagram is `4`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点/节点的度数**：给定顶点上偶然出现的边的总数称为该顶点的度数。例如，前面图中**B**顶点的度数是`4`。'
- en: '**Adjacency**: This refers to the connection(s) between any two nodes; thus,
    if there is a connection between any two vertices or nodes, then they are said
    to be adjacent to each other. For example, the C node is adjacent to the A node
    because there is an edge between them.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邻接**：这指的是任何两个节点之间的连接；因此，如果有任何两个顶点或节点之间存在连接，则它们被认为是相邻的。例如，C节点与A节点相邻，因为它们之间有一条边。'
- en: '**Path**: A sequence of vertices and edges between any two nodes represents
    a path. For example, **CABE** represents a path from the **C** node to the **E**
    node.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：任何两个节点之间的一组顶点和边表示一条路径。例如，**CABE**代表从**C**节点到**E**节点的路径。'
- en: '**Leaf vertex** (also called *pendant vertex*): A vertex or node is called
    a leaf vertex or pendant vertex if it has exactly one degree.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶节点**（也称为*悬挂节点*）：如果一个节点或顶点恰好有一个度数，则称为叶节点或悬挂节点。'
- en: Now, we shall take a look at the different types of graphs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨不同类型的图。
- en: Directed and undirected graphs
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向和无向图
- en: 'Graphs are represented by the edges between the nodes. The connecting edges
    can be considered directed or undirected. If the connecting edges in a graph are
    undirected, then the graph is called an undirected graph, and if the connecting
    edges in a graph are directed, then it is called a directed graph. An undirected
    graph simply represents edges as lines between the nodes. There is no additional
    information about the relationship between the nodes, other than the fact that
    they are connected. For example, in *Figure 9.2*, we demonstrate an undirected
    graph of four nodes, **A**, **B**, **C**, and **D**, which are connected using
    edges:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图由节点之间的边表示。连接边可以是定向的或非定向的。如果一个图中的连接边是非定向的，那么这个图被称为无向图；如果一个图中的连接边是定向的，那么它被称为有向图。无向图简单地表示节点之间的边为线条。除了节点之间相连的事实之外，没有关于节点之间关系的其他信息。例如，在
    *图9.2* 中，我们展示了四个节点 **A**、**B**、**C** 和 **D** 的无向图，它们通过边连接：
- en: '![](img/B17217_09_02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_02.png)'
- en: 'Figure 9.2: An example of an undirected graph'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：无向图的示例
- en: In a directed graph, the edges provide information on the direction of connection
    between any two nodes in a graph. If an edge from **A** node to **B** is said
    to be directed, then the edge (**A**, **B**) would not be equal to the edge (**B**,
    **A**). The directed edges are drawn as lines with arrows, which will point in
    whichever direction the edge connects the two nodes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，边提供了图中任意两个节点之间连接方向的信息。如果从 **A** 节点到 **B** 的边是有向的，那么边（**A**，**B**）就不会等于边（**B**，**A**）。有向边以带有箭头的线条绘制，箭头将指向边连接两个节点的方向。
- en: 'For example, in *Figure 9.3*, we show a directed graph where many nodes are
    connected using directed edges:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 *图9.3* 中，我们展示了一个有向图，其中许多节点通过有向边连接：
- en: '![](img/B17217_09_03.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_03.png)'
- en: 'Figure 9.3: An example of a directed graph'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：有向图的示例
- en: 'The arrow of an edge determines the flow of direction. One can only move from
    **A** to **B**, as shown in the preceding diagram—not **B** to **A**. In a directed
    graph, each node (or vertex) has an indegree and an outdegree. Let’s have a look
    at what these are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 边的箭头决定了方向的流动。只能从 **A** 移动到 **B**，如前图所示——不能从 **B** 移动到 **A**。在有向图中，每个节点（或顶点）都有一个入度和一个出度。让我们看看这些是什么：
- en: '**Indegree**: The total number of edges that come into a vertex in the graph
    is called the indegree of that vertex. For example, in the previous diagram, the
    **E** node has `1` indegree, due to edge **CE** coming into the **E** node.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入度**：图中进入一个顶点的所有边的总数称为该顶点的入度。例如，在之前的图中，**E** 节点有一个入度为 `1`，因为边 **CE** 进入 **E**
    节点。'
- en: '**Outdegree**: The total number of edges that go out from a vertex in the graph
    is called the outdegree of that vertex. For example, the **E** node in the previous
    diagram has an outdegree of `2`, as it has two edges, **EF** and **ED**, going
    out of that node.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出度**：图中从一个顶点出发的所有边的总数称为该顶点的出度。例如，在之前的图中，**E** 节点有一个出度为 `2`，因为它有两个边，**EF**
    和 **ED**，从这个节点出发。'
- en: '**Isolated vertex**: A node or vertex is called an isolated vertex when it
    has a degree of zero, as shown as **G** node in *Figure 9.3*.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**孤立顶点**：当一个节点或顶点的度为零时，它被称为孤立顶点，如图9.3中的**G**节点所示。'
- en: '**Source vertex**: A vertex is called a source vertex if it has an indegree
    of zero. For example, in the previous diagram, the **A** node is the source vertex.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源点**：如果一个顶点的入度为零，那么这个顶点被称为源点。例如，在之前的图中，**A** 节点是源点。'
- en: '**Sink vertex**: A vertex is a sink vertex if it has an outdegree of zero.
    For example, in the previous diagram, the **F** node is the sink vertex.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇点**：如果一个顶点的出度为零，那么这个顶点被称为汇点。例如，在之前的图中，**F** 节点是汇点。'
- en: Now that we understand how directed graphs work, we can look into directed acyclic
    graphs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了有向图的工作原理，我们可以看看有向无环图。
- en: Directed acyclic graphs
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有向无环图
- en: A **directed acyclic graph** (**DAG**) is a directed graph with no cycles; in
    a DAG all the edges are directed from one node to another node so that the sequence
    of edges never forms a closed loop. A cycle in a graph is formed when the starting
    node of the first edge is equal to the ending node of the last edge in a sequence.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**有向无环图**（**DAG**）是一个没有环的有向图；在DAG中，所有边都是从一个节点指向另一个节点，这样边的序列永远不会形成一个闭环。当序列中第一条边的起始节点等于最后一条边的结束节点时，图中形成一个环。'
- en: 'A DAG is shown in *Figure 9.4* in which all the edges in the graph are directed
    and the graph does not have any cycles:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.4*中展示了一个有向无环图（DAG），其中图中所有边都是有向的，并且图中没有任何环：
- en: '![](img/B17217_09_04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_04.png)'
- en: 'Figure 9.4: An example of a directed acyclic graph'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：有向无环图的一个示例
- en: So, in a directed acyclic graph, if we start on any path from a given node,
    we never find a path that ends on the same node. A DAG has many applications,
    such as in job scheduling, citation graphs, and data compression.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在有向无环图中，如果我们从一个给定的节点开始沿任何路径，我们永远不会找到以相同节点结束的路径。DAG有许多应用，例如在作业调度、引用图和数据压缩中。
- en: Next, we will discuss weighted graphs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论带权图。
- en: Weighted graphs
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带权图
- en: 'A weighted graph is a graph that has a numeric weight associated with the edges
    in the graph. A weighted graph can be either a directed or an undirected graph.
    The numeric weight can be used to indicate distance or cost, depending on the
    purpose of the graph:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 带权图是一个与图中边关联有数值权重的图。带权图可以是定向图或无向图。数值权重可以根据图的目的用来表示距离或成本：
- en: '![](img/B17217_09_05.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_05.png)'
- en: 'Figure 9.5: An example of a weighted graph'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：带权图的一个示例
- en: Let’s consider an example – *Figure 9.5* indicates different ways to reach from
    **A** node to **D** node. There are two possible paths, such as from **A** node
    to **D** node, or it can be nodes **A-B-C-D** through **B** node and **C** node.
    Now, depending on the weights associated with the edges, any one of the paths
    can be considered better than the others for the journey – e.g. assume the weights
    in this graph represent the distance between two nodes, and we want to find out
    the shortest path between **A-D** nodes; then one possible path **A-D** has an
    associated cost of 40, and another possible path **A-B-C-D** has an associated
    cost of 25\. In this case, the better path is **A-B-C-D**, which has a lower distance.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子 – *图9.5*显示了从**A**节点到**D**节点的不同路径。有两种可能的路径，例如从**A**节点到**D**节点，或者它可以是经过**B**节点和**C**节点的节点**A-B-C-D**。现在，根据与边关联的权重，任何一条路径都可以被认为是比其他路径更适合旅行
    – 例如，假设这个图中的权重代表两个节点之间的距离，我们想要找出**A-D**节点之间的最短路径；那么一条可能的路径**A-D**有一个关联的成本为40，而另一条可能的路径**A-B-C-D**有一个关联的成本为25。在这种情况下，更好的路径是**A-B-C-D**，它具有更低的距离。
- en: Next, we will discuss bipartite graphs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论二分图。
- en: Bipartite graphs
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二分图
- en: A bipartite graph (also known as a bigraph) is a special graph in which all
    the nodes of the graph can be divided into two sets in such a way that edges connect
    the nodes from one set to the nodes of another set. See *Figure 9.6* for a sample
    bipartite graph; all the nodes of the graphs are divided into two independent
    sets, i.e., set U and set V, so that each edge in the graph has one end in set
    U and another end in set V (e.g. in edge (*A, B*), one end or one vertex is from
    set U, and another end or another vertex is from set V).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 二分图（也称为双图）是一种特殊的图，其中图中的所有节点都可以分为两个集合，使得边连接来自一个集合的节点到另一个集合的节点。参见*图9.6*以获取一个示例二分图；图中所有节点被分为两个独立的集合，即集合U和集合V，使得图中每条边的一个端点在集合U中，另一个端点在集合V中（例如，在边(*A,
    B*)中，一个端点或一个顶点来自集合U，另一个端点或另一个顶点来自集合V）。
- en: 'In bipartite graphs, no edge will connect to the nodes of the same set:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在二分图中，没有边会连接到同一集合的节点：
- en: '![](img/B17217_09_06.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_06.png)'
- en: 'Figure 9.6: An example of a bipartite graph'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：二分图的一个示例
- en: Bipartite graphs are useful when we need to model a relationship between two
    different classes of objects, for example, a graph of applicants and jobs, in
    which we may need to model the relationship between these two different groups;
    another example may be a bipartite graph of football players and clubs in which
    we may need to model if a player has played for a particular club or not.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要在两个不同类别的对象之间建模关系时，二分图非常有用，例如，申请人和工作的图，我们可能需要建模这两个不同组之间的关系；另一个例子可能是一个足球球员和俱乐部的二分图，我们可能需要建模一个球员是否为特定的俱乐部效力。
- en: Next, we will discuss different graph representation techniques.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论不同的图表示技术。
- en: Graph representations
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表示法
- en: A graph representation technique means how we store the graph in memory, i.e.,
    how we store the vertices, edges, and weights (if the graph is a weighted graph).
    Graphs can be represented with two methods, i.e. (1) an adjacency list, and (2)
    an adjacency matrix.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图表示技术意味着我们在内存中如何存储图，即我们如何存储顶点、边和权重（如果图是有权图）。图可以用两种方法表示，即（1）邻接表，和（2）邻接矩阵。
- en: An adjacency list representation is based on a linked list. In this, we represent
    the graph by maintaining a list of neighbors (also called an adjacent node) for
    every vertex (or node) of the graph. In an adjacency matrix representation of
    a graph, we maintain a matrix that represents which node is adjacent to which
    other node in the graph; i.e., the adjacency matrix has the information of every
    edge in the graph, which is represented by cells of the matrix.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接表表示法基于链表。在这里，我们通过为图中的每个顶点（或节点）维护一个邻居列表（也称为邻接节点）来表示图。在图的邻接矩阵表示法中，我们维护一个矩阵，表示图中哪个节点与哪个其他节点相邻；即，邻接矩阵包含图中每条边的所有信息，这些信息由矩阵的单元格表示。
- en: Either of these two representations can be used; however, our choice depends
    on the application where we will be using the graph representation. An adjacency
    list is preferable when we expect that the graph is going to be sparse and we
    will have a smaller number of edges; e.g. if a graph of 200 nodes has say 100
    edges, it is better to store this kind of graph in an adjacency list, because
    if we use an adjacency matrix, the size of the matrix will be 200x200 with a lot
    of zero values. The adjacency matrix is preferable when we expect the graph to
    have a lot of edges, and the matrix will be dense. In the adjacency matrix, the
    lookup and check for the presence or absence of an edge are very easy compared
    to adjacency list representation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种表示法都可以使用；然而，我们的选择取决于我们将要使用图表示的应用。当我们预期图将是稀疏的并且边的数量较少时，邻接表是首选；例如，如果一个有200个节点的图有大约100条边，那么将这种类型的图存储在邻接表中更好，因为如果我们使用邻接矩阵，矩阵的大小将是200x200，其中包含许多零值。当我们预期图将有大量边，并且矩阵将是密集的时，邻接矩阵是首选。在邻接矩阵中，与邻接表表示法相比，查找和检查边的存在或不存在非常容易。
- en: We will be discussing adjacency matrices in detail in subsequent sections. First,
    we will take a look at adjacency lists.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，我们将详细讨论邻接矩阵。首先，我们将查看邻接表。
- en: Adjacency lists
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接表
- en: In this representation, all the nodes directly connected to a node x are listed
    in its adjacent list of nodes. The graph is represented by displaying the adjacent
    list for all the nodes of the graph.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种表示法中，所有直接连接到节点x的节点都列在它的邻接节点列表中。通过显示图中所有节点的邻接列表来表示图。
- en: 'Two nodes, `A` and `B`, in the graph shown in *Figure 9.7*, are said to be
    adjacent if there is a direct connection between them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在图9.7中所示的图中，两个节点`A`和`B`被称为相邻的，如果它们之间存在直接连接：
- en: '![](img/B17217_09_07.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_07.png)'
- en: 'Figure 9.7: A sample graph of five nodes'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：五个节点的示例图
- en: A linked list can be used to implement the adjacency list. In order to represent
    the graph, we need the number of linked lists equal to the total number of nodes
    in the graph. At each index, the adjacent nodes to that vertex are stored. For
    example, consider the adjacency list shown in *Figure 9.8* corresponding to the
    sample graph shown in *Figure 9.7:*
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用链表来实现邻接表。为了表示图，我们需要与图中节点总数相等的链表数量。在每个索引处，存储该顶点的邻接节点。例如，考虑图9.8中所示的邻接表，对应于图9.7中所示的示例图：
- en: '![](img/B17217_09_08.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_08.png)'
- en: 'Figure 9.8: Adjacency list for the graph shown in Figure 9.7'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：图9.7中所示图的邻接表
- en: Here, the first node represents the `A` vertex of the graph, with its adjacent
    nodes being `B` and `C`. The second node represents the `B` vertex of the graph,
    with its adjacent nodes of `E`, `C`, and `A`. Similarly, the other vertices, `C`,
    `E`, and `F`, of the graph are represented with their adjacent nodes, as shown
    in the previous *Figure 9.8*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个节点代表图的`A`顶点，其邻接节点是`B`和`C`。第二个节点代表图的`B`顶点，其邻接节点是`E`、`C`和`A`。同样，图中的其他顶点`C`、`E`和`F`也用它们的邻接节点表示，如前图9.8所示。
- en: 'Using a `list` for the representation is quite restrictive, because we lack
    the ability to directly use the vertex labels. So, to implement a graph efficiently
    using Python, a `dictionary` data structure is used since it is more suitable
    to represent the graph. To implement the same graph using a dictionary data structure,
    we can use the following code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`list`进行表示相当受限，因为我们缺乏直接使用顶点标签的能力。因此，为了有效地使用Python实现图，我们使用`dictionary`数据结构，因为它更适合表示图。要使用字典数据结构实现相同的图，我们可以使用以下代码片段：
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we can easily establish that the `A` vertex has the adjacent vertices of
    `B` and `C`. The `F` vertex has the `C` vertex as its only neighbor. Similarly,
    the `B` vertex has adjacent vertices of `E`, `C`, and `A`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以轻松地确定`A`顶点有与`B`和`C`相邻的顶点。`F`顶点只有一个相邻顶点`C`。同样，`B`顶点有与`E`、`C`和`A`相邻的顶点。
- en: The adjacency list is a preferable graph representation technique when the graph
    is going to be sparse and we may need to add or delete the nodes in the graph
    frequently. However, it is very difficult to check whether a given edge is present
    in the graph or not using this technique.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当图将要变得稀疏并且我们可能需要频繁地在图中添加或删除节点时，邻接表是首选的图表示技术。然而，使用这种技术很难检查给定的边是否存在于图中。
- en: Next, we will discuss another method of graph representation, i.e., the adjacency
    matrix.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一种图表示方法，即邻接矩阵。
- en: Adjacency matrix
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: 'Another approach to representing a graph is to use an adjacency matrix. In
    this, the graph is represented by showing the nodes and their interconnections
    through edges. Using this method, the dimensions (`V x V`) of a matrix are used
    to represent the graph, where each cell denotes an edge in the graph. A matrix
    is a two-dimensional array. So, the idea here is to represent the cells of the
    matrix with a `1` or a `0`, depending on whether two nodes are connected by an
    edge or not. We show an example graph, along with its corresponding adjacency
    matrix, in *Figure 9.9*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表示图的另一种方法是使用邻接矩阵。在这种情况下，通过显示节点及其通过边相互连接的互连来表示图。使用这种方法，矩阵的维度（`V x V`）用于表示图，其中每个单元格表示图中的一个边。矩阵是一个二维数组。因此，这里的想法是根据两个节点是否通过边连接来用`1`或`0`表示矩阵的单元格。我们在*图9.9*中展示了示例图及其相应的邻接矩阵：
- en: '![](img/B17217_09_09.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_09.png)'
- en: 'Figure 9.9: Adjacency matrix for a given graph'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：给定图的邻接矩阵
- en: 'An adjacency matrix can be implemented using the given adjacency list. To implement
    the adjacency matrix, let’s take the previous dictionary-based implementation
    of the graph. Firstly, we have to obtain the key elements of the adjacency matrix.
    It is important to note that these matrix elements are the vertices of the graph.
    We can get the key elements by sorting the keys of the graph. The code snippet
    for this is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用给定的邻接表实现邻接矩阵。要实现邻接矩阵，让我们先从基于字典的图实现中获取邻接矩阵的关键元素。需要注意的是，这些矩阵元素是图中的顶点。我们可以通过排序图的键来获取关键元素。相应的代码片段如下：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, the length of the keys of the graph will be the dimensions of the adjacency
    matrix, which are stored in `cols` and `rows`. The values of the `cols` and `rows`
    are equal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，图的键的长度将是邻接矩阵的维度，这些维度存储在`cols`和`rows`中。`cols`和`rows`的值是相等的。
- en: 'So, now, we create an empty adjacency matrix of the dimensions `cols` by `rows`,
    initially filling all the values with zeros. The code snippet to initialize an
    empty adjacency matrix is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们创建一个空的邻接矩阵，其维度为`cols`乘以`rows`，初始时所有值都填充为零。初始化空邻接矩阵的代码片段如下：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `edges_list` variable will store the tuples that form the edges in the
    graph. For example, an edge between the A and B nodes will be stored as (`A`,
    `B`). The multidimensional array is filled using a nested `for` loop:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`edges_list`变量将存储构成图中边的元组。例如，A节点和B节点之间的边将被存储为（`A`，`B`）。多维数组使用嵌套的`for`循环填充：'
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The neighbors of a vertex are obtained by `graph[key]`. The key, in combination
    with the `neighbor`, is then used to create the tuple stored in `edges_list`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`graph[key]`获取顶点的相邻顶点。然后，使用`neighbor`与键结合来创建存储在`edges_list`中的元组。
- en: 'The output of the preceding Python code for storing the edges of the graph
    is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 存储图边的先前Python代码的输出如下：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step in implementing the adjacency matrix is to fill it, using `1`
    to denote the presence of an edge in the graph. This can be done with the `adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1` statement. The full code snippet that marks the presence of edges of the
    graph is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实现邻接矩阵的下一步是填充它，使用`1`表示图中存在边。这可以通过`adjacency_matrix[index_of_first_vertex][index_of_second_vertex]
    = 1`语句来完成。标记图中边存在的完整代码片段如下：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `matrix_elements` array has its `rows` and `cols`, starting from `A` to
    all other vertices with indices of `0` to `5`. The `for` loop iterates through
    the list of tuples and uses the `index` method to get the corresponding index
    where an edge is to be stored.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix_elements`数组有它的`rows`和`cols`，从`A`开始到所有其他顶点，索引为`0`到`5`。`for`循环遍历元组列表，并使用`index`方法获取存储边的对应索引。'
- en: 'The output of the preceding code is the adjacency matrix for the sample graph
    shown previously in *Figure 9.9*. The adjacency matrix produced looks like the
    following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码的输出是之前在*图9.9*中显示的示例图的邻接矩阵。生成的邻接矩阵看起来如下：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At row `1` and column `1`, `0` represents the absence of an edge between **A**
    and **A**. Similarly, at row `3` and column `2` there is a value of `1` that denotes
    the edge between the **C** and **B** vertices in the graph.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`1`和列`1`，`0`表示图中**A**和**A**之间没有边。同样，在行`3`和列`2`有一个值为`1`，表示图中**C**和**B**顶点之间的边。
- en: The use of the adjacency matrix for graph representation is suitable when we
    have to frequently look up and check the presence or absence of an edge between
    two nodes in the graph, e.g. in creating routing tables in networks, searching
    routes in public transport applications and navigation systems, etc. Adjacency
    matrices are not suitable when nodes are frequently added or deleted within a
    graph, in those situations, the adjacency list is a better technique.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要频繁地查找和检查图中两个节点之间是否存在边时，使用邻接矩阵来表示图是合适的，例如在创建网络中的路由表、在公共交通应用和导航系统中搜索路线等。当节点在图中频繁添加或删除时，邻接矩阵不适合，在这些情况下，邻接表是一种更好的技术。
- en: Next, let us discuss different graph traversal methods in which we visit all
    the nodes of the given graph.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论不同的图遍历方法，这些方法将遍历给定图的所有节点。
- en: Graph traversals
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图遍历
- en: A graph traversal means to visit all the vertices of the graph while keeping
    track of which nodes or vertices have already been visited and which ones have
    not. A graph traversal algorithm is efficient if it traverses all the nodes of
    the graph in the minimum possible time. Graph traversal, also known as a graph
    search algorithm, is quite similar to the tree traversal algorithms like `preorder`,
    `inorder`, `postorder`, and level order algorithms; similar to them, in a graph
    search algorithm we start with a node and traverse through edges to all other
    nodes in the graph.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图遍历意味着在访问图的所有顶点的同时，跟踪哪些节点或顶点已经被访问过，哪些还没有。如果一个图遍历算法能够在最短的时间内遍历图中的所有节点，那么它就是高效的。图遍历，也称为图搜索算法，与像`preorder`、`inorder`、`postorder`和层次遍历算法等树遍历算法非常相似；与它们类似，在图搜索算法中，我们从节点开始，通过边遍历图中的所有其他节点。
- en: A common strategy of graph traversal is to follow a path until a dead end is
    reached, then traverse back up until there is a point where we meet an alternative
    path. We can also iteratively move from one node to another in order to traverse
    the full graph or part of it. Graph traversal algorithms are very important in
    answering many fundamental problems—they can be useful to determine how to get
    from one vertex to another in a graph, and which path from **A** node to **B**
    node in a graph is better than other paths. For example, graph traversal algorithms
    can be useful in finding out the shortest route from one city to another in a
    network of cities.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图遍历的一个常见策略是沿着路径前进，直到达到死胡同，然后回溯直到遇到替代路径的点。我们也可以迭代地从节点移动到另一个节点，以遍历整个图或其部分。图遍历算法在解决许多基本问题中非常重要——它们可以用来确定如何在图中从一个顶点到达另一个顶点，以及图中从**A**节点到**B**节点的路径比其他路径更好。例如，图遍历算法在找出城市网络中从一个城市到另一个城市最短路径时非常有用。
- en: 'In the next section, we will discuss two important graph traversal algorithms:
    **breadth-first search** (**BFS**) and **depth-first search** (**DFS**).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论两个重要的图遍历算法：**广度优先搜索**（**BFS**）和**深度优先搜索**（**DFS**）。
- en: Breadth-first traversal
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广度优先遍历
- en: '**Breadth-first search** (**BFS**) works very similarly to how a level order
    traversal algorithm works in a tree data structure. The BFS algorithm also works
    level by level; it starts by visiting the root node at level 0, and then all the
    nodes at the first level directly connected to the root node are visited at level
    1\. The level 1 node has a distance of 1 from the root node. After visiting all
    the nodes at level 1, the level 2 nodes are visited next. Likewise, all the nodes
    in the graph are traversed level by level until all the nodes are visited. So,
    breadth-first traversal algorithms work breadthwise in the graph.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**广度优先搜索**（**BFS**）在树数据结构中与层序遍历算法的工作方式非常相似。BFS算法也是按层工作的；它从访问层0的根节点开始，然后访问与根节点直接相连的第一层的所有节点。层1的节点与根节点的距离为1。访问完层1的所有节点后，接下来访问层2的节点。同样，图中的所有节点都是按层遍历，直到所有节点都被访问。因此，广度优先遍历算法在图中按广度工作。'
- en: A queue data structure is used to store the information of vertices that are
    to be visited in a graph. We begin with the starting node. Firstly, we visit that
    node, and then we look up all of its neighboring, or adjacent, vertices. We first
    visit these adjacent vertices one by one, while adding their neighbors to the
    list of vertices that are to be visited. We follow this process until we have
    visited all the vertices of the graph, ensuring that no vertex is visited twice.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 队列数据结构用于存储图中要访问的顶点信息。我们从起始节点开始。首先，我们访问该节点，然后查找所有相邻的或相邻的顶点。我们首先逐个访问这些相邻顶点，同时将它们的邻居添加到要访问的顶点列表中。我们遵循这个过程，直到访问了图中的所有顶点，确保没有顶点被访问两次。
- en: 'Let’s consider an example to better understand the working of the breadth-first
    traversal for graphs, using the sample shown in *Figure 9.10*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，以更好地理解图广度优先遍历的工作原理，使用*图9.10*中的示例：
- en: '![](img/B17217_09_10.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_10.png)'
- en: 'Figure 9.10: A sample graph'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：一个示例图
- en: In *Figure 9.10*, we have a graph of five nodes on the left, and on the right,
    a queue data structure to store the vertices to be visited. We start visiting
    the first node, i.e., **A** node, and then we add all its adjacent vertices, **B**,
    **C**, and **E**, to the queue. Here, it is important to note that there are multiple
    ways of adding the adjacent nodes to the queue since there are three nodes, **B**,
    **C**, and **E**, that can be added to the queue as either **BCE**, **CEB**, **CBE**,
    **BEC**, or **ECB**, each of which would give us different tree traversal results.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图9.10*中，我们有一个左边的五个节点的图，右边是一个队列数据结构，用于存储要访问的顶点。我们开始访问第一个节点，即**A**节点，然后我们将所有相邻的顶点**B**、**C**和**E**添加到队列中。在这里，重要的是要注意，由于有三个节点**B**、**C**和**E**可以按**BCE**、**CEB**、**CBE**、**BEC**或**ECB**的顺序添加到队列中，每种顺序都会给出不同的树遍历结果，因此添加相邻节点到队列的方式有多种。
- en: 'All of these possible solutions to the graph traversal are correct, but in
    this example, we add the nodes in alphabetical order just to keep things simple
    in the queue, i.e., **BCE**. The **A** node is visited as shown in *Figure 9.11*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些图遍历的可能解决方案都是正确的，但在这个例子中，我们按字母顺序添加节点，只是为了使队列中的事情简单，即**BCE**。**A**节点访问如图*图9.11*所示：
- en: '![](img/B17217_09_11.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_11.png)'
- en: 'Figure 9.11: Node A is visited in breadth-first traversal'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：在广度优先遍历中访问节点A
- en: 'Once we have visited the **A** vertex, next, we visit its first adjacent vertex,
    **B**, and add those adjacent vertices of vertex **B** that are not already added
    in the queue or not visited. In this case, we have to add the **D** vertex (since
    it has two vertices, **A** and **D** nodes, out of which **A** is already visited)
    to the queue, as shown in *Figure 9.12*:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们访问了**A**顶点，接下来，我们访问它的第一个相邻顶点，**B**，并将顶点**B**的相邻顶点添加到队列中，这些顶点尚未添加到队列或尚未访问。在这种情况下，我们必须将**D**顶点（因为它有两个顶点，**A**和**D**节点，其中**A**已经访问过）添加到队列中，如图*图9.12*所示：
- en: '![](img/B17217_09_12.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_12.png)'
- en: 'Figure 9.12: Node B is visited in breadth-first traversal'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：在广度优先遍历中访问节点B
- en: 'Now, after visiting the **B** vertex, we visit the next vertex from the queue—the
    **C** vertex. And again, add those adjacent vertices that have not already been
    added to the queue. In this case, there are no unrecorded vertices left, as shown
    in *Figure 9.13*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在访问了**B**顶点之后，我们从队列中访问下一个顶点——**C**顶点。再次，将那些尚未添加到队列中的相邻顶点添加进去。在这种情况下，没有未记录的顶点剩下，如图*图9.13*所示：
- en: '![](img/B17217_09_13.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_13.png)'
- en: 'Figure 9.13: Node C is visited in breadth-first traversal'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：在广度优先遍历中访问节点C
- en: 'After visiting the **C** vertex, we visit the next vertex from the queue, the
    **E** vertex, as shown in *Figure 9.14*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问**C**顶点之后，我们从队列中访问下一个顶点，即**E**顶点，如图*图9.14*所示：
- en: '![](img/B17217_09_14.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_14.png)'
- en: 'Figure 9.14: Node E is visited in breadth-first traversal'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：在广度优先遍历中访问节点E
- en: 'Similarly, after visiting the **E** vertex, we visit the **D** vertex in the
    last step, as shown in *Figure 9.15*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在访问**E**顶点之后，我们在最后一步访问**D**顶点，如图*图9.15*所示：
- en: '![](img/B17217_09_15.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_15.png)'
- en: 'Figure 9.15: D node is visited in breadth-first traversal'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：在广度优先遍历中访问D节点
- en: Therefore, the BFS algorithm for traversing the preceding graph visits the vertices
    in the order of **A-B-C-E-D**. This is one of the possible solutions to the BFS
    traversal for the preceding graph, but we can get many possible solutions, depending
    on how we add the adjacent nodes to the queue.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，遍历前述图的BFS算法按**A-B-C-E-D**的顺序访问顶点。这是前述图BFS遍历的一个可能解，但我们可以得到许多可能的解，这取决于我们如何将相邻节点添加到队列中。
- en: 'To understand the implementation of this algorithm in Python, we will use another
    example of an undirected graph, as shown in *Figure 9.16*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Python中此算法的实现，我们将使用另一个无向图的示例，如图*图9.16*所示：
- en: '![](img/B17217_09_16.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_16.png)'
- en: 'Figure 9.16: An undirected sample graph'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16：一个无向样本图
- en: 'The adjacency list for the graph shown in *Figure 9.16* is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.16*中所示图的邻接表如下：'
- en: '[PRE7]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After storing the graph using the adjacency list, the implementation of the
    BFS algorithm is as follows, which we will discuss with an example in detail:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用邻接表存储图之后，BFS算法的实现如下，我们将通过一个示例详细讨论：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To traverse this graph using the breadth-first algorithm, we first initialize
    the queue and the source node. We start traversal from **A** node. Firstly, **A**
    node is queued and added to the list of visited nodes. Afterward, we use a `while`
    loop to affect the traversal of the graph. In the first iteration of the `while`
    loop, node A is dequeued.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用广度优先算法遍历此图，我们首先初始化队列和源节点。我们从**A**节点开始遍历。首先，**A**节点被入队并添加到已访问节点列表中。之后，我们使用`while`循环来影响图的遍历。在`while`循环的第一次迭代中，节点A被出队。
- en: 'Next, all the unvisited adjacent nodes of **A** node, which are **B**, **D**,
    and **G**, are sorted in alphabetical order and queued up. The queue now contains
    nodes **B**, **D**, and **G**. This is shown in *Figure 9.17*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将**A**节点的所有未访问相邻节点（**B**、**D**和**G**）按字母顺序排序并排队。此时，队列包含节点**B**、**D**和**G**。这如图*图9.17*所示：
- en: '![](img/B17217_09_17.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_17.png)'
- en: 'Figure 9.17: Node A is visited using the BFS algorithm'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：使用BFS算法访问节点A
- en: For implementation, we add all these nodes (**B**, **D**, **G**) to the list
    of visited nodes, and then we add the adjacent/neighboring nodes of these nodes.
    At this point, we start another iteration of the `while` loop. After visiting
    **A** node, **B** node is dequeued. Out of its adjacent nodes (**A**, **E**, and
    **F**), **A** node has already been visited. Therefore, we only queue the **E**
    and **F** nodes in alphabetical order, as shown in *Figure 9.18*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实现，我们将所有这些节点（**B**、**D**、**G**）添加到已访问节点列表中，然后添加这些节点的相邻/邻近节点。此时，我们开始`while`循环的另一个迭代。在访问**A**节点后，**B**节点被出队。在其相邻节点（**A**、**E**和**F**）中，**A**节点已经访问过。因此，我们只按字母顺序将**E**和**F**节点入队，如图*图9.18*所示。
- en: 'When we want to find out whether a set of nodes is in the list of visited nodes,
    we use the `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`
    statement. This uses the `set` object’s `difference` method to find the nodes
    that are in `adj_nodes`, but not in `visited_vertices`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要找出是否有一组节点在已访问节点的列表中时，我们使用`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`语句。这使用`set`对象的`difference`方法来找出在`adj_nodes`中但不在`visited_vertices`中的节点：
- en: '![](img/B17217_09_18.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_18.png)'
- en: 'Figure 9.18: Node B is visited using the BFS algorithm'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18：使用BFS算法访问节点B
- en: 'The queue now holds the following nodes at this point—**D**, **G**, **E**,
    and **F**. The **D** node is dequeued, but all of its adjacent nodes have been
    visited, so we simply dequeue it. The next node at the front of the queue is **G**.
    We dequeue the **G** node, but we also find out that all its adjacent nodes have
    been visited because they are in the list of visited nodes. So, the **G** node
    is also dequeued. We dequeue the **E** node too because all of its adjacent nodes
    have also been visited. The only node in the queue now is the **F** node; this
    is shown in *Figure 9.19*:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，队列中包含以下节点—**D**、**G**、**E**和**F**。**D**节点被出队，但所有相邻的节点都已被访问，所以我们只需简单地出队它。队列前面的下一个节点是**G**。我们出队**G**节点，但我们还发现所有相邻的节点都已被访问，因为它们在已访问节点的列表中。因此，**G**节点也被出队。我们也出队**E**节点，因为所有相邻的节点也都已被访问。现在队列中只剩下一个**F**节点；这如图9.19所示：
- en: '![](img/B17217_09_19.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_19.png)'
- en: 'Figure 9.19: Node E is visited using the BFS algorithm'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19：使用BFS算法访问节点E
- en: 'The **F** node is dequeued, and we see that out of its adjacent nodes, **B**,
    **D**, and **C**, only **C** has not been visited. We then enqueue the **C** node
    and add it to the list of visited nodes, as shown in *Figure 9.20*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**F**节点被出队，我们看到在其相邻节点中，**B**、**D**和**C**，只有**C**未被访问。然后我们将**C**节点入队并添加到已访问节点的列表中，如图9.20所示：'
- en: '![](img/B17217_09_20.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_20.png)'
- en: 'Figure 9.20: Node E is visited using the BFS algorithm'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20：使用BFS算法访问节点E
- en: Then, the **C** node is dequeued. **C** has the adjacent nodes of **F** and
    **H**, but **F** has already been visited, leaving the **H** node. The **H** node
    is enqueued and added to the list of visited nodes. Finally, the last iteration
    of the `while` loop will lead to the **H** node being dequeued.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，**C**节点被出队。**C**有**F**和**H**的相邻节点，但**F**已经被访问，只剩下**H**节点。**H**节点被入队并添加到已访问节点的列表中。最后，`while`循环的最后一次迭代将导致**H**节点被出队。
- en: 'Its only adjacent node, **C**, has already been visited. Once the queue is
    empty, the loop breaks. This is shown in *Figure 9.21*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它的唯一相邻节点**C**已经被访问。一旦队列变为空，循环就会中断。这如图9.21所示：
- en: '![](img/B17217_09_21.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_09_21.png)'
- en: 'Figure 9.21: Final node H is visited using the BFS algorithm'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21：使用BFS算法访问最终节点H
- en: The output of the traversal of the given graph using the BFS algorithm is **A**,
    **B**, **D**, **G**, **E**, **F**, **C**, and **H**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BFS算法遍历给定图的输出是**A**、**B**、**D**、**G**、**E**、**F**、**C**和**H**。
- en: 'When we run the above BFS code on the graph shown in *Figure 9.16* using the
    following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用以下代码在*图9.16*中显示的图上运行上述BFS代码时：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We get the following sequence of nodes when we traverse the graph shown in
    *Figure 9.16*:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历*图9.16*中显示的图时，我们得到以下节点序列：
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the worst-case scenario, each node and the edge will need to be traversed,
    and hence each node will be enqueued and dequeued at least once. The time taken
    for each enqueue and dequeue operation is O(1), so the total time for this is
    O(V). Further, the time spent scanning the adjacency list for every vertex is
    O(E). So, the total time complexity of the BFS algorithm is `O(|V| + |E|)`, where
    `|V|` is the number of vertices or nodes, while `|E|` is the number of edges in
    the graph.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，每个节点和边都需要被遍历，因此每个节点至少会被入队和出队一次。每次入队和出队操作的时间复杂度是O(1)，所以总的时间复杂度是O(V)。此外，扫描每个顶点的邻接表的时间复杂度是O(E)。因此，BFS算法的总时间复杂度是`O(|V|
    + |E|)`，其中`|V|`是顶点或节点的数量，而`|E|`是图中边的数量。
- en: The BFS algorithm is very useful for constructing the shortest path traversal
    in a graph with minimal iterations. As for some of the real-world applications
    of BFS, it can be used to create an efficient web crawler in which multiple levels
    of indexes can be maintained for search engines, and it can maintain a list of
    closed web pages from a source web page. BFS can also be useful for navigation
    systems in which neighboring locations can be easily retrieved from a graph of
    different locations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: BFS算法对于在图中以最少的迭代次数构建最短路径遍历非常有用。至于BFS的一些实际应用，它可以用来创建一个高效的网页爬虫，其中可以为搜索引擎维护多个级别的索引，并且可以维护从源网页开始的已关闭网页列表。BFS还可以用于导航系统，其中可以从不同位置的图中轻松检索相邻位置。
- en: Next, we will discuss another graph traversal algorithm, i.e., the depth-first
    search algorithm.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一个图遍历算法，即深度优先搜索算法。
- en: Depth-first search
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: As the name suggests, the **depth-first search** (**DFS**) or traversal algorithm
    traverses the graph similar to how the `preorder` traversal algorithm works in
    trees. In the DFS algorithm, we traverse the tree in the depth of any particular
    path in the graph. As such, child nodes are visited first before sibling nodes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，**深度优先搜索**（**DFS**）或遍历算法遍历图的方式类似于树中的`前序遍历`算法的工作方式。在DFS算法中，我们在图中任何特定路径的深度中遍历树。因此，在遍历兄弟节点之前，先访问子节点。
- en: In this, we start with the root node; firstly we visit it, and then we see all
    the adjacent vertices of the current node. We start visiting one of the adjacent
    nodes. If the edge leads to a visited node, we backtrack to the current node.
    And, if the edge leads to an unvisited node, then we go to that node and continue
    processing from that node. We continue the same process until we reach a dead
    end when there is no unvisited node; in that case, we backtrack to previous nodes,
    and we stop when we reach the root node while backtracking.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，我们从根节点开始；首先访问它，然后查看当前节点的所有相邻顶点。我们开始访问其中一个相邻节点。如果边通向一个已访问的节点，我们就回溯到当前节点。如果边通向一个未访问的节点，那么我们就前往那个节点并从那个节点继续处理。我们继续这个过程，直到达到一个死胡同，即没有未访问的节点；在这种情况下，我们回溯到前面的节点，并在回溯过程中停止，当我们达到根节点时。
- en: 'Let’s take an example to understand the working of the DFS algorithm using
    the graph shown in *Figure 9.22*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过图9.22中所示图例来举例说明DFS算法的工作原理：
- en: '![](img/B17217_09_22.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_22.png)'
- en: 'Figure 9.22: An example graph for understanding the DFS algorithm'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22：用于理解DFS算法的示例图
- en: 'We start by visiting the **A** node, and then we look at the neighbors of the
    **A** vertex, then a neighbor of that neighbor, and so on. After visiting the
    **A** vertex, we visit one of its neighbors, **B** (in our example, we sort alphabetically;
    however, any neighbor can be added), as shown in *Figure 9.23*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先访问**A**节点，然后查看**A**顶点的邻居，然后是那个邻居的邻居，依此类推。在访问**A**顶点后，我们访问其一个邻居**B**（在我们的例子中，我们按字母顺序排序；然而，任何邻居都可以添加），如图9.23所示：
- en: '![](img/B17217_09_23.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_23.png)'
- en: 'Figure 9.23: Nodes A and B are visited in depth-first traversal'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23：在深度优先遍历中访问节点A和B
- en: 'After visiting the **B** vertex, we look at another neighbor of **A**, that
    is, **S**, as there is no vertex connected to **B** that can be visited. Next,
    we look for the neighbors of the **S** vertex, which are the **C** and **G** vertices.
    We visit **C** as shown in *Figure 9.24*:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问**B**顶点后，我们查看**A**的另一个邻居，即**S**，因为没有顶点连接到**B**可以访问。接下来，我们查找**S**顶点的邻居，它们是**C**和**G**顶点。我们按照图9.24所示访问**C**：
- en: '![](img/B17217_09_24.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_24.png)'
- en: 'Figure 9.24: Node C is visited in depth-first traversal'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24：在深度优先遍历中访问节点C
- en: 'After visiting the **C** node, we visit its neighboring vertices, **D** and
    **E**, as shown in *Figure 9.25*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问**C**节点后，我们访问其相邻顶点**D**和**E**，如图9.25所示：
- en: '![](img/B17217_09_25.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_25.png)'
- en: 'Figure 9.25: D and E nodes are visited in depth-first traversal'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25：在深度优先遍历中访问节点D和E
- en: 'Similarly, after visiting the **E** vertex, we visit the **H** and **G** vertices,
    as shown in *Figure 9.26*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在访问**E**顶点之后，我们访问**H**和**G**顶点，如图9.26所示：
- en: '![](img/B17217_09_26.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_26.png)'
- en: 'Figure 9.26: H and F nodes are visited in depth-first traversal'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26：在深度优先遍历中访问节点H和F
- en: 'Finally, we visit the **F** node, as shown in *Figure 9.27*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们访问**F**节点，如图9.27所示：
- en: '![](img/B17217_09_27.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_27.png)'
- en: 'Figure 9.27: F node is visited in depth-first traversal'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27：在深度优先遍历中访问节点F
- en: The output of the DFS traversal is **A-B-S-C-D-E-H-G-F**.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DFS遍历的输出为**A-B-S-C-D-E-H-G-F**。
- en: 'To implement DFS, we start with the adjacency list of the given graph. Here
    is the adjacency list of the preceding graph:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现DFS，我们从给定图的邻接表开始。以下是前面图的邻接表：
- en: '[PRE11]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The implementation of the DFS algorithm begins with creating a list to store
    the visited nodes. The `graph_stack` stack variable is used to aid the traversal
    process. We are using a Python list as a stack.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: DFS算法的实现首先创建一个列表来存储已访问的节点。`graph_stack`栈变量用于辅助遍历过程。我们使用Python列表作为栈。
- en: 'The starting node, called `root`, is passed with the graph’s adjacency matrix,
    `graph`. Firstly, the `root` is pushed onto the stack. The statement `node = root`
    is for holding the first node in the stack:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 起始节点，称为`root`，与图的邻接矩阵`graph`一起传递。首先，将`root`压入栈中。语句`node = root`是为了在栈中保留第一个节点：
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The body of the `while` loop will be executed, provided the stack is not empty.
    If the `node` under consideration is not in the list of visited nodes, we add
    it. All adjacent nodes of `node` are collected by `adj_nodes = graph[node]`. If
    all the adjacent nodes have been visited, we pop the top node from the stack and
    set `node` to `graph_stack[-1]`. Here, `graph_stack[-1]` is the top node on the
    stack. The `continue` statement jumps back to the beginning of the `while` loop’s
    test condition.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当栈不为空时，将执行`while`循环的主体。如果正在考虑的`node`不在已访问节点的列表中，我们将它添加进去。通过`adj_nodes = graph[node]`收集`node`的所有相邻节点。如果所有相邻节点都已访问，则从栈中弹出顶部节点，并将`node`设置为`graph_stack[-1]`。在这里，`graph_stack[-1]`是栈顶的节点。`continue`语句将跳回到`while`循环测试条件的开始。
- en: If, on the other hand, not all the adjacent nodes have been visited, then the
    nodes that are yet to be visited are obtained by finding the difference between
    the `adj_nodes` and `visited_vertices` with the `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`
    statement.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是所有相邻的节点都已被访问，那么尚未访问的节点将通过使用`remaining_elements = set(adj_nodes).difference(set(visited_vertices))`语句来找到`adj_nodes`和`visited_vertices`之间的差异来获得。
- en: The first item within `sorted(remaining_elements)` is assigned to `first_adj_node`,
    and pushed onto the stack. We then point the top of the stack to this node.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted(remaining_elements)`中的第一个项目被分配给`first_adj_node`，并推入栈中。然后我们将栈顶指向此节点。'
- en: When the `while` loop exits, we will return `visited_vertices`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当`while`循环退出时，我们将返回`visited_vertices`。
- en: 'We will now explain the working of the source code by relating it to the previous
    example. The **A** node is chosen as our starting node. **A** is pushed onto the
    stack and added to the `visited_vertices` list. In doing so, we mark it as having
    been visited. The `graph_stack` stack is implemented with a simple Python list.
    Our stack now has **A** as its only element. We examine the **A** node’s adjacent
    nodes, **B** and **S**. To test whether all the adjacent nodes of **A** have been
    visited, we use the `if` statement:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过关联先前的示例来解释源代码的工作原理。我们选择**A**节点作为起始节点。**A**被推入栈中，并添加到`visited_vertices`列表中。这样做时，我们将其标记为已访问。`graph_stack`栈使用简单的Python列表实现。我们的栈现在只有**A**作为其唯一元素。我们检查**A**节点的相邻节点，**B**和**S**。为了测试**A**的所有相邻节点是否都已访问，我们使用`if`语句：
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If all the nodes have been visited, we pop the top of the stack. If the `graph_stack`
    stack is not empty, we assign the node on top of the stack to `node`, and start
    the beginning of another execution of the body of the `while` loop. The `set(adj_nodes).issubset(set(visited_vertices))`
    statement will evaluate to `True` if all the nodes in `adj_nodes` are a subset
    of `visited_vertices`. If the `if` statement fails, it means that some nodes remain
    to be visited. We obtain that list of nodes with `remaining_elements = set(adj_nodes).difference(set(visited_vertices))`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有节点都已访问，则弹出栈顶。如果`graph_stack`栈不为空，则将栈顶的节点分配给`node`，并开始另一个`while`循环主体的执行。如果`set(adj_nodes).issubset(set(visited_vertices))`语句评估为`True`，则表示`adj_nodes`中的所有节点都是`visited_vertices`的子集。如果`if`语句失败，则表示还有一些节点尚未访问。我们使用`remaining_elements
    = set(adj_nodes).difference(set(visited_vertices))`来获取该节点列表。
- en: 'Referring to the diagram, the **B** and **S** nodes will be stored in `remaining_elements`.
    We will access the list in alphabetical order as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图示，**B**和**S**节点将被存储在`remaining_elements`中。我们将按以下顺序按字母顺序访问列表：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We sort `remaining_elements` and return the first node to `first_adj_node`.
    This will return **B**. We push the **B** node onto the stack by appending it
    to the `graph_stack`. We prepare the **B** node for access by assigning it to
    `node`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`remaining_elements`进行排序，并将第一个节点返回到`first_adj_node`。这将返回**B**。我们将**B**节点推入栈中，通过将其附加到`graph_stack`。我们通过将其分配给`node`来准备**B**节点以供访问。
- en: On the next iteration of the `while` loop, we add the **B** node to the list
    of `visited nodes`. We discover that the only adjacent node to **B**, which is
    **A**, has already been visited. Because all the adjacent nodes of **B** have
    been visited, we pop it off the stack, leaving **A** as the only element on the
    stack. We return to **A** and examine whether all of its adjacent nodes have been
    visited. The **A** node now has **S** as the only unvisited node. We push **S**
    to the stack and begin the whole process again.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的下一迭代中，我们将**B**节点添加到已访问节点的列表中。我们发现**B**的唯一相邻节点是**A**，它已经被访问过。因为**B**的所有相邻节点都已访问过，所以我们将其从栈中弹出，留下**A**作为栈上的唯一元素。我们回到**A**并检查其所有相邻节点是否都已访问过。现在**A**节点唯一的未访问节点是**S**。我们将**S**推入栈中，并再次开始整个过程。
- en: The output of the traversal is `A-B-S-C-D-E-H-G-F`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历的输出结果是 `A-B-S-C-D-E-H-G-F`。
- en: The time complexity of DFS is O(V+E) when we use an adjacency list, and O(V²)
    when we use an adjacency matrix for graph representation. The time complexity
    of DFS with the adjacency list is lower because getting the adjacent nodes is
    easier, whereas it is not efficient with the adjacency matrix.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用邻接表表示图时，DFS的时间复杂度是O(V+E)，当我们使用邻接矩阵表示图时，时间复杂度是O(V²)。使用邻接表进行DFS的时间复杂度较低，因为获取相邻节点更容易，而使用邻接矩阵则不太高效。
- en: DFS can be applied to solving maze problems, finding connected components, cycle
    detection in graphs, and finding the bridges of a graph, among other use cases.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: DFS可以应用于解决迷宫问题、查找连通分量、图中检测循环以及查找图的桥，以及其他用例。
- en: We have discussed very important graph traversal algorithms; now let us discuss
    some more useful graph-related algorithms for finding the spanning tree from the
    given graph. Spanning trees are useful for several real-world problems such as
    the traveling salesman problem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了非常重要的图遍历算法；现在让我们讨论一些更有用的图相关算法，用于从给定的图中找到生成树。生成树在解决旅行商问题等几个现实世界问题中非常有用。
- en: Other useful graph methods
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他有用的图方法
- en: It is very often that we need to use graphs for finding a path between two nodes.
    Sometimes, it is necessary to find all the paths between nodes, and in some situations,
    we might need to find the shortest path between nodes. For example, in routing
    applications, we generally use various algorithms to determine the shortest path
    from the source node to the destination node. For an unweighted graph, we would
    simply determine the path with the lowest number of edges between them. If a weighted
    graph is given, we have to calculate the total weight of passing through a set
    of edges.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要使用图来在两个节点之间找到路径。有时，我们需要找到节点之间的所有路径，在某些情况下，我们可能需要找到节点之间的最短路径。例如，在路由应用中，我们通常使用各种算法来确定从源节点到目标节点的最短路径。对于无权图，我们只需确定它们之间边数最少的路径。如果给定的是加权图，我们必须计算通过一组边的总权重。
- en: Thus, in a different situation, we may have to find the longest or shortest
    path using different algorithms, such as a **Minimum Spanning Tree**, which we
    look into in the next section.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不同的情境下，我们可能需要使用不同的算法来找到最长或最短路径，例如**最小生成树**，我们将在下一节中探讨。
- en: Minimum Spanning Tree
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小生成树
- en: A **Minimum Spanning Tree** (**MST**) is a subset of the edges of the connected
    graph with an edge-weighted graph that connects all the nodes of the graph, with
    the lowest possible total edge weights and no cycle. More formally, given a connected
    graph G, where G = (V, E) with real-valued edge weights, an MST is a subgraph
    with a subset of the edges ![](img/B17217_09_001.png) so that the sum of edge
    weights is minimum and there is no cycle. There are many possible spanning trees
    that can connect all the nodes of the graph without any cycle, but the the minimum
    weight spanning tree is a spanning tree that has the lowest total edge weight
    (also called cost) among all other possible spanning trees. An example graph is
    shown in *Figure 9.28* along with its corresponding MST (on the right) in which
    we can observe that all the nodes are connected and have a subset of edges taken
    from the original graph (on the left).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小生成树**（**MST**）是连通图中边的子集，它通过带权重的图连接图中的所有节点，具有最低可能的总边权重且没有环。更正式地说，给定一个连通图G，其中G
    = (V, E)具有实值边权重，MST是一个子图，其边子集 ![](img/B17217_09_001.png) 使得边权重的总和最小且没有环。有许多可能的生成树可以连接图中的所有节点而不形成任何环，但最小权重生成树是所有其他可能生成树中具有最低总边权重（也称为成本）的生成树。一个示例图如图9.28所示，以及其对应的MST（在右侧），我们可以观察到所有节点都是连接的，并且从原始图（在左侧）中选取了边的子集。'
- en: 'The MST has the lowest total weight of all the edges, i.e. (1+4+2+4+5 = 16)
    among all the other possible spanning trees:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树具有所有边中最低的总权重，即（1+4+2+4+5 = 16），在所有其他可能的生成树中：
- en: '![](img/B17217_09_28.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_28.png)'
- en: 'Figure 9.28: A sample graph with the corresponding Minimum Spanning Tree'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28：一个示例图及其对应的最低生成树
- en: The MST has diverse real-world applications. They are mainly used in network
    design for road congestion, hydraulic cables, electric cable networks, and even
    cluster analysis.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最小生成树在现实世界中有着多种应用。它们主要用于网络设计，如道路拥堵、液压电缆、电力电缆网络，甚至聚类分析。
- en: First, let us discuss Kruskal’s minimum spanning tree algorithm.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论克鲁斯卡尔最小生成树算法。
- en: Kruskal’s Minimum Spanning Tree algorithm
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔最小生成树算法
- en: 'Kruskal’s algorithm is a widely used algorithm for finding the spanning tree
    from a given weighted, connected, and undirected graph. It is based on the greedy
    approach, as we firstly find the edge with the lowest weight and add it to the
    tree, and then in each iteration, we add the edge with the lowest weight to the
    spanning tree so that we do not form a cycle. In this algorithm, initially, we
    treat all the vertices of the graph as a separate tree, and then in each iteration
    we select edge with the lowest weight in such a way that it does not form a cycle.
    These separate trees are combined, and it grows to form a spanning tree. We repeat
    this process until all the nodes are processed. The algorithm works as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔算法是一种广泛使用的算法，用于从给定的加权、连通且无向图中找到生成树。它基于贪婪算法，因为我们首先找到权重最低的边并将其添加到树中，然后在每次迭代中，我们将权重最低的边添加到生成树中，以防止形成环。在这个算法中，最初，我们将图的所有顶点视为单独的树，然后在每次迭代中，我们选择权重最低的边，使其不形成环。这些单独的树被组合起来，逐渐形成一个生成树。我们重复这个过程，直到所有节点都被处理。算法的工作原理如下：
- en: Initialize an empty MST (M) with zero edges
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个包含零边的空MST（M）
- en: Sort all the edges according to their weights
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照它们的权重对所有边进行排序
- en: For each edge from the sorted list, we add them one by one to the MST (M) in
    such a way that it does not form a cycle
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于排序列表中的每条边，我们依次将它们添加到MST（M）中，使其不形成环
- en: Let’s consider an example.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。
- en: 'We start by selecting the edge with the lowest weight (weight 1), as represented
    by the dotted line shown in *Figure 9.29*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先选择权重最低的边（权重1），如图9.29中所示虚线所示：
- en: '![](img/B17217_09_29.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_29.png)'
- en: 'Figure 9.29: Selecting the first edge with the lowest weight in the spanning
    tree'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29：在生成树中选择权重最低的第一条边
- en: 'After selecting the edge with weight 1, we select the edge with weight 2 and
    then the edge with weight 3, since these are the next lowest weights, as shown
    in *Figure 9.30*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择权重为1的边之后，我们选择权重为2的边，然后是权重为3的边，因为这些是下一个最低的权重，如图9.30所示：
- en: '![](img/B17217_09_30.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_30.png)'
- en: 'Figure 9.30: Selecting edges with wieghts 2 and 3 in the spanning tree'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30：在生成树中选择权重为2和3的边
- en: 'Similarly, we select the next edges with weights 4 and 5 respectively as shown
    in *Figure 9.31*:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们选择权重为4和5的下一条边，如图9.31所示：
- en: '![](img/B17217_09_31.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_31.png)'
- en: 'Figure 9.31: Selecting edges with weights 4 and 5 in the spanning tree'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31：在生成树中选择权重为4和5的边
- en: 'Next, we select the next edge with weight 6 and make it a dotted line. After
    that, we see that the lowest weight is 7 but if we select it, it makes a cycle,
    so we ignore it. Next, we check the edge with weight 8, and then 9, which are
    also ignored because they will also form a cycle. So, the next edge with the lowest
    weight, 10, is selected. This is shown in *Figure 9.32*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们选择权重为6的下一条边，并将其变为虚线。之后，我们发现最低权重是7，但如果选择它，会形成一个环，所以我们忽略它。接下来，我们检查权重为8的边，然后是9，这些边也被忽略，因为它们也会形成一个环。所以，下一个最低权重的边，即10，被选中。这如图*图9.32*所示：
- en: '![](img/B17217_09_32.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_32.png)'
- en: 'Figure 9.32: Selecting edges with weights 6 and 10 in the spanning tree'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32：在生成树中选择权重为6和10的边
- en: 'Finally, we see the following spanning tree using Kruskal’s algorithm, as shown
    in *Figure 9.33*:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用克鲁斯卡尔算法看到以下生成树，如图*图9.33*所示：
- en: '![](img/B17217_09_33.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_33.png)'
- en: 'Figure 9.33: The final spanning tree created using Kruskal’s algorithm'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33：使用克鲁斯卡尔算法创建的最终生成树
- en: Kruskal’s algorithm has many real-world applications, such as solving the traveling
    salesman problem (TSP), in which starting from one city, we have to visit all
    the different cities in a network with the minimum total cost and without visiting
    the same city twice. There are many other applications, such as TV networks, tour
    operations, LAN networks, and electric grids.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔算法在现实世界中有很多应用，例如解决旅行商问题（TSP），在这个问题中，从一个城市出发，我们必须以最低的总成本访问网络中的所有不同的城市，并且不能重复访问同一个城市。还有许多其他应用，例如电视网络、旅游运营、局域网和电网。
- en: The time complexity of Kruskal’s algorithm is O (E log (E)) or O (E log(V)),
    where E is the number of edges and V is the number of vertices.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 克鲁斯卡尔算法的时间复杂度是O(E log(E))或O(E log(V))，其中E是边的数量，V是顶点的数量。
- en: Now, let us discuss one more popular MST algorithm in the next section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节讨论另一个流行的MST算法。
- en: Prim’s Minimum Spanning Tree algorithm
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普里姆最小生成树算法
- en: 'Prim’s algorithm is also based on a greedy approach to find the minimum cost
    spanning tree. Prim’s algorithm is very similar to the Dijkstra algorithm for
    finding the shortest path in a graph. In this algorithm, we start with an arbitrary
    node as a starting point, and then we check the outgoing edges from the selected
    nodes and traverse through the edge that has the lowest cost (or weights). The
    terms cost and weight are used interchangeably in this algorithm. So, after starting
    from the selected node, we grow the tree by selecting the edges, one by one, that
    have the lowest weight and do not form a cycle. The algorithm works as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法也是基于贪心算法来找到最小生成树。普里姆算法与寻找图中最短路径的迪杰斯特拉算法非常相似。在这个算法中，我们从一个任意节点作为起点，然后检查所选节点的出边，并通过具有最低成本（或权重）的边进行遍历。在这个算法中，成本和权重是可互换的。因此，从所选节点开始，我们通过选择具有最低权重且不形成环的边，一个接一个地扩展树。算法的工作原理如下：
- en: Create a dictionary that holds all the edges and their weights
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含所有边及其权重的字典
- en: Get the edges, one by one, that have the lowest cost from the dictionary and
    grow the tree in such a way that the cycle is not formed
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字典中逐个获取具有最低成本的边，并以此方式扩展树，以确保不形成环
- en: Repeat step 2 until all the vertices are visited
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤2，直到所有顶点都被访问
- en: 'Let us consider an example to understand the working of Prim’s algorithm. Assuming
    that we arbitrarily select **A** node, we then check all the outgoing edges from
    **A**. Here, we have two options, **AB** and **AC**; we select edge **AC** since
    it has less cost/weight (weight 1), as shown in *Figure 9.34*:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解普里姆算法的工作原理。假设我们任意选择**A**节点，然后检查从**A**出发的所有出边。在这里，我们有两种选择，**AB**和**AC**；我们选择成本/权重较低的边**AC**（权重1），如图*图9.34*所示：
- en: '![](img/B17217_09_34.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_34.png)'
- en: 'Figure 9.34: Selecting edge AC in constructing the spanning tree using Prim’s
    algorithm'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34：使用普里姆算法构建生成树时选择边AC
- en: 'Next, we check the lowest outgoing edges from edge **AC**. We have options
    **AB**, **CD**, **CE**, **CF**, out of which we select edge **CF**, which has
    the lowest weight of 2\. Likewise, we grow the tree, and next we select the lowest
    weighted edge, i.e., **AB**, as shown in *Figure 9.35*:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查从边**AC**出发的最低权重出边。我们有**AB**、**CD**、**CE**、**CF**等选项，其中我们选择权重最低的边**CF**，其权重为2。同样，我们扩展树，接下来我们选择下一个最低权重的边，即**AB**，如图*图9.35*所示：
- en: '![](img/B17217_09_35.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_35.png)'
- en: 'Figure 9.35: Selecting edge AB in constructing the spanning tree using Prim’s
    algorithm'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35：使用普里姆算法选择边AB构建生成树
- en: 'Afterward, we select edge **BD**, which has a weight of 3, and similarly, next,
    we select edge **DG**, which has the lowest weight of 4\. This is shown in *Figure
    9.36*:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们选择边**BD**，其权重为3，同样地，接下来我们选择边**DG**，其权重为最低的4。这如图*图9.36*所示：
- en: '![](img/B17217_09_36.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_36.png)'
- en: 'Figure 9.36: Selecting edges BD and DG in constructing the spanning tree using
    Prim’s algorithm'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36：使用普里姆算法选择边BD和DG构建生成树
- en: 'Next, we select edges **FE** and **GH**, which have weights of 6 and 10 respectively,
    as shown in *Figure 9.37*:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们选择边**FE**和**GH**，它们的权重分别为6和10，如图*图9.37*所示：
- en: '![](img/B17217_09_37.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_37.png)'
- en: 'Figure 9.37: Selecting edges FE and GH in constructing the spanning tree using
    Prim’s algorithm'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37：使用普里姆算法选择边FE和GH构建生成树
- en: 'Next, whenever we try to include any more edges, a cycle is formed, so we ignore
    those edges. Finally, we obtain the spanning tree, which is shown below in *Figure
    9.38*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试添加更多边时，会形成一个环，所以我们忽略这些边。最后，我们得到生成树，如图*图9.38*所示：
- en: '![](img/B17217_09_38.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_38.png)'
- en: 'Figure 9.38: The final spanning tree using Prim’s algorithm'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38：使用普里姆算法得到的最终生成树
- en: Prim’s algorithm also has many real-world applications. For all the applications
    where we can use Kruskal’s algorithm, we can also use Prim’s algorithm. Other
    applications include road networks, game development, etc.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 普里姆算法也有许多实际应用。对于我们可以使用克鲁斯卡尔算法的所有应用，我们也可以使用普里姆算法。其他应用包括道路网络、游戏开发等。
- en: Since both Kruskal’s and Prim’s MST algorithms are used for the same purpose,
    which one should be used? In general, it depends on the structure of the graph.
    For a graph with **C** vertices and **E** edges, Kruskal’s algorithm’s worst-case
    time complexity is O(E logV), and Prim’s algorithm has a time complexity of O(E
    + V logV). So, we can observe that Prim’s algorithm works better when we have
    a dense graph, whereas Kruskal’s algorithm is better when we have a sparse graph.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 由于克鲁斯卡尔和普里姆的最小生成树算法都用于相同的目的，那么应该使用哪一个？一般来说，这取决于图的性质。对于一个有**C**个顶点和**E**条边的图，克鲁斯卡尔算法的最坏情况时间复杂度是O(E
    logV)，而普里姆算法的时间复杂度是O(E + V logV)。因此，我们可以观察到，当图是稠密的时候，普里姆算法表现更好，而当图是稀疏的时候，克鲁斯卡尔算法更优。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A graph is a non-linear data structure, which is very important due to the large
    number of real-world applications it has. In this chapter, we have discussed different
    ways to represent a graph in Python, using lists and dictionaries. Further, we
    learned two very important graph traversal algorithms, i.e., depth-first search
    (DFS) and breadth-first search (BFS). Moreover, we also discussed two very important
    algorithms for finding an MST, i.e. Kruskal’s algorithm and Prim’s algorithm.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一种非线性数据结构，由于它在现实世界中有大量的应用，因此非常重要。在本章中，我们讨论了在Python中使用列表和字典表示图的不同方法。此外，我们还学习了两个非常重要的图遍历算法，即深度优先搜索（DFS）和广度优先搜索（BFS）。此外，我们还讨论了找到最小生成树的两个非常重要的算法，即克鲁斯卡尔算法和普里姆算法。
- en: In the next chapter, we will discuss searching algorithms and the various methods
    using which we can efficiently search for items in lists.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论搜索算法以及我们可以使用哪些方法来有效地在列表中搜索项目。
- en: Exercises
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What is the maximum number of edges (without self-loops) possible in an undirected
    simple graph with five nodes?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个有五个节点的无向简单图中，可能的最大边数（不包括自环）是多少？
- en: What do we call a graph in which all the nodes have equal degrees?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们称所有节点度数都相等的图为什么？
- en: 'Explain what cut vertices are and identify the cut vertices in the given graph:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释什么是割点，并识别给定图中的割点：
- en: '![](img/B17217_09_39.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_09_39.png)'
- en: 'Figure 9.39: A sample graph'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39：一个示例图
- en: Assuming a graph G of order n, what will be the maximum number of cut vertices
    possible in graph G?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个图G的阶数为n，那么在图G中可能的最大割点数是多少？
- en: Join our community on Discord
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code14212497725512230621.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code14212497725512230621.png)'
