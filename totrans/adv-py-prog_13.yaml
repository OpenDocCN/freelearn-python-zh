- en: '*Chapter 11*: Building Communication Channels with asyncio'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication channels are a big part of applied concurrency in the field of
    computer science. In this chapter, we will cover the fundamental theories of transports,
    which are classes provided by the `asyncio` module to abstract various forms of
    communication channels. We will also cover an implementation of a simple echoing
    server-client logic in Python, to further illustrate the use of `asyncio` and
    concurrency in communication systems. This chapter will help us frame what we
    have learned so far about asynchronous programming in the practical context of
    communication channels, and the code we work with will serve as a base for more
    complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The ecosystem of communication channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Python and Telnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side communication with `aiohttp`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be accessed through this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11)'
  prefs: []
  type: TYPE_NORMAL
- en: The ecosystem of communication channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *communication channel* is used to denote both the physical wiring
    connection between different systems and the logical communication of data that
    facilitates computer networks. In this chapter, we will only be concerned with
    the latter, as it is a problem that is related to computing and is more germane
    to the idea of asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: First, in this section, we will be discussing the general structure of a communication
    channel, and two specific elements in that structure that are particularly relevant
    to asynchronous programming. The first element is communication protocol layers.
  prefs: []
  type: TYPE_NORMAL
- en: Communication protocol layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most data transmission processes that are done through communication channels
    are facilitated in the form of the **Open Systems Interconnection** (**OSI**)
    model protocol layers. The OSI model lays out the major layers and topics in an
    intersystem communication process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the general structure of the OSI model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – OSI model structure ](img/Figure_11.1_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – OSI model structure
  prefs: []
  type: TYPE_NORMAL
- en: As indicated, there are seven main layers of communication in a data transmission
    process, with varying degrees of computing level and specificity. We will not
    be going into the details of the purposes and specific functions of each layer,
    but it is still important that you understand the general ideas behind the media
    and host layers.
  prefs: []
  type: TYPE_NORMAL
- en: The three bottom layers contain low-level operations that interact with the
    underlying process of the communication channel. The operations in the physical
    and data link layers include coding schemes, access schemes, low-level error detection
    and correction, bit synchronization, and so on. These operations are used to implement
    and specify the logic of processing and preparing data before transferring it.
    The network layer, on the other hand, handles forwarding packets of data from
    one system (for example, the server) to another (for example, the client) in a
    computer network, by determining the address of the recipient and which path of
    data transfer to take.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the top layers deal with high-level data communication and
    manipulation. Among these layers, we will be focusing on the transport layer,
    as it is directly utilized by the `asyncio` module in the implementation of communication
    channels. This layer is often viewed as the conceptual transition between the
    media layers and the host layers (for example, the client and the server), responsible
    for sending data along with **end-to-end** (**E2E**) connections between different
    systems. Additionally, because packets of data (prepared by the network layer)
    might be lost or corrupted during transmission processes due to network errors,
    the transport layer is also in charge of detecting these errors via methods in
    error detection code.
  prefs: []
  type: TYPE_NORMAL
- en: The other host layers implement mechanisms for handling, interpreting, and providing
    the data sent from another system. After receiving data from the transport layer,
    the session layer handles the authentication, authorization, and session restoration
    processes. The presentation layer then translates the same data and reorganizes
    it into an interpretable representation. Finally, the application layer displays
    that data in a user-friendly format. With that in mind, let's see how we can apply
    the framework of asynchronous programming to communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming for communication channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The asynchronous programming model nicely complements the process of facilitating
    communication channels. For instance, in **HyperText Transfer Protocol** (**HTTP**)
    communication, the server can asynchronously handle multiple clients at the same
    time: while it is waiting for a specific client to make an HTTP request, it can
    switch to another client and process that client''s request. Similarly, if a client
    needs to make HTTP requests to multiple servers and must wait for large responses
    from some servers, it can consider the more lightweight responses, which have
    already been processed and were sent back to the client first. The following diagram
    shows an example of how servers and clients interact with each other asynchronously
    in HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Asynchronous, interleaved HTTP requests ](img/Figure_11.2_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Asynchronous, interleaved HTTP requests
  prefs: []
  type: TYPE_NORMAL
- en: Overall, asynchronous programming is an attractive framework for building communication
    channels. As such, we will see how this can be done with the `asyncio` module.
  prefs: []
  type: TYPE_NORMAL
- en: Transports and protocols in asyncio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `asyncio` module provides several different transport classes. In essence,
    these classes are implementations of the functionalities of the transport layer
    that were discussed in the preceding section. As the transport layer plays an
    integral role in communication channels, the transport classes give `asyncio`
    (and, consequently, developers) more control over the process of implementing
    our own communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncio` module combines the abstract of transports with the implementation
    of an asynchronous program. Specifically, even though transports are the central
    elements of communication channels, in order to utilize the transport classes
    and other relevant communication channel tools, we need to initiate and call an
    event loop, which is an instance of the `asyncio.AbstractEventLoop` class. The
    event loop itself will then create transports and manage the low-level communication
    procedures.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a `transport` object in an established communication
    channel in `asyncio` is always associated with an instance of the `asyncio.Protocol`
    class. As the name suggests, the `Protocol` class specifies the underlying protocols
    that the communication channels use; for each connection made with another system,
    a new protocol object from this class will be created. While working closely with
    a `transport` object, a protocol object can call various methods from the `transport`
    object; this is where we can implement the specific inner workings of a communication
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, we generally need to focus on the implementation of an `asyncio.Protocol`
    subclass and its methods while building a connection channel. In other words,
    we use `asyncio.Protocol` as a parent class to derive a subclass that meets the
    needs of our communication channel. To do this, we overwrite the following methods
    from the `asyncio.Protocol` base class in our own custom protocol subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Protocol.connection_made(transport)`: This method is automatically called
    whenever a connection from another system is made. The `transport` argument holds
    the `transport` object that is associated with the connection. Again, each `transport`
    object needs to be paired with a protocol; we generally store this `transport`
    object as an attribute of this specific protocol object in the `connection_made()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Protocol.data_received(data)`: This method is automatically called whenever
    the one system that we are connected to sends its data. Note that the `data` argument,
    which holds the sent information, is usually represented in bytes, so the `encode()`
    function of Python should be used before `data` is processed further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s consider other important methods from the transport classes from
    `asyncio`. All transport classes inherit from a parent transport class, called
    `asyncio.BaseTransport`, for which we have the following common methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseTransport.get_extra_info()`: This method returns, as the name suggests,
    additional channel-specific information for the calling `transport` object. The
    result can include information regarding the socket, the pipe, and the subprocess
    associated with that transport. Later in this chapter, we will be calling `BaseTransport.get_extra_info(''peername'')`
    to obtain the remote address from which the transport traveled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseTransport.close()`: This method is used to close the calling `transport`
    object, after which the connections between different systems will be stopped.
    The corresponding protocol of the transport will automatically call its `connection_lost()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the many implementations of transport classes, we will focus on the `asyncio.WriteTransport`
    class, which again inherits the methods from the `BaseTransport` class and additionally
    implements other methods that are used to facilitate write-only transport functionalities.
    Here, we will be using the `WriteTransport.write()` method, which will write the
    data that we would like to send to the other system that we communicate with via
    the `transport` object. As a part of the `asyncio` module, this method is not
    a blocking function; instead, it buffers and sends out the written data in an
    asynchronous way.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into a working example in Python, let's briefly discuss the big
    picture of what we are trying to accomplish—or, in other words, the general structure
    of our program.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture of asyncio's server client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, we need to implement a subclass of `asyncio.Protocol`
    to specify the underlying organization of our communication channel. There is
    an event loop at the heart of each asynchronous program, so we also need to create
    a server outside of the context of the protocol class and initiate that server
    inside of the event loop of our program. This process will set up the asynchronous
    architecture of our entire server and can be done via the `asyncio.create_server()`
    method, which we will look at in our upcoming example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will run the event loop of our asynchronous program forever by
    using the `AbstractEventLoop.run_forever()` method. Similar to an actual, real-life
    server, we would like to keep our server running until it encounters a problem,
    in which case we will close the server gracefully. The following diagram illustrates
    this whole process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Asynchronous program structure in communication channels ](img/Figure_11.3_B17499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Asynchronous program structure in communication channels
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we are ready to start building our application, starting from
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Python and Telnet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a specific Python example that implements a server that facilitates
    asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the `EchoServerClientProtocol` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, our `EchoServerClientProtocol` class is a subclass of `asyncio.Protocol`.
    As we discussed earlier, inside of this class, we need to implement the `connection_made(transport)`
    and `data_received(data)` methods. In the `connection_made()` method, we simply
    obtain the address of the connected system via the `get_extra_info()` method (with
    the `'peername'` argument), print a message out with that information, and finally
    store the `transport` object in an attribute of the class. To print out a similar
    message in the `data_received()` method, we again use the `decode()` method to
    obtain a string object from byte data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the main program of our script, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the familiar `asyncio.get_event_loop()` function to create an
    event loop for our asynchronous program. Then, we create a server for our communication
    by having that event loop call the `create_server()` method; this method takes
    in a subclass from the `asyncio.Protocol` class, an address for our server (in
    this case, it is our localhost: `127.0.0.1`), and finally, a port for that address
    (typically, `8888`).'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method does not create a server itself; it only initiates the
    process of creating a server asynchronously and returns a coroutine that will
    finish the process. For this reason, we need to store the returned coroutine from
    the method in a variable (`coro`, in our case) and have our event loop run that
    coroutine. After printing out a message using the `sockets` attribute of our server
    object, we will run the event loop forever, to keep the server running, except
    for the case of a `KeyboardInterrupt` exception being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of our program, we will handle the house-cleaning portion
    of the script, which is closing the server gracefully. This is typically done
    by having the server object call the `close()` method (to initiate the closing
    process of the server) and using the event loop to run the `wait_closed()` method
    on the server object, to make sure that the server is properly closed. Finally,
    we close the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Telnet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can run our sample Python program, we have to install the Telnet program
    to correctly simulate a connection channel between a client and a server. Telnet
    is a program that provides Terminal commands that facilitate protocols for bidirectional,
    interactive, text-oriented communication. If you already have Telnet working on
    your computer, simply skip to the next section; otherwise, find the information
    appropriate to your system in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows systems, Telnet is already installed, but might not be enabled.
    To enable it, you can either utilize the **Turn Windows features on or off** window
    and make sure that the **Telnet Client** box is checked, or run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Linux systems typically come with Telnet preinstalled, so if you own a Linux
    system, simply move on to the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In macOS systems, it is possible that Telnet has already been installed on
    your computer. If not, you will need to do it via the Homebrew package management
    software, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that macOS systems do have a preinstalled alternative to Telnet, called
    Netcat. If you do not want Telnet installed on your macOS computer, simply use
    the `nc` command instead of `telnet` in the following examples, and you will achieve
    the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a connection channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are multiple steps to running the following server example. First, we
    need to run the script to start the server, from which you will obtain the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the program will run until you invoke the *Ctrl* + *C* key combination.
    With the program still running in one Terminal (this is our server Terminal),
    open another Terminal and connect to the server (`127.0.0.1`) at the specified
    port (`8888`), as illustrated here; this will serve as our client Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will see some changes in both the server and the client Terminals.
    Most likely, your client Terminal will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is from the interface of the Telnet program, which indicates that we have
    successfully connected to our local server. The more interesting output is on
    our server Terminal, which will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Recall that this is an information message that we implemented in our `EchoServerClientProtocol`
    class—specifically, in the `connection_made()` method. Again, as a connection
    between the server and a new client is made, this method will be called automatically
    to initiate the communication. From the output message, we know that the client
    is making their requests from port `60332` of server `127.0.0.1` (which is the
    same as the running server, since they are both local).
  prefs: []
  type: TYPE_NORMAL
- en: Another feature that we implemented in the `EchoServerClientProtocol` class
    was in the `data_received()` method. Specifically, we print the decoded data that
    is sent from the client. To simulate this type of communication, simply type a
    message in your client Terminal and press the *Return* (*Enter*, for Windows)
    key. You will not see any changes in the client Terminal output, but the server
    Terminal should print out a message, as specified in the `data_received()` method
    of our protocol class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is my server Terminal output when I send the message `Hello,
    World!` from my client Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `\r` and `\n` characters are simply the return characters included in the
    message string. With our current protocol, you can send multiple messages to the
    server and can even have multiple clients send messages to the server. To implement
    this, simply open another Terminal and connect to the local server again. You
    will see from your server Terminal that a different client (from a different port)
    has made a connection to the server, while the original communication of our server
    with the old client is still being maintained. This is another result achieved
    from asynchronous programming, allowing multiple clients to communicate with the
    same server seamlessly, without using threading or multiprocessing.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages back to clients
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, in our current example, we can have our asynchronous server receive, read,
    and process messages from clients. However, for our communication channel to be
    useful, we would also like to send messages from the server to the clients. In
    this section, we will update our server to an echo server, which, by definition,
    will send all data that it receives from a specific client back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will be using the `write()` method from the `asyncio.WriteTransport`
    class. Consider the `data_received()` method of the `EchoServerClientProtocol`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After receiving the data from the `transport` object and printing it out, we
    write a corresponding message to the `transport` object, which will go back to
    the original client. By running this script and simulating the same communication
    that we implemented in the last example with Telnet or Netcat, you will see that
    after typing a message in the client Terminal, the client receives an echoed message
    from the server. This is my output after initiating the communication channel
    and typing in the `Hello, World!` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In essence, this example illustrates the capability of a bidirectional communication
    channel that we can implement through a custom `asyncio.Protocol` class. While
    running a server, we can obtain data sent from various clients connected to the
    server, process the data, and finally send the desired result back to the appropriate
    clients.
  prefs: []
  type: TYPE_NORMAL
- en: Closing transports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, we will want to forcefully close a transport in a communication
    channel. For example, even with asynchronous programming and other forms of concurrency,
    it is possible for your server to be overwhelmed with constant communications
    from multiple clients. On the other hand, it is undesirable to have the server
    completely handle some of the sent requests and plainly reject the rest of the
    requests as soon as the server is at its maximum capacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of keeping the communication open for each client connected to
    the server, we can specify in our protocol that each connection should be closed
    after a successful communication. We will do this by using the `BaseTransport.close()`
    method to forcefully close the calling `transport` object, which will stop the
    connection between the server and that specific client. Again, we are modifying
    the `data_received()` method of the `EchoServerClientProtocol` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script, connect to the specified server, and type in some messages
    to see the changes that we implemented. With our current setup, after a client
    connects and sends a message to the server, it will receive an echoed message
    back, and its connection with the server will be closed. This is the output (again,
    from the interface of the Telnet program) that I obtained after simulating this
    process with our current implementation of the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have covered examples of implementing asynchronous communication
    channels with the `asyncio` module, mostly from the perspective of the server
    side of the communication process; in other words, we have been handling and processing
    requests sent from external systems. This, however, is only one side of the equation,
    and we also have the client side of communication to explore. In the next section,
    we will discuss applying asynchronous programming to make requests to servers.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side communication with aiohttp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have most likely guessed, the end goal of this process is to efficiently
    collect data from external systems by asynchronously making requests to those
    systems. We will be revisiting the concept of web scraping, which is the process
    of automating HTTP requests to various websites and extracting specific information
    from their **HyperText Markup Language** (**HTML**) source code. If you have not
    read [*Chapter 9*](B17499_09_Final_SS_ePub.xhtml#_idTextAnchor158), *Concurrent
    Web Requests*, I highly recommend going through it before proceeding with this
    section, as that chapter covers the fundamental ideas of web scraping and other
    relevant, important concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will also be introduced to another module that supports
    asynchronous programming options: `aiohttp` (which stands for `asyncio` module,
    to facilitate asynchronous programming.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing aiohttp and aiofiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `aiohttp` module does not come preinstalled with your Python distribution;
    however, similarly to other packages, you can easily install the module by using
    the `pip` or `conda` commands. We will also be installing another module, `aiofiles`,
    which facilitates asynchronous file writing. If you use `pip` as your package
    manager, simply run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to use Anaconda, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, to confirm that you have successfully installed a package, open
    your Python interpreter and try to import the module. In this case, run the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There will be no error messages if the package has been successfully installed.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a website's HTML code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at how to make a request and obtain the HTML source code
    from a single website with `aiohttp`. Note that even with only one task (a website),
    our application remains asynchronous, and the structure of an asynchronous program
    still needs to be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider the `main()` coroutine first. We are initiating an instance from
    the `aiohttp.ClientSession` class within a context manager; note that we are also
    placing the `async` keyword in front of this declaration since the whole context
    block itself will also be treated as a coroutine. Inside of this block, we are
    calling and waiting for the `get_html()` coroutine to process and return.
  prefs: []
  type: TYPE_NORMAL
- en: Turning our attention to the `get_html()` coroutine, we can see that it takes
    in a session object and a `GET` request and store the response from the server
    to the `res` variable. Finally, we return the HTML source code stored in the response.
    Since the response is an object returned from the `aiohttp.ClientSession` class,
    its methods are asynchronous functions, and therefore we need to specify the `await`
    keyword when we call the `text()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you run the program, the entire HTML source code of Packt''s website will
    be printed out. For example, here is a portion of my output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we can collect data by making requests to multiple websites asynchronously
    and print out the response HTML. Most of the time, simply printing out the HTML
    is inappropriate; instead, we'd like to write the returned HTML code to output
    files. In essence, this process is asynchronous downloading, which is also implemented
    in the underlying architecture of popular download managers. To do this, we will
    use the `aiofiles` module, in combination with `aiohttp` and `asyncio`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing files asynchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will write a `download_html()` coroutine, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is an updated version of the `get_html()` coroutine from the last example.
    Instead of using an `aiohttp.ClientSession` instance to make a `GET` request and
    print out the returned HTML code, we now write the HTML code to the file using
    the `aiofiles` module. For example, to facilitate asynchronous file writing, we
    use the asynchronous `open()` function from `aiofiles` to read in a file in a
    context manager. Furthermore, we read the returned HTML in chunks, asynchronously,
    using the `read()` function for the `content` attribute of the response object;
    this means that after reading `1024` bytes of the current response, the execution
    flow will be released back to the event loop, and the task-switching event will
    take place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` coroutine and the main program of this example remain relatively
    the same as those in our last example, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` coroutine takes in a URL and passes it to the `download_html()`
    coroutine, along with an `aiohttp.ClientSession` instance. Finally, in our main
    program, we create an event loop and pass each item in a specified list of URLs
    to the `main()` coroutine. After running the program, your output should look
    like this, although the time it takes to run the program might vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, a subfolder named `output` (inside of the `Chapter18` folder)
    will be filled with the downloaded HTML code from each website in our list of
    URLs. Again, these files were created and written asynchronously, via the functionalities
    of the `aiofiles` module, which we discussed earlier. As you can see, to compare
    the speed of this program and its corresponding synchronous version, we are also
    keeping track of the time it takes to run the entire program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, head to the `Chapter11/example6.py` file. This script contains the code
    of the synchronous version of our current program. Specifically, it makes HTTP
    `GET` requests to individual websites in order, and the process of file writing
    is also implemented sequentially. This script produced the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While it achieved the same results (downloading the HTML code and writing it
    to files), our sequential program took significantly more time than its asynchronous
    counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming can provide functionalities that complement the process
    of efficiently facilitating communication channels. Together with the `aiohttp`
    module, `asyncio` offers efficiency and flexibility regarding client-side communication
    processes. The `aiofiles` module, which can work in conjunction with the other
    two asynchronous programming modules, can also help to facilitate asynchronous
    file reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now explored three of the biggest, most important topics in concurrent
    programming: threading, multiprocessing, and asynchronous programming. We have
    shown how each of them can be applied to various programming problems and provide
    significant improvements in speed. The code we developed in this chapter serves
    as a base that may be easily modified to build more complex applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter of this book, we will start to discuss problems that concurrent
    programming commonly poses to developers and programmers, starting with deadlocks.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a communication channel? What is its connection to asynchronous programming?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two main parts of the OSI model protocol layers? What purpose does
    each of them serve?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the transport layer? Why is it crucial to communication channels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `asyncio` facilitate the implementation of server-side communication
    channels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `asyncio` facilitate the implementation of client-side communication
    channels?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `aiofiles`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*IoT Systems and Communication Channels* (br`idgera.com/iot-communication-channels/`),
    by *Bridgera*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*,
    *Al Sweigart*, *No Starch Press*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Transports and protocols* (`docs.python.org/3/library/asyncio-protocol`),
    Python documentation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
