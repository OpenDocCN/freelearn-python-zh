- en: '*Chapter 11*: Building Communication Channels with asyncio'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用asyncio构建通信通道'
- en: Communication channels are a big part of applied concurrency in the field of
    computer science. In this chapter, we will cover the fundamental theories of transports,
    which are classes provided by the `asyncio` module to abstract various forms of
    communication channels. We will also cover an implementation of a simple echoing
    server-client logic in Python, to further illustrate the use of `asyncio` and
    concurrency in communication systems. This chapter will help us frame what we
    have learned so far about asynchronous programming in the practical context of
    communication channels, and the code we work with will serve as a base for more
    complex applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通信通道是计算机科学领域应用并发的重要组成部分。在本章中，我们将介绍传输的基本理论，这些理论是由`asyncio`模块提供的类，用于抽象各种形式的通信通道。我们还将通过Python实现一个简单的回声服务器-客户端逻辑，以进一步说明`asyncio`和并发在通信系统中的应用。本章将帮助我们构建在通信通道的实际应用中关于异步编程的知识框架，我们使用的代码将作为更复杂应用的基础。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The ecosystem of communication channels
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信通道的生态系统
- en: Getting started with Python and Telnet
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python和Telnet入门
- en: Client-side communication with `aiohttp`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`aiohttp`的客户端通信
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code files for this chapter can be accessed through this link:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以通过此链接访问：
- en: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter11)'
- en: The ecosystem of communication channels
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信通道的生态系统
- en: The term *communication channel* is used to denote both the physical wiring
    connection between different systems and the logical communication of data that
    facilitates computer networks. In this chapter, we will only be concerned with
    the latter, as it is a problem that is related to computing and is more germane
    to the idea of asynchronous programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*通信通道*用于表示不同系统之间的物理布线连接以及促进计算机网络的数据逻辑通信。在本章中，我们只关注后者，因为它与计算相关，并且更贴近异步编程的概念。
- en: First, in this section, we will be discussing the general structure of a communication
    channel, and two specific elements in that structure that are particularly relevant
    to asynchronous programming. The first element is communication protocol layers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在本节中，我们将讨论通信通道的一般结构，以及该结构中两个与异步编程特别相关的特定元素。第一个元素是通信协议层。
- en: Communication protocol layers
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信协议层
- en: Most data transmission processes that are done through communication channels
    are facilitated in the form of the **Open Systems Interconnection** (**OSI**)
    model protocol layers. The OSI model lays out the major layers and topics in an
    intersystem communication process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数通过通信通道完成的数据传输过程都是以**开放系统互联**（**OSI**）模型协议层的形式进行的。OSI模型概述了系统间通信过程中的主要层和主题。
- en: 'The following diagram shows the general structure of the OSI model:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了OSI模型的一般结构：
- en: '![Figure 11.1 – OSI model structure ](img/Figure_11.1_B17499.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – OSI模型结构](img/Figure_11.1_B17499.jpg)'
- en: Figure 11.1 – OSI model structure
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – OSI模型结构
- en: As indicated, there are seven main layers of communication in a data transmission
    process, with varying degrees of computing level and specificity. We will not
    be going into the details of the purposes and specific functions of each layer,
    but it is still important that you understand the general ideas behind the media
    and host layers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在数据传输过程中，存在七个主要的通信层，这些层具有不同的计算级别和特定性。我们不会深入探讨每一层的具体目的和功能，但了解媒体和主机层背后的基本概念仍然很重要。
- en: The three bottom layers contain low-level operations that interact with the
    underlying process of the communication channel. The operations in the physical
    and data link layers include coding schemes, access schemes, low-level error detection
    and correction, bit synchronization, and so on. These operations are used to implement
    and specify the logic of processing and preparing data before transferring it.
    The network layer, on the other hand, handles forwarding packets of data from
    one system (for example, the server) to another (for example, the client) in a
    computer network, by determining the address of the recipient and which path of
    data transfer to take.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 三个底层包含与通信通道底层过程交互的低级操作。物理层和数据链路层的操作包括编码方案、接入方案、低级错误检测和纠正、位同步等。这些操作用于实现和指定在传输之前处理和准备数据的逻辑。另一方面，网络层通过确定接收者的地址和选择数据传输路径，在计算机网络中将一个系统（例如，服务器）的数据包转发到另一个系统（例如，客户端）。
- en: On the other hand, the top layers deal with high-level data communication and
    manipulation. Among these layers, we will be focusing on the transport layer,
    as it is directly utilized by the `asyncio` module in the implementation of communication
    channels. This layer is often viewed as the conceptual transition between the
    media layers and the host layers (for example, the client and the server), responsible
    for sending data along with **end-to-end** (**E2E**) connections between different
    systems. Additionally, because packets of data (prepared by the network layer)
    might be lost or corrupted during transmission processes due to network errors,
    the transport layer is also in charge of detecting these errors via methods in
    error detection code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，最顶层处理高级数据通信和处理。在这些层级中，我们将重点关注传输层，因为它在实现通信通道时直接被`asyncio`模块利用。这一层通常被视为媒体层和主机层（例如，客户端和服务器）之间的概念过渡，负责在不同系统之间通过**端到端**（**E2E**）连接发送数据。此外，由于数据包（由网络层准备）在传输过程中可能会因为网络错误而丢失或损坏，传输层还负责通过错误检测代码中的方法检测这些错误。
- en: The other host layers implement mechanisms for handling, interpreting, and providing
    the data sent from another system. After receiving data from the transport layer,
    the session layer handles the authentication, authorization, and session restoration
    processes. The presentation layer then translates the same data and reorganizes
    it into an interpretable representation. Finally, the application layer displays
    that data in a user-friendly format. With that in mind, let's see how we can apply
    the framework of asynchronous programming to communication channels.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 其他主机层实现处理、解释和提供来自另一个系统的数据的机制。在从传输层接收数据后，会话层处理身份验证、授权和会话恢复过程。表示层随后将相同的数据转换并重新组织成可解释的表示形式。最后，应用层以用户友好的格式显示这些数据。考虑到这一点，让我们看看我们如何将异步编程框架应用于通信通道。
- en: Asynchronous programming for communication channels
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信通道的异步编程
- en: 'The asynchronous programming model nicely complements the process of facilitating
    communication channels. For instance, in **HyperText Transfer Protocol** (**HTTP**)
    communication, the server can asynchronously handle multiple clients at the same
    time: while it is waiting for a specific client to make an HTTP request, it can
    switch to another client and process that client''s request. Similarly, if a client
    needs to make HTTP requests to multiple servers and must wait for large responses
    from some servers, it can consider the more lightweight responses, which have
    already been processed and were sent back to the client first. The following diagram
    shows an example of how servers and clients interact with each other asynchronously
    in HTTP requests:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程模型很好地补充了促进通信通道的过程。例如，在**超文本传输协议**（**HTTP**）通信中，服务器可以异步地同时处理多个客户端：当它等待特定客户端发起HTTP请求时，它可以切换到另一个客户端并处理该客户端的请求。同样，如果客户端需要向多个服务器发起HTTP请求并且必须等待某些服务器的大响应，它可以考虑更轻量级的响应，这些响应已经处理并发送回客户端。以下图表展示了服务器和客户端如何在HTTP请求中异步交互的示例：
- en: '![Figure 11.2 – Asynchronous, interleaved HTTP requests ](img/Figure_11.2_B17499.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 异步、交错HTTP请求](img/Figure_11.2_B17499.jpg)'
- en: Figure 11.2 – Asynchronous, interleaved HTTP requests
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 异步、交错HTTP请求
- en: Overall, asynchronous programming is an attractive framework for building communication
    channels. As such, we will see how this can be done with the `asyncio` module.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，异步编程是一个构建通信通道的有吸引力的框架。因此，我们将看到如何使用 `asyncio` 模块来实现这一点。
- en: Transports and protocols in asyncio
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: asyncio 中的传输和协议
- en: The `asyncio` module provides several different transport classes. In essence,
    these classes are implementations of the functionalities of the transport layer
    that were discussed in the preceding section. As the transport layer plays an
    integral role in communication channels, the transport classes give `asyncio`
    (and, consequently, developers) more control over the process of implementing
    our own communication channels.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 模块提供了几个不同的传输类。本质上，这些类是前面章节中讨论的传输层功能的实现。由于传输层在通信通道中扮演着至关重要的角色，传输类为
    `asyncio`（以及开发者）提供了更多控制我们自己的通信通道实现过程的能力。'
- en: The `asyncio` module combines the abstract of transports with the implementation
    of an asynchronous program. Specifically, even though transports are the central
    elements of communication channels, in order to utilize the transport classes
    and other relevant communication channel tools, we need to initiate and call an
    event loop, which is an instance of the `asyncio.AbstractEventLoop` class. The
    event loop itself will then create transports and manage the low-level communication
    procedures.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 模块结合了传输的抽象与异步程序实现的实现。具体来说，尽管传输是通信通道的核心元素，但为了利用传输类和其他相关通信通道工具，我们需要启动并调用事件循环，这是一个
    `asyncio.AbstractEventLoop` 类的实例。然后，事件循环本身将创建传输并管理低级通信过程。'
- en: It is important to note that a `transport` object in an established communication
    channel in `asyncio` is always associated with an instance of the `asyncio.Protocol`
    class. As the name suggests, the `Protocol` class specifies the underlying protocols
    that the communication channels use; for each connection made with another system,
    a new protocol object from this class will be created. While working closely with
    a `transport` object, a protocol object can call various methods from the `transport`
    object; this is where we can implement the specific inner workings of a communication
    channel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在 `asyncio` 中已建立的通信通道中的 `transport` 对象始终与 `asyncio.Protocol` 类的实例相关联。正如其名称所暗示的，`Protocol`
    类指定了通信通道使用的底层协议；对于与另一个系统建立的每个连接，都会从这个类中创建一个新的协议对象。在紧密与 `transport` 对象协作时，协议对象可以调用来自
    `transport` 对象的各种方法；这就是我们可以实现通信通道特定内部工作方式的地方。
- en: 'For this reason, we generally need to focus on the implementation of an `asyncio.Protocol`
    subclass and its methods while building a connection channel. In other words,
    we use `asyncio.Protocol` as a parent class to derive a subclass that meets the
    needs of our communication channel. To do this, we overwrite the following methods
    from the `asyncio.Protocol` base class in our own custom protocol subclass:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在构建连接通道时，我们通常需要关注 `asyncio.Protocol` 子类的实现及其方法。换句话说，我们使用 `asyncio.Protocol`
    作为父类来派生一个满足我们通信通道需求的子类。为此，我们在自己的自定义协议子类中重写了以下来自 `asyncio.Protocol` 基类的方法：
- en: '`Protocol.connection_made(transport)`: This method is automatically called
    whenever a connection from another system is made. The `transport` argument holds
    the `transport` object that is associated with the connection. Again, each `transport`
    object needs to be paired with a protocol; we generally store this `transport`
    object as an attribute of this specific protocol object in the `connection_made()`
    method.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protocol.connection_made(transport)`: 当另一个系统建立连接时，此方法会自动调用。`transport` 参数包含与连接关联的
    `transport` 对象。同样，每个 `transport` 对象都需要与一个协议配对；我们通常在 `connection_made()` 方法中将此
    `transport` 对象存储为特定协议对象的属性。'
- en: '`Protocol.data_received(data)`: This method is automatically called whenever
    the one system that we are connected to sends its data. Note that the `data` argument,
    which holds the sent information, is usually represented in bytes, so the `encode()`
    function of Python should be used before `data` is processed further.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protocol.data_received(data)`: 当我们连接的系统发送其数据时，此方法会自动调用。请注意，包含发送信息的 `data`
    参数通常以字节表示，因此在进一步处理 `data` 之前，应使用 Python 的 `encode()` 函数。'
- en: 'Next, let''s consider other important methods from the transport classes from
    `asyncio`. All transport classes inherit from a parent transport class, called
    `asyncio.BaseTransport`, for which we have the following common methods:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseTransport.get_extra_info()`: This method returns, as the name suggests,
    additional channel-specific information for the calling `transport` object. The
    result can include information regarding the socket, the pipe, and the subprocess
    associated with that transport. Later in this chapter, we will be calling `BaseTransport.get_extra_info(''peername'')`
    to obtain the remote address from which the transport traveled.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BaseTransport.close()`: This method is used to close the calling `transport`
    object, after which the connections between different systems will be stopped.
    The corresponding protocol of the transport will automatically call its `connection_lost()`
    method.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the many implementations of transport classes, we will focus on the `asyncio.WriteTransport`
    class, which again inherits the methods from the `BaseTransport` class and additionally
    implements other methods that are used to facilitate write-only transport functionalities.
    Here, we will be using the `WriteTransport.write()` method, which will write the
    data that we would like to send to the other system that we communicate with via
    the `transport` object. As a part of the `asyncio` module, this method is not
    a blocking function; instead, it buffers and sends out the written data in an
    asynchronous way.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into a working example in Python, let's briefly discuss the big
    picture of what we are trying to accomplish—or, in other words, the general structure
    of our program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The big picture of asyncio's server client
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, we need to implement a subclass of `asyncio.Protocol`
    to specify the underlying organization of our communication channel. There is
    an event loop at the heart of each asynchronous program, so we also need to create
    a server outside of the context of the protocol class and initiate that server
    inside of the event loop of our program. This process will set up the asynchronous
    architecture of our entire server and can be done via the `asyncio.create_server()`
    method, which we will look at in our upcoming example.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will run the event loop of our asynchronous program forever by
    using the `AbstractEventLoop.run_forever()` method. Similar to an actual, real-life
    server, we would like to keep our server running until it encounters a problem,
    in which case we will close the server gracefully. The following diagram illustrates
    this whole process:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Asynchronous program structure in communication channels ](img/Figure_11.3_B17499.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Asynchronous program structure in communication channels
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we are ready to start building our application, starting from
    the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Python and Telnet
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a specific Python example that implements a server that facilitates
    asynchronous communication.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Starting a server
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the `EchoServerClientProtocol` class, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, our `EchoServerClientProtocol` class is a subclass of `asyncio.Protocol`.
    As we discussed earlier, inside of this class, we need to implement the `connection_made(transport)`
    and `data_received(data)` methods. In the `connection_made()` method, we simply
    obtain the address of the connected system via the `get_extra_info()` method (with
    the `'peername'` argument), print a message out with that information, and finally
    store the `transport` object in an attribute of the class. To print out a similar
    message in the `data_received()` method, we again use the `decode()` method to
    obtain a string object from byte data.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the main program of our script, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are using the familiar `asyncio.get_event_loop()` function to create an
    event loop for our asynchronous program. Then, we create a server for our communication
    by having that event loop call the `create_server()` method; this method takes
    in a subclass from the `asyncio.Protocol` class, an address for our server (in
    this case, it is our localhost: `127.0.0.1`), and finally, a port for that address
    (typically, `8888`).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method does not create a server itself; it only initiates the
    process of creating a server asynchronously and returns a coroutine that will
    finish the process. For this reason, we need to store the returned coroutine from
    the method in a variable (`coro`, in our case) and have our event loop run that
    coroutine. After printing out a message using the `sockets` attribute of our server
    object, we will run the event loop forever, to keep the server running, except
    for the case of a `KeyboardInterrupt` exception being invoked.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of our program, we will handle the house-cleaning portion
    of the script, which is closing the server gracefully. This is typically done
    by having the server object call the `close()` method (to initiate the closing
    process of the server) and using the event loop to run the `wait_closed()` method
    on the server object, to make sure that the server is properly closed. Finally,
    we close the event loop.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Installing Telnet
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can run our sample Python program, we have to install the Telnet program
    to correctly simulate a connection channel between a client and a server. Telnet
    is a program that provides Terminal commands that facilitate protocols for bidirectional,
    interactive, text-oriented communication. If you already have Telnet working on
    your computer, simply skip to the next section; otherwise, find the information
    appropriate to your system in this section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows systems, Telnet is already installed, but might not be enabled.
    To enable it, you can either utilize the **Turn Windows features on or off** window
    and make sure that the **Telnet Client** box is checked, or run the following
    command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Linux systems typically come with Telnet preinstalled, so if you own a Linux
    system, simply move on to the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统通常预装了 Telnet，所以如果你拥有 Linux 系统，只需继续到下一节。
- en: 'In macOS systems, it is possible that Telnet has already been installed on
    your computer. If not, you will need to do it via the Homebrew package management
    software, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 系统中，Telnet 可能已经安装在你的计算机上。如果没有，你需要通过 Homebrew 软件包管理工具来安装，如下所示：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that macOS systems do have a preinstalled alternative to Telnet, called
    Netcat. If you do not want Telnet installed on your macOS computer, simply use
    the `nc` command instead of `telnet` in the following examples, and you will achieve
    the same effect.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，macOS 系统确实预装了 Telnet 的替代品，名为 Netcat。如果你不想在 macOS 计算机上安装 Telnet，只需在以下示例中使用
    `nc` 命令代替 `telnet`，你将获得相同的效果。
- en: Simulating a connection channel
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟连接通道
- en: 'There are multiple steps to running the following server example. First, we
    need to run the script to start the server, from which you will obtain the following
    output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下服务器示例有多个步骤。首先，我们需要运行脚本以启动服务器，你将获得以下输出：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that the program will run until you invoke the *Ctrl* + *C* key combination.
    With the program still running in one Terminal (this is our server Terminal),
    open another Terminal and connect to the server (`127.0.0.1`) at the specified
    port (`8888`), as illustrated here; this will serve as our client Terminal:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，程序将一直运行，直到你调用 *Ctrl* + *C* 键组合。当程序在一个终端（这是我们服务器终端）中运行时，打开另一个终端并连接到指定端口（`8888`）的服务器（`127.0.0.1`），如图所示；这将作为我们的客户端终端：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you will see some changes in both the server and the client Terminals.
    Most likely, your client Terminal will have the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在服务器和客户端终端中看到一些变化。很可能是你的客户端终端会有以下输出：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is from the interface of the Telnet program, which indicates that we have
    successfully connected to our local server. The more interesting output is on
    our server Terminal, which will be similar to the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Telnet 程序的界面来的，表示我们已经成功连接到本地服务器。更有趣的输出在我们的服务器终端上，它将类似于以下内容：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Recall that this is an information message that we implemented in our `EchoServerClientProtocol`
    class—specifically, in the `connection_made()` method. Again, as a connection
    between the server and a new client is made, this method will be called automatically
    to initiate the communication. From the output message, we know that the client
    is making their requests from port `60332` of server `127.0.0.1` (which is the
    same as the running server, since they are both local).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，这是我们 `EchoServerClientProtocol` 类中实现的一个信息消息——具体来说，是在 `connection_made()`
    方法中。同样，当服务器与一个新客户端建立连接时，此方法将自动调用以启动通信。从输出消息中，我们知道客户端正在从服务器 `127.0.0.1` 的端口 `60332`
    发出请求（由于它们都是本地的，所以这与运行中的服务器相同）。
- en: Another feature that we implemented in the `EchoServerClientProtocol` class
    was in the `data_received()` method. Specifically, we print the decoded data that
    is sent from the client. To simulate this type of communication, simply type a
    message in your client Terminal and press the *Return* (*Enter*, for Windows)
    key. You will not see any changes in the client Terminal output, but the server
    Terminal should print out a message, as specified in the `data_received()` method
    of our protocol class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `EchoServerClientProtocol` 类中实现的一个新功能是在 `data_received()` 方法中。具体来说，我们打印从客户端发送的解码数据。要模拟这种类型的通信，只需在客户端终端中输入一条消息并按
    *Return* (*Enter*，对于 Windows) 键。你不会在客户端终端输出中看到任何变化，但服务器终端应该会打印出一条消息，正如我们协议类中的
    `data_received()` 方法所指定的。
- en: 'For example, this is my server Terminal output when I send the message `Hello,
    World!` from my client Terminal:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是我从客户端终端发送消息 `Hello, World!` 时我的服务器终端的输出：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `\r` and `\n` characters are simply the return characters included in the
    message string. With our current protocol, you can send multiple messages to the
    server and can even have multiple clients send messages to the server. To implement
    this, simply open another Terminal and connect to the local server again. You
    will see from your server Terminal that a different client (from a different port)
    has made a connection to the server, while the original communication of our server
    with the old client is still being maintained. This is another result achieved
    from asynchronous programming, allowing multiple clients to communicate with the
    same server seamlessly, without using threading or multiprocessing.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`\r`和`\n`字符仅仅是消息字符串中包含的回车字符。根据我们当前的协议，你可以向服务器发送多条消息，甚至可以有多个客户端向服务器发送消息。要实现这一点，只需打开另一个终端并再次连接到本地服务器。你将从服务器终端看到，一个不同的客户端（来自不同的端口）已连接到服务器，而我们的服务器与旧客户端的原始通信仍在进行中。这是异步编程带来的另一个结果，允许多个客户端无缝地与同一服务器通信，而不使用线程或进程。'
- en: Sending messages back to clients
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息回客户端
- en: So, in our current example, we can have our asynchronous server receive, read,
    and process messages from clients. However, for our communication channel to be
    useful, we would also like to send messages from the server to the clients. In
    this section, we will update our server to an echo server, which, by definition,
    will send all data that it receives from a specific client back to the client.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的当前示例中，我们的异步服务器可以接收、读取和处理来自客户端的消息。然而，为了使我们的通信通道有用，我们还想从服务器向客户端发送消息。在本节中，我们将更新我们的服务器为回显服务器，根据定义，它将把从特定客户端接收到的所有数据发送回该客户端。
- en: 'To do this, we will be using the `write()` method from the `asyncio.WriteTransport`
    class. Consider the `data_received()` method of the `EchoServerClientProtocol`
    class, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用`asyncio.WriteTransport`类的`write()`方法。考虑以下`EchoServerClientProtocol`类的`data_received()`方法：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After receiving the data from the `transport` object and printing it out, we
    write a corresponding message to the `transport` object, which will go back to
    the original client. By running this script and simulating the same communication
    that we implemented in the last example with Telnet or Netcat, you will see that
    after typing a message in the client Terminal, the client receives an echoed message
    from the server. This is my output after initiating the communication channel
    and typing in the `Hello, World!` message:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`transport`对象接收数据并打印出来后，我们向`transport`对象写入一条相应的消息，该消息将返回到原始客户端。通过运行此脚本并模拟我们在上一个示例中用Telnet或Netcat实现的相同通信，你将看到在客户端终端中输入一条消息后，客户端从服务器接收到了回显消息。这是我在启动通信通道并输入`Hello,
    World!`消息后的输出：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In essence, this example illustrates the capability of a bidirectional communication
    channel that we can implement through a custom `asyncio.Protocol` class. While
    running a server, we can obtain data sent from various clients connected to the
    server, process the data, and finally send the desired result back to the appropriate
    clients.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，这个例子说明了我们可以通过自定义`asyncio.Protocol`类实现的双向通信通道的能力。在运行服务器时，我们可以获取连接到服务器的各个客户端发送的数据，处理数据，并最终将所需的结果发送回适当的客户端。
- en: Closing transports
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关闭传输
- en: Occasionally, we will want to forcefully close a transport in a communication
    channel. For example, even with asynchronous programming and other forms of concurrency,
    it is possible for your server to be overwhelmed with constant communications
    from multiple clients. On the other hand, it is undesirable to have the server
    completely handle some of the sent requests and plainly reject the rest of the
    requests as soon as the server is at its maximum capacity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能需要强制关闭通信通道中的传输。例如，即使使用异步编程和其他并发形式，你的服务器也可能因为来自多个客户端的持续通信而超负荷。另一方面，当服务器达到最大容量时，完全处理一些已发送的请求并立即拒绝其余请求是不理想的。
- en: 'So, instead of keeping the communication open for each client connected to
    the server, we can specify in our protocol that each connection should be closed
    after a successful communication. We will do this by using the `BaseTransport.close()`
    method to forcefully close the calling `transport` object, which will stop the
    connection between the server and that specific client. Again, we are modifying
    the `data_received()` method of the `EchoServerClientProtocol` class, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在我们的协议中指定，在成功通信后关闭每个连接到服务器的客户端。我们将通过使用`BaseTransport.close()`方法强制关闭调用`transport`对象来实现这一点，这将停止服务器与特定客户端之间的连接。再次强调，我们正在修改`EchoServerClientProtocol`类的`data_received()`方法，如下所示：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the script, connect to the specified server, and type in some messages
    to see the changes that we implemented. With our current setup, after a client
    connects and sends a message to the server, it will receive an echoed message
    back, and its connection with the server will be closed. This is the output (again,
    from the interface of the Telnet program) that I obtained after simulating this
    process with our current implementation of the protocol:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，连接到指定的服务器，并输入一些消息以查看我们实现的变化。根据我们当前的设置，在客户端连接并发送消息到服务器后，它将收到一个回显消息，并且与服务器之间的连接将被关闭。这是我在使用我们当前协议实现模拟此过程后获得的输出（再次，来自Telnet程序的界面）：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So far, we have covered examples of implementing asynchronous communication
    channels with the `asyncio` module, mostly from the perspective of the server
    side of the communication process; in other words, we have been handling and processing
    requests sent from external systems. This, however, is only one side of the equation,
    and we also have the client side of communication to explore. In the next section,
    we will discuss applying asynchronous programming to make requests to servers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了使用`asyncio`模块实现异步通信通道的示例，主要从通信过程的客户端角度进行；换句话说，我们一直在处理和外部系统发送的请求。然而，这仅仅是方程式的一方面，我们还需要探索通信的客户端。在下一节中，我们将讨论如何将异步编程应用于向服务器发送请求。
- en: Client-side communication with aiohttp
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用aiohttp进行客户端通信
- en: As you have most likely guessed, the end goal of this process is to efficiently
    collect data from external systems by asynchronously making requests to those
    systems. We will be revisiting the concept of web scraping, which is the process
    of automating HTTP requests to various websites and extracting specific information
    from their **HyperText Markup Language** (**HTML**) source code. If you have not
    read [*Chapter 9*](B17499_09_Final_SS_ePub.xhtml#_idTextAnchor158), *Concurrent
    Web Requests*, I highly recommend going through it before proceeding with this
    section, as that chapter covers the fundamental ideas of web scraping and other
    relevant, important concepts.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测，这个过程的目标是高效地从外部系统异步请求数据。我们将回顾网络爬虫的概念，这是自动化HTTP请求到各种网站并从它们的**超文本标记语言**（**HTML**）源代码中提取特定信息的过程。如果你还没有阅读[*第9章*](B17499_09_Final_SS_ePub.xhtml#_idTextAnchor158)，*并发Web请求*，我强烈建议你在继续本节之前阅读它，因为该章节涵盖了网络爬虫和其他相关、重要的概念。
- en: 'In this section, you will also be introduced to another module that supports
    asynchronous programming options: `aiohttp` (which stands for `asyncio` module,
    to facilitate asynchronous programming.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你还将了解到另一个支持异步编程选项的模块：`aiohttp`（代表`asyncio`模块，以方便异步编程）。
- en: Installing aiohttp and aiofiles
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装aiohttp和aiofiles
- en: 'The `aiohttp` module does not come preinstalled with your Python distribution;
    however, similarly to other packages, you can easily install the module by using
    the `pip` or `conda` commands. We will also be installing another module, `aiofiles`,
    which facilitates asynchronous file writing. If you use `pip` as your package
    manager, simply run the following commands:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiohttp`模块不是Python发行版预安装的；然而，与其他包类似，你可以通过使用`pip`或`conda`命令轻松安装该模块。我们还将安装另一个模块`aiofiles`，它支持异步文件写入。如果你使用`pip`作为包管理器，只需运行以下命令：'
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you''d like to use Anaconda, run the following commands:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Anaconda，请运行以下命令：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As always, to confirm that you have successfully installed a package, open
    your Python interpreter and try to import the module. In this case, run the following
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，为了确认你已成功安装了包，打开你的Python解释器并尝试导入该模块。在这种情况下，运行以下代码：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There will be no error messages if the package has been successfully installed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a website's HTML code
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s look at how to make a request and obtain the HTML source code
    from a single website with `aiohttp`. Note that even with only one task (a website),
    our application remains asynchronous, and the structure of an asynchronous program
    still needs to be implemented as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's consider the `main()` coroutine first. We are initiating an instance from
    the `aiohttp.ClientSession` class within a context manager; note that we are also
    placing the `async` keyword in front of this declaration since the whole context
    block itself will also be treated as a coroutine. Inside of this block, we are
    calling and waiting for the `get_html()` coroutine to process and return.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Turning our attention to the `get_html()` coroutine, we can see that it takes
    in a session object and a `GET` request and store the response from the server
    to the `res` variable. Finally, we return the HTML source code stored in the response.
    Since the response is an object returned from the `aiohttp.ClientSession` class,
    its methods are asynchronous functions, and therefore we need to specify the `await`
    keyword when we call the `text()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'As you run the program, the entire HTML source code of Packt''s website will
    be printed out. For example, here is a portion of my output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this point, we can collect data by making requests to multiple websites asynchronously
    and print out the response HTML. Most of the time, simply printing out the HTML
    is inappropriate; instead, we'd like to write the returned HTML code to output
    files. In essence, this process is asynchronous downloading, which is also implemented
    in the underlying architecture of popular download managers. To do this, we will
    use the `aiofiles` module, in combination with `aiohttp` and `asyncio`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Writing files asynchronously
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will write a `download_html()` coroutine, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is an updated version of the `get_html()` coroutine from the last example.
    Instead of using an `aiohttp.ClientSession` instance to make a `GET` request and
    print out the returned HTML code, we now write the HTML code to the file using
    the `aiofiles` module. For example, to facilitate asynchronous file writing, we
    use the asynchronous `open()` function from `aiofiles` to read in a file in a
    context manager. Furthermore, we read the returned HTML in chunks, asynchronously,
    using the `read()` function for the `content` attribute of the response object;
    this means that after reading `1024` bytes of the current response, the execution
    flow will be released back to the event loop, and the task-switching event will
    take place.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` coroutine and the main program of this example remain relatively
    the same as those in our last example, as we can see here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `main()` coroutine takes in a URL and passes it to the `download_html()`
    coroutine, along with an `aiohttp.ClientSession` instance. Finally, in our main
    program, we create an event loop and pass each item in a specified list of URLs
    to the `main()` coroutine. After running the program, your output should look
    like this, although the time it takes to run the program might vary:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Additionally, a subfolder named `output` (inside of the `Chapter18` folder)
    will be filled with the downloaded HTML code from each website in our list of
    URLs. Again, these files were created and written asynchronously, via the functionalities
    of the `aiofiles` module, which we discussed earlier. As you can see, to compare
    the speed of this program and its corresponding synchronous version, we are also
    keeping track of the time it takes to run the entire program.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, head to the `Chapter11/example6.py` file. This script contains the code
    of the synchronous version of our current program. Specifically, it makes HTTP
    `GET` requests to individual websites in order, and the process of file writing
    is also implemented sequentially. This script produced the following output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While it achieved the same results (downloading the HTML code and writing it
    to files), our sequential program took significantly more time than its asynchronous
    counterpart.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming can provide functionalities that complement the process
    of efficiently facilitating communication channels. Together with the `aiohttp`
    module, `asyncio` offers efficiency and flexibility regarding client-side communication
    processes. The `aiofiles` module, which can work in conjunction with the other
    two asynchronous programming modules, can also help to facilitate asynchronous
    file reading and writing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now explored three of the biggest, most important topics in concurrent
    programming: threading, multiprocessing, and asynchronous programming. We have
    shown how each of them can be applied to various programming problems and provide
    significant improvements in speed. The code we developed in this chapter serves
    as a base that may be easily modified to build more complex applications.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter of this book, we will start to discuss problems that concurrent
    programming commonly poses to developers and programmers, starting with deadlocks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a communication channel? What is its connection to asynchronous programming?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two main parts of the OSI model protocol layers? What purpose does
    each of them serve?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the transport layer? Why is it crucial to communication channels?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `asyncio` facilitate the implementation of server-side communication
    channels?
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does `asyncio` facilitate the implementation of client-side communication
    channels?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `aiofiles`?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '*IoT Systems and Communication Channels* (br`idgera.com/iot-communication-channels/`),
    by *Bridgera*'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automate the Boring Stuff with Python: Practical Programming for Total Beginners*,
    *Al Sweigart*, *No Starch Press*'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用Python自动化无聊的事情：适合完全初学者的实用编程*，*Al Sweigart*，*No Starch Press*'
- en: '*Transports and protocols* (`docs.python.org/3/library/asyncio-protocol`),
    Python documentation'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传输和协议* (`docs.python.org/3/library/asyncio-protocol`), Python文档'
