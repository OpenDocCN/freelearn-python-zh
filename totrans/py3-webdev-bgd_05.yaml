- en: Chapter 5. Entities and Relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most real life applications sport more than one entity and often many of these
    entities are related. Modeling these relations is one of the strong points of
    a relational database. In this chapter, we will develop an application to maintain
    lists of books for multiple users.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and implement a data model consisting of several entities and relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement reusable entity and relation modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look in depth at the necessity of clearly separating layers of functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And encounter jQuery UI's autocomplete widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So let's get started with it...
  prefs: []
  type: TYPE_NORMAL
- en: Designing a book database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to design our application, let's have a good look at the different
    entities that need to be handled by it. The entities we recognize are a book,
    an author, and a user. A book may have many attributes, but here we limit ourselves
    to a title, an ISBN (International Standard Book Number), and a publisher. An
    author has just a name, but of course, if we would like to extend that with extra
    attributes, like the date of birth or nationality, we can always add that later.
    Finally, a user is an entity with a single attribute as well, the user ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important part is to have a clear understanding of the relations between
    these entities. A book may be written by one or more authors, so we need to define
    a relation between a book entity and an author entity. Also, any number of users
    may own a copy of a book. This is another relation we have to define, this time,
    between a book entity and a user entity. The following diagram may help to see
    those entities and their relations more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a book database](img/3746OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'These three entities and the relations between them need to be represented
    in two realms: as database tables and as Python classes. Now we could model each
    entity and relation separately, like we did in the previous chapter for the `tasklist`
    application, but all entities share a lot of common functionality so there are
    ample opportunities for reuse. Reuse means less code and less code equals less
    maintenance and often better readability. So let''s see what we need to define
    a reusable `Entity` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The Entity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From what we learned in the previous chapters, we already know there is a shared
    body of functionality that each class that represents an entity needs to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: It needs to be able to verify that a corresponding table exists in the database
    and create one if it doesn't.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It needs to implement a way to manage database connections in a thread-safe
    manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, each entity should present us with a **CRUD** interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Create* new object instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Retrieve* individual object instances and find instances that match some criteria'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Update* the attributes of an object instance and synchronize this data to
    the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Delete* an object instance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is a lot of shared functionality, but of course a book and an author are
    not identical: They differ in the number and type of their attributes. Before
    we look at the implementation, let''s illustrate how we would like to use an `Entity`
    class to define a specific entity, for example, a car.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action using the Entity class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us first define for ourselves how we want to use an `Entity` class, because
    the interface we create must match as closely as possible the things we would
    like to express in our code. The following example shows what we have in mind
    (available as `carexample.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/carexample.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea is to create a `Car` class that is a subclass of `Entity`. We therefore
    have to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `Entity` class from the `entity` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `Car` class. The body of this class is completely empty as we simply
    inherit all functionality from the `Entity` class. We could, of course, augment
    this with specific functionality, but in general, this shouldn't be necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a connection to the database. Before we can work with the `Car` instances,
    an application has to initialize a connection to the database for each thread.
    In this example, we do not create extra threads, so there is just the single main
    thread of the application that needs a connection to the database. We create one
    here with the `threadinit()` method (highlighted).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure an appropriate table with the necessary columns exists in the database.
    Therefore, we call the `inittable()` method with arguments that specify the attributes
    of our entity with possibly extra information on how to define them as columns
    in a database table. Here we define three columns: `make, model`, and `licenseplate`.
    Remember that SQLite doesn''t need explicit typing, so `make` and `model` are
    passed as arguments with just an empty string as the value. The `licenseplate`
    attribute, however, is adorned with a `unique` constraint in this example.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can work with `Car` instances, as illustrated in the lines that create
    two different objects or in the last few lines that retrieve the IDs of all `Car`
    records in the database and instantiate `Car` instances with those IDs to print
    the various attributes of a `Car`.
  prefs: []
  type: TYPE_NORMAL
- en: That is the way we would like it to work. The next step is to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example showed how we could derive the `Car` class from `Entity`
    and use it. But what does that `Entity` class look like?
  prefs: []
  type: TYPE_NORMAL
- en: The definition for the `Entity` class starts off with defining a class variable
    `threadlocal` and a class method `threadinit()` to initialize this variable with
    an object that holds data that is local to each thread (the full code is available
    as `entity.py)`.
  prefs: []
  type: TYPE_NORMAL
- en: If this `threadlocal` object does not yet have a `connection` attribute, a new
    connection to the database is created (highlighted) and we configure this connection
    by setting its `row_factory` attribute to `sqlite.Row`, as this will enable us
    to access columns in the results by name.
  prefs: []
  type: TYPE_NORMAL
- en: We also execute a single `pragma foreign_keys=1` statement to enable the enforcing
    of foreign keys. As we will see, when we discuss the implementation of relations,
    this is vital in maintaining a database without dangling references. This `pragma`
    must be set for each connection separately; therefore, we put it in the thread
    initialization method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next is the `inittable()` method. This should be called once to verify that
    the table necessary for this entity already exists or to define a table with suitable
    columns if it doesn't. It takes any number of keyword arguments. The names of
    the keywords correspond to the names of the columns and the value of such a keyword
    may be an empty string or a string with additional attributes for the column,
    for example, `unique` or an explicit type like `float`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although SQLite allows you to store a value of any type in a column, you may
    still define a type. This type (or more accurately, **affinity)** is what SQLite
    tries to convert a value to when it is stored in a column. If it doesn't succeed,
    the value is stored as is. Defining a column as float, for example, may save a
    lot of space. More on these affinities can be found on [http://www.sqlite.org/datatype3.html](http://www.sqlite.org/datatype3.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The column definitions are stored in the `columns` class variable for later
    use by the `__init__()` method and joined together to a single string. This string,
    together with the name of the class (available in the `__name__` attribute of
    a (possibly derived) class) is then used to compose a SQL statement to create
    a table (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: Besides the columns that we defined based on the keyword arguments, we can also
    create a primary key column that will be filled with a unique integer automatically.
    This way, we ensure that we can refer to each individual row in the table later
    on, for example, from a bridging table that defines a relation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take our previous car example, we see that a Python statement like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Is converted to the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the order in which we pass the keyword arguments to the `inittable()`
    method is not necessarily preserved as these arguments are stored in a `dict`
    object, and regular `dict` objects do not preserve the order of their keys.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes preserving the order of the keys in a dictionary is very desirable.
    In this case, column order doesn't matter much, but Python does have an `OrderedDict`
    class available in its `collections` module (see [http://docs.python.org/library/collections.html#collections.OrderedDict)](http://docs.python.org/library/collections.html#collections.OrderedDict))
    that we could have used. However, this would prevent us from using keywords to
    define each column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that there isn''t any form of sanity checking implemented: anything
    may be passed as a value for one of the column definitions. Judging whether that
    is anything sensible is left to SQLite when we pass the SQL statement to the database
    engine with the `execute()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: This method will raise an `sqlite3.OperationalError` if there is a syntax error
    in the SQL statement. However, many issues are simply ignored. If we pass an argument
    like `licenseplate="foo`", it would happily proceed, assuming `foo` to be a type
    it doesn't recognize, so it is simply ignored! If the execution didn't raise an
    exception, we finish by committing our changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero checking your input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Silently ignoring things passed as arguments is not considered a good habit.
    Without explicit checking, a developer might not even know he/she has done something
    wrong, something that might backfire later.
  prefs: []
  type: TYPE_NORMAL
- en: How would you implement code to restrict the value to a limited set of directives?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Types and constraints in a SQL column definition mostly consist of single
    words. You could check each word against a list of allowable types, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action creating instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next method we look at is the constructor the `__init__()` method. It will
    be used to create individual instances of an entity. The constructor can be called
    in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: With a single `id` argument, in which case, an existing record will be retrieved
    from the database and the instance initialized with the column values of this
    record, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a number of keyword arguments to create a new instance and save this as
    a new database record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code to implement this behavior looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code reflects this dual use. After checking that all keywords indeed refer
    to the previously defined columns (highlighted), it checks whether it was passed
    an `id` argument. If it was, there shouldn't be any other keyword arguments. If
    there are additional keywords, an exception is raised. If the `id` argument is
    present, an SQL statement is constructed next that will retrieve the records from
    the associated table. Each record's primary key should match the ID.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the primary key is unique, this will match at most a single record,
    something that is verified after we retrieve the matching records. If we didn't
    fetch exactly one (1) record, an exception is raised (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: If everything went well, we initialize the attributes of the instance we are
    creating with the built-in `setattr()` function. The columns of the record we
    retrieved can be accessed by name because we initialized the `row_factory` attribute
    of the connection object to a `sqlite3.Row`. We also stored the names of the columns
    in the `columns` class variable and this lets us initialize the instance's attributes
    with the values of the corresponding column names (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a `Car` instance with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Will result in a SQL statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Where the question mark is a placeholder for the actual value that is passed
    to the `execute()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second branch of the code (starting at the `else` clause) is executed if
    no `id` argument was present. In this case, we separate the keyword names and
    values and set the attributes of the instance we are creating. The keyword names
    and values are then used to construct an SQL statement to insert a new row in
    the table associated with this `Entity` (highlighted). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Will give us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The question marks are again placeholders for the values we pass to the `execute()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: If calling the `execute()` method (highlighted) went well, we initialize the
    `id` attribute of the instance we are creating with the value of the `lastrowid`
    attribute. Because we defined the primary key as a `primary key integer autoincrement`
    column and did not specify it in the insert statement, the primary key will hold
    a new unique integer and this integer is available as the `lastrowid` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is very SQLite-specific and the primary key should be defined in exactly
    this way for this to hold true. More on this can be found at [http://www.sqlite.org/lang_createtable.html#rowid](http://www.sqlite.org/lang_createtable.html#rowid)
  prefs: []
  type: TYPE_NORMAL
- en: Any `sqlite3.IntegrityError` that might be raised due to the violation of a
    uniqueness constraint is caught and re-raised as a `ValueError` with slightly
    more meaningful text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update()` method is used to synchronize an instance with the database.
    It can be used in two ways: we can alter any attributes of an instance first and
    then call `update()`, or we may pass keyword arguments to `update()` to let `update()`
    alter the corresponding attributes and synchronize the instance to the database.
    These two ways may even be combined. Either way, the database will hold the most
    current values of all attributes corresponding to a column once the `update()`
    returns. The following two pieces of code are therefore equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Any keyword arguments we pass to `update()` should match a column name, otherwise
    an exception is raised (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The column names and the values of the corresponding attributes are then used
    to construct an SQL statement to update records with these values, but only for
    the single record whose primary key matches the ID of the instance we are updating.
    The SQL statement might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The question marks again are placeholders for the values we pass to the `execute()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: After we execute this statement, we do a sanity check by validating that the
    number of affected records is indeed one. Just as for an insert statement, this
    number is available as the `rowcount` attribute of the cursor object after an
    update statement (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting an instance is implemented by the `delete()` method of the `Entity`
    class and consists primarily of composing an SQL statement that will delete the
    record with a primary key equal to the `id` attribute of the instance. The resulting
    SQL looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like in the `update()` method, we end with a sanity check to verify that
    just a single record was affected (highlighted). Note that `delete()` will only
    remove the record in the database, not the Python instance it is called on. If
    nothing references this object instance, it will be automatically removed by the
    Python''s garbage collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The final method we encounter is the class method `list()`. This method may
    be used to retrieve the IDs of all instances of an entity when called without
    arguments or to retrieve the IDs of instances that match certain criteria passed
    as arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Will return a list of IDs of all cars in the database, whereas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Will return the IDs of all the Volvos in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is straightforward and starts off with creating an SQL statement
    to select all IDs from the table (highlighted). An example would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If there were any keyword arguments passed to the `list()` method, these are
    then used to construct a `where` clause that will restrict the IDs returned to
    those of the records that match. This `where` clause is appended to our general
    select statement (highlighted). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After invocation of the `execute()` method, we yield all the IDs. By using the
    `yield` statement, we have identified the `list()` method as a **generator** that
    will return the IDs found one-by-one rather than in one go. We still can manipulate
    this generator just like a list if we wish, but for very large result sets, a
    generator might be a better option as it does consume less memory, for example.
  prefs: []
  type: TYPE_NORMAL
- en: The Relation class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Relation` class is used to manage relations between individual instances
    of entities. If we have `Car` entities as well as `Owner` entities, we might like
    to define a `CarOwner` class that provides us with the functionality to identify
    the ownership of a certain car by a specific owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like entities, generic relations share a lot of common functionality: we must
    be able to create a new relation between two entities, delete a relation, and
    list related entities given a primary entity, for example, list all owners of
    a given car or all cars of a certain owner.'
  prefs: []
  type: TYPE_NORMAL
- en: Relations are stored in the database in a table, often called a **bridging table**,
    consisting of records with columns that store the IDs of both related entities.
    When an application starts using a (subclass of) the `Relation` class, we must
    verify that the corresponding table exists, and if not, create it.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action using the Relation class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at how we would like to use our `Relation` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/carexample2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Like before, we first define a `Car` class and then an `Owner` class because
    the `CarOwner` class we define and initialize in the first highlighted lines are
    only meaningful if the entities in the relation exist. The highlighted lines show
    that defining and initializing a relation follows the same general pattern as
    initializing the entities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create two `Car` entities and an `Owner` and establish a relation between
    these (second set of highlighted lines).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final lines show how we can find and print the owners of a car or the cars
    belonging to an owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these requirements for the `Relation` class are similar to those of
    the `Entity` class, so when we take a look at the code, some pieces will look
    familiar.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first method we encounter is the `threadinit()` class method (the full code
    is available as `relation.py)`. It is identical to the one we encountered in the
    `Entity` class and should be called once for every thread.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `inittable()` class method is the method that should be called once when
    we start an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It takes the two classes involved in the relations as arguments to construct
    a proper SQL statement to create a bridging table if it does not exist yet (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `CarOwner.inittable(Car,Owner)` will result in a statement like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of interesting things to note here. There are two columns
    each referring to a table by way of the `references` clause. Because we do not
    explicitly state *which* column we reference inside the table, the reference is
    made to the primary key. This is a convenient way to write this down and works
    because we always define a proper primary key for any table that represents an
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is the `on delete cascade` clause. This helps us to maintain
    something called **referential integrity**. It ensures that when the record that
    is referenced is deleted, the records in the bridging table that refer to it are
    deleted as well. This way, there will never be entries in a table that represent
    a relation that points to non-existing entities. To ensure that this referential
    integrity checking is actually performed, it is necessary to execute a `pragma
    foreign_keys = 1` instruction for each connection to the database. This is taken
    care of in the `threadinit()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is a `unique` constraint over both the columns. This effectively
    ensures that we only maintain, at most, a single entry in this table for each
    relation between two entities. That is, if I own a car, I can enter this specific
    relation only once.
  prefs: []
  type: TYPE_NORMAL
- en: If the execution of this statement went well, `inittable()` finishes with storing
    the names of the entity classes that this relation refers to in the `columns`
    class variable.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz how to check a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we make sure that the classes we are passing as arguments to the `initdb()`
    method are subclasses of `Entity?`
  prefs: []
  type: TYPE_NORMAL
- en: Relation instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `__init__()` method constructs an instance of a `Relation`, that is, we
    use it to record the relation between two specific entities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It takes the IDs of both `Entity` instances that are involved in this specific
    relation and a `stub` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__()` method is not meant to be called directly as it doesn't know
    nor check whether the IDs passed to it make any sense. It simply stores those
    IDs if the `stub` parameter is true or inserts a record in the table if it isn't.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we would use the `add()` method to create a new relationship with
    all necessary type checking. Separating this makes sense as all this checking
    is expensive and is unnecessary if we know that the IDs we pass are correct. The
    `list()` method of the `Relation` class for example retrieves only pairs of valid
    IDs so that we can use the `__init__()` method without the need for costly additional
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL statement that is constructed may look like this for a new `CarOwner`
    relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we would try to insert a second relation between the same entities, the `unique`
    constraint on both columns together would be violated. If so, the `insert or replace`
    clause would make sure that the insert statement wouldn't fail, but there still
    would be just one record with these two IDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the insert statement could fail for another reason. If either of
    the IDs we try to insert does not refer to an existing record in the table it
    refers to, it would fail with an exception `sqlite3.IntegrityError: foreign key
    constraint failed`.'
  prefs: []
  type: TYPE_NORMAL
- en: The final sanity check in the last line is to use the `rowcount` attribute to
    verify that just one record was inserted.
  prefs: []
  type: TYPE_NORMAL
- en: The `add()` method *does* make sure that the instances passed to it are in the
    correct order by checking the names of the classes against the names of the columns
    stored by the `inittable()` method. It raises a `ValueError()` if this is not
    correct, otherwise it instantiates a new relation by calling the class constructor
    with both IDs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `list()` method is meant to return a list of zero or more `Relation` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It needs to work for both sides of the relation: if we pass a `Car` instance,
    for example, to the `list()` method of the `CarOwner` class, we should find all
    records where the `Car_id` column matches the `id` attribute of the `Car` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, if we pass an `Owner` instance, we should find all records where
    the `Owner_id` column matches the `id` attribute of the `Owner` instance. But
    precisely because we gave the columns in the table that represents the relation
    meaningful names derived from the names of the classes and hence the tables, this
    is rather straightforward. For example, the SQL constructed for `CarOwner.list(car)`
    might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas the SQL for `CarOwner.list(owner)` would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is accomplished by referring to the class name of the instance passed as
    argument (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: After executing this SQL statement, the results are fetched with the `fetchall()`
    method and returned as a list of relation instances. Note that this list may be
    of zero length if there weren't any matching relations.
  prefs: []
  type: TYPE_NORMAL
- en: The last method of note defined for the `Relation` class is the `delete()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/relation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It constructs an SQL delete statement which, in our `CarOwner` example, may
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The sanity check we perform in the last line means that an exception is raised
    if the number of deleted records is not exactly one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there was not exactly one record deleted, what would that signify?
  prefs: []
  type: TYPE_NORMAL
- en: If it would be more than one, that would indicate a serious problem because
    all the constraints are there to prevent that there is never more than one record
    describing the same relationship, but if it would be zero, this would probably
    mean we try to delete the same relationship more than once.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might wonder why there isn''t any method to update a `Relation` object
    in any way. The reason is that this hardly makes any sense: either there is a
    relation between two entity instances or there isn''t. If we would like to transfer
    ownership of a car, for example, it is just as simple to delete the relation between
    the car and the current owner and then add a new relation between the car and
    the new owner.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a simple Entity and Relation framework, let's look at how we
    can use this to implement the foundation of our books application.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action defining the Books database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to create a module `booksdb.py` that uses the `entity` and
    `relation` modules to construct a data model that can be used conveniently by
    the delivery layer (the parts of the web application that deal with providing
    content to the client). We therefore have to define `Book, Author`, and `User`
    entities as well as a `BookAuthor` relation and a `UserBook` relation.
  prefs: []
  type: TYPE_NORMAL
- en: We will also provide some functions that are bit more high-level, for example,
    a `newbook()` function that checks whether a book with a given title already exists
    and that only creates a new `Book` instance if the authors are different (presumably
    because they wrote a book with the same title).
  prefs: []
  type: TYPE_NORMAL
- en: Having a separate layer that models data in terms that are meaningful in the
    context makes it easier to understand what is going on. It also keeps the delivery
    layer less cluttered and therefore easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After importing the `Entity` and `Relation` class, the first thing we do is
    define the appropriate entities and relations (the full code is available as `booksdb.py)`.
    The first function we encounter is `threadinit()` (highlighted). It is a convenience
    function that calls all the individual `threadinit()` methods of the different
    entities and relations we have defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the `inittable()` function is a convenience function that calls all
    the necessary `inittable()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It defines a `Book` as a subclass of `Entity` having a `title`, a `unique isbn`,
    and a `publisher` attribute. An `Author` is defined as a subclass of `Entity`
    with just a `name` attribute and a `User` as an `Entity` with just a `userid`
    that must be unique and cannot be null. Also, the relations that exist between
    `Book` and `Author`, and `User` and `Book` are initialized here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `newbook()` function should be used to add a new book to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It takes a `title` argument and a list of `Author` objects and any number of
    optional keywords to select a unique book if the title is not sufficient to identify
    a book. If a book with the given title and additional keywords cannot be found,
    a new `Book` object is created (highlighted). If more than one book is found that
    matches the criteria, an exception is raised.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to retrieve a list of authors associated with this book. This
    list is used to check if any author in the list of authors passed to the `newbook()`
    function is not already associated with this book. If not, this new author is
    added. This ensures we do not attempt to associate an author more than once with
    the same book, but it also makes it possible to add authors to the list of authors
    associated with an existing book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `newauthor()` function verifies that the name passed as an argument is
    not empty and is indeed a string (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Then it checks whether an author with such a name already exists. If it doesn't,
    a new `Author` object is created and returned. If only one `Author` was found,
    that one is returned without creating a new one. If the same name matched more
    than one `Author`, an exception is raised because our current data model does
    not provide the notion of more than one author with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: An application to register books is most often used to see if we already own
    a book. A function to list books matching a set of criteria should therefore be
    quite flexible to provide the end user with enough functionality to make finding
    books as simple as possible, even if the books number is in the thousands.
  prefs: []
  type: TYPE_NORMAL
- en: The `listbooks()` function tries to encapsulate the necessary functionality.
    It takes a number of keyword arguments used to match any number of books. If the
    `user` argument is present, the results returned are limited to those books that
    are owned by that user. Likewise, the `author` argument limits the results to
    books by that author. The `pattern` argument may be a string that limits the books
    returned to those whose title contains the text in the `pattern` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the number of books matching the criteria could be very large, `listbooks()`
    takes two additional parameters to return a smaller subset. This way, the delivery
    layer can offer the list of results in a page-by-page manner. The `offset` argument
    determines the start of the subset and `limit` of the number of results returned.
    If `limit` is `-1`, all results starting at the given `offset` are returned. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Would return the first three books I own that have the text blind in their title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given these requirements, the implementation of `listbooks()` is rather straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It starts by checking that any `user` argument is indeed an instance of a `User`
    entity and then finds all books owned by this user (highlighted) and converts
    this list to a **set**. It checks any `author` argument in a similar way. If neither
    an author nor a user was specified, we simply retrieve a list of all books (highlighted)
    and convert it to a set as well.
  prefs: []
  type: TYPE_NORMAL
- en: Working with sets is convenient, as sets will never contain duplicates and can
    easily be manipulated. For example, if we have a non-empty set of books associated
    with an author and a non-empty set of books owned by a user, we can obtain the
    **intersection** (that is, books both owned by the given owner and written by
    the given author) with the`&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, we end up with a list of book IDs in `lb`. This list of IDs is then
    converted to `Book` objects and sorted on the title to ensure consistent results
    when dealing with offsets (highlighted). The next step is to reduce the number
    of results to those books whose title contains the text in the `pattern` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All this matching, sorting, and filtering could have been done with SQL as well
    and probably in a more efficient manner too. However, this would mean the SQL
    would be rather complicated and we would ruin the clear distinction between the
    low-level database operations defined in the `entity` and `relation` modules and
    the more high-level operations defined here in `booksdb`. If efficiency was more
    important, that would be a valid argument, but here we choose for a clear separation
    to aid understanding, as Python is a lot easier to read than SQL.
  prefs: []
  type: TYPE_NORMAL
- en: All that is left now is to return the proper slice from the list of books based
    on the `offset` and `limit` arguments, as shown in the last line of the `listbooks()`
    function. Note that we actually return a tuple, the first item being the total
    number of matching books, the second item the actual list of matching books. This
    makes it simple to present information to the end user like 'showing items 20-29
    of 311'.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `listauthors()` function either returns a list of authors associated with
    a book if a `book` argument is given or a list of all authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It does make sure that any `book` argument is indeed an instance of a `Book`
    entity.
  prefs: []
  type: TYPE_NORMAL
- en: '`checkuser()` may be called to see if there already exists a user with the
    given username and if not creates one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Any user that uses this application should have a corresponding `User` entity,
    if he/she wants to be able to register his/her ownership of a book. This function
    makes sure this is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note that our application does not *authenticate* a user at this level, that
    is left to the delivery layer as we will see. Any authentication database the
    delivery layer uses is completely separate from the `User` entity in our books
    database. The delivery layer may, for example, use the system password database
    to authenticate a user and pass the username to this layer if the authentication
    was successful. If, at that point, the user does not yet exist in our books database,
    we can make sure he does by calling the `checkuser()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `addowner()` and `delowner()` functions are used to establish or remove
    a specific ownership relation between a book and a user. Both are thin wrappers
    around the underlying methods in the `Relation` class, but add some additional
    type checking.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This foundation will be put to good use in the next section where we will implement
    the delivery layer.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz how to select a limited number of books
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How would you select the third page of 10 books from a list of all books in
    the database?
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero cleaning up the books database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`booksdb.py` lacks a `delbooks()` function because we won''t be providing this
    functionality in our final application. It is not a disadvantage to just remove
    ownership and leave the book as is, even if it doesn''t have any owners because
    other users may register ownership by referring to this existing book without
    the need to enter it again. However, occasionally we might want to clean up the
    database. How would you implement a function that removes all books without an
    owner?'
  prefs: []
  type: TYPE_NORMAL
- en: The delivery layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because we laid a substantial foundation with the `entity, relation`, and `booksdb`
    modules, we can now cleanly separate the delivery layer from the rest of the application.
    The delivery layer consists of just a couple of CherryPy applications. To authenticate
    a user, we will reuse the logon application we encountered in previous chapters
    and the rest of the application consists of a single `Books` class with the necessary
    methods to provide two main screens: a navigable and filterable list of books
    and a screen to add new books to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action designing the delivery layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To design these screens it is often convenient to make some drawings to have
    a visual representation of the screen. This makes it a lot easier to discuss functionality
    with your client.
  prefs: []
  type: TYPE_NORMAL
- en: 'There exist a number of good applications to assist you with drawing up some
    mock ups (for example, Microsoft''s Expression Blend or Kaxaml [http://kaxaml.com/)](http://kaxaml.com/))
    but often, especially in the early stages of designing an application, a simple
    drawing will do, even if it''s hand drawn. The illustrations show the sketches
    I used in making a rough draft, both done with the GIMP (http://www.gimp.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action designing the delivery layer](img/3746_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first image is a sketch of the screen that lets the user interact with a
    list of books, the second image shows what a screen to add a new book could look
    like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action designing the delivery layer](img/3746_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Such images are easy to print and annotate during a discussion without the need
    for a computer application, all you need is a pen or pencil. Another useful designing
    technique is to draw some outline on a whiteboard and add details while you discuss
    functionality. At the end of the session, you can take a picture of the whiteboard
    with your cell phone and use that as a starting point. The design will likely
    change anyway during the development and starting with this simple approach saves
    a lot of effort that might have to be undone later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take a look at the design for the screen that lists the books we see
    immediately that the key functionality is all in the **button bar**. Notably,
    we will have to implement functionality to:'
  prefs: []
  type: TYPE_NORMAL
- en: Show a list of books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Page forward and backward through this list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the list of books to those owned by the current user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter the list of books on words occurring in the title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The screen to add a new book is deceptively simple. The user must be able to
    enter a title and an author to indicate he owns a book, but this means that in
    the background, we have at least the following scenarios to check:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no book in the database with the given title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a book with the given title but without the given author
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The combination of book and author is known
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first situation, we have to create a new `Book` entity, and possibly
    a new `Author` entity if the author is unknown.
  prefs: []
  type: TYPE_NORMAL
- en: In the second situation, we will create a new `Book` entity as well, because
    it is very well possible that different authors write books with the same title.
    In a more elaborate application, we might be able to make a distinction based
    on the ISBN.
  prefs: []
  type: TYPE_NORMAL
- en: In the last situation, we do not have to create a new `Book` or an `Author`
    entity, but we still have to make sure that we register ownership of that specific
    book.
  prefs: []
  type: TYPE_NORMAL
- en: The final requirement is one of convenience to the user. If there are many users
    entering books in the database, chances will grow that if someone registers a
    new book he/she owns, that book is already present in the database. To save the
    user some typing, it would be nice if we could present the user with a list of
    possible titles and authors while he/she types along. This is called auto completion
    and is fairly straightforward to implement with a combination of jQuery UI and
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action designing the delivery layer](img/3746_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When `booksweb.py` is started, the list of books will look like the preceding
    image and the page to add a new book is shown next. We will enhance these looks
    in the last section of this chapter, but we focus on the implementation of the
    delivery layer in `booksweb.py` first.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action designing the delivery layer](img/3746_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Auto completion is a close companion of client-side input validation. By presenting
    the user with a list of possibilities to choose from, we lower the risk of a user
    entering a similar title with a slightly different spelling. Of course there are
    some additional checks to make: a title may not be empty, for example. If the
    user does make an erroneous entry, there should also be some sort of feedback
    so he/she can correct his mistake.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, client-side validation is a useful tool to enhance the user experience,
    but it doesn't protect us from malicious attempts to corrupt our data. Therefore,
    we have implemented some server-side checks as well.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start off by creating a global variable that holds the basic HTML that we
    will use both in the booklist screen as well as in the add book screen (the full
    code is available as `booksweb.py):`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We read it in from a separate file instead of storing it inside the module as
    a string. Storing the HTML in a separate file makes it a lot easier to edit because
    the editor can use syntax highlighting for HTML instead of just marking it as
    a string literal in Python. The file is available as `basepage.html:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/basepage.html**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This time, we choose to incorporate all external libraries from Google's content
    delivery network (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: You might not want to depend on an external agency for your production application,
    but for development, this is an advantage as you don't have to lug around those
    files. But even in a production environment, this choice may make sense as this
    option will reduce the number of requests made to your server and minimize the
    bandwidth. Likewise, we refer to the cascading style sheets and accompanying files
    for our chosen theme (Smoothness) on Google's content delivery network.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides Google, a number of other large players offer a Content Delivery Network
    (CDN) that you may use. Even Microsoft (http://www.asp.net/ajaxlibrary/cdn.ashx)
    offers free access to the jQuery and jQuery UI libraries on its CDN.
  prefs: []
  type: TYPE_NORMAL
- en: The head section also contains a link to an additional style sheet `books.css`
    that will be used to tweak the layout and style of the elements that are not jQuery
    UI widgets.
  prefs: []
  type: TYPE_NORMAL
- en: The body is a single`<div>` element with a `%s` placeholder to be filled with
    different relevant markup for the booklist and new book pages, followed by a`<script>`
    tag that will provide other script elements within the specific pages with common
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '`booksweb.py` continues with the definition of the `Books` class that will
    act as the central application in the CherryPy framework for this application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `index()` function serves `basepage.html` with a single`<div>` element that
    will hold the content.
  prefs: []
  type: TYPE_NORMAL
- en: The `list()` method will be called from JavaScript functions defined in `booksweb.js`
    once it loads and will be used to fill the content`<div>` initially, as well as
    refresh the contents of this div when the buttons in the navigation button bar
    are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Before we examine the `list()` and `addbook()` methods, let's have a look at
    the JavaScript in `booksweb.js` to see how these methods are invoked from the
    AJAX calls in the client (the full JavaScript code is available as `booksweb.js)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first activity we encounter in `booksweb.js` is setting global defaults
    for all AJAX calls. We disable caching to make sure the browser executes an AJAX
    call every time we ask it to, without checking if it made a call to the same URL
    earlier, because otherwise we would not actually refresh the content of our list
    of books.
  prefs: []
  type: TYPE_NORMAL
- en: For debugging purposes, we also make sure every AJAX call uses the HTTP `GET`
    method because arguments to a `POST` call are not logged normally while arguments
    to a `GET` are part of the URL of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `prepnavbar()` function we encounter next is our workhorse: every time
    we make the URL `/books/list` get a list of books, `prepnavbar()` is called once
    the request is completed.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The HTML returned by `/books/list` not only contains the matching books, but
    also the navigation buttons themselves together with additional information on
    the number of matching books returned. These navigation buttons are not yet styled
    and configuring this is the task of the `prepnavbar()` function.
  prefs: []
  type: TYPE_NORMAL
- en: It styles each button (except for the input button that is used to filter on
    text) as a jQuery UI button widget without text but with an appropriate icon.
    It also adds the `oddline` class to each odd row of the `bookrow` class, so we
    can refer to this class in our style sheet to give it distinctive zebra stripes,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: When `booksweb.js` is executed, the content of the page consists of an empty`<div>`.
    This`<div>` element is filled with HTML returned by calling the `/books/list`
    URL with parameters (last line). The `prepnavbar()` function is passed as the
    second argument to the `load()` method and will be called once loading the data
    is completed.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining part of `booksweb.js` is filled with adding live click handlers
    to all navigation buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A live handler will be attached to any element that matches its selector, even
    elements that are not present yet in the documents. This will ensure that when
    we reload the list of books complete with new navigation buttons, the click handlers
    we define here will be bound to these new buttons as well.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these handlers call the `getparams()` function to retrieve the information
    contained in the`<p>` element with the `id="info`". This data is returned as a
    JavaScript object that may be passed to the `load()` method. The `load()` method
    will append the attributes in this object as parameters to the URL it calls. The
    information in the object reflects the currently listed books and each handler
    modifies this data according to its function.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the handler for the `#firstpage` button (highlighted) modifies
    the `offset` attribute. It simply sets it to zero before calling `/books/load`
    to retrieve the first set of books.
  prefs: []
  type: TYPE_NORMAL
- en: The handler for the `#previouspage` button subtracts the value of the `limit`
    attribute from offset to get the previous page full of books, but makes sure that
    the offset is not smaller than zero. The handlers for the other clickable buttons
    perform similar actions before calling `/books/load`.
  prefs: []
  type: TYPE_NORMAL
- en: The exception is the handler for the `#mine` button, that does not manipulate
    offsets but toggles the `checked` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `#pattern` input element is different as well. It doesn't act on a click,
    but reacts on pressing the *return* key. If that key is pressed, it also calls
    `getparams()` just like the other handlers. The object retrieved this way will
    also contain a `pattern` attribute, which holds the value of the `#pattern` input
    element that was just entered by the user. The `offset` attribute is set to zero
    to ensure that when we pass on a new pattern value, we start viewing the resulting
    list at the start.
  prefs: []
  type: TYPE_NORMAL
- en: Let's return to the server-side in `booksweb.py` and see how the `list()` method
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `list()` method takes a number of keyword arguments to determine which
    books to return. It doesn''t return a complete HTML page but just a list of`<div>`
    elements representing the selection of books together with some additional information
    on the number of books selected and the button elements used to browse through
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `offset` argument determines where the list of matching books will start.
    Counting starts at 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `limit` argument determines the number of matching books to return. This
    is a maximum, less books will be returned if they are not available. When we have
    14 matching books, an offset of 10, with a limit of 10, will return 10 books through
    13.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `mine` argument is non-zero, the list of matching books is limited to
    the ones owned by the user issuing the request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if the `pattern` argument is not an empty string, the list of matching books
    is limited to the ones that contain the pattern string in their title.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_` (underscore) argument is ignored. We configured our AJAX calls not to
    be cached (in `booksweb.js)` and jQuery prevents caching by appending each time
    an `_` argument with a random value to the URL it requests. The URL will look
    different each time to the browser this way, and this will prevent caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of the `list()` method starts off by validating that the
    user is logged in and then retrieving the corresponding `User` object. The next
    steps systematically validate the arguments passed to the method and raise a `ValueError`
    or `TypeError` if something fails to validate. The `offset` argument, for example,
    should be larger or equal to zero (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: Once the arguments are validated, these are handed off to the `booksdb.listbooks()`
    function, that will take care of the actual selection and will return a tuple
    consisting of the number of matching books and the actual list of books sorted
    on their title.
  prefs: []
  type: TYPE_NORMAL
- en: This list of books is used to step through and generate the appropriate HTML
    markup. For each book, we fetch the authors of the book (highlighted) and then
    yield a string with HTML markup. This HTML contains the title of the book and
    the name of the first author. If there is more information we would like to present,
    for example, the ISBN of the book, we could easily add it here. By using `yield`
    to return the results one-by one, we save ourselves the trouble of constructing
    a complete string first before returning it in one go.
  prefs: []
  type: TYPE_NORMAL
- en: The final `yield` statement contains a`<div>` element with the `id="navigation`".
    We choose to return the complete navigation markup, including buttons, to enable
    us to easily set the values of these buttons. The pattern`<input>` element, for
    example, should display the current text we filter on. We could pass this as separate
    information and use client-side JavaScript to set these values but this would
    complicate the JavaScript quite a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, the `offset` and `limit` values together with the total number of matching
    books is returned inside a`<p>` element. This serves two goals: we can display
    this as an informational message to the user, but it is also necessary information
    for the navigation buttons to function.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action adding a new book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The screen to add a new book to the database is a simple form. What we need
    to implement is:'
  prefs: []
  type: TYPE_NORMAL
- en: Some HTML to make it possible to display the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method in our CherryPy application that will produce this HTML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A method to process the input once this form is submitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no need to implement two different methods here because based on the
    arguments passed to the method we can decide whether to return a form or to process
    the submitted contents of the same form. Although it may be considered bad form
    to design a method to do two things, it does keep related functionality together.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `addbookform` class variable contains the template that refers to a number
    of string variables to interpolate. There is also a`<script>` element to add some
    extra functionality that we examine later:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `addbook()` method itself is used both to display the initial screen and
    to process the results, that is, it acts as the target of the`<form>` element's
    action attribute and processes the values from the various`<input>` and`<button>`
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'All arguments are therefore keyword arguments with default values. If they
    are all missing, `addbook()` will construct an empty form, otherwise it will check
    and process the information. In the latter case, there will be two possible scenarios:
    the values are ok, in which case a new book will be added and the user will be
    returned to the page with the book listing, or one or more of the values are not
    ok, in which case, the form is presented again, with suitable error markings,
    but with the entered values still in place for the user to edit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `addbook()` method first verifies if the user is logged in, and if so, fetches
    the corresponding `User` object. The next step is to check if the cancel button
    contained in the form was clicked, in which case the `cancel` argument will contain
    a value and the user will be redirected to the list of books (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a default dictionary that will return an empty string for every
    missing key that is accessed. This default dictionary will be used as interpolation
    data for strings in `addbookform`. This way we can set a number of interpolation
    variables if we want to (for example, `%(title)s` in the `value` attribute of
    the`<input>` element for a title), but if we leave anything out, it will be automatically
    replaced by an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: If the `submit` argument is equal to None, this means it wasn't present, so
    `addbook()` was called to display just the empty form and that is just what is
    done (highlighted). Because `data` contains no keys at all at this moment, *all*
    interpolation variables will yield an empty string resulting in an empty form.
  prefs: []
  type: TYPE_NORMAL
- en: If the `submit` argument was not None, we are processing the values in the form.
    First we perform a sanity check. If either the `title` or the `author` argument
    is missing, we raise an exception (highlighted). Even if the user failed to enter
    either of them, the corresponding values would be present in the arguments but
    as empty strings. So, if either of these arguments is missing completely, this
    cannot be the result of a user action and therefore it is sensible to raise an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: If both arguments are present, we save them in the default dictionary so that
    we can redisplay them as default values in the form, if we need to present the
    form again.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to try the `newauthor()` function from the `booksdb` module.
    It either returns a valid `Author` object (because we already know the author
    or a new one was created) or it raises an exception. Such an exception is caught
    and the error text is added to the `authorerror` key in the dictionary together
    with some HTML class attributes that will enable us to display the corresponding`<input>`
    element in a suitable manner to indicate the error condition.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a valid `Author` object, the same approach is used to retrieve
    a valid `Book` object. This may fail (mainly if the `title` argument is an empty
    string) in which case we set the `titleerror` key in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: We end with establishing an ownership relation between the user and the book
    with a call to the `addowner()` function and then redirect the user to the page
    that lists the books.
  prefs: []
  type: TYPE_NORMAL
- en: If anything goes wrong, we catch some exception and we end up at the return
    statement which will return the form again, only this time the dictionary will
    hold some keys that will be interpolated, resulting in suitable default values
    (for example, if a `title` argument was empty, but the `author` argument wasn't,
    the user doesn't have to enter the name of the author again) and information on
    the errors encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this string interpolation business might be a bit daunting, so let''s have
    a brief look at an example. The definition for the title`<input>` element in the
    `addbookform` variable looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to present the user with an empty form, the string is interpolated
    with a default dictionary that holds no keys. The references `%(title)s` and `%(titlerror)s`
    will therefore come up with empty strings resulting in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: A plain`<input>` element without a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if something went wrong with locating or creating an author, the dictionary
    would hold a `title` key but no `titleerror` key (but it would have an `authorrerror`
    key). Assuming that the title entered by the user was "A book title", the resulting
    interpolation would therefore look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if there was an error with the title, for example, because no book
    title was entered by the user, both the `title` key would be present (albeit,
    in this case, as an empty string) and the `titleerror` key. The value of the `titleerror`
    key holds both the error message as an HTML `title` attribute together with an
    HTML `class` attribute that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'So the final interpolation would result in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Auto completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we presented the HTML markup for the page that shows a form to add a new
    book, we skipped over the`<script>` element at the end. That script element is
    used to augment the title and author`<input>` elements with **auto completion**.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action using input fields with auto completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the`<script>` element in place, the input elements can now retrieve possible
    completions with an AJAX call. Now, when we enter a few characters in an input
    field, we are presented with a list of choices, as shown in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action using input fields with auto completion](img/3746_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's look in some detail at how this is implemented in, remarkably, a few lines
    of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we look at the code again, we see that we call the `autocomplete()` method
    on both the `#title` and `#author <input>` elements, but each with a different
    source argument. The **autocomplete widget** in jQuery UI is very versatile and
    simple to apply (The code shown is part of `booksweb.py`, but we skipped this
    earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `source` attribute of the options object we pass to the `autocomplete()`
    method holds a URL that will be used to retrieve a list of possible completions
    for the characters entered so far.
  prefs: []
  type: TYPE_NORMAL
- en: The `minLength` attribute ensures that we only start looking for possible completions
    once the user has entered at least two characters, otherwise the list would probably
    be enormous and not much of a help. Note that it is still possible to enter a
    completely new value into an input field. The user is not obliged to pick an item
    from the list presented and can keep on typing.
  prefs: []
  type: TYPE_NORMAL
- en: The autocomplete widget adds the text entered so far as the `term` argument
    to the `source` URL. When the user has typed 'foo' in the `#author <input>` element,
    this will result in a call to a URL like `/books/getauthors?term=foo&_=12345678`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the `gettitles()` and `getauthors()` methods will both take
    a `term` argument (and an `_` (underscore) argument to ensure nothing is cached):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Both methods simply pass on the request to the corresponding `booksdb` functions,
    but because autocomplete widgets expect the result as a JSON encoded string, we
    convert the list with the `json.dumps()` function before returning it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksdb.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions `getauthors()` and `gettitles()` in `booksdb.py` could have simply
    retrieved a list of `Author` or `Book` objects respectively and extracted the
    `name` or `title` attributes. This would have been fairly slow, however, as creating
    potentially a lot of objects is costly in terms of processing power. Moreover,
    since we are really interested in just a list of strings and not in whole objects,
    it is worthwhile to implement a `getcolumnvalues()` method in the `Entity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`getcolumnvalues()` first checks if the requested column exists in this `Entity`
    (sub)class and raises an exception if it doesn''t. Then it constructs a SQL statement
    to return the values in the requested column, sorted without regard for case (highlighted).
    The result is a list of tuples consisting of a single item and this is converted
    to a simple list of items before returning it.'
  prefs: []
  type: TYPE_NORMAL
- en: The presentation layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have implemented the delivery layer, the application is almost usable,
    but looks a bit rough on the edges. Although some components already look quite
    good due to the styling inherent in the jQuery UI widgets used, other parts need
    some serious tweaking.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action using an enhanced presentation layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The additional JavaScript code and CSS information is part of `booksweb.js`
    and `booksweb.css` respectively. The following illustrations show the end results
    for the page with the list of books and the page to add a new book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action using an enhanced presentation layer](img/3746_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We added some zebra stripes to aid readability and changed the look of the column
    headings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action using an enhanced presentation layer](img/3746_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The page to add a book had its buttons styled in the same style as the buttons
    on the page with the list of books. Also, the layout was cleaned up and functionality
    was added to present any errors returned in a clearly visible way (in the last
    example, the title is empty so the background is red).
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action using an enhanced presentation layer](img/3746_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To effect the changes seen in the previous images, we added the following lines
    of JavaScript to `booksweb.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter5/booksweb.js**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The effect is just to alter the appearance of the buttons, not to add to their
    functionality with some sort of event handler because there is no need for this.
    The page contains a regular`<form>` element with a valid `action` attribute, so
    our submit and cancel buttons will behave as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the changes, including borders, fonts, and colors are implemented
    in `booksweb.css`, which we do not examine here as the CSS contained in it is
    very straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a lot in this chapter about designing and implementing a web
    application around a data model consisting of several entities and relations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to design the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a reusable entity and relation framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to maintain a clear separation between database, object layer, and delivery
    layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement auto completion using jQuery UI's autocomplete widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discussed the importance of input validation, both client-side and server-side.
  prefs: []
  type: TYPE_NORMAL
- en: We did not yet wield the full power of our entity and relation framework and
    input validation might be much more involved. To exercise our new skills and expand
    them, the next chapter will be about designing and building a wiki application.
  prefs: []
  type: TYPE_NORMAL
