- en: Chapter 9. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章 测试
- en: Until now, we have reviewed the different steps involved in building the photoblog
    application but we have not tested our design and implementation. This chapter
    will introduce some testing techniques such as unit, functional, and load testing
    using open-source products such as unittest, CherryPy webtest, FunkLoad, and Selenium.
    By the end of this chapter, you should have a good understanding of how to use
    these tools in their context and improve the test suite for your applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经回顾了构建照片博客应用程序所涉及的不同步骤，但我们还没有测试我们的设计和实现。本章将介绍一些测试技术，例如使用开源产品如unittest、CherryPy
    webtest、FunkLoad和Selenium进行的单元测试、功能测试和负载测试。到本章结束时，你应该能够很好地理解如何在特定环境中使用这些工具，并改进你应用程序的测试套件。
- en: Why Testing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要测试
- en: Why testing, some might wonder? Does it bring any value to the application?
    You may believe that if a problem is found in your code, it will be reported and
    eventually be fixed. Therefore, you may argue that testing is fairly irrelevant
    and is time consuming. If you do believe this, then with the help of this chapter
    we will try to show you that testing is not just the cherry on the cake but actually
    it is part of the recipe for success.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要测试，有些人可能会问？它能为应用程序带来任何价值吗？你可能会认为，如果你的代码中发现了问题，它将被报告并最终得到修复。因此，你可能会认为测试相当无关紧要且耗时。如果你确实这样认为，那么在本章的帮助下，我们将尝试向你展示测试不仅仅是蛋糕上的樱桃，实际上它是成功配方的一部分。
- en: 'Testing is a process during which the application is audited from different
    perspectives in order to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个过程，在这个过程中，从不同的角度对应用程序进行审计，以便：
- en: Find bugs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现错误
- en: Find differences between the expected and real result, output, states, etc.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找出预期结果和实际结果、输出、状态等之间的差异。
- en: Understand how complete the implementation is
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解实现的完整性
- en: Exercise the application in realistic situations before its release
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布前在现实场景中测试应用程序
- en: The goal of testing is not to put the developer at fault but to provide tools
    to estimate the health of the application at a given time. Testing measures the
    quality of an application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的目标不是将责任归咎于开发者，而是提供工具来估计在特定时间点应用程序的健康状况。测试衡量应用程序的质量。
- en: Testing is, therefore, not just a part of the application life cycle but is
    actually the true barometer of where the application stands in that cycle. Lines
    of code are meaningless; but test summary and test reports are the reference points
    that the different members of a project can relate to for understanding what has
    been achieved, what still needs to be achieved, and how to plan it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试不仅只是应用程序生命周期的一部分，实际上它是衡量应用程序在该生命周期中位置的真正晴雨表。代码行数没有意义；但测试总结和测试报告是不同项目成员可以联系起来了解已实现的内容、还需要实现的内容以及如何规划它们的参考点。
- en: Planning a Test
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试规划
- en: From the previous section we can say that since testing is so critical to a
    project, everything should be tested and reviewed. This is true, but it does not
    mean the same amount of resources and efforts should be allocated to every part
    of the system under test.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一节中我们可以得出，由于测试对项目至关重要，因此应该对一切进行测试和审查。这是真的，但这并不意味着应该将相同数量的资源和努力分配给测试系统中的每个部分。
- en: First of all, it depends on the position of the project in its life cycle. For
    instance, there is little need for performance testing right at the beginning
    of the project. There might not be a need for capacity testing, if the application
    does not require lots of hardware or network resources. That being said some tests
    will be carried all along the life cycle of the project. They will be built up
    by successive iterations bringing more strength to the test each time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这取决于项目在其生命周期中的位置。例如，在项目开始时进行性能测试的需求很小。如果应用程序不需要大量的硬件或网络资源，可能不需要进行容量测试。话虽如此，一些测试将在项目的整个生命周期中进行。它们将通过连续的迭代逐步建立，每次迭代都会使测试更具强度。
- en: 'To summarize, testing needs to be planned in advance in order to define:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，测试需要提前规划，以便定义：
- en: 'Goals: What is it relevant to test and for what purpose?'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标：测试哪些内容与其相关，以及为了什么目的？
- en: 'Scope: What is in the scope of the test? What is not?'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：测试的范围包括什么？不包括什么？
- en: 'Requirements: What will the test involve in terms of resources (human, software,
    hardware, etc.)?'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求：测试将涉及哪些资源（人力、软件、硬件等）？
- en: 'Risks: What are the risks related to that test if it does not pass? What will
    be the mitigation and action taken? Will it stop the project? What is the impact?'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风险：如果测试未通过，与该测试相关的风险是什么？将采取哪些缓解措施和行动？它是否会停止项目？影响是什么？
- en: These are just a few points to be kept in mind while planning a test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划测试时，只需记住以下几点。
- en: Another important point is that testing does not end once the application is
    released. It can also be carried on later so that the production release meets
    the defined requirements. In any case, since testing draws together so many different
    aspects it should be seen as a long, continuous process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的一点是，测试一旦应用程序发布并不意味着结束。它也可以在之后进行，以确保生产发布满足定义的要求。在任何情况下，由于测试汇集了众多不同方面，因此应将其视为一个漫长、持续的过程。
- en: Common Testing Approach
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见测试方法
- en: 'Testing is a generic term for a range of aspects to be validated on a system
    or application. Here is a brief list of the common ones:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是对系统或应用程序上要验证的一系列方面的通用术语。以下是一个简要的常见列表：
- en: 'Unit testing: Usually carried by the developers themselves. Unit tests aim
    at checking whether a unit of code works as expected.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试：通常由开发者自己执行。单元测试旨在检查代码单元是否按预期工作。
- en: 'Usability testing: Developers may usually forget that they are writing an application
    for end users who do not have knowledge of the system and might end up making
    it unusable. Functional and usability tests provide a way to make sure that applications
    will fulfill user expectations.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试：开发者可能通常忘记他们正在为最终用户编写应用程序，而这些用户可能不了解系统，最终可能导致应用程序不可用。功能和可用性测试提供了一种确保应用程序将满足用户期望的方法。
- en: 'Functional/Acceptance testing: While usability testing checks whether the application
    or system is usable, functional testing ensures that every specified functionality
    is implemented.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能/验收测试：虽然可用性测试检查应用程序或系统是否可用，但功能测试确保每个指定的功能都已实现。
- en: 'Load and performance testing: Once an application or system has reached a certain
    level of completeness, it may require load and performance tests to be conducted
    in order to understand whether the system can cope with its expected peak load
    and to find potential bottlenecks. This can lead to changing hardware, optimizing
    SQL queries, etc.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和性能测试：一旦应用程序或系统达到一定程度的完整性，可能需要进行加载和性能测试，以了解系统是否能够应对预期的峰值负载，并找到潜在瓶颈。这可能导致更改硬件、优化SQL查询等。
- en: 'Regression testing: Regression testing verifies that successive releases of
    a product do not break any of the previously working functionalities. Unit testing
    can be considered as a part of regression testing in some ways.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回归测试：回归测试验证产品连续发布不会破坏任何之前工作的功能。在某些方面，单元测试可以被视为回归测试的一部分。
- en: 'Reliability and resilience testing: Some applications or systems cannot afford
    to break at any time. Reliability and resilience tests can validate how the system
    application copes with the breakdown of one or several components.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性和弹性测试：某些应用程序或系统不能承受在任何时候崩溃。可靠性和弹性测试可以验证系统应用程序如何应对一个或多个组件的故障。
- en: The previous list is far from being exhaustive and each system or application
    environment may require specific types of testing to be defined.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表远非详尽无遗，每个系统或应用程序环境可能需要定义特定的测试类型。
- en: Unit Testing
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Our photoblog application will extensively use unit tests in order to constantly
    check the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的照片博客应用程序将广泛使用单元测试来不断检查以下内容：
- en: New functionalities work correctly and as expected.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新功能按预期正确工作。
- en: Existing functionalities are not broken by new code release.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码发布不会破坏现有功能。
- en: Defects are fixed and remain fixed.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺陷已修复且保持修复状态。
- en: Python comes in with a standard `unittest` module and also provides a `doctest`
    module offering a different approach to unit testing as we will explain later
    on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个标准的 `unittest` 模块，还提供了一个 `doctest` 模块，它提供了一种不同的单元测试方法，我们将在后面解释。
- en: unittest
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest
- en: '`unittest` is rooted in JUnit, a Java unit test package developed by Kent Beck
    and Erich Gamma, which in turn came from a Smalltalk testing framework developed
    by Kent Beck. Let''s now review a basic example of this module.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 源于由 Kent Beck 和 Erich Gamma 开发的 Java 单元测试包 JUnit，而 JUnit 又源于 Kent
    Beck 开发的 Smalltalk 测试框架。现在让我们回顾一下这个模块的基本示例。'
- en: Unit tests can often work on mock objects that are so called because they support
    the same interface as the domain objects of the applications but do not actually
    perform any work. They simply return defined data. Mock objects therefore allow
    testing against an interface of our design without having to rely on the overall
    application to be deployed for instance. They also provide a way to run tests
    in isolation mode from other tests.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常可以在所谓的模拟对象上工作，这些对象支持与应用程序的域对象相同的接口，但实际上并不执行任何操作。它们只是返回定义好的数据。因此，模拟对象允许我们对我们的设计接口进行测试，而无需依赖于整个应用程序的部署。它们还提供了一种从其他测试中独立运行测试的方法。
- en: 'First let''s define a dummy class as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个模拟类，如下所示：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class provides an interface to get the next or previous value within a
    range defined by the left and right boundaries. We could imagine it as a mock
    object of a more complex class but providing dummy data.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一个接口，用于在由左右边界定义的范围内获取下一个或上一个值。我们可以将其想象为一个更复杂类的模拟对象，但提供的是模拟数据。
- en: 'A simple usage of this class is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的简单用法如下：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's imagine we wish to unit test this exciting module to make sure that the
    code is correct.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们希望对这个令人兴奋的模块进行单元测试，以确保代码的正确性。
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s explain this code step by step:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地解释这段代码：
- en: 1\. To provide unit test capabilities using the `unittest` standard module you
    only need to import that specific module.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 要使用`unittest`标准模块提供单元测试功能，你只需要导入该特定模块。
- en: 2\. Create a class that subclasses `unittest.TestCase`, which is the interface
    providing unit test functionalities to our code. This class is referred to as
    a **test case**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 创建一个类，它继承自`unittest.TestCase`，这是为我们代码提供单元测试功能的接口。这个类被称为**测试用例**。
- en: 3\. Create methods starting with the word `test`. Each method starting with
    it will be called by the `unittest` internal handler. Notice that the methods
    this class defines also use a two-digit pattern. This is not required by `unittest`
    but it allows us to force methods to be called in the order we wish. Indeed `unittest`
    calls methods by alpha-numeric order, which can sometimes lead to unexpected results.
    Providing digits like this is a good way to work around that limitation.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 创建以单词`test`开头的方法。每个以它开头的方法都将由`unittest`内部处理程序调用。请注意，这个类定义的方法也使用两位数的模式。这并不是`unittest`的要求，但它允许我们强制方法按照我们希望的顺序调用。实际上，`unittest`按照字母数字顺序调用方法，这有时会导致意外结果。提供这样的数字是一种很好的方法来绕过这种限制。
- en: 4\. Call the different `assert/fail` methods provided by the `TestCase` class
    to perform checking of values, exceptions, outputs, etc.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 调用`TestCase`类提供的不同`assert/fail`方法来执行值、异常、输出等的检查。
- en: 'The next step is to run this test case as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是按照以下方式运行这个测试用例：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This assumes that the call to `main()` is done from within the same module
    containing the `TestCase` class. The result of this test looks like the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设`main()`的调用是在包含`TestCase`类的同一模块中进行的。这个测试的结果看起来如下：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is common to make the output a little more verbose as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会将输出设置得更加详细，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will produce the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let''s provoke an error so that one of the tests fails. In `test_01_forward`
    replace the first `assertEqual` with the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们引发一个错误，以便其中一个测试失败。在`test_01_forward`中将第一个`assertEqual`替换为以下内容：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then while running the test again you should get the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在再次运行测试时，你应该得到以下输出：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the `unittest` module does not stop processing any remaining
    test cases when one fails. Instead, it displays the traceback of the raised assertion
    error. Here the test is wrong but in the case where your assertion is a valid
    one, it would point to a failure of your application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`unittest`模块在测试失败时不会停止处理任何剩余的测试用例。相反，它显示抛出的断言错误的跟踪信息。这里的测试是错误的，但在你的断言是有效的情况下，它将指向你的应用程序的失败。
- en: Let's assume that we write a test that tries to go forward when the right boundary
    is less than the starting point. We assume that the documentation of the method
    tells us that it should raise an exception expressing the fact that the class
    has rejected this case.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们编写了一个测试，试图在右边界小于起点时向前移动。我们假设该方法的文档告诉我们，它应该抛出一个异常，表示该类已拒绝此情况。
- en: 'Let''s create `test_00_construct` accordingly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们相应地创建`test_00_construct`：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s run the test now:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在运行这个测试：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see the test case does fail on the new test we have included. The
    reason is that the `Dummy.__init__()` method does not contain any error handling
    for this case unlike what the documentation told us. Let''s fix this by adding
    the following code at the bottom of the `__init__` method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，新的测试用例确实失败了。原因是`Dummy.__init__()`方法没有包含任何对此情况的错误处理，这与文档告诉我们的不同。让我们通过在`__init__`方法底部添加以下代码来修复这个问题：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s now re-run the test:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们重新运行测试：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The previous example shows that it is sometimes desirable to write the test
    before implementing the functionality itself in order to avoid designing the test
    to match the code behavior. This is often called test-driven development. Another
    way to achieve this is to provide the API of the application or library to a third
    party, who will write the test case based on that API in a neutral fashion. Either
    way the previous example demonstrates that unit testing is only relevant when
    the tests are coherent with the design and are there to test the implementation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子表明，有时在实现功能本身之前编写测试是有好处的，这样可以避免设计测试以匹配代码行为。这通常被称为测试驱动开发。另一种实现方式是将应用程序或库的API提供给第三方，第三方将根据该API以中立的方式编写测试用例。无论如何，之前的例子表明，单元测试只有在测试与设计一致并且用于测试实现时才有意义。
- en: Now that we have introduced the `unittest` module let's present the `doctest`
    one.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了`unittest`模块，让我们来介绍`doctest`模块。
- en: doctest
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doctest
- en: The `doctest` module supports running Python code inlined within an object docstring.
    The advantage of this technique is that test cases are close to the code they
    test. The inconvenience is that some complex tests can be difficult to achieve
    this way. Let's see an example on the class we have defined earlier.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块支持在对象docstring中运行内联的Python代码。这种技术的优点是测试用例与它们要测试的代码非常接近。不便之处在于，一些复杂的测试可能难以用这种方式实现。让我们看看我们之前定义的类的一个例子。'
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, each method you wish to test must have a docstring containing
    use cases that will be run as-is by the `doctest` module.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，你希望测试的每个方法都必须有一个包含将直接由`doctest`模块运行的用例的docstring。
- en: 'Then you can run the test as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以按照以下步骤运行测试：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We do not reproduce the complete result trace as it is too long for the purpose
    of the chapter. You may consider that mixing code and documentation will reduce
    the efficiency of both, making the documentation harder to read. This concern
    is actually raised by the `doctest` module documentation itself, which sensibly
    advises handling *docstring examples with care*. Indeed, since the code belongs
    to the docstring, it will be displayed while viewing it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有复制完整的输出结果，因为对于本章的目的来说，它太长了。你可以考虑，将代码和文档混合在一起可能会降低两者的效率，使得文档更难以阅读。这个担忧实际上是由`doctest`模块的文档本身提出的，它明智地建议要小心处理*docstring示例*。确实，由于代码属于docstring，所以在查看时也会显示出来。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In such cases the tests can either be part of the documentation itself or be
    too complex making the documentation unusable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，测试可以是文档的一部分，或者过于复杂，使得文档无法使用。
- en: In a nutshell both the `unittest` and `doctest` modules deserve to be reviewed
    for your requirements and it is common to find both being used in a single project
    to provide a strong unit-test suite. In any case, we recommend you to read the
    documentation of both the modules, which will demonstrate that there is much more
    than the brief introduction given in this chapter. In addition a very informative
    mailing-list is available at [http://lists.idyll.org/listinfo/testing-in-python](http://lists.idyll.org/listinfo/testing-in-python).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`unittest`和`doctest`模块都值得根据你的需求进行审查，并且在一个项目中同时使用这两个模块以提供强大的单元测试套件是很常见的。无论如何，我们建议你阅读这两个模块的文档，这将证明其中包含的内容远不止本章所提供的简要介绍。此外，还有一个非常有信息量的邮件列表可供参考，网址为[http://lists.idyll.org/listinfo/testing-in-python](http://lists.idyll.org/listinfo/testing-in-python)。
- en: Unit Testing Web Applications
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试Web应用程序
- en: In the previous section, we have presented two standard modules to perform unit
    testing in Python applications and packages. Unfortunately as they stand they
    lack some common features to help in specific contexts such as web applications.
    The Python community has obviously come up with solutions and there are several
    good extensions to `unittest` or completely distinct test packages to help us.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了两个标准模块，用于在 Python 应用程序和包中进行单元测试。不幸的是，它们目前缺少一些常见功能，无法帮助在特定上下文中，如网络应用程序中进行测试。显然，Python
    社区已经提出了解决方案，并且有几种好的扩展来增强 `unittest` 或完全独立的测试包来帮助我们。
- en: We will use an extension to `unittest`, provided by CherryPy, called `webtest`
    and developed by Robert Brewer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由 CherryPy 提供的 `unittest` 扩展，称为 `webtest`，由 Robert Brewer 开发。
- en: This module provides a transparent integration with CherryPy and also provides
    a command-line helper to test different configurations of servers. It allows a
    test to be stopped when a failure occurs, offers access to the HTTP stack when
    an error is raised, also supports code coverage and profiling, etc. In a nutshell
    this module starts a CherryPy server automatically, which each test case uses
    to mount CherryPy applications as needed for the test run and to perform HTTP
    requests on that server.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块提供了与 CherryPy 的透明集成，并提供了一个命令行辅助工具来测试服务器的不同配置。它允许在发生失败时停止测试，当引发错误时提供对 HTTP
    栈的访问，还支持代码覆盖率分析和性能分析等。总之，此模块会自动启动 CherryPy 服务器，每个测试用例都使用它来挂载 CherryPy 应用程序，以适应测试运行，并在该服务器上执行
    HTTP 请求。
- en: 'This section will now show all the different test cases of our photoblog application
    but you will find them within the source code of the application. Based on what
    we have explained in the previous section we design our test cases as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示我们照片博客应用程序的所有不同测试用例，但您将在应用程序的源代码中找到它们。根据我们在上一节中解释的内容，我们设计测试用例如下：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The test case above is only an example of different tests we can conduct against
    our application and in reality more tests would be required to ensure that the
    application works as expected and to perform regression testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试用例只是我们针对应用程序可以进行的各种测试的一个示例，实际上可能需要更多的测试来确保应用程序按预期工作，并执行回归测试。
- en: As you can see, our test case performs HTTP requests and validates the content
    of the response as well as its headers. The simplicity of these validations is
    brought by the unit testing extension provided by the `webtest` module. Let's
    now see in detail how to set up that module to run the test case shown earlier.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的测试用例执行 HTTP 请求，并验证响应的内容及其标题。这些验证的简单性得益于 `webtest` 模块提供的单元测试扩展。现在让我们详细看看如何设置该模块以运行前面显示的测试用例。
- en: 'First let''s create a `test.py` module containing the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含以下代码的 `test.py` 模块：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s inspect what the `test.py` module can achieve:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 `test.py` 模块可以实现什么：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, our test supports a handful of functionalities allowing us to
    run our tests in different configurations such as by using the built-in HTTP server
    or a `mod_python` handler, as we will explain in[Chapter 10](ch10.html "Chapter 10. Deployment").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的测试支持一系列功能，允许我们在不同的配置下运行测试，例如使用内置的 HTTP 服务器或 `mod_python` 处理器，我们将在第 10
    章（[Chapter 10](ch10.html "第 10 章。部署"））中解释。
- en: 'Next we create a `PhotoblogTest` class, which will be the base class of our
    test cases. In a module called `blogtest.py` we add the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `PhotoblogTest` 类，它将成为我们测试用例的基类。在名为 `blogtest.py` 的模块中，我们添加以下代码：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `PhotoblogTest` class inherits from the CherryPy `CPWebCase` class, which
    provides a list of functions to perform assertions checking against a web test.
    For instance, the `CPWebCase` class defines the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhotoblogTest` 类继承自 CherryPy 的 `CPWebCase` 类，该类提供了一系列函数来对网络测试进行断言检查。例如，`CPWebCase`
    类定义了以下内容：'
- en: '`assertStatus(status)` to verify the status of the last response'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertStatus(status)` 用于验证最后响应的状态'
- en: '`assertHeader(name, value=None)` to verify whether a header is present as well
    as ensure that the value, if not `None`, is the one provided'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertHeader(name, value=None)` 用于验证是否存在标题，并确保如果 `value` 不是 `None`，则其值是提供的值'
- en: '`assertBody(value)` to check the returned body is the one we expected'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertBody(value)` 用于检查返回的正文是否是我们预期的'
- en: '`assertInBody(value)` to verify the returned content contained a given value'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertInBody(value)` 用于验证返回的内容是否包含给定的值'
- en: This class also comes with the `getPage(uri, method, headers, body)` method
    to issue an HTTP request.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此类还提供了 `getPage(uri, method, headers, body)` 方法来发起 HTTP 请求。
- en: Our `PhotoblogTest` class defines the photoblog property so that tests can easily
    get a reference to the blog we create by default throughout the life of the test.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `PhotoblogTest` 类定义了 photoblog 属性，以便测试可以轻松地获取对测试期间默认创建的博客的引用。
- en: 'The `blogtest.py` module also contains the following functions used to set
    up the server for the life cycle of a test:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`blogtest.py` 模块还包含以下函数，用于设置测试生命周期的服务器：'
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `setup_photoblog_server()` function is responsible for setting up the photoblog
    application and loading the different configuration settings. These must be a
    part of the test directory. For instance, we could provide a different database
    name for the storage to be used so that we do not run the test on a production
    database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_photoblog_server()` 函数负责设置 photoblog 应用程序并加载不同的配置设置。这些必须作为测试目录的一部分。例如，我们可以为存储提供不同的数据库名称，这样我们就不需要在生产数据库上运行测试。'
- en: 'Finally, we define our test cases in a module named `test_services.py` as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在名为 `test_services.py` 的模块中定义我们的测试用例，如下所示：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s explain how this module is constructed:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下这个模块是如何构建的：
- en: 1\. We must import a bunch of modules to perform specific tasks for our tests.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 我们必须导入许多模块以执行测试的特定任务。
- en: 2\. Our test case subclasses the `PhotoblogTest` class that we have described
    earlier.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 我们的测试用例是继承自我们之前描述的 `PhotoblogTest` 类。
- en: 3\. We need to define two functions—`setup_server()` and `teardown_server()`,
    which will be automatically called by the CherryPy test module each time it starts
    and finishes running a test module. This allows us to initialize our photoblog
    application for the test case.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 我们需要定义两个函数——`setup_server()` 和 `teardown_server()`，这两个函数将由 CherryPy 测试模块在每次开始和结束运行测试模块时自动调用。这允许我们在测试用例中对
    photoblog 应用程序进行初始化。
- en: 4\. Finally we add the `TestServicesREST` class as our test case.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 最后，我们添加 `TestServicesREST` 类作为我们的测试用例。
- en: 'Let''s now run the entire test suite:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来运行整个测试套件：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If on the other hand you wish to run only one module:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想运行一个模块：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, writing unit tests using the CherryPy test module makes the
    task of testing an application based on CherryPy an easy one, because CherryPy
    takes care of a lot of common burdens allowing the tester to focus on what really
    matters.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用 CherryPy 测试模块编写单元测试使得基于 CherryPy 的应用程序测试变得简单，因为 CherryPy 负责处理许多常见负担，使测试人员能够专注于真正重要的事情。
- en: Performance and Load Testing
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和负载测试
- en: Depending on the application you are writing and your expectations in terms
    of volume, you may need to run load and performance testing in order to detect
    potential bottlenecks in the application that are preventing it from reaching
    a certain level of performance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你正在编写的应用程序以及你对容量的期望，你可能需要运行负载和性能测试，以检测应用程序中可能阻止其达到一定性能水平的潜在瓶颈。
- en: This section will not detail how to conduct a performance or load test as it
    is out of its scope but we will review one Python solution, the FunkLoad package
    provided by Nuxeo, a French company specialized in free software written in Python.
    You can install FunkLoad via the `easy_install` command. FunkLoad is available
    at [http://funkload.nuxeo.org/](http://funkload.nuxeo.org/).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不会详细介绍如何进行性能或负载测试，因为这超出了其范围，但我们将回顾一个 Python 解决方案，即由 Nuxeo 提供的 FunkLoad 软件包，Nuxeo
    是一家专注于用 Python 编写的免费软件的法国公司。您可以通过 `easy_install` 命令安装 FunkLoad。FunkLoad 可在 [http://funkload.nuxeo.org/](http://funkload.nuxeo.org/)
    获取。
- en: FunkLoad is an extension to the `webunit` module, a Python module oriented towards
    unit testing web application. FunkLoad comes with a fairly extensive API and set
    of tools taking care of the burden of extracting metrics from a load test to eventually
    generate test reports with nice-looking charts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: FunkLoad 是 `webunit` 模块的一个扩展，这是一个面向单元测试 Web 应用的 Python 模块。FunkLoad 提供了一个相当广泛的
    API 和工具集，负责从负载测试中提取指标，最终生成带有美观图表的测试报告。
- en: Let's see an extremely basic example of using FunkLoad.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 FunkLoad 的一个极其基本的例子。
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s understand this example in detail:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解这个例子：
- en: 1\. Your test case must inherit from the `FunkLoadTestCase` class so that FunkLoad
    can do its internal job of tracking what happens during the test.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 你的测试用例必须继承自 `FunkLoadTestCase` 类，这样 FunkLoad 才能在其测试过程中跟踪发生的情况。
- en: '2\. Your class name is important as FunkLoad will look for a file named after
    that name, in our case: `LoadHomePage.conf` in the test directory.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 你的类名很重要，因为 FunkLoad 会寻找一个以该名称命名的文件，在我们的例子中：测试目录中的 `LoadHomePage.conf` 文件。
- en: '3\. Your test has direct access to the configuration file and gets values as
    follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 你的测试可以直接访问配置文件，并按以下方式获取值：
- en: '`conf_get(section, key)` returns a string.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf_get(section, key)`返回一个字符串。'
- en: '`conf_getInt(section, key)` returns the value as an integer.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf_getInt(section, key)`以整数值返回值。'
- en: '`conf_getFloat(section key)` returns the value as a float.'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf_getFloat(section, key)`以浮点数形式返回值。'
- en: '`conf_getList(section, key)` returns the value column separated as a list of
    strings.'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf_getList(section, key)`以列分隔的字符串列表形式返回值。'
- en: 4\. You then simply call the `get()` or `post()` method to issue a request against
    the server and retrieve the response returned by these methods.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 然后，你只需调用`get()`或`post()`方法向服务器发出请求并检索这些方法返回的响应。
- en: Internally Funkload will create a set of metrics of the test and save them in
    an `XML` file that can be processed later.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 内部Funkload将创建一系列测试指标并将它们保存到一个可以稍后处理的`XML`文件中。
- en: 'Let''s analyze the `LoadHomePage.conf` settings:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析`LoadHomePage.conf`设置：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `main` section contains global settings for the test, whereas the `test_homepage`
    contains specific values for the `test_homepage()` method of our test case. The
    `ftest` section is used by FunkLoad for internal processing.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`部分包含测试的全局设置，而`test_homepage`部分包含我们测试用例的`test_homepage()`方法的特定值。`ftest`部分由FunkLoad用于内部处理。'
- en: 'After starting an instance of the photoblog application server, we run the
    test:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动photoblog应用程序服务器的一个实例后，我们运行测试：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The previous test is not really a load test yet. To use it as a load or performance
    test, we need to use a FunkLoad tool called `fl-run-bench`. This command-line
    tool will run a benchmark using a test like the one we have just created.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试还不是真正的负载测试。要将其用作负载或性能测试，我们需要使用一个名为`fl-run-bench`的FunkLoad工具。这个命令行工具将使用我们刚刚创建的测试运行基准测试。
- en: A benchmark will simulate virtual users to run concurrently to perform a realistic
    use of the server. For instance, if we want to benchmark three cycles of 5, 10,
    and 20 virtual users during 30 seconds, we would do the following.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试将模拟虚拟用户以并发运行，以执行对服务器的实际使用。例如，如果我们想在30秒内基准测试5、10和20个虚拟用户的三轮循环，我们会这样做。
- en: 'First add the following sections to the configuration file:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在配置文件中添加以下部分：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then launch the benchmark:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后启动基准测试：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have run our benchmark we can create a report using the `fl-build-report`
    command-line tool as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了基准测试，我们可以使用`fl-build-report`命令行工具创建报告如下：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will produce an HTML page with statistics gathered from the benchmark
    as shown in the following figure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个HTML页面，其中包含从基准测试中收集的统计数据，如下所示：
- en: '![Performance and Load Testing](img/1848_09_01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![性能和负载测试](img/1848_09_01.jpg)'
- en: In addition to these modules, FunkLoad offers tools to test XML-RPC servers
    or record tests from a browser directly, allowing for complex tests to be developed
    easily. Kindly refer the FunkLoad documentation for more details about these features.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些模块之外，FunkLoad还提供测试XML-RPC服务器或从浏览器直接记录测试的工具，这使得开发复杂的测试变得容易。请参考FunkLoad文档以获取有关这些功能的更多详细信息。
- en: Overall Funkload is quite a powerful tool and yet flexible and simple to use,
    providing a comprehensive load and performance-testing environment for Python
    web applications.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，Funkload是一个非常强大的工具，同时灵活且易于使用，为Python Web应用程序提供了一个全面的负载和性能测试环境。
- en: Functional Testing
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能测试
- en: Once your application functionalities start taking shape, you may want to conduct
    a set of functional testing so that you can validate your application's correctness
    regarding the specification. For a web application, this would mean going through
    the application from a browser for example. However, since the test would have
    to be automated it would require the use of third-party products such as Selenium
    (Selenium is available at [http://www.openqa.org/selenium/](http://www.openqa.org/selenium/)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序功能开始成形时，你可能想要进行一系列的功能测试，以便你可以验证你的应用程序是否符合规格。对于一个Web应用程序，这意味着可以通过浏览器等工具遍历应用程序。然而，由于测试需要自动化，它将需要使用像Selenium这样的第三方产品（Selenium可在[http://www.openqa.org/selenium/](http://www.openqa.org/selenium/)找到）。
- en: Selenium is a JavaScript-based open-source product, developed and maintained
    by the OpenQA team to perform functional and acceptance testing. It works directly
    from the browser it targets helping to ensure the portability of the client-side
    code of the application.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一个基于JavaScript的开源产品，由OpenQA团队开发和维护，用于执行功能性和验收测试。它直接从它针对的浏览器工作，有助于确保应用程序客户端代码的可移植性。
- en: 'Selenium comes in several packages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium有几个包：
- en: 'Core: The core package allows a tester to design and run tests directly from
    the browser using pure HTML and JavaScript.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心包：核心包允许测试人员直接从浏览器使用纯HTML和JavaScript设计和运行测试。
- en: 'Remote Control: This package allows performing tests using common programming
    languages such as Python, Perl, Ruby, Java, or C#. Scripts written in these languages
    drive a browser to automate actions to be performed during the test.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程控制：此包允许使用Python、Perl、Ruby、Java或C#等常用编程语言执行测试。用这些语言编写的脚本可以驱动浏览器在测试期间自动化执行的操作。
- en: 'IDE: The Selenium IDE is available as a Firefox extension to help the creation
    of tests by recording actions carried out via the browser itself. The tests can
    then be exported to be used by the Core and Remote Control packages.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE：Selenium IDE作为Firefox扩展提供，可以帮助通过浏览器本身记录操作来创建测试。然后可以将测试导出以供核心和远程控制包使用。
- en: Application under Test
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待测试的应用程序
- en: 'Before we explain how Selenium components work, we must introduce an application
    example. This application will simply provide one web page with two links. One
    of them will replace the current page with a new one. The second link will fetch
    data using Ajax. We use this example rather than our photoblog application for
    the sake of simplicity. The code of the application is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释Selenium组件如何工作之前，我们必须介绍一个应用程序示例。这个应用程序将简单地提供一个包含两个链接的网页。其中一个将用新页面替换当前页面。第二个链接将使用Ajax获取数据。我们使用这个示例而不是我们的照片博客应用程序，因为它的简单性。应用程序的代码如下：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We define three paths to be served as static directories. The first one carries
    our Selenium test suite and test cases that will be detailed later. The second
    one contains the MochiKit JavaScript toolkit and the last one contains the Selenium
    Core package. Indeed, Selenium Core must be served by the same server under which
    the tests are conducted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个路径作为静态目录提供服务。第一个包含我们的Selenium测试套件和将在后面详细说明的测试用例。第二个包含MochiKit JavaScript工具包，最后一个包含Selenium核心包。实际上，Selenium核心必须在执行测试的同一服务器上提供服务。
- en: 'The application will look like the following in the browser:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，应用程序将看起来如下：
- en: '![Application under Test](img/1848_09_02.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![待测试的应用程序](img/1848_09_02.jpg)'
- en: 'When clicking on the first link, the `fetch_report()` JavaScript function will
    be triggered to fetch the report data via `XMLHttpRequest`. The result will look
    like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击第一个链接时，`fetch_report()` JavaScript函数将被触发，通过`XMLHttpRequest`获取报告数据。结果将如下所示：
- en: '![Application under Test](img/1848_09_03.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![待测试的应用程序](img/1848_09_03.jpg)'
- en: 'When clicking on the second link, the current page will be replaced by a new
    page containing the report such as the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击第二个链接时，当前页面将被替换为包含如下报告的新页面：
- en: '![Application under Test](img/1848_09_04.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![待测试的应用程序](img/1848_09_04.jpg)'
- en: As you can see this application is not doing anything fancy but provides us
    with common use cases in modern web applications. In the following sections we
    will therefore describe two test cases, one for each link of our application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个应用程序并没有做什么特别的事情，但它为我们提供了现代Web应用程序中的常见用例。因此，在接下来的章节中，我们将描述两个测试用例，每个链接一个。
- en: Selenium Core
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selenium核心
- en: 'Selenium tests are described via HTML tables of three columns and as many rows
    as needed with each row describing an action to be performed by Selenium. The
    three columns are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium测试通过三列和所需行数的HTML表格描述，每行描述Selenium要执行的操作。三列如下：
- en: Name of the Selenium action to be performed.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要执行Selenium操作的名称。
- en: Target to be looked for by Selenium within the document object model of the
    page. It can be the identifier of an element or an XPath statement leading to
    an element.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium在页面文档对象模型中要查找的目标。它可以是一个元素的标识符或指向元素的XPath语句。
- en: Value. A value to compare to or to be used by the action.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值。要比较或由操作使用的值。
- en: 'Let''s describe for example the following test:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们描述以下测试：
- en: 1\. Fetch the home page.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 获取主页。
- en: 2\. Click on the **Get Report** link and wait for the returned page.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 点击**获取报告**链接并等待返回的页面。
- en: 3\. Verify that we can find the HTML string in the new page.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 验证我们可以在新页面中找到HTML字符串。
- en: 'This would translate into (save this in `test/test_html.html` ):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将转换为（将以下内容保存到`test/test_html.html`）：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s describe now our second use case to test our Ajax code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来描述我们的第二个用例以测试我们的Ajax代码：
- en: 1\. Fetch the home page.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 获取主页。
- en: 2\. Click on the **Get Report via Ajax** link.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 点击**通过Ajax获取报告**链接。
- en: 3\. Pause for a few seconds.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 暂停几秒钟。
- en: 4\. Verify that we can find the Ajax string in the new page.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 验证我们能否在新的页面中找到 Ajax 字符串。
- en: 'The third step is compulsory because when performing an `XMLHttpRequest`, Selenium
    does not wait for the response. In such a case, you must pause Selenium''s execution
    so that it gives time for the response to come back and update the document object
    model of the page. The previous use case will translate into (save this in `test/test_ajax.html`
    ):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是强制性的，因为在执行 `XMLHttpRequest` 时，Selenium 不会等待响应。在这种情况下，您必须暂停 Selenium 的执行，以便它有时间等待响应返回并更新页面的文档对象模型。前面的用例将转换为（将其保存在
    `test/test_ajax.html` 中）：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that we have our test cases in our `test` directory, we can create a test
    suite as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将测试用例放在了 `test` 目录中，我们可以创建一个测试套件，如下所示：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We now have everything we need to run a test. To do so, we will use the test
    runner provided by the Selenium Core package. In a browser open the following
    page:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了运行测试所需的一切。要做到这一点，我们将使用 Selenium 核心包提供的测试运行器。在浏览器中打开以下页面：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will display a page like the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个如下所示的页面：
- en: '![Selenium Core](img/1848_09_05.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![Selenium 核心组件](img/1848_09_05.jpg)'
- en: 'We can now load our test suite and get the next screen by entering the following
    path: `../../test/testsuite.html` in the **TestSuite** input box on the top left
    of the page.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以加载我们的测试套件，通过在页面左上角的 **TestSuite** 输入框中输入以下路径来获取下一个屏幕：`../../test/testsuite.html`。
- en: '![Selenium Core](img/1848_09_06.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![Selenium 核心组件](img/1848_09_06.jpg)'
- en: As you can see, the left pane lists all our test cases, the central pane displays
    the current selected test case, and the right pane shows Selenium's controls and
    results. Finally, the bottom of the page will display the result web page of each
    test case.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，左侧面板列出了所有我们的测试用例，中间面板显示了当前选定的测试用例，右侧面板显示了 Selenium 的控件和结果。最后，页面底部将显示每个测试用例的结果网页。
- en: 'The next step is to run these tests by clicking the **All** button, which will
    generate the following screen:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过点击 **All** 按钮，这将生成以下屏幕：
- en: '![Selenium Core](img/1848_09_07.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Selenium 核心组件](img/1848_09_07.jpg)'
- en: '**Selenium TestRunner** will use color codes to inform you of how test cases
    have performed. Green means things were fine, yellow means the step is not finished,
    and red shows errors during the test.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**Selenium 测试运行器**将使用颜色代码来通知您测试用例的执行情况。绿色表示一切正常，黄色表示步骤尚未完成，红色表示测试过程中出现错误。'
- en: Selenium IDE
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selenium IDE
- en: 'In the previous section we have written our test cases directly from a text
    editor, which can become a little tedious with long use cases. Thankfully, the
    OpenQA team provides an integrated development editor for Selenium available as
    an extension for the Mozilla Firefox browser. The advantages of this IDE are:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们直接从文本编辑器中编写了测试用例，这对于长用例来说可能会变得有点繁琐。幸运的是，OpenQA 团队为 Mozilla Firefox
    浏览器提供了一个集成的开发编辑器，作为扩展程序提供。这个 IDE 的优点包括：
- en: No need to install Selenium core package on the server
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需在服务器上安装 Selenium 核心包
- en: Ability to record actions by following the business process in the browser
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够通过在浏览器中遵循业务流程来录制操作
- en: Ability to manually amend any generated test
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够手动修改任何生成的测试
- en: Step-by-step debugging of test cases
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例的逐步调试
- en: Recorded test cases can be exported to HTML or any of the supported languages
    of the Selenium Remote Control package
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制的测试用例可以导出为 HTML 或 Selenium 远程控制包支持的任何语言
- en: 'To record a test case you first need to provide the base URL of your server,
    [http://localhost:8080](http://localhost:8080) in the following window:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要录制一个测试用例，您首先需要在以下窗口中提供服务器的基准 URL，[http://localhost:8080](http://localhost:8080)：
- en: '![Selenium IDESeleniumcore](img/1848_09_08.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Selenium IDESeleniumcore](img/1848_09_08.jpg)'
- en: Since by default when you start the IDE it runs in recording mode, you can now
    go to the browser and follow your business process. Each step will be recorded
    automatically by the Selenium IDE. For instance, by clicking on **Get Report**,
    the **clickAndWait** step will be generated. To verify the presence of a given
    text, you must highlight the targeted text, right-click to open the pop-up menu,
    and select **verifyTextPresent**.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认情况下，当您启动 IDE 时，它会以录制模式运行，您现在可以转到浏览器并遵循您的业务流程。Selenium IDE 将自动记录每个步骤。例如，通过点击
    **Get Report**，将生成 **clickAndWait** 步骤。要验证给定文本的存在，您必须突出显示目标文本，右键单击以打开弹出菜单，并选择
    **verifyTextPresent**。
- en: 'Your IDE will then look like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的 IDE 将看起来如下所示：
- en: '![Selenium IDESeleniumcore](img/1848_09_09.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![Selenium IDESeleniumcore](img/1848_09_09.jpg)'
- en: Now that we have a recorded test we can run it by clicking the green triangle.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经录制了一个测试，我们可以通过点击绿色三角形来运行它。
- en: '![Selenium IDESeleniumcore](img/1848_08_10.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Selenium IDESeleniumcore](img/1848_08_10.jpg)'
- en: As you can see, the steps to create a script are much simpler using the IDE.
    Moreover, thanks to its great flexibility you can either insert new steps or remove
    and modify existing ones if the IDE failed to record an action for instance. You
    can also load tests created manually into the IDE and run them from there.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用 IDE 创建脚本的步骤要简单得多。此外，多亏了其出色的灵活性，你可以在 IDE 中插入新步骤，或者在 IDE 无法记录动作的情况下删除和修改现有步骤。你还可以将手动创建的测试加载到
    IDE 中并从那里运行它们。
- en: Finally, you can export your recorded step so that you can run it via the Test
    Runner or via the Selenium Remote Control package as we will see in the next section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以导出你的记录步骤，以便你可以通过测试运行器或通过我们在下一节中将要看到的 Selenium 远程控制包来运行它。
- en: Selenium Remote Control
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selenium 远程控制
- en: The Selenium **Remote Control** (**RC**) package offers the possibility of driving
    a browser using a recorded step from several programming languages. This is extremely
    interesting because your tests can therefore be run as regular unit tests.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium **远程控制**（**RC**）包提供了使用从多种编程语言记录的步骤来驱动浏览器的可能性。这非常有趣，因为你的测试因此可以作为常规单元测试运行。
- en: 'You need to first get the Python modules from the Selenium RC package. Once
    they can be found in your `PYTHONPATH`, you should be able to do the following:
    `from selenium import selenium`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要首先从 Selenium RC 包中获取 Python 模块。一旦它们出现在你的 `PYTHONPATH` 中，你应该能够执行以下操作：`from
    selenium import selenium`。
- en: 'Next step will be to export the previously recorded test to the Python language.
    The resulting script will look like the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是将之前录制的测试导出为 Python 语言。生成的脚本将如下所示：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, this is a pure test case from the `unittest` standard module.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个来自 `unittest` 标准模块的纯测试用例。
- en: 'Let''s see what the script does:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看脚本做了什么：
- en: 1\. The `setUp()` method, called before each test method, initializes a Selenium
    object indicating the host and the port of the Selenium proxy as well as which
    kind of browser should be used during the test.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 在每个测试方法之前调用的 `setUp()` 方法，初始化一个 Selenium 对象，指定 Selenium 代理的主机和端口，以及测试期间应使用哪种浏览器。
- en: 2\. The `test_TestHTML()` method performs the actual steps of our test case.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. `test_TestHTML()` 方法执行了我们测试用例的实际步骤。
- en: 3\. The `tearDown()` method, called after each test method, stops this instance
    of the Selenium object.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 在每个测试方法之后调用的 `tearDown()` 方法停止了 Selenium 对象的这个实例。
- en: Before running the test, you must start the Selenium proxy, which will handle
    the startup of the chosen browser as well as run the test. It will then return
    all the results to our test case.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，你必须启动 Selenium 代理，它将处理所选浏览器的启动以及运行测试。然后，它将所有结果返回到我们的测试用例。
- en: 'The Selenium RC package comes with a default proxy server written in Java,
    which is the one we will use in our example. However, nothing prevents anyone
    from writing a proxy in a different language of course. To start the server, you
    must go to the Selenium RC package directory and issue the following command,
    assuming you have a Java virtual machine 1.4.2 or above installed on your machine:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium RC 包附带了一个用 Java 编写的默认代理服务器，这是我们将在示例中使用的。然而，当然没有任何阻止任何人用不同的语言编写代理的限制。要启动服务器，你必须转到
    Selenium RC 包目录，并执行以下命令，假设你的机器上已安装了 1.4.2 或更高版本的 Java 虚拟机：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once the server is started, you must start your application server and then
    you can run the test as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器启动后，你必须启动你的应用程序服务器，然后你可以按照以下方式运行测试：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you look at the Selenium proxy server logs, you should see something like
    the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 Selenium 代理服务器日志，你应该会看到以下类似的内容：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will launch a Firefox instance, run the test, and pass back the results
    to your test case as normal input.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个 Firefox 实例，运行测试，并将结果作为正常输入传递回你的测试用例。
- en: In this section, we have presented an open-source solution, Selenium, to perform
    acceptance and functional testing in order to validate the correctness of our
    application. Although this solution is not the only one, it has gained lots of
    support from the community. Its flexibility and large set of features offer the
    tester a large palette to build his or her tests on.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了一个开源解决方案 Selenium，用于执行验收和功能测试，以验证我们应用程序的正确性。尽管这不是唯一的解决方案，但它已经得到了社区的广泛支持。它的灵活性和庞大的功能集为测试人员提供了一个构建测试的大色板。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter we have presented different aspects of testing an application.
    Although this is not a comprehensive list of what can be achieved, it should provide
    a good starting point to understand how an application can and should be tested.
    It is important to note that testing should not happen at the last stage of the
    application development's life but instead be a part of its building as soon as
    possible.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了测试应用程序的不同方面。尽管这不是一个详尽无遗的清单，但它应该为理解应用程序可以以及应该如何进行测试提供一个良好的起点。重要的是要注意，测试不应发生在应用程序开发的最后阶段，而应尽早成为其构建过程的一部分。
