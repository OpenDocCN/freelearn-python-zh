- en: Chapter 9. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have reviewed the different steps involved in building the photoblog
    application but we have not tested our design and implementation. This chapter
    will introduce some testing techniques such as unit, functional, and load testing
    using open-source products such as unittest, CherryPy webtest, FunkLoad, and Selenium.
    By the end of this chapter, you should have a good understanding of how to use
    these tools in their context and improve the test suite for your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Why Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why testing, some might wonder? Does it bring any value to the application?
    You may believe that if a problem is found in your code, it will be reported and
    eventually be fixed. Therefore, you may argue that testing is fairly irrelevant
    and is time consuming. If you do believe this, then with the help of this chapter
    we will try to show you that testing is not just the cherry on the cake but actually
    it is part of the recipe for success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing is a process during which the application is audited from different
    perspectives in order to:'
  prefs: []
  type: TYPE_NORMAL
- en: Find bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find differences between the expected and real result, output, states, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how complete the implementation is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise the application in realistic situations before its release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of testing is not to put the developer at fault but to provide tools
    to estimate the health of the application at a given time. Testing measures the
    quality of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is, therefore, not just a part of the application life cycle but is
    actually the true barometer of where the application stands in that cycle. Lines
    of code are meaningless; but test summary and test reports are the reference points
    that the different members of a project can relate to for understanding what has
    been achieved, what still needs to be achieved, and how to plan it.
  prefs: []
  type: TYPE_NORMAL
- en: Planning a Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the previous section we can say that since testing is so critical to a
    project, everything should be tested and reviewed. This is true, but it does not
    mean the same amount of resources and efforts should be allocated to every part
    of the system under test.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, it depends on the position of the project in its life cycle. For
    instance, there is little need for performance testing right at the beginning
    of the project. There might not be a need for capacity testing, if the application
    does not require lots of hardware or network resources. That being said some tests
    will be carried all along the life cycle of the project. They will be built up
    by successive iterations bringing more strength to the test each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, testing needs to be planned in advance in order to define:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Goals: What is it relevant to test and for what purpose?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scope: What is in the scope of the test? What is not?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Requirements: What will the test involve in terms of resources (human, software,
    hardware, etc.)?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Risks: What are the risks related to that test if it does not pass? What will
    be the mitigation and action taken? Will it stop the project? What is the impact?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few points to be kept in mind while planning a test.
  prefs: []
  type: TYPE_NORMAL
- en: Another important point is that testing does not end once the application is
    released. It can also be carried on later so that the production release meets
    the defined requirements. In any case, since testing draws together so many different
    aspects it should be seen as a long, continuous process.
  prefs: []
  type: TYPE_NORMAL
- en: Common Testing Approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Testing is a generic term for a range of aspects to be validated on a system
    or application. Here is a brief list of the common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing: Usually carried by the developers themselves. Unit tests aim
    at checking whether a unit of code works as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usability testing: Developers may usually forget that they are writing an application
    for end users who do not have knowledge of the system and might end up making
    it unusable. Functional and usability tests provide a way to make sure that applications
    will fulfill user expectations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Functional/Acceptance testing: While usability testing checks whether the application
    or system is usable, functional testing ensures that every specified functionality
    is implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Load and performance testing: Once an application or system has reached a certain
    level of completeness, it may require load and performance tests to be conducted
    in order to understand whether the system can cope with its expected peak load
    and to find potential bottlenecks. This can lead to changing hardware, optimizing
    SQL queries, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regression testing: Regression testing verifies that successive releases of
    a product do not break any of the previously working functionalities. Unit testing
    can be considered as a part of regression testing in some ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reliability and resilience testing: Some applications or systems cannot afford
    to break at any time. Reliability and resilience tests can validate how the system
    application copes with the breakdown of one or several components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous list is far from being exhaustive and each system or application
    environment may require specific types of testing to be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our photoblog application will extensively use unit tests in order to constantly
    check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: New functionalities work correctly and as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existing functionalities are not broken by new code release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defects are fixed and remain fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python comes in with a standard `unittest` module and also provides a `doctest`
    module offering a different approach to unit testing as we will explain later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: unittest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`unittest` is rooted in JUnit, a Java unit test package developed by Kent Beck
    and Erich Gamma, which in turn came from a Smalltalk testing framework developed
    by Kent Beck. Let''s now review a basic example of this module.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests can often work on mock objects that are so called because they support
    the same interface as the domain objects of the applications but do not actually
    perform any work. They simply return defined data. Mock objects therefore allow
    testing against an interface of our design without having to rely on the overall
    application to be deployed for instance. They also provide a way to run tests
    in isolation mode from other tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s define a dummy class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class provides an interface to get the next or previous value within a
    range defined by the left and right boundaries. We could imagine it as a mock
    object of a more complex class but providing dummy data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple usage of this class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's imagine we wish to unit test this exciting module to make sure that the
    code is correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain this code step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. To provide unit test capabilities using the `unittest` standard module you
    only need to import that specific module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Create a class that subclasses `unittest.TestCase`, which is the interface
    providing unit test functionalities to our code. This class is referred to as
    a **test case**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Create methods starting with the word `test`. Each method starting with
    it will be called by the `unittest` internal handler. Notice that the methods
    this class defines also use a two-digit pattern. This is not required by `unittest`
    but it allows us to force methods to be called in the order we wish. Indeed `unittest`
    calls methods by alpha-numeric order, which can sometimes lead to unexpected results.
    Providing digits like this is a good way to work around that limitation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Call the different `assert/fail` methods provided by the `TestCase` class
    to perform checking of values, exceptions, outputs, etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to run this test case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This assumes that the call to `main()` is done from within the same module
    containing the `TestCase` class. The result of this test looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It is common to make the output a little more verbose as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s provoke an error so that one of the tests fails. In `test_01_forward`
    replace the first `assertEqual` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then while running the test again you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `unittest` module does not stop processing any remaining
    test cases when one fails. Instead, it displays the traceback of the raised assertion
    error. Here the test is wrong but in the case where your assertion is a valid
    one, it would point to a failure of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we write a test that tries to go forward when the right boundary
    is less than the starting point. We assume that the documentation of the method
    tells us that it should raise an exception expressing the fact that the class
    has rejected this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create `test_00_construct` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the test now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see the test case does fail on the new test we have included. The
    reason is that the `Dummy.__init__()` method does not contain any error handling
    for this case unlike what the documentation told us. Let''s fix this by adding
    the following code at the bottom of the `__init__` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now re-run the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The previous example shows that it is sometimes desirable to write the test
    before implementing the functionality itself in order to avoid designing the test
    to match the code behavior. This is often called test-driven development. Another
    way to achieve this is to provide the API of the application or library to a third
    party, who will write the test case based on that API in a neutral fashion. Either
    way the previous example demonstrates that unit testing is only relevant when
    the tests are coherent with the design and are there to test the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced the `unittest` module let's present the `doctest`
    one.
  prefs: []
  type: TYPE_NORMAL
- en: doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `doctest` module supports running Python code inlined within an object docstring.
    The advantage of this technique is that test cases are close to the code they
    test. The inconvenience is that some complex tests can be difficult to achieve
    this way. Let's see an example on the class we have defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each method you wish to test must have a docstring containing
    use cases that will be run as-is by the `doctest` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can run the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We do not reproduce the complete result trace as it is too long for the purpose
    of the chapter. You may consider that mixing code and documentation will reduce
    the efficiency of both, making the documentation harder to read. This concern
    is actually raised by the `doctest` module documentation itself, which sensibly
    advises handling *docstring examples with care*. Indeed, since the code belongs
    to the docstring, it will be displayed while viewing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In such cases the tests can either be part of the documentation itself or be
    too complex making the documentation unusable.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell both the `unittest` and `doctest` modules deserve to be reviewed
    for your requirements and it is common to find both being used in a single project
    to provide a strong unit-test suite. In any case, we recommend you to read the
    documentation of both the modules, which will demonstrate that there is much more
    than the brief introduction given in this chapter. In addition a very informative
    mailing-list is available at [http://lists.idyll.org/listinfo/testing-in-python](http://lists.idyll.org/listinfo/testing-in-python).
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have presented two standard modules to perform unit
    testing in Python applications and packages. Unfortunately as they stand they
    lack some common features to help in specific contexts such as web applications.
    The Python community has obviously come up with solutions and there are several
    good extensions to `unittest` or completely distinct test packages to help us.
  prefs: []
  type: TYPE_NORMAL
- en: We will use an extension to `unittest`, provided by CherryPy, called `webtest`
    and developed by Robert Brewer.
  prefs: []
  type: TYPE_NORMAL
- en: This module provides a transparent integration with CherryPy and also provides
    a command-line helper to test different configurations of servers. It allows a
    test to be stopped when a failure occurs, offers access to the HTTP stack when
    an error is raised, also supports code coverage and profiling, etc. In a nutshell
    this module starts a CherryPy server automatically, which each test case uses
    to mount CherryPy applications as needed for the test run and to perform HTTP
    requests on that server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section will now show all the different test cases of our photoblog application
    but you will find them within the source code of the application. Based on what
    we have explained in the previous section we design our test cases as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The test case above is only an example of different tests we can conduct against
    our application and in reality more tests would be required to ensure that the
    application works as expected and to perform regression testing.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our test case performs HTTP requests and validates the content
    of the response as well as its headers. The simplicity of these validations is
    brought by the unit testing extension provided by the `webtest` module. Let's
    now see in detail how to set up that module to run the test case shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s create a `test.py` module containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect what the `test.py` module can achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our test supports a handful of functionalities allowing us to
    run our tests in different configurations such as by using the built-in HTTP server
    or a `mod_python` handler, as we will explain in[Chapter 10](ch10.html "Chapter 10. Deployment").
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we create a `PhotoblogTest` class, which will be the base class of our
    test cases. In a module called `blogtest.py` we add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PhotoblogTest` class inherits from the CherryPy `CPWebCase` class, which
    provides a list of functions to perform assertions checking against a web test.
    For instance, the `CPWebCase` class defines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertStatus(status)` to verify the status of the last response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertHeader(name, value=None)` to verify whether a header is present as well
    as ensure that the value, if not `None`, is the one provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertBody(value)` to check the returned body is the one we expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertInBody(value)` to verify the returned content contained a given value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class also comes with the `getPage(uri, method, headers, body)` method
    to issue an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Our `PhotoblogTest` class defines the photoblog property so that tests can easily
    get a reference to the blog we create by default throughout the life of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `blogtest.py` module also contains the following functions used to set
    up the server for the life cycle of a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `setup_photoblog_server()` function is responsible for setting up the photoblog
    application and loading the different configuration settings. These must be a
    part of the test directory. For instance, we could provide a different database
    name for the storage to be used so that we do not run the test on a production
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define our test cases in a module named `test_services.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain how this module is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. We must import a bunch of modules to perform specific tasks for our tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Our test case subclasses the `PhotoblogTest` class that we have described
    earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. We need to define two functions—`setup_server()` and `teardown_server()`,
    which will be automatically called by the CherryPy test module each time it starts
    and finishes running a test module. This allows us to initialize our photoblog
    application for the test case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Finally we add the `TestServicesREST` class as our test case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now run the entire test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If on the other hand you wish to run only one module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, writing unit tests using the CherryPy test module makes the
    task of testing an application based on CherryPy an easy one, because CherryPy
    takes care of a lot of common burdens allowing the tester to focus on what really
    matters.
  prefs: []
  type: TYPE_NORMAL
- en: Performance and Load Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on the application you are writing and your expectations in terms
    of volume, you may need to run load and performance testing in order to detect
    potential bottlenecks in the application that are preventing it from reaching
    a certain level of performance.
  prefs: []
  type: TYPE_NORMAL
- en: This section will not detail how to conduct a performance or load test as it
    is out of its scope but we will review one Python solution, the FunkLoad package
    provided by Nuxeo, a French company specialized in free software written in Python.
    You can install FunkLoad via the `easy_install` command. FunkLoad is available
    at [http://funkload.nuxeo.org/](http://funkload.nuxeo.org/).
  prefs: []
  type: TYPE_NORMAL
- en: FunkLoad is an extension to the `webunit` module, a Python module oriented towards
    unit testing web application. FunkLoad comes with a fairly extensive API and set
    of tools taking care of the burden of extracting metrics from a load test to eventually
    generate test reports with nice-looking charts.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see an extremely basic example of using FunkLoad.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand this example in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Your test case must inherit from the `FunkLoadTestCase` class so that FunkLoad
    can do its internal job of tracking what happens during the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2\. Your class name is important as FunkLoad will look for a file named after
    that name, in our case: `LoadHomePage.conf` in the test directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3\. Your test has direct access to the configuration file and gets values as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`conf_get(section, key)` returns a string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf_getInt(section, key)` returns the value as an integer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf_getFloat(section key)` returns the value as a float.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf_getList(section, key)` returns the value column separated as a list of
    strings.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 4\. You then simply call the `get()` or `post()` method to issue a request against
    the server and retrieve the response returned by these methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Internally Funkload will create a set of metrics of the test and save them in
    an `XML` file that can be processed later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the `LoadHomePage.conf` settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `main` section contains global settings for the test, whereas the `test_homepage`
    contains specific values for the `test_homepage()` method of our test case. The
    `ftest` section is used by FunkLoad for internal processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'After starting an instance of the photoblog application server, we run the
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The previous test is not really a load test yet. To use it as a load or performance
    test, we need to use a FunkLoad tool called `fl-run-bench`. This command-line
    tool will run a benchmark using a test like the one we have just created.
  prefs: []
  type: TYPE_NORMAL
- en: A benchmark will simulate virtual users to run concurrently to perform a realistic
    use of the server. For instance, if we want to benchmark three cycles of 5, 10,
    and 20 virtual users during 30 seconds, we would do the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'First add the following sections to the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then launch the benchmark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have run our benchmark we can create a report using the `fl-build-report`
    command-line tool as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce an HTML page with statistics gathered from the benchmark
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Performance and Load Testing](img/1848_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In addition to these modules, FunkLoad offers tools to test XML-RPC servers
    or record tests from a browser directly, allowing for complex tests to be developed
    easily. Kindly refer the FunkLoad documentation for more details about these features.
  prefs: []
  type: TYPE_NORMAL
- en: Overall Funkload is quite a powerful tool and yet flexible and simple to use,
    providing a comprehensive load and performance-testing environment for Python
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once your application functionalities start taking shape, you may want to conduct
    a set of functional testing so that you can validate your application's correctness
    regarding the specification. For a web application, this would mean going through
    the application from a browser for example. However, since the test would have
    to be automated it would require the use of third-party products such as Selenium
    (Selenium is available at [http://www.openqa.org/selenium/](http://www.openqa.org/selenium/)).
  prefs: []
  type: TYPE_NORMAL
- en: Selenium is a JavaScript-based open-source product, developed and maintained
    by the OpenQA team to perform functional and acceptance testing. It works directly
    from the browser it targets helping to ensure the portability of the client-side
    code of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Selenium comes in several packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Core: The core package allows a tester to design and run tests directly from
    the browser using pure HTML and JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remote Control: This package allows performing tests using common programming
    languages such as Python, Perl, Ruby, Java, or C#. Scripts written in these languages
    drive a browser to automate actions to be performed during the test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IDE: The Selenium IDE is available as a Firefox extension to help the creation
    of tests by recording actions carried out via the browser itself. The tests can
    then be exported to be used by the Core and Remote Control packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application under Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we explain how Selenium components work, we must introduce an application
    example. This application will simply provide one web page with two links. One
    of them will replace the current page with a new one. The second link will fetch
    data using Ajax. We use this example rather than our photoblog application for
    the sake of simplicity. The code of the application is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We define three paths to be served as static directories. The first one carries
    our Selenium test suite and test cases that will be detailed later. The second
    one contains the MochiKit JavaScript toolkit and the last one contains the Selenium
    Core package. Indeed, Selenium Core must be served by the same server under which
    the tests are conducted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application will look like the following in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application under Test](img/1848_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When clicking on the first link, the `fetch_report()` JavaScript function will
    be triggered to fetch the report data via `XMLHttpRequest`. The result will look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application under Test](img/1848_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When clicking on the second link, the current page will be replaced by a new
    page containing the report such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application under Test](img/1848_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see this application is not doing anything fancy but provides us
    with common use cases in modern web applications. In the following sections we
    will therefore describe two test cases, one for each link of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Selenium tests are described via HTML tables of three columns and as many rows
    as needed with each row describing an action to be performed by Selenium. The
    three columns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Selenium action to be performed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target to be looked for by Selenium within the document object model of the
    page. It can be the identifier of an element or an XPath statement leading to
    an element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value. A value to compare to or to be used by the action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s describe for example the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Fetch the home page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Click on the **Get Report** link and wait for the returned page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Verify that we can find the HTML string in the new page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This would translate into (save this in `test/test_html.html` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s describe now our second use case to test our Ajax code:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Fetch the home page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Click on the **Get Report via Ajax** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Pause for a few seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Verify that we can find the Ajax string in the new page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third step is compulsory because when performing an `XMLHttpRequest`, Selenium
    does not wait for the response. In such a case, you must pause Selenium''s execution
    so that it gives time for the response to come back and update the document object
    model of the page. The previous use case will translate into (save this in `test/test_ajax.html`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our test cases in our `test` directory, we can create a test
    suite as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have everything we need to run a test. To do so, we will use the test
    runner provided by the Selenium Core package. In a browser open the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display a page like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selenium Core](img/1848_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can now load our test suite and get the next screen by entering the following
    path: `../../test/testsuite.html` in the **TestSuite** input box on the top left
    of the page.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selenium Core](img/1848_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the left pane lists all our test cases, the central pane displays
    the current selected test case, and the right pane shows Selenium's controls and
    results. Finally, the bottom of the page will display the result web page of each
    test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to run these tests by clicking the **All** button, which will
    generate the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selenium Core](img/1848_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Selenium TestRunner** will use color codes to inform you of how test cases
    have performed. Green means things were fine, yellow means the step is not finished,
    and red shows errors during the test.'
  prefs: []
  type: TYPE_NORMAL
- en: Selenium IDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section we have written our test cases directly from a text
    editor, which can become a little tedious with long use cases. Thankfully, the
    OpenQA team provides an integrated development editor for Selenium available as
    an extension for the Mozilla Firefox browser. The advantages of this IDE are:'
  prefs: []
  type: TYPE_NORMAL
- en: No need to install Selenium core package on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to record actions by following the business process in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to manually amend any generated test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step-by-step debugging of test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recorded test cases can be exported to HTML or any of the supported languages
    of the Selenium Remote Control package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To record a test case you first need to provide the base URL of your server,
    [http://localhost:8080](http://localhost:8080) in the following window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selenium IDESeleniumcore](img/1848_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since by default when you start the IDE it runs in recording mode, you can now
    go to the browser and follow your business process. Each step will be recorded
    automatically by the Selenium IDE. For instance, by clicking on **Get Report**,
    the **clickAndWait** step will be generated. To verify the presence of a given
    text, you must highlight the targeted text, right-click to open the pop-up menu,
    and select **verifyTextPresent**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your IDE will then look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selenium IDESeleniumcore](img/1848_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have a recorded test we can run it by clicking the green triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Selenium IDESeleniumcore](img/1848_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the steps to create a script are much simpler using the IDE.
    Moreover, thanks to its great flexibility you can either insert new steps or remove
    and modify existing ones if the IDE failed to record an action for instance. You
    can also load tests created manually into the IDE and run them from there.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can export your recorded step so that you can run it via the Test
    Runner or via the Selenium Remote Control package as we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium Remote Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Selenium **Remote Control** (**RC**) package offers the possibility of driving
    a browser using a recorded step from several programming languages. This is extremely
    interesting because your tests can therefore be run as regular unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to first get the Python modules from the Selenium RC package. Once
    they can be found in your `PYTHONPATH`, you should be able to do the following:
    `from selenium import selenium`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next step will be to export the previously recorded test to the Python language.
    The resulting script will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a pure test case from the `unittest` standard module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the script does:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The `setUp()` method, called before each test method, initializes a Selenium
    object indicating the host and the port of the Selenium proxy as well as which
    kind of browser should be used during the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. The `test_TestHTML()` method performs the actual steps of our test case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. The `tearDown()` method, called after each test method, stops this instance
    of the Selenium object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before running the test, you must start the Selenium proxy, which will handle
    the startup of the chosen browser as well as run the test. It will then return
    all the results to our test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Selenium RC package comes with a default proxy server written in Java,
    which is the one we will use in our example. However, nothing prevents anyone
    from writing a proxy in a different language of course. To start the server, you
    must go to the Selenium RC package directory and issue the following command,
    assuming you have a Java virtual machine 1.4.2 or above installed on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is started, you must start your application server and then
    you can run the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the Selenium proxy server logs, you should see something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will launch a Firefox instance, run the test, and pass back the results
    to your test case as normal input.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have presented an open-source solution, Selenium, to perform
    acceptance and functional testing in order to validate the correctness of our
    application. Although this solution is not the only one, it has gained lots of
    support from the community. Its flexibility and large set of features offer the
    tester a large palette to build his or her tests on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter we have presented different aspects of testing an application.
    Although this is not a comprehensive list of what can be achieved, it should provide
    a good starting point to understand how an application can and should be tested.
    It is important to note that testing should not happen at the last stage of the
    application development's life but instead be a part of its building as soon as
    possible.
  prefs: []
  type: TYPE_NORMAL
