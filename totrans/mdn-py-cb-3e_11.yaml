- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: Input/Output, Physical Format, and Logical Layout
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 输入/输出、物理格式和逻辑布局
- en: 'Computing often works with persistent data. There may be source data to be
    analyzed, or output to be created using Python input and output operations. The
    map of the dungeon that’s explored in a game is data that will be input to the
    game application. Images, sounds, and movies are data output by some applications
    and input by other applications. Even a request through a network will involve
    input and output operations. The common aspect to all of these is the concept
    of a file of data. The term file is overloaded with many meanings:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 计算通常与持久数据一起工作。可能有源数据需要分析，或者使用Python的输入和输出操作创建输出。在游戏中探索的地牢图是游戏应用程序将输入的数据。图像、声音和电影是某些应用程序输出的数据，由其他应用程序输入。甚至通过网络发送的请求也会涉及输入和输出操作。所有这些的共同之处在于数据文件的概念。术语“文件”具有许多含义：
- en: 'The operating system (OS) uses a file as a way to organize bytes of data on
    a device. It’s the responsibility of application software to make sense of the
    bytes. Two common kinds of devices offer variations in terms of the features of
    OS files:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统（OS）使用文件作为在设备上组织数据字节的方式。解析字节是应用程序软件的责任。两种常见的设备在操作系统文件的功能方面提供了不同的变体：
- en: 'Block devices such as disks or solid-state drives (SSDs): A file on this kind
    of device can seek any specific byte, making them particularly good for databases,
    where any row can be processed at any time.'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块设备，如磁盘或固态驱动器（SSD）：这类设备上的文件可以定位任何特定的字节，这使得它们特别适合数据库，因为任何行都可以在任何时候进行处理。
- en: Character devices such as a network connection, a keyboard, or a GPS antenna.
    A file on this kind of device is viewed as a stream of individual bytes in transit.
    There’s no way to seek forward or backward; the bytes must be captured in a buffer
    and processed as they arrive.
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符设备，如网络连接、键盘或GPS天线。这类设备上的文件被视为传输中的单个字节流。无法向前或向后查找；字节必须被捕获在缓冲区中，并按到达顺序进行处理。
- en: The word file also defines a data structure used by the Python runtime. A uniform
    Python file abstraction wraps the various OS file implementations. When we open
    a Python file, there is a binding between the Python abstraction, an OS implementation,
    and the underlying collection of bytes on a block device or stream of bytes of
    a character device.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “文件”这个词还定义了Python运行时使用的数据结构。统一的Python文件抽象封装了各种操作系统文件实现。当我们打开Python文件时，Python抽象、操作系统实现以及块设备上的底层字节集合或字符设备的字节流之间存在绑定。
- en: 'Python gives us two common modes for working with a file’s content:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了两种常见模式来处理文件内容：
- en: In ”b” (binary) mode, our application sees the bytes, without further interpretation.
    This can be helpful for processing media data like images, audio, and movies,
    which have complex encodings. We’ll often import libraries like pillow to handle
    the details of image file encoding into bytes and decoding from bytes.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“b”（二进制）模式下，我们的应用程序看到的是字节，而不进行进一步解释。这有助于处理具有复杂编码的媒体数据，如图像、音频和电影。我们通常会导入像pillow这样的库来处理图像文件编码为字节以及从字节解码的细节。
- en: In ”t” (text) mode, the bytes of the file are encodings of string values. Python
    strings are made of Unicode characters, and there are a variety of schemes for
    decoding bytes into text and encoding text into bytes. Generally, the OS has a
    preferred encoding and Python respects this. The UTF-8 encoding is popular. Pragmatically,
    a file can have any of the available Unicode encodings, and it may not be obvious
    which encoding was used to create a file.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“t”（文本）模式下，文件的字节是字符串值的编码。Python字符串由Unicode字符组成，有多种方案用于将字节解码为文本以及将文本编码为字节。通常，操作系统有一个首选的编码，Python会尊重这一点。UTF-8编码很受欢迎。从实用主义的角度来看，文件可以具有任何可用的Unicode编码，并且可能不清楚使用了哪种编码来创建文件。
- en: Additionally, Python modules like shelve and pickle have unique ways of representing
    more complex Python objects than simple strings. There are a number of pickle
    protocols available; all of them are based on binary mode file operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python模块如shelve和pickle有独特的方式来表示比简单字符串更复杂的Python对象。有几种pickle协议可用；它们都基于二进制模式文件操作。
- en: 'Throughout this chapter, we’ll talk about how Python objects are serialized.
    Serialization creates a representation of the Python object’s state as a series
    of bytes. Deserialization is the reverse process: it recovers a Python object’s
    state from the bytes of a file. Saving and transferring a representation of the
    object state is the foundational concept behind REST web services.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Python 对象的序列化。序列化创建了一系列字节，以表示 Python 对象的状态。反序列化是相反的过程：它从文件的字节中恢复
    Python 对象的状态。保存和传输对象状态的表示是 REST 网络服务背后的基本概念。
- en: 'When we process data from files, we have two common concerns:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理来自文件的数据时，我们有两个常见的问题：
- en: 'The physical format of the data: We need to know how the bytes on the file
    are interpreted to reconstruct a Python object. The bytes could represent a JPEG-encoded
    image or an MPEG-encoded movie. One very common example is the bytes of the file
    representing Unicode text, organized into lines. Generally, physical format concerns
    are handled by Python libraries like csv, json, and pickle, among many others.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的物理格式：我们需要知道如何解释文件上的字节来重建 Python 对象。字节可能代表 JPEG 编码的图像或 MPEG 编码的电影。一个非常常见的例子是表示
    Unicode 文本的文件字节，组织成行。通常，物理格式问题由 Python 库如 csv、json 和 pickle 等处理。
- en: 'The logical layout of the data: A given data collection may have flexible positions
    for storing data items. The arrangement of CSV columns or JSON fields can vary.
    In cases where the data includes labels, the logical layout is clear. Without
    labels, the layout is positional, and some additional schema information is required
    to identify which data items occupy the various positions.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据的逻辑布局：给定的数据集合可能有灵活的位置来存储数据项。CSV 列或 JSON 字段的排列可以不同。在数据包含标签的情况下，逻辑布局是清晰的。如果没有标签，布局是位置性的，需要一些额外的模式信息来识别哪些数据项占据了各种位置。
- en: Both the physical format decoding and logical layout schema are essential to
    interpreting the data on a file. We’ll look at a number of recipes for working
    with different physical formats. We’ll also look at ways to divorce our program
    from some aspects of the logical layout.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 物理格式解码和逻辑布局模式对于解释文件上的数据都是必不可少的。我们将探讨处理不同物理格式的多个食谱。我们还将探讨将我们的程序与逻辑布局的一些方面分离的方法。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下食谱：
- en: '[Using pathlib to work with filenames](ch015_split_000.xhtml#x1-6160001)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 pathlib 处理文件名](ch015_split_000.xhtml#x1-6160001)'
- en: '[Replacing a file while preserving the previous version](ch015_split_000.xhtml#x1-6260002)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[替换文件同时保留旧版本](ch015_split_000.xhtml#x1-6260002)'
- en: '[Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 CSV 模块读取分隔文件](ch015_split_000.xhtml#x1-6320003)'
- en: '[Using dataclasses to simplify working with CSV files](ch015_split_000.xhtml#x1-6380004)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 dataclasses 简化处理 CSV 文件](ch015_split_000.xhtml#x1-6380004)'
- en: '[Reading complex formats using regular expressions](ch015_split_001.xhtml#x1-6440005)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用正则表达式读取复杂格式](ch015_split_001.xhtml#x1-6440005)'
- en: '[Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[读取 JSON 和 YAML 文档](ch015_split_001.xhtml#x1-6520006)'
- en: '[Reading XML documents](ch015_split_001.xhtml#x1-6600007)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[读取 XML 文档](ch015_split_001.xhtml#x1-6600007)'
- en: '[Reading HTML documents](ch015_split_001.xhtml#x1-6660008)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[读取 HTML 文档](ch015_split_001.xhtml#x1-6660008)'
- en: In order to work with files, we’ll start with objects that help control the
    OS filesystem. The common features of the directory structure of files and devices
    are described by Python’s pathlib module. This module has consistent behavior
    across a number of operating systems, allowing a Python program to work similarly
    on Linux, macOS, and Windows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理文件，我们将从帮助控制操作系统文件系统的对象开始。Python 的 pathlib 模块描述了文件和设备的目录结构的常见特性。此模块在多个操作系统上具有一致的行为，使得
    Python 程序在 Linux、macOS 和 Windows 上可以以类似的方式工作。
- en: 11.1 Using pathlib to work with filenames
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.1 使用 pathlib 处理文件名
- en: 'Most operating systems use a hierarchical tree of directories that contain
    files. The path from the root directory to a specific file is often shown as a
    string. Here’s an example path:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数操作系统使用包含文件的目录树结构。从根目录到特定文件的路径通常表示为一个字符串。以下是一个示例路径：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This full path name lists seven named directories contained in the (unnamed)
    root directory. The final name has a stem of recipe_01 and a suffix of .py.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个完整路径名列出了包含在（未命名的）根目录中的七个命名目录。最后的名称有一个 recipe_01 的前缀和 .py 的后缀。
- en: We can represent this as a string, and parse the string to locate directory
    names, file stems, and suffix strings. Doing this isn’t portable between the macOS
    and Linux operating systems, which use "/" for a separator, and Windows, which
    uses "\" for a separator. Further, Windows files may also have device names as
    a prefix to the path.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其表示为一个字符串，并解析该字符串以定位目录名称、文件名和后缀字符串。这样做在macOS和Linux操作系统之间不可移植，它们使用"/"作为分隔符，而Windows使用"\"作为分隔符。此外，Windows文件可能还有设备名称作为路径的前缀。
- en: Dealing with edge cases like "/" in a filename or "." in a directory name can
    make string processing needlessly difficult. We can simplify parsing and many
    filesystem operations by using pathlib.Path objects instead of strings.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件名中的“/”或目录名中的“.”等边缘情况会使字符串处理变得不必要地困难。我们可以通过使用pathlib.Path对象而不是字符串来简化解析和许多文件系统操作。
- en: 11.1.1 Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.1 准备工作
- en: 'It’s important to separate three concepts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分三个概念：
- en: A path that identifies a file, including the name
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标识文件的路径，包括文件名
- en: Metadata for a file – like creation timestamps and ownership – kept in the directory
    tree
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件元数据，如创建时间戳和所有权，存储在目录树中
- en: The contents of the file
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件内容
- en: The contents of the files are independent of the directory information. It’s
    common for multiple directory entries to be linked to the same content. This can
    be done with hard links, where the directory information is shared among multiple
    paths, and soft links, where a special kind of file contains a reference to another
    file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容与目录信息无关。多个目录条目链接到相同内容是很常见的。这可以通过硬链接来完成，其中目录信息在多个路径之间共享，以及软链接，其中一种特殊类型的文件包含对另一个文件的引用。
- en: Often, a filename has a suffix (or extension) used as a hint as to what the
    physical format is. A filename ending in .csv is likely a text file that can be
    interpreted as rows and columns of data. This binding between name and physical
    format is not absolute. File suffixes are only a hint and can be wrong.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件名有一个后缀（或扩展名），用作关于物理格式的提示。以.csv结尾的文件名很可能是一个可以解释为行和列数据的文本文件。这种名称与物理格式之间的绑定不是绝对的。文件后缀只是一个提示，可能会出错。
- en: 'In Python, the pathlib module handles all path-related processing. The module
    makes several distinctions among paths:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，pathlib模块处理所有与路径相关的处理。该模块在路径之间做出几个区分：
- en: Pure paths that may or may not refer to an actual file
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能或可能不指向实际文件的纯路径
- en: Concrete paths that are resolved; these refer to an actual file
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析的具体路径；这些指的是一个实际文件
- en: This distinction allows us to create pure paths for files that our application
    will possibly create or refer to. We can also create concrete paths for those
    files that actually exist on the OS. An application often resolves a pure path
    to a concrete path.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区分使我们能够为应用可能创建或引用的文件创建纯路径。我们也可以为实际存在于操作系统上的文件创建具体路径。应用程序通常将纯路径解析为具体路径。
- en: While the pathlib module can make a distinction between Linux path objects and
    Windows path objects, this distinction is rarely needed. An important reason for
    using pathlib is because we want processing that is isolated from the details
    of the underlying OS.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然pathlib模块可以在Linux路径对象和Windows路径对象之间做出区分，但这种区分很少需要。使用pathlib的一个重要原因是，我们希望处理与底层操作系统的细节隔离。
- en: 'All of the mini recipes in this section will leverage the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有迷你食谱都将利用以下内容：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We’ll also presume the argparse module is used to gather the file or directory
    names. For more information on argparse, see the [Using argparse to get command-line
    input](ch010.xhtml#x1-3490004) recipe in Chapter [6](ch010.xhtml#x1-3300006).
    We’ll use an options variable as a namespace that contains the input filename
    or directory name that the recipe works with. As an example, we’ll use the following
    Namespace object:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设使用argparse模块来收集文件或目录名称。有关argparse的更多信息，请参阅第[6](ch010.xhtml#x1-3300006)章中的[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)食谱。我们将使用一个options变量作为命名空间，该命名空间包含食谱处理的输入文件名或目录名。作为一个例子，我们将使用以下Namespace对象：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Frequently, we’ll define argparse options to use type=Path so that the argument
    parsing creates Path objects for us. For the purposes of showing how Path objects
    work, the path information is provided as string values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会定义argparse选项使用type=Path，以便参数解析为我们创建Path对象。为了展示Path对象的工作方式，路径信息以字符串值的形式提供。
- en: 11.1.2 How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.2 如何操作...
- en: 'We’ll show a number of common pathname manipulations in the following mini-recipes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下迷你食谱中，我们将展示一些常见的路径名操作：
- en: '[Making the output filename by changing the input filename’s suffix](ch015_split_000.xhtml#x1-6190002)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过更改输入文件名后缀来创建输出文件名](ch015_split_000.xhtml#x1-6190002)'
- en: '[Making a number of sibling output files with distinct names](ch015_split_000.xhtml#x1-6200002)'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建具有不同名称的多个同级输出文件](ch015_split_000.xhtml#x1-6200002)'
- en: '[Comparing file dates to see which is newer](ch015_split_000.xhtml#x1-6210002)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[比较文件日期以查看哪个更新](ch015_split_000.xhtml#x1-6210002)'
- en: '[Finding all files that match a given pattern](ch015_split_000.xhtml#x1-6220002)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[查找所有匹配给定模式的文件](ch015_split_000.xhtml#x1-6220002)'
- en: The first two reflect techniques for working with the path of directories to
    a file; using a Path object is much easier than doing sophisticated string manipulation.
    The last two gather information about concrete paths and the related files on
    a computer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个反映了处理目录到文件路径的技术；使用Path对象比进行复杂的字符串操作要容易得多。最后两个收集有关计算机上具体路径和相关文件的信息。
- en: Making the output filename by changing the input filename’s suffix
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过更改输入文件名后缀来创建输出文件名
- en: 'Perform the following steps to create the output filename from an input filename
    by changing the input name’s suffix:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改输入名称的后缀来创建输出文件名的以下步骤：
- en: 'Create a Path object from the input filename string:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入文件名字符串创建一个Path对象：
- en: '[PRE3]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The PosixPath class is displayed because the author is using macOS. On a Windows
    machine, the class would be WindowsPath.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显示PosixPath类，因为作者正在使用macOS。在Windows机器上，该类将是WindowsPath。
- en: 'Create the output Path object using the with_suffix() method:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用with_suffix()方法创建输出Path对象：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All of the filename parsing is handled seamlessly by the Path class. This doesn’t
    create the concrete output file; it merely creates a new Path for it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件名解析都由Path类无缝处理。这不会创建具体的输出文件；它只是为它创建了一个新的Path对象。
- en: Making a number of sibling output files with distinct names
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建具有不同名称的多个同级输出文件
- en: 'Perform the following steps to make a number of sibling output files with distinct
    names:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改输入名称的后缀来创建具有不同名称的多个同级输出文件：
- en: 'Create a Path object from the input filename string:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入文件名字符串创建一个Path对象：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Extract the parent directory and the stem from the filename. The stem is the
    name without the suffix:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件名中提取父目录和基本名称。基本名称是没有后缀的名称：
- en: '[PRE6]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build the desired output name. For this example, we’ll append _pass to the
    stem and build the complete Path object:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建所需的输出名称。对于此示例，我们将追加_pass到基本名称并构建完整的Path对象：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The / operator assembles a new Path from Path components. We need to put the
    / operation in parentheses to be sure that it’s performed first, to create a new
    Path object before changing the suffix.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: /运算符从Path组件组装一个新的Path。我们需要将/运算放在括号中，以确保它首先执行，在更改后缀之前创建一个新的Path对象。
- en: Comparing file dates to see which is newer
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较文件日期以查看哪个更新
- en: 'The following are the steps to see newer file dates by comparing them:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是比较文件日期以查看哪个更新的步骤：
- en: 'Create the Path objects from the input filename strings. The Path class will
    properly parse the string to determine the elements of the path:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入文件名字符串创建Path对象。Path类将正确解析字符串以确定路径的元素：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When exploring this example, be sure the names in the options object are actual
    files.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在探索此示例时，请确保options对象中的名称是实际文件。
- en: 'Use the stat() method of each Path object to get timestamps for the file. Within
    the stat object, the st_mtime— attribute provides the most recent modification
    time for the file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用每个Path对象的stat()方法获取文件的戳记。在stat对象中，st_mtime属性提供了文件的最新修改时间：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The values are timestamps measured in seconds. Your values will depend on the
    files on your system. If we want a timestamp that seems sensible to most people,
    we can use the datetime module to create a more useful object from this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是以秒为单位的时间戳。您的值将取决于您系统上的文件。如果我们想要一个对大多数人来说都合理的时间戳，我们可以使用datetime模块从这个值创建一个更有用的对象：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can use any of a number of methods to format the datetime object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方法来格式化datetime对象。
- en: Finding all files that match a given pattern
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找所有匹配给定模式的文件
- en: 'The following are the steps to find all the files that match a given pattern:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要查找所有匹配给定模式的文件的步骤：
- en: 'Create the Path object from the input directory name:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输入目录名创建Path对象：
- en: '[PRE12]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Use the glob() method of the Path object to locate all files in this directory
    that match a given pattern. For non-existent directories, the iterator will be
    empty. Using ** as part of the pattern will recursively walk the directory tree:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Path 对象的 glob() 方法定位此目录中所有匹配给定模式的文件。对于不存在的目录，迭代器将为空。在模式中使用 ** 将递归遍历目录树：
- en: '[PRE13]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We’ve elided a number of the files in the results.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们省略了结果中的许多文件。
- en: The glob() method is an iterator, and we’ve used the sorted() function to consume
    the values from this iterator and create a single list object from them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: glob() 方法是一个迭代器，我们使用了 sorted() 函数来消费这个迭代器的值，并从它们创建一个单独的列表对象。
- en: 11.1.3 How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.3 它是如何工作的...
- en: Inside the OS, the sequence of directories to find a file is a path through
    the filesystem. In some cases, a simple string representation can be used to summarize
    the path. The string representation, however, makes many kinds of path operations
    into complex string parsing problems. A string is an unhelpfully opaque abstraction
    for working with OS paths.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中，查找文件的目录序列是通过文件系统路径实现的。在某些情况下，可以使用简单的字符串表示来总结路径。然而，字符串表示使得许多路径操作变成了复杂的字符串解析问题。字符串对于操作操作系统路径来说是一个无用的不透明抽象。
- en: 'The Path class definition simplifies operations on paths. These attributes,
    methods, and operators on a Path instance include the following examples:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Path 类定义简化了路径操作。Path 实例上的这些属性、方法和运算符包括以下示例：
- en: .parent extracts the parent directory.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .parent 提取父目录。
- en: .parents enumerates all the enclosing directories.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .parents 列出所有封装的目录。
- en: .name is the final name.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .name 是最终名称。
- en: .stem is the stem of the final name (without any suffix).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .stem 是最终名称的基名（不带任何后缀）。
- en: .suffix is the final suffix.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .suffix 是最终的后缀。
- en: .suffixes is the sequence of suffix values, used with file.tag.gz kinds of names.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .suffixes 是后缀值序列，用于与 file.tag.gz 类型的名称一起使用。
- en: The .with_suffix() method replaces the suffix of the file with a new suffix.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .with_suffix() 方法用新的后缀替换文件的后缀。
- en: The .with_name() method replaces the name in the path with a new name.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .with_name() 方法用新的名称替换路径中的名称。
- en: The / operator builds Path objects from Path and string components.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: / 操作符从 Path 和字符串组件构建 Path 对象。
- en: 'A concrete path represents an actual filesystem resource. For concrete path
    objects, we can do a number of additional manipulations of the directory information:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 具体路径代表实际的文件系统资源。对于具体的路径对象，我们可以对目录信息进行一系列额外的操作：
- en: Determine what kind of directory entry this is; that is, an ordinary file, a
    directory, a link, a socket, a named pipe (or FIFO), a block device, or a character
    device.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定这种目录条目是什么类型；即普通文件、目录、链接、套接字、命名管道（或 FIFO）、块设备或字符设备。
- en: Get the directory details, including information such as timestamps, permissions,
    ownership, size, and so on.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取目录详细信息，包括时间戳、权限、所有权、大小等信息。
- en: Unlink (that is, remove) the directory entry. Note that unlinking ordinary files
    is distinct from removing an empty directory. We’ll look at this in the There’s
    more... section of this recipe.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解除链接（即删除）目录条目。请注意，解除普通文件的链接与删除空目录是不同的。我们将在本食谱的 There’s more... 部分中探讨这一点。
- en: Rename the file to place it in a new path. We’ll also look at this in the There’s
    more... section of this recipe.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件重命名以将其放置在新的路径中。我们也会在本食谱的 There’s more... 部分中探讨这一点。
- en: Just about anything we might want to do with directory entries for files can
    be done with the pathlib module. The few exceptions are part of the os module,
    because they are generally OS-specific.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎我们可以对文件目录执行的所有操作都可以使用 pathlib 模块来完成。少数例外是 os 模块的一部分，因为它们通常是特定于操作系统的。
- en: 11.1.4 There’s more...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.4 更多内容...
- en: 'In addition to manipulating the path and gathering information about a file,
    we can also make some changes to the filesystem. Two common operations are renaming
    a file and unlinking (or removing) a file. We can use a number of methods to make
    changes to the filesystem:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了操作路径和收集有关文件的信息外，我们还可以对文件系统进行一些更改。两个常见的操作是重命名文件和解除链接（或删除）文件。我们可以使用多种方法来更改文件系统：
- en: The .unlink() method removes ordinary files. It doesn’t remove directories.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .unlink() 方法删除普通文件。它不会删除目录。
- en: The .rmdir() method removes empty directories. Removing a directory with files
    requires a two-step operation to first unlink all the files in the directory,
    then remove the directory.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .rmdir() 方法删除空目录。删除包含文件的目录需要两步操作：首先解除目录中所有文件的联系，然后删除目录。
- en: The .rename() method renames a file to a new path.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .rename() 方法将文件重命名为新路径。
- en: The .replace() method replaces a file without raising an exception if the target
    already exists.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .replace() 方法在目标已存在的情况下不会引发异常来替换文件。
- en: The .symlink_to() method creates a soft link file with a link to an existing
    file.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .symlink_to() 方法创建一个指向现有文件的软链接文件。
- en: The .hardlink_to() method creates an OS hard link; two distinct directory entries
    will now own the underlying file content.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .hardlink_to() 方法创建一个操作系统硬链接；现在两个不同的目录条目将拥有底层文件内容。
- en: 'We can open a Path either using the built-in open() function or the open()
    method. Some people like to see open(some_path), where others prefer some_path.open().
    Both do the same thing: create an open file object.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过内置的 open() 函数或 open() 方法来打开一个路径。有些人喜欢看到 open(some_path)，而有些人则更喜欢 some_path.open()。两者都做同样的事情：创建一个打开的文件对象。
- en: 'We can create directories using the mkdir() method. There are two keyword parameters
    for this method:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 mkdir() 方法创建目录。此方法有两个关键字参数：
- en: exist_ok=False is the default; if the directory already exists, an exception
    is raised. Changing this to True makes the code tolerant of an existing directory.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: exist_ok=False 是默认值；如果目录已存在，将引发异常。将此更改为 True 使代码对现有目录具有容错性。
- en: parents=False is the default; the parents are not created, only the child-most
    directory in the path. Changing this to True will create the entire path, parents
    and children.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: parents=False 是默认值；不会创建父目录，只有路径中的最底层目录。将此更改为 True 将创建整个路径，包括父目录和子目录。
- en: 'We can also read and write files as large string or bytes objects:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以以大字符串或字节对象的形式读取和写入文件：
- en: The .read_text() method reads a file as a single string.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .read_text() 方法将文件作为单个字符串读取。
- en: The .write_text() method creates or replaces a file with the given string.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .write_text() 方法使用给定的字符串创建或替换文件。
- en: The .read_bytes() method reads a file as a single bytes instance.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .read_bytes() 方法将文件作为单个字节实例读取。
- en: The .write_bytes() method creates or replaces a file with the given bytes.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .write_bytes() 方法使用给定的字节创建或替换文件。
- en: There are yet more file system operations, like changing ownership or changing
    permissions. These operations are available in the os module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多文件系统操作，如更改所有权或更改权限。这些操作在 os 模块中可用。
- en: 11.1.5 See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1.5 参见
- en: In the [Replacing a file while preserving the previous version](ch015_split_000.xhtml#x1-6260002)
    recipe, later in this chapter, we’ll look at how to leverage the features of a
    Path object to create a temporary file and then rename the temporary file to replace
    the original file.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章后面的 [在保留先前版本的同时替换文件](ch015_split_000.xhtml#x1-6260002) 菜谱中，我们将探讨如何利用路径对象的功能来创建一个临时文件，然后将临时文件重命名为替换原始文件。
- en: In the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    in Chapter [6](ch010.xhtml#x1-3300006), we looked at one very common way to use
    a string to create a Path object.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [6](ch010.xhtml#x1-3300006) 章的 [使用 argparse 获取命令行输入](ch010.xhtml#x1-3490004)
    菜谱中，我们查看了一种非常常见的方法，即使用字符串来创建路径对象。
- en: The os module offers a number of filesystem operations that are less commonly
    used than the ones provided by pathlib.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: os 模块提供了一些比 pathlib 提供的更不常用的文件系统操作。
- en: 11.2 Replacing a file while preserving the previous version
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.2 在保留先前版本的同时替换文件
- en: We can leverage the power of the pathlib module to support a variety of filename
    manipulations. In the [Using pathlib to work with filenames](ch015_split_000.xhtml#x1-6160001)
    recipe in this chapter, we looked at a few of the most common techniques for managing
    directories, filenames, and file suffixes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 pathlib 模块的功能来支持各种文件名操作。在第 [使用 pathlib 处理文件名](ch015_split_000.xhtml#x1-6160001)
    菜谱中，我们查看了一些管理目录、文件名和文件后缀的最常见技术。
- en: One common file processing requirement is to create output files in a fail-safe
    manner; that is, the application should preserve any previous output file, no
    matter how or where the application fails.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的文件处理需求是以安全的方式创建输出文件；也就是说，无论应用程序如何或在哪里失败，应用程序都应该保留任何先前的输出文件。
- en: 'Consider the following scenario:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：
- en: At time T[0], there’s a valid output.csv file from a previous run of the long_complex.py
    application.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间 T[0] 时，有一个来自 long_complex.py 应用程序先前运行的 valid output.csv 文件。
- en: At time T[1], we start running the long_complex.py application using new data.
    It begins overwriting the output.csv file. Until the program finishes, the bytes
    will be unusable.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间 T[1] 时，我们开始使用新数据运行 long_complex.py 应用程序。它开始覆盖 output.csv 文件。直到程序完成，字节将不可用。
- en: At time T[2], the application crashes. The partial contents of the output.csv
    file are useless. Worse, the valid file from time T[0] is no longer available
    either because it was overwritten.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在时间 T[2] 时，应用程序崩溃。output.csv 文件的局部内容是无用的。更糟糕的是，时间 T[0] 的有效文件也不再可用，因为它被覆盖了。
- en: In this recipe, we’ll look at an approach to creating output files that’s safe
    in the event of a failure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨在失败情况下创建输出文件的一种安全方法。
- en: 11.2.1 Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.1 准备工作
- en: For files that don’t span across physical devices, fail-safe file output generally
    means creating a new copy of the file using a temporary name. If the new file
    can be created successfully, then the old file should be replaced using a single,
    atomic rename operation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不跨越物理设备的文件，安全文件输出通常意味着使用临时名称创建文件的新副本。如果新文件可以成功创建，则应使用单个原子重命名操作替换旧文件。
- en: 'We want to have the following features:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有以下功能：
- en: The important output file must be preserved in a valid state at all times.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的输出文件必须始终以有效状态保存。
- en: 'A temporary version of the file is written by the application. There are a
    variety of conventions for naming this file. Sometimes, extra characters such
    as ~ or # are placed on the filename to indicate that it’s a temporary, working
    file; for example, output.csv~. We’ll use a longer suffix, .new; for example,
    output.csv.new.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '应用程序写入文件的临时版本。命名此文件有许多约定。有时，在文件名上放置额外的字符，如 ~ 或 #，以指示它是临时的工作文件；例如，output.csv~。我们将使用更长的后缀，.new；例如，output.csv.new。'
- en: The previous version of the file is also preserved. Sometimes, the previous
    version has a suffix of .bak, meaning ”backup.” We’ll use a longer suffix and
    call it output.csv.old. This also means any previous .old file must be removed
    as part of finalizing the output; only a single version is preserved.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的先前版本也被保留。有时，先前版本有一个 .bak 后缀，表示“备份”。我们将使用更长的后缀，称为 output.csv.old。这也意味着任何先前的
    .old 文件都必须作为最终输出的一部分被删除；只保留一个版本。
- en: 'To create a concrete example, we’ll work with a file that has a very small
    but precious piece of data: a sequence of Quotient objects. Here’s the definition
    for the Quotient class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个具体的例子，我们将使用一个包含非常小但珍贵的部分数据的文件：一系列商对象。以下是商类的定义：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following function will write an object to a file in CSV notation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数将对象写入 CSV 格式的文件：
- en: '[PRE15]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If a problem arises when writing the data object to the file, we could be left
    with a corrupted, unusable file. We’ll wrap this function with another to provide
    a reliable write.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在将数据对象写入文件时出现问题，我们可能会留下一个损坏的、不可用的文件。我们将用另一个函数包装此函数，以提供可靠的写入。
- en: 11.2.2 How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.2 如何操作...
- en: 'We start creating a wrapper function by importing the classes we need:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过导入所需的类开始创建一个包装函数：
- en: 'Define a function to encapsulate the save_data() function along with a few
    extra features. The function signature is the same as the save_data() function:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来封装 save_data() 函数以及一些额外功能。函数签名与 save_data() 函数相同：
- en: 'Save the original suffix and create a new name with .new at the end of the
    suffix. This is a temporary file. If it is written properly, with no exceptions,
    then we can rename it so that it’s the target file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存原始后缀，并在后缀末尾创建一个带有 .new 的新名称。这是一个临时文件。如果它正确写入，没有异常，那么我们可以重命名它，使其成为目标文件：
- en: '[PRE16]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The save_data() function is the original process to create the new file being
    wrapped by this function.
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: save_data() 函数是封装在此函数中的创建新文件的原始过程。
- en: 'Before replacing the previous file with the new, good file, remove any previous
    backup copy. We’ll unlink an .old file, if one exists:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用新文件替换旧文件之前，删除任何先前的备份副本。如果存在，我们将解除 .old 文件的链接：
- en: '[PRE17]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can preserve any previous good file with the name of .old:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以保留任何先前的良好文件，其名称为 .old：
- en: '[PRE18]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The final step is to make the temporary .new file the official output:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将临时的 .new 文件变为官方输出：
- en: '[PRE19]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This multi-step process uses two rename operations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多步骤过程使用两个重命名操作：
- en: Rename the previous version to a backup version with .old appended to the suffix.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将先前的版本重命名为带有后缀 .old 的备份版本。
- en: Rename the new version, which had .new appended to the suffix, to be the current
    version of the file.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将带有 .new 后缀的新版本重命名为文件的当前版本。
- en: A Path object has a replace() method. This always overwrites the target file,
    with no warning if overwriting an existing file. The choice between rename() and
    replace() depends on how our application needs to handle cases where old versions
    of files may be left in the filesystem. We’ve used rename() in this recipe to
    try and avoid overwriting files in the case of multiple problems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Because these are applied serially, there’s a tiny span of time between preserving
    the old file and renaming the new file where an application failure would fail
    to put a new file in place. We’ll look at this in the next section.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.3 How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This process involves three separate OS operations: an unlink and two renames.
    This is designed to ensure that an .old file is preserved and can be used to recover
    the previously good state.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a timeline that shows the state of the various files. We’ve labeled
    the content as version 0 (some previous data), version 1 (the current, valid data),
    and version 2 (the newly created data):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '| Time | Operation | .csv.old | .csv | .csv.new |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '| T[0] |  | version 0 | version 1 |  |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '| T[1] | Mid-creation | version 0 | version 1 | Will appear corrupt if used
    |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '| T[2] | Post-creation, closed | version 0 | version 1 | version 2 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '| T[3] | After unlinking .csv.old |  | version 1 | version 2 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '| T[4] | After renaming .csv to .csv.old | version 1 |  | version 2 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '| T[5] | After renaming .csv.new to .csv | version 1 | version 2 |  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |  |  |  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
- en: 'Table 11.1: Timeline of file operations'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are several opportunities for failure, there’s no ambiguity about
    which file is valid:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: If there’s a .csv file, it’s the current, valid file.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there’s no .csv file, then the .csv.old file is a valid backup copy, which
    should be used for recovery. See the T[4] moment in time, for this condition.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since none of these operations involve actually copying the files, the operations
    are all extremely fast and reliable. They are, however, not guaranteed to work.
    The state of the filesystem can be changed by any user with the right permissions,
    leading to the need for care when creating new files that replace old files.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the output file is valid, some applications will take an additional
    step and write a final checksum row in the file to provide unambiguous evidence
    that the file is complete and consistent.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 11.2.4 There’s more...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some enterprise applications, output files are organized into directories
    with names based on timestamps. These operations can be handled gracefully by
    the pathlib module. We might, for example, have an archive directory for old files.
    This directory has date-stamped subdirectories for keeping temporary or working
    files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些企业应用中，输出文件被组织成基于时间戳命名的目录。这些操作可以通过 pathlib 模块优雅地处理。例如，我们可能有一个用于旧文件的存档目录。这个目录包含带有日期戳的子目录，用于存储临时或工作文件。
- en: 'We can then do the following to define a working directory:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行以下操作来定义一个工作目录：
- en: '[firstline=58,lastline=58,gobble=4][python]src/ch11/recipe˙02.py [firstline=60,lastline=65,gobble=4][python]src/ch11/recipe˙02.py'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[firstline=58,lastline=58,gobble=4][python]src/ch11/recipe˙02.py [firstline=60,lastline=65,gobble=4][python]src/ch11/recipe˙02.py'
- en: The mkdir() method will create the expected directory. By including the parents=True
    argument, any needed parent directories will also be created. This can be handy
    to create the archive_path the very first time an application is executed. The
    exists_ok=True will avoid raising an exception if the archive directory already
    exists.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: mkdir() 方法将创建预期的目录。通过包含 parents=True 参数，任何需要的父目录也将被创建。这可以在应用程序第一次执行时创建 archive_path
    非常方便。exists_ok=True 将避免在存档目录已存在时引发异常。
- en: For some applications it can be appropriate to use the tempfile module to create
    temporary files. This module can create filenames that are guaranteed to be unique.
    This allows a complex server process to create temporary files without regard
    to filename conflicts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，使用 tempfile 模块创建临时文件可能是合适的。此模块可以创建保证唯一的文件名。这允许复杂的服务器进程在无需考虑文件名冲突的情况下创建临时文件。
- en: 11.2.5 See also
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2.5 参见
- en: In the [Using pathlib to work with filenames](ch015_split_000.xhtml#x1-6160001)
    recipe, earlier in this chapter, we looked at the fundamentals of the Path class.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的[使用 pathlib 处理文件名](ch015_split_000.xhtml#x1-6160001)配方中，我们探讨了 Path 类的基本原理。
- en: In Chapter [15](ch019_split_000.xhtml#x1-79400015), we’ll look at some techniques
    for writing unit tests that can ensure that parts of this recipe’s example code
    will behave properly.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [15](ch019_split_000.xhtml#x1-79400015) 章，我们将探讨一些编写单元测试的技术，以确保本配方示例代码的部分行为正确。
- en: In Chapter [6](ch010.xhtml#x1-3300006), the [Creating contexts and context managers](ch011_split_001.xhtml#x1-43700011)
    recipe shows additional details regarding working with the with statement to ensure
    file operations complete properly, and that all of the OS resources are released.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [6](ch010.xhtml#x1-3300006) 章，[创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011)配方展示了有关使用
    with 语句确保文件操作正确完成以及释放所有 OS 资源的更多细节。
- en: The shutil module provides a number of methods for copying files and directories
    full of files. This package reflects features of Linux shell programs like cp,
    as well as Windows programs like copy and xcopy.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: shutil 模块提供了一系列用于复制文件和包含文件的目录的方法。这个包反映了 Linux shell 程序（如 cp）以及 Windows 程序（如
    copy 和 xcopy）的功能。
- en: 11.3 Reading delimited files with the CSV module
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.3 使用 CSV 模块读取分隔符文件
- en: One commonly used data format is comma-separated values (CSV). We can generalize
    this to think of the comma character as simply one of many candidate separator
    characters. For example, a CSV file can use the | character as the separator between
    columns of data. This generalization for separators other than the literal , makes
    CSV files particularly powerful.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的数据格式是逗号分隔值（CSV）。我们可以将逗号字符视为众多候选分隔符之一。例如，CSV 文件可以使用 | 字符作为数据列之间的分隔符。这种对非逗号分隔符的泛化使得
    CSV 文件特别强大。
- en: How can we process data in one of the wide varieties of CSV formats?
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理各种 CSV 格式的数据？
- en: 11.3.1 Getting ready
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.1 准备工作
- en: A summary of a file’s content is called a schema. It’s essential to distinguish
    between two aspects of a schema.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容的摘要称为模式。区分模式的两个方面是至关重要的。
- en: The physical format of a CSV file’s bytes encode lines of text. For CSV files,
    the text is organized into rows and columns using a row separator character (or
    characters) and a column separator character. Many spreadsheet products will use
    , (comma) as the column separator and the \r\n sequence of characters as the row
    separator. The specific combination of punctuation characters in use is called
    the CSV dialect.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 文件的字节物理格式编码文本行。对于 CSV 文件，文本使用行分隔符字符（或字符序列）和列分隔符字符组织成行和列。许多电子表格产品将使用 ,（逗号）作为列分隔符，将
    \r\n 字符序列作为行分隔符。使用的标点符号字符的具体组合称为 CSV 语法。
- en: Additionally, column data can be quoted when it contains one of the separators.
    The most common quoting rules are to surround the column value with " characters.
    In order to include the quote character in column data, the quote character is
    doubled. For example, "He said, ""Thanks.""".
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当列数据包含分隔符之一时，可以引用列数据。最常见的引用规则是用"字符包围列值。为了在列数据中包含引号字符，引号字符被加倍。例如，"He said,
    ""Thanks."""。
- en: 'The logical layout of the data in the file is a sequence of data columns that
    are present. There are several common cases for handling the logical layout in
    CSV files:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中数据的逻辑布局是一系列存在的数据列。在CSV文件中处理逻辑布局有几种常见情况：
- en: The file may have one line of headings. This fits nicely with the way the csv
    module works. It can be even more helpful when the headings are also proper Python
    variable names. The schema is stated explicitly in the first line of the file.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件可能有一行标题。这与csv模块的工作方式很好地吻合。如果标题也是合适的Python变量名，那么这会更有帮助。模式在文件的第一行中明确声明。
- en: The file has no headings, but the column positions are fixed. In this case,
    we can impose headings on the file when we open it. Pragmatically, this involves
    some risk because it’s difficult to confirm that the data meets the imposed schema.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件没有标题，但列位置是固定的。在这种情况下，我们可以在打开文件时在文件上施加标题。从实用主义的角度来看，这涉及一些风险，因为很难确认数据符合施加的模式。
- en: If the file has no headings and the column positions aren’t fixed. In this case,
    additional external schema information is required to interpret the columns of
    data.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件没有标题且列位置不固定。在这种情况下，需要额外的外部模式信息来解释数据列。
- en: There are, of course, some common complications that can arise with any data.
    Some files are not in First Normal Form (1NF). In 1NF, each row is independent
    of all other rows. When a file is not in this normal form, we’ll need to add a
    generator function to rearrange the data into 1NF rows. See the [Slicing and dicing
    a list](ch008_split_000.xhtml#x1-2400003) recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004),
    and the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)
    recipe in Chapter [9](ch013_split_000.xhtml#x1-5020009), for other recipes that
    show how to normalize data structures.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何数据都可能出现的某些常见复杂问题。有些文件不是第一范式（1NF）。在1NF中，每一行都是独立于所有其他行的。当一个文件不处于这种范式时，我们需要添加一个生成器函数来重新排列数据以形成1NF行。请参阅第[4](ch008_split_000.xhtml#x1-2240004)章中的[Slicing
    and dicing a list](ch008_split_000.xhtml#x1-2400003)配方，以及第[9](ch013_split_000.xhtml#x1-5020009)章中的[Using
    stacked generator expressions](ch013_split_000.xhtml#x1-5180003)配方，以了解其他显示如何规范化数据结构的配方。
- en: 'We’ll look at a CSV file that has some real-time data recorded from the log
    of a sailboat. This is the waypoints.csv file. The data looks as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个包含从帆船日志中记录的一些实时数据的CSV文件。这是waypoints.csv文件。数据如下所示：
- en: '[PRE20]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This data contains four columns named in the first line of the file: lat, lon,
    date, and time. These describe a waypoint and need to be reformatted to create
    more useful information.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据包含文件第一行中命名的四个列：lat、lon、date和time。这些描述了一个航点，需要重新格式化以创建更有用的信息。
- en: 11.3.2 How to do it...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.2 如何实现...
- en: 'Before starting to write any code, examine the data file to confirm the following
    features:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写任何代码之前，检查数据文件以确认以下功能：
- en: The column separator character is ’,’, which is the default.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列分隔符字符是’,’，这是默认值。
- en: The row separator characters are ’\r\n’, also widely used in both Windows and
    Linux.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行分隔符字符是’\r\n’，在Windows和Linux中都广泛使用。
- en: There is a single-row heading. If this isn’t present, the headings should be
    provided separately when the reader object is created.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个单行标题。如果不存在，当创建读取器对象时，应单独提供标题。
- en: 'Once the format has been confirmed, we can start creating the needed functions
    as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦格式得到确认，我们就可以开始创建所需的函数，如下所示：
- en: 'Import the csv module and the Path class:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入csv模块和Path类：
- en: '[PRE21]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Define a raw() function to read raw data from a Path object that refers to
    the file:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个raw()函数，从指向文件的Path对象中读取原始数据：
- en: '[PRE22]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Use the Path object to open the file in a with statement. Build the reader
    from the open file:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Path对象在with语句中打开文件。从打开的文件构建读取器：
- en: '[PRE23]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Consume (and process) the rows of data from the iterable reader. This is properly
    indented inside the with statement:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消费（并处理）可迭代读取器的数据行。这正确地缩进在with语句内：
- en: '[PRE24]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output from the raw() function is a series of dictionaries that look as
    follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: raw()函数的输出是一系列看起来如下所示的字典：
- en: '[PRE25]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can now process the data by referring to the columns as dictionary items,
    using syntax like, for example, row[’date’]. Using the column names is more descriptive
    than referring to the column by position; for example, row[0] is hard to understand.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过将列作为字典项来处理数据，使用例如row[’date’]这样的语法。使用列名比通过位置引用列更具有描述性；例如，row[0]难以理解。
- en: To be sure that we’re using the column names correctly, the typing.TypedDict
    type hint can be used to provide the expected column names.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们正确地使用了列名，可以使用typing.TypedDict类型提示来提供预期的列名。
- en: 11.3.3 How it works...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.3 它是如何工作的...
- en: The csv module handles the work of parsing the physical format. This separates
    the rows from each other, and also separates the columns within each row. The
    default rules ensure that each input line is treated as a separate row and that
    the columns are separated by ’,’.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: csv模块处理解析物理格式的工作。这使行彼此分离，并在每行内分离列。默认规则确保每条输入行被视为单独的行，并且列由逗号分隔。
- en: 'What happens when we need to use the column separator character as part of
    data? We might have data like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要将列分隔符字符作为数据的一部分使用时会发生什么？我们可能会有这样的数据：
- en: '[PRE26]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The notes column has data in the first row, which includes the ’,’ column separator
    character. The rules for CSV allow a column’s value to be surrounded by quotes.
    By default, the quoting characters are ". Within these quoting characters, the
    column and row separator characters are ignored.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注释列在第一行有数据，包括逗号分隔符字符。CSV的规则允许列的值被引号包围。默认情况下，引号字符是"。在这些引号字符内，列和行分隔符字符被忽略。
- en: In order to embed the quote character within a quoted string, the character
    is doubled. The second example row shows how the value blowing "like stink" is
    encoded by doubling the quote characters when they are part of the value of a
    column.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在引号字符串中嵌入引号字符，该字符被加倍。第二个示例行显示了如何通过将引号字符加倍来编码值"like stink"，当它们是列值的一部分时。
- en: The values in a CSV file are always strings. A string value like 7331 may look
    like a number to us, but it’s always text when processed by the csv module. This
    makes the processing simple and uniform, but it can be awkward for our Python
    applications.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件中的值始终是字符串。像7331这样的字符串值可能看起来像数字，但它在csv模块处理时始终是文本。这使得处理简单且统一，但可能对我们的Python应用程序来说有些尴尬。
- en: When data is saved from a manually prepared spreadsheet, the data may reveal
    the quirks of the desktop software’s internal rules for data display. Data that
    is displayed as a date on the desktop software is stored as a floating-point number
    in the CSV file.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当从手动准备的电子表格中保存数据时，数据可能会揭示桌面软件内部数据显示规则的古怪之处。在桌面软件中显示为日期的数据在CSV文件中存储为浮点数。
- en: There are two solutions to the date-as-number problem. One is to add a column
    in the source spreadsheet to properly format the date data as a string. Ideally,
    this is done using ISO rules so that the date is represented in the YYYY-MM-DD
    format. The other solution is to recognize the spreadsheet date as a number of
    seconds past some epochal date. The epochal dates vary slightly with versions
    of various tools, but they’re generally Jan 1, 1900\. (A few spreadsheet applications
    used Jan 1, 1904.)
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 日期作为数字的问题有两个解决方案。一个是向源电子表格中添加一个列，以正确格式化日期数据为字符串。理想情况下，这是使用ISO规则完成的，以便日期以YYYY-MM-DD格式表示。另一个解决方案是将电子表格中的日期识别为从某个纪元日期以来的秒数。纪元日期随着各种工具的版本略有不同，但通常是1900年1月1日。（一些电子表格应用程序使用1904年1月1日。）
- en: 11.3.4 There’s more...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.4 更多内容...
- en: As we saw in the [Combining the map and reduce transformations](ch013_split_001.xhtml#x1-5440006)
    recipe in Chapter [9](ch013_split_000.xhtml#x1-5020009), there’s often a pipeline
    of processing that includes cleaning and transforming the source data. This idea
    of stacked generator functions lets a Python program process large volumes of
    data. Reading one row at a time can avoid reading all the data into a vast, in-memory
    list. In this specific example, there are no extra rows that need to be eliminated.
    However, each column needs to be converted into something more useful.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第[9](ch013_split_000.xhtml#x1-5020009)章的[结合map和reduce转换](ch013_split_001.xhtml#x1-5440006)食谱中看到的，通常有一个包括清理和转换源数据的处理流程。这种堆叠生成器函数的想法让Python程序能够处理大量数据。一次读取一行可以避免将所有数据读入一个庞大的内存列表。在这个特定例子中，没有需要消除的额外行。然而，每个列都需要转换成更有用的形式。
- en: In Chapter [10](ch014.xhtml#x1-57300010), a number of recipes use Pydantic to
    perform these kinds of data conversions. See the [Implementing more strict type
    checks with Pydantic](ch014.xhtml#x1-6000005) recipe for an example of this alternative
    approach.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [10](ch014.xhtml#x1-57300010) 章中，许多配方使用 Pydantic 来执行这些类型的数据转换。参见 [使用 Pydantic
    实现更严格的类型检查](ch014.xhtml#x1-6000005) 配方，了解这种替代方法的示例。
- en: To transform the data into a more useful form, we’ll define a row-level cleansing
    function. A function can apply this cleansing function to each row of the source
    data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数据转换成更有用的形式，我们将定义一个行级清洗函数。一个函数可以将此清洗函数应用于源数据中的每一行。
- en: 'In this case, we’ll create a dictionary object and insert additional values
    that are derived from the input data. The core type hints for this Waypoint dictionary
    are these:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个字典对象，并插入从输入数据派生出的额外值。这个 Waypoint 字典的核心类型提示如下：
- en: '[PRE27]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Based on this definition of a Waypoint type, a clean_row() function can look
    like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此对 Waypoint 类型的定义，clean_row() 函数可能看起来像这样：
- en: '[PRE28]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The clean_row() function creates several new column values from the raw string
    data. The column named lat_lon has a two-tuple with proper floating-point values
    instead of strings. We’ve also parsed the date and time values to create datetime.date
    and datetime.time objects, respectively. We’ve combined the date and time into
    a single, useful value, which is the value of the timestamp column.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: clean_row() 函数从原始字符串数据中创建几个新的列值。名为 lat_lon 的列包含一个包含正确浮点值的二元组，而不是字符串。我们还解析了日期和时间值，分别创建了
    datetime.date 和 datetime.time 对象。我们将日期和时间合并成一个单一的有用值，即时间戳列的值。
- en: 'Once we have a row-level function for cleaning and enriching our data, we can
    map this function to each row in the source data. We can use map(clean_row, reader)
    or we can write a function that embodies this processing loop:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个用于清洗和丰富我们数据的行级函数，我们就可以将此函数映射到源数据中的每一行。我们可以使用 map(clean_row, reader) 或者我们可以编写一个体现此处理循环的函数：
- en: '[PRE29]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This can be used to provide more useful data from each row:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来从每一行提供更有用的数据：
- en: '[PRE30]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These cleansed and enriched rows look as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这些清洗和丰富的行看起来如下：
- en: '[PRE31]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The new columns such as lat_lon have proper numeric values instead of strings.
    The timestamp value has a full date-time value that can be used for simple computations
    of elapsed time between waypoints.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 新的列，如 lat_lon，包含正确的数值而不是字符串。时间戳值包含完整的日期时间值，可用于计算航点之间经过的时间的简单计算。
- en: 11.3.5 See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3.5 参见
- en: See the [Combining the map and reduce transformations](ch013_split_001.xhtml#x1-5440006)
    recipe in Chapter [9](ch013_split_000.xhtml#x1-5020009) for more information on
    the idea of a processing pipeline or stack.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见第 [9](ch013_split_000.xhtml#x1-5020009) 章中的 [结合 map 和 reduce 转换](ch013_split_001.xhtml#x1-5440006)
    配方，以获取有关处理流程或堆栈的想法的更多信息。
- en: See the [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) recipe
    in Chapter [4](ch008_split_000.xhtml#x1-2240004), and the [Using stacked generator
    expressions](ch013_split_000.xhtml#x1-5180003) recipe in Chapter [9](ch013_split_000.xhtml#x1-5020009),
    for more information on processing a CSV file that isn’t in a proper 1NF.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见第 [4](ch008_split_000.xhtml#x1-2240004) 章中的 [切片和切块列表](ch008_split_000.xhtml#x1-2400003)
    配方，以及第 [9](ch013_split_000.xhtml#x1-5020009) 章中的 [使用堆叠生成表达式](ch013_split_000.xhtml#x1-5180003)
    配方，以获取有关处理不正确 1NF 的 CSV 文件的更多信息。
- en: For more information on the with statement, see the [Creating contexts and context
    managers](ch011_split_001.xhtml#x1-43700011) recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 with 语句的更多信息，请参阅第 [7](ch011_split_000.xhtml#x1-3760007) 章中的 [创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011)
    配方。
- en: In Chapter [10](ch014.xhtml#x1-57300010), a number of recipes use Pydantic to
    perform these kinds of data conversions. See the [Implementing more strict type
    checks with Pydantic](ch014.xhtml#x1-6000005) recipe for an example of this alternative
    approach.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [10](ch014.xhtml#x1-57300010) 章中，许多配方使用 Pydantic 来执行这些类型的数据转换。参见 [使用 Pydantic
    实现更严格的类型检查](ch014.xhtml#x1-6000005) 配方，了解这种替代方法的示例。
- en: See [https://www.packtpub.com/product/learning-pandas-second-edition/9781787123137](https://www.packtpub.com/product/learning-pandas-second-edition/9781787123137)
    Learning pandas for an approach to CSV files using the pandas framework.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看 [https://www.packtpub.com/product/learning-pandas-second-edition/9781787123137](https://www.packtpub.com/product/learning-pandas-second-edition/9781787123137)
    学习 pandas，了解使用 pandas 框架处理 CSV 文件的方法。
- en: 11.4 Using dataclasses to simplify working with CSV files
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.4 使用 dataclasses 简化 CSV 文件的工作
- en: One commonly used data format is known as Comma-Separated Values (CSV). Python’s
    csv module has a very handy DictReader class definition. When a file contains
    a one-row header, the header row’s values become keys that are used for all the
    subsequent rows. This allows a great deal of flexibility in the logical layout
    of the data. For example, the column ordering doesn’t matter, since each column’s
    data is identified by a name taken from the header row.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的数据格式称为逗号分隔值 (CSV)。Python 的 csv 模块有一个非常方便的 DictReader 类定义。当一个文件包含一行标题时，标题行的值成为用于所有后续行的键。这为数据的逻辑布局提供了很大的灵活性。例如，列顺序并不重要，因为每个列的数据都由标题行中的一个名称标识。
- en: 'Using a dictionary forces us to write, for example, row[’lat’] or row[’date’]
    to refer to data in specific columns. The built-in dict class has no provision
    for derived data. If we switch to a dataclass, we have a number of benefits:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典迫使我们编写，例如，row[’lat’] 或 row[’date’] 来引用特定列中的数据。内置的 dict 类没有提供派生数据。如果我们切换到数据类，我们将获得许多好处：
- en: Nicer attribute syntax like row.lat or row.date.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好的属性语法，如 row.lat 或 row.date。
- en: Derived values can be lazy properties.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生值可以是延迟属性。
- en: A frozen dataclass is immutable, and the objects can be keys to dictionaries
    and members of sets.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冻结的数据类是不可变的，对象可以作为字典的键和集合的成员。
- en: How can we improve data access and processing using dataclasses?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用数据类改进数据访问和处理？
- en: 11.4.1 Getting ready
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.1 准备工作
- en: 'We’ll look at a CSV file that has some real-time data recorded from the log
    of a sailboat. This file is the waypoints.csv file. For more information, see
    the [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe in this chapter. The data looks as follows:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个包含从帆船日志中记录的实时数据的 CSV 文件。此文件是 waypoints.csv 文件。有关更多信息，请参阅本章中的 [使用 CSV
    模块读取定界文件](ch015_split_000.xhtml#x1-6320003) 烹饪配方。数据如下所示：
- en: '[PRE32]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first line contains a header that names the four columns, lat, lon, date,
    and time. The data can be read by a csv.DictReader object. We’d like to do more
    sophisticated work, so we’ll create a @dataclass class definition encapsulating
    the data and the processing we need to do.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包含一个标题，命名了四个列，lat、lon、date 和 time。数据可以通过 csv.DictReader 对象读取。我们希望进行更复杂的工作，因此我们将创建一个
    @dataclass 类定义，封装数据和我们需要执行的处理。
- en: 11.4.2 How to do it...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.2 如何操作...
- en: 'We need to start with a dataclass that reflects the available data, and then
    we can use this dataclass with a dictionary reader:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从一个反映可用数据的数据类开始，然后我们可以使用这个数据类与字典读取器一起使用：
- en: 'Import the definitions from the various libraries that are needed:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的各种库的定义：
- en: '[PRE33]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define a dataclass narrowly focused on the input, precisely as it appears in
    the source file. We’ve called the class RawRow. In a complex application, a more
    descriptive name than RawRow would be appropriate. This definition of the attributes
    may change as the source file organization changes:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个专注于输入的数据类，精确地像源文件中那样出现。我们称这个类为 RawRow。在一个复杂的应用程序中，一个比 RawRow 更有描述性的名称会更合适。这个属性定义可能会随着源文件组织的变化而变化：
- en: '[PRE34]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As a practical matter, enterprise file formats are likely to change whenever
    new software versions are introduced. It’s often helpful to formalize file schema
    as class definitions to facilitate unit testing and problem resolution when changes
    occur.
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，企业文件格式很可能在引入新软件版本时发生变化。在发生变化时，将文件模式正式化为类定义通常有助于单元测试和问题解决。
- en: 'Define a second dataclass where objects are built from the source dataclass
    attributes. This second class is focused on the real work of the application.
    The source data is in a single attribute, raw, in this example. Fields computed
    from this source data are all initialized with field(init=False) because they’ll
    be computed after initialization:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义第二个数据类，其中对象由源数据类的属性构建。这个第二类专注于应用程序的实际工作。在这个例子中，源数据在一个名为 raw 的单个属性中。从这个源数据计算的字段都使用
    field(init=False) 初始化，因为它们将在初始化之后计算：
- en: '[PRE35]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the __post_init__() method to eagerly initialize all the derived fields:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `__post_init__()` 方法添加到急切初始化所有派生字段：
- en: '[PRE36]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Given these two dataclass definitions, we can create an iterator that will
    accept individual dictionaries from a csv.DictReader object and create the needed
    Waypoint objects. The intermediate representation, RawRow, is a convenience so
    that we can assign attribute names to the source data columns:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定这两个数据类定义，我们可以创建一个迭代器，它将接受来自 `csv.DictReader` 对象的单独字典并创建所需的 `Waypoint` 对象。中间表示
    `RawRow` 是一个便利，这样我们就可以将属性名称分配给源数据列：
- en: '[PRE37]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The waypoint_iter() function creates RawRow objects from the input dictionary,
    and then creates the final Waypoint objects from the RawRow instances. This two-step
    process is helpful for isolating code changes to the source or the processing.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`waypoint_iter()` 函数从输入字典创建 `RawRow` 对象，然后从 `RawRow` 实例创建最终的 `Waypoint` 对象。这个两步过程有助于隔离对源或处理的代码变更。'
- en: 'We can use the following function to read and display the CSV data:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下函数来读取和显示 CSV 数据：
- en: '[PRE38]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 11.4.3 How it works...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.3 它是如何工作的...
- en: The source dataclass, the RawRow class in this example, is designed to match
    the input document. The field names and types match the CSV input types. Because
    the names match, the RawRow(**row) expression will create an instance of the RawRow
    class from the DictReader dictionary.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，源数据类 `RawRow` 类被设计成与输入文档相匹配。字段名称和类型与 CSV 输入类型相匹配。由于名称匹配，`RawRow(**row)`
    表达式将从 `DictReader` 字典创建 `RawRow` 类的实例。
- en: From this initial, or raw, data, we can derive the more useful data, as shown
    in the Waypoint class definition. The __post_init__() method transforms the initial
    value in the self.raw attribute into a number of more useful attribute values.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个初始的或原始的数据中，我们可以推导出更有用的数据，如 `Waypoint` 类定义所示。`__post_init__()` 方法将 `self.raw`
    属性中的初始值转换成多个更有用的属性值。
- en: 'This separation lets us manage the following two kinds of common changes to
    application software:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离使我们能够管理应用软件的以下两种常见变更：
- en: 'The source data can change because the spreadsheet was adjusted manually. This
    is common: a person may change column names or change the order of the columns.'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于电子表格是手动调整的，源数据可能会发生变化。这是常见的：一个人可能会更改列名或更改列的顺序。
- en: The required computations may change as the application’s focus expands or shifts.
    More derived columns may be added, or the algorithms may change.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着应用程序焦点的扩展或转移，所需的计算可能会发生变化。可能会添加更多派生列，或者算法可能会改变。
- en: It’s helpful to disentangle the various aspects of a program so that we can
    let them evolve independently. Gathering, cleaning, and filtering source data
    is one aspect of this separation of concerns. The resulting computations are a
    separate aspect, unrelated to the format of the source data.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序的各种方面解开，以便我们可以让它们独立演变，这是很有帮助的。收集、清理和过滤源数据是这种关注点分离的一个方面。由此产生的计算是一个独立的方面，与源数据的格式无关。
- en: 11.4.4 There’s more...
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.4 更多...
- en: In many cases, the source CSV file will have headers that do not map directly
    to valid Python attribute names. In these cases, the keys present in the source
    dictionary must be mapped to the column names. This can be managed by expanding
    the RawRow class definition to include a @classmethod that builds the RawRow dataclass
    object from the source dictionary.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，源 CSV 文件将具有不直接映射到有效 Python 属性名称的标题。在这些情况下，源字典中存在的键必须映射到列名。这可以通过扩展 `RawRow`
    类定义以包括一个构建 `RawRow` 数据类对象的 `@classmethod` 来管理。
- en: 'The following example defines a class called RawRow_HeaderV2\. This definition
    reflects a variant spreadsheet with different column names in the header:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例定义了一个名为 `RawRow_HeaderV2` 的类。这个定义反映了具有不同列名标题的变体电子表格：
- en: '[PRE39]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The instances of the RawRow_HeaderV2 class are built using the expression RawRow_HeaderV2.from_csv(row).
    The objects are compatible with the RawRow class. Either of these classes of objects
    can also be transformed into Waypoint instances.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`RawRow_HeaderV2` 类的实例是通过表达式 `RawRow_HeaderV2.from_csv(row)` 构建的。这些对象与 `RawRow`
    类兼容。这两个类中的任何一个对象也可以转换成 `Waypoint` 实例。'
- en: 'For an application that works with a variety of data sources, these kinds of
    ”raw data transformation” dataclasses can be handy for mapping the minor variations
    in a logical layout to a consistent internal structure for further processing.
    As the number of input transformation classes grows, additional type hints are
    required. For example, the following type hint provides a common name for the
    variations in input format:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于与各种数据源一起工作的应用程序，这类“原始数据转换”dataclasses可以方便地将逻辑布局中的细微变化映射到一致的内部结构，以便进一步处理。随着输入转换类的数量增加，需要额外的类型提示。例如，以下类型提示为输入格式的变化提供了一个通用名称：
- en: '[PRE40]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This type hint helps to unify the original RawRow and the alternative RawRow_HeaderV2
    types, which are alternative definitions with compatible features. The most important
    feature is the use of generators to process rows individually and avoid creating
    large list objects with all of the data.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型提示有助于统一原始的RawRow和替代的RawRow_HeaderV2类型，它们是具有兼容功能的替代定义。最重要的功能是使用生成器逐行处理数据，以避免创建包含所有数据的庞大列表对象。
- en: 11.4.5 See also
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4.5 参考信息
- en: The [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe, earlier in this chapter, also covers CSV file reading.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面的[使用CSV模块读取分隔符文件](ch015_split_000.xhtml#x1-6320003)配方也涵盖了CSV文件读取。
- en: In Chapter [6](ch010.xhtml#x1-3300006), the [Using dataclasses for mutable objects](ch011_split_000.xhtml#x1-4010005)
    recipe also covers ways to use Python’s dataclasses.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[6](ch010.xhtml#x1-3300006)章的[使用dataclasses处理可变对象](ch011_split_000.xhtml#x1-4010005)配方中，也介绍了使用Python的dataclasses的方法。
- en: 11.5 Reading complex formats using regular expressions
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.5 使用正则表达式读取复杂格式
- en: Many file formats lack the elegant regularity of a CSV file. One common file
    format that’s rather difficult to parse is a web server log file. These files
    tend to have complex data without a single, uniform separator character or consistent
    quoting rules.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文件格式缺乏CSV文件那种优雅的规律性。一个相当难以解析的常见文件格式是Web服务器日志文件。这些文件往往具有复杂的数据，没有单一的、统一的分隔符字符或一致的引号规则。
- en: 'When we looked at a simplified log file in the [Writing generator functions
    with the yield statement](ch013_split_000.xhtml#x1-5030001) recipe in Chapter [9](ch013_split_000.xhtml#x1-5020009),
    we saw that the rows look as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在第[9](ch013_split_000.xhtml#x1-5020009)章的[使用yield语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)配方中查看简化的日志文件时，我们看到行如下所示：
- en: '[PRE41]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are a variety of punctuation marks being used in this file. The csv module
    can’t parse this complexity.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中使用了各种标点符号。csv模块无法解析这种复杂性。
- en: We’d like to write programs with the elegant simplicity of CSV processing. This
    means we’ll need to encapsulate the complexities of log file parsing and keep
    this aspect separate from analysis and summary processing.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望编写出像CSV处理一样优雅简单的程序。这意味着我们需要封装日志文件解析的复杂性，并将这一方面与分析和汇总处理分开。
- en: 11.5.1 Getting ready
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5.1 准备工作
- en: Parsing a file with a complex structure generally involves writing a function
    that behaves somewhat like the reader() function in the csv module. In some cases,
    it can be easier to create a small class that behaves like the DictReader class.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 解析具有复杂结构的文件通常涉及编写一个函数，该函数的行为类似于csv模块中的reader()函数。在某些情况下，创建一个类似于DictReader类的简单类可能更容易。
- en: The core feature of reading a complex file is a function that will transform
    one line of text into a dictionary or tuple of individual field values. Parts
    of this job can often be done by the re package.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 读取复杂文件的核心功能是将一行文本转换成字典或单个字段值的元组。这项工作的部分通常可以通过re包来完成。
- en: Before we can start, we’ll need to develop (and debug) the regular expression
    that properly parses each line of the input file. For more information on this,
    see the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要开发（并调试）一个正则表达式，以便正确解析输入文件的每一行。有关此信息，请参阅第[1](ch005_split_000.xhtml#x1-170001)章中的[使用正则表达式进行字符串解析](ch005_split_000.xhtml#x1-350003)配方。
- en: 'For this example, we’ll use the following code. We’ll define a pattern string
    with a series of regular expressions for the various elements of the line:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用以下代码。我们将定义一个模式字符串，其中包含一系列用于行中各种元素的正则表达式：
- en: '[PRE42]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’ve used the re.X option so that we can include extra whitespace in the regular
    expression. This can help to make it more readable by separating prefix and suffix
    characters.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 re.X 选项，这样我们可以在正则表达式中包含额外的空白。这可以通过分隔前缀和后缀字符来帮助使其更易于阅读。
- en: When we write a regular expression, we wrap the interesting sub-strings to capture
    in (). After performing a match() or search() operation, the resulting Match object
    will have the captured text for the matched substrings. The groups() method of
    a Match object and the groupdict() method of a Match object will provide the captured
    strings.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写正则表达式时，我们将要捕获的有兴趣的子字符串用 () 括起来。在执行 match() 或 search() 操作后，生成的 Match 对象将包含匹配的子字符串的捕获文本。Match
    对象的 groups() 方法和 Match 对象的 groupdict() 方法将提供捕获的字符串。
- en: 'Here’s how this pattern works:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此模式的工作方式：
- en: '[PRE43]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’ve provided a line of sample data in the sample_data variable. The resulting
    Match object has a groups() method that returns each of the interesting fields.
    The value of the groupdict() method of a match object is a dictionary, with the
    name provided in the ?P<name> preface to the regular expression in brackets, ().
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 sample_data 变量中提供了一行样本数据。生成的 Match 对象有一个 groups() 方法，它返回每个有趣的字段。match 对象的
    groupdict() 方法的值是一个字典，其中包含在正则表达式中括号内的 ?P<name> 前缀提供的名称。
- en: 11.5.2 How to do it...
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5.2 如何做到...
- en: This recipe is split into two mini-recipes. The first part defines a log_parser()
    function to parse a single line, while the second part applies the log_parser()
    function for each line of input.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方分为两个小配方。第一部分定义了一个 log_parser() 函数来解析单行，而第二部分则将 log_parser() 函数应用于输入的每一行。
- en: Defining the parse function
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义解析函数
- en: 'Perform the following steps to define the log_parser() function:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以定义 log_parser() 函数：
- en: 'Define the compiled regular expression object:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义编译后的正则表达式对象：
- en: '[PRE44]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Define a class to model the resulting complex data object. This can have additional
    derived properties or other complex computations. Minimally, a NamedTuple must
    define the fields that are extracted by the parser. The field names should match
    the regular expression capture name in the (?P<name>...) prefix:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个类来模拟生成的复杂数据对象。这可以具有额外的派生属性或其他复杂计算。最小化地，NamedTuple 必须定义解析器提取的字段。字段名称应与正则表达式捕获名称在
    (?P<name>...) 前缀中匹配：
- en: '[PRE45]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Define a function that accepts a line of text as an argument and produces a
    parsed LogLine instance:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个接受一行文本作为参数并生成解析后的 LogLine 实例的函数：
- en: '[PRE46]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Apply the regular expression to create a match object. We’ve assigned it to
    the match variable and also checked to see it is not None:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将正则表达式应用于创建一个匹配对象。我们将其分配给 match 变量，并检查它是否不为 None：
- en: '[PRE47]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the value of match is not None, return a useful data structure with the
    various pieces of data from this input line:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 match 的值为非 None 时，返回一个包含此输入行各种数据的有用数据结构：
- en: '[PRE48]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When the match is None, either log the problem or raise an exception to stop
    processing:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当匹配为 None 时，记录问题或引发异常以停止处理：
- en: '[PRE49]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using the log_parser() function
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 log_parser() 函数
- en: 'This portion of the recipe will apply the log_parser() function to each line
    of the input file:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分的配方将应用 log_parser() 函数到输入文件的每一行：
- en: 'From the pathlib module, import useful class and function definitions:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 pathlib 模块中导入有用的类和函数定义：
- en: '[PRE50]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create the Path object that identifies the file:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建标识文件的 Path 对象：
- en: '[PRE51]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use the Path object to open the file in a with statement. Create the log file
    reader from the open file object, data_file. In this case, we’ll use the built-in
    map() function to apply the log_parser() function to each line from the source
    file:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Path 对象以 with 语句打开文件。从打开的文件对象 data_file 创建日志文件读取器。在这种情况下，我们将使用内置的 map() 函数将
    log_parser() 函数应用于源文件的每一行：
- en: '[PRE52]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Read (and process) the various rows of data. For this example, we’ll print
    each row:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取（并处理）各种数据行。对于此示例，我们将打印每一行：
- en: '[PRE53]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is a series of LogLine tuples that looks as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一系列看起来如下所示的 LogLine 元组：
- en: '[PRE54]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can do more meaningful processing on these tuple instances than we can on
    a line of raw text. These allow us to filter the data by severity level, or create
    a counter based on the module providing the message.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对这些元组实例进行比原始文本行更有意义的处理。这允许我们通过严重程度级别过滤数据，或根据提供消息的模块创建计数器。
- en: 11.5.3 How it works...
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5.3 它是如何工作的...
- en: 'This log file is in First Normal Form (1NF): the data is organized into lines
    that represent independent entities or events. Each row has a consistent number
    of attributes or columns, and each column has data that is atomic or can’t be
    meaningfully decomposed further. Unlike CSV files, however, this particular format
    requires a complex regular expression to parse.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 此日志文件处于第一范式（1NF）：数据组织成代表独立实体或事件的行。每一行都有一致的属性或列数，每一列都有原子数据或无法进一步有意义的分解。然而，与CSV文件不同的是，这种特定格式需要复杂的正则表达式来解析。
- en: In our log file example, the timestamp contains a number of individual elements
    – year, month, day, hour, minute, second, and millisecond – but there’s little
    value in further decomposing the timestamp. It’s more helpful to use it as a single
    datetime object and derive details (like the hour of the day) from this object,
    rather than assembling individual fields into a new piece of composite data.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日志文件示例中，时间戳包含多个单独的元素——年、月、日、小时、分钟、秒和毫秒——但进一步分解时间戳的价值不大。将其用作单个日期时间对象并从中提取详细信息（如一天中的小时）比将单个字段组装成新的复合数据更有帮助。
- en: In a complex log processing application, there may be several varieties of message
    fields. It may be necessary to parse these message types using separate patterns.
    When we need to do this, it reveals that the various lines in the log aren’t consistent
    in terms of the format and number of attributes, breaking one of the 1NF assumptions.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的日志处理应用程序中，可能有几种不同类型的消息字段。可能需要使用不同的模式来解析这些消息类型。当我们需要这样做时，我们发现日志中的各种行在格式和属性数量方面并不一致，这违反了1NF假设之一。
- en: 'We’ve generally followed the design pattern from the [Reading delimited files
    with the CSV module](ch015_split_000.xhtml#x1-6320003) recipe, so that reading
    a complex log is nearly identical to reading a simple CSV file. Indeed, we can
    see that the primary difference lies in one line of code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常遵循[使用CSV模块读取定界文件](ch015_split_000.xhtml#x1-6320003)配方中的设计模式，这样读取复杂的日志文件几乎与读取简单的CSV文件相同。实际上，我们可以看到主要区别在于一行代码：
- en: '[firstline=93,lastline=93,gobble=8][python]src/ch11/recipe˙05.py'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[firstline=93,lastline=93,gobble=8][python]src/ch11/recipe˙05.py'
- en: 'Compare that to the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下内容比较：
- en: '[firstline=95,lastline=95,gobble=8][python]src/ch11/recipe˙05.py'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[firstline=95,lastline=95,gobble=8][python]src/ch11/recipe˙05.py'
- en: This parallel construct allows us to reuse analysis functions across many input
    file formats. This allows us to create a library of tools that can be used on
    a number of data sources. It can help to make analytic applications resilient
    when data sources change.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这种并行结构允许我们在许多输入文件格式之间重用分析函数。这使我们能够创建一个库，该库可以用于多个数据源。它可以帮助使分析应用程序在数据源更改时具有弹性。
- en: 11.5.4 There’s more...
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5.4 更多...
- en: One of the most common operations when reading very complex files is to rewrite
    them into an easier-to-process format. We’ll often want to save data in the CSV
    format for later processing.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取非常复杂的文件时，最常见的操作之一是将它们重写为更容易处理的格式。我们通常会想将数据保存为CSV格式以供以后处理。
- en: Some of this is similar to the [Managing multiple contexts with multiple resources](ch011_split_001.xhtml#x1-44300012)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007). This recipe shows multiple
    open file-processing contexts. We’ll read from one file and write to another file.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些与第[7](ch011_split_000.xhtml#x1-3760007)章中的[使用多个资源管理多个上下文](ch011_split_001.xhtml#x1-44300012)配方类似。这个配方展示了多个打开的文件处理上下文。我们将从一个文件中读取并写入到另一个文件中。
- en: 'The file writing process looks as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 文件写入过程如下：
- en: '[PRE55]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first portion of this script defines a CSV writer for the target file. The
    path for the output file, target_path, is based on the input name, data_path.
    The suffix is changed to .csv.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本的第一个部分定义了一个用于目标文件的CSV写入器。输出文件的路径target_path基于输入名称data_path。后缀被更改为.csv。
- en: The target file is opened with the newline character turned off by the newline=’’
    option. This allows the csv.DictWriter class to insert newline characters appropriate
    for the desired CSV dialect.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用newline=’’选项关闭了换行符，以打开目标文件。这允许csv.DictWriter类插入适合所需CSV方言的换行符。
- en: A DictWriter object is created to write to the given file. The sequence of column
    headings is provided by the LogLines class definition. This makes sure the output
    CSV file will contain correct, consistent column names.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个DictWriter对象以写入指定的文件。列标题的序列由LogLines类定义提供。这确保输出CSV文件将包含正确、一致的列名。
- en: The writeheader() method writes the column names as the first line of output.
    This makes reading the file slightly easier because the column names are provided.
    The first row of a CSV file can contain an explicit schema definition that shows
    what data is present.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: writeheader() 方法将列名写入输出文件的第一行。这使得读取文件稍微容易一些，因为提供了列名。CSV 文件的第一行可以包含显式的模式定义，显示存在哪些数据。
- en: The source file is opened, as shown in the preceding recipe. Because of the
    way the csv module writers work, we can provide the reader generator expression
    to the writerows() method of the writer. The writerows() method will consume all
    of the data produced by the reader generator. This will, in turn, consume all
    the rows produced by the open file.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 源文件已按前一个菜谱所示打开。由于 csv 模块编写器的工作方式，我们可以将读取生成器表达式提供给 writer 的 writerows() 方法。writerows()
    方法将消耗读取生成器产生的所有数据。这将反过来消耗由打开的文件产生的所有行。
- en: We don’t need to write any explicit for statements to ensure that all of the
    input rows are processed. The writerows() function makes this guarantee for us.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要编写任何显式的 for 语句来确保处理所有输入行。writerows() 函数为我们保证了这一点。
- en: 'The output file looks as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件如下所示：
- en: '[PRE56]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The file has been transformed from the rather complex input format into a simpler
    CSV format, suitable for further analysis and processing.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件已从相对复杂的输入格式转换为更简单的 CSV 格式，适合进一步分析和处理。
- en: 11.5.5 See also
  id: totrans-462
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.5.5 参考内容
- en: For more information on the with statement, see the [Creating contexts and context
    managers](ch011_split_001.xhtml#x1-43700011) recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007).
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 with 语句的更多信息，请参阅第 [7](ch011_split_000.xhtml#x1-3760007) 章的 [创建上下文和上下文管理器](ch011_split_001.xhtml#x1-43700011)
    菜单。
- en: The [Writing generator functions with the yield statement](ch013_split_000.xhtml#x1-5030001)
    recipe in Chapter [9](ch013_split_000.xhtml#x1-5020009) shows other processing
    of this log format.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 [9](ch013_split_000.xhtml#x1-5020009) 章的 [使用 yield 语句编写生成器函数](ch013_split_000.xhtml#x1-5030001)
    菜谱展示了这种日志格式的其他处理方式。
- en: In the [Reading delimited files with the CSV module](ch015_split_000.xhtml#x1-6320003)
    recipe, earlier in this chapter, we looked at other applications of this general
    design pattern.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的 [使用 CSV 模块读取分隔文件](ch015_split_000.xhtml#x1-6320003) 菜谱中，我们探讨了这种通用设计模式的其它应用。
- en: In the [Using dataclasses to simplify working with CSV files](ch015_split_000.xhtml#x1-6380004)
    recipe, earlier in this chapter, we looked at other sophisticated CSV processing
    techniques.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的 [使用数据类简化 CSV 文件处理](ch015_split_000.xhtml#x1-6380004) 菜谱中，我们探讨了其他复杂的 CSV
    处理技术。
- en: 11.6 Reading JSON and YAML documents
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.6 读取 JSON 和 YAML 文档
- en: JavaScript Object Notation (JSON) is often used for serializing data. For details,
    see [http://json.org](http://json.org). Python includes the json module in order
    to serialize and deserialize data in this notation.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 对象表示法 (JSON) 通常用于序列化数据。有关详细信息，请参阅 [http://json.org](http://json.org)。Python
    包含 json 模块，以便使用这种表示法序列化和反序列化数据。
- en: JSON documents are used widely by web applications. It’s common to exchange
    data between RESTful web clients and servers using documents in JSON notation.
    These two tiers of an application stack communicate via JSON documents sent via
    the HTTP protocol.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文档被广泛应用于网络应用程序。在 RESTful 网络客户端和服务器之间使用 JSON 表示法的文档交换数据是很常见的。这两个应用堆栈的层级通过通过
    HTTP 协议发送的 JSON 文档进行通信。
- en: 'The YAML format is a more sophisticated and flexible extension to JSON notation.
    For details, see [https://yaml.org](https://yaml.org). Any JSON document is also
    a valid YAML document. The reverse is not true: YAML syntax is more complex and
    includes constructs that are not valid JSON.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 格式是 JSON 表示法的更复杂和灵活的扩展。有关详细信息，请参阅 [https://yaml.org](https://yaml.org)。任何
    JSON 文档都是有效的 YAML 文档。反之则不然：YAML 语法更复杂，包括一些在 JSON 中无效的构造。
- en: 'To use YAML, an additional module has to be installed:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 YAML，必须安装一个额外的模块：
- en: '[PRE57]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The PyYAML project offers a yaml module that is popular and works well. See
    [https://pypi.org/project/PyYAML/](https://pypi.org/project/PyYAML/).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: PyYAML 项目提供了一个流行且功能良好的 yaml 模块。请参阅 [https://pypi.org/project/PyYAML/](https://pypi.org/project/PyYAML/).
- en: In this recipe, we’ll use the json module to parse JSON format data in Python.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将使用 json 模块来解析 Python 中的 JSON 格式数据。
- en: 11.6.1 Getting ready
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6.1 准备工作
- en: We’ve gathered some sailboat racing results in race_result.json. This file contains
    information on the teams, the legs of the race, and the order in which the various
    teams finished each individual leg of the race. JSON handles this complex data
    elegantly.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在race_result.json文件中收集了一些帆船比赛结果。这个文件包含了关于队伍、比赛段以及各个队伍完成每个单独比赛段顺序的信息。JSON优雅地处理了这些复杂的数据。
- en: 'An overall score can be computed by summing the finish position in each leg:
    the lowest score is the overall winner. In some cases, there are null values when
    a boat did not start, did not finish, or was disqualified from the race.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 总分可以通过计算每个比赛段的完成位置来得出：得分最低的是总冠军。在某些情况下，当一艘船未参赛、未完成比赛或被取消比赛资格时，会有null值。
- en: When computing the team’s overall score, the null values are assigned a score
    of one more than the number of boats in the competition. If there are seven boats,
    then the team is given eight points for their failure to finish, a hefty penalty.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算队伍的总分时，null值被分配一个比比赛船只数量多一个的分数。如果有七艘船，那么队伍因未能完成比赛而得到八分，这是一个相当大的惩罚。
- en: 'The data has the following schema. There are two fields within the overall
    document:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 数据具有以下架构。在整个文档中有两个字段：
- en: 'legs: An array of strings that shows the starting port and ending port.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: legs：一个字符串数组，显示起点和终点。
- en: 'teams: An array of objects with details about each team. Within each teams
    object, there are several fields of data:'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: teams：一个包含每个队伍详细信息的对象数组。在每个teams对象中，有几个数据字段：
- en: 'name: String team name.'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: name：字符串形式的队伍名称。
- en: 'position: An array of integers and nulls with a position. The order of the
    items in this array matches the order of the items in the legs array.'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: position：一个包含整数和nulls的数组，表示位置。这个数组中项目的顺序与legs数组中项目的顺序相匹配。
- en: 'The data looks as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 数据看起来如下：
- en: '[PRE58]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We’ve only shown the first team’s details. There were a total of seven teams
    in this particular race. Each team is represented by a Python dictionary, with
    the team’s name and their history of finish positions on each leg. For the team
    shown here, Abu Dhabi Ocean Racing, they finished in first place in the first
    leg, and then third place in the next leg. Their worst performance was fifth place
    in both the seventh and ninth legs of the race, which were the legs from Newport,
    Rhode Island, USA, to Lisbon, Portugal, and from Lorient, France, to Gothenburg,
    Sweden.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只展示了第一支队伍的详细信息。在这场特定的比赛中，总共有七支队伍。每个队伍由一个Python字典表示，其中包含队伍的名称和他们在每个比赛段的完成位置历史。对于这里展示的队伍，阿布扎比海洋赛车队，他们在第一段比赛中获得第一名，然后在下一段比赛中获得第三名。他们的最差表现是在第七段和第九段比赛中获得第五名，这两段比赛是从美国罗德岛纽波特到葡萄牙里斯本，以及从法国洛里昂到瑞典哥德堡。
- en: 'The JSON-formatted data can look like a Python dictionary that contains lists
    within it. This overlap between Python syntax and JSON syntax can be thought of
    as a happy coincidence: it makes it easier to visualize the Python data structure
    that will be built from the JSON source document.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: JSON格式的数据看起来像包含列表的Python字典。这种Python语法和JSON语法的重叠可以被视为一种愉快的巧合：它使得从JSON源文档构建的Python数据结构更容易可视化。
- en: 'JSON has a small set of data structures: null, Boolean, number, string, list,
    and object. These map to objects of Python types in a very direct way. The json
    module makes the conversions from source text into Python objects for us.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: JSON有一组小的数据结构：null、布尔值、数字、字符串、列表和对象。这些直接映射到Python类型中的对象。json模块为我们将这些源文本转换为Python对象。
- en: One of the strings contains a Unicode escape sequence, \u00cd, instead of the
    actual Unicode character Í. This is a common technique used to encode characters
    beyond the 128 ASCII characters. The parser in the json module handles this for
    us.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个字符串包含一个Unicode转义序列，\u00cd，而不是实际的Unicode字符Í。这是一种常见的用于编码超出128个ASCII字符的字符的技术。json模块中的解析器为我们处理了这一点。
- en: In this example, we’ll write a function to disentangle this document and show
    the team finishes for each leg.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将编写一个函数来解开这个文档，并显示每个比赛段的队伍完成情况。
- en: 11.6.2 How to do it...
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6.2 如何实现...
- en: 'This recipe will start by importing the necessary modules. We’ll then use these
    modules to transform the contents of the file into a useful Python object:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将首先导入必要的模块。然后我们将使用这些模块将文件内容转换为有用的Python对象：
- en: 'We’ll need the json module to parse the text. We’ll also need a Path object
    to refer to the file:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要json模块来解析文本。我们还需要一个Path对象来引用文件：
- en: '[PRE59]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Define a race\_summary() function to read the JSON document from a given Path
    instance:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 race_summary() 函数来从给定的 Path 实例读取 JSON 文档：
- en: '[PRE60]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a Python object by parsing the JSON document. It’s often easiest to
    use source_path.read_text() to read the file named by the Path object. We provided
    this string to the json.loads() function for parsing. For very large files, an
    open file can be passed to the json.load() function:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过解析 JSON 文档创建一个 Python 对象。通常，使用 source_path.read_text() 读取由 Path 对象命名的文件是最简单的。我们将此字符串提供给
    json.loads() 函数进行解析。对于非常大的文件，可以将打开的文件传递给 json.load() 函数：
- en: '[PRE61]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Display the data: The document object contains a dictionary with two keys,
    teams and legs. Here’s how we can iterate through each leg, showing the team’s
    position in the leg:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示数据：文档对象包含一个包含两个键的字典，teams 和 legs。以下是遍历每个 legs 的方法，显示队伍在 legs 中的位置：
- en: '[PRE62]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The data for each team will be a dictionary with two keys: name and position.
    We can navigate down into the team details to get the name of the first team:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 每个队伍的数据将是一个包含两个键的字典：name 和 position。我们可以深入到队伍的详细信息中，以获取第一个队伍的名称：
- en: '[PRE63]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can look inside the legs field to see the names of each leg of the race:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看 legs 字段，以查看每个赛段的名称：
- en: '[PRE64]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 11.6.3 How it works...
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6.3 它是如何工作的...
- en: A JSON document is a data structure in JavaScript Object Notation. JavaScript
    programs can parse the document trivially. Other languages must do a little more
    work to translate the JSON to a native data structure.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文档是 JavaScript 对象表示法中的数据结构。JavaScript 程序可以轻松解析文档。其他语言必须做更多工作来将 JSON 转换为本地数据结构。
- en: 'A JSON document contains three kinds of structures:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文档包含三种结构：
- en: 'Objects that map to Python dictionaries: JSON has a syntax similar to Python:
    {"key": "value", ...}.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '映射到 Python 字典的对象：JSON 的语法与 Python 类似：{"key": "value", ...}。'
- en: 'Arrays that map to Python lists: JSON syntax uses [item, ...], which is also
    similar to Python.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到 Python 列表的数组：JSON 语法使用 [item, ...]，这也与 Python 类似。
- en: 'Primitive values: There are five classes of values: string, number, true, false,
    and null. Strings are enclosed in " and use a variety of \ escape sequences, which
    are similar to Python’s. Numbers follow the rules for floating-point values. The
    other three values are simple literals; these parallel Python’s True, False, and
    None literals.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始值：有五种值类别：字符串、数字、true、false 和 null。字符串用 " 和 " 包围，并使用各种 \ 转义序列，这与 Python 的类似。数字遵循浮点值规则。其他三个值是简单的字面量；这些与
    Python 的 True、False 和 None 字面量平行。
- en: As a special case, numbers with no decimal point become Python int objects.
    This is an extension of the JSON standard.
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为特殊情况，没有小数点的数字成为 Python int 对象。这是 JSON 标准的扩展。
- en: There is no provision for any other kinds of data. This means that Python programs
    must convert complex Python objects into a simpler representation so that they
    can be serialized in JSON notation.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 没有提供其他数据类型的支持。这意味着 Python 程序必须将复杂的 Python 对象转换为更简单的表示，以便它们可以用 JSON 语法进行序列化。
- en: Conversely, we often apply additional conversions to reconstruct complex Python
    objects from the simplified JSON representation. The json module has places where
    we can apply additional processing to the simple structures to create more sophisticated
    Python objects.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们经常应用额外的转换来从简化的 JSON 表示中重建复杂的 Python 对象。json 模块有一些地方可以应用额外的处理来创建更复杂的 Python
    对象。
- en: 11.6.4 There’s more...
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6.4 更多...
- en: A file, generally, contains a single JSON document. The JSON standard doesn’t
    provide an easy way to encode multiple documents in a single file. If we want
    to analyze a web log, for example, the original JSON standard may not be the best
    notation for preserving a huge volume of information.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个文件包含一个单一的 JSON 文档。JSON 标准没有提供一种简单的方法来将多个文档编码到单个文件中。如果我们想分析一个网络日志，例如，原始的
    JSON 标准可能不是保存大量信息的最佳表示法。
- en: There are common extensions, like Newline Delimited JSON ( [http://ndjson.org](http://ndjson.org))
    and JSON Lines, [http://jsonlines.org](http://jsonlines.org), to define a way
    to encode multiple JSON documents into a single file.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些常见扩展，如换行符分隔的 JSON（[http://ndjson.org](http://ndjson.org)）和 JSON Lines，[http://jsonlines.org](http://jsonlines.org)，用于定义将多个
    JSON 文档编码到单个文件中的方式。
- en: 'While these approaches handle collections of documents, there is an additional
    problem that we often have to tackle: serializaing (and deserializing) complex
    objects, for example, datetime objects.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些方法处理文档集合时，还有一个额外的问题我们需要解决：序列化（和反序列化）复杂对象，例如 datetime 对象。
- en: When we represent a Python object’s state as a string of text characters, we’ve
    serialized the object’s state. Many Python objects need to be saved in a file
    or transmitted to another process. These kinds of transfers require a representation
    of the object state. We’ll look at serializing and deserializing separately.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 Python 对象的状态表示为文本字符的字符串时，我们已经序列化了对象的状态。许多 Python 对象需要被保存到文件或传输到另一个进程。这类传输需要对象状态的表示。我们将分别查看序列化和反序列化。
- en: Serializing a complex data structure
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化复杂的数据结构
- en: The serialization to JSON works out the best if we create Python objects limited
    to values of the built-in types dict, list, str, int, float, bool, and the special
    type for None. This subset of Python types can be used to build objects the json
    module can serialize and can be used widely by a number of programs, written in
    different languages.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建的 Python 对象仅限于内置类型 dict、list、str、int、float、bool 和 None 的值，那么序列化到 JSON
    的效果最好。这个 Python 类型子集可以用来构建 json 模块可以序列化的对象，并且可以由多种不同语言编写的许多程序广泛使用。
- en: One commonly used data structure that doesn’t serialize easily is the datetime.datetime
    object.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常用的、不易序列化的数据结构是 datetime.datetime 对象。
- en: Avoiding the TypeError exception exceptions when trying to serialize an unusual
    Python object can be done in one of two ways. We can either convert the data into
    a JSON-friendly structure before building the document, or we can add a default
    type handler to the JSON serialization process that gives us a way to provide
    a serializable version of the data.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在尝试序列化不寻常的 Python 对象时引发 TypeError 异常，可以通过两种方式之一实现。我们可以在构建文档之前将数据转换为 JSON 友好的结构，或者我们可以在
    JSON 序列化过程中添加一个默认类型处理器，这样我们就可以提供一个可序列化的数据版本。
- en: To convert a datetime object into a string prior to serializing it as JSON,
    we need to make a change to the underlying data. It seems awkward to mangle the
    data or Python’s data types because of a serialization concern.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 datetime 对象序列化为 JSON 之前转换为字符串，我们需要对底层数据进行更改。由于序列化问题而篡改数据或 Python 的数据类型似乎有些尴尬。
- en: 'The other technique for serializing complex data is to provide a function that’s
    used by the json module during serialization. This function must convert a complex
    object into something that can be safely serialized. In the following example,
    we’ll convert a datetime object into a simple string value:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化复杂数据的另一种技术是提供一个在序列化过程中由 json 模块使用的函数。此函数必须将复杂对象转换为可以安全序列化的东西。在下面的示例中，我们将
    datetime 对象转换为简单的字符串值：
- en: '[PRE65]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We’ve defined a function, default_date(), which will apply a special conversion
    rule to datetime objects. Any datetime.datetime instance will be replaced with
    a dictionary with an obvious key – "$date$" – and a string value. This dictionary
    can then be serialized by the json module.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个函数，default_date()，它将对 datetime 对象应用特殊的转换规则。任何 datetime.datetime 实例都将被替换为一个具有明显键
    – "$date$" – 和字符串值的字典。这个字典可以通过 json 模块进行序列化。
- en: 'We provide this serialization helper function to the json.dumps() function.
    This is done by assigning the default_date() function to the default parameter,
    as follows:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个序列化辅助函数提供给 json.dumps() 函数。这是通过将 default_date() 函数分配给默认参数来完成的，如下所示：
- en: '[PRE66]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: When the json module can’t serialize an object, it passes the object to the
    given default function, default_date(). In any given application, we’ll need to
    expand this function to handle a number of Python object types that we might want
    to serialize in JSON notation. If there is no default function provided, an exception
    is raised when an object can’t be serialized.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当 json 模块无法序列化一个对象时，它将对象传递给给定的默认函数 default_date()。在任何给定的应用程序中，我们需要扩展这个函数以处理我们可能想要在
    JSON 表示法中序列化的多种 Python 对象类型。如果没有提供默认函数，当对象无法序列化时将引发异常。
- en: Deserializing a complex data structure
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反序列化复杂的数据结构
- en: When deserializing JSON to create Python objects, there’s a hook that can be
    used to convert data from a JSON dictionary into a more complex Python object.
    This is called object_hook and it is used during processing by the json.loads()
    function. This hook is used to examine each JSON dictionary to see if something
    else should be created from the dictionary instance.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当反序列化 JSON 以创建 Python 对象时，有一个钩子可以用来将数据从 JSON 字典转换为更复杂的 Python 对象。这被称为 object_hook，它在
    json.loads() 函数的处理过程中被使用。此钩子用于检查每个 JSON 字典，以查看是否应该从字典实例创建其他内容。
- en: 'The function we provide will either create a more complex Python object, or
    it will simply return the original dictionary object unmodified:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的函数将创建一个更复杂的Python对象，或者简单地返回未修改的原始字典对象：
- en: '[PRE67]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This function will check each object that’s decoded to see if the object has
    a single field, and if that single field is named "$date$". If that is the case,
    the value of the entire object is replaced with a datetime.datetime object. The
    return type is a union of Any and dict[str, Any] to reflect the two possible results:
    either some object or the original dictionary.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将检查每个解码的对象，以查看对象是否只有一个字段，并且该单个字段是否命名为"$date$"。如果是这种情况，整个对象的价值将替换为datetime.datetime对象。返回类型是Any和dict[str,
    Any]的联合，以反映两种可能的结果：要么是某个对象，要么是原始字典。
- en: 'We provide a function to the json.loads() function using the object_hook parameter,
    as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过json.loads()函数使用object_hook参数提供了一个函数，如下所示：
- en: '[PRE68]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This parses a very small JSON document. All objects are provided to the as_date()
    object hook. Of these objects, one dictionary meets the criteria for containing
    a date. A Python object is built from the string value found in the JSON serialization.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这解析了一个非常小的JSON文档。所有对象都提供给as_date()对象钩子。在这些对象中，有一个字典符合包含日期的标准。从JSON序列化中找到的字符串值构建了一个Python对象。
- en: The Pydantic package offers a number of serialization features. Recipes are
    shown in Chapter [10](ch014.xhtml#x1-57300010) for working with this package.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic包提供了一系列序列化功能。关于如何使用此包的配方在第[10](ch014.xhtml#x1-57300010)章中有展示。
- en: 11.6.5 See also
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6.5 参见
- en: The [Reading HTML documents](ch015_split_001.xhtml#x1-6660008) recipe, later
    in this chapter, will show how we prepared this data from an HTML source.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章后面的[读取HTML文档](ch015_split_001.xhtml#x1-6660008)配方将展示我们如何从HTML源准备这些数据。
- en: The [Implementing more strict type checks with Pydantic](ch014.xhtml#x1-6000005)
    recipe in Chapter [10](ch014.xhtml#x1-57300010) covers some features of the Pydantic
    package.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第[10](ch014.xhtml#x1-57300010)章中的[使用Pydantic实现更严格的类型检查](ch014.xhtml#x1-6000005)配方涵盖了Pydantic包的一些功能。
- en: 11.7 Reading XML documents
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.7 读取XML文档
- en: The XML markup language is widely used to represent the state of objects in
    a serialized form. For details, see [http://www.w3.org/TR/REC-xml/](http://www.w3.org/TR/REC-xml/).
    Python includes a number of libraries for parsing XML documents.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: XML标记语言广泛用于以序列化形式表示对象的状态。有关详细信息，请参阅[http://www.w3.org/TR/REC-xml/](http://www.w3.org/TR/REC-xml/)。Python包含多个用于解析XML文档的库。
- en: XML is called a markup language because the content of interest is marked with
    tags, written with a start <tag> and an end </tag>, used to define the structure
    of the data. The overall file text includes both the content and the XML markup.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: XML被称为标记语言，因为感兴趣的内容被标记为标签，使用起始<tag>和结束</tag>来书写，用于定义数据结构。整个文件文本包括内容和XML标记。
- en: Because the markup is intermingled with the text, there are some additional
    syntax rules that must be used to distinguish markup from text. A document must
    use &lt; instead of <, &gt; instead of >, and &amp; instead of & in text. Additionally,
    &quot; is also used to embed a " character in an attribute value. For the most
    part, XML parsers will handle this transformation when consuming XML.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标记与文本交织在一起，因此必须使用一些额外的语法规则来区分标记和文本。文档必须使用&lt;代替<，&gt;代替>，以及&amp;代替&在文本中。此外，&quot;也用于在属性值中嵌入一个"字符。在大多数情况下，XML解析器在消费XML时会处理这种转换。
- en: 'The example document, then, will have items as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，示例文档将包含以下项目：
- en: '[PRE69]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The <team> tag contains the <name> tag, which contains the text of the team’s
    name. The <position> tag contains more data about the team’s finish position in
    each leg of a race.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: <team>标签包含<name>标签，其中包含团队的名称文本。《position>标签包含关于团队在每个赛段完成位置的数据。
- en: The overall document forms a large, nested collection of containers. We can
    think of a document as a tree with a root tag that contains all the other tags
    and their embedded content. Between tags, there can be additional content. In
    some applications, the additional content between the ends of tags is entirely
    whitespace.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 整个文档形成一个大型、嵌套的容器集合。我们可以将文档视为一个树，其根标签包含所有其他标签及其嵌入的内容。在标签之间，可以有额外的内容。在某些应用中，标签结束之间的额外内容完全是空白。
- en: 'Here’s the beginning of the document we’ll be looking at:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将要查看的文档的开始部分：
- en: '[PRE70]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The top-level container is the <results> tag. Within this is a <teams> tag.
    Within the <teams> tag are many repetitions of data for each individual team,
    each enclosed in the <team> tag. We’ve used ... to show where parts of the document
    were elided.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 最高层容器是<results>标签。在这个容器内有一个<teams>标签。在<teams>标签内，每个团队的数据都以<team>标签的形式重复出现。我们使用...来表示文档中省略的部分。
- en: It’s very, very difficult to parse XML with regular expressions. Regular expressions
    don’t cope well with the kinds of recursion and repetition present in XML. We
    need more sophisticated parsers to handle the syntax of nested tags.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式解析XML非常困难。正则表达式不擅长处理XML中存在的递归和重复类型。我们需要更复杂的解析器来处理嵌套标签的语法。
- en: There are two binary libraries, part of the modules xml.sax and xml.parsers.expat,
    to parse XML. These have the advantage of being very fast.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个二进制库，分别是xml.sax和xml.parsers.expat模块的一部分，用于解析XML。这些库的优点是速度非常快。
- en: In addition to these, there’s a very sophisticated set of tools in the xml.etree
    package. We’ll focus on using the ElementTree class in this package to parse and
    analyze XML documents. This has the advantage of offering a large number of useful
    features like XPath searching to find tags in a complicated document.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，xml.etree包中还有一个非常复杂的工具集。我们将专注于使用此包中的ElementTree类来解析和分析XML文档。这具有提供大量有用功能的优势，如XPath搜索，以在复杂文档中查找标签。
- en: 11.7.1 Getting ready
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.1 准备工作
- en: We’ve gathered some sailboat racing results in race_result.xml. This file contains
    information on teams, legs, and the order in which the various teams finished
    each leg. For more information on this data, see the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    recipe in this chapter.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收集了一些帆船赛成绩，保存在race_result.xml文件中。该文件包含有关团队、赛段以及各个团队完成每个赛段顺序的信息。有关此数据的更多信息，请参阅本章中的[阅读JSON和YAML文档](ch015_split_001.xhtml#x1-6520006)配方。
- en: 'The root tag for this data is a <results> document. This has the following
    schema:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据的根标签是一个<results>文档。它具有以下模式：
- en: The <legs> tag contains individual <leg> tags that name each leg of the race.
    Each <leg> tag will contain both a starting port and an ending port in the text.
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <legs>标签包含单个<leg>标签，命名每条赛道的名称。每个<leg>标签将包含一个起始港和一个结束港的文本。
- en: 'The <teams> tag contains a number of <team> tags with details of each team.
    Each team has data structured with internal tags:'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <teams>标签包含多个<team>标签，包含每个团队的详细信息。每个团队的数据都使用内部标签进行结构化：
- en: The <name> tag contains the team name.
  id: totrans-561
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <name>标签包含团队名称。
- en: The <position> tag contains a number of <leg> tags with the finish position
    for the given leg. Each leg is numbered, and the numbering matches the leg definitions
    in the <legs> tag.
  id: totrans-562
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <position>标签包含多个<leg>标签，表示给定腿的完成位置。每个腿都有编号，编号与<legs>标签中的腿定义相匹配。
- en: In XML notation, the application data shows up in two kinds of places. The first
    is between the start and the end tags – for example, <name>Abu Dhabi Ocean Racing</name>,
    has text, ”Abu Dhabi Ocean Racing”, as well as <name> and </name> tags.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML表示法中，应用程序数据出现在两种地方。第一种是在起始标签和结束标签之间——例如，<name>阿布扎比海洋赛车</name>，有文本“阿布扎比海洋赛车”，以及<name>和</name>标签。
- en: Also, data will also show up as an attribute of a tag; for example, in <leg n="1">.
    The tag is <leg>, with an attribute, n, with a value of "1". A tag can have an
    indefinite number of attributes.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，数据还将作为标签的属性出现；例如，在<leg n="1">中。标签是<leg>，具有属性n，其值为"1"。一个标签可以有无限数量的属性。
- en: The <leg> tags point out an interesting problem with XML. These tags include
    the leg number given as an attribute, while the position for the leg is given
    as the text inside the tag. There’s no real pattern or preference to where useful
    data is located. Ideally, it’s always between tags, but that’s not generally true.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: <leg>标签指出了XML的一个有趣问题。这些标签包括作为属性的腿号，而腿的位置由标签内的文本给出。没有真正的模式或偏好来指定有用数据的位置。理想情况下，它总是在标签之间，但这通常不是真的。
- en: 'XML permits a mixed content model. This reflects the case where XML is mixed
    in with text and there is text inside and outside XML tags. Here’s an example
    of mixed content:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: XML允许混合内容模型。这反映了XML与文本混合的情况，其中文本位于XML标签内外。以下是一个混合内容的示例：
- en: '[PRE71]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The content of the <p> tag is a mixture of text and a tag. The data we’re working
    with in this recipe does not rely on this kind of mixed content model, meaning
    all the data is within a single tag or an attribute of a tag. The whitespace between
    tags can be ignored.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: <p> 标签的内容是文本和标签的混合。我们在本食谱中处理的数据不依赖于这种混合内容模型，这意味着所有数据都在单个标签或标签的属性中。标签之间的空白可以忽略。
- en: 11.7.2 How to do it...
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.2 如何实现...
- en: 'We’ll define a function to convert the XML document to a dictionary with leg
    descriptions and team results:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个函数，将 XML 文档转换为包含腿描述和团队结果的字典：
- en: 'We’ll need the xml.etree module to parse the XML text. We’ll also need a Path
    object to refer to the file. We’ve assigned a shorter name of XML to the ElementTree
    class:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要 xml.etree 模块来解析 XML 文本。我们还需要一个 Path 对象来引用文件。我们将 ElementTree 类的较短名称分配给了
    XML：
- en: '[PRE72]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The cast() function is needed to force tools like mypy to treat the result as
    if it were a given type. This lets us ignore the possibility of None results.
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: cast() 函数是必需的，用于强制工具如 mypy 将结果视为给定类型。这使得我们可以忽略 None 结果的可能性。
- en: 'Define a function to read the XML document from a given Path instance:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来从给定的 Path 实例读取 XML 文档：
- en: '[PRE73]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Create a Python ElementTree object by parsing the XML text. It’s often easiest
    to use source_path.read_text() to read the file named by path. We provided this
    string to the XML.fromstring() method for parsing. For very large files, an incremental
    parser is sometimes more helpful. Here’s the version for smaller files:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过解析 XML 文本创建一个 Python ElementTree 对象。通常，使用 source_path.read_text() 读取由路径指定的文件是最简单的。我们提供了这个字符串给
    XML.fromstring() 方法进行解析。对于非常大的文件，增量解析器有时更有帮助。以下是针对较小文件的版本：
- en: '[PRE74]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Display the data. The XML element objects has two useful methods for navigating
    the XML structure, the find() and findall() methods, to locate the first instance
    of a tag and locate all instances of a tag, respectively. Using these, we can
    create a dictionary with two keys, "teams" and "legs":'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示数据。XML 元素对象有两个用于导航 XML 结构的有用方法，即 find() 和 findall() 方法，分别用于定位标签的第一个实例和所有实例。使用这些方法，我们可以创建一个包含两个键的字典，"teams"
    和 "legs"：
- en: '[PRE75]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Within the <legs> tag, there are a number of individual <leg> tags. Each of
    those tags has the following structure:'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 <legs> 标签内，有许多单独的 <leg> 标签。每个标签都具有以下结构：
- en: '[PRE76]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The Python expression leg.attrib[’n’] extracts the value of the attribute named
    n from the given element. The expression leg.text.strip() will find all the text
    within the <leg> tag, stripped of extra whitespace.
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Python 表达式 leg.attrib[’n’] 从给定元素中提取名为 n 的属性值。表达式 leg.text.strip() 将找到 <leg>
    标签内的所有文本，并去除额外的空白。
- en: The find() and findall() methods of an element use XPath notation to locate
    tags. We’ll examine the features in detail in the There’s more... section of this
    recipe.
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 元素的 find() 和 findall() 方法使用 XPath 语法来定位标签。我们将在本食谱的 There’s more... 部分中详细检查这些功能。
- en: 'It’s important to note that the results of the find() function have a type
    hint of XML.Element | None. We have two choices for handling the possibility of
    a None result:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，find() 函数的结果具有 XML.Element | None 的类型提示。对于 None 结果的可能性，我们有两种处理方法：
- en: Use an if statement to handle the cases where the result is None.
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 if 语句来处理结果为 None 的情况。
- en: Use cast(XML.Element, tag.find(...)) to claim that the result is never going
    to be None. If the tag is missing, the exception raised will help diagnose the
    mismatch between the source document and processing expectations by our consumer
    application.
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '使用 cast(XML.Element, tag.find(...)) 来声明结果永远不会是 None。如果标签缺失，引发的异常将有助于诊断源文档与我们的消费者应用程序处理期望之间的不匹配。 '
- en: For each leg of the race, we need to print the finish positions, which are contained
    within the <teams> tag. Within this tag, we need to find the proper <leg> tag
    with the finish position for this team on the given leg. For this, we use a complex
    XPath search, f"position/leg[@n=’{n}’]", to locate a specific instance of the
    <position> tag based on the presence of a <leg> tag with a specific attribute
    value. The value of n is the leg number. For the ninth leg, n=9, the f-string
    will be "position/leg[@n=’9’]". This will locate the <position> tag containing
    a <leg> tag that has an attribute n equal to 9.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 对于比赛的每一腿，我们需要打印完成位置，这些位置包含在 <teams> 标签内。在这个标签内，我们需要找到具有给定腿上该团队完成位置的适当 <leg>
    标签。为此，我们使用复杂的 XPath 搜索，f"position/leg[@n=’{n}’]"，根据具有特定属性值的 <leg> 标签的存在来定位特定的
    <position> 标签。n 的值是腿号。对于第九腿，n=9，f-string 将是 "position/leg[@n=’9’]"。这将定位包含具有属性
    n 等于 9 的 <leg> 标签的 <position> 标签。
- en: Because XML supports a mixed content model, all the \n, \t, and space characters
    in the content are perfectly preserved by the parsing operation. We rarely want
    any of this whitespace, and it makes sense to use the strip() method to remove
    any extraneous characters before and after the meaningful content.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 由于XML支持混合内容模型，内容中的所有 \n、\t 和空格字符在解析操作中都被完美保留。我们很少希望保留这些空白字符，因此在使用 strip() 方法在有意义的内容前后删除任何多余的字符是有意义的。
- en: 11.7.3 How it works...
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.3 它是如何工作的...
- en: The XML parser modules transform XML documents into a fairly complex tree structure
    based on a standardized Document Object Model (DOM). In the case of the xml.etree
    module, the document will be built from Element objects, which generally represent
    tags and text.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: XML解析模块将XML文档转换为基于标准化的文档对象模型（DOM）的相当复杂的树结构。在 xml.etree 模块的情况下，文档将由 Element 对象构建，这些对象通常代表标签和文本。
- en: XML can also include processing instructions and comments. We’ll ignore them
    and focus on the document structure and content here.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: XML还可以包含处理指令和注释。在这里，我们将忽略它们，专注于文档结构和内容。
- en: Each Element instance has the text of the tag, the text within the tag, attributes
    that are part of the tag, and a tail. The tag is the name inside <tag>. The attributes
    are the fields that follow the tag name, for example, the <leg n="1"> tag has
    a tag name of leg and an attribute named n. Values are always strings in XML;
    any conversion to a different data type is the responsibility of the application
    using the data.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素实例都有标签的文本、标签内的文本、标签的部分属性和尾部。标签是 <tag> 内部的名称。属性是跟在标签名称后面的字段，例如，<leg n="1">
    标签有一个名为 leg 的标签名称和一个名为 n 的属性。在XML中，值始终是字符串；任何转换为不同数据类型都是使用该数据的应用程序的责任。
- en: The text is contained between the start and end of a tag. Therefore, a tag such
    as <name>Team SCA</name> has "Team SCA" for the value of the text attribute of
    the Element that represents the <name> tag.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 文本包含在标签的开始和结束之间。因此，一个如 `<name>Team SCA</name>` 的标签具有 "Team SCA" 作为代表 `<name>`
    标签的元素的文本属性值。
- en: 'Note that a tag also has a tail attribute. Consider this sequence of two tags:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签还有一个尾部属性。考虑以下两个标签的序列：
- en: '[PRE77]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: There’s a \n whitespace character after the closing </name> tag and before the
    opening of the <position> tag. This extra text is collected into the tail attribute
    of the <name> tag. These tail values can be important when working with a mixed
    content model. The tail values are generally whitespace when working in an element
    content model.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在 </name> 标签关闭后和 <position> 标签打开前有一个 \n 空白字符。这些额外的文本被收集到 <name> 标签的尾部属性中。当在混合内容模型中工作时，这些尾部值可能很重要。在元素内容模型中工作时，尾部值通常是空白字符。
- en: 11.7.4 There’s more...
  id: totrans-597
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.4 更多内容...
- en: Because we can’t trivially translate an XML document into a Python dictionary,
    we need a handy way to search through the document’s content. The ElementTree
    class provides a search technique that’s a partial implementation of the XML Path
    Language (XPath) for specifying a location in an XML document. The XPath notation
    gives us considerable flexibility.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不能简单地将在XML文档转换为Python字典，我们需要一种方便的方法来搜索文档的内容。ElementTree类提供了一种搜索技术，这是XML路径语言（XPath）的部分实现，用于指定XML文档中的位置。XPath表示法为我们提供了相当大的灵活性。
- en: 'The XPath queries are used with the find() and findall() methods. Here’s how
    we can find all of the team names:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: XPath查询与 find() 和 findall() 方法一起使用。以下是如何找到所有团队名称的方法：
- en: '[PRE78]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The XPath query looks for the top-level <teams> tag. Within that tag, we want
    <team> tags. Within those tags, we want the <name> tags. This will search for
    all the instances of this nested tag structure.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: XPath查询查找顶级 <teams> 标签。在该标签内，我们想要 <team> 标签。在这些标签内，我们想要 <name> 标签。这将搜索所有这种嵌套标签结构的实例。
- en: 11.7.5 See also
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7.5 参见
- en: There are a number of security issues related to XML documents. See the OWASP
    [XML Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html)
    for more information.
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与XML文档相关的安全问题有很多。有关更多信息，请参阅OWASP [XML安全速查表](https://cheatsheetseries.owasp.org/cheatsheets/XML_Security_Cheat_Sheet.html)。
- en: The [lxml](https://pypi.org/project/lxml/) library extends the core features
    of the element tree library, offering additional capabilities.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[lxml](https://pypi.org/project/lxml/) 库扩展了元素树库的核心功能，提供了额外的功能。'
- en: The [Reading HTML documents](ch015_split_001.xhtml#x1-6660008) recipe, later
    in this chapter, shows how we prepared this data from an HTML source.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章后面的 [阅读HTML文档](ch015_split_001.xhtml#x1-6660008) 菜谱展示了我们如何从HTML源准备这些数据。
- en: 11.8 Reading HTML documents
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.8 阅读HTML文档
- en: A great deal of content on the web is presented using HTML. A browser renders
    the data very nicely. We can write applications to extract content from HTML pages.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上大量的内容都是使用HTML呈现的。浏览器将数据渲染得非常漂亮。我们可以编写应用程序从HTML页面中提取内容。
- en: 'Parsing HTML involves two complications:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 解析HTML涉及两个复杂因素：
- en: Ancient HTML dialects that are distinct from modern XML
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现代XML不同的古老HTML方言
- en: Browsers that tolerate HTML that’s incorrect and create a proper display
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以容忍不正确HTML并创建正确显示的浏览器
- en: The first complication is the history of HTML and XML. Modern HTML is a specific
    document type of XML. Historically, HTML started with its own unique document
    type definitions, based on the older SGML. These original SGML/HTML concepts were
    revised and extended to create a new language, XML. During the transition from
    legacy HTML to XML-based HTML, web servers provided content using a variety of
    transitional document type definitions. Most modern web servers use a <DOCTYPE html>
    preamble to state that the document is properly structured XML syntax, using the
    HTML document model. Some web servers will use other DOCTYPE references in the
    preamble and provide HTML that’s not proper XML.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个复杂因素是HTML和XML的历史。现代HTML是XML的一个特定文档类型。历史上，HTML从自己的独特文档类型定义开始，基于较老的SGML。这些原始SGML/HTML概念被修订和扩展，以创建一种新的语言，XML。在从遗留HTML到基于XML的HTML的过渡期间，网络服务器使用各种过渡文档类型定义提供内容。大多数现代网络服务器使用<DOCTYPE html>前缀来声明文档是正确结构的XML语法，使用HTML文档模型。一些网络服务器将在前缀中使用其他DOCTYPE引用，并提供不是正确XML的HTML。
- en: A further complication to parsing HTML is the design of browsers. Browsers are
    obligated to render a web page in spite of poorly structured or even outright
    invalid HTML. The design objective is to provide something to the user that reflects
    the content – not display an error message stating the content is invalid.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 解析HTML的另一个复杂因素是浏览器的设计。浏览器有义务渲染网页，即使HTML结构不佳甚至完全无效。设计目标是向用户提供反映内容的东西——而不是显示错误消息，指出内容无效。
- en: HTML pages may be filled with problems and still display a good-looking page
    in a browser.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: HTML页面可能充满了问题，但在浏览器中仍然可以显示一个看起来不错的页面。
- en: We can use the standard library html.parser module, but it’s not as helpful
    as we’d like. The Beautiful Soup package provides more helpful ways to parse HTML
    pages into useful data structures. This is available from the Python Package Index
    (PyPI). See [https://pypi.python.org/pypi/beautifulsoup4](https://pypi.python.org/pypi/beautifulsoup4).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准库的html.parser模块，但它并不像我们希望的那样有帮助。Beautiful Soup包提供了更多有用的方法来解析HTML页面到有用的数据结构。这个包可以在Python包索引（PyPI）上找到。请参阅[https://pypi.python.org/pypi/beautifulsoup4](https://pypi.python.org/pypi/beautifulsoup4)。
- en: 'This must be downloaded and installed with the following terminal command:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这必须使用以下终端命令下载和安装：
- en: '[PRE79]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 11.8.1 Getting ready
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8.1 准备工作
- en: We’ve gathered some historical sailboat racing results in Volvo Ocean Race.html.
    This file contains information on teams, legs, and the order in which the various
    teams finished each leg. It’s been scraped from the Volvo Ocean Race website,
    and it looks wonderful when opened in a browser. For more information on this
    data, see the [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006)
    recipe in this chapter.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收集了一些历史帆船赛结果，保存在Volvo Ocean Race.html文件中。这个文件包含有关团队、航段以及各个团队完成每个航段的顺序的信息。它已被从沃尔沃海洋赛网站抓取，并在浏览器中打开时看起来很棒。有关此数据的更多信息，请参阅本章中的[阅读JSON和YAML文档](ch015_split_001.xhtml#x1-6520006)配方。
- en: While Python’s standard library has the urllib package to acquire documents,
    it’s common to use the Requests package to read web pages.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python的标准库有urllib包来获取文档，但通常使用Requests包来读取网页。
- en: 'Generally, an HTML page has the following overall structure:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个HTML页面具有以下整体结构：
- en: '[PRE80]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Within the <head> tag, there will be metadata, links to JavaScript libraries,
    and links to Cascading Style Sheet (CSS) documents. The content is in the <body>
    tag.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在<head>标签内，将有元数据、指向JavaScript库的链接以及指向层叠样式表（CSS）文档的链接。内容位于<body>标签中。
- en: 'In this case, the race results are in an HTML <table> tag inside the <body>
    tag. The table has the following structure:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，比赛结果位于<body>标签内的HTML<table>标签中。该表格具有以下结构：
- en: '[PRE81]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The <thead> tag defines the column titles for a table. There’s a single row
    tag, <tr>, with table heading tags, <th>, that include the column titles. For
    the example data, each of the <th> tags look like this:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: <thead>标签定义了表格的列标题。有一个单独的行标签<TR>，其中包含表格标题标签<TH>，这些标签包含列标题。对于示例数据，每个<TH>标签看起来像这样：
- en: '[PRE82]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The essential display is an identifier for each leg of the race; LEG 1, in this
    example. This is the text content of the <th> tag. There’s also an attribute value,
    data, that’s used by a JavaScript function. This attribute value has the name
    of the leg, and it is displayed when the cursor hovers over a column heading.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的显示是每个赛段的标识符；在这个例子中是LEG 1。这是<th>标签的文本内容。还有一个由JavaScript函数使用的属性值，data。这个属性值是腿的名称，当鼠标悬停在列标题上时显示。
- en: 'The <tbody> tag includes rows with the results for each team and race. Each
    <tr> table row tag contains <td> table data tags with the name of a team and its
    results. Here’s a typical <tr> row from the HTML:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: <tbody>标签包含每个团队和比赛的成果行。每个<tr>表格行标签包含带有团队名称及其结果的<td>表格数据标签。以下是从HTML中典型的<tr>行：
- en: '[PRE83]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The <tr> tag has a class attribute that defines the CSS style for this row.
    This class attribute can help our data-gathering application locate the relevant
    content.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: <tr>标签有一个class属性，它定义了此行的CSS样式。这个class属性可以帮助我们的数据收集应用程序定位相关内容。
- en: The <td> tags also have class attributes. For this well-designed data, the class
    clarifies what the content of the <td> cell is. Not all CSS class names are as
    well defined as these.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: <td>标签也有class属性。对于这个精心设计的数据，class属性阐明了<td>单元格的内容。并不是所有的CSS类名都像这些定义得那么好。
- en: One of the cells – with the tooltipster attribute – has no text content. Instead,
    this cell has an <a> tag and an empty <div> tag. That cell also contains several
    attributes, including data, among others. These attributes are used by a JavaScript
    function to display additional information in the cell.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个单元格——带有tooltipster属性——没有文本内容。相反，这个单元格有一个<a>标签和一个空的<div>标签。这个单元格还包含几个属性，包括data等。这些属性由JavaScript函数用于在单元格中显示更多信息。
- en: Another complexity here is that the data attribute contains text that’s actually
    HTML content. Parsing this bit of text will require creating a separate BeautifulSoup
    parser.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个复杂性，即data属性包含实际上是HTML内容的文本。解析这部分文本需要创建一个单独的BeautifulSoup解析器。
- en: 11.8.2 How to do it...
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8.2 如何实现...
- en: 'We’ll define a function to convert the HTML <table> to a dictionary with leg
    descriptions and team results:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个函数，将HTML <table>转换为包含腿描述和团队结果的字典：
- en: 'Import the BeautifulSoup class from the bs4 module to parse the text. We’ll
    also need a Path object to refer to the file:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从bs4模块导入BeautifulSoup类以解析文本。我们还需要一个Path对象来引用文件：
- en: '[PRE84]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define a function to read the HTML document from a given Path instance:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，从给定的Path实例读取HTML文档：
- en: '[PRE85]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create the soup structure from the HTML content. We’ll assign it to a variable,
    soup. As an alternative, we could also read the content using the Path.read_text()
    method:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从HTML内容创建soup结构。我们将将其分配给一个变量，soup。作为替代，我们也可以使用Path.read_text()方法来读取内容：
- en: '[PRE86]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'From the soup object, we need to navigate to the first <table> tag. Within
    that, we need to find the first <thead> and <tr> tags. Navigating to the first
    instance of a tag is done by using the tag name as an attribute:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从soup对象中，我们需要导航到第一个<table>标签。在其内部，我们需要找到第一个<thead>和<tr>标签。通过使用标签名作为属性来导航到第一个实例的标签：
- en: '[PRE87]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'A special comment is used to silence a mypy warning. The # type: ignore [union-attr]
    is needed because each tag property has a type hint of Tag | None. For some applications,
    additional if statements can be used to confirm the expected combinations of tags
    that are present.'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用一个特殊的注释来抑制mypy警告。# type: ignore [union-attr]是必需的，因为每个标签属性的类型提示为Tag | None。对于某些应用程序，可以使用额外的if语句来确认存在的标签的预期组合。
- en: 'We must accumulate heading data from each <th> cell within the row:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须从每一行的每个<th>单元格中累积标题数据：
- en: '[PRE88]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To find the table’s content, we navigate down into the <table> and <tbody>
    tags:'
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找到表格的内容，我们导航到<table>和<tbody>标签：
- en: '[PRE89]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We need to visit all of the <tr> tags. Within each row, we want to convert
    the content of all <td> tags into team names and a collection of team positions,
    depending on the attributes of the td tag:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要访问所有的<tr>标签。在每一行中，我们希望将所有<td>标签的内容转换为团队名称和团队位置集合，这取决于td标签的属性：
- en: '[PRE90]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Once the legs and teams have been extracted, we can create a useful dictionary
    that will contain the two collections:'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦提取了腿和团队，我们就可以创建一个有用的字典，它将包含这两个集合：
- en: '[PRE91]'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We’ve created a list of legs showing the order and names for each leg, and
    we parsed the body of the table to create a dict-of-list structure with each leg’s
    results for a given team. The resulting object looks like this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个腿的列表，显示了每个腿的顺序和名称，并解析了表格的主体以创建一个字典-列表结构，其中包含给定团队的每个腿的结果。生成的对象看起来像这样：
- en: '[PRE92]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Within the body of the table, many cells have None for the final race position
    and a complex value in data attribute for the specific <TD> tag. Parsing the HTML
    embedded in this text follows the pattern shown in the recipe, using another BeautifulSoup
    instance.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在表格的主体中，许多单元格的最终比赛位置为None，而特定<TD>标签的数据属性中有一个复杂值。解析此文本中嵌入的HTML遵循配方中显示的模式，使用另一个BeautifulSoup实例。
- en: 11.8.3 How it works...
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8.3 它是如何工作的...
- en: The BeautifulSoup class transforms HTML documents into fairly complex objects
    based on a Document Object Model (DOM). The resulting structure will be built
    from instances of the Tag, NavigableString, and Comment classes.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: BeautifulSoup类将HTML文档转换为基于文档对象模型（DOM）的相当复杂对象。生成的结构将由Tag、NavigableString和Comment类的实例组成。
- en: Each Tag object has a name, string, and attributes. The name is the word inside
    < and > characters. The attributes are the fields that follow the tag name. For
    example, <td class="ranking-number">1</td> has a tag name of td and an attribute
    named class. Values are often strings, but in a few cases, the value can be a
    list of strings. The string attribute of the Tag object is the content enclosed
    by the tag; in this case, it’s a very short string, 1.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Tag对象都有一个名称、字符串和属性。名称是<和>字符内的单词。属性是跟随标签名称的字段。例如，<td class="ranking-number">1</td>有一个名为td的标签名称和一个名为class的属性。值通常是字符串，但在少数情况下，值可以是字符串列表。Tag对象的字符串属性是标签内的内容；在这种情况下，它是一个非常短的字符串，1。
- en: HTML is a mixed content model. When looking at the children of a given tag,
    there will be a sequence of child Tags and child NavigableText objects freely
    intermixed.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是一个混合内容模型。在查看给定标签的子标签时，将有一个子标签和子NavigableText对象的序列，这些子标签和子NavigableText对象可以自由混合。
- en: The BeautifulSoup parser class depends on a lower-level library to do some of
    the parsing work. It’s easiest to use the built-in html.parser module for this.
    The alternatives offer some advantages, like better performance or better handling
    of damaged HTML.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: BeautifulSoup解析器类依赖于一个底层库来完成一些解析工作。使用内置的html.parser模块来做这个工作是最简单的。其他替代方案提供了一些优势，如更好的性能或更好地处理损坏的HTML。
- en: 11.8.4 There’s more...
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8.4 更多...
- en: The Tag objects of Beautiful Soup represent the hierarchy of the document’s
    structure. There are several kinds of navigation among tags. In this recipe, we
    relied on the way soup.html is the same as soup.find("html"). We can also search
    by attribute values, including class and id. These often provide semantic information
    about the content.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup的Tag对象代表文档结构的层次结构。在标签之间有几种导航方式。在这个配方中，我们依赖于soup.html与soup.find("html")相同的方式。我们还可以通过属性值进行搜索，包括类和id。这些通常提供了关于内容的意义信息。
- en: 'In some cases, a document will have a well-designed organization, and a search
    by the id attribute or class attribute will find the relevant data. Here’s a typical
    search for a given structure using the HTML class attribute:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个文档将有一个精心设计的组织，通过id属性或class属性进行搜索将找到相关数据。以下是一个使用HTML类属性进行给定结构典型搜索的例子：
- en: '[PRE94]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that we have to use class_ in our Python query to search for the attribute
    named class. The token class is a reserved word in Python and cannot be used as
    a parameter name. Given the overall document, we’re searching for any <table class="ranking-list">
    tag. This will find the first such table in a web page. Since we know there will
    only be one of these, this attribute-based search helps distinguish between what
    we are trying to find and any other tabular data on a web page.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须在我们的Python查询中使用class_来搜索名为class的属性。class是一个Python的保留字，不能用作参数名称。考虑到整个文档，我们正在搜索任何<table
    class="ranking-list">标签。这将找到网页中的第一个此类标签。由于我们知道只有一个这样的标签，这种基于属性的搜索有助于区分我们试图找到的内容和网页上的任何其他表格数据。
- en: 11.8.5 See also
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8.5 参见
- en: The [Requests](https://pypi.org/project/requests/) package can greatly simplify
    the code required to interact with complex websites.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Requests](https://pypi.org/project/requests/)包可以极大地简化与复杂网站交互所需的代码。'
- en: Se the [https://www.robotstxt.org](https://www.robotstxt.org) website for information
    on the robots.txt file and the [RFC 9309 Robots Exclusion Protocol](https://www.rfc-editor.org/rfc/rfc9309.html#name-informative-references).
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看关于 robots.txt 文件和 [RFC 9309 机器人排除协议](https://www.rfc-editor.org/rfc/rfc9309.html#name-informative-references)
    的信息，请访问 [https://www.robotstxt.org](https://www.robotstxt.org) 网站。
- en: The [Reading JSON and YAML documents](ch015_split_001.xhtml#x1-6520006) and
    [Reading XML documents](ch015_split_001.xhtml#x1-6600007) recipes, shown earlier
    in this chapter, both use similar data. The example data was created for them
    by scraping the original HTML page using these techniques.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[阅读 JSON 和 YAML 文档](ch015_split_001.xhtml#x1-6520006) 和 [阅读 XML 文档](ch015_split_001.xhtml#x1-6600007)
    的配方，如本章前面所示，都使用了类似的数据。示例数据是通过使用这些技术从原始 HTML 页面抓取创建的。'
- en: Join our community Discord space
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
