- en: 5 Handling and Responding Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 处理和响应视图
- en: Up until this point, our applications have largely been reactive. We worked
    on different parts of web applications to learn about how to manage the incoming
    HTTP request. If we imagine the HTTP request/response cycle as a conversation,
    up until this point, we have been only listening. Our applications have been built
    to hear what the incoming client has to say.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序在很大程度上是反应式的。我们致力于Web应用程序的不同部分，以了解如何管理传入的HTTP请求。如果我们想象HTTP请求/响应周期为一场对话，那么到目前为止，我们只是在倾听。我们的应用程序被构建成听取传入客户端要说的内容。
- en: 'Now, it is our turn to talk. In this Chapter, we begin to explore different
    facets of the HTTP response. Just as we began our learning of the HTTP request
    by looking at a raw request object, we will look at the raw response. It looks
    nearly identical, and at this point should be familiar. We go on to explore some
    of the powerful tools Sanic has to offer. Of course, there are mechanisms for
    JSON and HTML responses, which are probably the most popular types of content
    to be delivered on the Web today. Sanic, however, has an advantage by being an
    async framework: it is super easy to implement server driven responses like: websockets,
    server-sent events (SSE), and streaming responses. We will explore these in this
    chapter as well:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，轮到我们发言了。在本章中，我们将开始探索HTTP响应的不同方面。正如我们通过查看原始请求对象开始学习HTTP请求一样，我们将查看原始响应。它看起来几乎相同，在这个阶段应该很熟悉。我们将继续探索Sanic提供的强大工具。当然，有机制用于JSON和HTML响应，这些可能是今天在网络上交付的最受欢迎的内容类型。然而，Sanic作为一个异步框架，具有优势：实现服务器驱动的响应（如：Websockets、服务器发送事件（SSE）和流式响应）非常简单。我们将在本章中探讨这些内容：
- en: Examining the HTTP response structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查HTTP响应结构
- en: Rendering HTML content
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染HTML内容
- en: Serializing JSON content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化JSON内容
- en: Streaming data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输数据
- en: Server-Sent Events for push communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于推送通信的服务器发送事件
- en: Websockets for two-way communication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于双向通信的Websockets
- en: Setting response headers and cookies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置响应头和cookie
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Some of our examples are going to start getting a little longer than what we
    have previously seen. For the sake of convenience, you may want to keep the GitHub
    repository handy as you read through this chapter: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05.](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05.)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一些示例将开始比我们之前看到的要长一些。为了方便起见，当你阅读本章时，你可能想将GitHub仓库放在手边：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05.](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05.)
- en: Examining the HTTP response structure
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查HTTP响应结构
- en: 'Back in *Chapter 3, Routing and intaking HTTP requests*, we looked at the structure
    of the HTTP request. When a web server is ready to send back a response, the format
    is very similar to what we already saw. The HTTP response will look something
    like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*第3章，路由和接收HTTP请求*，我们探讨了HTTP请求的结构。当Web服务器准备发送响应时，其格式与我们之前看到的非常相似。HTTP响应将看起来像这样：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What we see is the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是以下内容：
- en: First line containing HTTP protocol used, a status code, and a status description
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含使用的HTTP协议、状态码和状态描述的第一行
- en: 'Response headers in `key: value` format and separated by a line break'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '以`key: value`格式和换行符分隔的响应头'
- en: A blank row
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一行空白
- en: Response body
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应体
- en: We are looking at this here not because it is something we must know to build
    a web application. After all, building these response objects to a valid HTTP
    specification is precisely one of the reasons that we use web frameworks. Without
    them, building these blobs would be tedious and error prone. Instead, it is helpful
    for us to review and understand what is happening so that we can increase our
    grasp of HTTP and web application development.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里查看这并不是因为我们必须知道它来构建一个Web应用。毕竟，将响应对象构建为有效的HTTP规范正是我们使用Web框架的原因之一。没有它们，构建这些数据块将会是乏味且容易出错的。相反，对我们来说，回顾和理解所发生的事情，以便我们能够增加我们对HTTP和Web应用开发的掌握是有帮助的。
- en: A lot of the structure is duplicative of what we have already learned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分结构与我们之前学过的内容重复。
- en: HTTP response status
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP响应状态
- en: 'If you compare the HTTP request and response objects, perhaps the most identifying
    difference is the first line. Whereas the request first line had three distinct
    parts, it is easier to think of the response as having only two: the HTTP protocol
    in use, and the response status. We discussed the HTTP protocol earlier in this
    book, for example see *Chapter 3*, *Routing and intaking HTTP requests*, so we
    will skip it here and focus on the response status. The response status is meant
    to be both a computer-friendly and human-friendly tool to let the client know
    what happened to the request. Did it succeed? Was the request wrong? Did the server
    make a mistake? These questions, and more, are answered by the HTTP response status.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较HTTP请求和响应对象，最明显的区别可能是第一行。请求的第一行有三个不同的部分，而响应则更容易想象为只有两个部分：正在使用的HTTP协议和响应状态。我们在这本书中之前讨论了HTTP协议，例如见*第3章*，*路由和接收HTTP请求*，所以在这里我们将跳过它，并专注于响应状态。响应状态旨在成为既适合计算机又适合人类的工具，以便让客户端知道请求发生了什么。它是成功的吗？请求错误吗？服务器出错吗？这些问题以及更多，都由HTTP响应状态回答。
- en: Likely you have a basic understanding of different response codes if you have
    built a website in the past. Even people who have never built an application have
    surely at some time landed on a web page that said **404 Not Found** or **500
    Internal Server Error**. These are response statuses. HTTP response statuses consist
    of a number, and a description. The meanings of these numbers and the specific
    descriptions associated with them are defined in *RFC 7231 § 6*. [https://datatracker.ietf.org/doc/html/rfc7231#section-6.](https://datatracker.ietf.org/doc/html/rfc7231#section-6.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您过去曾经构建过网站，您可能对不同的响应码有基本的了解。即使从未构建过应用程序的人，也肯定在某个时候看到过网页上写着**404 未找到**或**500
    内部服务器错误**。这些都是响应状态。HTTP响应状态由一个数字和一个描述组成。这些数字及其具体描述的定义在*RFC 7231 § 6*中。[https://datatracker.ietf.org/doc/html/rfc7231#section-6.](https://datatracker.ietf.org/doc/html/rfc7231#section-6.)
- en: To clarify, if you see the term *response status*, *status code*, or *response
    code*, they are all describing the same thing. I generally prefer to use *response
    status* to describe the general concept, and *status code* when talking about
    the numeric value of the status. However, they are fairly interchangeable, and
    this book uses the terms interchangeably as well.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，如果您看到术语*响应状态*、*状态码*或*响应码*，它们都描述的是同一件事。我通常更喜欢使用*响应状态*来描述一般概念，而在谈论状态码的数值时使用*状态码*。然而，它们相当可以互换，这本书也使用了这些术语的互换。
- en: 'The three most common statuses are:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的三种状态如下：
- en: 200 OK
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 200 OK
- en: 404 Not Found
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404 未找到
- en: 500 Internal Server Error
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 500 内部服务器错误
- en: In general, Sanic will attempt to respond with the most appropriate status.
    If there is an error, you will likely get a `500`. If the path does not exist,
    it will be a `404`. And, if the server can respond properly, Sanic uses `200`.
    Let’s dig a little deeper to see how the statuses are organized.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Sanic会尝试以最合适的状态响应。如果有错误，您可能会得到一个`500`。如果路径不存在，它将是一个`404`。如果服务器可以正确响应，Sanic将使用`200`。让我们深入探讨一下，看看状态是如何组织的。
- en: Response groupings
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应分组
- en: 'The standard responses are grouped in series of 100s as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标准响应被分组为100系列，如下所示：
- en: '**100s**: *Informational* - provisional responses with information about how
    the client should proceed'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**100系列**：*信息性* - 提供有关客户端应如何继续的信息的临时响应'
- en: '**200s**: *Successful* - responses that indicate the request was processed
    as expected'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**200系列**：*成功* - 表示请求按预期处理'
- en: '**300s**: *Redirection* - responses that indicate the client must take further
    action'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**300系列**：*重定向* - 表示客户端必须采取进一步行动的响应'
- en: '**400s**: *Client error* - responses where it appears the client made a mistake
    in trying to access or proceed with some resource'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**400系列**：*客户端错误* - 表示客户端在尝试访问或处理某些资源时出现了错误'
- en: '**500s**: *Server error* - responses where the server made a mistake and a
    response as expected could not be generated'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**500系列**：*服务器错误* - 表示服务器出现了错误，无法生成预期的响应'
- en: 'Beyond the big three, there are some other important responses you should be
    familiar with:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个主要类别之外，还有一些其他重要的响应您应该熟悉：
- en: '| **Code** | **Description** | **Use case** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **描述** | **用途** |'
- en: '| `201` | Created | Endpoint successfully created a new resource; often the
    response will include the new data and/or an ID that can be used to look it up
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `201` | 已创建 | 端点成功创建了一个新资源；通常响应将包括新数据以及/或可以用来查找它的ID |'
- en: '| `202` | Accepted | The application has taken the request and pushed it to
    a queue or background process for further operation |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `202` | 已接受 | 应用程序已接收请求并将其推送到队列或后台进程以进行进一步操作 |'
- en: '| `204` | No Content | There is no body; typical on an OPTIONS request |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `204` | 无内容 | 没有主体；通常在OPTIONS请求中 |'
- en: '| `301` | Moved Permanently | The target resource is now located at a new permanent
    URI |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `301` | 永久移动 | 目标资源现在位于一个新的永久URI |'
- en: '| `302` | Found | The target resource is temporarily located at a different
    URI |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `302` | 找到 | 目标资源临时位于不同的URI |'
- en: '| `400` | Bad Request | The server is refusing to respond to the request because
    of something improper by the client |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 错误请求 | 服务器拒绝响应请求，因为客户端有不适当的行为 |'
- en: '| `401` | Unauthorized | The request lacks valid authentication credentials
    to be allowed access |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `401` | 未授权 | 请求缺少有效的认证凭据，不允许访问 |'
- en: '| `403` | Forbidden | The request is authenticated, but the server does not
    recognize valid authorization to proceed with the response |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `403` | 禁止 | 请求已认证，但服务器不识别有效的授权以继续响应 |'
- en: Table 5.1 – Common status codes
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.1 – 常见状态码
- en: Response through exceptions
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过异常进行响应
- en: Many of Sanic’s built-in exceptions are associated with a specific status code.
    This means that we can raise an exception and Sanic will automatically catch that
    exception and provide an appropriate response with the proper status code. This
    makes it super convenient, and simple to respond.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic的大多数内置异常都与特定的状态码相关联。这意味着我们可以引发一个异常，Sanic将自动捕获该异常，并使用适当的响应和状态码提供响应。这使得它非常方便，并且简单易行。
- en: 'For example, let’s imagine that we are building a music player application.
    One of our endpoints allows users that are logged in to see their playlist. However,
    it is protected behind authentication and only users that the playlist has been
    shared with are able to access it. Something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们想象我们正在构建一个音乐播放器应用程序。我们的端点之一允许登录用户查看他们的播放列表。然而，它被认证保护，只有与播放列表共享过的用户才能访问它。类似于以下内容：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By raising `NotFound`, Sanic will automatically know that it should return
    a `404 Not Found` response:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引发`NotFound`，Sanic将自动知道它应该返回一个`404 Not Found`响应：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We also could extend this concept with our own custom exception handlers.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过我们自己的自定义异常处理程序扩展这个概念。
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, by subclassing `SanicException` we can associate the exception
    with a status code. We also set a class property: `quiet=True`. This is not necessary,
    but may be desirable. What it means is that the exception and its traceback (the
    details about the type and location of an exception) will not appear in your logging.
    This is a particular feature to `SanicException`. It is helpful for exceptions
    that may be expected (but otherwise uncaught) in the regular course of your application.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，通过继承`SanicException`，我们可以将异常与状态码关联起来。我们还设置了一个类属性：`quiet=True`。这不是必需的，但可能是期望的。这意味着异常及其跟踪信息（有关异常类型和位置的详细信息）将不会出现在您的日志中。这是`SanicException`的一个特定功能。对于在应用程序的正常运行过程中可能预期（但未捕获）的异常，它是有帮助的。
- en: Custom status
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义状态
- en: Just as we saw with HTTP methods, it is possible to make-up your own status
    codes as long as they have three digits. I am not suggesting this is a *good*
    idea, merely pointing out that it is possible and Sanic will let you do it, even
    though you probably should not. Creating your own status codes might confuse browsers
    or clients that are using your application. Throwing caution to the wind, we will
    try it anyway just to see that Sanic allows us to do it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的HTTP方法一样，只要它们有三位数，就可以创建自己的状态码。我并不是建议这是一个*好*主意，只是指出这是可能的，Sanic允许我们这样做，尽管你可能不应该这样做。创建自己的状态码可能会让使用你的应用程序的浏览器或客户端感到困惑。不顾一切，我们仍然会尝试一下，看看Sanic是否允许我们这样做。
- en: 'Add a new status type to an otherwise “private” variable (remember, its just
    Python so we can hack it if we want):'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向一个“私有”变量（记住，它只是Python，所以如果我们想，我们可以对其进行修改）添加一个新的状态类型：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Nice. Now let’s see what happens.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很好。现在让我们看看会发生什么。
- en: 'Check the HTTP return making sure to use `-i` so we see the raw response:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查HTTP返回，确保使用`-i`以便我们看到原始响应：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To wrap up, here is a fun little experiment, and a quirk of the HTTP spec.
    Enter this route into your application:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结一下，这里有一个有趣的小实验，以及HTTP规范的怪癖。将此路由输入您的应用程序：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, query it using `curl` so you can see the response (don’t forget the `-i`):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`curl`查询它，以便您可以看到响应（别忘了`-i`）：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Headers
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标题
- en: 'The second part of the HTTP response is the same as the second part of the
    HTTP request: headers arranged one per line in a `key: value` format. Like before,
    the keys are case insensitive, and can be repeated more than once in the response.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'HTTP响应的第二部分与HTTP请求的第二部分相同：以`key: value`格式每行排列的标题。像之前一样，键不区分大小写，可以在响应中重复多次。'
- en: One interesting thing to keep in mind is that when a webserver responds with
    an informational status (series 100), it does *not* include headers. These responses
    are generally used only in the context of *upgrading* an HTTP connection to a
    websocket connection. Since this is a responsibility of the framework, we can
    safely ignore this, and just file it away as good information to have.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有趣的事情需要记住，当一个网络服务器以信息状态（系列100）响应时，它*不*包括标题。这些响应通常仅在将HTTP连接升级为websocket连接的上下文中使用。由于这是框架的责任，我们可以安全地忽略它，并将其作为有用的信息存档。
- en: Headers are generally pretty simple to use in Sanic. We will dig into them a
    little bit later on, but for now we need to keep in mind that we can simply pass
    a dictionary with values.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sanic中使用标题通常很简单。我们稍后会深入探讨它们，但到目前为止，我们需要记住我们可以简单地传递一个包含值的字典。
- en: 'Add a `headers` argument with a dictionary of values into any response function.
    Here we use `empty` because we are not sending any body response, just the headers:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何响应函数中添加一个包含值的`headers`参数。这里我们使用`empty`，因为我们没有发送任何正文响应，只是标题：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s see what the response looks like using curl, and making sure to use -i
    so that we see the headers:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看使用curl的响应是什么样的，并确保使用`-i`以便我们看到标题：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The astute mathematician looking at my example will notice that I got it only
    partially correct. Two is not the only value. How can we have duplicate header
    keys? Since Python regular dictionaries will not allow us to duplicate keys, we
    can use a special data type that Sanic offers us to do the job.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 精明的数学家在审视我的例子时会注意到，我只部分正确。2并不是唯一的值。我们如何会有重复的标题键？由于Python常规字典不允许我们重复键，我们可以使用Sanic为我们提供的特殊数据类型来完成这项工作。
- en: 'Using the same response as before, insert a `Header` object with two of the
    same keys as shown:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前相同的响应，插入一个具有两个相同键的`Header`对象，如下所示：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We hopefully will now see our more mathematically correct response headers;
    the same key twice, but each time with a different value:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望现在能看到更数学上正确的响应头；相同的键两次，但每次都有不同的值：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Response Body
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应正文
- en: 'The last part of the HTTP response is the body. It is arguably the most important
    part of this whole business we call HTTP. We can realistically state that the
    HTTP response body is what the whole driving force of the web is after: the sharing
    of content. The remainder of this chapter will focus on some of the different
    and more popular ways that we can structure data in the HTTP response body. Whether
    it is HTML, JSON, or raw bytes, what we are about to dive into will be part of
    the cornerstone of every web application you build. First up is HTML content where
    we will explore methodologies for sending both static HTML content and generating
    dynamic HTML content.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应的最后一部分是正文。它可以说是我们称之为HTTP的整个业务中最重要的一部分。我们可以合理地说，HTTP响应正文是整个网络驱动的动力：内容的共享。本章的其余部分将重点介绍我们可以在HTTP响应正文中结构化数据的一些不同且更流行的方法。无论是HTML、JSON还是原始字节，我们即将深入探讨的内容将是每个你构建的Web应用程序的基石之一。首先是HTML内容，我们将探讨发送静态HTML内容和生成动态HTML内容的方法。
- en: Rendering HTML content
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染HTML内容
- en: The foundation of the Web is HTML. It is the media that enables browsers to
    function, and therefore it is fundamental that a web server must be capable of
    delivering HTML content. Whether building a traditional page-based application,
    or a single-page application, HTML delivery will be necessary. In *Chapter 3*,
    *Routing and Intaking HTTP Requests*, we discussed how we could route web requests
    to our static files. If you have static HTML files, then this is a great option.
    But, what if you need to generate dynamic HTML for your application?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的基础是HTML。它是使浏览器能够工作的媒体，因此，一个网络服务器必须能够传递HTML内容是基本的。无论是构建传统的基于页面的应用程序，还是单页应用程序，HTML传递都是必要的。在*第3章*，*路由和接收HTTP请求*中，我们讨论了如何将网络请求路由到我们的静态文件。如果你有静态HTML文件，那么这是一个很好的选择。但是，如果你需要为你的应用程序生成动态HTML呢？
- en: Since there are multitudes of ways that this could be accomplished, we will
    take a look at some of the general patterns that could be used with Sanic.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有无数种实现方式，我们将查看一些可以使用 Sanic 的一般模式。
- en: Delivering HTML files
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 交付 HTML 文件
- en: 'Serving HTML content is generally a simple operation. We need to send back
    a response to the client with HTML text and a header that tells the recipient
    that the document should be treated as HTML. Ultimately, the raw HTTP response
    is going to look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器 HTML 内容通常是一个简单的操作。我们需要向客户端发送一个包含 HTML 文本和头部的响应，告诉接收者该文档应被视为 HTML。最终，原始 HTTP
    响应将看起来像这样：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Quick side note, while the preceding example may be valid HTML, not all the
    following examples will be. Getting 100% HTML semantics is not the aim of this
    book, so we might break a few rules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 快速说明，虽然前面的例子可能是有效的 HTML，但接下来的所有例子可能不是。本书的目标不是达到 100% 的 HTML 语义，所以我们可能会打破一些规则。
- en: 'Let’s imagine now that we are building a music player application. The first
    thing that needs to happen when someone lands on our website is to login. If that
    person already has an active session, we want them to go to the **What’s new**
    page. In Chapter 6 and 7 we will look at how to use middleware and integrate it
    with authentication. For now, we will assume our application has already determined
    authentication and authorization. It has stored those values as `request.ctx.user`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们现在正在构建一个音乐播放器应用程序。当有人访问我们的网站时，需要发生的第一个事情是登录。如果那个人已经有了一个活跃的会话，我们希望他们去**最新内容**页面。在第
    6 章和第 7 章中，我们将探讨如何使用中间件并将其与身份验证集成。现在，我们将假设我们的应用程序已经确定了身份验证和授权。它已经将这些值存储为 `request.ctx.user`：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Have you noticed a pattern so far? All we really need to do to generate HTML
    content with Sanic is basic string building! So, if we can inject values into
    a string with string interpolation, then we have dynamic HTML. Here’s a simple
    illustration:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到一个模式了吗？我们真正需要做的，为了使用 Sanic 生成 HTML 内容，只是基本的字符串构建！所以，如果我们可以用字符串插值将值注入到字符串中，那么我们就有了动态
    HTML。这里有一个简单的说明：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Instead of using `curl`, let’s see what it looks like in a browser this time:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们不用 `curl`，看看在浏览器中是什么样子：
- en: '![Figure 5.1 - Browser screenshot of interpolated HTML](img/file4.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 - 混插 HTML 的浏览器截图](img/file4.png)'
- en: Figure 5.1 - Browser screenshot of interpolated HTML
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 - 混插 HTML 的浏览器截图
- en: String interpolation of HTML is just a fancy way of saying templating.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 字符串插值只是模板化的一种花哨说法。
- en: Basic templating
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本模板化
- en: 'In the past, I have presented at a couple Python web conferences. While preparing
    my talks I looked for tools that would make it super simple to generate a slide
    presentation. Since I am most comfortable working in my text editor, I was particularly
    interested in solutions that would translate markdown to slides. I found a tool
    called `remark.js`. If you want to learn more about remark: [https://remarkjs.com/.](https://remarkjs.com/.)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我参加过几次 Python 网络会议。在准备我的演讲时，我寻找能够使生成幻灯片变得超级简单的工具。由于我最舒服的工作环境是文本编辑器，我对将 Markdown
    转换为幻灯片的解决方案特别感兴趣。我找到了一个名为 `remark.js` 的工具。如果你想了解更多关于 remark 的信息：[https://remarkjs.com/](https://remarkjs.com/)
- en: 'In order to render slides from markdown, all I needed was an HTML file and
    some markdown text:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 Markdown 渲染幻灯片，我只需要一个 HTML 文件和一些 Markdown 文本：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This was super simple and exactly what I was looking for. However, there was
    a problem because my IDE did not know the text inside the `<textarea>` was markdown.
    Therefore, I had no syntax highlighting. Bummer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，正好是我想要的。然而，有一个问题，因为我的 IDE 不知道 `<textarea>` 中的文本是 Markdown。因此，我没有语法高亮。真糟糕。
- en: The solution was quite simple really. I just needed a way to inject my markdown
    into the HTML file and serve that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案实际上非常简单。我只需要一种方法将我的 Markdown 注入到 HTML 文件中，并提供服务。
- en: 'A quick fix to the HTML:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对 HTML 的快速修复：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Voila! An HTML template. Now, let’s *render* it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！一个 HTML 模板。现在，让我们*渲染*它。
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Just like that, we built a templating engine. The basic idea of any templating
    engine is that there is some protocol for telling the application how to convert
    and inject dynamic content. Python does this with its multiple forms of string
    interpolations. In my super simple solution engine, all I needed to do was replace
    the `__SLIDES__` value. I am sure you can start to formulate ideas on how you
    could build your own simple engine.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们构建了一个模板引擎。任何模板引擎的基本思想是存在某种协议，用于告诉应用程序如何转换和注入动态内容。Python通过其多种字符串插值形式来实现这一点。在我的超级简单的解决方案引擎中，我只需要替换`__SLIDES__`值。我相信你已经开始思考如何构建自己的简单引擎了。
- en: 'In fact, maybe you should try that now. Here is a HTML template:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，也许你现在应该尝试一下。这里有一个HTML模板：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now for the start:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It is your turn now to fill in the rest by building the rendering agent. Try
    to build a `render` function to work with *any* variable names, not just `name`
    and `age`. We want this to be reusable in more than just one location.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到你了，通过构建渲染代理来填写剩余的部分。尝试构建一个可以与**任何**变量名一起工作的`render`函数，而不仅仅是`name`和`age`。我们希望这个函数能在多个位置重复使用。
- en: Using a templating engine
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模板引擎
- en: 'Of course, you do not need to always make your own templating engine. There
    are many great choices already built. Popular template engines in Python are Genshi,
    Mako, and Jinja2\. But remember, all we really need to do is build a string. So
    any tools that you have that can do this will work. These packages can be thought
    of as fancy versions of the Python format function. They take strings and inject
    data into them to generate a bigger string. Any Python templating tool that you
    pick up will work with Sanic. Specifically regarding Jinja2, there are some Sanic
    plugins already out there that make interactions between Sanic and Jinja2 super
    simple. Feel free to check them out on your own time. On the basic level, templating
    with Jinja2 can be as lightweight as this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必总是创建自己的模板引擎。已经有很多优秀的选项可供选择。Python中流行的模板引擎有Genshi、Mako和Jinja2。但请记住，我们真正需要做的只是构建一个字符串。所以任何可以做到这一点的工具都可以工作。这些包可以被视为Python格式函数的高级版本。它们接受字符串并将数据注入其中以生成更长的字符串。你选择的任何Python模板工具都可以与Sanic一起工作。具体到Jinja2，已经有了一些Sanic插件，可以让Sanic和Jinja2之间的交互变得非常简单。你可以随时查看它们。在基本层面上，使用Jinja2进行模板化可以像这样轻量级：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And now to see the result:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来看看结果：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To move our templates out of Python and into their own HTML files, we can use
    Jinja2’s `Environment` construct.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的模板从Python移动到它们自己的HTML文件中，我们可以使用Jinja2的`Environment`构造。
- en: 'Create some HTML using Jinja2 syntax. This will be saved as `index.html` in
    a `templates` directory. You can see the structure used in the GitHub repository:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Jinja2语法创建一些HTML。这将保存在`templates`目录下的`index.html`文件中。你可以在GitHub仓库中看到使用的结构：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now setup the `Environment` and attach it to our application context so that
    it is easily available throughout our application:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在设置`Environment`并将其附加到我们的应用程序上下文中，以便在整个应用程序中轻松访问：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, grab the template by filename in our route handler, and inject some
    content into it:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的路由处理程序中通过文件名获取模板，并向其中注入一些内容：
- en: '[PRE24]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With that all done, we should be able to visit our application in a web browser
    and see the rendered HTML.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都完成之后，我们应该能够在网页浏览器中访问我们的应用程序并看到渲染的HTML。
- en: '**TIP**'
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When building with Sanic, you may have noticed how handy it is to have `auto_reload`
    enabled. Every time you hit the save button, the application restarts and is available
    for you to test immediately. Wouldn’t it be great if the same were true when building
    HTML files? There is a tool that does this called **livereload**. Essentially
    it injects some Javascript into your HTML to make it listen to commands to refresh
    the page. When building that slide presentation I talked about earlier, I made
    a livereload server so that I could keep the browser open side-by-side with my
    IDE while I typed. Every time I hit **Save**, my browser refreshed, and I could
    see the rendered content without having to lift my fingers off the keyboard. If
    you are interested in more detail on this topic, checkout *Chapter 11*.
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当使用Sanic构建时，你可能已经注意到启用`auto_reload`是多么方便。每次你点击保存按钮时，应用程序都会重新启动，并立即可供你测试。如果构建HTML文件时也能这样那就太好了。有一个叫做**livereload**的工具可以做到这一点。本质上，它会将一些JavaScript注入到你的HTML中，使其能够监听刷新页面的命令。在我之前提到的那个幻灯片演示中，我创建了一个livereload服务器，这样我可以在编写代码的同时，将浏览器和IDE并排打开。每次我点击**保存**，浏览器都会刷新，我可以在不离开键盘的情况下看到渲染的内容。如果你对这个主题感兴趣，可以查看*第11章*。
- en: Serializing JSON content
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化JSON内容
- en: Next to HTML content, JSON is one of the most common forms of data transferred
    on the web. If you are building a **single-page application** (**SPA**),( also
    known as a **progressive web application** or **PWA**), likely your backend server
    *only* or *mostly* returns JSON content. A common build pattern for a modern web
    application is to build a frontend user-interface with a Javascript framework
    powered by a backend server that feeds the frontend with dynamic JSON documents.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML内容旁边，JSON是网络上传输的最常见的数据格式之一。如果你正在构建**单页应用程序**（SPA），（也称为**渐进式Web应用程序**或**PWA**），很可能会让你的后端服务器**仅**或**主要**返回JSON内容。现代Web应用程序的一个常见构建模式是使用JavaScript框架构建前端用户界面，并由后端服务器提供动态JSON文档。
- en: Choosing on a serializer
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择序列化器
- en: The Python standard library, of course, ships with a JSON package that makes
    serializing Python objects to JSON strings (and the reverse) very simple. However,
    it is not the most performant implementation. In fact, it is quite slow. Many
    third-party packages have popped up to attempt to fix this problem. We will explore
    two of the common packages often used with Sanic.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库当然附带了一个JSON包，它使得将Python对象序列化为JSON字符串（反之亦然）变得非常简单。然而，它并不是最有效的实现。实际上，它相当慢。许多第三方包已经出现，试图解决这个问题。我们将探索两个常与Sanic一起使用的常见包。
- en: 'When talking about response serialization, what we care about is the operation
    of the `dumps()` method. Each of these projects provides an interface with this
    method. To select a serializer, what we need to do is to set the dumps() method
    in one of two locations: at the response level, or application wide. We will see
    how to do both shortly.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到响应序列化时，我们关心的是`dumps()`方法的操作。这些项目中的每一个都提供了一个具有此方法的面板。要选择序列化器，我们需要做的是在两个位置之一设置`dumps()`方法：在响应级别或应用程序范围内。我们很快就会看到如何做到这一点。
- en: UJSON
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: UJSON
- en: '**UltraJSON** (aka **ujson**) is an alternative JSON implementation that is
    written in C. Because of its emphasis on performance, it was adopted as the default
    JSON tool for Sanic. If you do nothing else, this is the package that Sanic will
    use.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**UltraJSON**（也称为**ujson**）是一个用C编写的JSON实现替代方案。由于其注重性能，它被选为Sanic的默认JSON工具。如果你什么都不做，这就是Sanic将使用的包。'
- en: 'It includes some helpful encoder options such as: `encode_html_chars`, `ensure_ascii`,
    and `escape_forward_slashes`. Consider the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一些有用的编码器选项，例如：`encode_html_chars`、`ensure_ascii`和`escape_forward_slashes`。考虑以下示例：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we access this endpoint, `ujson` will by default escape our slashes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问这个端点时，`ujson`将默认转义我们的斜杠：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can use `functools.partial` to change the behavior.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`functools.partial`来改变行为。
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By using the `dumps` keyword argument, we have told Sanic to use a different
    serializer. The result should be what we want:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`dumps`关键字参数，我们已告诉Sanic使用不同的序列化器。结果应该是我们想要的：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you do not want to use ujson in your projects, then you can force Sanic
    to skip installation of ujson:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在你的项目中使用ujson，那么你可以强制Sanic跳过ujson的安装：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: While ujson is a great project that adds some much needed performance to JSON
    string manipulation in Python, it *might* not actually be the fastest. Next, we
    will look at another relatively new package that attempts to bring performance
    to JSON manipulation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ujson`是一个很好的项目，它为Python中的JSON字符串操作添加了一些急需的性能，但它**可能**并不是最快的。接下来，我们将看看另一个相对较新的包，它试图将性能带到JSON操作中。
- en: ORJSON
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ORJSON
- en: A newer player to the game is orjson. It is written in Rust and claims to be
    the fastest alternative according to benchmarks. For this reason, many people
    like to swap out ujson for orjson.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中有一个新玩家是orjson。它是用Rust编写的，根据基准测试声称是最快的替代方案。因此，许多人喜欢用orjson替换ujson。
- en: An interesting thing to note about orjson is that it has built-in support for
    serializing common Python objects like `datetime.datetime` and `uuid.UUID`. Since
    these are both very common when building web applications, it is super convenient
    to not have to think about how to handle these object types. It also should be
    noted that whereas the standard library and ujson return a `str` value, orjson
    returns a `bytes` string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关于orjson的一个有趣的事情是它内置了对常见Python对象如`datetime.datetime`和`uuid.UUID`的序列化支持。由于这些在构建Web应用程序时都非常常见，因此无需考虑如何处理这些对象类型是非常方便的。还应该注意的是，标准库和ujson返回一个`str`值，而orjson返回一个`bytes`字符串。
- en: 'We can easily tell Sanic to use orjson everywhere:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地告诉Sanic在所有地方使用orjson：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Serializing custom objects
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化自定义对象
- en: 'In the last two sections, you may have noticed there are two ways to override
    the default dumps method. The first is by changing a single response:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两个部分中，你可能已经注意到有两种方法可以覆盖默认的 `dumps` 方法。第一种是通过更改单个响应：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The second, will apply to all routes globally:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法将应用于全局所有路由：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Feel free to mix and match both the handler-specific method, and the application-wide
    method to meet your application needs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 随意混合使用特定处理器的方法和全局应用方法，以满足您的应用需求。
- en: 'We quickly looked at two alternative packages. There are of course others.
    So how should you decide which package to use? When deciding on an implementation,
    often one of the biggest considerations is how to handle custom non-scalar objects.
    That is to say, how do we want objects that do not have an obvious and built-in
    mapping to JSON types (like strings, integers, floats, booleans, lists, and dictionaries)
    to behave when rendered to JSON. To make this point clear, consider this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速浏览了两个替代包。当然还有其他的。那么，你应该如何决定使用哪个包呢？在决定实现时，通常最大的考虑之一是如何处理自定义的非标量对象。也就是说，我们希望没有明显和内置映射到
    JSON 类型（如字符串、整数、浮点数、布尔值、列表和字典）的对象在渲染为 JSON 时如何表现。为了使这一点更清晰，考虑以下示例：
- en: 'Let’s say we have a Thing.It looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个 `Thing`。它看起来像这样：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If we do nothing, serializing a `Thing` object is not so straightforward, and
    JSON tools usually will throw an error because they do not know what to do with
    it. Without resorting to manual intervention, we can rely upon each of the tools’
    methodology to explicitly provide instructions when coming across a `Thing` object.
    We will consider each alternative to see how we can reduce `Thing` to a JSON accessible
    object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们什么都不做，序列化一个 `Thing` 对象并不那么直接，JSON 工具通常会抛出一个错误，因为它们不知道如何处理它。在不进行手动干预的情况下，我们可以依赖每个工具的方法来明确提供指令，当遇到
    `Thing` 对象时。我们将考虑每个替代方案，看看我们如何将 `Thing` 减少到可访问的 JSON 对象。
- en: 'Perhaps, the most simple is `ujson`. Besides its performance, this happens
    to be one of my favorite features. If an object has a `__json__` method, ujson
    will call it when converting the object to JSON:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，最简单的是 `ujson`。除了其性能外，这恰好也是我最喜欢的功能之一。如果一个对象有一个 `__json__` 方法，ujson 在将对象转换为
    JSON 时会调用它：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Because of this functionality, when I am working on a project one of the things
    I often do is identify some base models for my objects and include a `__json__`
    method. But what about the other tools?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个功能，当我在一个项目上工作时，我经常做的事情之一是确定一些对象的基本模型，并包括一个 `__json__` 方法。但其他工具怎么办呢？
- en: 'Orjson allows us to pass a `default function` to the serializer. If it does
    not know how to render an object, it will call this. While ujson opts to handle
    this on the object/model, orjson opts to handle it in each individual serializer.
    The sky is really the limit to the complexity you want to add. Since I am a fan
    of using `__json__` methods on my custom objects, we can achieve the same functionality
    with orjson like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Orjson 允许我们将一个 `default function` 传递给序列化器。如果它不知道如何渲染一个对象，它将调用这个函数。虽然 ujson 选择在对象/模型上处理这个问题，但
    orjson 选择在每个单独的序列化器中处理它。你想要添加的复杂性实际上是没有限制的。由于我是一个喜欢在我的自定义对象上使用 `__json__` 方法的粉丝，我们可以像这样使用
    orjson 实现相同的功能：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This might get a bit repetitive if you are constantly redefining the serializer
    method in response handlers. Instead, maybe it is worth it to use the standard
    library to help. We can create a partial function with the `default` argument
    already populated.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常在响应处理器中重新定义序列化方法，这可能会变得有点重复。相反，也许使用标准库来帮助是有价值的。我们可以创建一个部分函数，其中 `default`
    参数已经填充。
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The most cumbersome implementation is the standard library that requires you
    to pass it a custom encoder class. It is very similar to the orjson method, albeit
    with a little more boilerplate needed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最繁琐的实现是标准库，它要求你传递一个自定义编码器类。它与 orjson 方法非常相似，尽管需要更多的样板代码。
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Seeing the above example, you should now be able to add the `__json__` approach
    to the `CustomEncoder`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看上述示例，你现在应该能够将 `__json__` 方法添加到 `CustomEncoder` 中。
- en: No matter the project, you are very likely to come up against this issue. Having
    a standard and consistent way to handle non-scalar objects is important. Assess
    how you plan to build and look for meaningful patterns. I generally find this
    to be more of an important decision than raw performance. The incremental performance
    changes from one package to the next are likely not going to be as impactful as
    making a decision based upon how your application will be built and maintained.
    For example, what if you need to render an integer that is larger than 64 bits?
    Both ujson and orjson have a limitation where they will raise exceptions and not
    be capable of handling your data. The standard library implementation, however
    does have this capacity. As we stated back in the beginning, make the right decisions
    that are the most obvious to your needs. But, let’s turn to some common practices
    and see what we might be able to learn from.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 无论项目是什么，你很可能都会遇到这个问题。有一个标准和一致的方式来处理非标量对象是很重要的。评估你计划如何构建，并寻找有意义的模式。我通常发现这比原始性能更重要。从一个包到下一个包的性能增量变化可能不会像基于你的应用程序如何构建和维护所做的决策那样有影响。例如，如果你需要渲染一个大于64位的整数呢？ujson和orjson都有局限性，它们会引发异常，无法处理你的数据。然而，标准库实现确实有这个能力。正如我们一开始所说的，做出最符合你需求的正确决策。但是，让我们转向一些常见的做法，看看我们能学到什么。
- en: Best practices
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 'There are a number of common practices for what *typical* JSON responses look
    like. Of course, the content and your organization is something that will be determined
    by your application’s needs. But, there is one common question you will find often
    discussed on developer forums: “*How should I format an array of objects?*”'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*典型*的JSON响应格式，有许多常见的做法。当然，内容和你的组织结构将由你的应用程序需求决定。但是，你会在开发者论坛上经常看到的一个常见问题是：“*我应该如何格式化对象数组？*”
- en: 'Coming back to our earlier example, let’s imagine we are still building our
    music app. We now want to build an endpoint that lists out all of the available
    songs. Each individual song “object” will look something like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子，让我们假设我们仍在构建我们的音乐应用。我们现在想要构建一个端点，列出所有可用的歌曲。每个单独的歌曲“对象”看起来可能像这样：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'How should we organize an array of songs? There are two schools of thought:
    only use top level objects, use whatever structure fits your data best. What we
    are talking about is the difference between:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何组织歌曲数组？有两种观点：只使用顶级对象，使用最适合你数据结构的结构。我们讨论的是以下两种结构之间的区别：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Why is there even a debate? And, why do some people strictly only use top level
    objects? There was a JSON security flaw in browsers uncovered in 2006 that would
    allow attackers to execute code based upon the second option, the top-level JSON
    array. For this reason, many people suggested that using the first structure was
    more secure.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会有这样的争论？为什么有些人严格只使用顶级对象？2006年，浏览器中发现了JSON的一个安全漏洞，允许攻击者根据第二种选择，顶级JSON数组执行代码。因此，许多人建议使用第一种结构更安全。
- en: 'While this is no longer a concern since the impacted browsers are long out
    of date, I still like the top-level object pattern. It still provides one critical
    benefit over the second option: flexibility without compromising on compatibility.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个问题现在已经不再存在，因为受影响的浏览器已经过时，但我仍然喜欢顶级对象模式。它仍然提供了第二个选项所没有的一个关键好处：灵活性而不牺牲兼容性。
- en: If our array of objects is nested inside of a top-level object, then we can
    easily modify our endpoints in the future to add new keys to the top-level without
    impacting anyone using that endpoint. One pattern that I like to include is to
    have a `meta` object that includes some of the details of the query, and contains
    pagination information.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的对象数组嵌套在顶级对象中，那么我们可以在未来轻松地修改我们的端点，添加新的键到顶级，而不会影响使用该端点的人。我喜欢包含的一个模式是有一个`meta`对象，它包含查询的一些细节，并包含分页信息。
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Therefore, I suggest that when given the choice, you nest your objects like
    this. Some people also like to nest single objects:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我建议，当有选择时，你应该像这样嵌套你的对象。有些人也喜欢嵌套单个对象：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The argument goes that the same principle applies. The endpoint is more easily
    extensible if the objects are nested. However, this argument seems less convincing
    and practical when dealing with single objects. Generally, any change in the endpoint
    would be related to the object itself. So, perhaps this is a use-case for versioning,
    which we explored in Chapter 3.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说，同样的原则也适用。如果对象是嵌套的，端点更容易扩展。然而，当处理单个对象时，这个论点似乎不太有说服力且不实用。通常，端点的任何变化都会与对象本身相关。因此，这可能是一个版本化的用例，我们在第3章中探讨了这一点。
- en: 'No matter your decision on how to structure the data, sending information about
    our songs in JSON format is still just a structural decision that will be dictated
    by the constraints of the application being built. Now we want to move onto the
    next step: actually sending the song itself. Let’s see how we can do that next.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定如何结构化数据，以JSON格式发送我们歌曲的信息仍然只是由构建的应用程序约束所决定的架构决策。现在我们想要进行下一步：实际上发送歌曲本身。让我们看看我们如何做到这一点。
- en: Streaming data
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式数据
- en: When introducing the concept of streaming in *Chapter 4*, I said that request
    streaming was probably the less popular of the two types. I do not have any empirical
    data to confirm this, but it seems readily apparent to me that when most people
    hear the term “streaming”—whether they are a developer or a layperson—the implication
    is that there is a consumption of some form of media from “the cloud.”
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章介绍流的概念时，我说请求流可能是两种类型中不太受欢迎的一种。我没有任何经验数据来证实这一点，但对我来说，当大多数人听到“流”这个词——无论他们是开发者还是普通人——其含义通常是“从云端”消费某种形式的媒体。
- en: 'What we are looking to achieve in this section is to learn how we can accomplish
    this. How exactly does this work? When building a streaming response, Sanic will
    add the same `Transfer Encoding: chunked` header that we saw with streaming requests.
    This is the indication to the client that the server is about to send incomplete
    data. Therefore, it should leave the connection open.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们想要了解我们如何实现这一点。这究竟是如何工作的？当构建流式响应时，Sanic会添加与流式请求中看到的相同的 `Transfer Encoding:
    chunked` 标头。这是向客户端的指示，表明服务器即将发送不完整的数据。因此，它应该保持连接打开。'
- en: 'Once this happens, it is time for the server to send data at its discretion.
    What is a chunk of data? It follows a protocol whereby the server sends the number
    of bytes it is about to send (in hexidecimal format), followed by a `\r\n` line
    break, followed by some bytes, and another `\r\n` line break:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生这种情况，服务器就有权自行发送数据。数据块是什么？它遵循一个协议，其中服务器发送它即将发送的字节数（十六进制格式），然后是一个 `\r\n` 换行符，接着是一些字节，再是一个
    `\r\n` 换行符：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the server is done, it needs to send a `0` length chunk:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器完成时，它需要发送一个长度为 `0` 的数据块：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can probably guess, Sanic will take care of much of the plumbing in
    setting up the headers, determining chunk sizes, and adding the appropriate line
    breaks. Our job is to control the business logic. Let’s see what a super simple
    implementation looks like, and then we can build from there:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所能猜到的，Sanic将负责设置标头、确定数据块大小和添加适当的换行符的大部分工作。我们的工作是控制业务逻辑。让我们看看一个超级简单的实现是什么样的，然后我们可以从这里开始构建：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we were consuming streaming requests, we needed to use the `stream` keyword
    argument or decorator. For responses, the simplest method is to generate the response
    up front: `resp = await request.respond()`. In our example, `resp` is a `<class
    ''sanic.response.HTTPResponse''>` type object.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们消费流式请求时，我们需要使用 `stream` 关键字参数或装饰器。对于响应，最简单的方法是提前生成响应：`resp = await request.respond()`。在我们的例子中，`resp`
    是一个 `<class 'sanic.response.HTTPResponse'>` 类型的对象。
- en: Once we have a response object, we can write to it whenever, and however we
    want using either regular strings `("hello")` or bytes strings `(b"hello").` When
    there is no more data to be transferred, we tell the client using `resp.eof(),`
    and we are done.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了响应对象，我们就可以随时以任何方式写入它，无论是使用常规字符串 `("hello")` 还是字节字符串 `(b"hello")`。当没有更多数据要传输时，我们使用
    `resp.eof()` 告诉客户端，然后我们就完成了。
- en: This asynchronous behavior of sending data at will does bring up an interesting
    question about the lifecycle of the request. Since we are slightly getting ahead
    of ourselves, if you are interested to see how middleware behaves with streaming
    responses, jump ahead to Chapter 6 now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种随意发送数据的异步行为确实引发了一个关于请求生命周期的有趣问题。由于我们稍微超前了一些，如果你想看看中间件如何处理流式响应，现在就跳转到第6章。
- en: 'As I am sure you can probably imagine from our simple example, by having the
    `resp.send()` method available to us, we now have the freedom to execute asynchronous
    calls as desired. Of course, a silly example to illustrate our point would be
    to add a loop with some time delays:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从我们的简单示例中可能想象到的，由于我们有 `resp.send()` 方法可用，我们现在可以自由地按需执行异步调用。当然，为了说明我们的观点，添加一个带有时间延迟的循环可能是一个愚蠢的例子：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the next section, we will see a more useful and complex example when we
    start sending server sent events (SSE). But first, let’s get back to our goal.
    We wanted to send the actual song. Not just meta data, not just the lyrics: the
    actual music file so we can listen to it through our web application.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到一个更有用且更复杂的示例，当我们开始发送服务器发送事件（SSE）时。但首先，让我们回到我们的目标。我们想要发送实际的歌。不仅仅是元数据，不仅仅是歌词：实际的音频文件，这样我们就可以通过我们的网络应用程序来听它。
- en: File streaming
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件流
- en: The simplest method to do this is with the `file_stream` convenience wrapper.
    This method takes care of all the work for us. It will asynchronously read the
    file contents, send the data in chunks to the client, and wrap up the response.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法是使用 `file_stream` 便利包装器。这个方法为我们处理所有工作。它将异步读取文件内容，以块的形式向客户端发送数据，并封装响应。
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now it is time to open the browser, turn up the volume, hit our webpage, and
    enjoy.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候打开浏览器，调高音量，访问我们的网页，并享受了。
- en: 'Okay, so perhaps relying upon the browser to be our media player is not the
    best UI. What if we want to embed the song content and have an actual player UI
    inside of our frontend? HTML and design is outside the scope of the book, obviously.
    But you can at least get a started using:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以依赖浏览器作为我们的媒体播放器可能不是最好的用户界面。如果我们想在我们的前端嵌入歌曲内容并拥有一个实际的播放器用户界面呢？显然，HTML 和设计超出了本书的范围。但你可以至少使用以下方法开始：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Sanic will default to sending chunks of 4096 bytes with this method. You may
    find it desirable to increase or decrease that number:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 使用此方法默认发送 4096 字节的块。你可能希望增加或减少这个数字：
- en: '[PRE49]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It is also worth mentioning that Sanic does some work under the hood to attempt
    to figure out what kind of file you are sending. This is so that it can properly
    setup the content-type header. If it is unable to figure it out, then it will
    fallback to text/plain. Sanic will look at the file extension and try and match
    it against the operating system’s mime type definitions.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，Sanic 在幕后做一些工作，试图确定你发送的是哪种类型的文件。这样它就可以正确设置内容类型头。如果它无法确定，那么它将回退到 text/plain。Sanic
    将查看文件扩展名，并尝试与操作系统的 MIME 类型定义相匹配。
- en: Server-Sent Events for push communication
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器发送事件用于推送通信
- en: Now that we know that we can control the flow of information from the server,
    we are entering the territory of being able to build some great features for our
    web applications.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们可以控制从服务器来的信息流，我们正在进入能够为我们的网络应用构建一些伟大功能的地盘。
- en: In the old days, when our application wanted to check the state of something,
    it would need to poll the web server by repeatedly sending the same request over
    and over again. We talked about building a music web application. We saw how we
    could display content, get information, and even stream some content to listen
    to music. The next step of course is to make the application social, because we
    of course want to share our music with our friends. We want to add a feature that
    will list out who is online, and the name of the song they are listening to. Refreshing
    the page constantly would work, but is a bad experience. Polling constantly by
    sending the same request over and over again also works, but this eats up resources
    and is also not a great experience.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当我们的应用程序想要检查某物的状态时，它需要通过反复发送相同的请求来轮询网络服务器。我们讨论了构建音乐网络应用程序。我们看到了如何显示内容，获取信息，甚至流式传输一些内容来听音乐。下一步当然是使应用程序变得社交，因为我们当然想与我们的朋友分享我们的音乐。我们希望添加一个功能，可以列出谁在线，以及他们正在听的歌曲的名称。不断刷新页面可以工作，但体验不好。通过反复发送相同的请求不断轮询也行得通，但这会消耗资源，体验也不佳。
- en: 'What would be better is if our server simply notified the browser when someone
    came online or when their music player changes. This is what server-sent events
    (SSE) provides: a super simple set of instructions for our server to send push
    notifications to the browser.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，如果我们的服务器在有人上线或他们的音乐播放器发生变化时简单地通知浏览器，这将是什么样子。这就是服务器发送事件（SSE）提供的：一套非常简单的指令，让我们的服务器向浏览器发送推送通知。
- en: 'The basic unit of the SSE protocol is the *event*, which is a single-line of
    text that contains a field and some body:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: SSE协议的基本单位是*事件*，它是一行文本，包含一个字段和一些正文：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case the field is: `data` and the body is `foo`. A message can consist
    of one or more events separated by a single new line character: `\n`. Here is
    an example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，字段是`data`，正文是`foo`。一条消息可以由一个或多个事件组成，这些事件由单个换行符分隔：`\n`。以下是一个示例：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When a browser receives this message, it will be decoded as: `foo\nbar`. A
    message should be terminated by the server by sending two (2) new line characters:
    `\n\n`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器接收到这条消息时，它将被解码为：`foo\nbar`。服务器应通过发送两个（2）换行符来终止消息：`\n\n`。
- en: 'The SSE protocol has five basic fields:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: SSE协议有五个基本字段：
- en: '| **Field** | **Description** | **Example** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **描述** | **示例** |'
- en: '| `<null>` | Should be treated as a comment | `: This is a comment` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `<null>` | 应被视为注释 | `: 这是一条注释` |'
- en: '| `event` | A description of the type of event being sent | `event: songplaying`
    |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `event` | 发送事件的类型描述 | `event: songplaying` |'
- en: '| `data` | he body of the message, often this is either plain text or JSON
    | `data: All Along the Watchtower` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `data` | 消息的主体，通常是纯文本或JSON | `data: All Along the Watchtower` |'
- en: '| `id` | A self-created event ID for tracking | `id: 123456ABC` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `id` | 用于跟踪的自创建事件ID | `id: 123456ABC` |'
- en: '| `retry` | Reconnection time in milliseconds | `retry: 1000` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `retry` | 重新连接时间（毫秒） | `retry: 1000` |'
- en: Figure 5.2 - Overview of the allowed SSE fields
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 允许的SSE字段概述
- en: Starting with the basics
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从基础知识开始
- en: 'Before diving into how we can implement SSE from Sanic, we need a frontend
    application that can understand how to process these events. We are not too concerned
    about how to build the SSE client. There is a prebuild frontend HTML client that
    you can find in the GitHub repo: … Just grab the code to follow along.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨如何从Sanic实现SSE之前，我们需要一个可以理解如何处理这些事件的前端应用程序。我们不太关心如何构建SSE客户端。你可以在GitHub仓库中找到一个预构建的前端HTML客户端：…只需获取代码来跟随。
- en: 'To deliver the client, we will store that HTML as `index.html` and use the
    existing tools we know to serve that file. To make sure that we cover the blank
    root path (`/`), we will also redirect it to our `index.html`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向客户交付，我们将把该HTML存储为`index.html`，并使用我们已知的现有工具来提供该文件。为了确保我们覆盖空白根路径（`/`），我们还将将其重定向到我们的`index.html`：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now that we have a simple client, let’s build the simple server to go along
    with it:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的客户端，让我们构建一个与之匹配的简单服务器：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Most of this should look familiar. We already saw how we can control the sending
    of chunks to the client, here we are just doing it in a more structured pattern.
    Of course, however, this super simple proof-of-concept is far from a feature complete
    build to be used for our music application. Let’s see how we can make it a bit
    better by creating a mini framework.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容应该看起来很熟悉。我们之前已经看到我们可以如何控制向客户端发送的数据块，这里我们只是以更结构化的模式来做。当然，然而，这个超级简单的概念证明远远不是一个功能完整的构建，可以用于我们的音乐应用。让我们看看我们如何通过创建一个迷你框架来使其变得更好。
- en: Building some SSE objects
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建一些SSE对象
- en: To create our SSE framework, we will start by building some basic objects to
    help in creating our messages. SSE messages are indeed super simple, so perhaps
    this is a bit overkill. On the other hand, making sure we use line breaks and
    field names appropriately sounds like a recipe for disaster. So, a few thoughtful
    steps up front should go a long way for us.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的SSE框架，我们将首先构建一些基本对象来帮助我们创建消息。SSE消息确实非常简单，所以这可能有点过度。另一方面，确保我们适当地使用换行符和字段名听起来像是一场灾难。因此，在开始时采取一些深思熟虑的步骤对我们来说将大有裨益。
- en: 'The first thing we will build are some objects for creating properly formatted
    fields:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将构建一些用于创建正确格式化字段的对象：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Notice how we are starting our inheritance with `str`. This will make our objects
    operate as strings, just with some auto-formatting involved:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何从`str`开始继承的。这将使我们的对象作为字符串操作，只是涉及一些自动格式化：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Moving on, we need a convenient way to compose fields together into a single
    message. It also would need to have proper string formatting, which means the
    additional `\n` at the end:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方便的方式来组合字段，形成一个单一的消息。它还需要有适当的字符串格式化，这意味着在末尾添加额外的`\n`：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, looking at this, we should see a properly formatter SSE message:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看着这个，我们应该看到一个正确格式化的SSE消息：
- en: '[PRE57]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The next step is to try out our new building blocks and see if they send messages
    as expected to the frontend:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是尝试我们的新构建模块，看看它们是否按预期向前端发送消息：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s pause for a moment and recap what it is we are trying to achieve. The
    goal is to send notifications to the browser when a certain event happens. So
    far, we have identified two events: another user logs into (or out of) the system,
    and a user starts (or stops) listening to a song. When one of these events are
    triggered, our stream should broadcast the notification back to the browser. To
    achieve this we will build a pubsub.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，回顾一下我们试图实现的目标。目标是当某个事件发生时向浏览器发送通知。到目前为止，我们已经确定了两个事件：另一个用户登录（或退出）系统，以及用户开始（或停止）听歌。当这些事件之一被触发时，我们的流应该向浏览器广播通知。为了实现这一点，我们将构建一个pubsub。
- en: 'A pubsub is a design paradigm where you have two actors: a publisher and a
    subscriber. It is the job of the publisher to send messages, and the job of the
    subscriber to listen for messages. In our scenario, we want the stream to be the
    subscriber. It will listen for incoming messages, and when it receives one, it
    will know that it should dispatch the SSE.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Pubsub是一种设计范式，其中有两个参与者：发布者和订阅者。发布者的任务是发送消息，订阅者的任务是监听消息。在我们的场景中，我们希望流成为订阅者。它将监听传入的消息，并在收到消息时知道它应该调度SSE。
- en: Since we are still working out exactly how we want our notification system to
    work, we are going to keep it simple. The mechanism for our pubsub will be a simple
    `asyncio.Queue`. Messages can come in, and messages can be consumed. It should
    be noted that this design pattern will be limited. Remember way back at the beginning
    we decided that we were going to run our development server with two workers?
    The reason for doing that was to keep horizontal scaling in mind. What we are
    about to do will absolutely break this, and will not work on a distributed system.
    Therefore, to make this production worthy, we will need a new plan for how to
    distribute messages across a cluster. We will get there later in this book in
    our *Chapter 11* complete example.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍在确定我们的通知系统应该如何工作，我们将保持其简单。我们的pubsub机制将是一个简单的`asyncio.Queue`。消息可以进来，消息也可以被消费。需要注意的是，这种设计模式将是有限的。记得一开始我们决定要使用两个工作进程来运行我们的开发服务器吗？这样做的原因是考虑到水平扩展。我们即将要做的事情将绝对破坏这一点，并且在一个分布式系统中将无法工作。因此，为了使这个系统能够投入生产，我们需要一个新的计划来跨集群分发消息。我们将在本书的*第11章*的完整示例中稍后实现这一点。
- en: 'First, we need to setup a single queue. We will do this with a listener:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要设置一个单独的队列。我们将通过一个监听器来完成这项工作：
- en: '[PRE59]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, when our application starts, anywhere we have access to the application
    instance, we can also access the notification queue.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，当我们的应用程序启动时，无论我们在哪里可以访问应用程序实例，我们也可以访问通知队列。
- en: '**IMPORTANT NOTE**'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we start building more complex applications, we are going to see more usage
    of `ctx` objects. These are convenient locations that Sanic provides for us–the
    developers–to do with as necessary. It is a storage location for “stuff”. Sanic
    almost never makes use of them directly. Therefore, we are free to set any properties
    we want on the object.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我们开始构建更复杂的应用程序时，我们将看到更多`ctx`对象的使用。这些是Sanic为我们——开发者——提供的方便位置，我们可以根据需要对其进行操作。这是一个“东西”的存储位置。Sanic几乎从不直接使用它们。因此，我们可以在这个对象上设置任何我们想要的属性。
- en: 'Next, we will create our subscriber. This instance will listen to the queue,
    and send messages when it finds a message on the queue that has not been dispatched:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的订阅者。这个实例将监听队列，并在找到队列中尚未调度的消息时发送消息：
- en: '[PRE60]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, our `run` operation consists of an infinite loop. Inside of
    that loop the `Notifier` will pause and wait until there is something inside of
    the queue. When there is, it removes the item from the queue and continues through
    the current iteration of the loop, which is to send that item. But, before our
    loop, we are going to send a single heartbeat message. This will flush out any
    startup events so that our client will clear out its own queue. It is not necessary,
    but I think it is a helpful practice to get into.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们的`run`操作由一个无限循环组成。在这个循环内部，`Notifier`将暂停并等待队列中有东西。当有东西时，它会从队列中移除项目并继续循环的当前迭代，即发送该项目。但是，在我们循环之前，我们将发送一个单一的心跳消息。这将清除任何启动事件，以便我们的客户端清除其自己的队列。这不是必需的，但我认为这是一种有用的实践。
- en: 'To implement this in our endpoint, it will look like this:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的端点中实现这一点，看起来是这样的：
- en: '[PRE61]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A response object is created using request.respond. Then, we create the `Notifier`
    and let it run. At the very end, `eof` is called to close out the connection.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`request.respond`创建响应对象。然后，我们创建`Notifier`并让它运行。最后，调用`eof`来关闭连接。
- en: '**IMPORTANT NOTE**'
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To be entirely up-front, the previous code sample is somewhat flawed. I intentionally
    left it simple for the sake of making a point. However, since there is no way
    to break out of the infinite loop, there is really no way the server would ever
    close out the connection itself. This makes the inclusion of `eof` a bit of a
    moot point. It is nice to have there as an example, but this code as written will
    only ever be stopped client side by navigating away from the endpoint.
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 完全坦白地说，之前的代码示例有些缺陷。我故意让它保持简单，以便说明问题。然而，由于没有方法跳出无限循环，服务器实际上根本无法自己关闭连接。这使得包含`eof`变得有些多余。虽然作为一个例子它很好，但按照这样的代码编写，它只会被客户端通过导航离开端点来停止。
- en: 'The easy part should now be pushing messages into the queue. We can do it like
    this on a separate endpoint:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应该很容易将消息推入队列。我们可以在一个单独的端点上这样做：
- en: '[PRE62]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can now test this out! Open your browser and go to: `http://localhost:7777/index.html`You
    should see something like this:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以测试一下！打开你的浏览器，访问：`http://localhost:7777/index.html`你应该会看到类似这样的内容：
- en: '![Figure 5.3 - Screenshot of HTML to test out SSE](img/file5.png)'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图5.3 - 测试SSE的HTML截图](img/file5.png)'
- en: Figure 5.3 - Screenshot of HTML to test out SSE
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图5.3 - 测试SSE的HTML截图
- en: 'Once we “start” the stream by clicking the button, switch back to a terminal
    and we will hit our fake login endpoint:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们通过点击按钮“开始”流，切换回终端，我们将访问我们的假登录端点：
- en: '[PRE63]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Did you see what just happened in the browser? Go ahead and do it again. Feel
    free to play around with this example to get a feel for how the different components
    are working.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你在浏览器中看到了什么？继续做，随意玩这个例子，以了解不同的组件是如何工作的。
- en: Do you think you can build the fake “start playing music” endpoint? Just make
    sure that if you are going to use `Event` that your frontend application knows
    about it by using `eventSource.addEventListener`. Take a look at the `index.html`
    and you will see the `login` event. I suggest you pause and take some time to
    dig into this code to see how the different components are working together to
    facilitate the exchange of data. What kinds of amazing things could you build
    using this?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为你能构建一个假的“开始播放音乐”端点吗？只需确保如果你要使用`Event`，你的前端应用程序通过使用`eventSource.addEventListener`知道它。看看`index.html`，你会看到`login`事件。我建议你暂停一下，花点时间深入研究这段代码，看看不同的组件是如何协同工作以促进数据交换的。你能用这个构建出什么样的奇妙事物？
- en: 'In *Chapter 6,* we will come back to this same example and see another way
    we could achieve it through the use of signals. I should also probably point out
    that using `asyncio.Queue` in this instance has another disadvantage: it will
    really only work in a single browser. Since our consumer (the `Notifier`) drains
    down the queue, what happens when multiple browsers are running simultaneously?
    Well, only the first one gets the message. Again, this solution is much too simplistic
    for real world usage, but hopefully it has gotten the ideas flowing for how you
    could build something more robust. To be entirely transparent, in situations like
    this I really like to fallback to Redis. If you are familiar with Redis, you might
    know that it has a pubsub built into it. With the right Python library interface,
    you can easily solve both the problems the `asyncio.Queue` implementation gave
    us: it can be used to push messages to multiple subscribers at once, and it can
    be used in a distributed system where multiple publishers are pushing into it.
    Maybe before coming to *Chapter 11* you want to see if you can make it work in
    our current example?'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*中，我们将回到这个相同的例子，并看看我们如何通过使用信号来实现它。我还应该指出，在这个例子中使用`asyncio.Queue`还有一个缺点：它实际上只能在单个浏览器中工作。由于我们的消费者（`Notifier`）会清空队列，当多个浏览器同时运行时会发生什么？嗯，只有第一个会收到消息。再次强调，这个解决方案对于实际应用来说过于简单，但希望它已经激发了您如何构建更健壮系统的想法。完全透明地说，在这种情况下，我真的很喜欢回退到Redis。如果你熟悉Redis，你可能知道它内置了pubsub。通过合适的Python库接口，你可以轻松解决`asyncio.Queue`实现给我们带来的两个问题：它可以用来一次性推送消息给多个订阅者，并且可以在分布式系统中使用，其中多个发布者向它推送消息。也许在到达*第11章*之前，你想看看是否能在我们当前的例子中让它工作？
- en: If nothing else, I hope you got excited when you saw the message pop-up in your
    browser. For me, it is still really interesting and fun to see messages being
    pushed into a browser session. SSE are a super simple solution that can solve
    some potentially complex problems, that ultimately lead to a powerful feature
    set. Being able to push data into a web browser truly helps an application feel
    like it is transforming from a web page to a web application.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有其他的话，我希望你在浏览器中看到消息弹出时感到兴奋。对我来说，看到消息被推送到浏览器会话中仍然非常有趣和有趣。SSE是一个超级简单的解决方案，可以解决一些可能很复杂的问题，最终导致强大的功能集。能够将数据推送到网络浏览器确实有助于使应用程序感觉像是从网页转变为网络应用程序。
- en: The downside of this implementation is that they are still only one-sided. To
    get two-way asynchronous communication, we need websockets.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现的缺点是它们仍然只是单向的。要实现双向异步通信，我们需要使用WebSocket。
- en: Websockets for two-way communication
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于双向通信的WebSocket
- en: You have almost definitely experienced websockets on your favorite web applications
    before. They are a tool that helps create a super-rich layer of user experience,
    and can be used in a wide variety of contexts. While SSEs are essentially just
    an open stream that has not yet been terminated, websockets are something different
    completely.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎肯定在你的最爱网络应用程序中体验过WebSocket。这是一个帮助创建超级丰富用户体验的工具，可以在各种环境中使用。虽然SSE本质上只是一个尚未终止的开放流，但WebSocket是完全不同的东西。
- en: Plain vanilla HTTP is just a specification (or protocol) for how messages can
    be formatted and transmitted over a TCP connection between machines. Websockets
    are a separate protocol complete with directions on how messages should be formatted,
    sent, received, etc. The specification for them is really quite involved, and
    we could probably devote an entire book to just discussing websockets. So instead
    we will simply focus on their implementation within Sanic. The one technical detail
    about websockets that worth mentioning is that they begin their life as a normal
    HTTP connection. The request comes in and asks the server for permission to upgrade
    its connection to a websocket. Then, the client and server do a bit of a dance
    together to iron out the details. When the negotiations are all done, we have
    an open socket where messages can be passed back and forth. Think of it as a two-lane
    highway where messages can pass by each other on their way to either end.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的HTTP只是一个规范（或协议），用于描述如何在机器之间的TCP连接上格式化和传输消息。WebSocket是一个独立的协议，其中包含了关于消息应该如何格式化、发送、接收等的详细说明。这个规范相当复杂，我们可能需要用整整一本书来讨论WebSocket。因此，我们将简单地关注Sanic中的实现。关于WebSocket的一个值得注意的技术细节是，它们的生命周期始于一个普通的HTTP连接。请求到来并请求服务器升级其连接为WebSocket。然后，客户端和服务器进行一些互动，以澄清细节。当谈判完成时，我们有一个开放的套接字，可以传递消息。想象它就像是一条双车道的高速公路，消息可以在前往两端的过程中相互通过。
- en: Perhaps the easiest way to conceptualize a websocket is to think of a chat application.
    We have a single endpoint on the backend server. Two separate web browsers connect
    to the server, and each are connected somehow so that when one pushes a message
    in, the server pushes that message out the other side. In this way, both clients
    are able to send and receive messages irrespective of what else is happening.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 想象WebSocket最简单的方法可能是将其视为一个聊天应用程序。我们在后端服务器上有一个单一的端点。两个独立的网络浏览器连接到服务器，并且它们以某种方式连接起来，以便当一个浏览器推送一条消息时，服务器会将该消息推送到另一侧。这样，两个客户端都能够发送和接收消息，而不管其他事情如何。
- en: 'This is true asynchronous web behavior. Sanic uses `async/await` to leverage
    and optimize server efficiency for performance. But, the side benefit is that
    it also allows Sanic to offer an almost effortless mechanism to implementing websockets.
    While we will not get into the details of how this works, you should be aware
    that Sanic makes uses of the Python `websockets` package under the hood. It is
    a fantastic project, and it might be helpful to look at their documentation when
    building your own websocket endpoint in Sanic: [https://websockets.readthedocs.io](https://websockets.readthedocs.io).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真正的异步网络行为。Sanic使用`async/await`来利用和优化服务器效率以实现性能。但，副作用是它还允许Sanic提供一个几乎无需努力的机制来实现WebSocket。虽然我们不会深入探讨它是如何工作的，你应该知道Sanic在底层使用了Python的`websockets`包。这是一个出色的项目，当你在Sanic中构建自己的WebSocket端点时，查看他们的文档可能会有所帮助：[https://websockets.readthedocs.io](https://websockets.readthedocs.io)。
- en: In the last section we started to make our music player application social by
    sharing information about who was logged in. Let’s turn up the social aspect by
    adding in chat. Our goal here is to have two browsers open side by side and be
    able to pass text messages back and forth between them. Just like with the SSE
    example, you can grab the frontend code from the GitHub repository so we do not
    have to worry about those implementation details. [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05/websockets](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05/websockets)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们开始使我们的音乐播放器应用变得社交，通过分享谁已登录的信息。让我们通过添加聊天功能来增强社交性。我们的目标是让两个浏览器并排打开，并能够相互传递文本消息。就像SSE示例一样，您可以从GitHub仓库中获取前端代码，这样我们就不必担心那些实现细节。[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05/websockets](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05/websockets)
- en: 'First thing we are going to create is a `Client`. When someone enters the application,
    the frontend will immediately open the websocket. The `Client` will be a holding
    place for us to be able to keep track of who is in the application, and how we
    can send them messages. Therefore we need a unique identifier, and the callable
    to send messages:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要创建的是一个`Client`。当有人进入应用时，前端会立即打开websocket。`Client`将是我们跟踪谁在应用中，以及如何向他们发送消息的存放地。因此我们需要一个唯一的标识符，以及发送消息的可调用函数：
- en: '[PRE64]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see above, we are going to keep track of the incoming session by
    assigning each client a `UUID`.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们将通过为每个客户端分配一个`UUID`来跟踪进入的会话。
- en: Instantiate this `Client` object inside of the `websocket` handler.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`websocket`处理程序内部实例化这个`Client`对象。
- en: '[PRE65]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, we need to create our `ChatRoom`. This will be a global instance that
    exists during the lifetime of the application. Its role will be to keep track
    of all of the clients that have entered or exited. When someone tries to send
    a message, it will be responsible for publishing that message to the rest of the
    clients. Just like with our SSE example, the implementation I am about to show
    you is limited in that it cannot be run across a distributed cluster. It will
    function great on just a single instance. This is because we are registering the
    clients on a single instance in memory. To build a more scalable application to
    be used in a production environment, we should use something like Redis or RabbitMQ
    to distribute the message across multiple Sanic instances. For now, this will
    do:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的`ChatRoom`。这将是一个在整个应用生命周期中存在的全局实例。它的作用是跟踪所有进入或离开的客户端。当有人尝试发送消息时，它将负责将消息发布给其他客户端。就像我们的SSE示例一样，我即将展示的实现是有限的，因为它不能在分布式集群上运行。它将在单个实例上运行得很好。这是因为我们在内存中的单个实例上注册了客户端。为了构建一个更可扩展的应用程序，用于生产环境，我们应该使用类似Redis或RabbitMQ的东西来在多个Sanic实例之间分发消息。现在，这就可以了：
- en: '[PRE66]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There is a mechanism to add and remove clients, and a method to push events
    to registered clients. One thing that is important to point out here is that we
    do not want to send the message back to the person that sent it. That would be
    a little bit awkward and a bit annoying for the user to constantly have their
    own messages fed back to them. Therefore, we will filter out the sending client.
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存在一种机制可以添加和删除客户端，以及一种方法可以向已注册的客户端推送事件。在这里需要指出的一点是，我们不希望将消息发送回发送者。那会显得有些尴尬，并且对用户来说，不断收到自己的消息会有些烦恼。因此，我们将过滤掉发送客户端。
- en: Remember, the `ChatRoom` instance is a single object lives for the lifetime
    of the application instance. So, where do you think it should be instantiated?
    That’s right, a listener!
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住，`ChatRoom`实例是一个在整个应用实例生命周期中存在的单一对象。那么，你认为它应该在何处实例化呢？没错，一个监听器！
- en: '[PRE67]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now all we need to do is wire it up!
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要将其连接起来！
- en: '[PRE68]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When the user enters, we add them to the chatroom. Then it enters and infinite
    loop and waits for a message to be received. This is very similar in concept to
    the SSE implementation we saw in the last section. When a message is received
    on the current websocket, it is passed to the `ChatRoom` object that is responsible
    for sending it to all of the other registered clients. Seems too easy, right?!
    Now to test it out. Open two browsers side by side, and start adding messages.
    Have fun chatting with yourself!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进入时，我们将他们添加到聊天室。然后它进入一个无限循环并等待接收消息。这与我们在上一节中看到的SSE实现非常相似。当当前websocket收到消息时，它会被传递给负责将其发送给所有已注册客户端的`ChatRoom`对象。看起来太简单了，对吧？！现在来测试一下。打开两个并排的浏览器，并开始添加消息。享受和自己聊天的乐趣！
- en: '![Figure 5.4 - Screenshot of two side-by-side HTML websocket-enabled applications:
    me talking to myself](img/file6.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 - 两个并排的HTML websocket应用程序的截图：我在和自己说话](img/file6.png)'
- en: 'Figure 5.4 - Screenshot of two side-by-side HTML websocket-enabled applications:
    me talking to myself'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 两个并排的HTML websocket应用程序的截图：我在和自己说话
- en: 'The code that you need to run the above websocket HTML application (and the
    backend chatroom code we just looked at) is available on GitHub: _____.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述websocket HTML应用程序（以及我们刚刚查看的后端聊天室代码）所需的代码可在GitHub上找到：______。
- en: Setting Response Headers and Cookies
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置响应头部和Cookies
- en: We have talked a lot about headers. They are super important when building web
    applications and are generally a fundamental part of application design. When
    building your application responses, you will likely find reasons to add handlers
    to your response objects. This could be for security purposes like CORS headers
    or a Content-Security-Policy, or for informational and tracking purposes. And,
    of course there are cookies, which are their own special kind of headers that
    receive special treatment in Sanic.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了很多关于头部的内容。在构建Web应用程序时，它们非常重要，通常是应用程序设计的基本部分。当构建您的应用程序响应时，您可能会找到添加处理程序到响应对象的原因。这可能出于安全目的，如CORS头部或内容安全策略，或者出于信息跟踪目的。当然，还有cookies，它们是它们自己的特殊类型的头部，在Sanic中会得到特殊处理。
- en: 'You may have noticed back in some earlier examples (like the SSE example) where
    we actually set the headers. It is such an easy and intuitive process, perhaps
    you did not even notice. Whenever we build a response object, all we need to do
    is pass a dictionary with key/value pairs:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在早期的一些示例（如SSE示例）中，我们实际上设置了头部。这是一个如此简单直观的过程，也许您甚至没有注意到。每次我们构建一个响应对象时，我们只需要传递一个包含键/值对的字典：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'That’s really all there is to it! Keep in mind you will not be required to
    set your own headers all the time. Sanic takes care of some of them for you, including:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容！请记住，您并不总是需要设置自己的头部。Sanic为您处理了一些，包括：
- en: '`content-length`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content-length`'
- en: '`content-type`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content-type`'
- en: '`connection`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connection`'
- en: '`transfer-encoding`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transfer-encoding`'
- en: Responding with a request ID
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用请求ID进行响应
- en: One pattern that is particularly helpful is to set an `x-request-id` header
    on every response. If then make a habit of using `request.id` in logging or tracing
    a request through your application, it becomes easier to track what is happening
    when you inevitability need to debug something.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有帮助的模式是在每个响应上设置一个`x-request-id`头部。如果习惯于在日志记录或通过应用程序跟踪请求时使用`request.id`，那么在不可避免地需要调试某些内容时，跟踪发生的事情会变得更容易。
- en: 'We want to make sure our response includes the header:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确保我们的响应包括以下头部：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: That is the simple example. As you have probably come to realize by now, that
    simple example might get tedious if we want to do it on all of our requests. Do
    you want to try to come up with a solution for adding that to all responses? Decorators
    and middleware are again potential tools. We will come back to this and you will
    see some implementations for setting this globally in the full example in *Chapter
    11*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子。您可能已经意识到，如果我们想在所有请求上都这样做，这个简单的例子可能会变得乏味。您想要尝试为所有响应添加这个解决方案吗？装饰器和中间件又是潜在的工具。我们将回到这个问题，您将在第11章的完整示例中看到一些全局设置此头部的实现。
- en: To truly make this useful, we should setup our logging to include the request
    ID. We have not talked too much about it yet, but Sanic includes a default logger
    for you to use. It may be helpful for you to piggyback onto it, but to override
    the default logging format to include that request ID. If you want to know more
    about how to set this up, jump ahead to *Chapter 6*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正使这有用，我们应该设置我们的日志记录以包括请求 ID。我们还没有过多地谈论它，但 Sanic 为你提供了一个默认的日志记录器。你可能需要在其基础上进行扩展，但为了覆盖默认的日志格式以包括那个请求
    ID。如果你想了解更多关于如何设置它的信息，请跳转到 *第 6 章*。
- en: Setting response cookies
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置响应 cookie
- en: One of the most important types of headers you can set on an individual response
    would be the cookie headers. Since they are so prominent, and they could include
    a bit of complexity to set them up, you can avoid having to use `Set-Cookie` directly.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在单个响应上设置的最重要类型之一就是 cookie 标头。由于它们非常突出，并且设置它们可能包含一些复杂性，你可以避免直接使用 `Set-Cookie`。
- en: Response cookies are basically a key/value pair that gets concatenated into
    a single string in the response, but then interpreted by the browser. It is yet
    another shared language in the conversation of the web. So, while a single cookie
    could be as simple as `flavor=chocolatechip`, that shared language allows us to
    set a whole bunch of meta data on top of the simple example.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 响应 cookie 实际上是一个键/值对，它在响应中被连接成一个字符串，然后由浏览器解释。这是网络对话中的另一种共享语言。因此，虽然单个 cookie
    可能像 `flavor=chocolatechip` 这样简单，但这种共享语言允许我们在简单示例之上设置大量的元数据。
- en: 'Before we get to the meta data, let’s look at the simple example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入元数据之前，让我们看看一个简单的例子：
- en: '[PRE71]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Seems fairly straightforward. Let’s see what it does to our response:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当直接。让我们看看它对我们的响应做了什么：
- en: '[PRE72]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Our response headers now have: `Set-Cookie: flavor=chocolatechip; Path=/.`
    So, what’s the deal with that `Path`? That is the cookie meta data at play. Here
    are some of the various meta values that we can add:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在的响应头有：`Set-Cookie: flavor=chocolatechip; Path=/.` 那么，那个 `Path` 是怎么回事？这是
    cookie 元数据在起作用。以下是我们可以添加的一些各种元值：'
- en: '| `expires: datetime` | The time at which a browser should discard the cookie
    |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `expires: datetime` | 浏览器应在何时丢弃 cookie |'
- en: '| `path: str` | The path in which the cookie will be applied |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `path: str` | cookie 将应用到的路径 |'
- en: '| `comment: str` | Comment |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `comment: str` | 注释 |'
- en: '| `domain: str` | The domain in which the cookie will be applied |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `domain: str` | cookie 将应用到的域名 |'
- en: '| `max-age: str` | Number of seconds before a browser should discard the cookie
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `max-age: str` | 浏览器应在多少秒后将 cookie 丢弃 |'
- en: '| `secure: bool` | Whether it should only be sent over HTTPS |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `secure: bool` | 是否应该仅通过 HTTPS 发送 |'
- en: '| `httponly: bool` | Whether it can be accessed by Javascript |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `httponly: bool` | 是否可以被 JavaScript 访问 |'
- en: '| `samesite: str` | Where it can be sent from, values can be: lax, strict,
    none |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `samesite: str` | 它可以从哪里发送，值可以是：lax、strict、none |'
- en: Table 5.2 - Cookie meta-fields
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.2 - Cookie 元字段
- en: 'When we setup our `flavor` cookie, it seemed like we were just adding a string
    value to a dictionary that looked like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设置我们的 `flavor` cookie 时，它看起来就像我们只是在看起来像这样的字典中添加一个字符串值：
- en: '[PRE73]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: That is not really the case. The `response.cookies` object is in fact a `CookieJar`
    object, which is itself a special kind of `dict`. When we setup a new key/value
    on that `CookieJar`, it is in fact creating a `Cookie` object. Huh?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是真的情况。`response.cookies` 对象实际上是一个 `CookieJar` 对象，它本身是一种特殊的 `dict` 类型。当我们在这个
    `CookieJar` 上设置新的键/值时，实际上是在创建一个 `Cookie` 对象。嗯？
- en: 'When we do this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时：
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: It is more like you are creating a `Cookie("flavor", "chocolatechip")`, and
    then putting it into a `CookieJar()`. To cleanup some of the complexity involved
    with managing these instances, Sanic let’s us just work with strings. We should
    keep this in mind when we go to set the meta data, which is what we will do next.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是你正在创建一个 `Cookie("flavor", "chocolatechip")`，然后将其放入 `CookieJar()` 中。为了清理与这些实例管理相关的复杂性，Sanic
    允许我们仅使用字符串。当我们设置元数据时，我们应该记住这一点，这就是我们接下来要做的。
- en: Let’s imagine we have a cookie that should timeout. After some period of time,
    we want the browser session to forget it existed. This might–for example–be useful
    with a session cookie. We set some value that identifies a browser session with
    a particular user. Storing it in a cookie means that on subsequent requests we
    can identify who the person is. However, by setting a max-age, we can control
    the length of time that person can use the application before they need to login
    again.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们有一个应该超时的cookie。经过一段时间后，我们希望浏览器会话忘记它的存在。例如，这对于会话cookie可能很有用。我们设置一些值来标识与特定用户的浏览器会话。将其存储在cookie中意味着在后续请求中我们可以识别出这个人是谁。然而，通过设置最大存活时间，我们可以控制这个人在需要再次登录之前可以使用应用程序的时间长度。
- en: '[PRE75]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The same applies for all the other meta fields:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于所有其他元字段：
- en: '[PRE76]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If we put this all together, our cookie headers will ultimately look like this:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些结合起来，我们的cookie头部最终将看起来像这样：
- en: '[PRE77]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The last thing we should look at is how we should delete cookies. When you want
    to remove a cookie, it is tempting to just use del like you might with any other
    dictionary object. The problem is this only works so far. Usually, what you want
    to do instead is tell the browser that it needs to remove the cookie so that the
    browser does not send it back in future requests. The easiest method to accomplish
    this is by setting the max-age of the cookie to 0.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后应该考虑的是如何删除cookies。当你想要删除一个cookie时，可能会倾向于像对待任何其他字典对象一样使用del。问题是这只能做到这一步。通常，你想要做的是告诉浏览器它需要删除cookie，这样浏览器就不会在未来的请求中发送它。实现这一点的最简单方法是将cookie的最大存活时间设置为0。
- en: '[PRE78]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You should now feel comfortable adding and deleting cookies to responses. It
    might be a good opportunity to create a response handler and use your browser’s
    cookie inspection tools to see how cookies can be set, manipulated, and deleted
    from your server.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该感到舒适地添加和删除响应中的cookies。这可能是一个创建响应处理器并使用浏览器cookie检查工具查看如何从服务器设置、操作和删除cookies的好机会。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we have seen how to manipulate both the request and the response, it
    is entirely possible for us to build some really powerful applications. Whether
    we are building an HTML-based website, a JSON powered web API, a streaming content
    application, or some combination of them all, Sanic provides us with the tools
    we need.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何操作请求和响应，我们完全有可能构建一些真正强大的应用程序。无论是构建基于HTML的网站、由JSON驱动的Web API、流媒体内容应用程序，还是它们的组合，Sanic都为我们提供了所需的工具。
- en: One of the first things we discussed is that Sanic tries hard to not obstruct
    the build of an application. We as the developers have the freedom to build with
    different tools, and layer them together to build a truly unique platform. This
    is very much prevalent when we realize the freedom given to the developer with
    the response object. Need to write bytes directly? Sure. Want to use a specific
    templating engine? Not a problem.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论的第一件事是Sanic努力不阻碍应用程序的构建。作为开发者，我们有自由使用不同的工具，并将它们组合起来构建一个真正独特的平台。当我们意识到开发者获得的响应对象所赋予的自由时，这一点尤为明显。需要直接写入字节？当然可以。想要使用特定的模板引擎？没问题。
- en: Now that we have the basic understanding on how to handle the lifecycle of an
    HTTP connection from request through to response, we can start to see what else
    we have at our disposal. In the next chapter we will take a deeper dive into some
    of the concepts already introduced like middleware, background tasks, and signals.
    Combining these basic building blocks will help us build not only a powerful application,
    but also one that is easy to maintain, update, and expand.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何处理HTTP连接的生命周期有了基本理解，从请求到响应，我们可以开始看到我们还有哪些可以利用的资源。在下一章中，我们将更深入地探讨一些已经介绍的概念，如中间件、后台任务和信号。结合这些基本构建块将帮助我们构建不仅功能强大，而且易于维护、更新和扩展的应用程序。
