- en: 5 Handling and Responding Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, our applications have largely been reactive. We worked
    on different parts of web applications to learn about how to manage the incoming
    HTTP request. If we imagine the HTTP request/response cycle as a conversation,
    up until this point, we have been only listening. Our applications have been built
    to hear what the incoming client has to say.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is our turn to talk. In this Chapter, we begin to explore different
    facets of the HTTP response. Just as we began our learning of the HTTP request
    by looking at a raw request object, we will look at the raw response. It looks
    nearly identical, and at this point should be familiar. We go on to explore some
    of the powerful tools Sanic has to offer. Of course, there are mechanisms for
    JSON and HTML responses, which are probably the most popular types of content
    to be delivered on the Web today. Sanic, however, has an advantage by being an
    async framework: it is super easy to implement server driven responses like: websockets,
    server-sent events (SSE), and streaming responses. We will explore these in this
    chapter as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the HTTP response structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering HTML content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing JSON content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-Sent Events for push communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Websockets for two-way communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting response headers and cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of our examples are going to start getting a little longer than what we
    have previously seen. For the sake of convenience, you may want to keep the GitHub
    repository handy as you read through this chapter: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05.](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05.)'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the HTTP response structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in *Chapter 3, Routing and intaking HTTP requests*, we looked at the structure
    of the HTTP request. When a web server is ready to send back a response, the format
    is very similar to what we already saw. The HTTP response will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What we see is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First line containing HTTP protocol used, a status code, and a status description
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Response headers in `key: value` format and separated by a line break'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A blank row
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Response body
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are looking at this here not because it is something we must know to build
    a web application. After all, building these response objects to a valid HTTP
    specification is precisely one of the reasons that we use web frameworks. Without
    them, building these blobs would be tedious and error prone. Instead, it is helpful
    for us to review and understand what is happening so that we can increase our
    grasp of HTTP and web application development.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the structure is duplicative of what we have already learned.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP response status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you compare the HTTP request and response objects, perhaps the most identifying
    difference is the first line. Whereas the request first line had three distinct
    parts, it is easier to think of the response as having only two: the HTTP protocol
    in use, and the response status. We discussed the HTTP protocol earlier in this
    book, for example see *Chapter 3*, *Routing and intaking HTTP requests*, so we
    will skip it here and focus on the response status. The response status is meant
    to be both a computer-friendly and human-friendly tool to let the client know
    what happened to the request. Did it succeed? Was the request wrong? Did the server
    make a mistake? These questions, and more, are answered by the HTTP response status.'
  prefs: []
  type: TYPE_NORMAL
- en: Likely you have a basic understanding of different response codes if you have
    built a website in the past. Even people who have never built an application have
    surely at some time landed on a web page that said **404 Not Found** or **500
    Internal Server Error**. These are response statuses. HTTP response statuses consist
    of a number, and a description. The meanings of these numbers and the specific
    descriptions associated with them are defined in *RFC 7231 § 6*. [https://datatracker.ietf.org/doc/html/rfc7231#section-6.](https://datatracker.ietf.org/doc/html/rfc7231#section-6.)
  prefs: []
  type: TYPE_NORMAL
- en: To clarify, if you see the term *response status*, *status code*, or *response
    code*, they are all describing the same thing. I generally prefer to use *response
    status* to describe the general concept, and *status code* when talking about
    the numeric value of the status. However, they are fairly interchangeable, and
    this book uses the terms interchangeably as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three most common statuses are:'
  prefs: []
  type: TYPE_NORMAL
- en: 200 OK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 404 Not Found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 Internal Server Error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, Sanic will attempt to respond with the most appropriate status.
    If there is an error, you will likely get a `500`. If the path does not exist,
    it will be a `404`. And, if the server can respond properly, Sanic uses `200`.
    Let’s dig a little deeper to see how the statuses are organized.
  prefs: []
  type: TYPE_NORMAL
- en: Response groupings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The standard responses are grouped in series of 100s as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**100s**: *Informational* - provisional responses with information about how
    the client should proceed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**200s**: *Successful* - responses that indicate the request was processed
    as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**300s**: *Redirection* - responses that indicate the client must take further
    action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**400s**: *Client error* - responses where it appears the client made a mistake
    in trying to access or proceed with some resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**500s**: *Server error* - responses where the server made a mistake and a
    response as expected could not be generated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beyond the big three, there are some other important responses you should be
    familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** | **Use case** |'
  prefs: []
  type: TYPE_TB
- en: '| `201` | Created | Endpoint successfully created a new resource; often the
    response will include the new data and/or an ID that can be used to look it up
    |'
  prefs: []
  type: TYPE_TB
- en: '| `202` | Accepted | The application has taken the request and pushed it to
    a queue or background process for further operation |'
  prefs: []
  type: TYPE_TB
- en: '| `204` | No Content | There is no body; typical on an OPTIONS request |'
  prefs: []
  type: TYPE_TB
- en: '| `301` | Moved Permanently | The target resource is now located at a new permanent
    URI |'
  prefs: []
  type: TYPE_TB
- en: '| `302` | Found | The target resource is temporarily located at a different
    URI |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | Bad Request | The server is refusing to respond to the request because
    of something improper by the client |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | Unauthorized | The request lacks valid authentication credentials
    to be allowed access |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | Forbidden | The request is authenticated, but the server does not
    recognize valid authorization to proceed with the response |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Common status codes
  prefs: []
  type: TYPE_NORMAL
- en: Response through exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of Sanic’s built-in exceptions are associated with a specific status code.
    This means that we can raise an exception and Sanic will automatically catch that
    exception and provide an appropriate response with the proper status code. This
    makes it super convenient, and simple to respond.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s imagine that we are building a music player application.
    One of our endpoints allows users that are logged in to see their playlist. However,
    it is protected behind authentication and only users that the playlist has been
    shared with are able to access it. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By raising `NotFound`, Sanic will automatically know that it should return
    a `404 Not Found` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We also could extend this concept with our own custom exception handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, by subclassing `SanicException` we can associate the exception
    with a status code. We also set a class property: `quiet=True`. This is not necessary,
    but may be desirable. What it means is that the exception and its traceback (the
    details about the type and location of an exception) will not appear in your logging.
    This is a particular feature to `SanicException`. It is helpful for exceptions
    that may be expected (but otherwise uncaught) in the regular course of your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as we saw with HTTP methods, it is possible to make-up your own status
    codes as long as they have three digits. I am not suggesting this is a *good*
    idea, merely pointing out that it is possible and Sanic will let you do it, even
    though you probably should not. Creating your own status codes might confuse browsers
    or clients that are using your application. Throwing caution to the wind, we will
    try it anyway just to see that Sanic allows us to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new status type to an otherwise “private” variable (remember, its just
    Python so we can hack it if we want):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Nice. Now let’s see what happens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the HTTP return making sure to use `-i` so we see the raw response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To wrap up, here is a fun little experiment, and a quirk of the HTTP spec.
    Enter this route into your application:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, query it using `curl` so you can see the response (don’t forget the `-i`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second part of the HTTP response is the same as the second part of the
    HTTP request: headers arranged one per line in a `key: value` format. Like before,
    the keys are case insensitive, and can be repeated more than once in the response.'
  prefs: []
  type: TYPE_NORMAL
- en: One interesting thing to keep in mind is that when a webserver responds with
    an informational status (series 100), it does *not* include headers. These responses
    are generally used only in the context of *upgrading* an HTTP connection to a
    websocket connection. Since this is a responsibility of the framework, we can
    safely ignore this, and just file it away as good information to have.
  prefs: []
  type: TYPE_NORMAL
- en: Headers are generally pretty simple to use in Sanic. We will dig into them a
    little bit later on, but for now we need to keep in mind that we can simply pass
    a dictionary with values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `headers` argument with a dictionary of values into any response function.
    Here we use `empty` because we are not sending any body response, just the headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s see what the response looks like using curl, and making sure to use -i
    so that we see the headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The astute mathematician looking at my example will notice that I got it only
    partially correct. Two is not the only value. How can we have duplicate header
    keys? Since Python regular dictionaries will not allow us to duplicate keys, we
    can use a special data type that Sanic offers us to do the job.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using the same response as before, insert a `Header` object with two of the
    same keys as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We hopefully will now see our more mathematically correct response headers;
    the same key twice, but each time with a different value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Response Body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last part of the HTTP response is the body. It is arguably the most important
    part of this whole business we call HTTP. We can realistically state that the
    HTTP response body is what the whole driving force of the web is after: the sharing
    of content. The remainder of this chapter will focus on some of the different
    and more popular ways that we can structure data in the HTTP response body. Whether
    it is HTML, JSON, or raw bytes, what we are about to dive into will be part of
    the cornerstone of every web application you build. First up is HTML content where
    we will explore methodologies for sending both static HTML content and generating
    dynamic HTML content.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering HTML content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The foundation of the Web is HTML. It is the media that enables browsers to
    function, and therefore it is fundamental that a web server must be capable of
    delivering HTML content. Whether building a traditional page-based application,
    or a single-page application, HTML delivery will be necessary. In *Chapter 3*,
    *Routing and Intaking HTTP Requests*, we discussed how we could route web requests
    to our static files. If you have static HTML files, then this is a great option.
    But, what if you need to generate dynamic HTML for your application?
  prefs: []
  type: TYPE_NORMAL
- en: Since there are multitudes of ways that this could be accomplished, we will
    take a look at some of the general patterns that could be used with Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: Delivering HTML files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Serving HTML content is generally a simple operation. We need to send back
    a response to the client with HTML text and a header that tells the recipient
    that the document should be treated as HTML. Ultimately, the raw HTTP response
    is going to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Quick side note, while the preceding example may be valid HTML, not all the
    following examples will be. Getting 100% HTML semantics is not the aim of this
    book, so we might break a few rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine now that we are building a music player application. The first
    thing that needs to happen when someone lands on our website is to login. If that
    person already has an active session, we want them to go to the **What’s new**
    page. In Chapter 6 and 7 we will look at how to use middleware and integrate it
    with authentication. For now, we will assume our application has already determined
    authentication and authorization. It has stored those values as `request.ctx.user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Have you noticed a pattern so far? All we really need to do to generate HTML
    content with Sanic is basic string building! So, if we can inject values into
    a string with string interpolation, then we have dynamic HTML. Here’s a simple
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using `curl`, let’s see what it looks like in a browser this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 - Browser screenshot of interpolated HTML](img/file4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 - Browser screenshot of interpolated HTML
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation of HTML is just a fancy way of saying templating.
  prefs: []
  type: TYPE_NORMAL
- en: Basic templating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the past, I have presented at a couple Python web conferences. While preparing
    my talks I looked for tools that would make it super simple to generate a slide
    presentation. Since I am most comfortable working in my text editor, I was particularly
    interested in solutions that would translate markdown to slides. I found a tool
    called `remark.js`. If you want to learn more about remark: [https://remarkjs.com/.](https://remarkjs.com/.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to render slides from markdown, all I needed was an HTML file and
    some markdown text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This was super simple and exactly what I was looking for. However, there was
    a problem because my IDE did not know the text inside the `<textarea>` was markdown.
    Therefore, I had no syntax highlighting. Bummer.
  prefs: []
  type: TYPE_NORMAL
- en: The solution was quite simple really. I just needed a way to inject my markdown
    into the HTML file and serve that.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick fix to the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Voila! An HTML template. Now, let’s *render* it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Just like that, we built a templating engine. The basic idea of any templating
    engine is that there is some protocol for telling the application how to convert
    and inject dynamic content. Python does this with its multiple forms of string
    interpolations. In my super simple solution engine, all I needed to do was replace
    the `__SLIDES__` value. I am sure you can start to formulate ideas on how you
    could build your own simple engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, maybe you should try that now. Here is a HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It is your turn now to fill in the rest by building the rendering agent. Try
    to build a `render` function to work with *any* variable names, not just `name`
    and `age`. We want this to be reusable in more than just one location.
  prefs: []
  type: TYPE_NORMAL
- en: Using a templating engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, you do not need to always make your own templating engine. There
    are many great choices already built. Popular template engines in Python are Genshi,
    Mako, and Jinja2\. But remember, all we really need to do is build a string. So
    any tools that you have that can do this will work. These packages can be thought
    of as fancy versions of the Python format function. They take strings and inject
    data into them to generate a bigger string. Any Python templating tool that you
    pick up will work with Sanic. Specifically regarding Jinja2, there are some Sanic
    plugins already out there that make interactions between Sanic and Jinja2 super
    simple. Feel free to check them out on your own time. On the basic level, templating
    with Jinja2 can be as lightweight as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And now to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To move our templates out of Python and into their own HTML files, we can use
    Jinja2’s `Environment` construct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create some HTML using Jinja2 syntax. This will be saved as `index.html` in
    a `templates` directory. You can see the structure used in the GitHub repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now setup the `Environment` and attach it to our application context so that
    it is easily available throughout our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, grab the template by filename in our route handler, and inject some
    content into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that all done, we should be able to visit our application in a web browser
    and see the rendered HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When building with Sanic, you may have noticed how handy it is to have `auto_reload`
    enabled. Every time you hit the save button, the application restarts and is available
    for you to test immediately. Wouldn’t it be great if the same were true when building
    HTML files? There is a tool that does this called **livereload**. Essentially
    it injects some Javascript into your HTML to make it listen to commands to refresh
    the page. When building that slide presentation I talked about earlier, I made
    a livereload server so that I could keep the browser open side-by-side with my
    IDE while I typed. Every time I hit **Save**, my browser refreshed, and I could
    see the rendered content without having to lift my fingers off the keyboard. If
    you are interested in more detail on this topic, checkout *Chapter 11*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Serializing JSON content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next to HTML content, JSON is one of the most common forms of data transferred
    on the web. If you are building a **single-page application** (**SPA**),( also
    known as a **progressive web application** or **PWA**), likely your backend server
    *only* or *mostly* returns JSON content. A common build pattern for a modern web
    application is to build a frontend user-interface with a Javascript framework
    powered by a backend server that feeds the frontend with dynamic JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing on a serializer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python standard library, of course, ships with a JSON package that makes
    serializing Python objects to JSON strings (and the reverse) very simple. However,
    it is not the most performant implementation. In fact, it is quite slow. Many
    third-party packages have popped up to attempt to fix this problem. We will explore
    two of the common packages often used with Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: 'When talking about response serialization, what we care about is the operation
    of the `dumps()` method. Each of these projects provides an interface with this
    method. To select a serializer, what we need to do is to set the dumps() method
    in one of two locations: at the response level, or application wide. We will see
    how to do both shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: UJSON
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**UltraJSON** (aka **ujson**) is an alternative JSON implementation that is
    written in C. Because of its emphasis on performance, it was adopted as the default
    JSON tool for Sanic. If you do nothing else, this is the package that Sanic will
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It includes some helpful encoder options such as: `encode_html_chars`, `ensure_ascii`,
    and `escape_forward_slashes`. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When we access this endpoint, `ujson` will by default escape our slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can use `functools.partial` to change the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `dumps` keyword argument, we have told Sanic to use a different
    serializer. The result should be what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not want to use ujson in your projects, then you can force Sanic
    to skip installation of ujson:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While ujson is a great project that adds some much needed performance to JSON
    string manipulation in Python, it *might* not actually be the fastest. Next, we
    will look at another relatively new package that attempts to bring performance
    to JSON manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: ORJSON
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A newer player to the game is orjson. It is written in Rust and claims to be
    the fastest alternative according to benchmarks. For this reason, many people
    like to swap out ujson for orjson.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing to note about orjson is that it has built-in support for
    serializing common Python objects like `datetime.datetime` and `uuid.UUID`. Since
    these are both very common when building web applications, it is super convenient
    to not have to think about how to handle these object types. It also should be
    noted that whereas the standard library and ujson return a `str` value, orjson
    returns a `bytes` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily tell Sanic to use orjson everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Serializing custom objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last two sections, you may have noticed there are two ways to override
    the default dumps method. The first is by changing a single response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The second, will apply to all routes globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to mix and match both the handler-specific method, and the application-wide
    method to meet your application needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We quickly looked at two alternative packages. There are of course others.
    So how should you decide which package to use? When deciding on an implementation,
    often one of the biggest considerations is how to handle custom non-scalar objects.
    That is to say, how do we want objects that do not have an obvious and built-in
    mapping to JSON types (like strings, integers, floats, booleans, lists, and dictionaries)
    to behave when rendered to JSON. To make this point clear, consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a Thing.It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If we do nothing, serializing a `Thing` object is not so straightforward, and
    JSON tools usually will throw an error because they do not know what to do with
    it. Without resorting to manual intervention, we can rely upon each of the tools’
    methodology to explicitly provide instructions when coming across a `Thing` object.
    We will consider each alternative to see how we can reduce `Thing` to a JSON accessible
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps, the most simple is `ujson`. Besides its performance, this happens
    to be one of my favorite features. If an object has a `__json__` method, ujson
    will call it when converting the object to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Because of this functionality, when I am working on a project one of the things
    I often do is identify some base models for my objects and include a `__json__`
    method. But what about the other tools?
  prefs: []
  type: TYPE_NORMAL
- en: 'Orjson allows us to pass a `default function` to the serializer. If it does
    not know how to render an object, it will call this. While ujson opts to handle
    this on the object/model, orjson opts to handle it in each individual serializer.
    The sky is really the limit to the complexity you want to add. Since I am a fan
    of using `__json__` methods on my custom objects, we can achieve the same functionality
    with orjson like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This might get a bit repetitive if you are constantly redefining the serializer
    method in response handlers. Instead, maybe it is worth it to use the standard
    library to help. We can create a partial function with the `default` argument
    already populated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The most cumbersome implementation is the standard library that requires you
    to pass it a custom encoder class. It is very similar to the orjson method, albeit
    with a little more boilerplate needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Seeing the above example, you should now be able to add the `__json__` approach
    to the `CustomEncoder`.
  prefs: []
  type: TYPE_NORMAL
- en: No matter the project, you are very likely to come up against this issue. Having
    a standard and consistent way to handle non-scalar objects is important. Assess
    how you plan to build and look for meaningful patterns. I generally find this
    to be more of an important decision than raw performance. The incremental performance
    changes from one package to the next are likely not going to be as impactful as
    making a decision based upon how your application will be built and maintained.
    For example, what if you need to render an integer that is larger than 64 bits?
    Both ujson and orjson have a limitation where they will raise exceptions and not
    be capable of handling your data. The standard library implementation, however
    does have this capacity. As we stated back in the beginning, make the right decisions
    that are the most obvious to your needs. But, let’s turn to some common practices
    and see what we might be able to learn from.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are a number of common practices for what *typical* JSON responses look
    like. Of course, the content and your organization is something that will be determined
    by your application’s needs. But, there is one common question you will find often
    discussed on developer forums: “*How should I format an array of objects?*”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to our earlier example, let’s imagine we are still building our
    music app. We now want to build an endpoint that lists out all of the available
    songs. Each individual song “object” will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'How should we organize an array of songs? There are two schools of thought:
    only use top level objects, use whatever structure fits your data best. What we
    are talking about is the difference between:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Why is there even a debate? And, why do some people strictly only use top level
    objects? There was a JSON security flaw in browsers uncovered in 2006 that would
    allow attackers to execute code based upon the second option, the top-level JSON
    array. For this reason, many people suggested that using the first structure was
    more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is no longer a concern since the impacted browsers are long out
    of date, I still like the top-level object pattern. It still provides one critical
    benefit over the second option: flexibility without compromising on compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: If our array of objects is nested inside of a top-level object, then we can
    easily modify our endpoints in the future to add new keys to the top-level without
    impacting anyone using that endpoint. One pattern that I like to include is to
    have a `meta` object that includes some of the details of the query, and contains
    pagination information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, I suggest that when given the choice, you nest your objects like
    this. Some people also like to nest single objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The argument goes that the same principle applies. The endpoint is more easily
    extensible if the objects are nested. However, this argument seems less convincing
    and practical when dealing with single objects. Generally, any change in the endpoint
    would be related to the object itself. So, perhaps this is a use-case for versioning,
    which we explored in Chapter 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter your decision on how to structure the data, sending information about
    our songs in JSON format is still just a structural decision that will be dictated
    by the constraints of the application being built. Now we want to move onto the
    next step: actually sending the song itself. Let’s see how we can do that next.'
  prefs: []
  type: TYPE_NORMAL
- en: Streaming data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When introducing the concept of streaming in *Chapter 4*, I said that request
    streaming was probably the less popular of the two types. I do not have any empirical
    data to confirm this, but it seems readily apparent to me that when most people
    hear the term “streaming”—whether they are a developer or a layperson—the implication
    is that there is a consumption of some form of media from “the cloud.”
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are looking to achieve in this section is to learn how we can accomplish
    this. How exactly does this work? When building a streaming response, Sanic will
    add the same `Transfer Encoding: chunked` header that we saw with streaming requests.
    This is the indication to the client that the server is about to send incomplete
    data. Therefore, it should leave the connection open.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this happens, it is time for the server to send data at its discretion.
    What is a chunk of data? It follows a protocol whereby the server sends the number
    of bytes it is about to send (in hexidecimal format), followed by a `\r\n` line
    break, followed by some bytes, and another `\r\n` line break:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server is done, it needs to send a `0` length chunk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can probably guess, Sanic will take care of much of the plumbing in
    setting up the headers, determining chunk sizes, and adding the appropriate line
    breaks. Our job is to control the business logic. Let’s see what a super simple
    implementation looks like, and then we can build from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When we were consuming streaming requests, we needed to use the `stream` keyword
    argument or decorator. For responses, the simplest method is to generate the response
    up front: `resp = await request.respond()`. In our example, `resp` is a `<class
    ''sanic.response.HTTPResponse''>` type object.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a response object, we can write to it whenever, and however we
    want using either regular strings `("hello")` or bytes strings `(b"hello").` When
    there is no more data to be transferred, we tell the client using `resp.eof(),`
    and we are done.
  prefs: []
  type: TYPE_NORMAL
- en: This asynchronous behavior of sending data at will does bring up an interesting
    question about the lifecycle of the request. Since we are slightly getting ahead
    of ourselves, if you are interested to see how middleware behaves with streaming
    responses, jump ahead to Chapter 6 now.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I am sure you can probably imagine from our simple example, by having the
    `resp.send()` method available to us, we now have the freedom to execute asynchronous
    calls as desired. Of course, a silly example to illustrate our point would be
    to add a loop with some time delays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we will see a more useful and complex example when we
    start sending server sent events (SSE). But first, let’s get back to our goal.
    We wanted to send the actual song. Not just meta data, not just the lyrics: the
    actual music file so we can listen to it through our web application.'
  prefs: []
  type: TYPE_NORMAL
- en: File streaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest method to do this is with the `file_stream` convenience wrapper.
    This method takes care of all the work for us. It will asynchronously read the
    file contents, send the data in chunks to the client, and wrap up the response.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to open the browser, turn up the volume, hit our webpage, and
    enjoy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so perhaps relying upon the browser to be our media player is not the
    best UI. What if we want to embed the song content and have an actual player UI
    inside of our frontend? HTML and design is outside the scope of the book, obviously.
    But you can at least get a started using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Sanic will default to sending chunks of 4096 bytes with this method. You may
    find it desirable to increase or decrease that number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It is also worth mentioning that Sanic does some work under the hood to attempt
    to figure out what kind of file you are sending. This is so that it can properly
    setup the content-type header. If it is unable to figure it out, then it will
    fallback to text/plain. Sanic will look at the file extension and try and match
    it against the operating system’s mime type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Server-Sent Events for push communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know that we can control the flow of information from the server,
    we are entering the territory of being able to build some great features for our
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the old days, when our application wanted to check the state of something,
    it would need to poll the web server by repeatedly sending the same request over
    and over again. We talked about building a music web application. We saw how we
    could display content, get information, and even stream some content to listen
    to music. The next step of course is to make the application social, because we
    of course want to share our music with our friends. We want to add a feature that
    will list out who is online, and the name of the song they are listening to. Refreshing
    the page constantly would work, but is a bad experience. Polling constantly by
    sending the same request over and over again also works, but this eats up resources
    and is also not a great experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would be better is if our server simply notified the browser when someone
    came online or when their music player changes. This is what server-sent events
    (SSE) provides: a super simple set of instructions for our server to send push
    notifications to the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic unit of the SSE protocol is the *event*, which is a single-line of
    text that contains a field and some body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the field is: `data` and the body is `foo`. A message can consist
    of one or more events separated by a single new line character: `\n`. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When a browser receives this message, it will be decoded as: `foo\nbar`. A
    message should be terminated by the server by sending two (2) new line characters:
    `\n\n`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SSE protocol has five basic fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `<null>` | Should be treated as a comment | `: This is a comment` |'
  prefs: []
  type: TYPE_TB
- en: '| `event` | A description of the type of event being sent | `event: songplaying`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `data` | he body of the message, often this is either plain text or JSON
    | `data: All Along the Watchtower` |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | A self-created event ID for tracking | `id: 123456ABC` |'
  prefs: []
  type: TYPE_TB
- en: '| `retry` | Reconnection time in milliseconds | `retry: 1000` |'
  prefs: []
  type: TYPE_TB
- en: Figure 5.2 - Overview of the allowed SSE fields
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before diving into how we can implement SSE from Sanic, we need a frontend
    application that can understand how to process these events. We are not too concerned
    about how to build the SSE client. There is a prebuild frontend HTML client that
    you can find in the GitHub repo: … Just grab the code to follow along.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To deliver the client, we will store that HTML as `index.html` and use the
    existing tools we know to serve that file. To make sure that we cover the blank
    root path (`/`), we will also redirect it to our `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a simple client, let’s build the simple server to go along
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Most of this should look familiar. We already saw how we can control the sending
    of chunks to the client, here we are just doing it in a more structured pattern.
    Of course, however, this super simple proof-of-concept is far from a feature complete
    build to be used for our music application. Let’s see how we can make it a bit
    better by creating a mini framework.
  prefs: []
  type: TYPE_NORMAL
- en: Building some SSE objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create our SSE framework, we will start by building some basic objects to
    help in creating our messages. SSE messages are indeed super simple, so perhaps
    this is a bit overkill. On the other hand, making sure we use line breaks and
    field names appropriately sounds like a recipe for disaster. So, a few thoughtful
    steps up front should go a long way for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will build are some objects for creating properly formatted
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we are starting our inheritance with `str`. This will make our objects
    operate as strings, just with some auto-formatting involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on, we need a convenient way to compose fields together into a single
    message. It also would need to have proper string formatting, which means the
    additional `\n` at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, looking at this, we should see a properly formatter SSE message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to try out our new building blocks and see if they send messages
    as expected to the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s pause for a moment and recap what it is we are trying to achieve. The
    goal is to send notifications to the browser when a certain event happens. So
    far, we have identified two events: another user logs into (or out of) the system,
    and a user starts (or stops) listening to a song. When one of these events are
    triggered, our stream should broadcast the notification back to the browser. To
    achieve this we will build a pubsub.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pubsub is a design paradigm where you have two actors: a publisher and a
    subscriber. It is the job of the publisher to send messages, and the job of the
    subscriber to listen for messages. In our scenario, we want the stream to be the
    subscriber. It will listen for incoming messages, and when it receives one, it
    will know that it should dispatch the SSE.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are still working out exactly how we want our notification system to
    work, we are going to keep it simple. The mechanism for our pubsub will be a simple
    `asyncio.Queue`. Messages can come in, and messages can be consumed. It should
    be noted that this design pattern will be limited. Remember way back at the beginning
    we decided that we were going to run our development server with two workers?
    The reason for doing that was to keep horizontal scaling in mind. What we are
    about to do will absolutely break this, and will not work on a distributed system.
    Therefore, to make this production worthy, we will need a new plan for how to
    distribute messages across a cluster. We will get there later in this book in
    our *Chapter 11* complete example.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to setup a single queue. We will do this with a listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, when our application starts, anywhere we have access to the application
    instance, we can also access the notification queue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: As we start building more complex applications, we are going to see more usage
    of `ctx` objects. These are convenient locations that Sanic provides for us–the
    developers–to do with as necessary. It is a storage location for “stuff”. Sanic
    almost never makes use of them directly. Therefore, we are free to set any properties
    we want on the object.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next, we will create our subscriber. This instance will listen to the queue,
    and send messages when it finds a message on the queue that has not been dispatched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, our `run` operation consists of an infinite loop. Inside of
    that loop the `Notifier` will pause and wait until there is something inside of
    the queue. When there is, it removes the item from the queue and continues through
    the current iteration of the loop, which is to send that item. But, before our
    loop, we are going to send a single heartbeat message. This will flush out any
    startup events so that our client will clear out its own queue. It is not necessary,
    but I think it is a helpful practice to get into.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To implement this in our endpoint, it will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A response object is created using request.respond. Then, we create the `Notifier`
    and let it run. At the very end, `eof` is called to close out the connection.
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTANT NOTE**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To be entirely up-front, the previous code sample is somewhat flawed. I intentionally
    left it simple for the sake of making a point. However, since there is no way
    to break out of the infinite loop, there is really no way the server would ever
    close out the connection itself. This makes the inclusion of `eof` a bit of a
    moot point. It is nice to have there as an example, but this code as written will
    only ever be stopped client side by navigating away from the endpoint.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The easy part should now be pushing messages into the queue. We can do it like
    this on a separate endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now test this out! Open your browser and go to: `http://localhost:7777/index.html`You
    should see something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 - Screenshot of HTML to test out SSE](img/file5.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5.3 - Screenshot of HTML to test out SSE
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we “start” the stream by clicking the button, switch back to a terminal
    and we will hit our fake login endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Did you see what just happened in the browser? Go ahead and do it again. Feel
    free to play around with this example to get a feel for how the different components
    are working.
  prefs: []
  type: TYPE_NORMAL
- en: Do you think you can build the fake “start playing music” endpoint? Just make
    sure that if you are going to use `Event` that your frontend application knows
    about it by using `eventSource.addEventListener`. Take a look at the `index.html`
    and you will see the `login` event. I suggest you pause and take some time to
    dig into this code to see how the different components are working together to
    facilitate the exchange of data. What kinds of amazing things could you build
    using this?
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 6,* we will come back to this same example and see another way
    we could achieve it through the use of signals. I should also probably point out
    that using `asyncio.Queue` in this instance has another disadvantage: it will
    really only work in a single browser. Since our consumer (the `Notifier`) drains
    down the queue, what happens when multiple browsers are running simultaneously?
    Well, only the first one gets the message. Again, this solution is much too simplistic
    for real world usage, but hopefully it has gotten the ideas flowing for how you
    could build something more robust. To be entirely transparent, in situations like
    this I really like to fallback to Redis. If you are familiar with Redis, you might
    know that it has a pubsub built into it. With the right Python library interface,
    you can easily solve both the problems the `asyncio.Queue` implementation gave
    us: it can be used to push messages to multiple subscribers at once, and it can
    be used in a distributed system where multiple publishers are pushing into it.
    Maybe before coming to *Chapter 11* you want to see if you can make it work in
    our current example?'
  prefs: []
  type: TYPE_NORMAL
- en: If nothing else, I hope you got excited when you saw the message pop-up in your
    browser. For me, it is still really interesting and fun to see messages being
    pushed into a browser session. SSE are a super simple solution that can solve
    some potentially complex problems, that ultimately lead to a powerful feature
    set. Being able to push data into a web browser truly helps an application feel
    like it is transforming from a web page to a web application.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this implementation is that they are still only one-sided. To
    get two-way asynchronous communication, we need websockets.
  prefs: []
  type: TYPE_NORMAL
- en: Websockets for two-way communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have almost definitely experienced websockets on your favorite web applications
    before. They are a tool that helps create a super-rich layer of user experience,
    and can be used in a wide variety of contexts. While SSEs are essentially just
    an open stream that has not yet been terminated, websockets are something different
    completely.
  prefs: []
  type: TYPE_NORMAL
- en: Plain vanilla HTTP is just a specification (or protocol) for how messages can
    be formatted and transmitted over a TCP connection between machines. Websockets
    are a separate protocol complete with directions on how messages should be formatted,
    sent, received, etc. The specification for them is really quite involved, and
    we could probably devote an entire book to just discussing websockets. So instead
    we will simply focus on their implementation within Sanic. The one technical detail
    about websockets that worth mentioning is that they begin their life as a normal
    HTTP connection. The request comes in and asks the server for permission to upgrade
    its connection to a websocket. Then, the client and server do a bit of a dance
    together to iron out the details. When the negotiations are all done, we have
    an open socket where messages can be passed back and forth. Think of it as a two-lane
    highway where messages can pass by each other on their way to either end.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the easiest way to conceptualize a websocket is to think of a chat application.
    We have a single endpoint on the backend server. Two separate web browsers connect
    to the server, and each are connected somehow so that when one pushes a message
    in, the server pushes that message out the other side. In this way, both clients
    are able to send and receive messages irrespective of what else is happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is true asynchronous web behavior. Sanic uses `async/await` to leverage
    and optimize server efficiency for performance. But, the side benefit is that
    it also allows Sanic to offer an almost effortless mechanism to implementing websockets.
    While we will not get into the details of how this works, you should be aware
    that Sanic makes uses of the Python `websockets` package under the hood. It is
    a fantastic project, and it might be helpful to look at their documentation when
    building your own websocket endpoint in Sanic: [https://websockets.readthedocs.io](https://websockets.readthedocs.io).'
  prefs: []
  type: TYPE_NORMAL
- en: In the last section we started to make our music player application social by
    sharing information about who was logged in. Let’s turn up the social aspect by
    adding in chat. Our goal here is to have two browsers open side by side and be
    able to pass text messages back and forth between them. Just like with the SSE
    example, you can grab the frontend code from the GitHub repository so we do not
    have to worry about those implementation details. [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05/websockets](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/05/websockets)
  prefs: []
  type: TYPE_NORMAL
- en: 'First thing we are going to create is a `Client`. When someone enters the application,
    the frontend will immediately open the websocket. The `Client` will be a holding
    place for us to be able to keep track of who is in the application, and how we
    can send them messages. Therefore we need a unique identifier, and the callable
    to send messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see above, we are going to keep track of the incoming session by
    assigning each client a `UUID`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Instantiate this `Client` object inside of the `websocket` handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to create our `ChatRoom`. This will be a global instance that
    exists during the lifetime of the application. Its role will be to keep track
    of all of the clients that have entered or exited. When someone tries to send
    a message, it will be responsible for publishing that message to the rest of the
    clients. Just like with our SSE example, the implementation I am about to show
    you is limited in that it cannot be run across a distributed cluster. It will
    function great on just a single instance. This is because we are registering the
    clients on a single instance in memory. To build a more scalable application to
    be used in a production environment, we should use something like Redis or RabbitMQ
    to distribute the message across multiple Sanic instances. For now, this will
    do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There is a mechanism to add and remove clients, and a method to push events
    to registered clients. One thing that is important to point out here is that we
    do not want to send the message back to the person that sent it. That would be
    a little bit awkward and a bit annoying for the user to constantly have their
    own messages fed back to them. Therefore, we will filter out the sending client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember, the `ChatRoom` instance is a single object lives for the lifetime
    of the application instance. So, where do you think it should be instantiated?
    That’s right, a listener!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now all we need to do is wire it up!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the user enters, we add them to the chatroom. Then it enters and infinite
    loop and waits for a message to be received. This is very similar in concept to
    the SSE implementation we saw in the last section. When a message is received
    on the current websocket, it is passed to the `ChatRoom` object that is responsible
    for sending it to all of the other registered clients. Seems too easy, right?!
    Now to test it out. Open two browsers side by side, and start adding messages.
    Have fun chatting with yourself!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 - Screenshot of two side-by-side HTML websocket-enabled applications:
    me talking to myself](img/file6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4 - Screenshot of two side-by-side HTML websocket-enabled applications:
    me talking to myself'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that you need to run the above websocket HTML application (and the
    backend chatroom code we just looked at) is available on GitHub: _____.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Response Headers and Cookies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have talked a lot about headers. They are super important when building web
    applications and are generally a fundamental part of application design. When
    building your application responses, you will likely find reasons to add handlers
    to your response objects. This could be for security purposes like CORS headers
    or a Content-Security-Policy, or for informational and tracking purposes. And,
    of course there are cookies, which are their own special kind of headers that
    receive special treatment in Sanic.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed back in some earlier examples (like the SSE example) where
    we actually set the headers. It is such an easy and intuitive process, perhaps
    you did not even notice. Whenever we build a response object, all we need to do
    is pass a dictionary with key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s really all there is to it! Keep in mind you will not be required to
    set your own headers all the time. Sanic takes care of some of them for you, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`content-length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content-type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transfer-encoding`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding with a request ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One pattern that is particularly helpful is to set an `x-request-id` header
    on every response. If then make a habit of using `request.id` in logging or tracing
    a request through your application, it becomes easier to track what is happening
    when you inevitability need to debug something.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to make sure our response includes the header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That is the simple example. As you have probably come to realize by now, that
    simple example might get tedious if we want to do it on all of our requests. Do
    you want to try to come up with a solution for adding that to all responses? Decorators
    and middleware are again potential tools. We will come back to this and you will
    see some implementations for setting this globally in the full example in *Chapter
    11*.
  prefs: []
  type: TYPE_NORMAL
- en: To truly make this useful, we should setup our logging to include the request
    ID. We have not talked too much about it yet, but Sanic includes a default logger
    for you to use. It may be helpful for you to piggyback onto it, but to override
    the default logging format to include that request ID. If you want to know more
    about how to set this up, jump ahead to *Chapter 6*.
  prefs: []
  type: TYPE_NORMAL
- en: Setting response cookies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important types of headers you can set on an individual response
    would be the cookie headers. Since they are so prominent, and they could include
    a bit of complexity to set them up, you can avoid having to use `Set-Cookie` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Response cookies are basically a key/value pair that gets concatenated into
    a single string in the response, but then interpreted by the browser. It is yet
    another shared language in the conversation of the web. So, while a single cookie
    could be as simple as `flavor=chocolatechip`, that shared language allows us to
    set a whole bunch of meta data on top of the simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the meta data, let’s look at the simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Seems fairly straightforward. Let’s see what it does to our response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Our response headers now have: `Set-Cookie: flavor=chocolatechip; Path=/.`
    So, what’s the deal with that `Path`? That is the cookie meta data at play. Here
    are some of the various meta values that we can add:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `expires: datetime` | The time at which a browser should discard the cookie
    |'
  prefs: []
  type: TYPE_TB
- en: '| `path: str` | The path in which the cookie will be applied |'
  prefs: []
  type: TYPE_TB
- en: '| `comment: str` | Comment |'
  prefs: []
  type: TYPE_TB
- en: '| `domain: str` | The domain in which the cookie will be applied |'
  prefs: []
  type: TYPE_TB
- en: '| `max-age: str` | Number of seconds before a browser should discard the cookie
    |'
  prefs: []
  type: TYPE_TB
- en: '| `secure: bool` | Whether it should only be sent over HTTPS |'
  prefs: []
  type: TYPE_TB
- en: '| `httponly: bool` | Whether it can be accessed by Javascript |'
  prefs: []
  type: TYPE_TB
- en: '| `samesite: str` | Where it can be sent from, values can be: lax, strict,
    none |'
  prefs: []
  type: TYPE_TB
- en: Table 5.2 - Cookie meta-fields
  prefs: []
  type: TYPE_NORMAL
- en: 'When we setup our `flavor` cookie, it seemed like we were just adding a string
    value to a dictionary that looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: That is not really the case. The `response.cookies` object is in fact a `CookieJar`
    object, which is itself a special kind of `dict`. When we setup a new key/value
    on that `CookieJar`, it is in fact creating a `Cookie` object. Huh?
  prefs: []
  type: TYPE_NORMAL
- en: 'When we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: It is more like you are creating a `Cookie("flavor", "chocolatechip")`, and
    then putting it into a `CookieJar()`. To cleanup some of the complexity involved
    with managing these instances, Sanic let’s us just work with strings. We should
    keep this in mind when we go to set the meta data, which is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine we have a cookie that should timeout. After some period of time,
    we want the browser session to forget it existed. This might–for example–be useful
    with a session cookie. We set some value that identifies a browser session with
    a particular user. Storing it in a cookie means that on subsequent requests we
    can identify who the person is. However, by setting a max-age, we can control
    the length of time that person can use the application before they need to login
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The same applies for all the other meta fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If we put this all together, our cookie headers will ultimately look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we should look at is how we should delete cookies. When you want
    to remove a cookie, it is tempting to just use del like you might with any other
    dictionary object. The problem is this only works so far. Usually, what you want
    to do instead is tell the browser that it needs to remove the cookie so that the
    browser does not send it back in future requests. The easiest method to accomplish
    this is by setting the max-age of the cookie to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: You should now feel comfortable adding and deleting cookies to responses. It
    might be a good opportunity to create a response handler and use your browser’s
    cookie inspection tools to see how cookies can be set, manipulated, and deleted
    from your server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen how to manipulate both the request and the response, it
    is entirely possible for us to build some really powerful applications. Whether
    we are building an HTML-based website, a JSON powered web API, a streaming content
    application, or some combination of them all, Sanic provides us with the tools
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things we discussed is that Sanic tries hard to not obstruct
    the build of an application. We as the developers have the freedom to build with
    different tools, and layer them together to build a truly unique platform. This
    is very much prevalent when we realize the freedom given to the developer with
    the response object. Need to write bytes directly? Sure. Want to use a specific
    templating engine? Not a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the basic understanding on how to handle the lifecycle of an
    HTTP connection from request through to response, we can start to see what else
    we have at our disposal. In the next chapter we will take a deeper dive into some
    of the concepts already introduced like middleware, background tasks, and signals.
    Combining these basic building blocks will help us build not only a powerful application,
    but also one that is easy to maintain, update, and expand.
  prefs: []
  type: TYPE_NORMAL
