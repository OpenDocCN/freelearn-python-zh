- en: Chapter 2. Responding to Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding event propagation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Key events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using UpdateUI events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with the mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom event classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing event handlers with EventStack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating input with validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Apple events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In an event-driven system, events are used to connect actions within the framework
    to callback functions that are linked to those events. Applications that are built
    upon an event-driven framework make use of these events in order to know when
    to respond to actions that are initiated by the user or the system. In a user
    interface, events are the way to know when a button is clicked, when a menu has
    been selected, or any other one of a wide variety of actions that a user could
    take while interacting with the applications interface.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, knowing how to respond to events that occur during the life
    of an application is a crucial part of creating a functional application. So let's
    dive into the event-driven world of wxPython.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: wxPython is an event-driven system. The usage of this system is pretty straightforward
    and regular across the framework. The basic patterns of working with events are
    the same regardless of the type of control or event that your application will
    interact with. This recipe will introduce the basics of working in wxPython's
    event system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a simple `Frame` with two buttons in it to show how to work with
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The lines of code to take notice of in this recipe are the two `Bind` calls.
    The `Bind` method is used to associate an event handler function with an event
    that may be sent to a control. Events always propagate up the window hierarchy
    and never down. In this example, we bound the button event to the `Frame`, but
    the events will originate from the `Button` objects that are children of the `Panel`.
    The `Frame` object is at the top of the hierarchy containing the `Panel`, which
    in turn contains the two `Buttons`. Because of this, since the event callback
    is not handled by the `Button` or the `Panel`, it will propagate to the `Frame`
    where our `OnButton` handler will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Bind` method takes two required parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The event binder object (`EVT_FOO`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callable object that takes an event object as its first parameter. This is
    the event handler function that will be called when the event occurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional parameters are for specifying the originating control to bind the
    event handler to. We bound one handler for each of our buttons in this example
    by specifying the `Button` objects as the third parameter to `Bind`.
  prefs: []
  type: TYPE_NORMAL
- en: '`EVT_BUTTON` is the event binder for when a `Button` is clicked by the user
    of the application. When the first button is clicked, the event handler `OnButton`
    will be called to notify our program that this action occurred. The event object
    will be passed to the handler function as its first parameter. The event object
    has a number of methods that can be used to get information about the event and
    what control it came from. Each event may have different data available, depending
    on the type of event that is related to the type of control it originated from.'
  prefs: []
  type: TYPE_NORMAL
- en: For our second `Button`, we used a `lambda` function as a shorthand way of creating
    an event-handler function without needing to define a new function. This is a
    handy way of handling events that only need to perform simple actions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Application object* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* talks about the MainLoop,
    which is at the core of the event system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding the window hierarchy* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* describes the window
    containment hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating Stock Buttons* recipe in [Chapter 3](ch03.html "Chapter 3. Basic
    Building Blocks of a User Interface"), *Basic Building Blocks of a User Interface*
    explains Buttons in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a BoxSizer* recipe in [Chapter 7](ch07.html "Chapter 7. Window Layout
    and Design"), *Window Layout and Design* explains how to use the `BoxSizer` class
    to lay out controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding event propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main types of Event Objects in wxPython, each with its own distinct
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic `Events` are events that do not propagate upwards in the window hierarchy.
    Instead, they stay local to the window that they were sent to or originated in.
    The second type, `CommandEvents`, are the more common type of events, and differ
    from regular events in that they propagate up the window parental hierarchy until
    they are handled or reach the end of the line at the application object. This
    recipe will explore how to work with, understand, and control the propagation
    of events.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explore how events propagate, lets create another simple application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Running this will create an application with two buttons on it. Click each of
    the buttons to see how the events propagate differently.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The chain of event handlers that will be called starts at the object that the
    event originates from. In this case, it will be one of our two buttons. Each level
    in the window hierarchy of this application has a general event handler bound
    to it, that will receive any button events.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the first button will show that all of the event handlers get called.
    This is because for the first button we called the event's `Skip` method. Calling
    `Skip` on an event will tell it to continue propagating to the next level of event
    handlers in the hierarchy. This will be apparent, as three statements will be
    printed to the console. On the other hand, clicking the second button will result
    in only one event handler being called, because `Skip` is not called.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Handling events* recipe in this chapter explains how event handlers work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding the window hierarchy* recipe in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with wxPython"), *Getting Started with wxPython* describes the window
    hierarchy that events propagate through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Key events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`KeyEvents` are events that are associated with keyboard actions. Many controls
    can accept keyboard events. Each time that a key is pressed on the keyboard, there
    will be two or three events sent to the control that has the keyboard focus, depending
    on what key was pressed. This recipe will create a simple text editor window,
    in order to demonstrate how to use `KeyEvents` to filter text that is added to
    a `TextCtrl`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see some `KeyEvents` in action, let''s make a simple window that has a `TextCtrl`
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When typing in this window, it will not allow text to be entered when the *Shift*
    key is pressed and it will turn all vowels into question marks.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `KeyEvents` are sent by the system in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EVT_KEY_DOWN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EVT_CHAR` (only for keys that have a character associated with them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EVT_KEY_UP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's important to notice that we called `Bind` on our `TextCtrl` and not the
    `Frame`. This is necessary because the `KeyEvents` will only be sent to the control
    that has the keyboard focus, which in this window will be `TextCtrl`.
  prefs: []
  type: TYPE_NORMAL
- en: Each `KeyEvent` has a number of attributes attached to it in order to specify
    what key was pressed and what other modifier keys were held down during the event,
    such as the *Shift, Alt*, and *Ctrl* keys.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `Skip` on the event allows the control to process it and for the next
    handler in the chain to be called. For example, not skipping the event in the
    `EVT_KEY_DOWN` handler will block the `EVT_CHAR` and `EVT_KEY_UP` handlers from
    being called.
  prefs: []
  type: TYPE_NORMAL
- en: In this sample, when a key on the keyboard is pressed, our `OnKeyDown` handler
    will be called first. All we do there is `print` a message to `stdout` and display
    some information about the event in the `StatusBar`, before calling `Skip`. Then,
    in our `OnChar` handler, we do some simple filtering of uppercase letters by checking
    to see if the *Shift key* is in the event's modifiers mask. If it is, we beep
    at the user and don't call `Skip` on the event, in order to prevent the character
    from appearing in the `TextCtrl`. Also, as an example of modifying what the event
    does, we perform a check for vowels by converting the raw key code into a character
    string and if the key was for a vowel, we simply insert a question mark into the
    `TextCtrl` instead. Finally, if the event was skipped in the `OnChar` handler,
    our `OnKeyUp` handler will be called, where we simply print a message to `stdout`
    to show it was called.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some controls require the `wx.WANTS_CHARS` style flag to be specified in their
    constructor in order to receive character events. The `Panel` class is the most
    common example that requires this special style flag in order to receive `EVT_CHAR`
    events. Often, this is used to perform special processing when creating a new
    custom control type that is derived from a `Panel`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Validating input with validators* recipe in this chapter uses `KeyEvents`
    to perform input validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using UpdateUI events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`UpdateUIEvents` are events that are sent by the framework on a regular basis
    in order to allow an application to update the state of its controls. These are
    useful for performing tasks such as changing when a control is enabled or disabled,
    based on the application''s business logic. This recipe will show how to use `UpdateUIEvents`
    to update the state of menu items, depending on the current context of the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we create a simple window with an `Edit Menu` and a `TextCtrl`.
    The `Edit Menu` has three items in it that will be enabled or disabled based on
    the current selection status in the `TextCtrl` by using `UpdateUIEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UpdateUIEvents` are sent periodically by the framework during idle time to
    allow the application to check if the state of a control needs to be updated.
    Our `TextFrame` class has three menu items in its Edit Menu that will be managed
    by our `OnUpdateUI` event handler. In `OnUpdateUI`, we check the event''s ID to
    see which object the event is being sent for, and then call the appropriate `UpdateUIEvent`
    method on the event to change the state of the control. The states of each of
    our menu items are dependent upon whether there is a selection in the `TextCtrl`
    or not. Calling the `GetSelection` method of `TextCtrl` will return a tuple with
    the start and end positions of the selection. When the two positions differ, there
    is a selection in the control and we will `Enable` the `Copy` and `Cut` items,
    or in the case of our `Selection Made` item we will set the check mark. If there
    is no selection, then the items will become disabled or un-checked.'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to call the method on the event object to update the control
    and not the method on the control itself, as it will allow for it to be updated
    far more efficiently. See the wxPython API documentation for `UpdateUIEvent` to
    see the full listing of what methods are available.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some static methods available in the `UpdateUIEvent` class that allow
    applications to change the behavior of how the events are delivered. Most notable
    are the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wx.UpdateUIEvent.SetUpdateInterval`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`wx.UpdateUIEvent.SetMode`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SetUpdateInterval` can be used to configure how often the `UpdateUIEvents`
    are sent. It takes a number of milliseconds as an argument. This is useful if
    you find that there is a noticeable amount of overhead in handling `UpdateUIEvents`
    in your application. You can use this to slow down the rate at which these events
    are sent.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SetMode` can be used configure the behavior of what windows will receive the
    events, by setting one of the following modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.UPDATE_UI_PROCESS_ALL` | Process `UpdateUI` events for all windows |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.UPDATE_UI_PROCESS_SPECIFIED` | Only process `UpdateUI` events for the
    windows that have the `WS_EX_PROCESS_UI_UPDATES` extra style flag set. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Managing event handlers with EventStack* recipe in this chapter shows a
    way to manage `UpdateUI` events in a centralized way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with the mouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MouseEvents` can be used to interact with the mouse-position changes and mouse-button
    clicks that a user makes within a window. This recipe will provide a quick crash
    course on some of the common mouse events that are available for use in a program.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here as an example, we will create a simple Frame class that has a `Panel` and
    a Button to see how to interact with `MouseEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we made use of the events for when the mouse cursor enters the
    `Panel` and for when the left mouse button is clicked on the `Panel`, to modify
    our `Button`. When the mouse cursor enters a window's area, an `EVT_ENTER_WINDOW`
    event will be sent to it; conversely, it will receive an `EVT_LEAVE_WINDOW` event
    when the cursor leaves the window. When the mouse enters or leaves the Panel's
    area, we update the Button's label to show what happened. When our `Panel` receives
    a left click event, we move the `Button` to where the click took place.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to notice is that we called `Bind` on the `Panel` directly
    and not on the `Frame`. This is important because `MouseEvents` are not `CommandEvents`
    so they will only be sent to the window they originated from, and will not propagate
    up the containment hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a large number of `MouseEvents` that can be used to interact with
    other mouse actions. The following table contains a quick reference to each of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| MouseEvents | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_MOUSEWHEEL` | Sent for mouse wheel scroll events. See the `GetWheelRotation`
    and `GetWheelDelta` methods that belong to the `MouseEvent` class for working
    with this event. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_LEFT_DCLICK` | Sent for left mouse button double-clicks. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_RIGHT_DOWN` | Sent when the right mouse button is pressed down. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_RIGHT_UP` | Sent when the right mouse button is released. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_RIGHT_DCLICK` | Sent for right mouse button double-clicks. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_MIDDLE_DOWN` | Sent when the middle mouse button is pressed down.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_MIDDLE_UP` | Sent when the middle mouse button is released. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_MIDDLE_DCLICK` | Sent for middle mouse button double-clicks. |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_MOTION` | Sent every time the mouse cursor moves within the window.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `wx.EVT_MOUSE_EVENTS` | This event binder can be used to get notifications
    for all mouse related events. |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding event propagation* recipe in this chapter discusses how different
    types of events propagate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom event classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it is necessary to define your own event types to signal custom actions
    and/or transport data from one place in the application to another. This recipe
    will show two ways of creating your own custom event class.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this little snippet, we define two new event types using two different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first example shows the easiest way to create a custom event class. The
    `NewCommandEvent` function from the wx.lib.newevent module will return a tuple
    that contains a new event class and an event binder for that class. The class
    definition that is returned can be used to construct an event object. This method
    of creating a new event type is of most use when you just want a new event type
    and don't need to send any custom data with the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of an event object, the object needs to be sent for processing
    by the event loop. There are two ways to do this, one of which is the `PostEvent`
    function. `PostEvent` takes two arguments: the first is the window that should
    receive the event, and the second is the event itself. For example, the following
    two lines of code could be used to create and send an instance of our custom `MyEvent`
    to a `Frame:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to send an event for processing is to use a window''s `ProcessEvent`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the two is that `PostEvent` will put the event into the
    application's event queue to have it processed on the next iteration of the `MainLoop`,
    whereas `ProcessEvent` will cause the event to be processed right then.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach shows how to derive a new event type from the `PyCommandEvent`
    base class. In order to create an event in this way, there are three things that
    need to be done.
  prefs: []
  type: TYPE_NORMAL
- en: Define a new event type using the `NewEventType` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the event binder object for binding event handlers with the `PyEventBinder`
    class. This object takes the event type as its first argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the event class that is used for creating the event object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This `MyTimeEvent` class can hold a custom value that we are using to send a
    formatted time string. It is necessary to derive this from `PyCommandEvent` so
    that the custom Python data and methods that we are attaching to this object will
    pass through the event system.
  prefs: []
  type: TYPE_NORMAL
- en: These events can now be sent to any event handler object, by using the `PostEvent`
    function or the windows `ProcessEvent` method. Either of these methods will cause
    the event to be dispatched to the event handler(s) that has been associated with
    the event by calling `Bind`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* explains
    the need for the Py versions of some classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Handling events* recipe in this chapter discusses the use of event handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing event handlers with EventStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`EventStack` is a module in `wx.lib` that provides a mix in class for the wx
    application object that can be used to help manage event handlers for `Menu` and
    `UpdateUI` events. It can be useful in programs that have multiple top-level windows
    or that need to switch the context of which handlers are called depending on the
    control that has the focus. This recipe will present a simple framework for managing
    events in `Frame-based` applications that make use of the `AppEventHandlerMixin`
    class. A full working example, showing how to use this recipe''s classes, is included
    in the example code that accompanies this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With this code, we define two classes that work together. First we define an
    `App` base class that uses the `AppEventHandlerMixin`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EventMgrApp` class is just a base class for creating an application object
    that uses `AppEventHandlerMixin`. This `mixin` provides methods for adding and
    removing event handlers for the `MenuEvent` and `UpdateUIEvent` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: The `EventMgrFrame` class is a base class for frames to derive from. This class
    will handle adding, removing, and binding event handlers that are registered using
    either its `RegisterMenuHandler` or `RegisterUpdateUIHandler` methods. These methods
    take care of adding the event handlers to the stack that will be pushed or popped
    as the `Frame` is activated or deactivated. The `AppEventHandlerMixin` will internally
    manage Binding and Unbinding of these handlers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using UpdateUI events* recipe in this chapter discusses `UpdateUI` events
    in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating input with validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Validators` are a general type of helper class for validating data and filtering
    events that are input to a control. Most controls that accept user input can dynamically
    have a `Validator` associated with them. This recipe will show how to create a
    `Validator` that checks if the data that has been entered into a window is an
    integer that is within a given range of values.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we will define a Validator for a `TextCtrl` that can be used to validate
    that the value input is an integer and between a given range.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Validator` classes have a number of virtual methods that need to be overridden
    in order for them to function properly. Hence, it is important to derive a subclass
    from the `PyValidator` class, instead of `Validator`, in order to get access to
    the virtual method aware version of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: All `Validator` subclasses must override the `Clone` method. This method simply
    needs to return a copy of the `Validator`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Validate` method is called to check if the value is valid or not. This
    method will be called if the control is the child of a modal dialog, prior to
    calling `EndModal` for an `Ok` button. This is a good time to notify the user
    of any issues with the input.
  prefs: []
  type: TYPE_NORMAL
- en: '`Validators` can also bind to any events that their window may bind to and
    can be used to filter the events. The events will be sent to the `OnChar` method
    of the `Validator` before they are sent to the window, allowing the `Validator`
    to filter which events are allowed to get to the control.'
  prefs: []
  type: TYPE_NORMAL
- en: The `TransferToWindow` and `TransferFromWindow` methods can be overridden if
    you wish to only do the validation in a `Dialog` at the time when the `Dialog`
    is being shown or closed. `TransferToWindow` will be called when a `Dialog` is
    shown, and `TransferFromWIndow` will be called when the `Dialog` is closed. Returning
    `True` from either of the methods indicates that the data is valid, and returning
    `False` will indicate that there is invalid data.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* discusses
    the use of the Py versions of classes and overriding virtual methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Handling Key events* recipe in this chapter discusses `KeyEvents` in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Apple events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AppleEvents are high-level system events used by the Macintosh operating system
    to pass information between processes. For an application to handle things such
    as opening files that are dropped on the application icon, it is necessary to
    handle these events. The wxPython application object has some built-in support
    for some of the most common events, by way of virtual overrides in the application
    object. This recipe will show how to create an application object that can make
    use of the built-in and somewhat hidden-event callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an OS X specific recipe, and will have will have no effect on other
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This little sample application shows all of the built-in callback methods available
    in the `App` for handling some of the commonly needed `AppleEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are five built-in handler methods for some of the common `AppleEvents`.
    All that needs to be done to use them in your application is to override them
    in your application object, as previously shown. Since what an application does
    in response to these events is highly application-specific, this recipe does not
    do much, other than report to the frame's status bar when the method is called.
  prefs: []
  type: TYPE_NORMAL
- en: The two most-common events that should be implemented are the `MacOpenFile`
    and `MacReopenApp` methods, as these are necessary to get standard expected behavior
    in an application on OS X. `MacOpenFile` is called when a user drops a file on
    an application's Dock icon. When this happens, it will be passed the path of the
    file as an argument. `MacReopenApp` is called when a user left-clicks on the Dock
    icon of a running application. As shown in the recipe, this is used to bring an
    application to the front and/or raise it from a minimized state in the Dock.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to add support for more `AppleEvents` to a wxPython application,
    although it is not a particularly easy task as it requires writing a native extension
    module to catch the event, block the wx `EventLoop`, and then restore the Python
    interpreter's state back to wx after handling the event. There is a pretty good
    example that can be used as a starting point in the wxPython Wiki (see [http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC)](http://wiki.wxpython.org/Catching%20AppleEvents%20in%20wxMAC)),
    if you find yourself needing to venture down this route.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Understanding inheritance limitations* recipe in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with wxPython"), *Getting Started with wxPython* includes
    more information on overriding virtual methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Optimizing for OS X* recipe in [Chapter 12](ch12.html "Chapter 12. Building
    and Managing Applications for Distribution"), *Application Infrastructure* includes
    more information on making wxPython applications work well on OS X.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
