<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Functions, the Building Blocks of Code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Functions, the Building Blocks of Code</h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"To create architecture is to put in order. Put what in order? Function and objects."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Le Corbusier</em></span></span></td></tr></table></div><p>In this chapter, we're going to explore functions. We already said that everything is an object in Python, and functions are no exception to this. But, what exactly is a function? A <span class="strong"><strong>function</strong></span> is<a id="id240" class="indexterm"/> a sequence of instructions that perform a task, bundled as a unit. This unit can then be imported and used wherever it's needed. There are many advantages to using functions in your code, as we'll see shortly.</p><p>I believe the saying, <span class="emphasis"><em>a picture is worth one thousand words</em></span>, is particularly true when explaining functions to someone who is new to this concept, so please take a look at the following image:</p><div class="mediaobject"><img src="graphics/4715_04_01.jpg" alt="Functions, the Building Blocks of Code"/></div><p>As you can see, a function is a block of instructions, packaged as a whole, like a box. Functions can accept input arguments and produce output values. Both of these are optional, as we'll see in the examples in this chapter.</p><p>A function in Python is defined by using the <code class="literal">def</code> keyword, after which the name of the function follows, terminated by a pair of braces (which may or may not contain input parameters) and, finally, a colon (<code class="literal">:</code>) signals the end of the function definition line. Immediately <a id="id241" class="indexterm"/>afterwards, indented by four spaces, we find the body of the function, which is the set of instructions that the function will execute when called.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>Note that the indentation by four spaces is not mandatory, but it is the amount of spaces<a id="id242" class="indexterm"/> suggested by <span class="strong"><strong>PEP8</strong></span>, and, in practice, it is the most widely used spacing measure.</p></div></div><p>A function may or may not return output. If a function wants to return output, it does so by using the <code class="literal">return</code> keyword, followed by the desired output. If you have an eagle eye, you may have noticed the little <span class="strong"><strong>*</strong></span> after <span class="strong"><strong>Optional</strong></span> in the output section of the preceding picture. This is because a function always returns something in Python, even if you don't explicitly use the <code class="literal">return</code> clause. If the function has no <code class="literal">return</code> statement in its body, it's return value is <code class="literal">None</code>. The reasons behind this design choice are out of the scope of an introductory chapter, so all you need to know is that this behavior will make your life easier, as always, thank you Python.</p><div class="section" title="Why use functions?"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Why use functions?</h1></div></div></div><p>Functions<a id="id243" class="indexterm"/> are among the most important concepts and constructs of any language, so let me give you a few reasons why we need them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They reduce code duplication in a program. By having a specific task taken care of by a nice block of packaged code that we can import and call whenever we want, we don't need to duplicate its implementation.</li><li class="listitem" style="list-style-type: disc">They help in splitting a complex task or procedure into smaller blocks, each of which becomes a function.</li><li class="listitem" style="list-style-type: disc">They hide the implementation details from their users.</li><li class="listitem" style="list-style-type: disc">They improve traceability.</li><li class="listitem" style="list-style-type: disc">They improve readability.</li></ul></div><p>Let's look at a few examples to get a better understanding of each point.</p><div class="section" title="Reduce code duplication"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Reduce code duplication</h2></div></div></div><p>Imagine <a id="id244" class="indexterm"/>that you are writing a piece of scientific software, and you need to calculate primes up to a limit, as we did in the previous chapter. You write several algorithms and prime numbers, being the basis of many different types of calculations, keep creeping into your code. Well, you have a nice algorithm to calculate them, so you copy and paste it to wherever you need. One day, though, your friend <span class="emphasis"><em>Mister Smarty</em></span> gives you a better algorithm to calculate prime numbers, and this will save you a lot of time. At this point, you need to go over your whole codebase and replace the old code with the new code.</p><p>This is<a id="id245" class="indexterm"/> actually a very bad way to go about it. It's error-prone, you never know what lines you are chopping out or leaving there by mistake when you cut and paste code in other code, and you may also risk missing one of the places where prime calculation was done, leaving your software with different versions. Can you imagine if you discovered that the old way was buggy? You would have an undetected bug in your code, and bugs like this are quite hard to spot, especially in big codebases.</p><p>So, what should you do? Simple! You write a function, <code class="literal">get_prime_numbers(upto)</code>, and use it anywhere you need a list of primes. When <span class="emphasis"><em>Mister Smarty</em></span> comes to you and gives you the new code, all you have to do is replace the body of that function with the new implementation, and you're done! The rest of the software will automatically adapt, since it's just calling the function.</p><p>Your code will be shorter, it will not suffer from inconsistencies between old and new ways of performing a task, or undetected bugs due to copy and paste failures or oversights. Use functions, and you'll only gain from it, I promise.</p></div><div class="section" title="Splitting a complex task"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Splitting a complex task</h2></div></div></div><p>Functions <a id="id246" class="indexterm"/>are very useful also to split a long or complex task into smaller pieces. The end result is that the code benefits from it in several ways, for example, readability, testability, and reuse. To give you a simple example, imagine that you're preparing a report. Your code needs to fetch data from a data source, parse it, filter it, polish it, and then a whole series of algorithms needs to be run against it, in order to produce the results which will feed the <code class="literal">Report</code> class. It's not uncommon to read procedures like this that are just one big function <code class="literal">do_report(data_source)</code>. There are tens or hundreds of lines of code which end with <code class="literal">return report</code>.</p><p>Situations like this are common in code produced by scientists. They have brilliant minds and they care about the correctness of the end result but, unfortunately, sometimes they have no training in programming theory. It is not their fault, one cannot know everything. Now, picture in your head something like a few hundred lines of code. It's very hard to follow through, to find the places where things are changing context (like finishing one task and starting the next one). Do you have the picture in your mind? Good. Don't do it! Instead, look at this code:</p><p>
<code class="literal">data.science.example.py</code>
</p><div class="informalexample"><pre class="programlisting">def do_report(data_source):
    # fetch and prepare data
    data = fetch_data(data_source)
    parsed_data = parse_data(data)
    filtered_data = filter_data(parsed_data)
    polished_data = polish_data(filtered_data)

    # run algorithms on data
    final_data = analyse(polished_data)

    # create and return report
    report = Report(final_data)
    return report</pre></div><p>The <a id="id247" class="indexterm"/>previous example is fictitious, of course, but can you see how easy it would be to go through the code? If the end result looks wrong, it would be very easy to debug each of the single data outputs in the <code class="literal">do_report</code> function. Moreover, it's even easier to exclude part of the process temporarily from the whole procedure (you just need to comment out the parts you need to suspend). Code like this is easier to deal with.</p></div><div class="section" title="Hide implementation details"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Hide implementation details</h2></div></div></div><p>Let's stay <a id="id248" class="indexterm"/>with the preceding example to talk about this point as well. You can see that, by going through the code of the <code class="literal">do_report</code> function, you can get a pretty good understanding without reading one single line of implementation. This is because functions hide the implementation details. This feature means that, if you don't need to delve into details, you are not forced to, in the way you would if <code class="literal">do_report</code> was just one big fat function. In order to understand what was going on, you would have to read the implementation details. You don't need to with functions. This reduces the time you spend reading the code and since, in a professional environment, reading code takes much more time than actually writing it, it's very important to reduce it as much as we can.</p></div><div class="section" title="Improve readability"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Improve readability</h2></div></div></div><p>Coders<a id="id249" class="indexterm"/> sometimes don't see the point in writing a function with a body of one or two lines of code, so let's look at an example that shows you why you should do it.</p><p>Imagine that you need to multiply two matrices:</p><div class="mediaobject"><img src="graphics/4715_04_03.jpg" alt="Improve readability"/></div><p>Would you prefer to have to read this code:</p><p>
<code class="literal">matrix.multiplication.nofunc.py</code>
</p><div class="informalexample"><pre class="programlisting">a = [[1, 2], [3, 4]]
b = [[5, 1], [2, 1]]
<span class="strong"><strong>c = [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]</strong></span>
<span class="strong"><strong>     for r in a]</strong></span>
</pre></div><p>Or <a id="id250" class="indexterm"/>would you prefer this one:</p><p>
<code class="literal">matrix.multiplication.func.py</code>
</p><div class="informalexample"><pre class="programlisting"># this function could also be defined in another module
def matrix_mul(a, b):
    return [[sum(i * j for i, j in zip(r, c)) for c in zip(*b)]
            for r in a]

a = [[1, 2], [3, 4]]
b = [[5, 1], [2, 1]]
<span class="strong"><strong>c = matrix_mul(a, b)</strong></span>
</pre></div><p>It's much easier to understand that <code class="literal">c</code> is the result of the multiplication between <code class="literal">a</code> and <code class="literal">b</code> in the second example. It's much easier to read through the code and, if you don't need to modify that part, you don't even need to go into the implementation details.</p><p>Therefore, readability is improved here while, in the first snippet, you would have to spend time trying to understand what that complicated list comprehension was doing.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Don't worry if you don't understand <span class="emphasis"><em>list comprehensions</em></span>, we'll study them in the next chapter.</p></div></div></div><div class="section" title="Improve traceability"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Improve traceability</h2></div></div></div><p>Imagine<a id="id251" class="indexterm"/> that you have written an e-commerce website. You have displayed the product prices all over the pages. Imagine that the prices in your database are stored with no VAT, but you want to display them on the website with VAT at 20%. Here's a few ways of calculating the VAT-inclusive price from the VAT-exclusive price.</p><p>
<code class="literal">vat.py</code>
</p><div class="informalexample"><pre class="programlisting">price = 100  # GBP, no VAT
final_price1 = price * 1.2
final_price2 = price + price / 5.0
final_price3 = price * (100 + 20) / 100.0
final_price4 = price + price * 0.2</pre></div><p>All these four different ways of calculating a VAT-inclusive price are perfectly acceptable, and I promise you I have found them all in my colleagues' code, over the years. Now, imagine that you have started selling your products in different countries and some of them have different VAT rates so you need to refactor your code (throughout the website) in order to make that VAT calculation dynamic.</p><p>How <a id="id252" class="indexterm"/>do you trace all the places in which you are performing a VAT calculation? Coding today is a collaborative task and you cannot be sure the VAT has been calculated using only one of those forms. It's going to be hell, believe me.</p><p>So, let's write a function that takes the input values, <code class="literal">vat</code> and <code class="literal">price</code> (VAT-exclusive), and returns a VAT-inclusive price.</p><p>
<code class="literal">vat.function.py</code>
</p><div class="informalexample"><pre class="programlisting">def calculate_price_with_vat(price, vat):
    return price * (100 + vat) / 100</pre></div><p>Now you can import that function and apply it in any place of your website where you need to calculate a VAT-inclusive price and when you need to trace those calls, you can search for <code class="literal">calculate_price_with_vat</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Note that, in the preceding example, <code class="literal">price</code> is assumed to be VAT-exclusive, and <code class="literal">vat</code> has a percentage value (for example, 19, 20, 23, and so on).</p></div></div></div></div></div>
<div class="section" title="Scopes and name resolution"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Scopes and name resolution</h1></div></div></div><p>Do you<a id="id253" class="indexterm"/> remember when we talked about scopes and namespaces in the first chapter? We're going to expand on that concept now. Finally, we can talk about functions and this will make everything easier to understand. Let's start with a very simple example.</p><p>
<code class="literal">scoping.level.1.py</code>
</p><div class="informalexample"><pre class="programlisting">def my_function():
    <span class="strong"><strong>test = 1</strong></span> # this is defined in the <span class="strong"><strong>local</strong></span> scope of the function
    print('my_function:', test)

<span class="strong"><strong>test = 0</strong></span>  # this is defined in the <span class="strong"><strong>global</strong></span> scope
my_function()
print('global:', test)</pre></div><p>I have defined the name <code class="literal">test</code> in two different places in the previous example. It is actually in two different scopes. One is the global scope (<code class="literal">test = 0</code>), and the other is the local scope of the function <code class="literal">my_function</code> (<code class="literal">test = 1</code>). If you execute the code, you'll see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python scoping.level.1.py</strong></span>
<span class="strong"><strong>my_function: 1</strong></span>
<span class="strong"><strong>global: 0</strong></span>
</pre></div><p>It's clear that <code class="literal">test = 1</code> shadows the assignment <code class="literal">test = 0</code> in <code class="literal">my_function</code>. In the global<a id="id254" class="indexterm"/> context, <code class="literal">test</code> is still <code class="literal">0</code>, as you can see from the output of the program but we define the name <code class="literal">test</code> again in the function body, and we set it to point to an integer of value <code class="literal">1</code>. Both the two <code class="literal">test</code> names therefore exist, one in the global scope, pointing to an <code class="literal">int</code> object with value 0, the other in the <code class="literal">my_function</code> scope, pointing to an <code class="literal">int</code> object with value 1. Let's comment out the line with <code class="literal">test = 1</code>. Python goes and searches for the name <code class="literal">test</code> in the next enclosing namespace (recall the <span class="emphasis"><em>LEGB</em></span> rule: <span class="emphasis"><em>Local</em></span>, <span class="emphasis"><em>Enclosing</em></span>, <span class="emphasis"><em>Global</em></span>, <span class="emphasis"><em>Built-in</em></span> described in <a class="link" href="ch01.html" title="Chapter 1. Introduction and First Steps – Take a Deep Breath">Chapter 1</a>, <span class="emphasis"><em>Introduction and First Steps – Take a Deep Breath</em></span>) and, in this case, we will see the value <code class="literal">0</code> printed twice. Try it in your code.</p><p>Now, let's raise the stakes here and level up:</p><p>
<code class="literal">scoping.level.2.py</code>
</p><div class="informalexample"><pre class="programlisting">def outer():
    <span class="strong"><strong>test = 1</strong></span>  # outer scope

    def inner():
        <span class="strong"><strong>test = 2</strong></span>  # inner scope
        print('inner:', test)
    inner()
    print('outer:', test)
<span class="strong"><strong>test = 0</strong></span>  # global scope
outer()
print('global:', test)</pre></div><p>In the preceding code, we have two levels of shadowing. One level is in the function <code class="literal">outer</code>, and the other one is in the function <code class="literal">inner</code>. It is far from rocket science, but it can be tricky. If we run the code, we get:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python scoping.level.2.py </strong></span>
<span class="strong"><strong>inner: 2</strong></span>
<span class="strong"><strong>outer: 1</strong></span>
<span class="strong"><strong>global: 0</strong></span>
</pre></div><p>Try commenting out the line <code class="literal">test = 1</code>. What do you think the result will be? Well, when reaching the line <code class="literal">print('outer:', test)</code>, Python will have to look for <code class="literal">test</code> in the next enclosing scope, therefore it will find and print <code class="literal">0</code>, instead of <code class="literal">1</code>. Make sure you comment out <code class="literal">test = 2</code> as well, to see if you understand what happens, and if the LEGB rule is clear, before proceeding.</p><p>Another thing to note is that Python gives you the ability to define a function in another function. The inner function's name is defined within the namespace of the outer function, exactly<a id="id255" class="indexterm"/> as would happen with any other name.</p><div class="section" title="The global and nonlocal statements"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec61"/>The global and nonlocal statements</h2></div></div></div><p>Going<a id="id256" class="indexterm"/> back to the preceding example, we can alter what happens to the shadowing of the test name by using one of these two special statements: <code class="literal">global</code> and <code class="literal">nonlocal</code>. As you can see from the previous example, when we define <code class="literal">test = 2</code> in the function <code class="literal">inner</code>, we overwrite <code class="literal">test</code> neither in the function <code class="literal">outer</code>, nor in the global scope. We can get read access to those names if we use them in a nested scope that doesn't define them, but we cannot modify them because, when we write an assignment instruction, we're actually defining a new name in the current scope.</p><p>How do we change this behavior? Well, we can use the <code class="literal">nonlocal</code> statement. According to the official documentation:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"The <code class="literal">nonlocal</code> statement causes the listed identifiers to refer to previously bound variables in the nearest enclosing scope excluding globals."</em></span></p></blockquote></div><p>Let's introduce it in the function <code class="literal">inner</code>, and see what happens:</p><p>
<code class="literal">scoping.level.2.nonlocal.py</code>
</p><div class="informalexample"><pre class="programlisting">def outer():
    test = 1  # outer scope

    def inner():
        <span class="strong"><strong>nonlocal test</strong></span>
        test = 2  <span class="strong"><strong># nearest enclosing scope</strong></span>
        print('inner:', test)
    inner()
    print('outer:', test)

test = 0  # global scope
outer()
print('global:', test)</pre></div><p>Notice how in the body of the function <code class="literal">inner</code> I have declared the <code class="literal">test</code> name to be <code class="literal">nonlocal</code>. Running this code produces the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python scoping.level.2.nonlocal.py </strong></span>
<span class="strong"><strong>inner: 2</strong></span>
<span class="strong"><strong>outer: 2</strong></span>
<span class="strong"><strong>global: 0</strong></span>
</pre></div><p>Wow, look at that result! It means that, by declaring <code class="literal">test</code> to be <code class="literal">nonlocal</code> in the function <code class="literal">inner</code>, we actually get to bind the name <code class="literal">test</code> to that declared in the function <code class="literal">outer</code>. If we removed the <code class="literal">nonlocal</code> <code class="literal">test</code> line from the function <code class="literal">inner</code> and tried the same trick in the function <code class="literal">outer</code>, we would get a <code class="literal">SyntaxError</code>, because the <code class="literal">nonlocal</code> statement works on enclosing scopes excluding the global one.</p><p>Is <a id="id257" class="indexterm"/>there a way to get to that <code class="literal">test = 0</code> in the global namespace then? Of course, we just need to use the <code class="literal">global</code> statement. Let's try it.</p><p>
<code class="literal">scoping.level.2.global.py</code>
</p><div class="informalexample"><pre class="programlisting">def outer():
    test = 1  # outer scope

    def inner():
        <span class="strong"><strong>global test</strong></span>
        test = 2  <span class="strong"><strong># global scope</strong></span>
        print('inner:', test)
    inner()
    print('outer:', test)

test = 0  # global scope
outer()
print('global:', test)</pre></div><p>Note that we have now declared the name <code class="literal">test</code> to be <code class="literal">global</code>, which will basically bind it to the one we defined in the global namespace (<code class="literal">test = 0</code>). Run the code and you should get the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python scoping.level.2.global.py</strong></span>
<span class="strong"><strong>inner: 2</strong></span>
<span class="strong"><strong>outer: 1</strong></span>
<span class="strong"><strong>global: 2</strong></span>
</pre></div><p>This shows that the name affected by the assignment <code class="literal">test = 2</code> is now the <code class="literal">global</code> one. This trick would also work in the <code class="literal">outer</code> function because, in this case, we're referring to the global scope. Try it for yourself and see what changes, get comfortable with scopes and name resolution, it's very important.</p></div></div>
<div class="section" title="Input parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Input parameters</h1></div></div></div><p>At the <a id="id258" class="indexterm"/>beginning of this chapter, we saw that a function can take input parameters. Before we delve into all possible type of parameters, let's make sure you have a clear understanding of what passing a parameter to a function means. There are three key points to keep in mind:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Argument passing is nothing more than assigning an object to a local variable name</li><li class="listitem" style="list-style-type: disc">Assigning an object to an argument name inside a function doesn't affect the caller</li><li class="listitem" style="list-style-type: disc">Changing a mutable object argument in a function affects the caller</li></ul></div><p>Let's <a id="id259" class="indexterm"/>look at an example for each of these points.</p><div class="section" title="Argument passing"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Argument passing</h2></div></div></div><p>Take <a id="id260" class="indexterm"/>a look at the following code. We declare a name <code class="literal">x</code> in the global scope, then we declare a function <code class="literal">func(y)</code> and we call it, passing <code class="literal">x</code>. I highlighted the call in the code.</p><p>
<code class="literal">key.points.argument.passing.py</code>
</p><div class="informalexample"><pre class="programlisting">x = 3
def func(y):
    print(y)
<span class="strong"><strong>func(x)</strong></span>  # prints: 3</pre></div><p>When <code class="literal">func</code> is called with <code class="literal">x</code>, what happens is that within its local scope, a name <code class="literal">y</code> is created, and it's pointed to the same object <code class="literal">x</code> is pointing to. This is better clarified by the following picture:</p><div class="mediaobject"><img src="graphics/4715_04_02.jpg" alt="Argument passing"/></div><p>The right part of the preceding picture depicts the state of the program when execution has reached the end, after <code class="literal">func</code> has returned (<code class="literal">None</code>). Take a look at the <span class="strong"><strong>Frames</strong></span> column, and note that we have two names, <span class="strong"><strong>x</strong></span> and <span class="strong"><strong>func</strong></span>, in the global namespace (<span class="strong"><strong>Global frame)</strong></span>, pointing to an <span class="strong"><strong>int</strong></span> (with a value of three) and to a function object, respectively. Right below it, in the rectangle titled <span class="strong"><strong>func</strong></span>, we can see the function's local namespace, in which only one name has been defined: <span class="strong"><strong>y</strong></span>. Because we have called <span class="strong"><strong>func</strong></span> with <span class="strong"><strong>x</strong></span> (line 5 in the left part of the picture), <span class="strong"><strong>y</strong></span> is pointing to the same object that <span class="strong"><strong>x</strong></span> is pointing to. This is what happens under the hood when an argument is passed to a function. If we had used the name <span class="strong"><strong>x</strong></span> instead of <span class="strong"><strong>y</strong></span> in the function definition, things would have been exactly the same (only maybe a bit confusing at first), there would be a local <span class="strong"><strong>x</strong></span> in the function, and a global <span class="strong"><strong>x</strong></span> outside, as we saw in the <span class="emphasis"><em>Scopes and name resolution</em></span> section.</p><p>So, in a<a id="id261" class="indexterm"/> nutshell, what really happens is that the function creates in its local scope the names defined as arguments and, when we call it, we basically tell Python which objects those names must be pointed towards.</p></div><div class="section" title="Assignment to argument names don't affect the caller"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Assignment to argument names don't affect the caller</h2></div></div></div><p>This <a id="id262" class="indexterm"/>is something that can be tricky to understand at first, so let's look at an example.</p><p>
<code class="literal">key.points.assignment.py</code>
</p><div class="informalexample"><pre class="programlisting">x = 3
def func(x):
    <span class="strong"><strong>x = 7  # defining a local x, not changing the global one</strong></span>

func(x)
print(x)  # prints: 3</pre></div><p>In the preceding code, when the line <code class="literal">x = 7</code> is executed, what happens is that within the local scope of the function <code class="literal">func</code>, the name <code class="literal">x</code> is pointed to an integer with value 7, leaving the global <code class="literal">x</code> unaltered.</p></div><div class="section" title="Changing a mutable affects the caller"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Changing a mutable affects the caller</h2></div></div></div><p>This is <a id="id263" class="indexterm"/>the final point, and it's very important because Python apparently behaves differently with mutables (just apparently though). Let's look at an example:</p><p>
<code class="literal">key.points.mutable.py</code>
</p><div class="informalexample"><pre class="programlisting">x = [1, 2, 3]
def func(x):
    <span class="strong"><strong>x[1] = 42  # this affects the caller!</strong></span>

func(x)
print(x)  # prints: [1, 42, 3]</pre></div><p>Wow, we actually changed the original object! If you think about it, there is nothing weird in this behavior. The name <code class="literal">x</code> in the function is set to point to the caller object by the function call and within the body of the function, we're not changing <code class="literal">x</code>, in that we're not changing its reference, or, in other words, we are not changing the object <code class="literal">x</code> is pointing to. What we're doing is accessing that object's element at position 1, and changing its value.</p><p>Remember point #2: "<span class="emphasis"><em>Assigning an object to an argument name within a function doesn't affect the caller</em></span>". If that is clear to you, the following code should not be surprising.</p><p>
<code class="literal">key.points.mutable.assignment.py</code>
</p><div class="informalexample"><pre class="programlisting">x = [1, 2, 3]
def func(x):
    <span class="strong"><strong>x[1] = 42</strong></span>  # this changes the caller!
    <span class="strong"><strong>x = 'something else'</strong></span>  # this points x to a new string object

func(x)
print(x)  # still prints: [1, 42, 3]</pre></div><p>Take <a id="id264" class="indexterm"/>a look at the two lines I have highlighted. At first, we just access the caller object again, at position 1, and change its value to number 42. Then, we reassign <code class="literal">x</code> to point to the string <code class="literal">'something else'</code>. This leaves the caller unaltered, according to point #2, and, in fact, the output is the same as that of the previous snippet.</p><p>Take your time to play around with this concept and experiment with prints and calls to the <code class="literal">id</code> function until everything is clear in your mind. This is one of the key aspects of Python and it must be very clear, otherwise you risk introducing subtle bugs into your code.</p><p>Now that we have a good understanding of input parameters and how they behave, let's see how we can specify them.</p></div><div class="section" title="How to specify input parameters"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec65"/>How to specify input parameters</h2></div></div></div><p>There <a id="id265" class="indexterm"/>are five different ways of specifying input parameters. Let's look at them one by one.</p><div class="section" title="Positional arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Positional arguments</h3></div></div></div><p>Positional <a id="id266" class="indexterm"/>arguments are read from left to right and they are the most common type of arguments.</p><p>
<code class="literal">arguments.positional.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(<span class="strong"><strong>a, b, c</strong></span>):
    print(a, b, c)
func(<span class="strong"><strong>1, 2, 3</strong></span>)  # prints: 1 2 3</pre></div><p>There is not much else to say. They can be as numerous as you want and they are assigned by position. In the function call, <code class="literal">1</code> comes first, <code class="literal">2</code> comes second and <code class="literal">3</code> comes third, therefore they are assigned to <code class="literal">a</code>, <code class="literal">b</code> and <code class="literal">c</code> respectively.</p></div><div class="section" title="Keyword arguments and default values"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Keyword arguments and default values</h3></div></div></div><p>
<span class="strong"><strong>Keyword arguments</strong></span> are<a id="id267" class="indexterm"/> assigned by keyword using the <code class="literal">name=value</code> syntax.</p><p>
<code class="literal">arguments.keyword.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(a, b, c):
    print(a, b, c)
func(<span class="strong"><strong>a=1, c=2, b=3</strong></span>)  # prints: 1 3 2</pre></div><p>Keyword <a id="id268" class="indexterm"/>arguments act when calling the function instead<a id="id269" class="indexterm"/> of respecting the left-to-right positional assignment, k. Keyword arguments are matched by name, even when they don't respect the definition's original position (we'll see that there is a limitation to this behavior later, when we mix and match different types of arguments).</p><p>The <a id="id270" class="indexterm"/>counterpart of keyword arguments, on the definition side, is <span class="strong"><strong>default values</strong></span>. The syntax is the same, <code class="literal">name=value</code>, and allows us to not have to provide an argument if we are happy with the given default.</p><p>
<code class="literal">arguments.default.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(<span class="strong"><strong>a, b=4, c=88</strong></span>):
    print(a, b, c)

func(1)              # prints: 1 4 88
func(b=5, a=7, c=9)  # prints: 7 5 9
func(42, c=9)        # prints: 42 4 9</pre></div><p>The are two things to notice, which are very important. First of all, you cannot specify a default argument on the left of a positional one. Second, note how in the examples, when an argument is passed without using the <code class="literal">argument_name=value</code> syntax, it must be the first one in the list,, and it is always assigned to <code class="literal">a</code>. Try and scramble those arguments and see what happens. Python error messages are very good at telling you what's wrong. So, for example, if you tried something like this:</p><div class="informalexample"><pre class="programlisting">func(b=1, c=2, 42)  # positional argument after keyword one</pre></div><p>You would get the following error:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>SyntaxError: non-keyword arg after keyword arg</strong></span>
</pre></div><p>This informs you that you've called the function incorrectly.</p></div><div class="section" title="Variable positional arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Variable positional arguments</h3></div></div></div><p>Sometimes<a id="id271" class="indexterm"/> you may want to pass a variable number of positional arguments to a function and Python provides you with the ability to do it. Let's look at a very common use case, the <code class="literal">minimum</code> function. This is a function that calculates the minimum of its input values.</p><p>
<code class="literal">arguments.variable.positional.py</code>
</p><div class="informalexample"><pre class="programlisting">def minimum(<span class="strong"><strong>*n</strong></span>):
    # print(n)  # n is a tuple
    if n:  # explained after the code
        mn = n[0]
        for value in n[1:]:
            if value &lt; mn:
                mn = value
        print(mn)

minimum(1, 3, -7, 9)  # n = (1, 3, -7, 9) - prints: -7
minimum()             # n = () - prints: nothing</pre></div><p>As you<a id="id272" class="indexterm"/> can see, when we specify a parameter prepending a <code class="literal">*</code> to its name, we are telling Python that that parameter will be collecting a variable number of positional arguments, according to how the function is called. Within the function, <code class="literal">n</code> is a tuple. Uncomment the <code class="literal">print(n)</code> to see for yourself and play around with it for a bit.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>Have you noticed how we checked if <code class="literal">n</code> wasn't empty with a simple <code class="literal">if n:</code>? This is due to the fact that collection objects evaluate to <code class="literal">True</code> when non-empty, and otherwise <code class="literal">False</code> in Python. This is true for tuples, sets, lists, dictionaries, and so on.</p><p>One other thing to note is that we may want to throw an error when we call the function with no arguments, instead of silently doing nothing. In this context, we're not concerned about making this function robust, but in understanding variable positional arguments.</p></div></div><p>Let's make another example to show you two things that, in my experience, are confusing to those who are new to this.</p><p>
<code class="literal">arguments.variable.positional.unpacking.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(*args):
    print(args)

values = (1, 3, -7, 9)
func(<span class="strong"><strong>values</strong></span>)   # equivalent to: <span class="strong"><strong>func((1, 3, -7, 9))</strong></span>
func(<span class="strong"><strong>*values</strong></span>)  # equivalent to: <span class="strong"><strong>func(1, 3, -7, 9)</strong></span>
</pre></div><p>Take a good look at the last two lines of the preceding example. In the first one, we call <code class="literal">func</code> with one argument, a four elements tuple. In the second example, by using the <code class="literal">*</code> syntax, we're<a id="id273" class="indexterm"/> doing something called <span class="strong"><strong>unpacking</strong></span>, which means that the four elements tuple is unpacked, and the function is called with four arguments: <code class="literal">1, 3, -7, 9</code>.</p><p>This behavior is part of the magic Python does to allow you to do amazing things when calling functions dynamically.</p></div><div class="section" title="Variable keyword arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec08"/>Variable keyword arguments</h3></div></div></div><p>Variable<a id="id274" class="indexterm"/> keyword arguments are very similar to variable positional arguments. The only difference is the syntax (<code class="literal">**</code> instead of <code class="literal">*</code>) and that they are collected in a dictionary. Collection and unpacking work in the same way, so let's look at an example:</p><p>
<code class="literal">arguments.variable.keyword.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(**kwargs):
    print(kwargs)
# All calls equivalent. They print: {'a': 1, 'b': 42}
func(a=1, b=42)
func(**{'a': 1, 'b': 42})
func(**dict(a=1, b=42))</pre></div><p>All the calls are equivalent in the preceding example. You can see that adding a <code class="literal">**</code> in front of the parameter name in the function definition tells Python to use that name to collect a variable number of keyword parameters. On the other hand, when we call the function, we can either pass <code class="literal">name=value</code> arguments explicitly, or unpack a dictionary using the same <code class="literal">**</code> syntax.</p><p>The reason why being able to pass a variable number of keyword parameters is so important may not be evident at the moment, so, how about a more realistic example? Let's define a function that connects to a database. We want to connect to a default database by simply calling this function with no parameters. We also want to connect to any other database by passing the function the appropriate arguments. Before you read on, spend a couple of minutes figuring out a solution by yourself.</p><p>
<code class="literal">arguments.variable.db.py</code>
</p><div class="informalexample"><pre class="programlisting">def connect(<span class="strong"><strong>**options</strong></span>):
    conn_params = {
        'host': options.get('host', '127.0.0.1'),
        'port': options.get('port', 5432),
        'user': options.get('user', ''),
        'pwd': options.get('pwd', ''),
    }
    print(conn_params)
    # we then connect to the db (commented out)
    # <span class="strong"><strong>db.connect(**conn_params)</strong></span>

connect()
connect(host='127.0.0.42', port=5433)
connect(port=5431, user='fab', pwd='gandalf')</pre></div><p>Note in the function we can prepare a dictionary of connection parameters (<code class="literal">conn_params</code>) in the function using default values as fallback, allowing them to be overwritten if they are provided in the function call. There are better ways to do this with fewer lines of code but we're not concerned with that now. Running the preceding code<a id="id275" class="indexterm"/> yields the following result:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python arguments.variable.db.py</strong></span>
<span class="strong"><strong>{'host': '127.0.0.1', 'pwd': '', 'user': '', 'port': 5432}</strong></span>
<span class="strong"><strong>{'host': '127.0.0.42', 'pwd': '', 'user': '', 'port': 5433}</strong></span>
<span class="strong"><strong>{'host': '127.0.0.1', 'pwd': 'gandalf', 'user': 'fab', 'port': 5431}</strong></span>
</pre></div><p>Note the correspondence between the function calls and the output. Note how default values are either there or overridden, according to what was passed to the function.</p></div><div class="section" title="Keyword-only arguments"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Keyword-only arguments</h3></div></div></div><p>Python<a id="id276" class="indexterm"/> 3 allows for a new type of parameter: the <span class="strong"><strong>keyword-only</strong></span> parameter. We are going to study them only briefly as their use cases <a id="id277" class="indexterm"/>are not that frequent. There are two ways of specifying them, either after the variable positional arguments, or after a bare *. Let's see an example of both.</p><p>
<code class="literal">arguments.keyword.only.py</code>
</p><div class="informalexample"><pre class="programlisting">def <span class="strong"><strong>kwo(*a, c)</strong></span>:
    print(a, c)

kwo(1, 2, 3, c=7)  # prints: (1, 2, 3) 7
kwo(c=4)           # prints: () 4
# kwo(1, 2)  # breaks, invalid syntax, with the following error
# TypeError: kwo() missing 1 required keyword-only argument: 'c'

def <span class="strong"><strong>kwo2(a, b=42, *, c)</strong></span>:
    print(a, b, c)

kwo2(3, b=7, c=99)  # prints: 3 7 99
kwo2(3, c=13)       # prints: 3 42 13
# kwo2(3, 23)  # breaks, invalid syntax, with the following error
# TypeError: kwo2() missing 1 required keyword-only argument: 'c'</pre></div><p>As anticipated, the function, <code class="literal">kwo</code>, takes a variable number of positional arguments (<code class="literal">a</code>) and a keyword-only function, <code class="literal">c</code>. The results of the calls are straightforward and you can uncomment the third call to see what error Python returns.</p><p>The same applies to the function, <code class="literal">kwo2</code>, which differs from <code class="literal">kwo</code> in that it takes a positional argument <code class="literal">a</code>, a keyword argument <code class="literal">b</code>, and then a keyword-only argument, <code class="literal">c</code>. You can uncomment the third call to see the error.</p><p>Now that you know how to specify different types of input parameters, let's see how you can combine them in function definitions.</p></div><div class="section" title="Combining input parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec10"/>Combining input parameters</h3></div></div></div><p>You can<a id="id278" class="indexterm"/> combine input parameters, as long as you follow these ordering rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When defining a function, normal positional arguments come first (<code class="literal">name</code>), then any default arguments (<code class="literal">name=value</code>), then the variable positional arguments (<code class="literal">*name</code>, or simply <code class="literal">*</code>), then any keyword-only arguments (either <code class="literal">name</code> or <code class="literal">name=value</code> form is good), then any variable keyword arguments (<code class="literal">**name</code>).</li><li class="listitem" style="list-style-type: disc">On the other hand, when calling a function, arguments must be given in the following order: positional arguments first (<code class="literal">value</code>), then any combination of keyword arguments (<code class="literal">name=value</code>), variable positional arguments (<code class="literal">*name</code>), then variable keyword arguments (<code class="literal">**name</code>).</li></ul></div><p>Since this can be a bit tricky when left hanging in the theoretical world, let's look at a couple of quick examples.</p><p>
<code class="literal">arguments.all.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(a, b, c=7, *args, **kwargs):
    print('a, b, c:', a, b, c)
    print('args:', args)
    print('kwargs:', kwargs)

func(1, 2, 3, *(5, 7, 9), **{'A': 'a', 'B': 'b'})
func(1, 2, 3, 5, 7, 9, A='a', B='b')  # same as previous one</pre></div><p>Note the order of the parameters in the function definition, and that the two calls are equivalent. In the first one, we're using the unpacking operators for iterables and dictionaries, while in the second one we're using a more explicit syntax. The execution of this yields (I printed only the result of one call):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python arguments.all.py </strong></span>
<span class="strong"><strong>a, b, c: 1 2 3</strong></span>
<span class="strong"><strong>args: (5, 7, 9)</strong></span>
<span class="strong"><strong>kwargs: {'A': 'a', 'B': 'b'}</strong></span>
</pre></div><p>Let's now look at an example with keyword-only arguments.</p><p>
<code class="literal">arguments.all.kwonly.py</code>
</p><div class="informalexample"><pre class="programlisting">def func_with_kwonly(a, b=42, *args, <span class="strong"><strong>c, d=256</strong></span>, **kwargs):
    print('a, b:', a, b)
    print('c, d:', c, d)
    print('args:', args)
    print('kwargs:', kwargs)

# both calls equivalent
func_with_kwonly(3, 42, c=0, d=1, *(7, 9, 11), e='E', f='F')
func_with_kwonly(3, 42, *(7, 9, 11), c=0, d=1, e='E', f='F')</pre></div><p>Note that I have highlighted the keyword-only arguments in the function declaration. They <a id="id279" class="indexterm"/>come after the variable positional argument <code class="literal">*args</code>, and it would be the same if they came right after a single <code class="literal">*</code> (in which case there wouldn't be a variable positional argument). The execution of this yields (I printed only the result of one call):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python arguments.all.kwonly.py</strong></span>
<span class="strong"><strong>a, b: 3 42</strong></span>
<span class="strong"><strong>c, d: 0 1</strong></span>
<span class="strong"><strong>args: (7, 9, 11)</strong></span>
<span class="strong"><strong>kwargs: {'f': 'F', 'e': 'E'}</strong></span>
</pre></div><p>One other thing to note are the names I gave to the variable positional and keyword arguments. You're free to choose differently, but be aware that <code class="literal">args</code> and <code class="literal">kwargs</code> are the conventional names given to these parameters, at least generically. Now that you know how to define a function in all possible flavors, let me show you something tricky: mutable defaults.</p></div><div class="section" title="Avoid the trap! Mutable defaults"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec11"/>Avoid the trap! Mutable defaults</h3></div></div></div><p>One <a id="id280" class="indexterm"/>thing to be very aware of with Python is that default values are created at <code class="literal">def</code> time, therefore, subsequent calls to the same function will possibly behave differently according to the mutability of their default values. Let's look at an example:</p><p>
<code class="literal">arguments.defaults.mutable.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(<span class="strong"><strong>a=[], b={}</strong></span>):
    print(a)
    print(b)
    print('#' * 12)
    a.append(len(a))  # this will affect a's default value
    b[len(a)] = len(a)  # and this will affect b's one

func()
func()
func()</pre></div><p>The parameters both have mutable default values. This means that, if you affect those objects, any modification will stick around in subsequent function calls. See if you can understand the output of those calls:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python arguments.defaults.mutable.py</strong></span>
<span class="strong"><strong>[]</strong></span>
<span class="strong"><strong>{}</strong></span>
<span class="strong"><strong>############</strong></span>
<span class="strong"><strong>[0]</strong></span>
<span class="strong"><strong>{1: 1}</strong></span>
<span class="strong"><strong>############</strong></span>
<span class="strong"><strong>[0, 1]</strong></span>
<span class="strong"><strong>{1: 1, 2: 2}</strong></span>
<span class="strong"><strong>############</strong></span>
</pre></div><p>It's<a id="id281" class="indexterm"/> interesting, isn't it? While this behavior may seem very weird at first, it actually makes sense, and it's very handy, for example, when using memoization techniques (Google an example of that, if you're interested).</p><p>Even more interesting is what happens when, between the calls, we introduce one that doesn't use defaults, like this:</p><p>
<code class="literal">arguments.defaults.mutable.intermediate.call.py</code>
</p><div class="informalexample"><pre class="programlisting">func()
func(a=[1, 2, 3], b={'B': 1})
func()</pre></div><p>When we run this code, this is the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python arguments.defaults.mutable.intermediate.call.py </strong></span>
<span class="strong"><strong>[]</strong></span>
<span class="strong"><strong>{}</strong></span>
<span class="strong"><strong>############</strong></span>
<span class="strong"><strong>[1, 2, 3]</strong></span>
<span class="strong"><strong>{'B': 1}</strong></span>
<span class="strong"><strong>############</strong></span>
<span class="strong"><strong>[0]</strong></span>
<span class="strong"><strong>{1: 1}</strong></span>
<span class="strong"><strong>############</strong></span>
</pre></div><p>This output shows us that the defaults are retained even if we call the function with other values. One question that comes to mind is, how do I get a fresh empty value every time? Well, the convention is the following:</p><p>
<code class="literal">arguments.defaults.mutable.no.trap.py</code>
</p><div class="informalexample"><pre class="programlisting">def func(<span class="strong"><strong>a=None</strong></span>):
    <span class="strong"><strong>if a is None:</strong></span>
<span class="strong"><strong>        a = []</strong></span>
    # do whatever you want with `a` ...</pre></div><p>Note that, by using the preceding technique, if <code class="literal">a</code> isn't passed when calling the function, you always get a brand new empty list.</p><p>Okay, enough with the input, let's look at the other side of the coin, the output.</p></div></div></div>
<div class="section" title="Return values"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Return values</h1></div></div></div><p>Return <a id="id282" class="indexterm"/>values of functions are one of those things where Python is light years ahead of most other languages. Functions are usually allowed to return one object (one value) but, in Python, you can return a tuple, and this implies that you can return whatever you want. This feature allows a coder to write software that would be much harder to write in any other language, or certainly more tedious. We've already said that to return something from a function we need to use the <code class="literal">return</code> statement, followed by what we want to return. There can be as many return statements as needed in the body of a function.</p><p>On the other hand, if within the body of a function we don't return anything, the function will return <code class="literal">None</code>. This behavior is harmless and, even though I don't have the room here to go into detail explaining why Python was designed like this, let me just tell you that this feature allows for several interesting patterns, and confirms Python as a very consistent language.</p><p>I say it's harmless because you are never forced to collect the result of a function call. I'll show you what I mean with an example:</p><p>
<code class="literal">return.none.py</code>
</p><div class="informalexample"><pre class="programlisting">def func():
    <span class="strong"><strong>pass</strong></span>
func()  # the return of this call won't be collected. It's lost.
a = func()  # the return of this one instead is collected into `a`
print(a)  # <span class="strong"><strong>prints: None</strong></span>
</pre></div><p>Note that the whole body of the function is comprised only of the <code class="literal">pass</code> statement. As the official documentation tells us, <code class="literal">pass</code> is a null operation. When it is executed, nothing happens. It is useful as a placeholder when a statement is required syntactically, but no code needs to be executed. In other languages, we would probably just indicate that with a pair of curly braces (<code class="literal">{}</code>), which define an <span class="emphasis"><em>empty scope</em></span> but in Python a scope is defined by indenting code, therefore a statement such as <code class="literal">pass</code> is necessary.</p><p>Notice also that the first call of the function <code class="literal">func</code> returns a value (<code class="literal">None</code>) which we don't collect. As I said before, collecting the return value of a function call is not mandatory.</p><p>Now, that's good but not very interesting so, how about we write an interesting function? Remember that in <a class="link" href="ch01.html" title="Chapter 1. Introduction and First Steps – Take a Deep Breath">Chapter 1</a>, <span class="emphasis"><em>Introduction and First Steps – Take a Deep Breath</em></span>, we talked about the factorial of a function. Let's write our own here (for simplicity, I will assume the function is always called correctly with appropriate values so I won't sanity-check on the input argument):</p><p>
<code class="literal">return.single.value.py</code>
</p><div class="informalexample"><pre class="programlisting">def factorial(n):
    if n in (0, 1):
        <span class="strong"><strong>return 1</strong></span>
    result = n
    for k in range(2, n):
        result *= k
    <span class="strong"><strong>return result</strong></span>

f5 = factorial(5)  # f5 = 120</pre></div><p>Note <a id="id283" class="indexterm"/>that we have two points of return. If <code class="literal">n</code> is either <code class="literal">0</code> or <code class="literal">1</code> (in Python it's common to use the <code class="literal">in</code> type of check as I did instead of the more verbose <code class="literal">if n ==0 or n == 1:</code>), we return <code class="literal">1</code>. Otherwise, we perform the required calculation, and we return <code class="literal">result</code>. Can we write this function a little bit more Pythonically? Yes, but I'll let you figure out that for yourself, as an exercise.</p><p>
<code class="literal">return.single.value.2.py</code>
</p><div class="informalexample"><pre class="programlisting">from functools import reduce
from operator import mul

def factorial(n):
    return <span class="strong"><strong>reduce(mul, range(1, n + 1), 1)</strong></span>
f5 = factorial(5)  # f5 = 120</pre></div><p>I know what you're thinking, one line? Python is elegant, and concise! I think this function is readable even if you have never seen <code class="literal">reduce</code> or <code class="literal">mul</code>, but if you can't read it or understand it, set aside a few minutes and do some research on the Python documentation until its behavior is clear to you. Being able to look up functions in the documentation and understand code written by someone else is a task every developer needs to be able to perform, so think of this as a good exercise, and good luck!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>To this end, make sure you look up the <code class="literal">help</code> function, which comes in very handy exploring with the console.</p></div></div><div class="section" title="Returning multiple values"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec66"/>Returning multiple values</h2></div></div></div><p>Unlike in<a id="id284" class="indexterm"/> most other languages, in Python it's very easy to return multiple objects from a function. This feature opens up a whole world of possibilities and allows you to code in a style that is hard to reproduce with other languages. Our thinking is limited by the tools we use, therefore when Python gives you more freedom than other languages, it is actually boosting your own creativity as well. To return multiple values is very easy, you just use tuples (either explicitly or implicitly). Let's look at a simple example that mimics the <code class="literal">divmod</code> built-in function:</p><p>
<code class="literal">return.multiple.py</code>
</p><div class="informalexample"><pre class="programlisting">def moddiv(a, b):
    return <span class="strong"><strong>a // b, a % b</strong></span>

print(moddiv(20, 7))  # prints (2, 6)</pre></div><p>I could have wrapped the highlighted part in the preceding code in braces, making it an explicit<a id="id285" class="indexterm"/> tuple, but there's no need for that. The preceding function returns both the result and the remainder of the division, at the same time.</p></div></div>
<div class="section" title="A few useful tips"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>A few useful tips</h1></div></div></div><p>When <a id="id286" class="indexterm"/>writing functions, it's very useful to follow guidelines so that you write them well. I'll quickly point some of them out here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functions should do one thing</strong></span>: Functions that do one thing are easy to describe in one short sentence. Functions which do multiple things can be split into smaller functions which do one thing. These smaller functions are usually easier to read and understand. Remember the data science example we saw a few pages ago.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functions should be small</strong></span>: The smaller they are, the easier it is to test them and to write them so that they do one thing.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The fewer input parameters, the better</strong></span>: Functions which take a lot of arguments quickly become harder to manage (among other issues).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functions should be consistent in their return values</strong></span>: Returning <code class="literal">False</code> or <code class="literal">None</code> is not the same thing, even if within a Boolean context they both evaluate to <code class="literal">False</code>. <code class="literal">False</code> means that we have information (<code class="literal">False</code>), while <code class="literal">None</code> means that there is no information. Try writing functions which return in a consistent way, no matter what happens in their body.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Functions shouldn't have side effects</strong></span>: In other words, functions should not affect the values you call them with. This is probably the hardest statement to understand at this point, so I'll give you an example using lists. In the following code, note how <code class="literal">numbers</code> is not sorted by the <code class="literal">sorted</code> function, which actually returns a sorted copy of <code class="literal">numbers</code>. Conversely, the <code class="literal">list.sort()</code> method is acting on the <code class="literal">numbers</code> object itself, and that is fine because it is a method (a function that belongs to an object and therefore has the rights to modify it):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; numbers = [4, 1, 7, 5]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; sorted(numbers)  # won't sort the original `numbers` list</strong></span>
<span class="strong"><strong>[1, 4, 5, 7]</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; numbers  # let's verify</strong></span>
<span class="strong"><strong>[4, 1, 7, 5]  # good, untouched</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; numbers.sort()  # this will act on the list</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; numbers</strong></span>
<span class="strong"><strong>[1, 4, 5, 7]</strong></span>
</pre></div></li></ul></div><p>Follow<a id="id287" class="indexterm"/> these guidelines and you'll write better functions, which will serve you well.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>
<span class="emphasis"><em>Chapter 3</em></span>, <span class="emphasis"><em>Functions</em></span> in <span class="emphasis"><em>Clean Code</em></span> by Robert C. Martin, Prentice Hall is dedicated to functions and it's probably the best set of guidelines I've ever read on the subject.</p></div></div></div>
<div class="section" title="Recursive functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Recursive functions</h1></div></div></div><p>When a<a id="id288" class="indexterm"/> function calls itself to produce a result, it is said to be <span class="strong"><strong>recursive</strong></span>. Sometimes recursive functions are very useful in that they make it easier to write code. Some algorithms are very easy to write using the recursive paradigm, while others are not. There is no recursive function that cannot be rewritten in an iterative fashion, so it's usually up to the programmer to choose the best approach for the case at hand.</p><p>A recursive function usually has a set of base cases for which the return value doesn't depend on a subsequent call to the function itself and a set of recursive cases, for which the return value is calculated with one or more calls to the function itself.</p><p>As an example, we can consider the (hopefully familiar by now) <code class="literal">factorial</code> function <span class="emphasis"><em>N!</em></span>. The base case is when <span class="emphasis"><em>N</em></span> is either 0 or 1. The function returns 1 with no need for further calculation. On the other hand, in the general case, <span class="emphasis"><em>N!</em></span> returns the product <span class="emphasis"><em>1 * 2 * ... * (N-1) * N</em></span>. If you think about it, <span class="emphasis"><em>N!</em></span> can be rewritten like this: <span class="emphasis"><em>N! = (N-1)! * N</em></span>. As a practical example, consider <span class="emphasis"><em>5! = 1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5</em></span>.</p><p>Let's write this down in code:</p><p>
<code class="literal">recursive.factorial.py</code>
</p><div class="informalexample"><pre class="programlisting">def factorial(n):
    if n in (0, 1):  # base case
        return <span class="strong"><strong>1</strong></span>
    return <span class="strong"><strong>factorial(n - 1) * n</strong></span>  # recursive case</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>When writing recursive functions, always consider how many nested calls you make, there is a limit. For further information on this, check out <code class="literal">sys.getrecursionlimit()</code> and <code class="literal">sys.setrecursionlimit()</code>.</p></div></div><p>Recursive<a id="id289" class="indexterm"/> functions are used a lot when writing algorithms and they can be really fun to write. As a good exercise, try to solve a couple of simple problems using both a recursive and an iterative approach.</p></div>
<div class="section" title="Anonymous functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Anonymous functions</h1></div></div></div><p>One<a id="id290" class="indexterm"/> last type of functions that I want to talk about are <span class="strong"><strong>anonymous</strong></span> functions. These functions, which are called <span class="strong"><strong>lambdas</strong></span> in Python, are usually <a id="id291" class="indexterm"/>used when a fully-fledged function with its own name would be overkill, and all we want is a quick, simple one-liner that does the job.</p><p>Imagine that you want a list of all the numbers up to <span class="emphasis"><em>N</em></span> which are multiples of five. Imagine that you want to filter those out using the <code class="literal">filter</code> function, which takes a function and an iterable and constructs a filter object which you can iterate on, from those elements of iterable for which the function returns <code class="literal">True</code>. Without using an anonymous function, you would do something like this:</p><p>
<code class="literal">filter.regular.py</code>
</p><div class="informalexample"><pre class="programlisting">def is_multiple_of_five(n):
    return not n % 5
def get_multiples_of_five(n):
    return list(<span class="strong"><strong>filter(is_multiple_of_five, range(n))</strong></span>)
print(get_multiples_of_five(50))</pre></div><p>I have highlighted the main logic of <code class="literal">get_multiples_of_five</code>. Note how the filter uses <code class="literal">is_multiple_of_five</code> to filter the first <span class="emphasis"><em>n</em></span> natural numbers. This seems a bit excessive, the task is simple and we don't need to keep the <code class="literal">is_multiple_of_five</code> function around for anything else. Let's rewrite it using a lambda function:</p><p>
<code class="literal">filter.lambda.py</code>
</p><div class="informalexample"><pre class="programlisting">def get_multiples_of_five(n):
    return list(filter(<span class="strong"><strong>lambda k: not k % 5</strong></span>, range(n)))
print(get_multiples_of_five(50))</pre></div><p>The logic is exactly the same but the filtering function is now a lambda. Defining a lambda is very easy and follows this form: <code class="literal">func_name = lambda [parameter_list]: expression</code>. A function object is returned, which is equivalent to this: <code class="literal">def func_name([parameter_list]): return expression</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Note that optional parameters are indicated following the common syntax of wrapping them in square brackets.</p></div></div><p>Let's look at another couple of examples of equivalent functions defined in the two forms:</p><p>
<code class="literal">lambda.explained.py</code>
</p><div class="informalexample"><pre class="programlisting"># example 1: adder
<span class="strong"><strong>def adder(a, b):</strong></span>
<span class="strong"><strong>    return a + b</strong></span>
# is equivalent to:
adder_lambda = <span class="strong"><strong>lambda a, b: a + b</strong></span>

# example 2: to uppercase
<span class="strong"><strong>def to_upper(s):</strong></span>
<span class="strong"><strong>    return s.upper()</strong></span>
# is equivalent to:
to_upper_lambda = <span class="strong"><strong>lambda s: s.upper()</strong></span>
</pre></div><p>The <a id="id292" class="indexterm"/>preceding examples are very simple. The first one adds two numbers, and the second one produces the uppercase version of a string. Note that I assigned what is returned by the <code class="literal">lambda</code> expressions to a name (<code class="literal">adder_lambda</code>, <code class="literal">to_upper_lambda</code>), but there is no need for that when you use lambdas in the way we did in the <code class="literal">filter</code> example before.</p></div>
<div class="section" title="Function attributes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Function attributes</h1></div></div></div><p>Every<a id="id293" class="indexterm"/> function is a fully-fledged object and, as such, they have many attributes. Some of them are special and can be used in an introspective way to inspect the function object at runtime. The following script is an example that shows all of them and how to display their value for an example function:</p><p>
<code class="literal">func.attributes.py</code>
</p><div class="informalexample"><pre class="programlisting">def multiplication(a, b=1):
    """Return a multiplied by b. """
    return a * b

special_attributes = [
    "__doc__", "__name__", "__qualname__", "__module__",
    "__defaults__", "__code__", "__globals__", "__dict__",
    "__closure__", "__annotations__", "__kwdefaults__",
]

for attribute in special_attributes:
    print(attribute, '-&gt;', <span class="strong"><strong>getattr</strong></span>(multiplication, attribute))</pre></div><p>I used the built-in <code class="literal">getattr</code> function to get the value of those attributes. <code class="literal">getattr(obj, attribute)</code> is equivalent to <code class="literal">obj.attribute</code> and comes in handy when we need to get an attribute at runtime using its string name. Running this script yields:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python func.attributes.py </strong></span>
<span class="strong"><strong>__doc__ -&gt; Return a multiplied by b. </strong></span>
<span class="strong"><strong>__name__ -&gt; multiplication</strong></span>
<span class="strong"><strong>__qualname__ -&gt; multiplication</strong></span>
<span class="strong"><strong>__module__ -&gt; __main__</strong></span>
<span class="strong"><strong>__defaults__ -&gt; (1,)</strong></span>
<span class="strong"><strong>__code__ -&gt; &lt;code object multiplication at 0x7ff529e79300, file "ch4/func.attributes.py", line 1&gt;</strong></span>
<span class="strong"><strong>__globals__ -&gt; {... omitted ...}</strong></span>
<span class="strong"><strong>__dict__ -&gt; {}</strong></span>
<span class="strong"><strong>__closure__ -&gt; None</strong></span>
<span class="strong"><strong>__annotations__ -&gt; {}</strong></span>
<span class="strong"><strong>__kwdefaults__ -&gt; None</strong></span>
</pre></div><p>I have <a id="id294" class="indexterm"/>omitted the value of the <code class="literal">__globals__</code> attribute, it was too big. An explanation of the meaning of this attribute can be found in the <span class="emphasis"><em>types</em></span> section of the <span class="emphasis"><em>Python Data Model</em></span> documentation page.</p></div>
<div class="section" title="Built-in functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Built-in functions</h1></div></div></div><p>Python <a id="id295" class="indexterm"/>comes with a lot of built-in functions. They are available anywhere and you can get a list of them by inspecting the <code class="literal">builtin</code> module with <code class="literal">dir(__builtin__)</code>, or by going to the official Python documentation. Unfortunately, I don't have the room to go through all of them here. Some of them we've already seen, such as <code class="literal">any</code>, <code class="literal">bin</code>, <code class="literal">bool</code>, <code class="literal">divmod</code>, <code class="literal">filter</code>, <code class="literal">float</code>, <code class="literal">getattr</code>, <code class="literal">id</code>, <code class="literal">int</code>, <code class="literal">len</code>, <code class="literal">list</code>, <code class="literal">min</code>, <code class="literal">print</code>, <code class="literal">set</code>, <code class="literal">tuple</code>, <code class="literal">type</code>, and <code class="literal">zip</code>, but there are many more, which you should read at least once.</p><p>Get familiar with them, experiment, write a small piece of code for each of them, make sure you have them at the tip of your fingers so that you can use them when you need them.</p></div>
<div class="section" title="One final example"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec46"/>One final example</h1></div></div></div><p>Before <a id="id296" class="indexterm"/>we finish off this chapter, how about a final example? I was thinking we could write a function to generate a list of prime numbers up to a limit. We've already seen the code for this so let's make it a function and, to keep it interesting, let's optimize it a bit.</p><p>It turns out that you don't need to divide it by all numbers from 2 to <span class="emphasis"><em>N</em></span>-1 to decide if a number <span class="emphasis"><em>N</em></span> is prime. You can stop at <span class="inlinemediaobject"><img src="graphics/4715_04_04.jpg" alt="One final example"/></span>. Moreover, you don't need to test the division for all numbers from 2 to <span class="inlinemediaobject"><img src="graphics/4715_04_04.jpg" alt="One final example"/></span>, you can just use the primes in that range. I'll leave it to you to figure out why this works, if you're interested. Let's see how the code changes:</p><p>
<code class="literal">primes.py</code>
</p><div class="informalexample"><pre class="programlisting">from math import <span class="strong"><strong>sqrt, ceil</strong></span>

def get_primes(n):
    """Calculate a list of primes up to n (included). """
    primelist = []
    for candidate in range(2, n + 1):
        is_prime = True
        root = <span class="strong"><strong>int(ceil(sqrt(candidate)))</strong></span>  # division limit
        for prime in primelist:  # we try only the primes
            <span class="strong"><strong>if prime &gt; root:</strong></span>  # no need to check any further
                <span class="strong"><strong>break</strong></span>
            if candidate % prime == 0:
                is_prime = False
                break
        if is_prime:
            primelist.append(candidate)
    return primelist</pre></div><p>The<a id="id297" class="indexterm"/> code is the same as in the previous chapter. We have changed the division algorithm so that we only test divisibility using the previously calculated primes and we stopped once the testing divisor was greater than the root of the candidate. We used the result list <code class="literal">primelist</code> to get the primes for the division. We calculated the root value using a fancy formula, the integer value of the ceiling of the root of the candidate. While a simple <code class="literal">int(k ** 0.5) + 1</code> would have served our purpose as well, the formula I chose is cleaner and requires me to use a couple of imports, which I wanted to show you. Check out the functions in the <code class="literal">math</code> module, they are very interesting!</p></div>
<div class="section" title="Documenting your code"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec47"/>Documenting your code</h1></div></div></div><p>I'm a big<a id="id298" class="indexterm"/> fan of code that doesn't need documentation. When you program correctly, choose the right names and take care of the details, your code should come out as self-explanatory and documentation should not be needed. Sometimes a comment is very useful though, and so is some documentation. You can find the guidelines for documenting Python in <span class="emphasis"><em>PEP257 – Docstring conventions</em></span>, but I'll show you the basics here.</p><p>Python is documented with strings, which are aptly called <span class="strong"><strong>docstrings</strong></span>. Any object can be documented, and <a id="id299" class="indexterm"/>you can use either one-line or multi-line docstrings. One-liners are very simple. They should not provide another signature for the function, but clearly state its purpose.</p><p>
<code class="literal">docstrings.py</code>
</p><div class="informalexample"><pre class="programlisting">def square(n):
    <span class="strong"><strong>"""Return the square of a number n. """</strong></span>
    return n ** 2

def get_username(userid):
    <span class="strong"><strong>"""Return the username of a user given their id. """</strong></span>
    return db.get(user_id=userid).username</pre></div><p>Using triple double-quoted strings allows you to expand easily later on. Use sentences that end in a period, and don't leave blank lines before or after.</p><p>Multi-line<a id="id300" class="indexterm"/> comments are structured in a similar way. There should be a one-liner that briefly gives you the gist of what the object is about, and then a more verbose description. As an example, I have documented a fictitious <code class="literal">connect</code> function, using the Sphinx notation, in the following example.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>
<span class="strong"><strong>Sphinx</strong></span> is <a id="id301" class="indexterm"/>probably the most widely used tool for creating Python documentation. In fact, the official Python documentation was written with it. It's definitely worth spending some time checking it out.</p></div></div><p>
<code class="literal">docstrings.py</code>
</p><div class="informalexample"><pre class="programlisting">def connect(host, port, user, password):
    """Connect to a database.

    Connect to a PostgreSQL database directly, using the given
    parameters.

    :param host: The host IP.
    :param port: The desired port.
    :param user: The connection username.
    :param password: The connection password.
    :return: The connection object.
    """
    # body of the function here...
    return connection</pre></div></div>
<div class="section" title="Importing objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec48"/>Importing objects</h1></div></div></div><p>Now that <a id="id302" class="indexterm"/>you know a lot about functions, let's see how to use them. The whole point of writing functions is to be able to later reuse them, and this in Python translates to importing them into the namespace in which you need them. There are many different ways to import objects into a namespace, but the most common ones are just two: <code class="literal">import module_name</code> and <code class="literal">from module_name import function_name</code>. Of course, these are quite simplistic examples, but bear with me for the time being.</p><p>The form <code class="literal">import module_name</code> finds the module <code class="literal">module_name</code> and defines a name for it in the local namespace where the <code class="literal">import</code> statement is executed.</p><p>The form <code class="literal">from module_name import identifier</code> is a little bit more complicated than that, but basically does the same thing. It finds <code class="literal">module_name</code> and searches for an attribute (or a submodule) and stores a reference to <code class="literal">identifier</code> in the local namespace.</p><p>Both forms have the option to change the name of the imported object using the <code class="literal">as</code> clause, like this:</p><div class="informalexample"><pre class="programlisting">from mymodule import myfunc as better_named_func</pre></div><p>Just to give you a flavor of what importing looks like, here's an example from a test module of a number theory library I wrote some years ago (it's available on Bitbucket):</p><p>
<code class="literal">karma/test_nt.py</code>
</p><div class="informalexample"><pre class="programlisting">import unittest  # imports the unittest module
from math import sqrt  # imports one function from math
from random import randint, sample  # two imports at once

from mock import patch
from nose.tools import (  # multiline import
    assert_equal,
    assert_list_equal,
    assert_not_in,
)

from karma import nt, utils</pre></div><p>I commented some of them and I hope it's easy to follow. When you have a structure of files starting in the root of your project, you can use the dot notation to get to the object you want to import into your current namespace, be it a package, a module, a class, a function, or anything else. The <code class="literal">from module import</code> syntax also allows a catch-all clause <code class="literal">from module import *</code>, which is sometimes used to get all the names from a module into the current namespace at once, but it's frowned upon for several reasons: performances, the risk of silently shadowing other names, and so on. You can read all that there is to know about imports in the official Python documentation but, before we leave the subject, let me give you a better example.</p><p>Imagine that you have defined a couple of functions: <code class="literal">square(n)</code> and <code class="literal">cube(n)</code> in a module, <code class="literal">funcdef.py</code>, which is in the <code class="literal">lib</code> folder. You want to use them in a couple of modules which are at the same level of the <code class="literal">lib</code> folder, called <code class="literal">func_import.py</code>, and <code class="literal">func_from.py</code>. Showing the tree structure of that project produces something like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>├── func_from.py</strong></span>
<span class="strong"><strong>├── func_import.py</strong></span>
<span class="strong"><strong>├── lib</strong></span>
<span class="strong"><strong>    ├── funcdef.py</strong></span>
<span class="strong"><strong>    └── __init__.py</strong></span>
</pre></div><p>Before I show you the code of each module, please remember that in order to tell Python that it is actually a package, we need to put a <code class="literal">__init__.py</code> module in it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>There are two things to note about the <code class="literal">__init__.py</code> file. First of all, it is a fully fledged Python module so you can put code into it as you would with any other module. Second, as of Python 3.3, its presence is no longer required to make a folder be interpreted as a Python package.</p></div></div><p>The code<a id="id303" class="indexterm"/> is as follows:</p><p>
<code class="literal">funcdef.py</code>
</p><div class="informalexample"><pre class="programlisting">def square(n):
    return n ** 2
def cube(n):
    return n ** 3</pre></div><p>
<code class="literal">func_import.py</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>import lib.funcdef</strong></span>
print(lib.funcdef.square(10))
print(lib.funcdef.cube(10))</pre></div><p>
<code class="literal">func_from.py</code>
</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>from lib.funcdef import square, cube</strong></span>
print(square(10))
print(cube(10))</pre></div><p>Both these files, when executed, print <code class="literal">100</code> and <code class="literal">1000</code>. You can see how differently we then access the <code class="literal">square</code> and <code class="literal">cube</code> functions, according to how and what we imported in the current scope.</p><div class="section" title="Relative imports"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec67"/>Relative imports</h2></div></div></div><p>The <a id="id304" class="indexterm"/>imports we've seen until now are called absolute, that is to say they define the whole path of the module that we want to import, or from which we want to import an object. There is another way of importing objects into Python, which is called relative import. It's helpful in situations in which we want to rearrange the structure of large packages without having to edit sub-packages, or when we want to make a module inside a package able to import itself. Relative imports are done by adding as many leading dots in front of the module as the number of folders we need to backtrack, in order to find what we're searching for. Simply put, it is something like this:</p><div class="informalexample"><pre class="programlisting">from .mymodule import myfunc</pre></div><p>For a <a id="id305" class="indexterm"/>complete explanation of relative imports, refer to <span class="strong"><strong>PEP328</strong></span> (<a class="ulink" href="https://www.python.org/dev/peps/pep-0328">https://www.python.org/dev/peps/pep-0328</a>).</p><p>In later <a id="id306" class="indexterm"/>chapters, we'll create projects using different libraries and we'll use several different types of imports, including relative ones, so make sure you take a bit of time to read up about it in the official Python documentation.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec49"/>Summary</h1></div></div></div><p>In this chapter, finally we explored the world of functions. They are extremely important and, from now on, we'll use them basically everywhere. We talked about the main reasons for using them, the most important of which are code reuse and implementation hiding.</p><p>We saw that a function object is like a box that takes optional input and produces output. We can feed input values to a function in many different ways, using positional and keyword arguments, and using variable syntax for both types.</p><p>Now you should know how to write a function, how to document it, import it into your code, and call it.</p><p>The next chapter will force me to push my foot down on the throttle even more so I suggest you take any opportunity you get to consolidate and enrich the knowledge you've gathered until now by putting your nose into the Python official documentation.</p><p>Ready for the cool stuff? Let's go!</p></div></body></html>