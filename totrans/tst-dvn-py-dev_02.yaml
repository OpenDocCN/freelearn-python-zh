- en: Chapter 2. Red-Green-Refactor – The TDD Cycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 红-绿-重构 – TDD 循环
- en: In the previous chapter, we went through a small TDD cycle by creating a failing
    test and then making it pass. In this chapter, we are going to fill out the rest
    of the `Stock` class by writing more tests. In the process, we will dig deeper
    into the TDD cycle and the `unittest` module.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过创建一个失败的测试然后使其通过，进行了一个小的TDD循环。在这一章中，我们将通过编写更多测试来完善`Stock`类的其余部分。在这个过程中，我们将更深入地了解TDD循环和`unittest`模块。
- en: Tests are executable requirements
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试是可执行的要求
- en: In the first test, we wrote a very simple test that checked whether a new `Stock`
    class has its `price` attribute initialized to `None`. We can now think about
    what requirement we want to implement next.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次测试中，我们编写了一个非常简单的测试，用来检查新的`Stock`类是否将`price`属性初始化为`None`。我们现在可以思考接下来想要实现哪些要求。
- en: An observant reader might have caught on to the terminology used in the previous
    sentence, where I said that we can think about the requirement to implement next,
    instead of saying that we can think about the test to write next. Both statements
    are equivalent, because in TDD, tests are nothing but requirements. Each time
    we write a test and implement code to make it pass, what we actually do is make
    the code meet some requirement. Looking at it another way, tests are just executable
    requirement specifications. Requirement documentation often goes out of sync with
    what is actually implemented, but this is impossible with tests, because the moment
    they go out of sync, the test will fail.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者可能会注意到上一句中使用的术语，我说我们可以思考接下来要实现的要求，而不是说我们可以思考接下来要编写的测试。这两个陈述是等效的，因为在TDD（测试驱动开发）中，测试不过是要求。每次我们编写一个测试并实现代码使其通过，我们实际上是在使代码满足某些要求。从另一个角度来看，测试只是可执行的规格说明。需求文档往往与实际实现脱节，但测试则不可能出现这种情况，因为一旦它们脱节，测试就会失败。
- en: 'In the previous chapter, we said that the `Stock` class will be used to hold
    price information and price history for a stock symbol. This suggests that we
    need a way to set the price whenever it is updated. Let us implement an `update`
    method that meets the following requirements:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到`Stock`类将用于存储股票符号的价格信息和价格历史。这表明我们需要一种方法来设置价格，每次更新时都要使用。让我们实现一个满足以下要求的`update`方法：
- en: It should take a timestamp and price value and set it on the object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该接受时间戳和价格值，并在对象上设置它
- en: The price cannot be negative
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价格不能为负
- en: After multiple updates, the object gives us the latest price
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过多次更新后，该对象会给我们提供最新的价格
- en: Arrange-Act-Assert
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安排-行动-断言
- en: 'Let us start with the first requirement. Here is the test:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个要求开始。以下是测试代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we call the `update` method (which doesn't exist yet) with the timestamp
    and price and then check that the price has been set correctly. We use the `assertEqual`
    method provided in the `unittest.TestCase` class to assert the value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`update`方法（目前还不存在）并传入时间戳和价格，然后检查价格是否已正确设置。我们使用`unittest.TestCase`类提供的`assertEqual`方法来断言值。
- en: Since we are using the `datetime` module to set the timestamp, we will have
    to add the line `from datetime import datetime` to the top of the file before
    it will run.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`datetime`模块来设置时间戳，我们将在文件顶部添加`from datetime import datetime`这一行，以便它能够运行。
- en: This test follows the pattern of Arrange-Act-Assert.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试遵循 Arrange-Act-Assert 模式。
- en: '**Arrange**: Set up the context for the test. In this case, we create a `Stock`
    object. In other tests, it may involve creating multiple objects or hooking a
    few things together that will be required by the particular test.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**安排**：为测试设置上下文。在这种情况下，我们创建一个`Stock`对象。在其他测试中，可能需要创建多个对象或将一些东西连接起来，以便特定测试需要。'
- en: '**Act**: Perform the action that we want to test. Here, we call the `update`
    method with the appropriate arguments.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**行动**：执行我们想要测试的操作。在这里，我们使用适当的参数调用`update`方法。'
- en: '**Assert**: Finally we assert that the outcome was as expected.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**断言**：最后我们断言结果符合预期。'
- en: In this test, each part of the pattern took one line of code, but this is not
    always the case. Often there will be more than one line for each part of the test.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，模式的每一部分都占用了一行代码，但这并不总是如此。通常，测试的每一部分会有多行代码。
- en: Documenting our tests
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录我们的测试
- en: 'When we run the tests, we get the following output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，我们得到以下输出：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The test fails as expected, but the interesting thing is that the first line
    of the docstring is printed out on the fourth line. This is useful because we
    get some more information on which case is failing. This shows a second way of
    documenting out tests by using the first line for a short summary, and the rest
    of the docstring for a more detailed explanation. The detailed explanation will
    not be printed out with a test failure, so there is no problem with cluttering
    the test failure output.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试如预期失败，但有趣的是，文档字符串的第一行在第四行打印出来。这很有用，因为它提供了更多关于哪个案例失败的信息。这显示了使用第一行作为简短摘要，其余的文档字符串作为更详细解释的另一种记录测试的方法。详细的解释在测试失败时不会打印出来，所以不会影响测试失败的输出。
- en: 'We have used two ways of documenting tests:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两种测试文档的方法：
- en: Writing a descriptive test method name
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写描述性的测试方法名称
- en: Putting an explanation in the docstring
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文档字符串中添加解释
- en: Which is better? Most of the time the test is self explanatory and doesn't need
    a whole lot of background explanation. In such cases, a well named test method
    is sufficient.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个更好？大多数情况下，测试是自我解释的，不需要很多背景解释。在这种情况下，一个命名良好的测试方法就足够了。
- en: However, sometimes the test method name becomes so long that it becomes clumsy
    and actually ends up reducing the readability of the code. At other times, we
    might want to put in a more detailed explanation of what we are testing and why.
    In such cases, shortening the method name and putting the explanation in the docstring
    is a good idea.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时测试方法名称变得非常长，以至于变得笨拙，实际上降低了代码的可读性。在其他时候，我们可能想要更详细地解释我们在测试什么以及为什么测试。在这种情况下，缩短方法名称并在文档字符串中添加解释是一个好主意。
- en: 'Here is the implementation to make this test pass:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是实现通过这个测试的方法：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This minimal implementation passes the test. As with the first bit of implementation,
    we aren't trying to implement the whole functionality. We want to implement just
    enough to make the test pass. Remember, when the test passes, it means the requirement
    is met. At this point, we have two passing tests, and we don't really have anything
    to refactor, so let us move on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最小化实现通过了测试。就像第一次实现一样，我们并不是试图实现全部功能。我们只想实现足够的部分来通过测试。记住，当测试通过时，意味着需求得到了满足。在这个阶段，我们有两个通过测试，实际上我们没有太多需要重构的地方，所以让我们继续前进。
- en: Testing for exceptions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试异常
- en: 'Another requirement is that the price should not be negative. We would want
    to raise a `ValueError` if the price is negative. How would we check for this
    expectation in a test? Here is one way to do that:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要求是价格不能为负。如果价格是负数，我们希望抛出一个 `ValueError`。我们如何在测试中检查这个期望呢？这里有一种方法可以做到：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we call the `update` method with a negative price. This
    call is wrapped with a `try...except` block to catch `ValueError`. If the exception
    is raised correctly, then control goes into the `except` block where we return
    from the test. Since the test method returned successfully, it is marked as passing.
    If the exception is not raised, then the `fail` method gets called. This is another
    method provided by `unittest.TestCase` and raises a test failure exception when
    it is called. We can pass in a message to provide some explanation as to why it
    failed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用负价格调用 `update` 方法。这个调用被 `try...except` 块包裹，以捕获 `ValueError`。如果异常被正确抛出，控制将进入
    `except` 块，我们在那里从测试中返回。由于测试方法成功返回，它被标记为通过。如果没有抛出异常，则调用 `fail` 方法。这是 `unittest.TestCase`
    提供的另一个方法，当它被调用时，会抛出一个测试失败异常。我们可以传递一个消息来提供一些解释，说明为什么它失败了。
- en: 'Here is the code to pass this test:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是通过这个测试的代码：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With this code, all the three tests so far pass.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，到目前为止的所有三个测试都通过了。
- en: 'Since checking for exceptions is quite a common case, `unittest` provides a
    simpler way to do it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于检查异常是一个相当常见的案例，`unittest` 提供了一种更简单的方式来处理：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `assertRaises` method takes the expected exception as the first argument,
    the function to call as the second argument, and the parameters to the function
    are passed as in the remaining arguments. If you need to call the function with
    keyword arguments, then they can be passed in as keyword arguments to the `assertRaises`
    method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertRaises` 方法将期望的异常作为第一个参数，将需要调用的函数作为第二个参数，函数的参数通过剩余的参数传递。如果你需要使用关键字参数调用函数，那么它们可以作为关键字参数传递给
    `assertRaises` 方法。'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the second argument to `assertRaises` is a reference to the function
    to be called. This is why we don't put parentheses after the function name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`assertRaises` 的第二个参数是对要调用的函数的引用。这就是为什么我们在函数名称后面不放置括号的原因。
- en: 'If passing in a function reference and a list of parameters feels awkward,
    then `assertRaises` provides another syntax that we can use:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入函数引用和参数列表感觉不自然，那么 `assertRaises` 提供了另一种我们可以使用的语法：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What is going on here? When we pass only one parameter to `assertRaises`, a
    context manager is returned. We can use that with the `with` statement and put
    our action in that block. If the block raises the expected exception, then the
    context manager matches it and exits the block without an error. However, if the
    expected exception is not raised in the block, then the context manager raises
    a failure when the block is exited.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？当我们只向 `assertRaises` 传递一个参数时，会返回一个上下文管理器。我们可以使用 `with` 语句，并将我们的操作放在该块中。如果该块抛出了预期的异常，那么上下文管理器会匹配它并退出块而不会出现错误。然而，如果块中没有抛出预期的异常，那么上下文管理器在块退出时会引发失败。
- en: Exploring assert methods
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索断言方法
- en: 'Now we have just one requirement for `update` remaining:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 `update` 的要求只剩下一个：
- en: '**-Done-** It should take a timestamp and price value and set it on the object'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-Done-** 它应该接受一个时间戳和价格值，并将其设置在对象上'
- en: '**-Done-** The price cannot be negative'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-Done-** 价格不能为负'
- en: After multiple updates, the object gives us the latest price
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过多次更新后，对象给出了最新的价格
- en: 'Let us take the remaining requirement. Here is the test:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看剩下的要求。以下是测试：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What this test does is to simply call `update` twice, and when we ask for the
    price, provide us with the newer one. The interesting point about the test is
    that we use the `assertAlmostEqual` method here. This method is often used when
    checking equality with floating point numbers. Why don't we use plain old `assertEqual`?
    The reason is that due to the way floating points are stored, the result may not
    be exactly the number you expect. There could be a very small difference between
    what you expect and the actual number that is stored. Taking this into account,
    the `assertAlmostEqual` method allows us to specify a tolerance in the comparison.
    So, for example, if we expect 8.4 but the actual value is 8.39999999, the test
    will still pass.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试所做的只是简单地调用 `update` 两次，并在我们请求价格时提供最新的价格。测试的有趣之处在于我们在这里使用了 `assertAlmostEqual`
    方法。这种方法通常用于检查浮点数的相等性。我们为什么不使用普通的 `assertEqual` 呢？原因是由于浮点数的存储方式，结果可能不会正好是您期望的数字。您期望的值和实际存储的值之间可能存在一个非常小的差异。考虑到这一点，`assertAlmostEqual`
    方法允许我们在比较中指定公差。例如，如果我们期望 8.4 但实际值是 8.39999999，测试仍然会通过。
- en: The `assertAlmostEqual` method has two ways of specifying tolerance. The method
    we used above involves passing in a `delta` parameter which says that the difference
    between the expected value and the actual value should be within the delta. We've
    specified the `delta` parameter above as `0.0001,` which means any value between
    8.3999 and 8.4001 will pass the test.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertAlmostEqual` 方法有两种指定公差的方式。我们上面使用的方法涉及传递一个 `delta` 参数，表示预期值和实际值之间的差异应在
    delta 范围内。我们上面指定的 `delta` 参数是 `0.0001`，这意味着任何在 8.3999 和 8.4001 之间的值都会通过测试。'
- en: 'The other way of specifying tolerance is to use the `places` parameter as shown
    in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 指定公差的其他方法是使用以下代码中所示的 `places` 参数：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If this parameter is used, then both the expected and the actual values are
    rounded to the given number of decimal places before being compared. Note that
    you need to pass either the `delta` parameter or the `places` parameter. It is
    an error to pass both parameters together.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用此参数，则在比较之前，预期的值和实际的值都会四舍五入到指定的十进制位数。请注意，您需要传递 `delta` 参数或 `places` 参数。同时传递这两个参数是错误的。
- en: 'So far, we''ve used the following assertion methods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了以下断言方法：
- en: '`assertIsNone`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNone`'
- en: '`assertEqual`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual`'
- en: '`assertRaises`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaises`'
- en: '`assertAlmostEqual`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertAlmostEqual`'
- en: '`fail`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail`'
- en: 'The `unittest` module provides a large number of assertion methods that we
    can use for various conditions. Some of the common ones are listed below:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 模块提供了大量我们可以用于各种条件的断言方法。以下列出了一些常见的：'
- en: '`assertFalse(x, msg)`, `assertTrue(x, msg)`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertFalse(x, msg)`，`assertTrue(x, msg)`'
- en: '`assertIsNone(x, msg)`, `assertIsNotNone(x, msg)`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNone(x, msg)`，`assertIsNotNone(x, msg)`'
- en: '`assertEqual(x, y, msg)`, `assertNotEqual(x, y, msg)`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual(x, y, msg)`，`assertNotEqual(x, y, msg)`'
- en: '`assertAlmostEqual(x, y, places, msg, delta)`, `assertNotAlmostEqual(x, y,
    places, msg, delta)`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertAlmostEqual(x, y, places, msg, delta)`，`assertNotAlmostEqual(x, y, places,
    msg, delta)`'
- en: '`assertGreater(x, y, msg)`, `assertGreaterEqual(x, y, msg)`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertGreater(x, y, msg)`，`assertGreaterEqual(x, y, msg)`'
- en: '`assertLess(x, y, msg)`, `assertLessEqual(x, y, msg)`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertLess(x, y, msg)`，`assertLessEqual(x, y, msg)`'
- en: '`assertIs(x, y, msg)`, `assertIsNot(x, y, msg)`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIs(x, y, msg)`，`assertIsNot(x, y, msg)`'
- en: '`assertIn(x, seq, msg)`, `assertNotIn(x, seq, msg)`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIn(x, seq, msg)`，`assertNotIn(x, seq, msg)`'
- en: '`assertIsInstance(x, cls, msg)`, `assertNotIsInstance(x, cls, msg)`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsInstance(x, cls, msg)`，`assertNotIsInstance(x, cls, msg)`'
- en: '`assertRegex(text, regex, msg)`, `assertNotRegex(text, regex, msg)`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRegex(text, regex, msg)`，`assertNotRegex(text, regex, msg)`'
- en: '`assertRaises(exception, callable, *args, **kwargs)`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaises(exception, callable, *args, **kwargs)`'
- en: '`fail(msg)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail(msg)`'
- en: 'Most of the preceding functions are self explanatory. The following are some
    points that require a bit of explanation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前面的函数都是自解释的。以下是一些需要一些解释的点：
- en: '`msg` parameter: Most of the assert methods take an optional message parameter.
    A string can be passed here and it will be printed out in case the assertion fails.
    Usually, the default message is quite descriptive and this parameter is not required.
    Most of the time it is used with the `fail` method, as we saw a little while ago.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msg`参数：大多数断言方法都接受一个可选的消息参数。可以在这里传递一个字符串，如果断言失败，它将被打印出来。通常，默认消息已经非常描述性，因此不需要此参数。大多数时候它与`fail`方法一起使用，就像我们刚才看到的那样。'
- en: '`assertEqual` versus `assertIs`: These two sets of assertions are very similar.
    The critical difference is that the former checks for *equality* while the latter
    assertion is used to check for object *identity*. The second assertion fails in
    previous example because although both objects are equal, they are still two different
    objects, and hence their identity is different:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertEqual`与`assertIs`：这两组断言非常相似。关键的区别在于前者检查的是`*相等性*`，而后者断言用于检查对象的`*身份*`。第二个断言在之前的例子中失败，因为尽管两个对象相等，但它们仍然是两个不同的对象，因此它们的身份是不同的：'
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`assertIn`/`assertNotIn`: These asserts are used to check if an element is
    present in a sequence. This includes strings, lists, sets, and any other object
    that supports the `in` operator.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIn`/`assertNotIn`: 这些断言用于检查一个元素是否在序列中。这包括字符串、列表、集合以及任何支持`in`操作符的其他对象。'
- en: '`assertIsInstance`/`assertNotIsInstance`: They check if an object is an instance
    of the given class. The `cls` parameter can also be a tuple of classes, to assert
    that the object is an instance of any one of them.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsInstance`/`assertNotIsInstance`: 它们检查一个对象是否是给定类的实例。`cls`参数也可以是一个类元组，用于断言对象是这些类中的任何一个的实例。'
- en: 'The `unittest` module also provides some less-frequently-used assertions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块还提供了一些不太常用的断言：'
- en: '`assertRaisesRegex(exception, regex, callable, *args, **kwargs)`: This assertion
    is similar to `assertRaises`, except that it takes an additional `regex` parameter.
    A regular expression can be passed in here and the assertion will check that the
    right exception was raised, as well as that the exception message matches the
    regular expression.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertRaisesRegex(exception, regex, callable, *args, **kwargs)`: 这个断言与`assertRaises`类似，但它还额外接受一个`regex`参数。可以在这里传递一个正则表达式，断言将检查是否抛出了正确的异常，以及异常消息是否与正则表达式匹配。'
- en: '`assertWarns(warning, callable, *args, **kwargs)`: It is similar to `assertRaises`,
    but checks that a warning was raised instead.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertWarns(warning, callable, *args, **kwargs)`: 它与`assertRaises`类似，但检查是否抛出了警告。'
- en: '`assertWarnsRegex(warning, callable, *args, **kwargs)`: It is the warning equivalent
    of `assertRaisesRegex`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertWarnsRegex(warning, callable, *args, **kwargs)`: 它是`assertRaisesRegex`的警告等效。'
- en: Specific asserts versus generic asserts
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特定断言与通用断言
- en: 'One question that might come to your mind is why there are so many different
    assert methods. Why can''t we just use `assertTrue` instead of the more specific
    assert, as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有人问一个问题，为什么有这么多不同的断言方法。为什么我们不能像以下代码中所示的那样使用`assertTrue`而不是更具体的断言呢：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While they are certainly equivalent, one motivation for using a specific assert
    is that you get a better error message if the assertion fails. When comparing
    objects like lists and dicts, the error message will show exactly where the difference
    occurs, making it much easier to understand. Therefore, it is recommended to use
    the more specific asserts wherever possible.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们确实等价，但使用特定断言的一个动机是，如果断言失败，你会得到更好的错误消息。当比较列表和字典等对象时，错误消息将显示差异的确切位置，这使得理解更容易。因此，建议尽可能使用更具体的断言。
- en: Setup and teardown
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和清理
- en: 'Let us take a look at the tests that we have done so far:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们迄今为止所做的测试：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you notice, each test does the same setup by instantiating a `Stock` object
    that is then used in the test. In this case, the setup is just one line, but sometimes
    we might have to do multiple steps before we are ready to run the test. Instead
    of repeating this setup code in each and every test, we can make use of the `setUp`
    method provided by the `TestCase` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，每个测试都通过实例化一个 `Stock` 对象来进行相同的设置，该对象随后用于测试。在这种情况下，设置只是一行代码，但有时我们可能需要在运行测试之前执行多个步骤。我们可以在每个测试中重复设置代码，而不是使用
    `TestCase` 类提供的 `setUp` 方法：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we are overriding the default `setUp` method with our
    own. We've put our setup code in this method. This method is executed before every
    test, so the initialization done here is available for our test method to use.
    Note that we have to change our tests to use `self.goog` since it has now become
    an instance variable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在用我们自己的方法覆盖默认的 `setUp` 方法。我们将设置代码放在这个方法中。这个方法在每个测试之前执行，因此在这里完成的初始化可用于我们的测试方法。请注意，我们必须更改我们的测试以使用
    `self.goog`，因为它现在已成为实例变量。
- en: Similar to `setUp`, a `tearDown` method is also available which is executed
    immediately after the test is executed. We can do any required cleanup in this
    method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `setUp` 类似，还有一个 `tearDown` 方法，它在测试执行后立即执行。我们可以在该方法中执行任何必要的清理操作。
- en: 'The `setUp` and `tearDown` methods are executed before and after every test.
    What if we want some setup to be done only once for a group of tests? The `setupUpClass`
    and `tearDownClass` methods can be implemented as class methods and will be executed
    only once per test class. Similarly, the `setupUpModule` and `tearDownModule`
    functions are available to do any initialization once for the whole module. The
    following example shows the order of execution:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp` 和 `tearDown` 方法在每个测试前后执行。如果我们想为测试组只执行一次设置，怎么办？可以将 `setUpClass` 和 `tearDownClass`
    方法实现为类方法，并且它们将只在每个测试类中执行一次。同样，`setUpModule` 和 `tearDownModule` 函数可用于在整个模块中只初始化一次。以下示例显示了执行顺序：'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When this code is run, the output is as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此代码时，输出如下：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, the module level setup is executed first, followed by the class
    level, and finally the test case level. The teardown is executed in reverse order.
    In practical use, the test case level `setUp` and `tearDown` methods are very
    commonly used, while class level and module level setups are not needed much.
    Class level and module level setups are only used when there is an expensive setup
    step, such as making a connection to a database or a remote server, and it is
    preferable to do this setup just once and share it between all the tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，模块级别的设置首先执行，然后是类级别，最后是测试用例级别。清理操作以相反的顺序执行。在实际使用中，测试用例级别的 `setUp` 和 `tearDown`
    方法非常常用，而类级别和模块级别的设置则不需要太多。类级别和模块级别的设置仅在存在昂贵的设置步骤时使用，例如连接数据库或远程服务器，并且最好只设置一次并共享给所有测试。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A warning when using class level and module level setup**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用类级别和模块级别设置时的警告**'
- en: Any initialization done at class and module levels is shared between tests.
    Hence, it is important that modifications made in one test do not affect the other.
    For example, if we had initialized `self.goog = Stock("GOOG")` in `setUpClass`,
    it could have led to an unexpected failure, since the first test to check that
    the price of a new `Stock` object should be `None` will fail if one of the other
    tests is executed before it and it changes the state of the object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在类和模块级别进行的任何初始化都是在测试之间共享的。因此，确保在一个测试中进行的修改不会影响另一个测试非常重要。例如，如果我们已经在 `setUpClass`
    中初始化了 `self.goog = Stock("GOOG")`，那么如果其他测试在它之前执行并改变了对象的状态，那么第一个测试检查新 `Stock` 对象的价格应该是
    `None` 将会失败。
- en: Remember that the order in which tests are run is not guaranteed. Tests should
    be independent and should pass no matter the order they are executed in. Therefore,
    it is crucial that `setUpClass` and `setUpModule` are used carefully to only setup
    state which can be reused between tests.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，测试运行的顺序是不确定的。测试应该是独立的，并且无论执行顺序如何，都应该通过。因此，谨慎使用`setUpClass`和`setUpModule`至关重要，以确保只在测试之间可以重用的状态下设置。
- en: Brittle tests
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脆弱的测试
- en: 'We''ve implemented the three requirements for the `update` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了`update`方法的三项要求：
- en: '**-Done-** It should take a timestamp and price value and set it on the object'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-完成-** 它应该接受时间戳和价格值，并将它们设置在对象上'
- en: '**-Done-** After multiple updates, the object gives us the latest price'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-完成-** 经过多次更新后，对象会给出最新的价格'
- en: '**-Done-** The price cannot be negative'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-完成-** 价格不能为负'
- en: 'Now, let us suppose that a new requirement comes up that we had not known about
    before:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设出现了一个我们之前不知道的新要求：
- en: The `Stock` class needs a method to check if the stock has an increasing trend.
    An increasing trend is one where each of the latest three updates is an increase
    over the previous one.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stock`类需要一个方法来检查股票是否有上升趋势。上升趋势是指最新的三个更新值都比前一个更新值高。'
- en: So far, our `Stock` implementation just stores the latest price. In order to
    implement this functionality, we need to store some history of past price values.
    One way to do this is to change the `price` variable to a list. The problem is
    that when we change the internals of our implementation, it would break all of
    our tests, because all of them access the `price` variable directly and assert
    that it has specific values.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`Stock`实现只是存储最新的价格。为了实现这一功能，我们需要存储一些过去的价格历史值。一种方法是将`price`变量改为列表。问题是当我们改变实现内部结构时，它将破坏我们所有的测试，因为它们都直接访问`price`变量并断言它具有特定的值。
- en: What we see here is an example of test brittleness.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的是测试脆弱性的一个例子。
- en: A test is brittle when a change in the implementation details requires a change
    in the test cases. Ideally, a test should be testing the interface and not the
    implementation directly. After all, it is the interface that other units will
    be using to interact with this unit. When we test through the interface, it allows
    us the freedom to change the implementation of code without worrying about breaking
    the tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现细节的改变需要更改测试用例时，测试就变得脆弱。理想情况下，测试应该测试接口而不是直接测试实现。毕竟，接口是其他单元将用来与这个单元交互的。当我们通过接口进行测试时，它允许我们有自由地更改代码实现，而不必担心破坏测试。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**There are three ways a test might fail:**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试可能失败的三种方式：**'
- en: If there is a bug introduced in the code being tested
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在测试的代码中引入了错误
- en: If the test is tightly coupled to an implementation and we make changes to the
    code that modify the implementation, but without introducing a bug (for example,
    renaming a variable or modifying the internal design)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试与实现紧密耦合，并且我们对代码进行更改以修改实现，但没有引入错误（例如，重命名变量或修改内部设计）
- en: If the test requires some resource that is unavailable (for example, connecting
    to an external server, but the server is down)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试需要一些不可用的资源（例如，连接到外部服务器，但服务器已关闭）
- en: Ideally, the first case should be the only case where a test should fail. We
    should try to avoid the second and third as much as possible.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，第一个情况应该是测试失败的唯一情况。我们应该尽可能避免第二个和第三个。
- en: Sometimes it might be important to test specific implementation details. For
    example, suppose we have a class that is expected to perform a complex calculation
    and cache it for future use. The only way to test the caching functionality would
    be to verify if the calculated value is stored in the cache. If we later change
    the caching method (for example, moving from a file cache to memcache), then we
    will have to change the test as well.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时测试特定的实现细节可能很重要。例如，假设我们有一个类，它预期执行复杂的计算并将结果缓存以供将来使用。测试缓存功能唯一的方法是验证计算值是否存储在缓存中。如果我们后来更改缓存方法（例如，从文件缓存切换到memcache），那么我们也必须更改测试。
- en: 'Brittle tests can be worse than no tests, as the maintenance overhead of having
    to fix ten or twenty tests with every change in the implementation can turn developers
    away from TDD, increase the amount of frustration, and lead to teams disabling
    or skipping testing. Here are some guidelines on how to think about test brittleness:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 碎片化测试可能比没有测试更糟糕，因为每次实现变更都需要修复十个或二十个测试的维护开销可能会让开发者远离测试驱动开发（TDD），增加挫败感，并导致团队禁用或跳过测试。以下是一些关于如何考虑测试碎片化的指南：
- en: If at all possible, avoid using implementation details in tests, and only use
    the publicly exposed interface. This includes using only the interface methods
    in setup code and assertions.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，避免在测试中使用实现细节，只使用公开的接口。这包括在设置代码和断言中只使用接口方法。
- en: If the test needs to check functionality that is internal to the unit being
    tested, and it is an important functionality, then it might make sense to check
    for specific implementation actions.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试需要检查被测试单元内部的特定功能，并且这是一个重要的功能，那么检查特定的实现动作可能是有意义的。
- en: If it is cumbersome to use the external interface to set up the exact state
    that we want, or there is no interface method that retrieves the specific value
    we want to assert, then we may need to peek into the implementation in our tests.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用外部接口设置我们想要的确切状态很麻烦，或者没有接口方法可以检索我们想要断言的特定值，那么我们可能需要在测试中查看实现细节。
- en: If we are fairly confident that the implementation details are very unlikely
    to change in the future, then we might go ahead and use implementation-specific
    details in the test.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们相当有信心，实现细节在未来不太可能发生变化，那么我们可能会继续在测试中使用特定于实现的细节。
- en: For the second and third cases, the important point is to understand that there
    is a tradeoff between convenience, test readability, and brittleness. There is
    no right answer and it is a subjective decision that needs to be taken, weighing
    up the pros and cons of each specific situation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种和第三种情况，重要的是要理解在便利性、测试可读性和碎片化之间存在权衡。没有正确答案，这是一个主观决定，需要权衡每种具体情况的利弊。
- en: Refactoring the design
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新设计
- en: In the previous section, we talked about the new requirement of having to check
    if a stock has an increasing trend.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了检查股票是否有上升趋势的新要求。
- en: 'Let us start by writing a test first:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从编写一个测试开始：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The test takes three timestamps and prices and performs an update for each one.
    Since all three prices are increasing, the `is_increasing_trend` method should
    return `True`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试接受三个时间戳和价格，并对每个价格执行更新。由于所有三个价格都在增加，`is_increasing_trend`方法应该返回`True`。
- en: To make this test pass, we need to first add support for storing price history.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个测试通过，我们首先需要添加支持存储价格历史的功能。
- en: 'In the initializer, let us replace the `price` attribute with a `price_history`
    list. This list will store the history of price updates, with each new update
    added to the end of the list:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器中，让我们将`price`属性替换为`price_history`列表。这个列表将存储价格更新的历史，每个新的更新都添加到列表的末尾：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After making this change, all the tests will now fail, including the ones that
    were passing before. Only after we complete a few steps will we be able to have
    the tests pass again. When tests are passing, we can constantly run the tests
    to make sure we aren't breaking any functionality with our changes. When tests
    are failing, we do not have this safety net. It is inevitable that certain design
    changes, like the one we are making now, will temporarily make a number of tests
    fail until we finish the sequence of changes. We should try and minimize the time
    we spend making changes during failing tests, by making small changes at a time.
    This allows us to validate our changes as we go along.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行这个更改后，现在所有测试都将失败，包括之前通过的那些。只有在我们完成几个步骤后，我们才能再次使测试通过。当测试通过时，我们可以不断运行测试，以确保我们的更改没有破坏任何功能。当测试失败时，我们没有这样的安全网。某些设计更改，就像我们现在所做的，在完成一系列更改之前，不可避免地会使许多测试暂时失败。我们应该尽量减少在测试失败时进行更改的时间，一次只做小改动。这允许我们在进行过程中验证我们的更改。
- en: We can now change the `update` method to store the new price in this list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将`update`方法更改为将新价格存储在这个列表中。
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We shall retain the current interface for getting the latest price by accessing
    the `price` attribute. However, since we have replaced the `price` attribute with
    the `price_history` list, we need to create a property that will mimic the existing
    interface:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留当前通过访问`price`属性获取最新价格的用户界面。然而，由于我们已经用`price_history`列表替换了`price`属性，我们需要创建一个属性来模拟现有的界面：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this change, we can run the tests again and see that all our previous tests
    are still passing, with only the new test for the trend functionality failing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，我们可以再次运行测试，并看到我们所有的先前测试仍然通过，只有新的趋势功能测试失败。
- en: 'The new design now allows us to implement the code to pass the trend test:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 新的设计现在允许我们实现代码以通过趋势测试：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The implementation of the method simply checks whether the last three price
    updates are increasing. With that code implemented, all our tests, including the
    new one, will pass.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的实现只是简单地检查最后三个价格更新是否在增加。代码实现后，包括新的测试在内，我们所有的测试都将通过。
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A quick primer on properties**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于属性的快速入门**'
- en: Properties are a feature of Python where we can delegate attribute access to
    a function. Since we declared price as a property, accessing `Stock.price` will
    cause the method to be called instead of searching for the attribute. In our implementation,
    it allows us to create an interface so that other modules can refer to the stock
    price as an attribute, even though there is no such actual attribute in the object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是Python的一个特性，我们可以将属性访问委托给一个函数。由于我们将价格声明为属性，访问`Stock.price`将导致调用该方法而不是搜索属性。在我们的实现中，它允许我们创建一个接口，这样其他模块可以像属性一样引用股票价格，尽管在对象中实际上没有这样的属性。
- en: Refactoring tests
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构测试
- en: 'With the first test passing, we can go ahead with the second test:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试通过后，我们可以继续进行第二个测试：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our implementation already passes this test, so let us move on to the third
    test:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现已经通过了这个测试，所以让我们继续进行第三个测试：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The current code passes this test as well. But let us pause at this point.
    If we look at the test cases so far, we can see that a lot of code is being repeated
    between tests. The setup code is also not very readable. The most important line
    here is the list of prices, which is getting hidden in the clutter. We need to
    clean this up. What we are going to do is to take the common code and put it into
    a helper method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的代码也通过了这个测试。但让我们在这里暂停一下。如果我们看看到目前为止的测试用例，我们可以看到在测试之间有很多代码被重复使用。设置代码也不是很易读。这里最重要的行是价格列表，它被隐藏在混乱中。我们需要清理一下。我们要做的是将公共代码放入辅助方法中：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Much better! Not only is the duplication removed, but the tests are a lot more
    readable. By default, the `unittest` module looks for methods that start with
    the word `test` and only executes those methods as tests, so there is no risk
    that our helper method will be mistaken for a test case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！不仅消除了重复，测试的可读性也大大提高。默认情况下，`unittest`模块会寻找以单词`test`开头的方法，并且只执行这些方法作为测试，因此我们的辅助方法被误认为是测试用例的风险很小。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that test cases are also code. All the rules of writing clean, maintainable,
    and readable code apply to the test cases as well.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，测试用例也是代码。所有关于编写干净、可维护和可读代码的规则也适用于测试用例。
- en: Exploring the Rule classes
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索规则类
- en: So far we have concentrated on the `Stock` class. Let us now turn our attention
    to the rule classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于`Stock`类。现在让我们将注意力转向规则类。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From this point in the book, we will look at the implementation code, and then
    show how we can test it effectively. Note, however, that this does not mean writing
    the code first, followed by the unit test. The TDD process is still test first,
    followed by the implementation. It is the test case which will drive the implementation
    strategy. We are showing the implementation code first, only because it makes
    it easier to understand the testing concepts that will follow. All this code was
    originally written test first!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从这本书的这个点开始，我们将查看实现代码，然后展示我们如何有效地测试它。注意，这并不意味着先写代码，然后写单元测试。TDD过程仍然是先测试，然后是实现。是测试用例将驱动实现策略。我们首先展示实现代码，只是为了更容易理解接下来的测试概念。所有这些代码最初都是先写测试！
- en: The rule classes keep track of the rules that the user wants to track and they
    can be of different types. For example, send an alert when a stock crosses a value,
    or matches a trend.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 规则类跟踪用户想要跟踪的规则，并且它们可以是不同类型的。例如，当股票价格超过某个值或符合某种趋势时发送警报。
- en: 'Here is an example of a `PriceRule` implementation:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个`PriceRule`实现的示例：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This class is initialized with a stock symbol and a condition. The condition
    can be a lambda or a function that takes a stock as a parameter and returns `True`
    or `False`. The rule matches when the stock matches the condition. The key method
    for this is the `matches` method. This method returns `True` or `False` depending
    on whether the rule is matched or not. The matches method takes an exchange as
    a parameter. This is nothing but a dictionary containing all the stocks that are
    available for the application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此类使用股票符号和条件进行初始化。条件可以是一个lambda或函数，它接受一个股票作为参数并返回`True`或`False`。规则匹配当股票匹配条件时。此类的关键方法是`matches`方法。此方法根据规则是否匹配返回`True`或`False`。`matches`方法接受一个交易所作为参数。这只是一个包含所有可用于应用程序的股票的字典。
- en: We haven't talked about the `depends_on` method. This method just returns which
    stocks updates the rule depends on. This will be used later on to check the rule
    when any of those particular stocks get an update. For the `PriceRule`, it only
    depends on the stock that is passed in the initializer. An observant reader will
    notice that it returns a set (curly braces) and not a list.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论`depends_on`方法。此方法仅返回哪些股票更新依赖于规则。这将在稍后用于检查任何特定股票更新时的规则。对于`PriceRule`，它仅依赖于在初始化器中传递的股票。一个细心的读者会注意到它返回一个集合（花括号），而不是列表。
- en: Put this rule code in the file `rule.py` in the `stock_alerter` directory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将此规则代码放入`stock_alerter`目录下的`rule.py`文件中。
- en: 'Here is how we would use the `PriceRule`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用`PriceRule`的示例：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is what some of the tests would look like:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些测试的示例：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: One point to note is how we have used the `setupClass` method to do the setup.
    As discussed previously, this method is called just once for the whole series
    of tests. We use this method to set up the exchange and store it. Remember to
    put the `@classmethod` decorator on the `setupClass` method. We store the exchange
    in the class, and we can access it in the tests using `self.exchange`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是我们如何使用`setupClass`方法来进行设置。如前所述，此方法只为整个测试系列调用一次。我们使用此方法来设置交易所并存储它。请记住在`setupClass`方法上放置`@classmethod`装饰器。我们在类中存储交易所，并在测试中使用`self.exchange`来访问它。
- en: Otherwise, the tests are simply a matter of constructing a rule and checking
    the matches method.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，测试只是构建一个规则并检查匹配方法。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A (very) quick primer on decorators**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**装饰器（非常）快速入门**'
- en: Decorators are functions that take a function as an input and return another
    function as an output. Python has a shorthand syntax by which we can say `@decorator`
    above a function or method and it will apply the decorator to that function. For
    more details, check the python documentation or a tutorial. A good one is [http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是接受一个函数作为输入并返回另一个函数作为输出的函数。Python有一个简写语法，我们可以通过在函数或方法上方使用`@decorator`来应用装饰器。有关更多详细信息，请参阅Python文档或教程。一个好的教程是[http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/)。
- en: Let us now look at another rule class, the `AndRule`. The `AndRule` is used
    when you want to compose two or more rules together, for example, `AAPL > 10 AND
    GOOG > 15`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看另一个规则类，即`AndRule`。当您想要组合两个或更多规则时，会使用`AndRule`，例如，`AAPL > 10 AND GOOG >
    15`。
- en: 'This is how we could write a test for it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何为它编写测试的示例：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: One of the things about writing a test first is that it makes us think about
    how the class is going to be used.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的第一件事是它让我们思考类将如何被使用。
- en: For example, how should we pass in the various sub-rules to the `AndRule`? Should
    we have a method to set them? Should we pass them as a list? Should we pass them
    as individual parameters? This is a design decision and creating the test first
    allows us to actually write code as a user of our class and determine which is
    the best choice. In the test above, we have decided to pass in each sub-rule as
    a separate parameter to the `AndRule` constructor.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们应该如何将各种子规则传递给`AndRule`？我们应该有一个设置它们的方法吗？我们应该将它们作为列表传递？我们应该将它们作为单独的参数传递？这是一个设计决策，首先创建测试允许我们作为类的用户实际编写代码，并确定哪种选择最佳。在上面的测试中，我们决定将每个子规则作为单独的参数传递给`AndRule`构造函数。
- en: 'Now that the decision has been made, we can implement some code to pass the
    test:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在决策已经做出，我们可以编写一些代码来通过测试：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here we can see how the test-first process helps drive the design of our code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到测试驱动过程如何帮助我们驱动代码的设计。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The all function**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**`all`函数**'
- en: The all function is a built-in function that takes a list and returns `True`
    only if every element of that list is `True`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`函数是一个内置函数，它接受一个列表，并且只有当列表中的每个元素都是`True`时才返回`True`。'
- en: Exercise
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'It is now time to put our newly-learned skills into practice. Here is a new
    requirement to build into the `Stock` class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们新学的技能付诸实践了。以下是向`Stock`类中添加的新要求：
- en: Sometimes, updates might come out of order and we might get an update for a
    newer timestamp, followed by an update for an older timestamp. This could be due
    to random network latency, or due to the fact that sometimes we might get updates
    from different sources and one might be slightly ahead of the other.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，更新可能会出现顺序问题，我们可能会先收到一个较新时间戳的更新，然后是较旧时间戳的更新。这可能是由于随机网络延迟，或者有时我们可能从不同的来源收到更新，其中一个可能稍微领先于另一个。
- en: The `Stock` class should be able to handle such cases, and the `price` attribute
    should return the latest price as per the timestamp.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stock`类应该能够处理这种情况，并且`price`属性应该根据时间戳返回最新的价格。'
- en: The `is_increasing_trend` should also process the latest three prices as per
    their timestamps.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_increasing_trend`也应该根据其时间戳处理最新的三个价格。'
- en: 'Try your hand at implementing this requirement. Do not make any changes to
    the existing interfaces for these methods, but feel free to make any changes to
    the implementation as you require. Here are some things to think about:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试实现这个要求。不要对这些方法的现有接口进行任何更改，但请随意根据需要更改实现。以下是一些需要考虑的事项：
- en: Does our existing design support this new feature? Do we need to make any changes
    to the current design?
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现有的设计支持这个新特性吗？我们需要对当前设计做出任何更改吗？
- en: What kind of tests would we write for this requirement?
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将为此要求编写什么样的测试？
- en: After we get everything working, is there any clean up we can do to make the
    code more readable or maintainable?
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们让一切正常运行之后，我们是否可以进行一些清理工作，使代码更易于阅读或维护？
- en: Do we need to change the existing tests after we make this change, or do they
    continue to work without any modifications?
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在做出这个更改后是否需要更改现有的测试，或者它们是否无需修改就能继续工作？
- en: By the end of the exercise, you should have all the existing tests passing,
    as well as any new ones that you wrote for this requirement. Once you are done,
    you can check [Appendix A](apa.html "Appendix A. Answers to Exercises"), *Answers
    to Exercises* for one possible solution to this exercise.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习结束时，你应该让所有现有的测试通过，以及为这个要求编写的任何新测试。完成后，你可以查看[附录A](apa.html "附录 A. 练习答案")，*练习答案*，以获取这个练习的一个可能的解决方案。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we took a more detailed look at the TDD cycle. We learnt about
    the Arrange-Act-Assert pattern, took a more detailed look at the various assertions
    that are provided, as well as some of the different ways of setting up tests and
    cleaning up afterwards. Finally, we looked at how to prevent tests from being
    too brittle and did a few basic refactorings.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更详细地研究了TDD周期。我们学习了 Arrange-Act-Assert 模式，更详细地研究了提供的各种断言，以及设置测试和之后的清理的一些不同方法。最后，我们探讨了如何防止测试过于脆弱，并进行了一些基本的重构。
