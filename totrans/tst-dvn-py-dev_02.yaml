- en: Chapter 2. Red-Green-Refactor – The TDD Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we went through a small TDD cycle by creating a failing
    test and then making it pass. In this chapter, we are going to fill out the rest
    of the `Stock` class by writing more tests. In the process, we will dig deeper
    into the TDD cycle and the `unittest` module.
  prefs: []
  type: TYPE_NORMAL
- en: Tests are executable requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first test, we wrote a very simple test that checked whether a new `Stock`
    class has its `price` attribute initialized to `None`. We can now think about
    what requirement we want to implement next.
  prefs: []
  type: TYPE_NORMAL
- en: An observant reader might have caught on to the terminology used in the previous
    sentence, where I said that we can think about the requirement to implement next,
    instead of saying that we can think about the test to write next. Both statements
    are equivalent, because in TDD, tests are nothing but requirements. Each time
    we write a test and implement code to make it pass, what we actually do is make
    the code meet some requirement. Looking at it another way, tests are just executable
    requirement specifications. Requirement documentation often goes out of sync with
    what is actually implemented, but this is impossible with tests, because the moment
    they go out of sync, the test will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we said that the `Stock` class will be used to hold
    price information and price history for a stock symbol. This suggests that we
    need a way to set the price whenever it is updated. Let us implement an `update`
    method that meets the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: It should take a timestamp and price value and set it on the object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The price cannot be negative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After multiple updates, the object gives us the latest price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrange-Act-Assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us start with the first requirement. Here is the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here we call the `update` method (which doesn't exist yet) with the timestamp
    and price and then check that the price has been set correctly. We use the `assertEqual`
    method provided in the `unittest.TestCase` class to assert the value.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are using the `datetime` module to set the timestamp, we will have
    to add the line `from datetime import datetime` to the top of the file before
    it will run.
  prefs: []
  type: TYPE_NORMAL
- en: This test follows the pattern of Arrange-Act-Assert.
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**: Set up the context for the test. In this case, we create a `Stock`
    object. In other tests, it may involve creating multiple objects or hooking a
    few things together that will be required by the particular test.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Act**: Perform the action that we want to test. Here, we call the `update`
    method with the appropriate arguments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Assert**: Finally we assert that the outcome was as expected.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this test, each part of the pattern took one line of code, but this is not
    always the case. Often there will be more than one line for each part of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting our tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run the tests, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The test fails as expected, but the interesting thing is that the first line
    of the docstring is printed out on the fourth line. This is useful because we
    get some more information on which case is failing. This shows a second way of
    documenting out tests by using the first line for a short summary, and the rest
    of the docstring for a more detailed explanation. The detailed explanation will
    not be printed out with a test failure, so there is no problem with cluttering
    the test failure output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used two ways of documenting tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a descriptive test method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting an explanation in the docstring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which is better? Most of the time the test is self explanatory and doesn't need
    a whole lot of background explanation. In such cases, a well named test method
    is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes the test method name becomes so long that it becomes clumsy
    and actually ends up reducing the readability of the code. At other times, we
    might want to put in a more detailed explanation of what we are testing and why.
    In such cases, shortening the method name and putting the explanation in the docstring
    is a good idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the implementation to make this test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This minimal implementation passes the test. As with the first bit of implementation,
    we aren't trying to implement the whole functionality. We want to implement just
    enough to make the test pass. Remember, when the test passes, it means the requirement
    is met. At this point, we have two passing tests, and we don't really have anything
    to refactor, so let us move on.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another requirement is that the price should not be negative. We would want
    to raise a `ValueError` if the price is negative. How would we check for this
    expectation in a test? Here is one way to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we call the `update` method with a negative price. This
    call is wrapped with a `try...except` block to catch `ValueError`. If the exception
    is raised correctly, then control goes into the `except` block where we return
    from the test. Since the test method returned successfully, it is marked as passing.
    If the exception is not raised, then the `fail` method gets called. This is another
    method provided by `unittest.TestCase` and raises a test failure exception when
    it is called. We can pass in a message to provide some explanation as to why it
    failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to pass this test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this code, all the three tests so far pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since checking for exceptions is quite a common case, `unittest` provides a
    simpler way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `assertRaises` method takes the expected exception as the first argument,
    the function to call as the second argument, and the parameters to the function
    are passed as in the remaining arguments. If you need to call the function with
    keyword arguments, then they can be passed in as keyword arguments to the `assertRaises`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the second argument to `assertRaises` is a reference to the function
    to be called. This is why we don't put parentheses after the function name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If passing in a function reference and a list of parameters feels awkward,
    then `assertRaises` provides another syntax that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What is going on here? When we pass only one parameter to `assertRaises`, a
    context manager is returned. We can use that with the `with` statement and put
    our action in that block. If the block raises the expected exception, then the
    context manager matches it and exits the block without an error. However, if the
    expected exception is not raised in the block, then the context manager raises
    a failure when the block is exited.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring assert methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have just one requirement for `update` remaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-Done-** It should take a timestamp and price value and set it on the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-Done-** The price cannot be negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After multiple updates, the object gives us the latest price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us take the remaining requirement. Here is the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What this test does is to simply call `update` twice, and when we ask for the
    price, provide us with the newer one. The interesting point about the test is
    that we use the `assertAlmostEqual` method here. This method is often used when
    checking equality with floating point numbers. Why don't we use plain old `assertEqual`?
    The reason is that due to the way floating points are stored, the result may not
    be exactly the number you expect. There could be a very small difference between
    what you expect and the actual number that is stored. Taking this into account,
    the `assertAlmostEqual` method allows us to specify a tolerance in the comparison.
    So, for example, if we expect 8.4 but the actual value is 8.39999999, the test
    will still pass.
  prefs: []
  type: TYPE_NORMAL
- en: The `assertAlmostEqual` method has two ways of specifying tolerance. The method
    we used above involves passing in a `delta` parameter which says that the difference
    between the expected value and the actual value should be within the delta. We've
    specified the `delta` parameter above as `0.0001,` which means any value between
    8.3999 and 8.4001 will pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way of specifying tolerance is to use the `places` parameter as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If this parameter is used, then both the expected and the actual values are
    rounded to the given number of decimal places before being compared. Note that
    you need to pass either the `delta` parameter or the `places` parameter. It is
    an error to pass both parameters together.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve used the following assertion methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertIsNone`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEqual`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertRaises`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertAlmostEqual`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `unittest` module provides a large number of assertion methods that we
    can use for various conditions. Some of the common ones are listed below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertFalse(x, msg)`, `assertTrue(x, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIsNone(x, msg)`, `assertIsNotNone(x, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEqual(x, y, msg)`, `assertNotEqual(x, y, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertAlmostEqual(x, y, places, msg, delta)`, `assertNotAlmostEqual(x, y,
    places, msg, delta)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertGreater(x, y, msg)`, `assertGreaterEqual(x, y, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertLess(x, y, msg)`, `assertLessEqual(x, y, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIs(x, y, msg)`, `assertIsNot(x, y, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIn(x, seq, msg)`, `assertNotIn(x, seq, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIsInstance(x, cls, msg)`, `assertNotIsInstance(x, cls, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertRegex(text, regex, msg)`, `assertNotRegex(text, regex, msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertRaises(exception, callable, *args, **kwargs)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail(msg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the preceding functions are self explanatory. The following are some
    points that require a bit of explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`msg` parameter: Most of the assert methods take an optional message parameter.
    A string can be passed here and it will be printed out in case the assertion fails.
    Usually, the default message is quite descriptive and this parameter is not required.
    Most of the time it is used with the `fail` method, as we saw a little while ago.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertEqual` versus `assertIs`: These two sets of assertions are very similar.
    The critical difference is that the former checks for *equality* while the latter
    assertion is used to check for object *identity*. The second assertion fails in
    previous example because although both objects are equal, they are still two different
    objects, and hence their identity is different:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`assertIn`/`assertNotIn`: These asserts are used to check if an element is
    present in a sequence. This includes strings, lists, sets, and any other object
    that supports the `in` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertIsInstance`/`assertNotIsInstance`: They check if an object is an instance
    of the given class. The `cls` parameter can also be a tuple of classes, to assert
    that the object is an instance of any one of them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `unittest` module also provides some less-frequently-used assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertRaisesRegex(exception, regex, callable, *args, **kwargs)`: This assertion
    is similar to `assertRaises`, except that it takes an additional `regex` parameter.
    A regular expression can be passed in here and the assertion will check that the
    right exception was raised, as well as that the exception message matches the
    regular expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertWarns(warning, callable, *args, **kwargs)`: It is similar to `assertRaises`,
    but checks that a warning was raised instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertWarnsRegex(warning, callable, *args, **kwargs)`: It is the warning equivalent
    of `assertRaisesRegex`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific asserts versus generic asserts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One question that might come to your mind is why there are so many different
    assert methods. Why can''t we just use `assertTrue` instead of the more specific
    assert, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While they are certainly equivalent, one motivation for using a specific assert
    is that you get a better error message if the assertion fails. When comparing
    objects like lists and dicts, the error message will show exactly where the difference
    occurs, making it much easier to understand. Therefore, it is recommended to use
    the more specific asserts wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Setup and teardown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let us take a look at the tests that we have done so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you notice, each test does the same setup by instantiating a `Stock` object
    that is then used in the test. In this case, the setup is just one line, but sometimes
    we might have to do multiple steps before we are ready to run the test. Instead
    of repeating this setup code in each and every test, we can make use of the `setUp`
    method provided by the `TestCase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are overriding the default `setUp` method with our
    own. We've put our setup code in this method. This method is executed before every
    test, so the initialization done here is available for our test method to use.
    Note that we have to change our tests to use `self.goog` since it has now become
    an instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `setUp`, a `tearDown` method is also available which is executed
    immediately after the test is executed. We can do any required cleanup in this
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setUp` and `tearDown` methods are executed before and after every test.
    What if we want some setup to be done only once for a group of tests? The `setupUpClass`
    and `tearDownClass` methods can be implemented as class methods and will be executed
    only once per test class. Similarly, the `setupUpModule` and `tearDownModule`
    functions are available to do any initialization once for the whole module. The
    following example shows the order of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is run, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the module level setup is executed first, followed by the class
    level, and finally the test case level. The teardown is executed in reverse order.
    In practical use, the test case level `setUp` and `tearDown` methods are very
    commonly used, while class level and module level setups are not needed much.
    Class level and module level setups are only used when there is an expensive setup
    step, such as making a connection to a database or a remote server, and it is
    preferable to do this setup just once and share it between all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A warning when using class level and module level setup**'
  prefs: []
  type: TYPE_NORMAL
- en: Any initialization done at class and module levels is shared between tests.
    Hence, it is important that modifications made in one test do not affect the other.
    For example, if we had initialized `self.goog = Stock("GOOG")` in `setUpClass`,
    it could have led to an unexpected failure, since the first test to check that
    the price of a new `Stock` object should be `None` will fail if one of the other
    tests is executed before it and it changes the state of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the order in which tests are run is not guaranteed. Tests should
    be independent and should pass no matter the order they are executed in. Therefore,
    it is crucial that `setUpClass` and `setUpModule` are used carefully to only setup
    state which can be reused between tests.
  prefs: []
  type: TYPE_NORMAL
- en: Brittle tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve implemented the three requirements for the `update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**-Done-** It should take a timestamp and price value and set it on the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-Done-** After multiple updates, the object gives us the latest price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**-Done-** The price cannot be negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let us suppose that a new requirement comes up that we had not known about
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Stock` class needs a method to check if the stock has an increasing trend.
    An increasing trend is one where each of the latest three updates is an increase
    over the previous one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, our `Stock` implementation just stores the latest price. In order to
    implement this functionality, we need to store some history of past price values.
    One way to do this is to change the `price` variable to a list. The problem is
    that when we change the internals of our implementation, it would break all of
    our tests, because all of them access the `price` variable directly and assert
    that it has specific values.
  prefs: []
  type: TYPE_NORMAL
- en: What we see here is an example of test brittleness.
  prefs: []
  type: TYPE_NORMAL
- en: A test is brittle when a change in the implementation details requires a change
    in the test cases. Ideally, a test should be testing the interface and not the
    implementation directly. After all, it is the interface that other units will
    be using to interact with this unit. When we test through the interface, it allows
    us the freedom to change the implementation of code without worrying about breaking
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**There are three ways a test might fail:**'
  prefs: []
  type: TYPE_NORMAL
- en: If there is a bug introduced in the code being tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the test is tightly coupled to an implementation and we make changes to the
    code that modify the implementation, but without introducing a bug (for example,
    renaming a variable or modifying the internal design)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the test requires some resource that is unavailable (for example, connecting
    to an external server, but the server is down)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, the first case should be the only case where a test should fail. We
    should try to avoid the second and third as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it might be important to test specific implementation details. For
    example, suppose we have a class that is expected to perform a complex calculation
    and cache it for future use. The only way to test the caching functionality would
    be to verify if the calculated value is stored in the cache. If we later change
    the caching method (for example, moving from a file cache to memcache), then we
    will have to change the test as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Brittle tests can be worse than no tests, as the maintenance overhead of having
    to fix ten or twenty tests with every change in the implementation can turn developers
    away from TDD, increase the amount of frustration, and lead to teams disabling
    or skipping testing. Here are some guidelines on how to think about test brittleness:'
  prefs: []
  type: TYPE_NORMAL
- en: If at all possible, avoid using implementation details in tests, and only use
    the publicly exposed interface. This includes using only the interface methods
    in setup code and assertions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the test needs to check functionality that is internal to the unit being
    tested, and it is an important functionality, then it might make sense to check
    for specific implementation actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is cumbersome to use the external interface to set up the exact state
    that we want, or there is no interface method that retrieves the specific value
    we want to assert, then we may need to peek into the implementation in our tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are fairly confident that the implementation details are very unlikely
    to change in the future, then we might go ahead and use implementation-specific
    details in the test.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the second and third cases, the important point is to understand that there
    is a tradeoff between convenience, test readability, and brittleness. There is
    no right answer and it is a subjective decision that needs to be taken, weighing
    up the pros and cons of each specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we talked about the new requirement of having to check
    if a stock has an increasing trend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by writing a test first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The test takes three timestamps and prices and performs an update for each one.
    Since all three prices are increasing, the `is_increasing_trend` method should
    return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: To make this test pass, we need to first add support for storing price history.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initializer, let us replace the `price` attribute with a `price_history`
    list. This list will store the history of price updates, with each new update
    added to the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After making this change, all the tests will now fail, including the ones that
    were passing before. Only after we complete a few steps will we be able to have
    the tests pass again. When tests are passing, we can constantly run the tests
    to make sure we aren't breaking any functionality with our changes. When tests
    are failing, we do not have this safety net. It is inevitable that certain design
    changes, like the one we are making now, will temporarily make a number of tests
    fail until we finish the sequence of changes. We should try and minimize the time
    we spend making changes during failing tests, by making small changes at a time.
    This allows us to validate our changes as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: We can now change the `update` method to store the new price in this list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We shall retain the current interface for getting the latest price by accessing
    the `price` attribute. However, since we have replaced the `price` attribute with
    the `price_history` list, we need to create a property that will mimic the existing
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this change, we can run the tests again and see that all our previous tests
    are still passing, with only the new test for the trend functionality failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new design now allows us to implement the code to pass the trend test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the method simply checks whether the last three price
    updates are increasing. With that code implemented, all our tests, including the
    new one, will pass.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A quick primer on properties**'
  prefs: []
  type: TYPE_NORMAL
- en: Properties are a feature of Python where we can delegate attribute access to
    a function. Since we declared price as a property, accessing `Stock.price` will
    cause the method to be called instead of searching for the attribute. In our implementation,
    it allows us to create an interface so that other modules can refer to the stock
    price as an attribute, even though there is no such actual attribute in the object.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the first test passing, we can go ahead with the second test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation already passes this test, so let us move on to the third
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The current code passes this test as well. But let us pause at this point.
    If we look at the test cases so far, we can see that a lot of code is being repeated
    between tests. The setup code is also not very readable. The most important line
    here is the list of prices, which is getting hidden in the clutter. We need to
    clean this up. What we are going to do is to take the common code and put it into
    a helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Much better! Not only is the duplication removed, but the tests are a lot more
    readable. By default, the `unittest` module looks for methods that start with
    the word `test` and only executes those methods as tests, so there is no risk
    that our helper method will be mistaken for a test case.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that test cases are also code. All the rules of writing clean, maintainable,
    and readable code apply to the test cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Rule classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have concentrated on the `Stock` class. Let us now turn our attention
    to the rule classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From this point in the book, we will look at the implementation code, and then
    show how we can test it effectively. Note, however, that this does not mean writing
    the code first, followed by the unit test. The TDD process is still test first,
    followed by the implementation. It is the test case which will drive the implementation
    strategy. We are showing the implementation code first, only because it makes
    it easier to understand the testing concepts that will follow. All this code was
    originally written test first!
  prefs: []
  type: TYPE_NORMAL
- en: The rule classes keep track of the rules that the user wants to track and they
    can be of different types. For example, send an alert when a stock crosses a value,
    or matches a trend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a `PriceRule` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This class is initialized with a stock symbol and a condition. The condition
    can be a lambda or a function that takes a stock as a parameter and returns `True`
    or `False`. The rule matches when the stock matches the condition. The key method
    for this is the `matches` method. This method returns `True` or `False` depending
    on whether the rule is matched or not. The matches method takes an exchange as
    a parameter. This is nothing but a dictionary containing all the stocks that are
    available for the application.
  prefs: []
  type: TYPE_NORMAL
- en: We haven't talked about the `depends_on` method. This method just returns which
    stocks updates the rule depends on. This will be used later on to check the rule
    when any of those particular stocks get an update. For the `PriceRule`, it only
    depends on the stock that is passed in the initializer. An observant reader will
    notice that it returns a set (curly braces) and not a list.
  prefs: []
  type: TYPE_NORMAL
- en: Put this rule code in the file `rule.py` in the `stock_alerter` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we would use the `PriceRule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what some of the tests would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: One point to note is how we have used the `setupClass` method to do the setup.
    As discussed previously, this method is called just once for the whole series
    of tests. We use this method to set up the exchange and store it. Remember to
    put the `@classmethod` decorator on the `setupClass` method. We store the exchange
    in the class, and we can access it in the tests using `self.exchange`.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, the tests are simply a matter of constructing a rule and checking
    the matches method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**A (very) quick primer on decorators**'
  prefs: []
  type: TYPE_NORMAL
- en: Decorators are functions that take a function as an input and return another
    function as an output. Python has a shorthand syntax by which we can say `@decorator`
    above a function or method and it will apply the decorator to that function. For
    more details, check the python documentation or a tutorial. A good one is [http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/).
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look at another rule class, the `AndRule`. The `AndRule` is used
    when you want to compose two or more rules together, for example, `AAPL > 10 AND
    GOOG > 15`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we could write a test for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: One of the things about writing a test first is that it makes us think about
    how the class is going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: For example, how should we pass in the various sub-rules to the `AndRule`? Should
    we have a method to set them? Should we pass them as a list? Should we pass them
    as individual parameters? This is a design decision and creating the test first
    allows us to actually write code as a user of our class and determine which is
    the best choice. In the test above, we have decided to pass in each sub-rule as
    a separate parameter to the `AndRule` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the decision has been made, we can implement some code to pass the
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here we can see how the test-first process helps drive the design of our code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**The all function**'
  prefs: []
  type: TYPE_NORMAL
- en: The all function is a built-in function that takes a list and returns `True`
    only if every element of that list is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is now time to put our newly-learned skills into practice. Here is a new
    requirement to build into the `Stock` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, updates might come out of order and we might get an update for a
    newer timestamp, followed by an update for an older timestamp. This could be due
    to random network latency, or due to the fact that sometimes we might get updates
    from different sources and one might be slightly ahead of the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Stock` class should be able to handle such cases, and the `price` attribute
    should return the latest price as per the timestamp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `is_increasing_trend` should also process the latest three prices as per
    their timestamps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try your hand at implementing this requirement. Do not make any changes to
    the existing interfaces for these methods, but feel free to make any changes to
    the implementation as you require. Here are some things to think about:'
  prefs: []
  type: TYPE_NORMAL
- en: Does our existing design support this new feature? Do we need to make any changes
    to the current design?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What kind of tests would we write for this requirement?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we get everything working, is there any clean up we can do to make the
    code more readable or maintainable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we need to change the existing tests after we make this change, or do they
    continue to work without any modifications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the exercise, you should have all the existing tests passing,
    as well as any new ones that you wrote for this requirement. Once you are done,
    you can check [Appendix A](apa.html "Appendix A. Answers to Exercises"), *Answers
    to Exercises* for one possible solution to this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we took a more detailed look at the TDD cycle. We learnt about
    the Arrange-Act-Assert pattern, took a more detailed look at the various assertions
    that are provided, as well as some of the different ways of setting up tests and
    cleaning up afterwards. Finally, we looked at how to prevent tests from being
    too brittle and did a few basic refactorings.
  prefs: []
  type: TYPE_NORMAL
