<html><head></head><body>
		<div><h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor016"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Creating a Django Project</h1>
			<p><strong class="bold">Django</strong> is one of the most famous backend frameworks written in Python and is often used to build simple or complex web applications. As for <strong class="bold">React</strong>, it’s one of the most widely used JavaScript libraries to create reactive and powerful user interfaces. In this chapter, we’ll focus on Django first.</p>
			<p>In this chapter, we’ll briefly explain <strong class="bold">software development</strong> and, in particular, <strong class="bold">backend development</strong> in the context of what we’ll be building: a social network web application with Django and React. We’ll also talk about the most common tools used for backend development in <strong class="bold">Python</strong> – here in Django. Then, we will create a Django project and explain the most important parts of a Django project. After that, we’ll connect <strong class="bold">PostgreSQL</strong> to the Django project.</p>
			<p>By the end of this chapter, you’ll understand concepts such as software development, frontend development, and backend development. You’ll also learn how to create a project in Django and start a server.</p>
			<p>In this chapter, we’ll be covering the following topics:</p>
			<ul>
				<li>An overview of software development</li>
				<li>Understanding backend development</li>
				<li>What is an API?</li>
				<li>What is Django?</li>
				<li>Setting up the work environment</li>
				<li>Configuring the database</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>An overview of software development</h1>
			<p>Software development is a complex process<a id="_idIndexMarker000"/> full of many steps and many components. These components ensure that conceiving, specifying, designing, programming, documenting, and testing an application, a framework, or software is respected and well applied.</p>
			<p>Generally, the software is made of the following two components:</p>
			<ul>
				<li>The <strong class="bold">backend</strong>: This represents what the user<a id="_idIndexMarker001"/> can’t see; it’s composed<a id="_idIndexMarker002"/> of the business logic and data manipulation from a database</li>
				<li>The <strong class="bold">frontend</strong>: This represents the interface<a id="_idIndexMarker003"/> provided to the user <a id="_idIndexMarker004"/>to interact with the whole application</li>
			</ul>
			<p>The term frontend refers to the elements of a site or application<a id="_idIndexMarker005"/> that users see onscreen and with which they will interact. For example, all internet users will see a combination of HTML, CSS, and JavaScript on a website. It is these frontend programming languages that will be interpreted by the browser.</p>
			<p>Typically, the frontend consists of HTML, CSS, JavaScript, and jQuery (or other UI libraries or frameworks) used to replicate a design. The design is created by the web designer who will create graphic models with dedicated tools, such as Photoshop or Figma.</p>
			<p>Here, we’ll focus on web development. Web development is the part of software development focused on building websites and web applications, and the notion of web development relies on a client-server architecture.</p>
			<p>The client-server architecture represents an environment in which applications running on a client machine can communicate with other applications installed on a server machine, which provides services or data from a database.</p>
			<p>On the web, the client will simply be a browser used to request a page or a resource from a server.</p>
			<p>Here’s a simple diagram<a id="_idIndexMarker006"/> demonstrating this:</p>
			<div><div><img src="img/Figure_1.1_B18221.jpg" alt="Figure 1.1 – Client-server architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Client-server architecture</p>
			<p>Now that we have a better understanding<a id="_idIndexMarker007"/> of software development, particularly web development, let’s move on to a component of it: backend development.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Understanding backend development</h1>
			<p>Backend development<a id="_idIndexMarker008"/> handles the behind-the-scenes of modern applications. Most of the time, it’s made of code that connects to the database, manages user connections, and also powers web applications or the <strong class="bold">API</strong>.</p>
			<p>The focus of backend development code is more on the business logic. It primarily focuses on how an application works and the functionality and logic powering the application.</p>
			<p>For example, let’s talk about a web application built to manage books. Let’s suppose that the application is connected to an SQL database.</p>
			<p>Whatever language is used to build the application and the structure, here are some requirements that represent the business logic and that primarily depend on the backend rather than the frontend:</p>
			<ul>
				<li><strong class="bold">Adding a book (only for admin)</strong>: This supposes that the client (frontend) should be able to make a request to an API powered using whatever language is built for the backend, containing the data needed to create a new entry in the database that represents a book. This action is only available to admins.</li>
				<li><strong class="bold">Listing all books</strong>: This supposes that the client should also be able to make a request to the API, and this API should send as a response a list of all the books in JSON/XML format.</li>
			</ul>
			<p>Just by taking a look at these two<a id="_idIndexMarker009"/> requirements, we can quickly understand that the frontend will just be the interface through which to request these actions. However, the backend will (taking the first requirement as an example) make sure that the incoming request is possible (checking for permissions such as whether the user making the request is really an admin) and that the data in the request is valid – only after that can data be safely registered in the d<a id="_idTextAnchor020"/>atabase. Backend developers use programming languages such as Python, PHP, and Ruby to set up and configure the server. These tools will allow them to store, process, and modify information. To make these programming languages even more practical, developers will improve them with frameworks such as Symfony, Ruby on Rails, CakePHP, or CodeIgniter. These tools will make development faster and more secure. They must then ensure that these tools are always up to date and facilitate the maintenance required.</p>
			<p>A backend developer<a id="_idIndexMarker010"/> is therefore responsible for creating and managing all the elements invisible to the end user. It is therefore they who are responsible for all the functionalities of the site or the application. They are also responsible for creating the database which will allow, among other things, the information provided by users to be retained. For example, the backend developer will use the databases to find the usernames and passwords that customers have used to connect. It is possible to train for this profession by training in web development or even training in Python.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Responsibilities of backend developers</h2>
			<p>The backend is typically made of three major parts:</p>
			<ul>
				<li><strong class="bold">Server</strong>: A machine or an application (NGINX) that receives<a id="_idIndexMarker011"/> requests</li>
				<li><strong class="bold">Application</strong>: A running application<a id="_idIndexMarker012"/> on the server that receives the requests, validates these requests, and sends an appropriate response</li>
				<li><strong class="bold">Database</strong>: Used to store<a id="_idIndexMarker013"/> data</li>
			</ul>
			<p>Thus, the responsibilities<a id="_idIndexMarker014"/> of backend programmers could easily involve writing APIs, writing code to interact with a database, creating modules or libraries, also working on business data and architecture, and much more.</p>
			<p>They also have to do the following:</p>
			<ul>
				<li>Coordinate and communicate with frontend developers to transfer data efficiently to the client side of the application</li>
				<li>Collaborate with quality assurance engineers to optimize the server-side processes and also pass some security checks</li>
				<li>Optimize the application when the number of requests or users scales as well</li>
				<li>Analyze the requirements of the project and create a simple structure to handle bugs and errors</li>
				<li>Propose efficient solutions for cloud hosting but also build CI/CD pipelines</li>
			</ul>
			<p>The backend architecture actually helps build one of the most common interfaces for consuming data in the software industry: an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>). Let’s learn more about the term.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor022"/>What is an API?</h1>
			<p>In this book, we’ll primarily<a id="_idIndexMarker015"/> be building an API – so, what is an API?</p>
			<p>Before answering this question, just <a id="_idIndexMarker016"/>remember that most of the internet is powered by <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) or <strong class="bold">RESTful APIs</strong>. An API simplifies the way data<a id="_idIndexMarker017"/> is exchanged between applications or machines. It consists mainly of two components:</p>
			<ul>
				<li>The technical specification, which describes<a id="_idIndexMarker018"/> the data exchange options between the parties, with the specification made in the form of a request for data delivery protocols and data processing</li>
				<li>The software interface (the programming code), which is written to the specification<a id="_idIndexMarker019"/> that represents it</li>
			</ul>
			<p>For example, if the client side of your application is written in JavaScript and the server side is written in PHP, you’ll need to create a web API with PHP (as data comes from the database), which will help you write the rules and routes that will be used to access data.</p>
			<p>Web APIs are relatively common<a id="_idIndexMarker020"/> and there are different specifications and protocols. The goal of API specification is to standardize—because of different programming languages and different <strong class="bold">Operating Systems</strong> (<strong class="bold">OSs</strong>)—exchanges between two or more web services. For example, you’ll find the following:</p>
			<ul>
				<li><strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>): A protocol that can be used by a program<a id="_idIndexMarker021"/> to request a service from a program on another computer on a network that it does not need<a id="_idIndexMarker022"/> to know the details<a id="_idIndexMarker023"/> of. This is sometimes called a function or subroutine call.</li>
				<li> <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>): An XML-based communication protocol that allows applications<a id="_idIndexMarker024"/> to exchange information with each other over HTTP. It therefore allows access to web services and the interoperability of applications across the web. SOAP is a simple and lightweight protocol that relies entirely on established standards such as HTTP and XML. It is portable and therefore independent of any OS and type of computer. SOAP is a non-proprietary specification.</li>
				<li><strong class="bold">REST/RESTful</strong>: A style of architecture for building<a id="_idIndexMarker025"/> applications (web, intranet, or web service). This <a id="_idIndexMarker026"/>is a set of conventions and best practices to be observed, not a technology in its own right. The REST architecture uses the original specifications of the HTTP protocol, rather than reinventing an overlay (as SOAP or XML-RPC do, for example):<ul><li><strong class="bold">Rule 1</strong>: The URL is a resource identifier</li><li><strong class="bold">Rule 2</strong>: HTTP verbs are identifiers of operations</li><li><strong class="bold">Rule 3</strong>: HTTP responses are representations of resources</li><li><strong class="bold">Rule 4</strong>: Links are relations between resources</li><li><strong class="bold">Rule 5</strong>: A parameter is an authentication token</li></ul></li>
			</ul>
			<p>In this book, we’ll be building REST APIs using Django and <strong class="bold">Django REST</strong>, so let’s get to know REST a bit better.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Understanding REST APIs</h2>
			<p>REST is usually the way<a id="_idIndexMarker027"/> to go when developers<a id="_idIndexMarker028"/> want to build an API. REST is a simple alternative to SOAP and RPC, as it makes it easier to write the logic to access resources; resources here are represented by a unique URL available with one request to this URL.</p>
			<p>RESTful APIs use<a id="_idIndexMarker029"/> HTTP requests (or methods)<a id="_idTextAnchor024"/> to interact with resources:</p>
			<ul>
				<li><code>GET</code>: The most commonly used method in APIs and websites. This method is used to retrieve data from a server at a specified resource. This resource is an endpoint returning an object or a list of objects in JSON or XML most of the time.</li>
				<li><code>POST</code>: The <code>POST</code> method is a basic method for requesting information processing from the server. These requests are supposed to bring mechanisms specific to the server into play and cause communications with other modules, or even other servers, to process said data. Therefore, it is quite likely that two identical <code>POST</code> requests will receive different or even semantically opposite responses. The data to be processed is specified in the body of the request. The document designated by the request via the page is the resource that must process the data and generate the response.</li>
				<li><code>HEAD</code>: The <code>HEAD</code> method is used to query the header of the response, without the file being sent to you immediately. This is useful, for example, if large files need to be transferred: thanks to the <code>HEAD</code> request, the client can be informed of the size of the file first and only then decide whether to receive the file.</li>
				<li><code>OPTIONS</code>: This is a diagnostic method, which returns a message that is useful primarily for debugging and the like. This message basically indicates, surprisingly, which HTTP methods are active on the web server. In reality, it’s rarely used for legitimate purposes these days, but it does give potential attackers a bit of help – it can be seen as a shortcut to finding another hole.</li>
				<li><code>DELETE</code> and <code>PUT</code>: These methods are supposed to allow a document<a id="_idIndexMarker030"/> to be uploaded (to the server) or deleted without going through an <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>) server or the like. Obviously, this can cause file replacements, and therefore very large security breaches on a server. Therefore, most web servers require a special configuration with a resource or a document responsible for processing these requests. The document referred to by the request is the one to be replaced (or created), and the content of the document is in the body of the request. In theory, URL parameters and the fragment identifier should be prohibited or ignored by the server. In practice, they are generally transmitted to the resource responsible for processing the request.</li>
				<li><code>PATCH</code>: The <code>PATCH</code> method of an HTTP request applies partial changes to a resource.</li>
				<li><code>TRACE</code>: The <code>TRACE</code> method can be used to trace the path that an HTTP request takes to the server and then to the client.</li>
				<li><code>CONNECT</code>: This method is supposed<a id="_idIndexMarker031"/> to be used to request the use of the server as a proxy. Not all servers necessarily implement them.</li>
			</ul>
			<p>One interesting benefit<a id="_idIndexMarker032"/> is that RESTful systems support different data formats, such as plain text, HTML, YAML, JSON, and XML.</p>
			<p>As mentioned previously, in this book, we’ll be building REST APIs using Django and Django REST.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor025"/>What is Django?</h1>
			<p>Django is an advanced web framework<a id="_idIndexMarker033"/> that was first released in 2005. It is written<a id="_idIndexMarker034"/> in Python and makes use of the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) architectural pattern. This pattern is commonly defined as follows:</p>
			<ul>
				<li><strong class="bold">Model</strong>: Corresponds to all the data-related logic. It’s deeply connected to the database, as it provides the shape of the data<a id="_idIndexMarker035"/> but also methods and functions for <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations.</li>
				<li><strong class="bold">View</strong>: Handles the UI logic of the application.</li>
				<li><strong class="bold">Controller</strong>: Represents a layer between the model and view. Most of the time, controllers interpret the incoming requests from the view, manipulate the data provided by the model component, and interact with the view again to render the final output.</li>
			</ul>
			<p>In Django, this will be referred to as the <strong class="bold">Model-View-Template</strong> (<strong class="bold">MVT</strong>) architecture with the template<a id="_idIndexMarker036"/> corresponding to the view and the view here represented by the controller. Here’s a simple representation of the MVT architecture:</p>
			<div><div><img src="img/Figure_1.2_B18221.jpg" alt="Figure 1.2 – MVT architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – MVT architecture</p>
			<p>Django is a web framework<a id="_idIndexMarker037"/> that adopts the <em class="italic">Batteries included</em> approach. When developing a custom web application, Django provides the tools required to speed up the development process. It provides code and tools for common operations such as database manipulation, HTML templates, URL routing, session management, and security.</p>
			<p>Django allows developers to build all kinds of web applications (social networks, news sites, and wikis) with all the necessary basics, such as application security, made available from the start to allow developers to fully concentrate on most of their projects. Django provides protection against commons attacks – cross-site scripting, SQL injection, and much more.</p>
			<p>Here, we’ll also be using <strong class="bold">Django REST Framework</strong> (<strong class="bold">DRF</strong>). It’s the most mature, testable, well-documented, and easily extendable<a id="_idIndexMarker038"/> framework, which will help create powerful RESTful APIs when coupled with Django. The combination of Django and the DRF is used by large companies such as Instagram, Mozilla, and even Pinterest.</p>
			<p>When this framework is coupled with Django, the view will be replaced by routes or endpoints. We’ll discuss this concept later in the book – but why build an API with Django?</p>
			<p>It’s true that traditional Django supports client languages such as HTML, CSS, and JavaScript. This helps build user interfaces that are served by the server and the performance is always impressive.</p>
			<p>However, what if you have many machines that’ll access resources on the Django server? It’s true that if these machines are running applications based on JavaScript, we can always use the traditional Django way.</p>
			<p>What if it’s a mobile application? What if it’s a service written with PHP?</p>
			<p>That’s where an API<a id="_idIndexMarker039"/> can really be useful. You can have as many machines as you want requesting data from your API without issue, irrespective of the technology or the language used to build the applications that these machines are running.</p>
			<p>Now that you have an idea about what Django is, let’s set up the working environment and create our first server in Django.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor026"/>Setting up the work environment</h1>
			<p>Before starting to work with Django, we<a id="_idIndexMarker040"/> must make sure you have a great environment, whatever OS you are using right now.</p>
			<p>First of all, make sure you have the latest version of Python installed. For this book, we’ll be working with Python 3.10.</p>
			<p>If you are using a Windows<a id="_idIndexMarker041"/> machine, go to the official download page at <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a> and download the relevant version.</p>
			<p>For Linux users, you can download it using the default repository package download manager.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor027"/>Creating a virtual environment</h2>
			<p>Now that we have Python<a id="_idIndexMarker042"/> installed, we have to ensure that we have <code>virtualenv</code> installed:</p>
			<pre class="console">
python3 -m pip install --user virtualenv</pre>
			<p>See the following for Windows users:</p>
			<pre class="console">
py -m pip install --user virtualenv</pre>
			<p>Once this is done, we can now create a virtual environment – but why?</p>
			<p>There are two types of environments when developing with Python: the global environment and the local environment.</p>
			<p>If you just enter <code>pip</code> install requests randomly in the terminal, the package will be installed and can be accessed globally: this means accessed anywhere on your machine. Sometimes, you want to isolate the working environment to avoid version conflicts. For example, globally you may be working with Python 3.5, which supports Django 2.x versions. However, for this project, you want to use Python 3.10 and the latest version of Django – here, 4.0. Creating a <code>virtualenv</code> environment helps you with that.</p>
			<p>Now that we have <code>virutalenv</code> installed, we can create and activate the <code>virtualenv</code> environment – but before that, create a directory called <code>django-api</code>. We’ll be building the Python project here.</p>
			<p>See the following for Unix or macOS:</p>
			<pre class="console">
python3 -m venv venv</pre>
			<p>See the following for Windows:</p>
			<pre class="console">
py -m venv venv</pre>
			<p>These preceding commands will create the <code>venv</code> directory containing the installed Python packages and the necessary configuration to access these packages when the virtual environment is activated. The next step is to activate the virtual environment. This will help us install the packages we need to start working on.</p>
			<p>See the following for Unix or macOS:</p>
			<pre class="console">
source venv/bin/activate</pre>
			<p>See the following<a id="_idIndexMarker043"/> for Windows:</p>
			<pre class="console">
.\venv\Scripts\activate</pre>
			<p>Great! Next, let’s install the Django package.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor028"/>Installing Django</h2>
			<p>There are two ways to install <a id="_idIndexMarker044"/>packages in Python. You can easily just run <code>pip </code><code>install package_name</code>.</p>
			<p>Alternatively, you can write the package name with the version in a text file. I’ll go with the latter but feel free to use whatever version works for you.</p>
			<p>Just understand that there can be some changes between the version and it can affect your project. For more similarities with what we’ll be using here, you can also use the latter option.</p>
			<p>Great – let’s create a file named <code>requirements.txt</code> at the root of the <code>django-api</code> directory and add the Django package name:</p>
			<pre class="console">
Django==4.0</pre>
			<p>Great! Now, run <code>pip install -r requirements.txt</code> to install Django.</p>
			<p>To make sure everything is working, we’ll quickly create a simple project.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor029"/>Creating a sample project</h2>
			<p>To create<a id="_idIndexMarker045"/> a new project, we’ll use the <code>django-admin</code> command. It comes with options we can use to create projects in Django:</p>
			<pre class="console">
django-admin startproject CoreRoot .</pre>
			<p>Don’t forget to add the <code>.</code> dot at the end of this command. This will actually generate all the files in the current directory instead of creating another directory to put all the files in.</p>
			<p>You should have a structure of a file such as this:</p>
			<div><div><img src="img/Figure_1.3_B18221.jpg" alt="Figure 1.3 – File structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – File structure</p>
			<p>Before starting the server, let’s run the migrations:</p>
			<pre class="console">
python manage.py migrate</pre>
			<p>You’ll have a similar output:</p>
			<pre class="console">
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK</pre>
			<p>Migrations are just a way to propagate<a id="_idIndexMarker046"/> changes made to the model in the database schema. As Django also comes with some models (such as the <code>User</code> model you can use for authentication), we need to apply these migrations. When we write our own models, we’ll also be creating migrations files and migrating them. Django has <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) that automatically handles the interaction<a id="_idIndexMarker047"/> with the database for you.</p>
			<p>Learning SQL and writing your own queries is quite difficult and demanding when you are new to it. It takes a long time and is quite off-putting. Fortunately, Django provides a system to take advantage of the benefits of an SQL database without having to write even a single SQL query!</p>
			<p>This type of system is called ORM. Behind<a id="_idIndexMarker048"/> this somewhat barbaric-sounding name hides a simple and very useful operation. When you create a model in your Django application, the framework will automatically create a suitable table in the database that will save the data relating to the model.</p>
			<p>No need to write SQL commands here – we’ll just write code in Python that will be directly translated into SQL. <code>python manage.py migrate</code> will then apply these changes to the database.</p>
			<p>Now, run <code>python manage.py runserver</code>. You’ll see a similar output, and you’ll also have your server running at <a href="https://localhost:8000">https://localhost:8000</a>.</p>
			<p>Just hit this URL in your browser and you will see something such as this:</p>
			<div><div><img src="img/Figure_1.4_B18221.jpg" alt="Figure 1.4 – Welcome page of the Django running server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Welcome page of the Django running server</p>
			<p>Great – we’ve just installed Django and started a Django server. Let’s talk about the structure of the project.</p>
			<h3>Discussing the sample project</h3>
			<p>In the last part, we’ve briefly<a id="_idIndexMarker049"/> talked about how to create a <code>virtualenv</code> environment with Python. We’ve also created a Django project and made it run.</p>
			<p>Let’s talk quickly about the project.</p>
			<p>You may have noticed some files and directories in the <code>django-api</code> directory. Well, let’s quickly talk about these:</p>
			<ul>
				<li><code>manage.py</code>: This is a utility provided by Django for many different needs. It’ll help you create projects and applications, run migrations, start a server, and so on.</li>
				<li><code>CoreRoot</code>: This is the name of the project we’ve created with the <code>django-admin</code> command. It contains files such as the following:<ul><li><code>urls.py</code>: This contains all the URLs that will be used to access resources in the project:<pre class="source-code">
from django.contrib import admin</pre><pre class="source-code">
from django.urls import path</pre><pre class="source-code">
urlpatterns = [</pre><pre class="source-code">
     path('admin/', admin.site.urls),</pre><pre class="source-code">
]</pre></li><li><code>wsgi.py</code>: This file is basically used for deployment but also as the default development environment in Django.</li><li><code>asgi.py</code>: Django also supports running asynchronous codes as an ASGI application.</li><li><code>settings.py</code>: This contains all the configurations for your Django projects. You can find <code>SECRET_KEY</code>, the <code>INSTALLED_APPS</code> list, <code>ALLOWED_HOST</code>, and<a id="_idIndexMarker050"/> so on.</li></ul></li>
			</ul>
			<p>Now that you are familiar with the structure of a Django project, let’s see how to configure the project to connect to a database.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor030"/>Configuring the database</h1>
			<p>Django, by default, uses <strong class="bold">sqlite3</strong> as a database, which is an<a id="_idIndexMarker051"/> in-process<a id="_idIndexMarker052"/> library that implements<a id="_idIndexMarker053"/> a fast self-contained, zero-configuration, serverless, transactional SQL database engine. It’s very compact and easy to use and set up. It’s ideal if you are looking to quickly save data or for testing. However, it comes with some disadvantages.</p>
			<p>First of all, there are no multi-user capabilities, which means that it comes with a lack of granular access control and some security capabilities. This is due to the fact that SQLite reads and writes directly to an ordinary disk file.</p>
			<p>For example, in our project, after running the migrations, you’ll notice the creation of a new file, <code>db.sqlite3</code>. Well, this is our database actually.</p>
			<p>We will be replacing it with a more powerful SMDB called <strong class="bold">Postgres</strong>.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor031"/>Postgres configuration</h2>
			<p>PostgreSQL is one of the world’s most<a id="_idIndexMarker054"/> advanced enterprise-class open source database<a id="_idIndexMarker055"/> management systems, developed and maintained by the PostgreSQL global development group. It’s a powerful and highly extensible object-relational SQL database system that comes with interesting features<a id="_idIndexMarker056"/> such as the following:</p>
			<ul>
				<li>User-defined types</li>
				<li>Table inheritance</li>
				<li>Asynchronous replication</li>
				<li>Multi-user capabilities</li>
			</ul>
			<p>These are the features you will be looking for in a database, mostly when working in a development or production environment.</p>
			<p>According<a id="_idIndexMarker057"/> to your OS, you can download<a id="_idIndexMarker058"/> Postgres versions at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>. In this book, we are working with PostgreSQL 14.</p>
			<p>Once it’s done, we’ll install<a id="_idIndexMarker059"/> a PostgreSQL<a id="_idIndexMarker060"/> adapter for Python, <strong class="bold">psycopg</strong>:</p>
			<pre class="console">
pip install psycopg2-binary</pre>
			<p>Don’t forget to add this to the <code>requirements.txt</code> file:</p>
			<pre class="source-code">
Django==4.0
psycopg2_binary==2.9.2</pre>
			<p>Great – now that we have the adapter installed, let’s quickly create the database we’ll use for this project.</p>
			<p>For that, we need to connect as a Postgres user in the terminal and then access the <code>psql</code> terminal. In that terminal, we can enter SQL commands.</p>
			<p>For Linux users, you can log in as follows:</p>
			<pre class="console">
sudo su postgres</pre>
			<p>Then, enter <code>psql</code>.</p>
			<p>Great – let’s create the database:</p>
			<pre class="console">
CREATE DATABASE coredb;</pre>
			<p>To connect to the database, we need <code>USER</code> with a password:</p>
			<pre class="console">
CREATE USER core WITH PASSWORD 'wCh29&amp;HE&amp;T83';</pre>
			<p>It’s always a good habit to use strong passwords. You can<a id="_idIndexMarker061"/> generate strong passwords at https://passwordsgenerator.net/ – and the next step is to grant access to our database to the new user:</p>
			<pre class="console">
GRANT ALL PRIVILEGES ON DATABASE coredb TO core;</pre>
			<p>We are nearly done. We also need to make sure this user can create a database. This will be helpful when we can run tests. To run tests, Django will configure a full environment but will also use a database:</p>
			<pre class="console">
 ALTER USER core CREATEDB;</pre>
			<p>With that, we are done <a id="_idIndexMarker062"/>with the creation of the database. Let’s connect<a id="_idIndexMarker063"/> this database to our Django project.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor032"/>Connecting the database</h2>
			<p>Connecting the database to Django<a id="_idIndexMarker064"/> requires some configurations. Then, we have to open the <code>settings.py</code> file, look for a database configuration, and then modify it.</p>
			<p>In the <code>settings.py</code> file, you’ll find a similar line:</p>
			<pre class="source-code">
# Database
# https://docs.djangoproject.com/en/4.0/ref        /settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}</pre>
			<p>Great – as you can see, the project is still running on the SQLite3 engine.</p>
			<p>Remove this content and replace it with this:</p>
			<pre class="source-code">
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': coredb,
        'USER': 'core',
           'PASSWORD': 'wCh29&amp;HE&amp;T83',
        'HOST': 'localhost',
        'PORT': '5342',
    }
}</pre>
			<p>We’ve just modified the database <a id="_idIndexMarker065"/>engine but also filled in information such as the name of the database, the user, the password, the host, and the port.</p>
			<p>The <code>ENGINE</code> key for the MySQL database varies. Besides that, there are a few additional keys, such as <code>USER</code>, <code>PASSWORD</code>, <code>HOST</code>, and <code>PORT</code>:</p>
			<ul>
				<li><code>NAME</code>: This key stores the name of your MySQL database</li>
				<li><code>USER</code>: This key stores the username of the MySQL account to which the MySQL database will be connected</li>
				<li><code>PASSWORD</code>: This key stores the password for this MySQL account</li>
				<li><code>HOST</code>: This key stores the IP address at which your MySQL database is hosted</li>
				<li><code>PORT</code>: This key stores the port number on which your MySQL database is hosted</li>
			</ul>
			<p>The configuration is done. Let’s run the migrations and see whether everything works okay:</p>
			<pre class="console">
python manage.py migrate</pre>
			<p>You will get a similar output in the terminal:</p>
			<pre class="console">
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK</pre>
			<p>Great! We’ve just configured Django with PostgreSQL.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Installing an HTTP request client</h1>
			<p>When developing an API<a id="_idIndexMarker066"/> as a backend developer, it’s a good habit to have an API client to test your API and make sure it behaves as you needed. API clients are packages, or libraries to send HTTP requests to an API. A great majority supports features such as SSL checking, authentication, and header modification. In this book, we’ll be working with Insomnia. It’s lightweight and simple to use and customize.</p>
			<p>To download a version of Insomnia<a id="_idIndexMarker067"/> that suits your OS, go to the following page: <a href="https://insomnia.rest/download">https://insomnia.rest/download</a>.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor034"/>Summary</h1>
			<p>In this chapter, we explored the world of backend development to clarify the roles and responsibilities of a backend developer. We also talked about APIs, mostly REST APIs, which will be built in this book. We’ve also had a brief introduction to Django, the MVT architecture used by the framework, and connected a PostgreSQL database to the Django project.</p>
			<p>In the next chapter, we will dig deeper into Django by creating our first models, tests, and endpoints.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor035"/>Questions</h1>
			<ol>
				<li>What is a REST API?</li>
				<li>What is Django?</li>
				<li>How to create a Django project?</li>
				<li>What are migrations?</li>
				<li>What is a virtual environment in Python?</li>
			</ol>
		</div>
	</body></html>