<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor016"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Creating a Django Project</h1>
			<p><strong class="bold">Django</strong> is one of the most famous backend frameworks written in Python and is often used to build simple or complex web applications. As for <strong class="bold">React</strong>, it’s one of the most widely used JavaScript libraries to create reactive and powerful user interfaces. In this chapter, we’ll focus on <span class="No-Break">Django first.</span></p>
			<p>In this chapter, we’ll briefly explain <strong class="bold">software development</strong> and, in particular, <strong class="bold">backend development</strong> in the context of what we’ll be building: a social network web application with Django and React. We’ll also talk about the most common tools used for backend development in <strong class="bold">Python</strong> – here in Django. Then, we will create a Django project and explain the most important parts of a Django project. After that, we’ll connect <strong class="bold">PostgreSQL</strong> to the <span class="No-Break">Django project.</span></p>
			<p>By the end of this chapter, you’ll understand concepts such as software development, frontend development, and backend development. You’ll also learn how to create a project in Django and start <span class="No-Break">a server.</span></p>
			<p>In this chapter, we’ll be covering the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>An overview of <span class="No-Break">software development</span></li>
				<li>Understanding <span class="No-Break">backend development</span></li>
				<li>What is <span class="No-Break">an API?</span></li>
				<li>What <span class="No-Break">is Django?</span></li>
				<li>Setting up the <span class="No-Break">work environment</span></li>
				<li>Configuring <span class="No-Break">the database</span></li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>An overview of software development</h1>
			<p>Software development is a complex process<a id="_idIndexMarker000"/> full of many steps and many components. These components ensure that conceiving, specifying, designing, programming, documenting, and testing an application, a framework, or software is respected and <span class="No-Break">well applied.</span></p>
			<p>Generally, the software is made of the following <span class="No-Break">two components:</span></p>
			<ul>
				<li>The <strong class="bold">backend</strong>: This represents what the user<a id="_idIndexMarker001"/> can’t see; it’s composed<a id="_idIndexMarker002"/> of the business logic and data manipulation from <span class="No-Break">a database</span></li>
				<li>The <strong class="bold">frontend</strong>: This represents the interface<a id="_idIndexMarker003"/> provided to the user <a id="_idIndexMarker004"/>to interact with the <span class="No-Break">whole application</span></li>
			</ul>
			<p>The term frontend refers to the elements of a site or application<a id="_idIndexMarker005"/> that users see onscreen and with which they will interact. For example, all internet users will see a combination of HTML, CSS, and JavaScript on a website. It is these frontend programming languages that will be interpreted by <span class="No-Break">the browser.</span></p>
			<p>Typically, the frontend consists of HTML, CSS, JavaScript, and jQuery (or other UI libraries or frameworks) used to replicate a design. The design is created by the web designer who will create graphic models with dedicated tools, such as Photoshop <span class="No-Break">or Figma.</span></p>
			<p>Here, we’ll focus on web development. Web development is the part of software development focused on building websites and web applications, and the notion of web development relies on a <span class="No-Break">client-server architecture.</span></p>
			<p>The client-server architecture represents an environment in which applications running on a client machine can communicate with other applications installed on a server machine, which provides services or data from <span class="No-Break">a database.</span></p>
			<p>On the web, the client will simply be a browser used to request a page or a resource from <span class="No-Break">a server.</span></p>
			<p>Here’s a simple diagram<a id="_idIndexMarker006"/> <span class="No-Break">demonstrating this:</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.1_B18221.jpg" alt="Figure 1.1 – Client-server architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Client-server architecture</p>
			<p>Now that we have a better understanding<a id="_idIndexMarker007"/> of software development, particularly web development, let’s move on to a component of it: <span class="No-Break">backend development.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor019"/>Understanding backend development</h1>
			<p>Backend development<a id="_idIndexMarker008"/> handles the behind-the-scenes of modern applications. Most of the time, it’s made of code that connects to the database, manages user connections, and also powers web applications or <span class="No-Break">the </span><span class="No-Break"><strong class="bold">API</strong></span><span class="No-Break">.</span></p>
			<p>The focus of backend development code is more on the business logic. It primarily focuses on how an application works and the functionality and logic powering <span class="No-Break">the application.</span></p>
			<p>For example, let’s talk about a web application built to manage books. Let’s suppose that the application is connected to an <span class="No-Break">SQL database.</span></p>
			<p>Whatever language is used to build the application and the structure, here are some requirements that represent the business logic and that primarily depend on the backend rather than <span class="No-Break">the frontend:</span></p>
			<ul>
				<li><strong class="bold">Adding a book (only for admin)</strong>: This supposes that the client (frontend) should be able to make a request to an API powered using whatever language is built for the backend, containing the data needed to create a new entry in the database that represents a book. This action is only available <span class="No-Break">to admins.</span></li>
				<li><strong class="bold">Listing all books</strong>: This supposes that the client should also be able to make a request to the API, and this API should send as a response a list of all the books in <span class="No-Break">JSON/XML format.</span></li>
			</ul>
			<p>Just by taking a look at these two<a id="_idIndexMarker009"/> requirements, we can quickly understand that the frontend will just be the interface through which to request these actions. However, the backend will (taking the first requirement as an example) make sure that the incoming request is possible (checking for permissions such as whether the user making the request is really an admin) and that the data in the request is valid – only after that can data be safely registered in the d<a id="_idTextAnchor020"/>atabase. Backend developers use programming languages such as Python, PHP, and Ruby to set up and configure the server. These tools will allow them to store, process, and modify information. To make these programming languages even more practical, developers will improve them with frameworks such as Symfony, Ruby on Rails, CakePHP, or CodeIgniter. These tools will make development faster and more secure. They must then ensure that these tools are always up to date and facilitate the <span class="No-Break">maintenance required.</span></p>
			<p>A backend developer<a id="_idIndexMarker010"/> is therefore responsible for creating and managing all the elements invisible to the end user. It is therefore they who are responsible for all the functionalities of the site or the application. They are also responsible for creating the database which will allow, among other things, the information provided by users to be retained. For example, the backend developer will use the databases to find the usernames and passwords that customers have used to connect. It is possible to train for this profession by training in web development or even training <span class="No-Break">in Python.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Responsibilities of backend developers</h2>
			<p>The backend is typically made of three <span class="No-Break">major parts:</span></p>
			<ul>
				<li><strong class="bold">Server</strong>: A machine or an application (NGINX) that <span class="No-Break">receives</span><span class="No-Break"><a id="_idIndexMarker011"/></span><span class="No-Break"> requests</span></li>
				<li><strong class="bold">Application</strong>: A running application<a id="_idIndexMarker012"/> on the server that receives the requests, validates these requests, and sends an <span class="No-Break">appropriate response</span></li>
				<li><strong class="bold">Database</strong>: Used to <span class="No-Break">store</span><span class="No-Break"><a id="_idIndexMarker013"/></span><span class="No-Break"> data</span></li>
			</ul>
			<p>Thus, the responsibilities<a id="_idIndexMarker014"/> of backend programmers could easily involve writing APIs, writing code to interact with a database, creating modules or libraries, also working on business data and architecture, and <span class="No-Break">much more.</span></p>
			<p>They also have to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Coordinate and communicate with frontend developers to transfer data efficiently to the client side of <span class="No-Break">the application</span></li>
				<li>Collaborate with quality assurance engineers to optimize the server-side processes and also pass some <span class="No-Break">security checks</span></li>
				<li>Optimize the application when the number of requests or users scales <span class="No-Break">as well</span></li>
				<li>Analyze the requirements of the project and create a simple structure to handle bugs <span class="No-Break">and errors</span></li>
				<li>Propose efficient solutions for cloud hosting but also build <span class="No-Break">CI/CD pipelines</span></li>
			</ul>
			<p>The backend architecture actually helps build one of the most common interfaces for consuming data in the software industry: an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>). Let’s learn more about <span class="No-Break">the term.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor022"/>What is an API?</h1>
			<p>In this book, we’ll primarily<a id="_idIndexMarker015"/> be building an API – so, what is <span class="No-Break">an API?</span></p>
			<p>Before answering this question, just <a id="_idIndexMarker016"/>remember that most of the internet is powered by <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) or <strong class="bold">RESTful APIs</strong>. An API simplifies the way data<a id="_idIndexMarker017"/> is exchanged between applications or machines. It consists mainly of <span class="No-Break">two components:</span></p>
			<ul>
				<li>The technical specification, which describes<a id="_idIndexMarker018"/> the data exchange options between the parties, with the specification made in the form of a request for data delivery protocols and <span class="No-Break">data processing</span></li>
				<li>The software interface (the programming code), which is written to the specification<a id="_idIndexMarker019"/> that <span class="No-Break">represents it</span></li>
			</ul>
			<p>For example, if the client side of your application is written in JavaScript and the server side is written in PHP, you’ll need to create a web API with PHP (as data comes from the database), which will help you write the rules and routes that will be used to <span class="No-Break">access data.</span></p>
			<p>Web APIs are relatively common<a id="_idIndexMarker020"/> and there are different specifications and protocols. The goal of API specification is to standardize—because of different programming languages and different <strong class="bold">Operating Systems</strong> (<strong class="bold">OSs</strong>)—exchanges between two or more web services. For example, you’ll find <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>): A protocol that can be used by a program<a id="_idIndexMarker021"/> to request a service from a program on another computer on a network that it does not need<a id="_idIndexMarker022"/> to know the details<a id="_idIndexMarker023"/> of. This is sometimes called a function or <span class="No-Break">subroutine call.</span></li>
				<li> <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>): An XML-based communication protocol that allows applications<a id="_idIndexMarker024"/> to exchange information with each other over HTTP. It therefore allows access to web services and the interoperability of applications across the web. SOAP is a simple and lightweight protocol that relies entirely on established standards such as HTTP and XML. It is portable and therefore independent of any OS and type of computer. SOAP is a <span class="No-Break">non-proprietary specification.</span></li>
				<li><strong class="bold">REST/RESTful</strong>: A style of architecture for building<a id="_idIndexMarker025"/> applications (web, intranet, or web service). This <a id="_idIndexMarker026"/>is a set of conventions and best practices to be observed, not a technology in its own right. The REST architecture uses the original specifications of the HTTP protocol, rather than reinventing an overlay (as SOAP or XML-RPC do, <span class="No-Break">for example):</span><ul><li><strong class="bold">Rule 1</strong>: The URL is a <span class="No-Break">resource identifier</span></li><li><strong class="bold">Rule 2</strong>: HTTP verbs are identifiers <span class="No-Break">of operations</span></li><li><strong class="bold">Rule 3</strong>: HTTP responses are representations <span class="No-Break">of resources</span></li><li><strong class="bold">Rule 4</strong>: Links are relations <span class="No-Break">between resources</span></li><li><strong class="bold">Rule 5</strong>: A parameter is an <span class="No-Break">authentication token</span></li></ul></li>
			</ul>
			<p>In this book, we’ll be building REST APIs using Django and <strong class="bold">Django REST</strong>, so let’s get to know REST a <span class="No-Break">bit better.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Understanding REST APIs</h2>
			<p>REST is usually the way<a id="_idIndexMarker027"/> to go when developers<a id="_idIndexMarker028"/> want to build an API. REST is a simple alternative to SOAP and RPC, as it makes it easier to write the logic to access resources; resources here are represented by a unique URL available with one request to <span class="No-Break">this URL.</span></p>
			<p>RESTful APIs use<a id="_idIndexMarker029"/> HTTP requests (or methods)<a id="_idTextAnchor024"/> to interact <span class="No-Break">with resources:</span></p>
			<ul>
				<li><strong class="source-inline">GET</strong>: The most commonly used method in APIs and websites. This method is used to retrieve data from a server at a specified resource. This resource is an endpoint returning an object or a list of objects in JSON or XML most of <span class="No-Break">the time.</span></li>
				<li><strong class="source-inline">POST</strong>: The <strong class="source-inline">POST</strong> method is a basic method for requesting information processing from the server. These requests are supposed to bring mechanisms specific to the server into play and cause communications with other modules, or even other servers, to process said data. Therefore, it is quite likely that two identical <strong class="source-inline">POST</strong> requests will receive different or even semantically opposite responses. The data to be processed is specified in the body of the request. The document designated by the request via the page is the resource that must process the data and generate <span class="No-Break">the response.</span></li>
				<li><strong class="source-inline">HEAD</strong>: The <strong class="source-inline">HEAD</strong> method is used to query the header of the response, without the file being sent to you immediately. This is useful, for example, if large files need to be transferred: thanks to the <strong class="source-inline">HEAD</strong> request, the client can be informed of the size of the file first and only then decide whether to receive <span class="No-Break">the file.</span></li>
				<li><strong class="source-inline">OPTIONS</strong>: This is a diagnostic method, which returns a message that is useful primarily for debugging and the like. This message basically indicates, surprisingly, which HTTP methods are active on the web server. In reality, it’s rarely used for legitimate purposes these days, but it does give potential attackers a bit of help – it can be seen as a shortcut to finding <span class="No-Break">another hole.</span></li>
				<li><strong class="source-inline">DELETE</strong> and <strong class="source-inline">PUT</strong>: These methods are supposed to allow a document<a id="_idIndexMarker030"/> to be uploaded (to the server) or deleted without going through an <strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>) server or the like. Obviously, this can cause file replacements, and therefore very large security breaches on a server. Therefore, most web servers require a special configuration with a resource or a document responsible for processing these requests. The document referred to by the request is the one to be replaced (or created), and the content of the document is in the body of the request. In theory, URL parameters and the fragment identifier should be prohibited or ignored by the server. In practice, they are generally transmitted to the resource responsible for processing <span class="No-Break">the request.</span></li>
				<li><strong class="source-inline">PATCH</strong>: The <strong class="source-inline">PATCH</strong> method of an HTTP request applies partial changes to <span class="No-Break">a resource.</span></li>
				<li><strong class="source-inline">TRACE</strong>: The <strong class="source-inline">TRACE</strong> method can be used to trace the path that an HTTP request takes to the server and then to <span class="No-Break">the client.</span></li>
				<li><strong class="source-inline">CONNECT</strong>: This method is supposed<a id="_idIndexMarker031"/> to be used to request the use of the server as a proxy. Not all servers necessarily <span class="No-Break">implement them.</span></li>
			</ul>
			<p>One interesting benefit<a id="_idIndexMarker032"/> is that RESTful systems support different data formats, such as plain text, HTML, YAML, JSON, <span class="No-Break">and XML.</span></p>
			<p>As mentioned previously, in this book, we’ll be building REST APIs using Django and <span class="No-Break">Django REST.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor025"/>What is Django?</h1>
			<p>Django is an advanced web framework<a id="_idIndexMarker033"/> that was first released in 2005. It is written<a id="_idIndexMarker034"/> in Python and makes use of the <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) architectural pattern. This pattern is commonly defined <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Model</strong>: Corresponds to all the data-related logic. It’s deeply connected to the database, as it provides the shape of the data<a id="_idIndexMarker035"/> but also methods and functions for <strong class="bold">Create, Read, Update, and Delete</strong> (<span class="No-Break"><strong class="bold">CRUD</strong></span><span class="No-Break">) operations.</span></li>
				<li><strong class="bold">View</strong>: Handles the UI logic of <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Controller</strong>: Represents a layer between the model and view. Most of the time, controllers interpret the incoming requests from the view, manipulate the data provided by the model component, and interact with the view again to render the <span class="No-Break">final output.</span></li>
			</ul>
			<p>In Django, this will be referred to as the <strong class="bold">Model-View-Template</strong> (<strong class="bold">MVT</strong>) architecture with the template<a id="_idIndexMarker036"/> corresponding to the view and the view here represented by the controller. Here’s a simple representation of the <span class="No-Break">MVT architecture:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.2_B18221.jpg" alt="Figure 1.2 – MVT architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – MVT architecture</p>
			<p>Django is a web framework<a id="_idIndexMarker037"/> that adopts the <em class="italic">Batteries included</em> approach. When developing a custom web application, Django provides the tools required to speed up the development process. It provides code and tools for common operations such as database manipulation, HTML templates, URL routing, session management, <span class="No-Break">and security.</span></p>
			<p>Django allows developers to build all kinds of web applications (social networks, news sites, and wikis) with all the necessary basics, such as application security, made available from the start to allow developers to fully concentrate on most of their projects. Django provides protection against commons attacks – cross-site scripting, SQL injection, and <span class="No-Break">much more.</span></p>
			<p>Here, we’ll also be using <strong class="bold">Django REST Framework</strong> (<strong class="bold">DRF</strong>). It’s the most mature, testable, well-documented, and easily extendable<a id="_idIndexMarker038"/> framework, which will help create powerful RESTful APIs when coupled with Django. The combination of Django and the DRF is used by large companies such as Instagram, Mozilla, and <span class="No-Break">even Pinterest.</span></p>
			<p>When this framework is coupled with Django, the view will be replaced by routes or endpoints. We’ll discuss this concept later in the book – but why build an API <span class="No-Break">with Django?</span></p>
			<p>It’s true that traditional Django supports client languages such as HTML, CSS, and JavaScript. This helps build user interfaces that are served by the server and the performance is <span class="No-Break">always impressive.</span></p>
			<p>However, what if you have many machines that’ll access resources on the Django server? It’s true that if these machines are running applications based on JavaScript, we can always use the traditional <span class="No-Break">Django way.</span></p>
			<p>What if it’s a mobile application? What if it’s a service written <span class="No-Break">with PHP?</span></p>
			<p>That’s where an API<a id="_idIndexMarker039"/> can really be useful. You can have as many machines as you want requesting data from your API without issue, irrespective of the technology or the language used to build the applications that these machines <span class="No-Break">are running.</span></p>
			<p>Now that you have an idea about what Django is, let’s set up the working environment and create our first server <span class="No-Break">in Django.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor026"/>Setting up the work environment</h1>
			<p>Before starting to work with Django, we<a id="_idIndexMarker040"/> must make sure you have a great environment, whatever OS you are using <span class="No-Break">right now.</span></p>
			<p>First of all, make sure you have the latest version of Python installed. For this book, we’ll be working with <span class="No-Break">Python 3.10.</span></p>
			<p>If you are using a Windows<a id="_idIndexMarker041"/> machine, go to the official download page at <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a> and download the <span class="No-Break">relevant version.</span></p>
			<p>For Linux users, you can download it using the default repository package <span class="No-Break">download manager.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor027"/>Creating a virtual environment</h2>
			<p>Now that we have Python<a id="_idIndexMarker042"/> installed, we have to ensure that we have <span class="No-Break"><strong class="source-inline">virtualenv</strong></span><span class="No-Break"> installed:</span></p>
			<pre class="console">
python3 -m pip install --user virtualenv</pre>
			<p>See the following for <span class="No-Break">Windows users:</span></p>
			<pre class="console">
py -m pip install --user virtualenv</pre>
			<p>Once this is done, we can now create a virtual environment – <span class="No-Break">but why?</span></p>
			<p>There are two types of environments when developing with Python: the global environment and the <span class="No-Break">local environment.</span></p>
			<p>If you just enter <strong class="source-inline">pip</strong> install requests randomly in the terminal, the package will be installed and can be accessed globally: this means accessed anywhere on your machine. Sometimes, you want to isolate the working environment to avoid version conflicts. For example, globally you may be working with Python 3.5, which supports Django 2.x versions. However, for this project, you want to use Python 3.10 and the latest version of Django – here, 4.0. Creating a <strong class="source-inline">virtualenv</strong> environment helps you <span class="No-Break">with that.</span></p>
			<p>Now that we have <strong class="source-inline">virutalenv</strong> installed, we can create and activate the <strong class="source-inline">virtualenv</strong> environment – but before that, create a directory called <strong class="source-inline">django-api</strong>. We’ll be building the Python <span class="No-Break">project here.</span></p>
			<p>See the following for Unix <span class="No-Break">or macOS:</span></p>
			<pre class="console">
python3 -m venv venv</pre>
			<p>See the following <span class="No-Break">for Windows:</span></p>
			<pre class="console">
py -m venv venv</pre>
			<p>These preceding commands will create the <strong class="source-inline">venv</strong> directory containing the installed Python packages and the necessary configuration to access these packages when the virtual environment is activated. The next step is to activate the virtual environment. This will help us install the packages we need to start <span class="No-Break">working on.</span></p>
			<p>See the following for Unix <span class="No-Break">or macOS:</span></p>
			<pre class="console">
source venv/bin/activate</pre>
			<p>See the following<a id="_idIndexMarker043"/> <span class="No-Break">for Windows:</span></p>
			<pre class="console">
.\venv\Scripts\activate</pre>
			<p>Great! Next, let’s install the <span class="No-Break">Django package.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor028"/>Installing Django</h2>
			<p>There are two ways to install <a id="_idIndexMarker044"/>packages in Python. You can easily just run <strong class="source-inline">pip </strong><span class="No-Break"><strong class="source-inline">install package_name</strong></span><span class="No-Break">.</span></p>
			<p>Alternatively, you can write the package name with the version in a text file. I’ll go with the latter but feel free to use whatever version works <span class="No-Break">for you.</span></p>
			<p>Just understand that there can be some changes between the version and it can affect your project. For more similarities with what we’ll be using here, you can also use the <span class="No-Break">latter option.</span></p>
			<p>Great – let’s create a file named <strong class="source-inline">requirements.txt</strong> at the root of the <strong class="source-inline">django-api</strong> directory and add the Django <span class="No-Break">package name:</span></p>
			<pre class="console">
Django==4.0</pre>
			<p>Great! Now, run <strong class="source-inline">pip install -r requirements.txt</strong> to <span class="No-Break">install Django.</span></p>
			<p>To make sure everything is working, we’ll quickly create a <span class="No-Break">simple project.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor029"/>Creating a sample project</h2>
			<p>To create<a id="_idIndexMarker045"/> a new project, we’ll use the <strong class="source-inline">django-admin</strong> command. It comes with options we can use to create projects <span class="No-Break">in Django:</span></p>
			<pre class="console">
django-admin startproject CoreRoot .</pre>
			<p>Don’t forget to add the <strong class="source-inline">.</strong> dot at the end of this command. This will actually generate all the files in the current directory instead of creating another directory to put all the <span class="No-Break">files in.</span></p>
			<p>You should have a structure of a file such <span class="No-Break">as this:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.3_B18221.jpg" alt="Figure 1.3 – File structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – File structure</p>
			<p>Before starting the server, let’s run <span class="No-Break">the migrations:</span></p>
			<pre class="console">
python manage.py migrate</pre>
			<p>You’ll have a <span class="No-Break">similar output:</span></p>
			<pre class="console">
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK</pre>
			<p>Migrations are just a way to propagate<a id="_idIndexMarker046"/> changes made to the model in the database schema. As Django also comes with some models (such as the <strong class="source-inline">User</strong> model you can use for authentication), we need to apply these migrations. When we write our own models, we’ll also be creating migrations files and migrating them. Django has <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) that automatically handles the interaction<a id="_idIndexMarker047"/> with the database <span class="No-Break">for you.</span></p>
			<p>Learning SQL and writing your own queries is quite difficult and demanding when you are new to it. It takes a long time and is quite off-putting. Fortunately, Django provides a system to take advantage of the benefits of an SQL database without having to write even a single <span class="No-Break">SQL query!</span></p>
			<p>This type of system is called ORM. Behind<a id="_idIndexMarker048"/> this somewhat barbaric-sounding name hides a simple and very useful operation. When you create a model in your Django application, the framework will automatically create a suitable table in the database that will save the data relating to <span class="No-Break">the model.</span></p>
			<p>No need to write SQL commands here – we’ll just write code in Python that will be directly translated into SQL. <strong class="source-inline">python manage.py migrate</strong> will then apply these changes to <span class="No-Break">the database.</span></p>
			<p>Now, run <strong class="source-inline">python manage.py runserver</strong>. You’ll see a similar output, and you’ll also have your server running <span class="No-Break">at </span><a href="https://localhost:8000"><span class="No-Break">https://localhost:8000</span></a><span class="No-Break">.</span></p>
			<p>Just hit this URL in your browser and you will see something such <span class="No-Break">as this:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.4_B18221.jpg" alt="Figure 1.4 – Welcome page of the Django running server"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Welcome page of the Django running server</p>
			<p>Great – we’ve just installed Django and started a Django server. Let’s talk about the structure of <span class="No-Break">the project.</span></p>
			<h3>Discussing the sample project</h3>
			<p>In the last part, we’ve briefly<a id="_idIndexMarker049"/> talked about how to create a <strong class="source-inline">virtualenv</strong> environment with Python. We’ve also created a Django project and made <span class="No-Break">it run.</span></p>
			<p>Let’s talk quickly about <span class="No-Break">the project.</span></p>
			<p>You may have noticed some files and directories in the <strong class="source-inline">django-api</strong> directory. Well, let’s quickly talk <span class="No-Break">about these:</span></p>
			<ul>
				<li><strong class="source-inline">manage.py</strong>: This is a utility provided by Django for many different needs. It’ll help you create projects and applications, run migrations, start a server, and <span class="No-Break">so on.</span></li>
				<li><strong class="source-inline">CoreRoot</strong>: This is the name of the project we’ve created with the <strong class="source-inline">django-admin</strong> command. It contains files such as <span class="No-Break">the following:</span><ul><li><strong class="source-inline">urls.py</strong>: This contains all the URLs that will be used to access resources in <span class="No-Break">the project:</span><pre class="source-code">
from django.contrib import admin</pre><pre class="source-code">
from django.urls import path</pre><pre class="source-code">
urlpatterns = [</pre><pre class="source-code">
     path('admin/', admin.site.urls),</pre><pre class="source-code">
]</pre></li><li><strong class="source-inline">wsgi.py</strong>: This file is basically used for deployment but also as the default development environment <span class="No-Break">in Django.</span></li><li><strong class="source-inline">asgi.py</strong>: Django also supports running asynchronous codes as an <span class="No-Break">ASGI application.</span></li><li><strong class="source-inline">settings.py</strong>: This contains all the configurations for your Django projects. You can find <strong class="source-inline">SECRET_KEY</strong>, the <strong class="source-inline">INSTALLED_APPS</strong> list, <strong class="source-inline">ALLOWED_HOST</strong>, and<a id="_idIndexMarker050"/> <span class="No-Break">so on.</span></li></ul></li>
			</ul>
			<p>Now that you are familiar with the structure of a Django project, let’s see how to configure the project to connect to <span class="No-Break">a database.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor030"/>Configuring the database</h1>
			<p>Django, by default, uses <strong class="bold">sqlite3</strong> as a database, which is an<a id="_idIndexMarker051"/> in-process<a id="_idIndexMarker052"/> library that implements<a id="_idIndexMarker053"/> a fast self-contained, zero-configuration, serverless, transactional SQL database engine. It’s very compact and easy to use and set up. It’s ideal if you are looking to quickly save data or for testing. However, it comes with <span class="No-Break">some disadvantages.</span></p>
			<p>First of all, there are no multi-user capabilities, which means that it comes with a lack of granular access control and some security capabilities. This is due to the fact that SQLite reads and writes directly to an ordinary <span class="No-Break">disk file.</span></p>
			<p>For example, in our project, after running the migrations, you’ll notice the creation of a new file, <strong class="source-inline">db.sqlite3</strong>. Well, this is our <span class="No-Break">database actually.</span></p>
			<p>We will be replacing it with a more powerful SMDB <span class="No-Break">called </span><span class="No-Break"><strong class="bold">Postgres</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor031"/>Postgres configuration</h2>
			<p>PostgreSQL is one of the world’s most<a id="_idIndexMarker054"/> advanced enterprise-class open source database<a id="_idIndexMarker055"/> management systems, developed and maintained by the PostgreSQL global development group. It’s a powerful and highly extensible object-relational SQL database system that comes with interesting features<a id="_idIndexMarker056"/> such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">User-defined types</span></li>
				<li><span class="No-Break">Table inheritance</span></li>
				<li><span class="No-Break">Asynchronous replication</span></li>
				<li><span class="No-Break">Multi-user capabilities</span></li>
			</ul>
			<p>These are the features you will be looking for in a database, mostly when working in a development or <span class="No-Break">production environment.</span></p>
			<p>According<a id="_idIndexMarker057"/> to your OS, you can download<a id="_idIndexMarker058"/> Postgres versions at <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>. In this book, we are working with <span class="No-Break">PostgreSQL 14.</span></p>
			<p>Once it’s done, we’ll install<a id="_idIndexMarker059"/> a PostgreSQL<a id="_idIndexMarker060"/> adapter for <span class="No-Break">Python, </span><span class="No-Break"><strong class="bold">psycopg</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
pip install psycopg2-binary</pre>
			<p>Don’t forget to add this to the <span class="No-Break"><strong class="source-inline">requirements.txt</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
Django==4.0
psycopg2_binary==2.9.2</pre>
			<p>Great – now that we have the adapter installed, let’s quickly create the database we’ll use for <span class="No-Break">this project.</span></p>
			<p>For that, we need to connect as a Postgres user in the terminal and then access the <strong class="source-inline">psql</strong> terminal. In that terminal, we can enter <span class="No-Break">SQL commands.</span></p>
			<p>For Linux users, you can log in <span class="No-Break">as follows:</span></p>
			<pre class="console">
sudo su postgres</pre>
			<p>Then, <span class="No-Break">enter </span><span class="No-Break"><strong class="source-inline">psql</strong></span><span class="No-Break">.</span></p>
			<p>Great – let’s create <span class="No-Break">the database:</span></p>
			<pre class="console">
CREATE DATABASE coredb;</pre>
			<p>To connect to the database, we need <strong class="source-inline">USER</strong> with <span class="No-Break">a password:</span></p>
			<pre class="console">
CREATE USER core WITH PASSWORD 'wCh29&amp;HE&amp;T83';</pre>
			<p>It’s always a good habit to use strong passwords. You can<a id="_idIndexMarker061"/> generate strong passwords at https://passwordsgenerator.net/ – and the next step is to grant access to our database to the <span class="No-Break">new user:</span></p>
			<pre class="console">
GRANT ALL PRIVILEGES ON DATABASE coredb TO core;</pre>
			<p>We are nearly done. We also need to make sure this user can create a database. This will be helpful when we can run tests. To run tests, Django will configure a full environment but will also use <span class="No-Break">a database:</span></p>
			<pre class="console">
 ALTER USER core CREATEDB;</pre>
			<p>With that, we are done <a id="_idIndexMarker062"/>with the creation of the database. Let’s connect<a id="_idIndexMarker063"/> this database to our <span class="No-Break">Django project.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor032"/>Connecting the database</h2>
			<p>Connecting the database to Django<a id="_idIndexMarker064"/> requires some configurations. Then, we have to open the <strong class="source-inline">settings.py</strong> file, look for a database configuration, and then <span class="No-Break">modify it.</span></p>
			<p>In the <strong class="source-inline">settings.py</strong> file, you’ll find a <span class="No-Break">similar line:</span></p>
			<pre class="source-code">
# Database
# https://docs.djangoproject.com/en/4.0/ref        /settings/#databases
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}</pre>
			<p>Great – as you can see, the project is still running on the <span class="No-Break">SQLite3 engine.</span></p>
			<p>Remove this content and replace it <span class="No-Break">with this:</span></p>
			<pre class="source-code">
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': coredb,
        'USER': 'core',
           'PASSWORD': 'wCh29&amp;HE&amp;T83',
        'HOST': 'localhost',
        'PORT': '5342',
    }
}</pre>
			<p>We’ve just modified the database <a id="_idIndexMarker065"/>engine but also filled in information such as the name of the database, the user, the password, the host, and <span class="No-Break">the port.</span></p>
			<p>The <strong class="source-inline">ENGINE</strong> key for the MySQL database varies. Besides that, there are a few additional keys, such as <strong class="source-inline">USER</strong>, <strong class="source-inline">PASSWORD</strong>, <strong class="source-inline">HOST</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">PORT</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">NAME</strong>: This key stores the name of your <span class="No-Break">MySQL database</span></li>
				<li><strong class="source-inline">USER</strong>: This key stores the username of the MySQL account to which the MySQL database will <span class="No-Break">be connected</span></li>
				<li><strong class="source-inline">PASSWORD</strong>: This key stores the password for this <span class="No-Break">MySQL account</span></li>
				<li><strong class="source-inline">HOST</strong>: This key stores the IP address at which your MySQL database <span class="No-Break">is hosted</span></li>
				<li><strong class="source-inline">PORT</strong>: This key stores the port number on which your MySQL database <span class="No-Break">is hosted</span></li>
			</ul>
			<p>The configuration is done. Let’s run the migrations and see whether everything <span class="No-Break">works okay:</span></p>
			<pre class="console">
python manage.py migrate</pre>
			<p>You will get a similar output in <span class="No-Break">the terminal:</span></p>
			<pre class="console">
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying sessions.0001_initial... OK</pre>
			<p>Great! We’ve just configured Django <span class="No-Break">with PostgreSQL.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor033"/>Installing an HTTP request client</h1>
			<p>When developing an API<a id="_idIndexMarker066"/> as a backend developer, it’s a good habit to have an API client to test your API and make sure it behaves as you needed. API clients are packages, or libraries to send HTTP requests to an API. A great majority supports features such as SSL checking, authentication, and header modification. In this book, we’ll be working with Insomnia. It’s lightweight and simple to use <span class="No-Break">and customize.</span></p>
			<p>To download a version of Insomnia<a id="_idIndexMarker067"/> that suits your OS, go to the following <span class="No-Break">page: </span><a href="https://insomnia.rest/download"><span class="No-Break">https://insomnia.rest/download</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor034"/>Summary</h1>
			<p>In this chapter, we explored the world of backend development to clarify the roles and responsibilities of a backend developer. We also talked about APIs, mostly REST APIs, which will be built in this book. We’ve also had a brief introduction to Django, the MVT architecture used by the framework, and connected a PostgreSQL database to the <span class="No-Break">Django project.</span></p>
			<p>In the next chapter, we will dig deeper into Django by creating our first models, tests, <span class="No-Break">and endpoints.</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor035"/>Questions</h1>
			<ol>
				<li>What is a <span class="No-Break">REST API?</span></li>
				<li>What <span class="No-Break">is Django?</span></li>
				<li>How to create a <span class="No-Break">Django project?</span></li>
				<li>What <span class="No-Break">are migrations?</span></li>
				<li>What is a virtual environment <span class="No-Break">in Python?</span></li>
			</ol>
		</div>
	</body></html>