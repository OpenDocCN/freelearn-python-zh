<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-33"><a id="_idTextAnchor033"/>2</h1>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>Python Entities and API</h1>
<p>Blender expands Python by making the <strong class="bold">modules</strong> of its <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) available inside the app.</p>
<p>These modules provide <strong class="bold">wrappers</strong> that translate Blender’s internal data into Python objects. Comprehensive documentation and an API reference are available online and can be reached from inside the application. Plus, there are some extra features to help programmers in their journey.</p>
<p>Much like the syntax highlight that we have met in <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, some features for developers are common-place in the programming world. Others, such as property tooltips and variables display, are specific to Blender.</p>
<p>In this chapter, we are going to look at some <strong class="bold">snippets</strong>, that is, chunks of code, that will help you become confident with the architecture of Blender’s API.</p>
<p>Generally, the API is designed to be very friendly to programmers that are already experienced with Python, only deviating a few times from the standards.</p>
<p>By the end of this chapter, you will be able to inspect Blender objects from the Python console and change their properties, use and expand Blender collections, and check the current state of the user interaction.</p>
<p>In this chapter, we are going to become familiar with the following topics:</p>
<ul>
<li>Features of Python</li>
<li>Blender modules and their structure</li>
<li>Data and Context Access</li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/>Technical requirements</h1>
<p>Only Blender is needed to follow along with this chapter.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Useful features of Python</h1>
<p>We already met the <em class="italic">Python</em> elements of the <strong class="bold">Scripting</strong> workspace in <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>. Now we are going to look at some useful features that can help us get the most out of them. When it comes to <a id="_idIndexMarker073"/>programming, automation can speed up the search for attributes and terms. That can happen both in the console, through conventional methods such as <strong class="bold">autocompletion</strong>, or in the interface, via shortcuts that display the Python address of a graphic element. Some of these features are already available when Blender starts, while others are left for the users to enable.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Options for developers</h2>
<p>Developer features are <a id="_idIndexMarker074"/>disabled by default. They can be enabled in the <strong class="bold">Preferences</strong> dialog from the <strong class="bold">Edit</strong> menu in the top bar of Blender. We need to select the <strong class="bold">Interface</strong> tab on the left and look at the first panel: <strong class="bold">Display</strong>. Programmers usually enable the <strong class="bold">Developer Extras</strong> and <strong class="bold">Python </strong><strong class="bold">Tooltips</strong> options.</p>
<h3>Developer Extras</h3>
<p><strong class="bold">Developer Extras</strong> adds a right-click <a id="_idIndexMarker075"/>menu entry that can display the Python source code of the UI in the <em class="italic">Text Editor</em>. It also shows the geometry index of mesh components when the user switches to <strong class="bold">Edit Mode</strong>. Among other things, it allows the <strong class="bold">search bar</strong> to execute operators that cannot be accessed via the UI.</p>
<h3>Python tooltips</h3>
<p>Hovering the mouse <a id="_idIndexMarker076"/>cursor over an attribute displays a tooltip with a small description. If Python tooltips are enabled, information about how to invoke that attribute in scripts is displayed as well.</p>
<div><div><img alt="Figure 2.1: Blender’s display preferences" height="790" src="img/Figure_2.1_B18375.jpg" width="1273"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: Blender’s display preferences</p>
<p>For instance, in the 3D <a id="_idIndexMarker077"/>Viewport, we can press the <em class="italic">N</em> key to display the <strong class="bold">transform channels</strong> on the right-hand side of the screen. Leaving the mouse pointer over a coordinate, such as <strong class="bold">Location:</strong> <strong class="bold">X</strong>, for a while will show two additional lines in the description:</p>
<div><div><img alt="Figure 2.2: Python tooltip of an object location" height="327" src="img/Figure_2.2_B18375.jpg" width="530"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: Python tooltip of an object location</p>
<p>The Python tooltip consists of two lines:</p>
<pre class="source-code">
Python: Object.location
bpy.data.objects['Cube'].location[0]</pre>
<p>The first line provides the Python <a id="_idIndexMarker078"/>name of the attribute; in this case, <code>location</code> is the <code>Object</code> position in space.</p>
<p>The second line is more specific: the location of this object (<code>'Cube'</code>) can be reached by typing that <a id="_idIndexMarker079"/>line in the console. This is usually referred to as the <strong class="bold">full data path</strong> of the property or, on <a id="_idIndexMarker080"/>some occasions, the <strong class="bold">RNA</strong> path. The latter term comes from a playful analogy to genetics: if Blender’s internal code <a id="_idIndexMarker081"/>makes its <em class="italic">DNA</em>, its <em class="italic">Python</em> access can be seen as the <em class="italic">RNA</em> of the application.</p>
<p>An object’s location is a simple case, other attributes can be more complex. Anyway, we can copy data paths to the clipboard following the steps in the next subsection.</p>
<h3>Copying the data path</h3>
<p>Right-clicking <a id="_idIndexMarker082"/>on a property opens a <em class="italic">context</em> menu. Some entries, such as <strong class="bold">Insert Keyframes</strong> and <strong class="bold">Reset to Default Value</strong>, are useful for animation. In this section, we will focus on the programming entries, <strong class="bold">Copy Data Path</strong> and <strong class="bold">Copy Full </strong><strong class="bold">Data Path</strong>:</p>
<ol>
<li>Select an object in the 3D Viewport.</li>
<li>If no transform properties are displayed on the right, press <em class="italic">N</em> to summon the <strong class="bold">Transform</strong> sidebar.</li>
<li>From the <strong class="bold">Item</strong> tab, right-click on the first location channel (<strong class="bold">X</strong>), then click <strong class="bold">Copy Full </strong><strong class="bold">Data Path</strong>.</li>
</ol>
<div><div><img alt="Figure 2.3: Right-click menu for location X" height="660" src="img/Figure_2.3_B18375.jpg" width="532"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: Right-click menu for location X</p>
<ol>
<li value="4">Go to the Python console, press <em class="italic">Ctrl</em> + <em class="italic">V</em> to paste, and then press <em class="italic">Enter</em>.</li>
</ol>
<p>The console will display the location value for the <em class="italic">X</em> coordinate:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects['Cube'].location[0]
0.0</pre>
<p>The full data path <a id="_idIndexMarker083"/>allows to access an attribute and, unless it is a read-only property, change its value. We can see how the copied line ends with an index, which is due to <code>location</code> being a three-dimensional attribute – each index refers to an axis of the space:</p>
<pre class="source-code">
bpy.data.objects['Cube'].location[0]  # X axis
bpy.data.objects['Cube'].location[1]  # Y axis
bpy.data.objects['Cube'].location[2]  # Z axis</pre>
<p>Data paths can be convoluted sometimes, but in the next section, we are going to look at some console tools that help a lot when looking for the right attribute.</p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Python console’s utilities</h2>
<p>The <em class="italic">Python console</em> offers some helpful utilities. Some of them, such as text completion and history, <a id="_idIndexMarker084"/>are common among programmers’ tools. Others, such as the 3D representation of variables, are typical of Blender. This section provides an overview of how the Python console is used in day-to-day programming.</p>
<h3>Autocompletion</h3>
<p>Pressing the <em class="italic">Tab</em> button while <a id="_idIndexMarker085"/>typing in the console suggests a few possible ways to complete the line. On top of that, if the current statement is associated with internal documentation (<code>print()</code>:</p>
<ol>
<li>In Blender, select <strong class="bold">Scripting Workspace</strong> in the tabs at the top of the screen, as we learned in the <em class="italic">The Scripting Workspace</em> section, in <em class="italic">First steps with Python</em>, in <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</li>
<li>In the Python console, type only <code>prin</code>, then press <em class="italic">Tab</em>.</li>
</ol>
<p>The console fills in the missing letters and displays <code>print(</code>, with an open bracket, and its documentation. Then, it lets the programmer finish the line.</p>
<div><div><img alt="Figure 2.4: Autocompletion in the Python console" height="438" src="img/Figure_2.4_B18375.jpg" width="1522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: Autocompletion in the Python console</p>
<h3>History</h3>
<p>Previous commands <a id="_idIndexMarker087"/>executed in Blender’s Python console can be retrieved using the up/down arrow keys. This can be tested with any code. Here is an example to run in the Python console:</p>
<ol>
<li>Type <code>print('Line One')</code>, then press <em class="italic">Enter</em>.</li>
<li>Press the <em class="italic">↑</em> key. The current text will change to the following:<pre class="source-code">
<strong class="bold">&gt;&gt;&gt; print("Line One")</strong></pre></li>
<li>Delete the last letters and change the line to <code>print('Line Two')</code>, then press <em class="italic">Enter</em>.</li>
<li>Press <em class="italic">↑</em> twice to display <code>&gt;&gt;&gt; print('Line </code><code>One')</code> again.</li>
<li>Alternate between pressing <em class="italic">↓</em> and <em class="italic">↑</em> to switch between the two commands.</li>
</ol>
<h3>Multiline input</h3>
<p>Snippets <a id="_idIndexMarker088"/>consisting of two or more lines can be pasted to the console and executed by pressing <em class="italic">Enter</em> twice.</p>
<p>Since blank lines mark the end of a snippet, they can make valid code fail when present inside indented blocks. Let’s look at a simple example: a condition containing two <code>print</code> statements separated by a line:</p>
<pre class="source-code">
if True<a id="_idTextAnchor039"/>:
    print('Line One')
    print('Line Two')</pre>
<p>This code works in the <em class="italic">Text Editor</em> but fails in the <em class="italic">Python console</em>. Here is the output:</p>
<pre class="source-code">
&gt;&gt;&gt; if True:
...     print('Line One')
...
Line One
&gt;&gt;&gt;     print('Line Two')
  File "&lt;blender_console&gt;", line 1
    print("Line Two")
IndentationError: unexpected indent</pre>
<p>After the first <a id="_idIndexMarker089"/>two lines are executed, the indentation of the second <code>print()</code> is considered wrong.</p>
<p>Blank lines should be replaced with comments (<code>#</code>) in every snippet meant for the console. The following code will work:</p>
<pre class="source-code">
if True:
    print('Line One')
    #
    print('Line Two')</pre>
<h3>Displaying 3D variables in the 3D Viewport</h3>
<p>Variables that <a id="_idIndexMarker090"/>represent a 3D point or transformation can be displayed in the three-dimensional space. This is made possible by the <strong class="bold">Math Vis (Console)</strong> add-on. <strong class="bold">Add-ons</strong> are Python extensions that can be enabled at need. We are going to write our own add-ons in this book. For now, we will see how to enable an add-on that ships with Blender.</p>
<h4>Enabling the Math Vis (Console) add-on</h4>
<p>Add-ons can <a id="_idIndexMarker091"/>be enabled in the preferences:</p>
<ol>
<li>From the top-bar menu, select <strong class="bold">Edit | </strong><strong class="bold">Preferences</strong>.</li>
<li>Choose the <strong class="bold">Add-ons</strong> tab in the left column.</li>
<li>Type <code>Math Vis</code> in the search filter marked with the magnifier icon.</li>
<li>Click the checkbox to the left of the add-on name.</li>
</ol>
<h4>Creating 3D variables</h4>
<p>Blender provides <a id="_idIndexMarker092"/>additional Python types for 3D entities. For instance, coordinates can be stored using a <code>Vector</code> type. We can store a vector in a variable by typing:</p>
<pre class="source-code">
my_vector = Vector([1.0, 2.0, 3.0])</pre>
<p>Since we have enabled the <em class="italic">Math Vis (Console)</em> add-on, a pink dot followed by the variable name will appear in the 3D Viewport.</p>
<div><div><img alt="Figure 2.5: Vector coordinates [1.0, 2.0, 3.0], as displayed in the 3D Viewport" height="902" src="img/Figure_2._05_B18375.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Vector coordinates [1.0, 2.0, 3.0], as displayed in the 3D Viewport</p>
<p>Variables are visualized only when the console is visible, as long as they exist. The drawing stops once they are deleted with the following:</p>
<pre class="source-code">
del my_vector</pre>
<p>The <code>del</code> statement is a standard Python command. We should keep in mind that it deletes Python variables, not Blender objects.</p>
<p>If we want to delete objects in Blender, we can use Blender’s <code>delete()</code> command:</p>
<pre class="source-code">
bpy.ops.object.delete()</pre>
<p><code>ops</code> in the preceding <a id="_idIndexMarker093"/>command stands for <code>bpy.ops.object.delete()</code>, this means pressing the <em class="italic">X</em> key or selecting the <strong class="bold">Delete</strong> action from the <strong class="bold">Object</strong> menu.</p>
<p>Types with a geometrical meaning, such as <code>Vector</code>, <code>Matrix</code>, and <code>Euler</code>, are mathematical constructs and belong to the <code>mathutils</code> module. This module is imported into the <em class="italic">console</em> automatically. There is no need to import it again in the console. If we were to use it in a script, we would have to import it from the module:</p>
<pre class="source-code">
from mathutils import Vector
my_vector = Vector([1.0, 2.0, 3.0])</pre>
<p>We are going to <a id="_idIndexMarker094"/>explore <code>mathutils</code> in the next chapters, when dealing with 3D objects and elements. In the next section, we’ll get familiar with how Blender objects translate into Python.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Accessing Blender modules</h1>
<p>Blender’s additional <a id="_idIndexMarker095"/>modules are available throughout the application and can be used via the standard <code>import</code> statement. They are available in the Python console, the Text Editor, and generally in the scripts that are installed in the Blender system and user paths.</p>
<p>Some modules are very specific; for instance, the <code>freestyle</code> module handles the settings of the freestyle stylized rendering and cannot be used for any other purpose. Others, such as <code>mathutils</code>, come into play whenever numbers are concerned.</p>
<p>Finally, the <code>bpy</code> module and its submodules play a bigger role in Blender scripts, as they grant access to objects and data.</p>
<p>In this section, we will have a closer look at <code>bpy</code>, how it is already present in the console, and how we can use it in our scripts. We will also learn where to find more information about the API and its elements.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>The bpy module</h2>
<p>In <a href="B18375_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, we copied the lines from the console using <strong class="bold">Console</strong>-&gt;<strong class="bold">Copy</strong> from <a id="_idIndexMarker096"/>the Python console editor and pasted them <a id="_idIndexMarker097"/>into a text block. In doing so, we found a few extra lines at the beginning:</p>
<pre class="source-code">
import bpy
from bpy import data as D
from bpy import context as C
...</pre>
<p>The first line imports <code>bpy</code>, the main module of the programming interface. Lines two and three import <code>data</code> and <code>context</code> and assign them, respectively, the <code>D</code> and <code>C</code> letters as convenience shortcuts. This is pointed out in the initial screen:</p>
<div><div><img alt="Figure 2.6: Python console’s convenience variables" height="238" src="img/Figure_2.6_B18375.jpg" width="1522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: Python console’s convenience variables</p>
<p><code>data</code> represents <a id="_idIndexMarker098"/>the storage of Blender objects and <code>context</code> is the <a id="_idIndexMarker099"/>current state of the user interaction, such as the selection or the current mode (<strong class="bold">Object</strong>, <strong class="bold">Edit</strong>, <strong class="bold">Pose</strong>, etc.).</p>
<p>Because of their nature, <code>context</code> and <code>data</code> are always present in Blender scripts. The autocompletion gives a glimpse of the other modules. If we type <code>bpy.</code> and press <em class="italic">Tab</em>, we’ll get a list of them.</p>
<div><div><img alt="Figure 2.7: bpy’s submodules" height="550" src="img/Figure_2.7_B18375.jpg" width="1523"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: bpy’s submodules</p>
<p>Each attribute of <code>bpy</code> covers a specific aspect of Blender. For instance, <code>bpy.app</code> contains the properties of the software (executable and version) and <code>bpy.ops</code> contains the operators, that is, functions that can be invoked in the interface.</p>
<p><code>bpy</code> and the <a id="_idIndexMarker100"/>other Blender modules contain a multitude of classes, methods, <a id="_idIndexMarker101"/>and utilities. These entities are documented in the <em class="italic">Python API Reference</em>, which is available online and can be downloaded if needed.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>API documentation</h2>
<p>The reference <a id="_idIndexMarker102"/>website can be reached via <strong class="bold">Help</strong> | <strong class="bold">Python API Reference</strong> from <a id="_idIndexMarker103"/>the top menu bar.</p>
<div><div><img alt="Figure 2.8: The link to the Python API Reference" height="534" src="img/Figure_2.8_B18375.jpg" width="908"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: The link to the Python API Reference</p>
<p>The <em class="italic">Python Help</em> for the current version will open in the web browser. The documentation is generated <a id="_idIndexMarker104"/>from the docstrings using software called <code>help()</code> function.</p>
<div><div><img alt="Figure 2.9: Comparison between the help() function and online help for the Euler class" height="565" src="img/Figure_2.9_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Comparison between the help() function and online help for the Euler class</p>
<p>The online help has the advantage of a search bar and doesn’t take space from our Blender session. It <a id="_idIndexMarker105"/>contains an index of the available <a id="_idIndexMarker106"/>modules and their content.</p>
<p>An API reference is very useful to navigate the various modules and the attributes of <code>bpy</code>.</p>
<p>In this chapter, we’ll focus on <code>bpy.data</code> and <code>bpy.context</code>, leaving the specific functionalities of the other modules to the next chapters.</p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor043"/>Accessing Blender data</h1>
<p>All the entities created <a id="_idIndexMarker107"/>in the current session are available as part of <code>bpy.data</code>. They are grouped in categories that follow the <code>bpy.data.armatures</code>, <code>bpy.data.curves</code>, and so on. Each category is a <code>bpy_collection</code>, a Blender type that contains more elements. Their content can be accessed with indices, like in a Python <code>list</code>, or with keywords, like in dictionaries.</p>
<h3>Objects access</h3>
<p>We can use Python <a id="_idIndexMarker108"/>to access the objects of a scene. For example, we can query the content of Blender’s default scene, which contains a <strong class="bold">Cube</strong>, a <strong class="bold">Camera</strong> and a <strong class="bold">Light</strong>:</p>
<ol>
<li>Open or restart Blender and select <strong class="bold">Scripting Workspace</strong> in the workspace tabs at the top of the screen.</li>
</ol>
<div><div><img alt="Figure 2.10: The workspace tabs" height="180" src="img/Figure_2.10_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: The workspace tabs</p>
<ol>
<li value="2">Type <code>len(bpy.data.objects)</code> and press <em class="italic">Enter</em>:<pre class="source-code">
&gt;&gt;&gt; len(bpy.data.objects)</pre><pre class="source-code">
3</pre></li>
<li>In the Python console, type <code>bpy.data.objects</code>, then press <em class="italic">Tab</em>.</li>
</ol>
<div><div><img alt="Figure 2.11: Blender’s default objects" height="383" src="img/Figure_2.11_B18375.jpg" width="1525"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: Blender’s default objects</p>
<p>It might be confusing at first, since objects of different types all belong to <code>bpy.data.objects</code>, rather than to <code>bpy.data.cameras</code>, <code>bpy.data.meshes</code>, and <code>bpy.data.lights</code>.</p>
<p>In fact, everything that <a id="_idIndexMarker109"/>can be placed and displayed in the 3D Viewport is of the <code>bpy.data.objects</code> type. An <strong class="bold">object</strong> is a generic container in which any <a id="_idIndexMarker110"/>kind of data, or <strong class="bold">datablock</strong>, can be stored. The <em class="italic">object</em>/<em class="italic">datablock</em> system is a tenet of Blender. We are going to get a better grasp of it in the next chapters. For now, we will focus on object-level access.</p>
<h4>List-like access</h4>
<p>Like Python lists, individual <a id="_idIndexMarker111"/>elements of <code>bpy_collection</code> can be accessed by appending an index number surrounded by brackets, as in the following example:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects[0]
bpy.data.objects['Camera']
&gt;&gt;&gt; bpy.data.objects[1]
bpy.data.objects['Cube']
&gt;&gt;&gt; bpy.data.objects[2]
bpy.data.objects['Light']</pre>
<p>If we know the <a id="_idIndexMarker112"/>name of an object we are looking for, we can get it through string keywords rather than indices.</p>
<h4>Dict-like access</h4>
<p>Besides using their <a id="_idIndexMarker113"/>ordinal index, we can access the elements of <code>bpy.data.objects</code> using their names as keywords, as we do with Python dictionaries:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects['Camera']
bpy.data.objects['Camera']
&gt;&gt;&gt; bpy.data.objects['Cube']
bpy.data.objects['Cube']
&gt;&gt;&gt; bpy.data.objects['Light']
bpy.data.objects['Light']</pre>
<h3>Iterating through collections</h3>
<p>To execute an <a id="_idIndexMarker114"/>expression on all the objects of an aggregate type, we need to <em class="italic">iterate</em> through the collection. <strong class="bold">Iteration</strong> describes the action of scrolling through the elements. By iterating using loop statements, we can carry the same operation on many objects.</p>
<h4>List-like looping</h4>
<p>The <a id="_idIndexMarker115"/>typical <code>for element in list</code> loop works with <code>bpy_collection</code>. The following snippets print out a list of the existing objects:</p>
<pre class="source-code">
import bpy
for ob in bpy.data.objects:
    print(ob.name, ob.type)</pre>
<p>Alternatively, we use the following if we need their collection index as well:</p>
<pre class="source-code">
import bpy
for i, ob in enumerate(bpy.data.objects):
    print(i, ob.name, ob.type)</pre>
<p>Looking at the output, we can see that the elements of <code>bpy.data.objects</code> are ordered alphabetically:</p>
<pre class="source-code">
0 Camera CAMERA
1 Cube MESH
2 Light LIGHT</pre>
<p>That implies that renaming the objects changes the order in which they are listed. It can be an issue if we rename an element while we are still iterating through its collection.</p>
<p>For instance, this snippet adds the letter<code>'z'</code> in front of the name of the first object (<strong class="bold">Camera</strong>). That changes its position in the <em class="italic">Outliner</em> from first to last displayed object:</p>
<pre class="source-code">
import bpy
bpy.data.objects[<strong class="bold">0</strong>].name ='z' + bpy.data.objects[0].name</pre>
<div><div><img alt="Figure 2.12: Before and after renaming – the order of the objects has changed" height="255" src="img/Figure_2._12_B18375.jpg" width="900"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12: Before and after renaming – the order of the objects has changed</p>
<p>We will experience a reordering issue if we execute the same operation inside a loop:</p>
<pre class="source-code">
import bpy
for ob in bpy.data.objects:
    ob.name ='z' + ob.name</pre>
<p>It would be <a id="_idIndexMarker116"/>reasonable to end up with <code>'z'</code> is repeated for a long span.</p>
<div><div><img alt="Figure 2.13: Renaming added way too many “z”s" height="224" src="img/Figure_2._13_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13: Renaming added way too many “z”s</p>
<p>This is a bug in which neither our code nor the application does anything inherently wrong.</p>
<p>To understand why that happens, we need to break it down into individual steps. Blender renames the first, second, and third objects, then it should stop. But since they were renamed, <code>"Light"</code> is renamed and put last, so after that, Blender proceeds to rename <code>"zCamera"</code> to <code>"zzCamera"</code>, and the process keeps going.</p>
<p>That lasts until the names become too long to be renamed.</p>
<p>Bugs like this can <a id="_idIndexMarker117"/>cause software halts and be very hard to find. Whenever our script renames the content of a collection, we must make sure that reordering is not going to be an issue. We are going to look at some possible workarounds.</p>
<h4>Avoiding reordering via list conversion</h4>
<p>The first and <a id="_idIndexMarker118"/>easiest way to avoid re-iteration is to convert <code>bpy_collection</code> into a Python list. Press <em class="italic">Ctrl</em> + <em class="italic">Z</em> to undo the renaming.</p>
<p>Now we will use a slightly different line that converts the collection into a pure Python list, via the <code>list()</code> method:</p>
<pre class="source-code">
import bpy
for ob in list(bpy.data.objects):
    ob.name = 'z' + ob.name</pre>
<div><div><img alt="Figure 2.14: The objects have been renamed properly" height="224" src="img/Figure_2._14_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14: The objects have been renamed properly</p>
<p>In the next subsection, we’ll see that dictionary methods are also supported. They are, among other things, immune to reordering.</p>
<h4>Dict-like looping</h4>
<p>Like in Python <a id="_idIndexMarker119"/>dictionaries, the <code>keys()</code> method returns all the names present in a collection:</p>
<pre class="source-code">
for name in bpy.data.objects.keys():
    print(name)</pre>
<p>Alternatively, we can obtain a list of the objects using the <code>values()</code> method:</p>
<pre class="source-code">
for ob in bpy.data.objects.values():
    print(ob.name, ob.type)</pre>
<p>Lastly, we can iterate both using <code>items()</code>:</p>
<pre class="source-code">
for name, ob in bpy.data.objects.items():
    print(name, ob.type)</pre>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Creating new objects</h2>
<p>Blender classes <a id="_idIndexMarker120"/>purposely lack a <code>new()</code> method of their <code>bpy_collection</code>. For instance, 3D objects are created using <code>bpy.data.objects.new()</code>.</p>
<h3>The new() method</h3>
<p>Adding an object to <a id="_idIndexMarker121"/>the scene takes one step with the Blender interface. Doing it in <a id="_idIndexMarker122"/>Python requires some extra work: the <code>new()</code> command stores a new object in the memory, but then we need to add it to our scene explicitly.</p>
<p>Typing <code>bpy.data.objects.new</code> and pressing <em class="italic">Tab</em> in the Python console displays its documentation:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects.new(
new()
BlendDataObjects.new(name, object_data)
Add a new object to the main database</pre>
<p>The new function requires two parameters: the name that we want to give to our object and the <em class="italic">datablock</em> that it’s going to contain. If we don’t have any <em class="italic">datablocks</em> yet, we can create an <code>None</code> type to the argument <code>object_data</code>:</p>
<pre class="source-code">
import bpy
my_empty = bpy.data.objects.new('My Empty', <strong class="bold">None</strong>)
print('New Empty created:', my_empty)</pre>
<p>The <code>print()</code> line will <a id="_idIndexMarker123"/>confirm that the object has been created. It doesn’t show up in <a id="_idIndexMarker124"/>the 3D Viewport, but we can check that <code>bpy.data.objects</code>.</p>
<div><div><img alt="Figure 2.15: The new Empty shows up in the Python collection" height="550" src="img/Figure_2.15_B18375.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15: The new Empty shows up in the Python collection</p>
<p>This object is not part of a 3D scene yet. In order to be part of a scene, objects must belong to a <strong class="bold">collection</strong>.</p>
<h3>Object collections</h3>
<p>The term <em class="italic">collection</em> carries some <a id="_idIndexMarker125"/>ambiguity, as we have referred to <code>bpy_collection</code> as <a id="_idIndexMarker126"/>part of data access. <code>bpy_collection</code> types, such as <code>bpy.data.objects</code>, are two distinct concepts:</p>
<ul>
<li><strong class="bold">Scene collections</strong> are groups of objects displayed as folders in the <strong class="bold">Outliner</strong>. They are used to organize 3D objects in the scene.</li>
<li><code>bpy_collection</code> without <a id="_idIndexMarker127"/>being part of any scene.</li>
</ul>
<p>All the scene collections <a id="_idIndexMarker128"/>can be accessed in Python using <code>bpy.data.collections</code>.</p>
<p>We are one step away from adding our object to the scene: we need to add <code>my_empty</code> to a scene collection, using the collection method <code>link</code>.</p>
<h3>Linking to the scene</h3>
<p>There is only <a id="_idIndexMarker129"/>one collection in the default scene, so if we type <code>bpy.data.collections</code> and press <em class="italic">Tab</em>, we get it from the autocompletion:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.collections['Collection']</pre>
<p>The default collection is named <code>Collection.objects</code> attribute. The Python line for linking <code>my_empty</code> is:</p>
<pre class="source-code">
bpy.data.collections['Collection'].objects.link(my_empty)</pre>
<p><strong class="bold">My Empty</strong> is now part of the scene and shows up in the outliner.</p>
<div><div><img alt="Figure 2.16: Our Empty sitting along with the other objects" height="251" src="img/Figure_2._16_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16: Our Empty sitting along with the other objects</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Removing elements</h2>
<p>Just like we can create <a id="_idIndexMarker130"/>new elements with <code>new()</code>, we can use the method <code>remove()</code> from <code>bpy.data.objects</code> to remove them. This line removes <code>my_empty</code> from blender:</p>
<pre class="source-code">
bpy.data.objects.remove(my_empty)</pre>
<p>Collections that link existing objects via <code>link()</code>, such as <code>Collection.objects</code>, have an <code>unlink()</code> method for removal:</p>
<pre class="source-code">
collection = bpy.data.collections['Collection']
collection.objects.unlink(bpy.data.objects['Cube'])</pre>
<p>In that case, <code>bpy.data.objects</code>.</p>
<p>In this section, we <a id="_idIndexMarker131"/>have accessed the Blender objects via Python using <code>bpy.data</code>.</p>
<p>How would we fetch the current scene if there is more than just one, or the current object and active selection?</p>
<p>We will see how states of user interaction can be tracked in the <code>bpy.context</code> module.</p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/>Understanding the user context</h1>
<p>The current state of <a id="_idIndexMarker132"/>interaction, the current scene, and the selection are available via <code>bpy.context</code>. Since it depends on the user actions, <code>bpy.context</code> is read-only; that is, it cannot be changed directly. Anyway, we can affect the state of the current activity via <em class="italic">Python</em>. Rather than changing the attributes of <code>bpy.context</code>, we must look for the selection and activity properties of Blender’s objects, layers, and scenes.</p>
<h3>Active scene</h3>
<p>A <code>.blend</code> file, or an <a id="_idIndexMarker133"/>unsaved session for that matter, can contain more <a id="_idIndexMarker134"/>than one <strong class="bold">scene</strong>. That differs from the standard in 3D packages, where a saved file is equivalent to one scene. If more scenes are available, they can be selected from the list menu at the top right of Blender’s header.</p>
<p>Each scene can contain any of the objects from <code>bpy.data.objects</code>, and one object can belong to more than one scene. Changes made to an object in one scene retained in the others.</p>
<p>We have seen how to create new objects using <code>bpy.data.objects.new()</code>. We can create new scenes in the same way, using <code>bpy.data.scenes.new()</code>:</p>
<pre class="source-code">
import bpy
new_scene = bpy.data.scenes.new('My Scene')
print('New scene created:', new_scene.name)</pre>
<p>The new scene will then be available in the top-right widget.</p>
<div><div><img alt="Figure 2.17: Blender scene menu" height="335" src="img/Figure_2._17_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17: Blender scene menu</p>
<p>The currently <a id="_idIndexMarker135"/>displayed scene is contained in <code>bpy.context.window</code>.</p>
<p>If we want to create a <a id="_idIndexMarker136"/>new scene and make it active, we can assign it to the <code>window.scene</code> property:</p>
<pre class="source-code">
import bpy
new_scene = bpy.data.scenes.new('Another Scene')
bpy.context.window.scene = new_scene</pre>
<p>After executing this snippet, the 3D Viewport will switch to a new, empty scene. The current scene itself is part of <code>bpy.context</code> and can be retrieved via Python using <code>bpy.context.scene</code>:</p>
<pre class="source-code">
print('The current scene is', bpy.context.scene.name)</pre>
<h3>View Layers</h3>
<p><strong class="bold">View Layers</strong> are used to render <a id="_idIndexMarker137"/>the objects of a scene separately and put them <a id="_idIndexMarker138"/>back together using <strong class="bold">compositing</strong>. This is done either to speed up the rendering process, for instance, rendering the background only once, or for artistic necessities. In the UI, View Layers are created in the same way as scenes, using the widget on the top bar.</p>
<p>When creating them in Python, we must keep in mind that they always belong to their scene rather than to <code>bpy.data</code>. Despite that, if we want to set the active layer, we still have to use an attribute of <code>bpy.context.window</code>:</p>
<pre class="source-code">
import bpy
new_layer = bpy.context.scene.view_layers.new('My Layer')
print('New layer created:', new_layer.name)
bpy.context.window.view_layer = new_layer
print('Current layer:', bpy.context.view_layer.name)</pre>
<p>The active layer must belong to the active scene. A statement that tries to assign a layer from a different scene to the current window will be ignored. Take the following example:</p>
<pre class="source-code">
import bpy
new_layer = bpy.context.scene.view_layers.new('Another Layer')
print('New layer created:', new_layer.name)
new_scene = bpy.data.scenes.new('Another Scene')
bpy.context.window.scene = new_scene
# NOTE: the following line will not work
bpy.context.window.view_layer = new_layer
print('Current layer:', bpy.context.view_layer.name)</pre>
<p>Layers can store rendering and pass properties, but also their visibility, activity, and selection status. In the next section, we’ll see how a layer stores the <strong class="bold">active object</strong>.</p>
<h3>Active object</h3>
<p>When the user selects <a id="_idIndexMarker139"/>an object, that becomes the <strong class="bold">active object</strong> of the <a id="_idIndexMarker140"/>current layer. Its properties are displayed in the interface, and it will be the main target of the user actions.</p>
<p>When Blender opens, a cube is the active object by default. We can see that from the <strong class="bold">Text Info</strong> in the top-left corner.</p>
<div><div><img alt="Figure 2.18: Blender’s default active object" height="463" src="img/Figure_2._18_B18375.jpg" width="1067"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18: Blender’s default active object</p>
<p>The active object can be retrieved in multiple places in the API, the most immediate being <code>bpy.context.object</code>:</p>
<pre class="source-code">
bpy.context.object  # read only
bpy.context.active_object  # read only, same as above
bpy.context.view_layer.objects.active  # can be set</pre>
<p>All three attributes point to the same object, but since <code>bpy.context</code> is read-only, only the <code>view_layer</code> attribute can be changed programmatically. If more layers are present, switching between layers can change the active object. Or we can change it using Python by following the next steps.</p>
<h4>Changing the active object</h4>
<p>The active object is a <a id="_idIndexMarker141"/>property of the active View Layer. With that in mind, we can just set the <code>view_layer.active</code> attribute to a different object. For instance, here is how to pick the camera instead:</p>
<ol>
<li>Open Blender or revert to the default scene via <strong class="bold">File</strong>-&gt;<strong class="bold">New</strong>-&gt;<strong class="bold">General</strong>.</li>
<li>Go to the Scripting Workspace.</li>
<li>Type the following lines in the Python console and press <em class="italic">Enter</em>:</li>
</ol>
<pre class="source-code">
import bpy
view_layer = bpy.context.view_layer
view_layer.objects.active = bpy.data.objects['Camera']</pre>
<p>We can see that the active object has changed from the 3D Viewport, the properties, and the status information.</p>
<div><div><img alt="Figure 2.19: Camera is now the active object" height="805" src="img/Figure_2.19_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19: Camera is now the active object</p>
<p>We can also see that the cube is still selected, and that the camera, despite being the active object, isn’t. That’s because the active and selected statuses are two distinct concepts. We are <a id="_idIndexMarker142"/>going to see, in the next section, how they differ, and how we can query and change the current selection.</p>
<p class="callout-heading">Keep your focus</p>
<p class="callout">The Blender focus policy can be confusing at first. The area under the mouse cursor takes the keyboard inputs.</p>
<p class="callout">That’s less of a problem for artists since their tasks usually involve keeping the cursor in the area in which they are operating. But it’s different for programmers; we might think of typing lines of code for the console only to find out that we are triggering shortcuts in the 3D Viewport, or the other way around.</p>
<h3>Selected objects</h3>
<p>Let’s select all the objects <a id="_idIndexMarker143"/>in the scene by pressing the <em class="italic">A</em> key in the 3D Viewport (<strong class="bold">Select | All</strong> from the menu bar). Then, in the console, we type the following:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.selected_objects
[bpy.data.objects['Cube'], bpy.data.objects['Light'], bpy.data.objects['Camera']]</pre>
<p><code>selected_objects</code> is a Python list. Unlike <code>bpy.data.objects</code>, it sorts the objects by their creation time and not alphabetically. Objects are <em class="italic">never</em> sorted by their selection time; Blender doesn’t keep that information at all. Should our tool require selecting objects in a specific sequence, we would have to store the order somewhere else.</p>
<p>Selecting an object usually makes it the active object of the current layer. We can print out which object is active using comparisons against <code>bpy.context.object</code>:</p>
<pre class="source-code">
import bpy
for ob in bpy.context.selected_objects:
    if ob is bpy.context.object:
        print(ob.name, 'is active, skipping')
        continue
    print(ob.name, 'is selected')</pre>
<p>Running this snippet with all default objects selected will produce this output:</p>
<pre class="source-code">
Cube is active, skipping
Light is selected
Camera is selected</pre>
<p>This pattern is useful whenever we want to propagate a property from the active object to the selection. We have already seen that we should not assume that the active object is always selected. Inverting the selection unselects the active object, but it will remain active. Or there might be no active object at all; it can be deleted or set to <code>None</code> via the following line:</p>
<pre class="source-code">
bpy.context.view_layer.objects.active = None</pre>
<p>A way to check whether the active object belongs to the selection is with the <code>in</code> operator:</p>
<pre class="source-code">
is_sel = bpy.context.object in bpy.context.selected_objects</pre>
<p>Even better, we <a id="_idIndexMarker144"/>can use the <code>select_get()</code> and <code>select_set()</code> object properties:</p>
<pre class="source-code">
is_sel = bpy.context.object.select_get()</pre>
<p>Like the active object, the selection status of an object is stored per View Layer. In the next section, we’ll learn how to affect the current selection and where it is stored.</p>
<h4>Changing selected objects</h4>
<p>The selection status <a id="_idIndexMarker145"/>of an object is queried and set using <code>object.select_get()</code> and <code>object.select_set()</code> as, respectively, the <code>select_set</code> function works, we can start to type it in the Python console, stopping at the parenthesis:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.select_set(</pre>
<p>Pressing the <em class="italic">Tab</em> key will display a description of the function and its arguments:</p>
<pre class="source-code">
select_set()
Object.select_set(state, view_layer=None)
Select or deselect the object. The selection state is per view layer</pre>
<p>If no View Layer is given, the selection of the current layer is used. For instance, this snippet will deselect all the objects in the current layer:</p>
<pre class="source-code">
import bpy
for ob in bpy.context.selected_objects:
ob.select_set(False)</pre>
<p>We can create layers dynamically and assign them a different selection. Here is a snippet that creates a View Layer where mesh objects are selected, and another where cameras are:</p>
<pre class="source-code">
import bpy
m_layer = bpy.context.scene.view_layers.new('Sel_Mesh')
c_layer = bpy.context.scene.view_layers.new('Sel_Cam')
for ob in bpy.data.objects:
    ob.select_set(ob.type == 'MESH', view_layer=m_layer)
    ob.select_set(ob.type == 'CAMERA', view_layer=c_layer)</pre>
<p>Selecting is the most <a id="_idIndexMarker148"/>immediate way for the user to pick objects from the scene. For this reason, <code>bpy.context</code> holds a pivotal role and is usually available in scripts, or even passed as a Python object.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor047"/>Summary</h1>
<p>In this chapter, we saw how Python can access the content of Blender via <code>bpy.data</code> and introduced space entities such as vectors. We also saw how to interact with the user activity through <code>bpy.context</code>, and how read-only attributes of context are changed by affecting the status of objects and layers.</p>
<p>In <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, we will see how to insert our routines in our own add-ons and make them ready to install and use in Blender.</p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor048"/>Questions</h1>
<ol>
<li>Which helper utilities are typical of Blender?</li>
<li>How can we store and display space coordinates?</li>
<li>Which attribute of <code>bpy</code> gives access to all Blender entities?</li>
<li>Do Python classes of Blender objects have a constructor?</li>
<li>How do we create new Blender objects?</li>
<li>What does it mean that an object is active?</li>
<li>Is the active object a property of the Blender scene?</li>
<li>Can we affect the selection using <code>bpy.context</code>?</li>
<li>Can we affect the selection using <code>bpy.context.view_layer</code>?</li>
</ol>
</div>
</div></body></html>