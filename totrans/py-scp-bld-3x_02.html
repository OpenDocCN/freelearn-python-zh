<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer057">
<h1 class="chapter-number" id="_idParaDest-33"><a id="_idTextAnchor033"/>2</h1>
<h1 id="_idParaDest-34"><a id="_idTextAnchor034"/>Python Entities and API</h1>
<p>Blender expands Python by making the <strong class="bold">modules</strong> of its <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) available inside <span class="No-Break">the app.</span></p>
<p>These modules provide <strong class="bold">wrappers</strong> that translate Blender’s internal data into Python objects. Comprehensive documentation and an API reference are available online and can be reached from inside the application. Plus, there are some extra features to help programmers in <span class="No-Break">their journey.</span></p>
<p>Much like the syntax highlight that we have met in <a href="B18375_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, some features for developers are common-place in the programming world. Others, such as property tooltips and variables display, are specific <span class="No-Break">to Blender.</span></p>
<p>In this chapter, we are going to look at some <strong class="bold">snippets</strong>, that is, chunks of code, that will help you become confident with the architecture of <span class="No-Break">Blender’s API.</span></p>
<p>Generally, the API is designed to be very friendly to programmers that are already experienced with Python, only deviating a few times from <span class="No-Break">the standards.</span></p>
<p>By the end of this chapter, you will be able to inspect Blender objects from the Python console and change their properties, use and expand Blender collections, and check the current state of the <span class="No-Break">user interaction.</span></p>
<p>In this chapter, we are going to become familiar with the <span class="No-Break">following topics:</span></p>
<ul>
<li>Features <span class="No-Break">of Python</span></li>
<li>Blender modules and <span class="No-Break">their structure</span></li>
<li>Data and <span class="No-Break">Context Access</span></li>
</ul>
<h1 id="_idParaDest-35"><a id="_idTextAnchor035"/>Technical requirements</h1>
<p>Only Blender is needed to follow along with <span class="No-Break">this chapter.</span></p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Useful features of Python</h1>
<p>We already met the <em class="italic">Python</em> elements of the <strong class="bold">Scripting</strong> workspace in <a href="B18375_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. Now we are going to look at some useful features that can help us get the most out of them. When it comes to <a id="_idIndexMarker073"/>programming, automation can speed up the search for attributes and terms. That can happen both in the console, through conventional methods such as <strong class="bold">autocompletion</strong>, or in the interface, via shortcuts that display the Python address of a graphic element. Some of these features are already available when Blender starts, while others are left for the users <span class="No-Break">to enable.</span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>Options for developers</h2>
<p>Developer features are <a id="_idIndexMarker074"/>disabled by default. They can be enabled in the <strong class="bold">Preferences</strong> dialog from the <strong class="bold">Edit</strong> menu in the top bar of Blender. We need to select the <strong class="bold">Interface</strong> tab on the left and look at the first panel: <strong class="bold">Display</strong>. Programmers usually enable the <strong class="bold">Developer Extras</strong> and <strong class="bold">Python </strong><span class="No-Break"><strong class="bold">Tooltips</strong></span><span class="No-Break"> options.</span></p>
<h3>Developer Extras</h3>
<p><strong class="bold">Developer Extras</strong> adds a right-click <a id="_idIndexMarker075"/>menu entry that can display the Python source code of the UI in the <em class="italic">Text Editor</em>. It also shows the geometry index of mesh components when the user switches to <strong class="bold">Edit Mode</strong>. Among other things, it allows the <strong class="bold">search bar</strong> to execute operators that cannot be accessed via <span class="No-Break">the UI.</span></p>
<h3>Python tooltips</h3>
<p>Hovering the mouse <a id="_idIndexMarker076"/>cursor over an attribute displays a tooltip with a small description. If Python tooltips are enabled, information about how to invoke that attribute in scripts is displayed <span class="No-Break">as well.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<img alt="Figure 2.1: Blender’s display preferences" height="790" src="image/Figure_2.1_B18375.jpg" width="1273"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: Blender’s display preferences</p>
<p>For instance, in the 3D <a id="_idIndexMarker077"/>Viewport, we can press the <em class="italic">N</em> key to display the <strong class="bold">transform channels</strong> on the right-hand side of the screen. Leaving the mouse pointer over a coordinate, such as <strong class="bold">Location:</strong> <strong class="bold">X</strong>, for a while will show two additional lines in <span class="No-Break">the description:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 2.2: Python tooltip of an object location" height="327" src="image/Figure_2.2_B18375.jpg" width="530"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: Python tooltip of an object location</p>
<p>The Python tooltip consists of <span class="No-Break">two lines:</span></p>
<pre class="source-code">
Python: Object.location
bpy.data.objects['Cube'].location[0]</pre>
<p>The first line provides the Python <a id="_idIndexMarker078"/>name of the attribute; in this case, <strong class="source-inline">location</strong> is the <strong class="bold">data path</strong> of an <strong class="source-inline">Object</strong> position <span class="No-Break">in space.</span></p>
<p>The second line is more specific: the location of this object (<strong class="source-inline">'Cube'</strong>) can be reached by typing that <a id="_idIndexMarker079"/>line in the console. This is usually referred to as the <strong class="bold">full data path</strong> of the property or, on <a id="_idIndexMarker080"/>some occasions, the <strong class="bold">RNA</strong> path. The latter term comes from a playful analogy to genetics: if Blender’s internal code <a id="_idIndexMarker081"/>makes its <em class="italic">DNA</em>, its <em class="italic">Python</em> access can be seen as the <em class="italic">RNA</em> of <span class="No-Break">the application.</span></p>
<p>An object’s location is a simple case, other attributes can be more complex. Anyway, we can copy data paths to the clipboard following the steps in the <span class="No-Break">next subsection.</span></p>
<h3>Copying the data path</h3>
<p>Right-clicking <a id="_idIndexMarker082"/>on a property opens a <em class="italic">context</em> menu. Some entries, such as <strong class="bold">Insert Keyframes</strong> and <strong class="bold">Reset to Default Value</strong>, are useful for animation. In this section, we will focus on the programming entries, <strong class="bold">Copy Data Path</strong> and <strong class="bold">Copy Full </strong><span class="No-Break"><strong class="bold">Data Path</strong></span><span class="No-Break">:</span></p>
<ol>
<li>Select an object in the <span class="No-Break">3D Viewport.</span></li>
<li>If no transform properties are displayed on the right, press <em class="italic">N</em> to summon the <span class="No-Break"><strong class="bold">Transform</strong></span><span class="No-Break"> sidebar.</span></li>
<li>From the <strong class="bold">Item</strong> tab, right-click on the first location channel (<strong class="bold">X</strong>), then click <strong class="bold">Copy Full </strong><span class="No-Break"><strong class="bold">Data Path</strong></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 2.3: Right-click menu for location X" height="660" src="image/Figure_2.3_B18375.jpg" width="532"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: Right-click menu for location X</p>
<ol>
<li value="4">Go to the Python console, press <em class="italic">Ctrl</em> + <em class="italic">V</em> to paste, and then <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
</ol>
<p>The console will display the location value for the <span class="No-Break"><em class="italic">X</em></span><span class="No-Break"> coordinate:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects['Cube'].location[0]
0.0</pre>
<p>The full data path <a id="_idIndexMarker083"/>allows to access an attribute and, unless it is a read-only property, change its value. We can see how the copied line ends with an index, which is due to <strong class="source-inline">location</strong> being a three-dimensional attribute – each index refers to an axis of <span class="No-Break">the space:</span></p>
<pre class="source-code">
bpy.data.objects['Cube'].location[0]  # X axis
bpy.data.objects['Cube'].location[1]  # Y axis
bpy.data.objects['Cube'].location[2]  # Z axis</pre>
<p>Data paths can be convoluted sometimes, but in the next section, we are going to look at some console tools that help a lot when looking for the <span class="No-Break">right attribute.</span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor038"/>Python console’s utilities</h2>
<p>The <em class="italic">Python console</em> offers some helpful utilities. Some of them, such as text completion and history, <a id="_idIndexMarker084"/>are common among programmers’ tools. Others, such as the 3D representation of variables, are typical of Blender. This section provides an overview of how the Python console is used in <span class="No-Break">day-to-day programming.</span></p>
<h3>Autocompletion</h3>
<p>Pressing the <em class="italic">Tab</em> button while <a id="_idIndexMarker085"/>typing in the console suggests a few possible ways to complete the line. On top of that, if the current statement is associated with internal documentation (<strong class="bold">docstring</strong>), that will be displayed along <a id="_idIndexMarker086"/>with the suggestion. For instance, let’s try these steps to autocomplete a call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">print()</strong></span><span class="No-Break">:</span></p>
<ol>
<li>In Blender, select <strong class="bold">Scripting Workspace</strong> in the tabs at the top of the screen, as we learned in the <em class="italic">The Scripting Workspace</em> section, in <em class="italic">First steps with Python</em>, in <a href="B18375_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></li>
<li>In the Python console, type only <strong class="source-inline">prin</strong>, then <span class="No-Break">press </span><span class="No-Break"><em class="italic">Tab</em></span><span class="No-Break">.</span></li>
</ol>
<p>The console fills in the missing letters and displays <strong class="source-inline">print(</strong>, with an open bracket, and its documentation. Then, it lets the programmer finish <span class="No-Break">the line.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 2.4: Autocompletion in the Python console" height="438" src="image/Figure_2.4_B18375.jpg" width="1522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: Autocompletion in the Python console</p>
<h3>History</h3>
<p>Previous commands <a id="_idIndexMarker087"/>executed in Blender’s Python console can be retrieved using the up/down arrow keys. This can be tested with any code. Here is an example to run in the <span class="No-Break">Python console:</span></p>
<ol>
<li>Type <strong class="source-inline">print('Line One')</strong>, then <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
<li>Press the <em class="italic">↑</em> key. The current text will change to <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">&gt;&gt;&gt; print("Line One")</strong></pre></li>
<li>Delete the last letters and change the line to <strong class="source-inline">print('Line Two')</strong>, then <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
<li>Press <em class="italic">↑</em> twice to display <strong class="source-inline">&gt;&gt;&gt; print('Line </strong><span class="No-Break"><strong class="source-inline">One')</strong></span><span class="No-Break"> again.</span></li>
<li>Alternate between pressing <em class="italic">↓</em> and <em class="italic">↑</em> to switch between the <span class="No-Break">two commands.</span></li>
</ol>
<h3>Multiline input</h3>
<p>Snippets <a id="_idIndexMarker088"/>consisting of two or more lines can be pasted to the console and executed by pressing <span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break"> twice.</span></p>
<p>Since blank lines mark the end of a snippet, they can make valid code fail when present inside indented blocks. Let’s look at a simple example: a condition containing two <strong class="source-inline">print</strong> statements separated by <span class="No-Break">a line:</span></p>
<pre class="source-code">
if True<a id="_idTextAnchor039"/>:
    print('Line One')
    print('Line Two')</pre>
<p>This code works in the <em class="italic">Text Editor</em> but fails in the <em class="italic">Python console</em>. Here is <span class="No-Break">the output:</span></p>
<pre class="source-code">
&gt;&gt;&gt; if True:
...     print('Line One')
...
Line One
&gt;&gt;&gt;     print('Line Two')
  File "&lt;blender_console&gt;", line 1
    print("Line Two")
IndentationError: unexpected indent</pre>
<p>After the first <a id="_idIndexMarker089"/>two lines are executed, the indentation of the second <strong class="source-inline">print()</strong> is <span class="No-Break">considered wrong.</span></p>
<p>Blank lines should be replaced with comments (<strong class="source-inline">#</strong>) in every snippet meant for the console. The following code <span class="No-Break">will work:</span></p>
<pre class="source-code">
if True:
    print('Line One')
    #
    print('Line Two')</pre>
<h3>Displaying 3D variables in the 3D Viewport</h3>
<p>Variables that <a id="_idIndexMarker090"/>represent a 3D point or transformation can be displayed in the three-dimensional space. This is made possible by the <strong class="bold">Math Vis (Console)</strong> add-on. <strong class="bold">Add-ons</strong> are Python extensions that can be enabled at need. We are going to write our own add-ons in this book. For now, we will see how to enable an add-on that ships <span class="No-Break">with Blender.</span></p>
<h4>Enabling the Math Vis (Console) add-on</h4>
<p>Add-ons can <a id="_idIndexMarker091"/>be enabled in <span class="No-Break">the preferences:</span></p>
<ol>
<li>From the top-bar menu, select <strong class="bold">Edit | </strong><span class="No-Break"><strong class="bold">Preferences</strong></span><span class="No-Break">.</span></li>
<li>Choose the <strong class="bold">Add-ons</strong> tab in the <span class="No-Break">left column.</span></li>
<li>Type <strong class="source-inline">Math Vis</strong> in the search filter marked with the <span class="No-Break">magnifier icon.</span></li>
<li>Click the checkbox to the left of the <span class="No-Break">add-on name.</span></li>
</ol>
<h4>Creating 3D variables</h4>
<p>Blender provides <a id="_idIndexMarker092"/>additional Python types for 3D entities. For instance, coordinates can be stored using a <strong class="source-inline">Vector</strong> type. We can store a vector in a variable <span class="No-Break">by typing:</span></p>
<pre class="source-code">
my_vector = Vector([1.0, 2.0, 3.0])</pre>
<p>Since we have enabled the <em class="italic">Math Vis (Console)</em> add-on, a pink dot followed by the variable name will appear in the <span class="No-Break">3D Viewport.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 2.5: Vector coordinates [1.0, 2.0, 3.0], as displayed in the 3D Viewport" height="902" src="image/Figure_2._05_B18375.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Vector coordinates [1.0, 2.0, 3.0], as displayed in the 3D Viewport</p>
<p>Variables are visualized only when the console is visible, as long as they exist. The drawing stops once they are deleted with <span class="No-Break">the following:</span></p>
<pre class="source-code">
del my_vector</pre>
<p>The <strong class="source-inline">del</strong> statement is a standard Python command. We should keep in mind that it deletes Python variables, not <span class="No-Break">Blender objects.</span></p>
<p>If we want to delete objects in Blender, we can use Blender’s <span class="No-Break"><strong class="source-inline">delete()</strong></span><span class="No-Break"> command:</span></p>
<pre class="source-code">
bpy.ops.object.delete()</pre>
<p><strong class="source-inline">ops</strong> in the preceding <a id="_idIndexMarker093"/>command stands for <strong class="bold">operators</strong>. We will learn more about operators in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. For now, we will keep in mind that they refer to the operation performed by Blender when responding to user inputs. In the case of <strong class="source-inline">bpy.ops.object.delete()</strong>, this means pressing the <em class="italic">X</em> key or selecting the <strong class="bold">Delete</strong> action from the <span class="No-Break"><strong class="bold">Object</strong></span><span class="No-Break"> menu.</span></p>
<p>Types with a geometrical meaning, such as <strong class="source-inline">Vector</strong>, <strong class="source-inline">Matrix</strong>, and <strong class="source-inline">Euler</strong>, are mathematical constructs and belong to the <strong class="source-inline">mathutils</strong> module. This module is imported into the <em class="italic">console</em> automatically. There is no need to import it again in the console. If we were to use it in a script, we would have to import it from <span class="No-Break">the module:</span></p>
<pre class="source-code">
from mathutils import Vector
my_vector = Vector([1.0, 2.0, 3.0])</pre>
<p>We are going to <a id="_idIndexMarker094"/>explore <strong class="source-inline">mathutils</strong> in the next chapters, when dealing with 3D objects and elements. In the next section, we’ll get familiar with how Blender objects translate <span class="No-Break">into Python.</span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor040"/>Accessing Blender modules</h1>
<p>Blender’s additional <a id="_idIndexMarker095"/>modules are available throughout the application and can be used via the standard <strong class="source-inline">import</strong> statement. They are available in the Python console, the Text Editor, and generally in the scripts that are installed in the Blender system and <span class="No-Break">user paths.</span></p>
<p>Some modules are very specific; for instance, the <strong class="source-inline">freestyle</strong> module handles the settings of the freestyle stylized rendering and cannot be used for any other purpose. Others, such as <strong class="source-inline">mathutils</strong>, come into play whenever numbers <span class="No-Break">are concerned.</span></p>
<p>Finally, the <strong class="source-inline">bpy</strong> module and its submodules play a bigger role in Blender scripts, as they grant access to objects <span class="No-Break">and data.</span></p>
<p>In this section, we will have a closer look at <strong class="source-inline">bpy</strong>, how it is already present in the console, and how we can use it in our scripts. We will also learn where to find more information about the API and <span class="No-Break">its elements.</span></p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>The bpy module</h2>
<p>In <a href="B18375_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, we copied the lines from the console using <strong class="bold">Console</strong>-&gt;<strong class="bold">Copy</strong> from <a id="_idIndexMarker096"/>the Python console editor and pasted them <a id="_idIndexMarker097"/>into a text block. In doing so, we found a few extra lines at <span class="No-Break">the beginning:</span></p>
<pre class="source-code">
import bpy
from bpy import data as D
from bpy import context as C
...</pre>
<p>The first line imports <strong class="source-inline">bpy</strong>, the main module of the programming interface. Lines two and three import <strong class="source-inline">data</strong> and <strong class="source-inline">context</strong> and assign them, respectively, the <strong class="source-inline">D</strong> and <strong class="source-inline">C</strong> letters as convenience shortcuts. This is pointed out in the <span class="No-Break">initial screen:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 2.6: Python console’s convenience variables" height="238" src="image/Figure_2.6_B18375.jpg" width="1522"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: Python console’s convenience variables</p>
<p><strong class="source-inline">data</strong> represents <a id="_idIndexMarker098"/>the storage of Blender objects and <strong class="source-inline">context</strong> is the <a id="_idIndexMarker099"/>current state of the user interaction, such as the selection or the current mode (<strong class="bold">Object</strong>, <strong class="bold">Edit</strong>, <span class="No-Break"><strong class="bold">Pose</strong></span><span class="No-Break">, etc.).</span></p>
<p>Because of their nature, <strong class="source-inline">context</strong> and <strong class="source-inline">data</strong> are always present in Blender scripts. The autocompletion gives a glimpse of the other modules. If we type <strong class="source-inline">bpy.</strong> and press <em class="italic">Tab</em>, we’ll get a list <span class="No-Break">of them.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 2.7: bpy’s submodules" height="550" src="image/Figure_2.7_B18375.jpg" width="1523"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: bpy’s submodules</p>
<p>Each attribute of <strong class="source-inline">bpy</strong> covers a specific aspect of Blender. For instance, <strong class="source-inline">bpy.app</strong> contains the properties of the software (executable and version) and <strong class="source-inline">bpy.ops</strong> contains the operators, that is, functions that can be invoked in <span class="No-Break">the interface.</span></p>
<p><strong class="source-inline">bpy</strong> and the <a id="_idIndexMarker100"/>other Blender modules contain a multitude of classes, methods, <a id="_idIndexMarker101"/>and utilities. These entities are documented in the <em class="italic">Python API Reference</em>, which is available online and can be downloaded <span class="No-Break">if needed.</span></p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>API documentation</h2>
<p>The reference <a id="_idIndexMarker102"/>website can be reached via <strong class="bold">Help</strong> | <strong class="bold">Python API Reference</strong> from <a id="_idIndexMarker103"/>the top <span class="No-Break">menu bar.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 2.8: The link to the Python API Reference" height="534" src="image/Figure_2.8_B18375.jpg" width="908"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: The link to the Python API Reference</p>
<p>The <em class="italic">Python Help</em> for the current version will open in the web browser. The documentation is generated <a id="_idIndexMarker104"/>from the docstrings using software called <strong class="bold">Sphinx</strong>, and adds examples and hyperlinks to the information displayed by the <span class="No-Break"><strong class="source-inline">help()</strong></span><span class="No-Break"> function.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 2.9: Comparison between the help() function and online help for the Euler class" height="565" src="image/Figure_2.9_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9: Comparison between the help() function and online help for the Euler class</p>
<p>The online help has the advantage of a search bar and doesn’t take space from our Blender session. It <a id="_idIndexMarker105"/>contains an index of the available <a id="_idIndexMarker106"/>modules and <span class="No-Break">their content.</span></p>
<p>An API reference is very useful to navigate the various modules and the attributes <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">bpy</strong></span><span class="No-Break">.</span></p>
<p>In this chapter, we’ll focus on <strong class="source-inline">bpy.data</strong> and <strong class="source-inline">bpy.context</strong>, leaving the specific functionalities of the other modules to the <span class="No-Break">next chapters.</span></p>
<h1 id="_idParaDest-42"><a id="_idTextAnchor043"/>Accessing Blender data</h1>
<p>All the entities created <a id="_idIndexMarker107"/>in the current session are available as part of <strong class="source-inline">bpy.data</strong>. They are grouped in categories that follow the <strong class="bold">object types</strong> available in Blender, so we have <strong class="source-inline">bpy.data.armatures</strong>, <strong class="source-inline">bpy.data.curves</strong>, and so on. Each category is a <strong class="source-inline">bpy_collection</strong>, a Blender type that contains more elements. Their content can be accessed with indices, like in a Python <strong class="source-inline">list</strong>, or with keywords, like <span class="No-Break">in dictionaries.</span></p>
<h3>Objects access</h3>
<p>We can use Python <a id="_idIndexMarker108"/>to access the objects of a scene. For example, we can query the content of Blender’s default scene, which contains a <strong class="bold">Cube</strong>, a <strong class="bold">Camera</strong> and <span class="No-Break">a </span><span class="No-Break"><strong class="bold">Light</strong></span><span class="No-Break">:</span></p>
<ol>
<li>Open or restart Blender and select <strong class="bold">Scripting Workspace</strong> in the workspace tabs at the top of <span class="No-Break">the screen.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 2.10: The workspace tabs" height="180" src="image/Figure_2.10_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10: The workspace tabs</p>
<ol>
<li value="2">Type <strong class="source-inline">len(bpy.data.objects)</strong> and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span><pre class="source-code">
&gt;&gt;&gt; len(bpy.data.objects)</pre><pre class="source-code">
3</pre></li>
<li>In the Python console, type <strong class="source-inline">bpy.data.objects</strong>, then <span class="No-Break">press </span><span class="No-Break"><em class="italic">Tab</em></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 2.11: Blender’s default objects" height="383" src="image/Figure_2.11_B18375.jpg" width="1525"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11: Blender’s default objects</p>
<p>It might be confusing at first, since objects of different types all belong to <strong class="source-inline">bpy.data.objects</strong>, rather than to <strong class="source-inline">bpy.data.cameras</strong>, <strong class="source-inline">bpy.data.meshes</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">bpy.data.lights</strong></span><span class="No-Break">.</span></p>
<p>In fact, everything that <a id="_idIndexMarker109"/>can be placed and displayed in the 3D Viewport is of the <strong class="source-inline">bpy.data.objects</strong> type. An <strong class="bold">object</strong> is a generic container in which any <a id="_idIndexMarker110"/>kind of data, or <strong class="bold">datablock</strong>, can be stored. The <em class="italic">object</em>/<em class="italic">datablock</em> system is a tenet of Blender. We are going to get a better grasp of it in the next chapters. For now, we will focus on <span class="No-Break">object-level access.</span></p>
<h4>List-like access</h4>
<p>Like Python lists, individual <a id="_idIndexMarker111"/>elements of <strong class="source-inline">bpy_collection</strong> can be accessed by appending an index number surrounded by brackets, as in the <span class="No-Break">following example:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects[0]
bpy.data.objects['Camera']
&gt;&gt;&gt; bpy.data.objects[1]
bpy.data.objects['Cube']
&gt;&gt;&gt; bpy.data.objects[2]
bpy.data.objects['Light']</pre>
<p>If we know the <a id="_idIndexMarker112"/>name of an object we are looking for, we can get it through string keywords rather <span class="No-Break">than indices.</span></p>
<h4>Dict-like access</h4>
<p>Besides using their <a id="_idIndexMarker113"/>ordinal index, we can access the elements of <strong class="source-inline">bpy.data.objects</strong> using their names as keywords, as we do with <span class="No-Break">Python dictionaries:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects['Camera']
bpy.data.objects['Camera']
&gt;&gt;&gt; bpy.data.objects['Cube']
bpy.data.objects['Cube']
&gt;&gt;&gt; bpy.data.objects['Light']
bpy.data.objects['Light']</pre>
<h3>Iterating through collections</h3>
<p>To execute an <a id="_idIndexMarker114"/>expression on all the objects of an aggregate type, we need to <em class="italic">iterate</em> through the collection. <strong class="bold">Iteration</strong> describes the action of scrolling through the elements. By iterating using loop statements, we can carry the same operation on <span class="No-Break">many objects.</span></p>
<h4>List-like looping</h4>
<p>The <a id="_idIndexMarker115"/>typical <strong class="source-inline">for element in list</strong> loop works with <strong class="source-inline">bpy_collection</strong>. The following snippets print out a list of the <span class="No-Break">existing objects:</span></p>
<pre class="source-code">
import bpy
for ob in bpy.data.objects:
    print(ob.name, ob.type)</pre>
<p>Alternatively, we use the following if we need their collection index <span class="No-Break">as well:</span></p>
<pre class="source-code">
import bpy
for i, ob in enumerate(bpy.data.objects):
    print(i, ob.name, ob.type)</pre>
<p>Looking at the output, we can see that the elements of <strong class="source-inline">bpy.data.objects</strong> are <span class="No-Break">ordered alphabetically:</span></p>
<pre class="source-code">
0 Camera CAMERA
1 Cube MESH
2 Light LIGHT</pre>
<p>That implies that renaming the objects changes the order in which they are listed. It can be an issue if we rename an element while we are still iterating through <span class="No-Break">its collection.</span></p>
<p>For instance, this snippet adds the letter<strong class="source-inline">'z'</strong> in front of the name of the first object (<strong class="bold">Camera</strong>). That changes its position in the <em class="italic">Outliner</em> from first to last <span class="No-Break">displayed object:</span></p>
<pre class="source-code">
import bpy
bpy.data.objects[<strong class="bold">0</strong>].name ='z' + bpy.data.objects[0].name</pre>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 2.12: Before and after renaming – the order of the objects has changed" height="255" src="image/Figure_2._12_B18375.jpg" width="900"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12: Before and after renaming – the order of the objects has changed</p>
<p>We will experience a reordering issue if we execute the same operation inside <span class="No-Break">a loop:</span></p>
<pre class="source-code">
import bpy
for ob in bpy.data.objects:
    ob.name ='z' + ob.name</pre>
<p>It would be <a id="_idIndexMarker116"/>reasonable to end up with <strong class="bold">zCamera</strong>, <strong class="bold">zCube</strong>, and <strong class="bold">zLight</strong>. Instead, we end up with very long names where the<strong class="source-inline">'z'</strong> is repeated for a <span class="No-Break">long span.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 2.13: Renaming added way too many “z”s" height="224" src="image/Figure_2._13_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13: Renaming added way too many “z”s</p>
<p>This is a bug in which neither our code nor the application does anything <span class="No-Break">inherently wrong.</span></p>
<p>To understand why that happens, we need to break it down into individual steps. Blender renames the first, second, and third objects, then it should stop. But since they were renamed, <strong class="bold">zCamera</strong> and <strong class="bold">zCube</strong> come after <strong class="bold">Light</strong>. The query for the next object happens before <strong class="source-inline">"Light"</strong> is renamed and put last, so after that, Blender proceeds to rename <strong class="source-inline">"zCamera"</strong> to <strong class="source-inline">"zzCamera"</strong>, and the process <span class="No-Break">keeps going.</span></p>
<p>That lasts until the names become too long to <span class="No-Break">be renamed.</span></p>
<p>Bugs like this can <a id="_idIndexMarker117"/>cause software halts and be very hard to find. Whenever our script renames the content of a collection, we must make sure that reordering is not going to be an issue. We are going to look at some <span class="No-Break">possible workarounds.</span></p>
<h4>Avoiding reordering via list conversion</h4>
<p>The first and <a id="_idIndexMarker118"/>easiest way to avoid re-iteration is to convert <strong class="source-inline">bpy_collection</strong> into a Python list. Press <em class="italic">Ctrl</em> + <em class="italic">Z</em> to undo <span class="No-Break">the renaming.</span></p>
<p>Now we will use a slightly different line that converts the collection into a pure Python list, via the <span class="No-Break"><strong class="source-inline">list()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
import bpy
for ob in list(bpy.data.objects):
    ob.name = 'z' + ob.name</pre>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 2.14: The objects have been renamed properly" height="224" src="image/Figure_2._14_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14: The objects have been renamed properly</p>
<p>In the next subsection, we’ll see that dictionary methods are also supported. They are, among other things, immune <span class="No-Break">to reordering.</span></p>
<h4>Dict-like looping</h4>
<p>Like in Python <a id="_idIndexMarker119"/>dictionaries, the <strong class="source-inline">keys()</strong> method returns all the names present in <span class="No-Break">a collection:</span></p>
<pre class="source-code">
for name in bpy.data.objects.keys():
    print(name)</pre>
<p>Alternatively, we can obtain a list of the objects using the <span class="No-Break"><strong class="source-inline">values()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
for ob in bpy.data.objects.values():
    print(ob.name, ob.type)</pre>
<p>Lastly, we can iterate both <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">items()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
for name, ob in bpy.data.objects.items():
    print(name, ob.type)</pre>
<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Creating new objects</h2>
<p>Blender classes <a id="_idIndexMarker120"/>purposely lack a <strong class="bold">constructor</strong>. The only way to create new objects via Python is with the <strong class="source-inline">new()</strong> method of their <strong class="source-inline">bpy_collection</strong>. For instance, 3D objects are created <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.data.objects.new()</strong></span><span class="No-Break">.</span></p>
<h3>The new() method</h3>
<p>Adding an object to <a id="_idIndexMarker121"/>the scene takes one step with the Blender interface. Doing it in <a id="_idIndexMarker122"/>Python requires some extra work: the <strong class="source-inline">new()</strong> command stores a new object in the memory, but then we need to add it to our <span class="No-Break">scene explicitly.</span></p>
<p>Typing <strong class="source-inline">bpy.data.objects.new</strong> and pressing <em class="italic">Tab</em> in the Python console displays <span class="No-Break">its documentation:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.objects.new(
new()
BlendDataObjects.new(name, object_data)
Add a new object to the main database</pre>
<p>The new function requires two parameters: the name that we want to give to our object and the <em class="italic">datablock</em> that it’s going to contain. If we don’t have any <em class="italic">datablocks</em> yet, we can create an <strong class="bold">empty</strong>, an object that has a position in space but no geometry or render data. To do that, we supply the <strong class="source-inline">None</strong> type to the <span class="No-Break">argument </span><span class="No-Break"><strong class="source-inline">object_data</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import bpy
my_empty = bpy.data.objects.new('My Empty', <strong class="bold">None</strong>)
print('New Empty created:', my_empty)</pre>
<p>The <strong class="source-inline">print()</strong> line will <a id="_idIndexMarker123"/>confirm that the object has been created. It doesn’t show up in <a id="_idIndexMarker124"/>the 3D Viewport, but we can check that <strong class="bold">My Empty</strong> is part <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">bpy.data.objects</strong></span><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 2.15: The new Empty shows up in the Python collection" height="550" src="image/Figure_2.15_B18375.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15: The new Empty shows up in the Python collection</p>
<p>This object is not part of a 3D scene yet. In order to be part of a scene, objects must belong to <span class="No-Break">a </span><span class="No-Break"><strong class="bold">collection</strong></span><span class="No-Break">.</span></p>
<h3>Object collections</h3>
<p>The term <em class="italic">collection</em> carries some <a id="_idIndexMarker125"/>ambiguity, as we have referred to <strong class="source-inline">bpy_collection</strong> as <a id="_idIndexMarker126"/>part of data access. <strong class="bold">Scene collections</strong> and the <strong class="source-inline">bpy_collection</strong> types, such as <strong class="source-inline">bpy.data.objects</strong>, are two <span class="No-Break">distinct concepts:</span></p>
<ul>
<li><strong class="bold">Scene collections</strong> are groups of objects displayed as folders in the <strong class="bold">Outliner</strong>. They are used to organize 3D objects in <span class="No-Break">the scene.</span></li>
<li><strong class="bold">bpy_collection</strong> is a Python type. It lists objects and datablocks. Objects might exist in <strong class="source-inline">bpy_collection</strong> without <a id="_idIndexMarker127"/>being part of <span class="No-Break">any scene.</span></li>
</ul>
<p>All the scene collections <a id="_idIndexMarker128"/>can be accessed in Python <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.data.collections</strong></span><span class="No-Break">.</span></p>
<p>We are one step away from adding our object to the scene: we need to add <strong class="source-inline">my_empty</strong> to a scene collection, using the collection <span class="No-Break">method </span><span class="No-Break"><strong class="source-inline">link</strong></span><span class="No-Break">.</span></p>
<h3>Linking to the scene</h3>
<p>There is only <a id="_idIndexMarker129"/>one collection in the default scene, so if we type <strong class="source-inline">bpy.data.collections</strong> and press <em class="italic">Tab</em>, we get it from <span class="No-Break">the autocompletion:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.data.collections['Collection']</pre>
<p>The default collection is named <strong class="bold">Collection</strong>. Its objects can be accessed via the <strong class="source-inline">Collection.objects</strong> attribute. The Python line for linking <span class="No-Break"><strong class="source-inline">my_empty</strong></span><span class="No-Break"> is:</span></p>
<pre class="source-code">
bpy.data.collections['Collection'].objects.link(my_empty)</pre>
<p><strong class="bold">My Empty</strong> is now part of the scene and shows up in <span class="No-Break">the outliner.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 2.16: Our Empty sitting along with the other objects" height="251" src="image/Figure_2._16_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16: Our Empty sitting along with the other objects</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Removing elements</h2>
<p>Just like we can create <a id="_idIndexMarker130"/>new elements with <strong class="source-inline">new()</strong>, we can use the method <strong class="source-inline">remove()</strong> from <strong class="source-inline">bpy.data.objects</strong> to remove them. This line removes <strong class="source-inline">my_empty</strong> <span class="No-Break">from blender:</span></p>
<pre class="source-code">
bpy.data.objects.remove(my_empty)</pre>
<p>Collections that link existing objects via <strong class="source-inline">link()</strong>, such as <strong class="source-inline">Collection.objects</strong>, have an <strong class="source-inline">unlink()</strong> method <span class="No-Break">for removal:</span></p>
<pre class="source-code">
collection = bpy.data.collections['Collection']
collection.objects.unlink(bpy.data.objects['Cube'])</pre>
<p>In that case, <strong class="bold">Cube</strong> is not anymore in the scene, but is still <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">bpy.data.objects</strong></span><span class="No-Break">.</span></p>
<p>In this section, we <a id="_idIndexMarker131"/>have accessed the Blender objects via Python <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.data</strong></span><span class="No-Break">.</span></p>
<p>How would we fetch the current scene if there is more than just one, or the current object and <span class="No-Break">active selection?</span></p>
<p>We will see how states of user interaction can be tracked in the <span class="No-Break"><strong class="source-inline">bpy.context</strong></span><span class="No-Break"> module.</span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor046"/>Understanding the user context</h1>
<p>The current state of <a id="_idIndexMarker132"/>interaction, the current scene, and the selection are available via <strong class="source-inline">bpy.context</strong>. Since it depends on the user actions, <strong class="source-inline">bpy.context</strong> is read-only; that is, it cannot be changed directly. Anyway, we can affect the state of the current activity via <em class="italic">Python</em>. Rather than changing the attributes of <strong class="source-inline">bpy.context</strong>, we must look for the selection and activity properties of Blender’s objects, layers, <span class="No-Break">and scenes.</span></p>
<h3>Active scene</h3>
<p>A <strong class="source-inline">.blend</strong> file, or an <a id="_idIndexMarker133"/>unsaved session for that matter, can contain more <a id="_idIndexMarker134"/>than one <strong class="bold">scene</strong>. That differs from the standard in 3D packages, where a saved file is equivalent to one scene. If more scenes are available, they can be selected from the list menu at the top right of <span class="No-Break">Blender’s header.</span></p>
<p>Each scene can contain any of the objects from <strong class="source-inline">bpy.data.objects</strong>, and one object can belong to more than one scene. Changes made to an object in one scene retained in <span class="No-Break">the others.</span></p>
<p>We have seen how to create new objects using <strong class="source-inline">bpy.data.objects.new()</strong>. We can create new scenes in the same way, <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.data.scenes.new()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import bpy
new_scene = bpy.data.scenes.new('My Scene')
print('New scene created:', new_scene.name)</pre>
<p>The new scene will then be available in the <span class="No-Break">top-right widget.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 2.17: Blender scene menu" height="335" src="image/Figure_2._17_B18375.jpg" width="500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17: Blender scene menu</p>
<p>The currently <a id="_idIndexMarker135"/>displayed scene is contained <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">bpy.context.window</strong></span><span class="No-Break">.</span></p>
<p>If we want to create a <a id="_idIndexMarker136"/>new scene and make it active, we can assign it to the <span class="No-Break"><strong class="source-inline">window.scene</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
import bpy
new_scene = bpy.data.scenes.new('Another Scene')
bpy.context.window.scene = new_scene</pre>
<p>After executing this snippet, the 3D Viewport will switch to a new, empty scene. The current scene itself is part of <strong class="source-inline">bpy.context</strong> and can be retrieved via Python <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.context.scene</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
print('The current scene is', bpy.context.scene.name)</pre>
<h3>View Layers</h3>
<p><strong class="bold">View Layers</strong> are used to render <a id="_idIndexMarker137"/>the objects of a scene separately and put them <a id="_idIndexMarker138"/>back together using <strong class="bold">compositing</strong>. This is done either to speed up the rendering process, for instance, rendering the background only once, or for artistic necessities. In the UI, View Layers are created in the same way as scenes, using the widget on the <span class="No-Break">top bar.</span></p>
<p>When creating them in Python, we must keep in mind that they always belong to their scene rather than to <strong class="source-inline">bpy.data</strong>. Despite that, if we want to set the active layer, we still have to use an attribute <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">bpy.context.window</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import bpy
new_layer = bpy.context.scene.view_layers.new('My Layer')
print('New layer created:', new_layer.name)
bpy.context.window.view_layer = new_layer
print('Current layer:', bpy.context.view_layer.name)</pre>
<p>The active layer must belong to the active scene. A statement that tries to assign a layer from a different scene to the current window will be ignored. Take the <span class="No-Break">following example:</span></p>
<pre class="source-code">
import bpy
new_layer = bpy.context.scene.view_layers.new('Another Layer')
print('New layer created:', new_layer.name)
new_scene = bpy.data.scenes.new('Another Scene')
bpy.context.window.scene = new_scene
# NOTE: the following line will not work
bpy.context.window.view_layer = new_layer
print('Current layer:', bpy.context.view_layer.name)</pre>
<p>Layers can store rendering and pass properties, but also their visibility, activity, and selection status. In the next section, we’ll see how a layer stores the <span class="No-Break"><strong class="bold">active object</strong></span><span class="No-Break">.</span></p>
<h3>Active object</h3>
<p>When the user selects <a id="_idIndexMarker139"/>an object, that becomes the <strong class="bold">active object</strong> of the <a id="_idIndexMarker140"/>current layer. Its properties are displayed in the interface, and it will be the main target of the <span class="No-Break">user actions.</span></p>
<p>When Blender opens, a cube is the active object by default. We can see that from the <strong class="bold">Text Info</strong> in the <span class="No-Break">top-left corner.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 2.18: Blender’s default active object" height="463" src="image/Figure_2._18_B18375.jpg" width="1067"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18: Blender’s default active object</p>
<p>The active object can be retrieved in multiple places in the API, the most immediate <span class="No-Break">being </span><span class="No-Break"><strong class="source-inline">bpy.context.object</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
bpy.context.object  # read only
bpy.context.active_object  # read only, same as above
bpy.context.view_layer.objects.active  # can be set</pre>
<p>All three attributes point to the same object, but since <strong class="source-inline">bpy.context</strong> is read-only, only the <strong class="source-inline">view_layer</strong> attribute can be changed programmatically. If more layers are present, switching between layers can change the active object. Or we can change it using Python by following the <span class="No-Break">next steps.</span></p>
<h4>Changing the active object</h4>
<p>The active object is a <a id="_idIndexMarker141"/>property of the active View Layer. With that in mind, we can just set the <strong class="source-inline">view_layer.active</strong> attribute to a different object. For instance, here is how to pick the <span class="No-Break">camera instead:</span></p>
<ol>
<li>Open Blender or revert to the default scene <span class="No-Break">via </span><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break">-&gt;</span><span class="No-Break"><strong class="bold">New</strong></span><span class="No-Break">-&gt;</span><span class="No-Break"><strong class="bold">General</strong></span><span class="No-Break">.</span></li>
<li>Go to the <span class="No-Break">Scripting Workspace.</span></li>
<li>Type the following lines in the Python console and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span></li>
</ol>
<pre class="source-code">
import bpy
view_layer = bpy.context.view_layer
view_layer.objects.active = bpy.data.objects['Camera']</pre>
<p>We can see that the active object has changed from the 3D Viewport, the properties, and the <span class="No-Break">status information.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 2.19: Camera is now the active object" height="805" src="image/Figure_2.19_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19: Camera is now the active object</p>
<p>We can also see that the cube is still selected, and that the camera, despite being the active object, isn’t. That’s because the active and selected statuses are two distinct concepts. We are <a id="_idIndexMarker142"/>going to see, in the next section, how they differ, and how we can query and change the <span class="No-Break">current selection.</span></p>
<p class="callout-heading">Keep your focus</p>
<p class="callout">The Blender focus policy can be confusing at first. The area under the mouse cursor takes the <span class="No-Break">keyboard inputs.</span></p>
<p class="callout">That’s less of a problem for artists since their tasks usually involve keeping the cursor in the area in which they are operating. But it’s different for programmers; we might think of typing lines of code for the console only to find out that we are triggering shortcuts in the 3D Viewport, or the other <span class="No-Break">way around.</span></p>
<h3>Selected objects</h3>
<p>Let’s select all the objects <a id="_idIndexMarker143"/>in the scene by pressing the <em class="italic">A</em> key in the 3D Viewport (<strong class="bold">Select | All</strong> from the menu bar). Then, in the console, we type <span class="No-Break">the following:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.selected_objects
[bpy.data.objects['Cube'], bpy.data.objects['Light'], bpy.data.objects['Camera']]</pre>
<p><strong class="source-inline">selected_objects</strong> is a Python list. Unlike <strong class="source-inline">bpy.data.objects</strong>, it sorts the objects by their creation time and not alphabetically. Objects are <em class="italic">never</em> sorted by their selection time; Blender doesn’t keep that information at all. Should our tool require selecting objects in a specific sequence, we would have to store the order <span class="No-Break">somewhere else.</span></p>
<p>Selecting an object usually makes it the active object of the current layer. We can print out which object is active using comparisons <span class="No-Break">against </span><span class="No-Break"><strong class="source-inline">bpy.context.object</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
import bpy
for ob in bpy.context.selected_objects:
    if ob is bpy.context.object:
        print(ob.name, 'is active, skipping')
        continue
    print(ob.name, 'is selected')</pre>
<p>Running this snippet with all default objects selected will produce <span class="No-Break">this output:</span></p>
<pre class="source-code">
Cube is active, skipping
Light is selected
Camera is selected</pre>
<p>This pattern is useful whenever we want to propagate a property from the active object to the selection. We have already seen that we should not assume that the active object is always selected. Inverting the selection unselects the active object, but it will remain active. Or there might be no active object at all; it can be deleted or set to <strong class="source-inline">None</strong> via the <span class="No-Break">following line:</span></p>
<pre class="source-code">
bpy.context.view_layer.objects.active = None</pre>
<p>A way to check whether the active object belongs to the selection is with the <span class="No-Break"><strong class="source-inline">in</strong></span><span class="No-Break"> operator:</span></p>
<pre class="source-code">
is_sel = bpy.context.object in bpy.context.selected_objects</pre>
<p>Even better, we <a id="_idIndexMarker144"/>can use the <strong class="source-inline">select_get()</strong> and <strong class="source-inline">select_set()</strong> <span class="No-Break">object properties:</span></p>
<pre class="source-code">
is_sel = bpy.context.object.select_get()</pre>
<p>Like the active object, the selection status of an object is stored per View Layer. In the next section, we’ll learn how to affect the current selection and where it <span class="No-Break">is stored.</span></p>
<h4>Changing selected objects</h4>
<p>The selection status <a id="_idIndexMarker145"/>of an object is queried and set using <strong class="source-inline">object.select_get()</strong> and <strong class="source-inline">object.select_set()</strong> as, respectively, the <strong class="bold">getter</strong> and <strong class="bold">setter</strong> of the <a id="_idIndexMarker146"/>property. These functions accept a View Layer as an optional argument, allowing us <a id="_idIndexMarker147"/>to set selections for a specific layer. To get a glimpse of how the <strong class="source-inline">select_set</strong> function works, we can start to type it in the Python console, stopping at <span class="No-Break">the parenthesis:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.select_set(</pre>
<p>Pressing the <em class="italic">Tab</em> key will display a description of the function and <span class="No-Break">its arguments:</span></p>
<pre class="source-code">
select_set()
Object.select_set(state, view_layer=None)
Select or deselect the object. The selection state is per view layer</pre>
<p>If no View Layer is given, the selection of the current layer is used. For instance, this snippet will deselect all the objects in the <span class="No-Break">current layer:</span></p>
<pre class="source-code">
import bpy
for ob in bpy.context.selected_objects:
ob.select_set(False)</pre>
<p>We can create layers dynamically and assign them a different selection. Here is a snippet that creates a View Layer where mesh objects are selected, and another where <span class="No-Break">cameras are:</span></p>
<pre class="source-code">
import bpy
m_layer = bpy.context.scene.view_layers.new('Sel_Mesh')
c_layer = bpy.context.scene.view_layers.new('Sel_Cam')
for ob in bpy.data.objects:
    ob.select_set(ob.type == 'MESH', view_layer=m_layer)
    ob.select_set(ob.type == 'CAMERA', view_layer=c_layer)</pre>
<p>Selecting is the most <a id="_idIndexMarker148"/>immediate way for the user to pick objects from the scene. For this reason, <strong class="source-inline">bpy.context</strong> holds a pivotal role and is usually available in scripts, or even passed as a <span class="No-Break">Python object.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor047"/>Summary</h1>
<p>In this chapter, we saw how Python can access the content of Blender via <strong class="source-inline">bpy.data</strong> and introduced space entities such as vectors. We also saw how to interact with the user activity through <strong class="source-inline">bpy.context</strong>, and how read-only attributes of context are changed by affecting the status of objects <span class="No-Break">and layers.</span></p>
<p>In <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we will see how to insert our routines in our own add-ons and make them ready to install and use <span class="No-Break">in Blender.</span></p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor048"/>Questions</h1>
<ol>
<li>Which helper utilities are typical <span class="No-Break">of Blender?</span></li>
<li>How can we store and display <span class="No-Break">space coordinates?</span></li>
<li>Which attribute of <strong class="source-inline">bpy</strong> gives access to all <span class="No-Break">Blender entities?</span></li>
<li>Do Python classes of Blender objects have <span class="No-Break">a constructor?</span></li>
<li>How do we create new <span class="No-Break">Blender objects?</span></li>
<li>What does it mean that an object <span class="No-Break">is active?</span></li>
<li>Is the active object a property of the <span class="No-Break">Blender scene?</span></li>
<li>Can we affect the selection <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.context</strong></span><span class="No-Break">?</span></li>
<li>Can we affect the selection <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bpy.context.view_layer</strong></span><span class="No-Break">?</span></li>
</ol>
</div>
</div></body></html>