- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Topics – Sending and Receiving Messages between Nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you can write nodes, how can you make several nodes communicate with
    each other, and how can you interact with existing nodes in an application?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three kinds of communication in ROS 2: topics, services, and actions.
    In this chapter, we will dive into ROS 2 topics.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how topics work, we will start with a real-life analogy. This
    will allow you to grasp the concept using existing and common knowledge. Then,
    you will dive into the code and write a publisher and a subscriber inside a node—first
    with existing interfaces, and then by building custom interfaces. You will also
    use ROS 2 tools such as the **ros2** command line and **rqt_graph** to introspect
    topics and unlock more functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to make your nodes communicate
    with each other using ROS 2 topics. You will learn by writing code and will be
    provided with an additional challenge at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Topics are used everywhere in ROS 2\. Whether you wish to create an application
    from scratch or use existing ROS plugins, you will have to use topics.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the code inside the **ch4** folder in this book’s GitHub repository
    ([https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch))
    as a starting point. You can find the final code in the **ch5** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a ROS 2 topic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a topic publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a topic subscriber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional tools to handle topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom interface for a topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Topic challenge – closed-loop control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a ROS 2 topic?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You discovered the concept of topics through hands-on experiments in [*Chapter
    3*](B22403_03.xhtml#_idTextAnchor092). With this, you should have a basic intuition
    of how things work.
  prefs: []
  type: TYPE_NORMAL
- en: I am now going to start from scratch again and explain topics—not by running
    code, but by using a real-life analogy that makes it easier to understand. We
    will build an example, step by step, and then recap the most important points.
  prefs: []
  type: TYPE_NORMAL
- en: A publisher and a subscriber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this analogy, I will use radio transmitters and receivers. As this is a
    simplified example, not everything I’ll say about radio will be correct, but the
    point here is to understand ROS 2 topics.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with one radio transmitter. This radio transmitter will send some
    data at a given frequency. To make it easier for people to remember, this frequency
    is usually represented by a number, such as *98.7*. We can even think of *98.7*
    as a name. If you want to listen to the radio, you know you have to connect your
    device to *98.7*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can say that *98.7* is a topic. The radio transmitter is a
    **publisher** on this topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Radio transmitter publishing to the 98.7 topic](img/B22403_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Radio transmitter publishing to the 98.7 topic
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s say you want to listen to that radio from your phone. You will ask
    your phone to connect to *98.7* to receive the data.
  prefs: []
  type: TYPE_NORMAL
- en: With this analogy, the phone is then a **subscriber** to the *98.7* topic.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note here is that both the radio transmitter and the
    phone must use the same type of frequency. For example, if the radio transmitter
    is using an AM signal, and if the phone is trying to decode an FM signal, it will
    not work.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, with ROS 2 topics, both the publisher and subscriber must use the
    same data type. This data type is called an **interface**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what defines a topic: a **name** and an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Publisher and subscriber using the same interface](img/B22403_05_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Publisher and subscriber using the same interface
  prefs: []
  type: TYPE_NORMAL
- en: With that, the communication is complete. The radio transmitter publishes an
    AM signal on the *98.7* topic. The phone subscribes to the *98.7* topic, decoding
    an AM signal.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple publishers and subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In real life, there won,t be just one device trying to listen to the radio.
    Let’s add a few more devices, each one subscribing to the *98.7* topic and decoding
    an AM signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Topic with multiple subscribers](img/B22403_05_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Topic with multiple subscribers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, one topic can have several subscribers. Each subscriber will
    get the same data. On the other hand, we could also have several publishers for
    one topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that there is another radio transmitter, also publishing an AM signal
    to *98.7*. In this case, both the data from the first transmitter and the second
    transmitter are received by all listening devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Multiple publishers and subscribers](img/B22403_05_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Multiple publishers and subscribers
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows boxes. Each box represents a node. Thus, we have
    two radio transmitter nodes, both containing a publisher to the *98.7* topic.
    We also have three nodes (phone, radio receiver, and car), each one containing
    a subscriber to *98.7*.
  prefs: []
  type: TYPE_NORMAL
- en: Note that one subscriber is not aware of the other subscribers. When you listen
    to the radio on your phone, you have no idea who else is listening to the radio,
    and on what device.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the phone, the radio receiver and the car are not aware of who is publishing
    on the radio. They only know they have to subscribe to *98.7*; they don’t know
    what’s behind it.
  prefs: []
  type: TYPE_NORMAL
- en: On the other side, both radio transmitters are not aware of each other and of
    who is receiving the data. They just publish on the topic, regardless of who is
    listening. Thus, we say that topics are **anonymous**. Publishers and subscribers
    are not aware of other publishers and subscribers. They only publish or subscribe
    to a topic, using its name and interface.
  prefs: []
  type: TYPE_NORMAL
- en: Any combination of publishers and subscribers is possible. For example, you
    could have two publishers on the topic and zero subscribers. In this case, the
    data is still correctly published, but no one receives it. Alternatively, you
    could have zero publishers and one or more subscribers. The subscribers will listen
    to the topic but will receive nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple publishers and subscribers inside one node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A node is not limited to having just one publisher or one subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add another radio to our example. We will name it *101.3*, and its data
    type is FM signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second radio transmitter is now publishing both on the *98.7* topic and
    the *101.3* topic, sending the appropriate type of data for each topic. Let’s
    also make the car listen to the *101.3* topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – A node with two publishers](img/B22403_05_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – A node with two publishers
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the second radio transmitter can publish on several topics,
    so long as it uses the correct name and interface for each topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that the car, while listening to the radio, is also sending its
    GPS coordinates to a remote server. We could create a topic named **car_location**,
    and the interface would contain a latitude and a longitude. The car node now contains
    one subscriber to the *98.7* topic, and one publisher to the **car_location**
    topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – A node with both a publisher and a subscriber](img/B22403_05_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – A node with both a publisher and a subscriber
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, I have also added another node for the server, represented
    by a computer. The server node will subscribe to the **car_location** topic so
    that it can receive the GPS coordinates. Of course, both the publisher and subscriber
    are using the same interface (latitude and longitude).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, inside one node, you can have any number of publishers and subscribers
    to different topics with different data types. A node can communicate with several
    nodes at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping things up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ROS 2 nodes can send messages to other nodes using topics.
  prefs: []
  type: TYPE_NORMAL
- en: Topics are mostly used to send data streams. For example, you could create a
    hardware driver for a camera sensor, and publish images taken from the camera.
    Other nodes can then subscribe to the topic and receive the images. You could
    also publish a stream of commands for a robot to move, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are many possibilities for when to use topics, and you will get to know
    more about them as you progress throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some important points about how topics work:'
  prefs: []
  type: TYPE_NORMAL
- en: A topic is defined by a name and an interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A topic name must start with a letter and can be followed by other letters,
    numbers, underscores, tildes, and slashes. For the real-life analogy with radio,
    I used numbers with dots as topic names. Although it made the examples easier,
    this is not valid for ROS 2 topics. To make it valid, instead of *98.7*, we would
    have to create a topic named `radio_98_7`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any publisher or subscriber to a topic must use the same interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishers and subscribers are anonymous. They are not aware of each other;
    they just know they are publishing or subscribing to a topic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node can contain several publishers and subscribers to different topics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, how do you create a publisher or a subscriber?
  prefs: []
  type: TYPE_NORMAL
- en: You will do this by adding some code to your nodes. As you saw previously, you
    can write a Python node using **rclpy** and a C++ node using **rclcpp**. With
    those two libraries, you can create publishers and subscribers directly in your
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a topic publisher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you’ll write your first ROS 2 publisher. To work on the core
    concepts, we will create a new ROS 2 application and build upon it in the following
    chapters. This application will be super minimalistic so that we can focus on
    the concept we want to learn, nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do for now is publish a number on a topic. This topic is new
    and we will *create* it. You don’t really create a topic—you create a publisher
    or a subscriber to that topic. This will automatically create the topic name,
    which will be registered on the graph.
  prefs: []
  type: TYPE_NORMAL
- en: To write a publisher, we need a node. We could use the first node we created
    in the previous chapter, but the purpose of the node is not the same. Hence, we
    will create a new node named **number_publisher**. In this node, we will create
    a publisher. As to the topic we want to publish to, we will have to choose a name
    and an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get started with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python publisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write a publisher, we need to create a node; to create a node, we need a
    package. To make things simple, let’s continue using the **my_py_pkg** package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Navigate inside the **my_py_pkg** package, create a Python file, and make it
    executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open this file, use the node OOP template (given in [*Chapter 4*](B22403_04.xhtml#_idTextAnchor157)),
    and modify the required fields to give names that make sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a **main()** function and a **NumberPublisherNode** class
    for your node, we can create a publisher.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a publisher to the node
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where can we create a publisher in this node? We will do that in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'And before we write the code, we need to ask ourselves a question: what is
    the name and the interface for this topic?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Case 1**: You’re publishing to a topic that already exists (other publishers
    or subscribers on that topic), and then you use the same name and interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case 2**: You create a publisher for a new topic (what we are doing now),
    and then you have to choose a name and interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the name, let’s keep it simple and use **number**. If we publish a number,
    we can expect to receive this number on a **number** topic. If you were to publish
    a temperature, you could name the topic **temperature**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the interface, you have two choices: use an existing interface or create
    a custom one. To get started, we will use an existing interface. To make this
    easier, I will just tell you what to use; you’ll learn how to find other interfaces
    yourself later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use **example_interfaces/msg/Int64**. To get more details about what’s
    in the interface, we can run **ros2 interface show <interface_name>** in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Great—this is exactly what we need: an **int64** number.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this information, let’s create the publisher. First, import
    the interface, and then create the publisher in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To import the interface, we must specify the name of the package (**example_interfaces**),
    then the folder name for topic messages (**msg**), and finally the class for the
    interface (**Int64**).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the publisher, we must use the **create_publisher()** method from
    the **Node** class. Inheriting from this class gives us access to all ROS 2 functionalities.
    In this method, you have to provide three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int64` from the `example_interfaces` package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10` every time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this, we now have a publisher on the **number** topic. However, if you
    just run your code like this, nothing will happen. A publisher won’t publish automatically
    on a topic. You have to write the code for that to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing with a timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common behavior in robotics is to do *X* action every *Y* seconds—for example,
    publish an image from a camera every **0.5** seconds, or in this case, publish
    a number on a topic every **1.0** second. As seen in [*Chapter 4*](B22403_04.xhtml#_idTextAnchor157),
    to do this, you must implement a timer and a callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the code inside the node so that you publish on the topic from a timer
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After creating the publisher with **self.create_publisher()**, we create a timer
    with **self.create_timer()**. Here, we say that we want the **publish_number()**
    method to be called every **1.0** second. This will happen when the node is spinning.
  prefs: []
  type: TYPE_NORMAL
- en: On top of that, I also added a log at the end of the constructor to say that
    the node has been started. I usually do this as a best practice so that I can
    see when the node is fully initialized on the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **publish_number()** method, we publish on the topic:'
  prefs: []
  type: TYPE_NORMAL
- en: We create an object from the `Int64` class. This is the interface—in other words,
    the message to send.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This object contains a `data` field. How do we know this? We found this previously
    when we ran `ros2 interface show example_interfaces/msg/Int64`. Thus, we provide
    a number in the `data` field of the message. For simplicity, we specify the same
    number every time we run the callback function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We publish the message using the `publish()` method from the publisher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This code structure is super common in ROS 2\. Any time you want to publish
    data from a sensor, you will write something similar.
  prefs: []
  type: TYPE_NORMAL
- en: Building the publisher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To try your code, you need to install the node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do this, since we’re using a new dependency (**example_interfaces**
    package), we also need to add one line to the **package.xml** file of the **my_py_pkg**
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you add more functionalities inside your package, you will add any other
    ROS 2 dependency here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the node, open the **setup.py** file from the **my_py_pkg** package
    and add a new line to create another executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you add a comma between each line; otherwise, you could encounter
    some strange errors when building the package.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ve created a new executable named **number_publisher**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, as you can see from this example, the node name, filename, and executable
    name are the same: `number_publisher`. This is a common thing to do. Just remember
    that those names represent three different things.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go to your workspace root directory and build the **my_py_pkg** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can add **--symlink-install** if you want to, so that you don’t need to
    run **colcon build** every time you modify the **number_publisher** node.
  prefs: []
  type: TYPE_NORMAL
- en: Running the publisher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the package has been built successfully, source your workspace and start
    the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The node is running, but apart from the initial log, nothing is displayed. That’s
    normal—we didn’t ask the node to print anything else.
  prefs: []
  type: TYPE_NORMAL
- en: How do we know that the publisher is working? We could write a subscriber node
    right away and see if we receive the messages. But before we do that, we can test
    the publisher directly from the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal window and list all topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can find the **/****number** topic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is an added leading slash in front of the topic name.
    We only wrote `number` in the code, not `/number`. This is because ROS 2 names
    (nodes, topics, and so on) are organized inside namespaces. Later, we will see
    that you can add a namespace to put all your topics or nodes inside the `/abc`
    namespace, for example. In this case, the topic name would be `/abc/number`. Here,
    as no namespace is provided, a leading slash is added to the name, even if we
    don’t provide it in the code. We could call this the *global* namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **ros2 topic echo <topic_name>** command, you can subscribe to the
    topic directly from the subscriber and see what’s being published. We will learn
    more about this command later in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get one new message per second, which contains a **data**
    field with a value of **2**. This is exactly what we wanted to do in the code.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve finished our first Python publisher. Let’s switch to C++.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a C++ publisher
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, the process is the same as for Python. We will create a new node, and
    in this node, add a publisher and a timer. In the timer callback function, we
    will create a message and publish it.
  prefs: []
  type: TYPE_NORMAL
- en: I will go a bit more quickly in this section as the explanations are the same.
    We will just focus on the specificities of the C++ syntax with ROS 2.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For everything related to C++ in this book, make sure you follow the explanations
    using the GitHub code on the side. I may not provide the full code, only the important
    snippets that are crucial for comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a node with a publisher and a timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let’s create a new file for our **number_publisher** node in the **my_cpp_pkg**
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Open this file and write the code for the node. You can start from the OOP
    template and add the publisher, timer, and callback function. The complete code
    for this chapter can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/ROS-2-from-Scratch](https://github.com/PacktPublishing/ROS-2-from-Scratch).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I will now comment on a few important lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To include an interface for a topic, use **"<package_name>/msg/<message_name>.hpp"**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the constructor, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In C++, we also use the **create_publisher()** method from the **Node** class.
    The syntax is a bit different since templates are used, but you can still find
    the topic interface, topic name, and queue size (as a reminder, you can set it
    to **10** every time).
  prefs: []
  type: TYPE_NORMAL
- en: 'The publisher is also declared as a private attribute in the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use the **rclcpp::Publisher** class, and as for many things
    in ROS 2, we use a shared pointer. For several common classes, ROS 2 provides**::SharedPtr**,
    which would be the same thing as writing **std::shared_ptr<the publisher>**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the publisher, we create a timer to call the **publishNumber**
    method every **1.0** second. Finally, we print a log so that we know that the
    constructor code has been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the callback method. As for Python, we create an object from the interface
    class, after which we fill any field from this interface and publish the message.
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the publisher
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve written the node with the publisher, timer, and callback function,
    it’s time to build it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did for Python, open the **package.xml** file of the **my_cpp_pkg** package
    and add one line for the dependency to **example_interfaces**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open the **CMakeLists.txt** file from the **my_cpp_pkg** package and
    add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For any new dependency, we need to add a new **find_package()** line.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create a new executable. Note that we also provide **example_interfaces**
    in the arguments of **ament_target_dependencies()**. If you omit this, you will
    get an error during compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there’s no need to re-create the **install()** block. Just add the
    executable in a new line, without any commas between the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can build, source, and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The node containing the publisher is up and running. By using **ros2 topic list**
    and **ros2 topic echo <topic_name>**, you can find the topic and see what’s being
    published.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve created a publisher and you know it’s working, it’s time to
    learn how to create a subscriber for that topic.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a topic subscriber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To continue improving our application, let’s create a new node that will subscribe
    to the **/number** topic. Each number that’s received will be added to a counter.
    We want to print the counter every time it’s updated.
  prefs: []
  type: TYPE_NORMAL
- en: As we did previously, let’s start the full explanations with Python, and then
    see the syntax specificities with C++.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Python subscriber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the complete code for this Python node on GitHub. Many things we
    need to do here are identical to what we did previously, so I won’t fully detail
    every step. Instead, we will focus on the most important things so that we can
    write the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Python node with a subscriber
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new node named **number_counter** inside the **my_py_pkg** package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, you can write the code for the node and add a subscriber. Here’s
    the explanation, step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we want to create a subscriber to receive what we sent with the publisher,
    we need to use the same interface. Hence, we import **Int64** as well. Then, we
    can create the subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As for publishers, we will create subscribers in the node’s constructor. Here,
    we use the **create_subscription()** method from the **Node** class. With this
    method, you need to provide four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int64`. This needs to be the same for both the publisher and subscriber.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`. This is the same name as for the publisher. Note that I don’t provide
    any additional slash here. This will be added automatically, so the topic name
    will become `/number`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/number` topic, it will be received here, and we will be able to use it and
    process it inside the callback method (that we need to implement).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10` and forget about it for now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s see the implementation for the callback method, which I named **callback_number**:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a best practice, I recommend naming callback methods for topics `callback_<topic>`.
    By adding the `callback_` prefix, you make it clear that this method is a callback
    and shouldn’t be called directly in the code. This can prevent lots of errors
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In a subscriber callback, you receive the message directly in the parameters
    of the function. Since we know that **Int64** contains a **data** field, we can
    access it with **msg.data**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we add the received number to a **counter_** attribute and print the counter
    every time with a ROS 2 log.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a best practice, I have specified the `Int64` type for the `msg` argument
    of the method. This isn’t mandatory for Python code to work, but it adds an extra
    level of safety (we are sure that we should receive `Int64` and nothing else)
    and it can sometimes make your IDE work better with auto-completion.
  prefs: []
  type: TYPE_NORMAL
- en: To finish the node, don’t forget to add the **main()** function after the **NumberCounterNode**
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Python subscriber
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, to try the code, add a new executable to the **setup.py** file of your
    Python package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Then, build the package and source the workspace (from now on, I will not write
    those commands every time since they’re always the same).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run each node (**number_publisher** and **number_counter**) in a different
    Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the **number_counter** node adds **2** to the counter every
    **1.0** second. If you see this, then the publish/subscribe communication between
    your two nodes is working.
  prefs: []
  type: TYPE_NORMAL
- en: You can start and stop the **number_publisher** node and see that every time
    you start it, **number_counter** continues to add numbers from the current count.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a C++ subscriber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s create the **number_counter** node in C++. The principle is the same,
    so let’s just focus on the syntax here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a C++ node with a subscriber
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new file for your node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Open this file and write the code for the node (once again, the complete code
    is on GitHub).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a subscriber in your node, run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We find the same components as for Python (but in a different order): topic
    interface, topic name, queue size, and callback for received messages. For **_1**
    to work, don’t forget to add **using namespace std::placeholders;** before it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even if the `rclpy` and `rclcpp` libraries are supposed to be based on the same
    underlying code, there can still be some differences in the API. Don’t worry if
    the code sometimes doesn’t look the same between Python and C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subscriber object is declared as a private attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use the **rclcpp::Subscription** class here, and once again, we create a
    shared pointer to that object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have the callback method, **callbackNumber**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The message we receive in the callback is also a (**const**) shared pointer.
    Hence, don’t forget to use **->** when accessing the **data** field.
  prefs: []
  type: TYPE_NORMAL
- en: In this callback, we add the received number to the counter and print it.
  prefs: []
  type: TYPE_NORMAL
- en: Running the C++ subscriber
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new executable for that node. Open **CMakeLists.txt** and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, build **my_cpp_pkg**, source the workspace, and run both the publisher
    and the subscriber node in different Terminals. You should see a similar output
    to what we had with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Python and C++ nodes together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve just created a publisher and subscriber for both Python and C++. The topic
    we use has the same name (**number**) and interface (**example_interfaces/msg/Int64**).
  prefs: []
  type: TYPE_NORMAL
- en: If the topic is the same, it means that you could start the Python **number_publisher**
    node with the C++ **number_counter** node, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can also try the opposite by running the C++ **number_publisher** node with
    the Python **number_counter** node.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it working? Simply because ROS 2 is language-agnostic. You could have
    any node written in any (supported) programming language, and this node could
    communicate with all the other nodes in the network, using topics and other ROS
    2 communications.
  prefs: []
  type: TYPE_NORMAL
- en: ROS 2 communications happen at a lower level, using **Data Distribution Service**
    (**DDS**). This is the middleware part and is responsible for sending and receiving
    messages between nodes. When you write a Python or C++ node, you are using the
    same DDS functionality, with an API implemented in either **rclpy** or **rclcpp**.
  prefs: []
  type: TYPE_NORMAL
- en: I will not go too far with this explanation as it’s quite advanced and not really
    in the scope of this book. If there is just one thing to remember from this, it’s
    that Python and C++ nodes can communicate with each other using ROS 2 communication
    features. You can create some nodes in Python and other nodes in C++; just make
    sure to use the same communication name and interface on both sides.
  prefs: []
  type: TYPE_NORMAL
- en: Additional tools to handle topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve just written a bunch of nodes containing publishers and subscribers.
    We will now explore how ROS 2 tools can help you do more things with topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introspection with `rqt_graph`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introspection and debugging with the `ros2 topic` command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing a topic name when starting a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaying topic data with bags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introspecting topics with rqt_graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used **rqt_graph** to visualize nodes in [*Chapter 3*](B22403_03.xhtml#_idTextAnchor092).
    Let’s run it again and see how to introspect the publisher and subscriber we have
    just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start both the **number_publisher** and **number_counter** nodes (from
    any package: **my_py_pkg** or **my_cpp_pkg**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, start **rqt_graph** in another Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed, refresh the view a few times and select **Nodes/Topics (all)**.
    You can also uncheck the **Dead sinks** box and the **Leaf topics** box. This
    will allow you to see topics even if there is just one subscriber and no publisher,
    or one publisher and no subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The number topic on rqt_graph](img/B22403_05_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The number topic on rqt_graph
  prefs: []
  type: TYPE_NORMAL
- en: There, we can see the **number_publisher** node and the **number_counter** node.
    In the middle, we have the **/number** topic, and we can see which node is a publisher
    or a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **rqt_graph** package can be extremely useful when debugging topics. Imagine
    that you run some nodes and you’re wondering why topic messages are not received
    by a subscriber. Maybe those nodes are not using the same topic name. You can
    easily see this with **rqt_graph**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Topic name mismatch between publisher and subscriber](img/B22403_05_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Topic name mismatch between publisher and subscriber
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I made an intentional error in the topic name inside the publisher.
    Instead of **number**, I have written **numberr**. With **rqt_graph**, I can see
    where the issue is. The two nodes are not communicating with each other.
  prefs: []
  type: TYPE_NORMAL
- en: The ros2 topic command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With **ros2 node**, we get additional command-line tools for nodes. For topics,
    we will use **ros2 topic**.
  prefs: []
  type: TYPE_NORMAL
- en: If you run **ros2 topic -h**, you’ll see that there are quite a lot of commands.
    You already know some of them. Here, I will do a quick recap and explore a few
    more commands that can be useful when debugging topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to list all topics, use **ros2** **topic list**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we get the **/number** topic. You will also always get **/parameter_events**
    and **/rosout** (all ROS 2 logs are published on this topic).
  prefs: []
  type: TYPE_NORMAL
- en: 'With **ros2 topic info <topic_name>**, you can get the interface for the topic,
    as well as the number of publishers and subscribers for that topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to go further and see the details for the interface, you can run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have all the information we need to create an additional publisher
    or subscriber to the topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, we can also directly subscribe to the topic from the Terminal
    with **ros2 topic echo <topic_name>**. That’s what we did just after writing the
    publisher so that we can make sure it’s working before we write any subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, you can publish to a topic directly from the Terminal with
    **ros2 topic pub -r <frequency> <topic_name> <interface> <message_in_json>**.
    To test this, stop all nodes, and start only the **number_counter** node in one
    Terminal. Apart from the first log, nothing will be printed. Then, run the following
    command in another Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will publish on the **/number** topic at **2.0** Hertz (every **0.5**
    seconds). When you run this, you’ll see some logs on the **number_counter** node,
    meaning that the messages have been received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can test a subscriber without having to write a publisher first.
    Note that this only really works for topics with a simple interface. When the
    interface contains too many fields, it becomes too complicated to write everything
    on the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both `ros2 topic echo` and `ros2 topic pub` can save you lots of time, and it’s
    also great for collaborating with other people on a project. You could be responsible
    for writing a publisher, and someone else would write a subscriber. With those
    command-line tools, both of you can make sure the topic communication is working.
    Then, when you run the two nodes together, you know that the data you send or
    receive is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a topic name at runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B22403_04.xhtml#_idTextAnchor157), you learned how to change
    a node name at runtime—that is, by adding **--ros-args -r __node:=<new_name>**
    after the **ros2** **run** command.
  prefs: []
  type: TYPE_NORMAL
- en: So, for any additional argument you pass after **ros2 run**, add **--ros-args**,
    but only once.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can also change a topic name at runtime. To do that, add another **-r**,
    followed by **<topic_name>:=<new_topic_name>**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s rename our topic from **number** to **my_number**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we start the **number_counter** node, to be able to receive the messages,
    we also need to modify the topic name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With this, the communication will work, but this time using the **my_number**
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things a bit more interesting, let’s keep those two nodes running,
    and let’s run another publisher to this topic, using the same **number_publisher**
    node. As you know, we can’t have two nodes running with the same name. Thus, we
    will have to rename both the node and the topic. In a third Terminal, run the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: After you run this, you’ll see that the **number_counter** receives messages
    twice as fast since there are two nodes publishing one message every **1.0** second.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of that, let’s start **rqt_graph**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Two publishers and a subscriber, with a renamed topic](img/B22403_05_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Two publishers and a subscriber, with a renamed topic
  prefs: []
  type: TYPE_NORMAL
- en: We’ll see that we have two nodes containing a publisher on the **my_number**
    topic, and one node containing a subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Changing topic names at runtime will be quite useful for you, especially when
    you want to run several existing nodes that you can’t modify. Even if you can’t
    rewrite the code, you can modify the names at runtime. Now, let’s continue with
    the tools and explore ROS 2 bags.
  prefs: []
  type: TYPE_NORMAL
- en: Replaying topic data with bags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine this scenario: you’re working on a mobile robot that’s supposed to
    perform in a certain way when navigating outside and while it’s raining.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this means you will need to run the robot in those conditions so that
    you can develop your application. There are a few problems: maybe you won’t have
    access to the robot every time, or you can’t take it outside, or it’s simply not
    raining every day.'
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this is to use ROS 2 bags. Bags allow you to record a topic and
    replay it later. Thus, you can run the experiment once with the required conditions,
    and then replay the data just like it was recorded. With this data, you can develop
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another scenario: you work with a piece of hardware that isn’t
    stable yet. Most of the time, it doesn’t work properly. You could record a bag
    while the hardware is working fine, and then replay this bag to develop your application
    instead of running the hardware again and again and wasting time on this.'
  prefs: []
  type: TYPE_NORMAL
- en: To work with ROS 2 bags, you must use the **ros2 bag** command-line tool. Let’s
    learn how to save and replay a topic with bags.
  prefs: []
  type: TYPE_NORMAL
- en: First, stop all nodes and run the **number_publisher** node only.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that the topic name is **/number**. You can retrieve that with
    **ros2 topic list** if needed. Then, in another Terminal, record the bag with
    **ros2 bag record <list of topics> -o <bag_name>**. To make things more organized,
    I suggest that you create a **bags** folder and record from within this folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the bag is recording and saving all incoming messages inside
    a database. Let it run for a few seconds, then stop it with *Ctrl* + *C*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The **ros2 bag** command will exit, and you’ll end up with a new directory named
    **bag1**. In this directory, you will find a **.mcap** file containing the recorded
    messages and a YAML file with more information. If you open this YAML file, you’ll
    see the recorded duration, number of recorded messages, and topics that were recorded.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can replay the bag, which means you’ll publish on the topic exactly
    like it was done when recording.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the **number_publisher** node and replay the bag with **ros2 bag** **play
    <path_to_bag>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will publish all the recorded messages, with the same duration as the recording.
    So, if you record for 3 minutes and 14 seconds, the bag will replay the topic
    for 3 minutes and 14 seconds. Then, the bag will exit, and you can play it again
    if you want.
  prefs: []
  type: TYPE_NORMAL
- en: While the bag is playing, you can run your subscriber(s). You can do a quick
    test with **ros2 topic echo /number** and see the data. You can also run your
    **number_counter** node, and you will see that the messages are received.
  prefs: []
  type: TYPE_NORMAL
- en: You are now able to save and replay a topic using ROS 2 bags. You can explore
    more advanced options with **ros2** **bag -h**.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, there are quite a few available tools for topics. Use these
    tools as often as possible to introspect, debug, and test your topics. They will
    save you lots of time when you’re developing your ROS 2 application.
  prefs: []
  type: TYPE_NORMAL
- en: We’re almost done with topics. So far, all we’ve done is use existing interfaces.
    Now, let’s learn how to create a custom interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom interface for a topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a publisher or subscriber for a topic, you know that you have
    to use a name and an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s quite easy to publish or subscribe to an existing topic: you’ll find the
    name and interface using the **ros2** command line, and use that in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you want to start a publisher or subscriber for a new topic, you will
    need to choose a name and interface by yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: No problem—it’s just a chain of characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface**: You have two choices—using an existing interface that works
    with your topic or creating a new one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s try to apply the ROS 2 philosophy of not reinventing the wheel. When you
    create a new topic, check if there is any existing interface that can match your
    needs. If so, then use it; don’t recreate it.
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll learn where you can find existing interfaces. Then, you’ll learn
    how to create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It’s quite common to use the word *message* when talking about topic interfaces.
    I could have named this section *Creating a custom message*. In the following
    section, when I talk about messages, I’m referring to topic interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Using existing interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you start a new publisher or subscriber for a topic, take some time to
    think about what kind of data you want to send or receive. Then, check if an already
    existing interface contains what you need.
  prefs: []
  type: TYPE_NORMAL
- en: Where to find interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like nodes, interfaces are organized in packages. You can find the most
    common packages for ROS 2 interfaces here: [https://github.com/ros2/common_interfaces](https://github.com/ros2/common_interfaces).
    Not all existing interfaces are listed here, but it’s already quite a lot. For
    other interfaces, a simple search on the internet should bring you to the corresponding
    GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: In this common interfaces repository, you can find the **Twist** message we
    used with Turtlesim, inside the **geometry_msgs** package. As you can see, for
    topic interfaces, we then have an additional **msg** folder, which contains all
    the message definitions for that package.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s say you want to create a driver node for a camera and publish the
    images to a topic. If you look inside the **sensor_msgs** package, and then inside
    the **msg** folder, you’ll find a file named **Image.msg**. This *Image* message
    is probably suitable for your needs. It is also used by a lot of other people,
    so it will even make your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: Using an existing interface in your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use this message, make sure you’ve installed the package that contains the
    message—in this case, **sensor_msgs**. As a quick reminder, to install a ROS 2
    package, you can run **sudo apt** **install ros-<distro>-<package-name>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe the package was already installed. If not, source your environment again
    afterward. Then, you can find the details regarding the interface with **ros2
    interface** **show <interface>**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this message in your code, just follow what we did in this chapter (with
    the **example_interfaces/msg/Int64** message):'
  prefs: []
  type: TYPE_NORMAL
- en: In the `package.xml` file of the package where you write your nodes, add the
    dependency to the interface package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your code, import the message and use it in your publisher or subscriber.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For C++ only: Add the dependency to the interface package in the `CMakeLists.txt`
    file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will see another example of this process very soon, just after we create
    our interface.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you know how to find and use existing messages in your code.
    But should you always do that?
  prefs: []
  type: TYPE_NORMAL
- en: When not to use existing messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For common use cases, sensors, and actuators, you will probably find what you
    need. However, if the interface doesn’t match exactly what you want, you will
    have to create a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few packages containing basic interfaces, such as **example_interfaces**,
    or even **std_msgs**. You could be tempted to use them in your code. As a best
    practice, it’s better to avoid it. Just read the comments from the message definitions
    to be sure of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the **std_msgs** package is deprecated, and **example_interfaces**
    is only recommended to make tests—which is what we’ve done in this chapter so
    far to help us learn various topics.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, if you don’t find exactly what you need in the existing interface
    packages, then create your own interface. It’s not hard to do and will always
    be the same process.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new topic interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will now create your first custom interface for a topic. We will see how
    to set a package up for that, how to create and build the interface, and how to
    use it in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and setting up an interfaces package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we create any topic interface (message), we need to create a new package
    and set it up for building interfaces. As a best practice, in your application,
    you will have one package dedicated to custom interfaces. This means that you
    create interfaces only in this package, and you keep this package only for interfaces—no
    nodes or other things, just interfaces. This will make it much easier when you’re
    scaling the application and will help you avoid creating a dependency mess.
  prefs: []
  type: TYPE_NORMAL
- en: A common practice when naming this interface package is to start with the name
    of your application or robot and add the **_interfaces** suffix. So, if your robot
    is named **abc**, you should use **abc_interfaces**.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t have a robot for this example, so let’s just name the package **my_robot_interfaces**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new package with the **ament_cmake** build type and no dependencies.
    You don’t even need to provide the build type since **ament_cmake** is the one
    used by default. Navigate to the **src** directory of your workspace and create
    this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your workspace should contain three packages: **my_py_pkg**,
    **my_cpp_pkg**, and **my_robot_interfaces**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to set this new package up and modify a few things so it can build
    messages. Go into the package, remove the **src** and **include** directories,
    and create a new **msg** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the **package.xml** file for this package. After **<buildtool_depend>ament_cmake</buildtool_depend>**,
    add the following three lines. I recommend that you just copy and paste them so
    that you don’t make any mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the **package.xml** file is complete and you won’t have to do anything
    else with it for now. Open the **CMakeLists.txt** file. After **find_package(ament_cmake
    REQUIRED)**, and before **ament_package()**, add the following lines (you can
    also remove the **if(BUILD_TESTING)** block):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There’s not much to understand about these lines you’re adding. They will find
    some dependencies (**rosidl** packages) and prepare your package so that it can
    build interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your package is ready and you can add new interfaces. You will
    only need to do this setup phase once. At this point, adding a new interface is
    very quick.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and building a new topic interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s say we want to create a publisher to send some kind of hardware status
    for our robot, including the robot version, internal temperature, a flag to know
    if the motors are ready, and a debug message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve looked at existing interfaces and nothing matches. How can you name this
    new interface? Here are the rules you have to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Use UpperCamelCase—for example, HardwareStatus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t write `Msg` or `Interface` in the name as this would add unnecessary redundancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `.msg` for the file extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Following these rules, create a new file named **HardwareStatus.msg** in the
    **msg** folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this file, we can add the definition for the message. Here’s what you
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Built-in types, such as `bool`, `byte`, `int64`, `float64`, and `string`, as
    well as arrays of those types. You can find the complete list here: [https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types](https://docs.ros.org/en/rolling/Concepts/Basic/About-Interfaces.html#field-types).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other existing messages, using the name of the package, followed by the name
    of the message —for example, `geometry_msgs/Twist` (don’t add the `msg` folder
    here).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To make things simple here, we will start with only built-in types. Write the
    following inside the message file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For each field, we provide the data type, and then the name of the field.
  prefs: []
  type: TYPE_NORMAL
- en: Now, how are we going to build this message? How can we get a Python or C++
    class that we can include and use in our code?
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the message, you simply have to add one line to **CMakelists.txt**,
    specifying the relative path to the message file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: For each new interface you build in this package, you will add one line inside
    the **rosidl_generate_interfaces()** function. *Don’t add any commas between*
    *the lines.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, save all the files and build your new package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The build system will take the interface definition you’ve written and use
    it to generate source code for Python and C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Build system for interfaces](img/B22403_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Build system for interfaces
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve built the package, make sure you source the environment. You should
    be able to see your interface from the Terminal (don’t forget to use auto-completion
    to build the command faster and be sure you have the correct name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If you see this, it means that the build process succeeded. If you can’t see
    the interface in the Terminal, then you need to go back and check that you did
    all the steps correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Using your custom message in your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s say you want to use your new interface in the **number_publisher** node
    you created in this chapter, inside the **my_py_pkg** package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the **package.xml** file from the **my_py_pkg** package and add
    a dependency to **my_robot_interfaces**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for Python, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the message by by adding the following import line in your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a publisher and specify the `HardwareStatus` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a message in your code, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using VS Code, the message might not be recognized after you import
    it. Close VS Code and open it again in a sourced environment. So, make sure the
    interface has been built correctly, then source the environment, and open VS code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use this message in your C++ node from the **my_cpp_pkg** package,
    add the dependency to **my_robot_interfaces** in the **package.xml** file of **my_cpp_package**.
    Then, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the message by adding the following `include` line in your code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a publisher and specify the interface with `<my_robot_interfaces::msg::``HardwareStatus>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a message in your code, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using VS code, the C++ include will not be recognized. You need to add
    a new line to the **c_cpp_properties.json** file that was auto-generated (inside
    a **.vscode** folder) when you started VS Code. You can find this file from VS
    Code using the explorer on the left. Then, in the **includePath** array, add the
    following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can now create and use your custom interface for topics. As you’ve seen,
    first, check whether there’s any existing interface that matches your needs. If
    there is, don’t reinvent the wheel. If nothing matches perfectly, however, don’t
    hesitate to create your own interface. To do that, you must create a new package
    dedicated to interfaces. Once you’ve finished the setup process for this package,
    you can add as many interfaces as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap things up, I will give you an additional challenge so that you
    can practice the concepts that were covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Topic challenge – closed-loop control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s a challenge for you so that you can continue practicing creating nodes,
    publishers, and subscribers. We will start a new ROS 2 project and improve it
    throughout the following chapters, as we discover more concepts.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage you to read the instructions and take the time to complete this
    challenge before you check the solution. Practicing is the key to effective learning.
  prefs: []
  type: TYPE_NORMAL
- en: I will not provide a full explanation of all the steps, just a few remarks on
    the important points. You can find the complete solution code on GitHub, for both
    Python and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Your challenge is to write a controller for the **turtlesim** node. So far,
    we’ve just used simple and basic numbers to publish and subscribe to topics. With
    this, you can practice as if you were working on a real robot.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal is simple: we want to make the turtle move in a circle. On top of
    this, we also want to modify the velocity of the turtle, whether it’s on the right
    or left of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the *X* coordinate of a turtle on the screen, you can subscribe to the
    **pose** topic for that turtle. Then, finding the middle of the screen is easy:
    the minimum *X* value on the left is **0**, and the maximum *X* value on the right
    is about **11**. We will assume that the *X* coordinate for the middle of the
    screen is **5.5**.'
  prefs: []
  type: TYPE_NORMAL
- en: You can then send a command velocity by publishing to the **cmd_vel** topic
    for the turtle. To make the turtle move in a circle, you just have to publish
    constant values for the linear *X* and angular *Z* velocities. Use **1.0** for
    both velocities if the turtle is on the left (*X* < 5.5), and **2.0** for both
    if the turtle is on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package (let’s name it `turtle_controller`). You can decide to
    create either a Python or C++ package. If you do both, make sure you give each
    a different name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside this package, create a new node named `turtle_controller`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the node’s constructor, add a publisher (command velocity) and a subscriber
    (pose).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is where it’s a bit different from before: instead of creating a timer
    and publishing from the timer callback, you can publish directly from the subscriber
    callback. The `turtlesim` node is constantly publishing on the `pose` topic. Publishing
    a command from the subscriber callback allows you to create some kind of closed-loop
    control. You can get the current *X* coordinate and send a different velocity
    command, depending on where the turtle is.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To test your code, create an executable out of your code. Then, run **turtlesim**
    in one Terminal and your node in another. You should see the turtle drawing a
    circle, with a different velocity depending on where the turtle is.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can find the complete code (for both Python and C++) and package organization
    on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the most important steps for the Python node. The code starts with
    all the required import lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import **Twist** from **geometry_msgs** and **Pose** from **turtlesim**.
    You can find those interfaces by running **turtlesim_node** and exploring topics
    with the **ros2 topic** and **ros2 interface** command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we create a class for our node, with a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we just create a publisher and a subscriber. There’s no timer
    as we plan to use the publisher directly from the subscriber callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is the subscriber callback. Whenever we receive a new **Pose** message,
    we create a new command (a **Twist** message). Then, depending on the current
    *X* coordinate of the turtle, we give different values for the velocity. Finally,
    we publish the new velocity command.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for this challenge. It can be a bit challenging to understand how
    to start, but in the end, you can see that there is not so much code to write.
    I encourage you to come back to this challenge in a few days and try again without
    looking at the solution. This way, you can check if you understood the concept
    of topics correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you worked on ROS 2 topics.
  prefs: []
  type: TYPE_NORMAL
- en: Topics allow nodes to communicate with each other using a publish/subscribe
    mechanism. Topics are made for unidirectional data streams and are anonymous.
  prefs: []
  type: TYPE_NORMAL
- en: You can write topic publishers and subscribers directly in your nodes by using
    **rclpy** for Python and **rclcpp** for C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a publisher, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, check what topic name and interface you must send. Import the interface
    into the code and create a publisher in the node’s constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To publish, you must create a message, fill in the different fields, and publish
    the message with your publisher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can potentially publish a message from anywhere in the code. A common structure
    is to add a timer and publish from the timer callback. If it makes sense, you
    can also publish from a subscriber callback directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a subscriber, you must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: As for the publisher, you need to know what name and interface to receive. Import
    the interface and create a subscriber in the node’s constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When creating the subscriber, you will need to specify a callback function.
    It’s in this callback function that you can receive and process incoming messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you create a publisher or subscriber for a new topic and no interface matches
    your needs, you might need to create a custom interface. In this case, you must
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create and configure a new package dedicated to interfaces for your robot or
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your topic interface inside the package and build the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you can use this custom interface in your publishers/subscribers, just
    like any other interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To try a publisher or a subscriber, simply build the package where the node
    is, source the environment, and run the node. You can then use the **ros2** command-line
    tools, as well as **rqt_graph**, to introspect your application and solve potential
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: After topics, the next logical step is to learn about ROS 2 services. This is
    what we will cover in the following chapter.
  prefs: []
  type: TYPE_NORMAL
