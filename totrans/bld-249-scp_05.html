<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Acting on Frame Changes</h1></div></div></div><p>Besides the many places we have encountered where Python can be used in Blender, we will now look at scripts that may be used to act on certain events. These scripts come in two flavors—<strong>script links</strong><a class="indexterm" id="id328"/> and <strong>space</strong> <strong>handlers</strong>.<a class="indexterm" id="id329"/>
</p><p>
<strong>Script links</strong> are scripts that may be associated with Blender objects (<code class="literal">Meshes</code>, <code class="literal">Cameras</code>, and so on, but also <code class="literal">Scenes</code> and <code class="literal">World</code> objects) and that can be set up to run automatically on the following occasions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Just before rendering a frame</li><li class="listitem" style="list-style-type: disc">Just after rendering a frame</li><li class="listitem" style="list-style-type: disc">When a frame is changed</li><li class="listitem" style="list-style-type: disc">When an object is updated</li><li class="listitem" style="list-style-type: disc">When the object data is updated</li></ul></div><p>Scene objects may have script links associated with them that may be invoked on two additional occasions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On loading a <code class="literal">.blend</code> file</li><li class="listitem" style="list-style-type: disc">On saving a <code class="literal">.blend</code> file</li></ul></div><p>Space handlers are Python scripts that are invoked each time the 3D view window is redrawn or a key or mouse action is detected. Their primary use is to extend the capabilities of Blender's user interface.</p><p>In this chapter, you will learn:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What script links and space handlers are</li><li class="listitem" style="list-style-type: disc">How to perform activities on each frame change in an animation</li><li class="listitem" style="list-style-type: disc">How to associate additional information with an object</li><li class="listitem" style="list-style-type: disc">How to make an object appear or disappear by changing its layout or changing its transparency</li><li class="listitem" style="list-style-type: disc">How to implement a scheme to associate a different mesh with an object on each frame</li><li class="listitem" style="list-style-type: disc">How to augment the functionality of the 3D View</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Animating the visibility of objects</h1></div></div></div><a class="indexterm" id="id330"/><p>An often recurring issue in making an animation is the wish to make an object disappear or fade away at a certain frame, either for the sake of the effect itself or to replace the object by another one to achieve some dramatic impact (such as an explosion or a bunny rabbit changing into a ball).</p><p>There are many ways to engineer these effects, and most of them are not specifically tied to script links reacting on a frame change (many can simply be keyed as well). Nevertheless, we will look at two techniques that may easily be adapted to all sorts of situations, even ones that are not easily keyed. For example, we demand some specific behavior of a parameter that is easy to formulate in an expression but awkward to catch in an IPO.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Fading a material</h2></div></div></div><a class="indexterm" id="id331"/><p>Our first example will change the <strong>diffuse</strong> <strong>color</strong> of a material. It would be just as simple to change the transparency, but it is easier to see changes in diffuse color in illustrations.</p><p>Our goal is to fade the diffuse color from black to white and back again, spaced over a period of two seconds. We therefore define a function <code class="literal">setcolor()</code><a class="indexterm" id="id332"/> that takes a material and changes its diffuse color (the <code class="literal">rgbColor</code> attribute<a class="indexterm" id="id333"/>). It assumes a frame rate of 25 frames per second and, therefore, the first line fetches the current frame number and performs a <em>modulo</em> operation to determine what fraction of the current whole second is elapsed.</p><p>The highlighted line in the following code snippet determines whether we are in an odd or even second. If we are in an even second, we ramp up the diffuse color to white so we just keep our computed fraction. If we are in an odd second, we tone down the diffuse color to black so we subtract the fraction from the maximum possible value (<code class="literal">25</code>). Finally, we scale our value to lie between <code class="literal">0</code> and <code class="literal">1</code> and assign it to all three color components to obtain a shade of gray:</p><div><pre class="programlisting">import Blender

def setcolor(mat):
   s = Blender.Get('curframe')%25
   <strong>if int(Blender.Get('curframe')/25.0)%2 == 0:</strong>
      c = s
   else:
      c = 25-s
   c /= 25.0
   mat.rgbCol = [c,c,c]
   
if Blender.bylink and Blender.event == 'FrameChanged':
   setcolor(Blender.link)</pre></div><p>The script ends with an important check: <code class="literal">Blender.bylink</code> is <code class="literal">True</code> only if this script is called as a script handler and in that case <code class="literal">Blender.event</code> holds the event type. We only want to act on frame changes so that is what we check for here. If these conditions are satisfied, we pass <code class="literal">Blender.link</code> to our <code class="literal">setcolor()</code> function as it holds the object our <code class="literal">scriptlink</code> script is associated with—in this case that will be a <code class="literal">Material</code> object. (This script is available as <code class="literal">MaterialScriptLink.py</code> in <code class="literal">scriptlinks.blend</code>.)</p><a class="indexterm" id="id334"/><p>The next thing on our list is to associate the script with the object whose material we want to change. We therefore select the object and in the <strong>Buttons</strong> <strong>Window</strong> we select the <strong>Script</strong> <strong>panel</strong>. In the <strong>Scriptlinks</strong> tab, we enable script links and select the <strong>MaterialScriptLinks</strong> button. (If there is no <strong>MaterialScriptLinks</strong> button then the selected object has no material assigned to it. Make sure it has.) There should now be a label <strong>Select</strong> <strong>Script</strong> <strong>link</strong> visible with a <strong>New</strong> button. Clicking on <strong>New</strong> will show a dropdown with available script links (files in the text editor). In this case, we will select <code class="literal">MaterialScriptLink.py</code> and we are done. We can now test our script link by changing the frame in the 3D view (with the arrow keys). The color of our object should change with the changing frame number. (If the color doesn't seem to change, check whether solid or shaded viewing is on in the 3D view.)</p><div><img alt="Fading a material" src="img/0400-05-01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Changing layers</h2></div></div></div><a class="indexterm" id="id335"/><p>If we want to change the <strong>visibility</strong> of an object, changing the layer(s) it is assigned to is a more general and powerful technique than changing material properties. Changing its assigned layer has, for instance, the advantage that we can make the object completely invisible for lamps that are configured to illuminate only certain layers and many aspects of an animation (for example, deflection of particles by force fields) may be limited to certain layers as well. Also, changing layers is not limited to objects with associated materials. You can just as easily change the layer of a <code class="literal">Lamp</code> or <code class="literal">Camera</code>.</p><p>For our next example, we want to assign an object to layer 1 if the number of elapsed seconds is even and to layer 2 if the number of seconds is odd. The script to implement this is very similar to our material changing script. The real work is done by the function <code class="literal">setlayer()</code>. The first line calculates the layer the object should be on in the current frame and the next line (highlighted) assigns the list of layer indices (consisting of a single layer in this case) to the <code class="literal">layers</code> attribute<a class="indexterm" id="id336"/> of the object. The final two lines of the <code class="literal">setlayer()</code> function<a class="indexterm" id="id337"/> ensure that the layer's change is actually visible in Blender.</p><div><pre class="programlisting">import Blender

def setlayer(ob):
   layer = 1+int(Blender.Get('curframe')/25.0)%2
   <strong>ob.layers = [ layer ]</strong>
   ob.makeDisplayList()
   Blender.Window.RedrawAll()

if Blender.bylink and Blender.event == 'FrameChanged':
   setlayer(Blender.link)</pre></div><a class="indexterm" id="id338"/><p>As in our previous script, the final lines of our script check whether we are called as a script link and on a frame change event, and if so, pass the associated object to the <code class="literal">setlayer()</code> function. (The script is available as <code class="literal">OddEvenScriptlink.py</code> in <code class="literal">scriptlinks.blend</code>.)</p><p>All that is left to do is to assign the script as a <code class="literal">scriptlink</code> to a selected object. Again, this is accomplished in the <strong>Buttons</strong> <strong>Window</strong> | <strong>Script</strong> <strong>panel</strong> by clicking on <strong>Enabling</strong> <strong>Script</strong> <strong>Links</strong> in the <strong>Scriptlinks</strong> tab (if necessary, it might still be selected because of our previous example. It is a global choice, that is, it is enabled or disabled for all objects). This time, we select the object <code class="literal">scriptlinks</code> instead of the material <code class="literal">scriptlinks</code> and click on <strong>New</strong> to select <code class="literal">OddEvenScriptlink.py</code> from the dropdown.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Countdown—animating a timer with script links</h1></div></div></div><a class="indexterm" id="id339"/><p>One of the possibilities of using a script link that acts on frame changes is the ability to modify the actual mesh either by changing the vertices of a <code class="literal">Mesh</code> object or by associating a completely different mesh with a Blender object. This is not possible when using IPOs as these are limited to shape keys that interpolate between predefined shapes with the same mesh topology (the same number of vertices connected in the same way). The same is true for curves and text objects.</p><p>One application of that technique is to implement a <code class="literal">counter</code> object that will display the number of seconds since the start of the animation. This is accomplished by changing the text of a <code class="literal">Text3d</code> object by way of its <code class="literal">setText()</code> method<a class="indexterm" id="id340"/>. The <code class="literal">setcounter()</code> function<a class="indexterm" id="id341"/> in the following code does exactly that together with the necessary actions to update Blender's display. (The script is available as <code class="literal">CounterScriptLink.py</code> in <code class="literal">scriptlinks.blend</code>.)</p><div><pre class="programlisting">import Blender

objectname='Counter'
scriptname='CounterScriptLink.py'

def setcounter(counterob):
   seconds = int(Blender.Get('curframe')/25.0)+1
   counterob.getData().setText(str(seconds))
   counterob.makeDisplayList()
   Blender.Window.RedrawAll()

<strong>if Blender.bylink:</strong>
   setcounter(Blender.link)
else:
   countertxt    = Blender.Text3d.New(objectname)
   scn           = Blender.Scene.GetCurrent()
   counterob     = scn.objects.new(countertxt)
   setcounter(counterob)
 <strong>  counterob.clearScriptLinks([scriptname])</strong>
 <strong>  counterob.addScriptLink(scriptname,'FrameChanged')</strong>
</pre></div><a class="indexterm" id="id342"/><p>This script may be associated as a script link with any <code class="literal">Text3d</code> object as shown before. However, if run with <em>Alt</em> <em>+</em> <em>P</em> from the text editor it will create a new <code class="literal">Text3d</code> object and will associate itself to this object as a script link. The highlighted lines show how we check for this just like in the previous scripts, but in this case we take some action when not called as a script link as well (the <code class="literal">else</code> clause). The final two highlighted lines show how we associate the script with the newly created object. First, we remove (clear) any script links with the same name that might have been associated earlier. This is done to prevent associating the same script link more than once, which is valid but hardly useful. Next, we add the script as a script link that will be called when a frame change occurs. The screenshot shows the 3D view with a frame from the animation together with the <strong>Buttons</strong> <strong>window</strong> (top-left) that lists the association of the script link with the object.</p><div><img alt="Countdown—animating a timer with script links" src="img/0400-05-02.jpg"/></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>Note that although it is possible to <em>associate</em> a script link with a Blender object from within a Python script, script links must be <em>enabled</em> manually for them to actually run! (In the <strong>ScriptLinks</strong> tab.) There is no functionality in the Blender Python API to do this from a script.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>I'll keep an eye on you</h1></div></div></div><a class="indexterm" id="id343"/><a class="indexterm" id="id344"/><p>Sometimes, when working with a complex object, it is difficult to keep track of a relevant feature as it may be obscured by other parts of the geometry. In such a situation, it would be nice to highlight certain vertices in a way that keeps them visible, no matter the orientation, and independent of the <em>edit</em> mode.</p><p>
<strong>Space</strong> <strong>handlers</strong> provide us with a way to perform actions each time the 3D view window is redrawn or a key or mouse action is detected. These actions may include drawing inside the 3D view area as well, so we will be able to add <strong>highlights</strong> at any position we like.</p><p>How do we determine which vertices we would like to highlight? Blender already provides us with a uniform way to group collections of vertices as vertex groups so all we have to do is let the user indicate which vertex group he would like to highlight. We then store the name of this selected vertex group as an object property. Object properties are designed to be used in the game engine but there is no reason why we shouldn't reuse them as a way to persistently store our choice of vertex group.</p><p>So again, we have a script that will be called in two ways: as a space handler (that is, each time the 3D view window is redrawn to highlight our vertices) or by running it from the text editor with <em>Alt + P</em> to prompt the user to choose a vertex group to highlight.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Code outline: AuraSpaceHandler.py</h2></div></div></div><a class="indexterm" id="id345"/><a class="indexterm" id="id346"/><p>The following outline shows which steps we will take in each situation:</p><div><ol class="orderedlist arabic"><li class="listitem">Get active object and mesh.</li><li class="listitem">If running standalone:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get list of vertex groups</li><li class="listitem" style="list-style-type: disc">Prompt user for choice</li><li class="listitem" style="list-style-type: disc">Store choice as property of object</li></ul></div></li><li class="listitem">Else:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get the property that holds the vertex group</li><li class="listitem" style="list-style-type: disc">Get a list of vertex coordinates</li><li class="listitem" style="list-style-type: disc">For each vertex:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">draw a small disk</li></ul></div></li></ul></div></li></ol></div><p>The resulting code is available as <code class="literal">AuraSpaceHandler.py</code> in <code class="literal">scriptlinks.blend</code>:</p><div><pre class="programlisting"># SPACEHANDLER.VIEW3D.DRAW</pre></div><p>It starts with a line of comment that is essential, as it signals to Blender that this is a space handler script that can be associated with the 3D view (no other area can have space handlers associated at present) and should be called on a <code class="literal">redraw</code> event<a class="indexterm" id="id347"/>.</p><div><pre class="programlisting">import Blender
from Blender import *

scn = Scene.GetCurrent()
ob  = scn.objects.active
if ob.type == 'Mesh':
   me = ob.getData(mesh = True)
   <strong>if Blender.bylink:</strong>
      p=ob.getProperty('Highlight')
      vlist = me.getVertsFromGroup(p.getData())
      matrix = ob.matrix
      drawAuras([me.verts[vi].co*matrix for vi in vlist],p.getData())
   <strong>else:</strong>	  
      groups = ['Select vertexgroup to highlight%t']
      groups.extend(me.getVertGroupNames())
      result = Draw.PupMenu( '|'.join(groups) )
      if result&gt;0:
         try:
            p=ob.getProperty('Highlight')
            p.setData(groups[result])
         except:
            ob.addProperty('Highlight',groups[result])</pre></div><p>The script proper then proceeds to retrieve the active object from the current scene and gets the object's mesh if it is a <code class="literal">Mesh</code>. At the highlighted line, we check if we are running as space handler and if so, we fetch the property that we named <code class="literal">Highlight</code>. The data of this property is the name of the vertex group that we want to highlight. We proceed by getting a list of all vertices in this vertex group and by getting the matrix of the object. We need this because vertex locations are stored relative to the object's matrix. We then construct a list of vertex locations and pass this along with the name of the vertex group to the <code class="literal">drawAuras()</code> function that will take care of the actual drawing.<a class="indexterm" id="id348"/>
</p><p>The second highlighted line marks the beginning of the code that will be executed when we run the script from the text editor. It creates a string consisting of the names of all vertex groups associated with the active object separated by pipe characters (<code class="literal">|</code>) and prepended by a suitable title. This string is passed to <code class="literal">PopMenu()</code> which will display the menu, and will either return with the user's choice or with <code class="literal">-1</code>, if nothing was chosen.</p><p>If there was a vertex group chosen, we try to retrieve the <code class="literal">Highlight</code> property. If this succeeds we set its data to the name of the chosen vertex group. If the property did not yet exist, we add a new one with the name <code class="literal">Highlight</code> and again with the name of the chosen vertex group as data.</p><p>Next we have to make sure that <code class="literal">scriptlinks</code> are enabled (<strong>Buttons</strong> <strong>window</strong> | <strong>Scripts</strong> <strong>panel</strong> | <strong>Scriptlinks</strong>. Click on <strong>enable</strong> <strong>scriptlinks</strong> if not yet selected.). Note that to Blender it makes no difference whether we are dealing with space handlers or script links as far as enabling them is concerned.</p><p>The final step in using our space handler is associating it with the 3D view. To do this toggle the entry <code class="literal">Draw: AuraSpaceHandler.py</code> in the view (<strong>Space</strong> <strong>Handler</strong> <strong>Scripts</strong> menu of the 3D view).</p><div><img alt="Code outline: AuraSpaceHandler.py" src="img/0400-05-03.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Using themes</h2></div></div></div><a class="indexterm" id="id350"/><p>The code we haven't seen yet deals with the actual drawing of the highlights and the name of the vertex group to identify what we are highlighting. It starts off by determining the colors we will use for the highlights and the text by retrieving these from the current theme. This way the user can customize these colors in a convenient way from the <strong>User</strong> <strong>Preferences</strong> window:</p><div><pre class="programlisting">theme     = Window.Theme.Get()[0]
textcolor = [float(v)/255 for v in theme.get(Window.Types.VIEW3D ).text_hi[:3]]
color     = [float(v)/255 for v intheme.get(Window.Types.VIEW3D).active[:3]]</pre></div><p>The first line will retrieve a list of <strong>themes</strong> that are present. The first one is the active theme. From this theme we retrieve the <code class="literal">VIEW3D</code> theme space and its <code class="literal">text_hi</code> attribute<a class="indexterm" id="id351"/> is a list of four integers representing a RGBA color. The list comprehension discards the alpha component and converts it to a list of three floats in the range [0, 1] that we will use as our text color. Likewise, we construct the color of the highlights from the <code class="literal">active</code> attribute.</p><a class="indexterm" id="id352"/><p>Our next challenge is to draw a disk-shaped highlight at a specified location. As the size of the disk is quite small (it can be adjusted by altering the <code class="literal">size</code> variable), we can approximate it well enough by an octagonal shape. We store the list of x, y coordinates of such an octagon in the <code class="literal">diskvertices</code> list:</p><div><pre class="programlisting">size=0.2
diskvertices=[( 0.0, 1.0),( 0.7, 0.7),( 1.0, 0.0),( 0.7,-0.7),( 0.0,-1.0),(-0.7,-0.7),(-1.0, 0.0),(-0.7, 0.7)]
         
def drawDisk(loc):
   <strong>BGL.glBegin</strong>(BGL.GL_POLYGON)
   for x,y in diskvertices:
      <strong>BGL.glVertex3f</strong>(loc[0]+x*size,loc[1]+y*size,loc[2])
<strong>   BGL.glEnd()</strong>
</pre></div><p>The actual drawing of the octagon depends heavily on the functions provided by Blender's <code class="literal">BGL</code> module (highlighted in the previous code). We start by stating that we will be drawing a polygon and then add a vertex for each tuple in the <code class="literal">diskvertices</code> list. The location passed to <code class="literal">drawDisk()</code> will be the center and the vertices will all lie on a circle with a radius equal to <code class="literal">size</code>. When we call the <code class="literal">glEnd()</code> function, the filled-in polygon will be drawn in the current color.</p><p>You might wonder how these drawing functions know how to translate locations in 3D to coordinates on the screen and there is indeed more here than meets the eye as we will see in the next section of code. The necessary function calls to inform the graphics system how to convert 3D coordinates to screen coordinates is not implemented in the <code class="literal">drawDisk()</code> function<a class="indexterm" id="id353"/> (preceding code snippet). This is because calculating this information for each disk separately would incur an unnecessary performance penalty as this information is the same for each disk we draw.</p><p>We therefore define a function, <code class="literal">drawAuras()</code>, which will take a list of locations and a <code class="literal">groupname</code> argument (a string). It will calculate the transformation parameters, call <code class="literal">drawDisk()</code> for each location in the list, and will then add the group name as an on-screen label at approximately just right of the center the highlights. Blender's <code class="literal">Window</code> module provides us with the <code class="literal">GetPerspMatrix()</code> function <a class="indexterm" id="id354"/>that will retrieve the matrix that will correctly convert a point in 3D space to a point on the screen. This 4 by 4 matrix is a Python object that will have to be converted to a single list of floats that can be used by the graphics system. The highlighted lines in the following code take care of that. The next three lines reset the projection mode and tell the graphics system to use our suitably converted perspective matrix to calculate screen coordinates. Note that changing these projection modes and other graphics settings does not affect how Blender itself draws things on screen, as these settings are saved before calling our script handler and restored afterward:</p><div><pre class="programlisting">def drawAuras(locations,groupname):
   viewMatrix = Window.GetPerspMatrix()
<strong>   viewBuff = [viewMatrix[i][j] for i in xrange(4) for j in xrange(4)]</strong>
<strong>   viewBuff = BGL.Buffer(BGL.GL_FLOAT, 16, viewBuff)</strong>

   BGL.glLoadIdentity()
   BGL.glMatrixMode(BGL.GL_PROJECTION)
   BGL.glLoadMatrixf(viewBuff)

   BGL.glColor3f(*color)
   for loc in locations:
      drawDisk(loc)
   n=len(locations)
   if n&gt;0:
      BGL.glColor3f(*textcolor)
      x=sum([l[0] for l in locations])/n
      y=sum([l[1] for l in locations])/n
      z=sum([l[2] for l in locations])/n
      BGL.glRasterPos3f(x+2*size,y,z)
      Draw.Text(groupname,'small')</pre></div><p>With the preliminary calculations out of the way we can set the color we will draw our disks in with the <code class="literal">glColor3f()</code> function. As we stored the color as a list of three floats and the <code class="literal">glColor3f()</code> function takes three separate arguments, we unpack this list with the asterisk operator. Next, we call <code class="literal">drawDisk()</code> for each item in <code class="literal">locations</code>.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>
<strong>Blender OpenGL functions:</strong>
</p><p>The documentation of Blenders <code class="literal">BGL</code> module lists a large number of functions from the <strong>OpenGL</strong> library. Many of these functions come in a large number of variants that perform the same action but receive their arguments in different ways. For example, <code class="literal">BGL.glRasterPos3f()</code> is a close relation to <code class="literal">BGL.glRasterPos3fv()</code> that will take a list of three single-precision float values instead of three separate arguments. For more information, refer to the API documentation of the <code class="literal">Blender.BGL</code> and <code class="literal">Blender.Draw</code> modules and the OpenGL reference manual on <a class="ulink" href="http://www.opengl.org/sdk/docs/man/">http://www.opengl.org/sdk/docs/man/</a>.</p></div></div><p>If the number of highlights we have drawn is not zero, we set the drawing color to <code class="literal">textcolor</code> and then calculate the average coordinates of all the highlights. We then use the <code class="literal">glRasterPos3f()</code> function to set the starting position of the text that we want to draw to these average coordinates with some extra space added to the x-coordinate to offset the text a little to the right. Blender's <code class="literal">Draw.Text()</code> function will then draw the group name in a small font at the chosen location.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Revisiting mesh—making an impression</h1></div></div></div><p>Although <strong>softbody</strong> and <strong>cloth</strong> simulators that are available in Blender do an excellent job in many situations, sometimes you want to have more control over the way a mesh is deformed or simulate some specific behavior that is not quite covered by Blender's built-in simulators. This exercise shows how to calculate the deformation of a mesh that is touched, but not penetrated by another mesh. This is not meant to be physically accurate. The aim is to give believable results for solid things touching an easily deformable or gooey surface such as a finger taking a lick of butter or a wheel running through a soft shoulder.</p><p>The following illustration gives some impression of what is possible. The tracks are created by animating a rolling car tire on a subdivided plane:</p><div><img alt="Revisiting mesh—making an impression" src="img/0400-05-04.jpg"/></div><p>In the following part, we will refer to the object mesh being deformed as the source and the object, or objects, doing the deforming as targets. In a sense, this is much like a constraint and we might have implemented these deformations as pycontraints. However, that wouldn't be feasible because constraints get evaluated each time the source or targets move; thereby causing the user interface to come to a grinding halt as calculating the intersections and the resulting deformation of meshes is computationally intensive. Therefore, we choose an approach where we calculate and cache the results each time the frame is changed.</p><p>Our script will have to serve several functions, it must:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calculate and cache the deformations on each frame change</li><li class="listitem" style="list-style-type: disc">Change vertex coordinates when cached information is present</li></ul></div><p>And when run standalone, the script should:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Save or restore the original mesh</li><li class="listitem" style="list-style-type: disc">Prompt the user for targets</li><li class="listitem" style="list-style-type: disc">Associate itself as a script link with the source object</li><li class="listitem" style="list-style-type: disc">Possibly remove itself as a script link</li></ul></div><p>An important consideration in designing the script is how we will store or cache the original mesh and the intermediate, deformed meshes. Because we will not change the topology of the mesh (that is, the way vertices are connected to each other), but just the vertex coordinates, it will be sufficient to store just those coordinates. That leaves us with the question: where to store this information.</p><p>If we do not want to write our own persistent storage solution, we have two options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use Blender's registry</li><li class="listitem" style="list-style-type: disc">Associate the data with the source object as a property</li></ul></div><p>Blender's <strong>registry</strong> is easy to use but we must have some method of associating the data with an object because it is possible that the user might want to associate more than one object with an impression calculation. We could use the name of the object as a key, but if the user would change that name, we would lose the reference with the stored information while the script link functionality would still be there. This would leave the user responsible for removing the stored data if the name of the object was changed.</p><p>Associating all data as a <strong>property</strong> would not suffer from any renaming and the data would be cleared when the object is deleted, but the types of data that may be stored in a property are limited to an integer, a floating point value, or a string. There are ways to convert arbitrary data to strings by using Python's standard <code class="literal">pickle</code> module, but, unfortunately, this scenario is thwarted by two problems: </p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Vertex coordinates in Blender are <code class="literal">Vector</code> instances and these do not support the pickle protocol</li><li class="listitem" style="list-style-type: disc">The size of <strong>string properties</strong> is limited to 127 characters and that is far too small to store even a single frame of vertex coordinates for a moderately sized mesh</li></ul></div><p>Despite the drawbacks of using the registry, we will use it to devise two functions—one to store vertex coordinates for a given frame number and one to retrieve that data and apply it to the vertices of the mesh. First, we define a utility function <code class="literal">ckey()</code> that will return a key to use with the registry functions based on the name of the object whose mesh data we want to cache:</p><div><pre class="programlisting">def ckey(ob):
   return meshcache+ob.name</pre></div><div><div><h3 class="title"><a id="note19"/>Note</h3><p>
<strong>Not all registries are the same</strong>
</p><p>Do not confuse Blender's registry with the Windows registry. Both serve the similar purpose of providing a persistent storage for all sorts of data, but both are distinct entities. The actual data for Blender registry items that are written to disk resides in <code class="literal">.blender/scripts/bpydata/config/</code> by default and this location may be altered by setting the <code class="literal">datadir</code> property with <code class="literal">Blender.Set()</code>.</p></div></div><p>Our <code class="literal">storemesh()</code> function will take an object and a frame number as arguments. Its first action is to extract just the vertex coordinates from the mesh data associated with the object. Next, it retrieves any data stored in Blender's registry for the object that we are dealing with and we pass the extra <code class="literal">True</code> parameter to indicate that if there is no data present in memory, <code class="literal">GetKey()</code> should check for it on disk. If there is no data stored for our object whatsoever, <code class="literal">GetKey()</code> will return <code class="literal">None</code>, in which case we initialize our cache to an empty dictionary.</p><p>Subsequently, we store our mesh coordinates in this dictionary indexed by the frame number (highlighted in the next code snippet). We convert this integer frame number to a string to be used as the actual key because Blender's <code class="literal">SetKey()</code> function assumes all of the keys to be strings when saving registry data to disk, and will raise an exception if it encounters an integer. The final line calls <code class="literal">SetKey()</code> again with an extra <code class="literal">True</code> argument to indicate that we want the data to be stored to disk as well.</p><div><pre class="programlisting">def storemesh(ob,frame):
   coords = [(v.co.x,v.co.y,v.co.z) for v in ob.getData().verts]
   d=Blender.Registry.GetKey(ckey(ob),True)
   if d == None: d={}
<strong>   d[str(frame)]=coords</strong>
   Blender.Registry.SetKey(ckey(ob),d,True)</pre></div><p>The <code class="literal">retrievemesh()</code> function will take an object and a frame number as arguments. If it finds cached data for the given object and frame, it will assign the stored vertex coordinates to vertices in the mesh. We first define two new exceptions to indicate some specific error conditions <code class="literal">retrievemesh()</code> may encounter:</p><div><pre class="programlisting">class NoSuchProperty(RuntimeError): pass;
class NoFrameCached(RuntimeError): pass;</pre></div><p>
<code class="literal">retrievemesh()</code> will raise the <code class="literal">NoSuchProperty</code> exception if the object has no associated cached mesh data and a <code class="literal">NoFrameCached</code> exception if the data is present but not for the indicated frame. The highlighted line in the next code deserves some attention. We fetch the associated mesh data of the object with <code class="literal">mesh=True</code>. This will yield a wrapped mesh, not a copy, so any vertex data we access or alter will refer to the actual data. Also, we encounter Python's built-in <code class="literal">zip()</code> function that will take two lists and returns a list consisting of tuples of two elements, one from each list. It effectively lets us traverse two lists in parallel. In our case, these lists are a list of vertices and a list of coordinates and we simply convert these coordinates to vectors and assign them to the co-attribute of each vertex:</p><div><pre class="programlisting">def retrievemesh(ob,frame):
   d=Blender.Registry.GetKey(ckey(ob),True)
   if d == None:
      raise NoSuchProperty("no property %s for object %s"
            %(meshcache,ob.name))
   try:
      coords = d[str(frame)]
   except KeyError:
      raise NoFrameCached("frame %d not cached on object %s"
             %(frame,ob.name))
<strong>   for v,c in zip(ob.getData(mesh=True).verts,coords):</strong>
      v.co = Blender.Mathutils.Vector(c)</pre></div><p>To complete our set of cache functions we define a function <code class="literal">clearcache()</code> that will attempt to remove the registry data associated with our object. The <code class="literal">try … except …</code> clause will ensure that the absence of stored data is silently ignored: </p><div><pre class="programlisting">def clearcache(ob):
   try:
      Blender.Registry.RemoveKey(ckey(ob))
   except:
      pass</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec61"/>The user interface</h2></div></div></div><p>Our script will not only be used as a script link associated with an object but it will also be used standalone (by pressing <em>Alt + P</em> in the text editor for example) to provide the user with the means to identify a target that will make the impression to clear the cache, and to associate the script link with the active object. If used in this fashion, it will present the end user with a few pop-up menus, both shown in the screenshots. The first one shows the possible actions:</p><div><img alt="The user interface" src="img/0400-05-05.jpg"/></div><p>The second screenshot shows the pop up offered to select an object from a list of <code class="literal">Mesh</code> objects that the user can choose to make an impression:</p><div><img alt="The user interface" src="img/0400-05-06.jpg"/></div><p>We first define a utility function that will be used by the pop-up menu that will present the user with a choice of <code class="literal">Mesh</code> objects to be used as a target to make an impression. <code class="literal">getmeshobjects()</code><a class="indexterm" id="id355"/> will take a <code class="literal">scene</code> argument and will return a list of names of all <code class="literal">Mesh</code> objects. As depicted in the screenshot, the list of target objects includes the source object as well. Although this is legal, it is debatable whether this is very useful:</p><div><pre class="programlisting">def getmeshobjects(scene):
   return [ob.name for ob in scene.objects if ob.type=='Mesh']</pre></div><p>The menu itself is implemented by the <code class="literal">targetmenu()</code> function<a class="indexterm" id="id356"/> defined as follows:</p><div><pre class="programlisting">def targetmenu(ob):
   meshobjects=getmeshobjects(Blender.Scene.GetCurrent())
   menu='Select target%t|'+ "|".join(meshobjects)
   ret = Blender.Draw.PupMenu(menu)
<strong>   if ret&gt;0:</strong>
      try:
         p = ob.getProperty(impresstarget)
         p.setData(meshobjects[ret-1])
      except:
         ob.addProperty(impresstarget,meshobjects[ret-1])</pre></div><a class="indexterm" id="id357"/><p>It will fetch the list of all of the <code class="literal">Mesh</code> objects in the scene and present this list as a choice to the user by using Blender's <code class="literal">Draw.PupMenu()</code> function<a class="indexterm" id="id358"/>. If the user selects one of the menu entries (the return value will be positive and non-zero, see the highlighted line of the preceding code), it will store the name of this <code class="literal">Mesh</code> object as a property associated with our object. <code class="literal">impresstarget</code> is defined elsewhere as the name for the property. First, the code checks whether there already is such a property associated with the object by calling the <code class="literal">getProperty()</code> method<a class="indexterm" id="id359"/> and setting the properties data, if there is. If <code class="literal">getProperty()</code> raises an exception because the property does not yet exist, we then add the new property to the object and assign data to it with a single call to the <code class="literal">addProperty()</code> method<a class="indexterm" id="id360"/>.</p><p>The main user interface is defined in the top level of the script. It verifies that it is not running as a script link and then presents the user with a number of choices:</p><div><pre class="programlisting">if not Blender.bylink:
   ret = Blender.Draw.PupMenu('Impress scriptlink%t|Add/Replace' +'scriptlink|Clear cache|Remove' + 'all|New Target')
   active = Blender.Scene.GetCurrent().objects.active
   if ret &gt; 0:
      clearcache(active)
   if ret== 1:
      active.clearScriptLinks([scriptname])
      active.addScriptLink(scriptname,'FrameChanged')
      targetmenu(active)
   elif ret== 2:
      pass
   elif ret== 3:
      active.removeProperty(meshcache)
      active.clearScriptLinks([scriptname])
   elif ret== 4:
      targetmenu(active)</pre></div><p>Any valid choice will clear the cache (highlighted) and the subsequent checks perform the necessary actions associated with each individual choice: <strong>Add/Replace scriptlink</strong> will remove the script link, if it is already present, to prevent duplicates and then add it to the active object. It then presents the target menu to select a <code class="literal">Mesh</code> object to use to make an impression. As we already cleared the cache, the second choice, <strong>Clear cache</strong>, will do nothing specific, so we just pass. <strong>Remove All</strong> will try to remove the cache and attempt to dissociate itself as a script link and the final <strong>New target</strong> menu will present the target selection menu to allow the user to select a new target object without removing any cached results.</p><a class="indexterm" id="id361"/><p>If we <em>are</em> running as a script link we first check that we are acting on a <code class="literal">FrameChanged</code> event<a class="indexterm" id="id362"/> and then try to retrieve any stored vertex coordinates for the current frame (highlighted in the next code). If there is no previously stored data, we have to calculate the effects of the target object for this frame. We therefore get a list of target objects for the object under consideration by calling the utility function <code class="literal">gettargetobjects()</code><a class="indexterm" id="id363"/> (for now, a list of just one object will be returned) and for each object we calculate the effect on our mesh by calling <code class="literal">impress()</code>. Then, we store these possibly changed vertex coordinates and update the display list so that the Blender GUI knows how to display our altered mesh:</p><div><pre class="programlisting">elif Blender.event == 'FrameChanged':
   try:
<strong>      retrievemesh(Blender.link,Blender.Get('curframe'))</strong>
   except Exception as e: # we catch anything
      objects = gettargetobjects(Blender.link)
      for ob in objects:
         impress(Blender.link,ob)
      storemesh(Blender.link,Blender.Get('curframe'))
   Blender.link.makeDisplayList()</pre></div><p>That leaves us with the actual calculation of the impression of a target object on our mesh.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Calculating an impression</h2></div></div></div><a class="indexterm" id="id364"/><p>When determining the effect of a target object making an impression, we will approach this as follows:</p><p>For each vertex in the mesh receiving the impression:</p><div><ol class="orderedlist arabic"><li class="listitem">Determine if it is located inside the target object and if so:</li><li class="listitem">Set the location of the vertex to the location of the closest vertex on the object making the impression</li></ol></div><p>There are some important issues to address here. The location of a vertex in a mesh is stored relative to the object's transformation matrix. In other words, if we want to compare vertex coordinates in two different meshes, we have to transform each vertex by the transformation matrices of their respective objects before doing any comparison.</p><p>Also, a <code class="literal">Blender.Mesh</code> object has a <code class="literal">pointInside()</code> method<a class="indexterm" id="id365"/> that will return <code class="literal">True</code> if a given point is inside the mesh. This will, however, only work reliably on closed meshes so the user has to verify that the objects that will make the impression are in fact closed. (They may have interior bubbles but their surfaces must not contain edges that are not shared by exactly two faces. These so-called non-manifold edges can be selected in <em>edge</em> <em>select</em> mode by selecting <strong>Select | Non Manifold</strong> in the 3D view or pressing <em>Ctrl + Shift + Alt + M</em>.)</p><a class="indexterm" id="id366"/><p>Finally, moving vertices to the closest vertex on the target object may be quite inaccurate when the target mesh is rather coarse. Performance wise, however, it is good to have relatively few points—as our algorithm is rather inefficient because by first determining whether a point is inside a mesh and then separately calculating the closest vertex duplicates a lot of calculations. However, as the performance is acceptable even for meshes consisting of hundreds of points, we stick with our approach, as it keeps our code simple and saves us having to write and test very intricate code.</p><p>The implementation starts with a function to return the distance to and the coordinates of the vertex closest to a given point <code class="literal">pt</code>:</p><div><pre class="programlisting">def closest(me,pt):
   min = None
   vm = None
   for v in me.verts:
      d=(v.co-pt).length
      if min == None or d&lt;min:
         min = d
         vm = v.co
   return min,vm</pre></div><p>The <code class="literal">impress()</code> function<a class="indexterm" id="id367"/> itself takes a source and a target object as arguments and will modify the mesh data of the source object if the target mesh makes an impression. The first thing that it does is retrieve the transformation matrices of the objects. As indicated before, these will be needed to transform the coordinates of the vertices so that they might be compared. We also retrieve the inverse matrix of the source object. This will be needed to transform coordinates back to the space of the source object.</p><p>The highlighted line retrieves the wrapped mesh data of the source object. We need wrapped data because we might want to change some of the vertex coordinates. The next two lines retrieve copies of the mesh data. We also need copies because the transformation we will perform may not affect the actual mesh data. Instead of copying we could have left out the <code class="literal">mesh=True</code> argument, which would have given us a reference to an <code class="literal">Nmesh</code> object instead of a <code class="literal">Mesh</code> object. However, <code class="literal">Nmesh</code> objects are not wrapped and are marked as deprecated. Also, they lack the <code class="literal">pointInside()</code> method we need, so we opt for copying the meshes ourselves.</p><p>Next, we transform these mesh copies by their respective object transform matrices. Using the <code class="literal">transform()</code> method of these meshes saves us from iterating over each vertex and multiplying the vertex coordinates by the transform matrix ourselves, and this method is probably a bit faster as well as <code class="literal">transform()</code> is completely implemented in C:</p><div><pre class="programlisting">from copy import copy

def impress(source,target):
   srcmat=source.getMatrix()
   srcinv=source.getInverseMatrix()
   tgtmat=target.getMatrix()
   orgsrc=source.getData(mesh=True)
   mesrc=copy(source.getData(mesh=True))
   metgt=copy(target.getData(mesh=True))
   
   mesrc.transform(srcmat)
   metgt.transform(tgtmat)
   
   for v in mesrc.verts:
      if metgt.pointInside(v.co):
         d,pt = closest(metgt,v.co)
         orgsrc.verts[v.index].co=pt*srcinv</pre></div><a class="indexterm" id="id368"/><p>The final part of the <code class="literal">impress()</code> function loops over all of the vertices in the transformed source mesh and checks if the vertex lies enclosed within the (transformed) target mesh. If they are, it determines which vertex on the target mesh is closest and sets the affected vertex in the original mesh to these coordinates.</p><p>This original mesh is not transformed, so we have to transform this closest point back to the object space of the source object by multiplying the coordinates with the inverse transformation matrix. Because transformation calculations are expensive, modifying the transformed mesh and transforming the complete mesh back at the end may take a considerate amount of time. Keeping a reference to the untransformed mesh and just transforming back individual points may, therefore, be preferable when only relatively few vertices are affected by the impression. The full script is available as <code class="literal">ImpressScriptLink.py</code> in <code class="literal">scriptlinks.blend</code>. The following illustration shows what is possible. Here we made a small animation of a ball (an icosphere) rolling along and descending into the mud (a subdivided plane).</p><div><img alt="Calculating an impression" src="img/0400-05-07.jpg"/></div><p>When working with the script it is important to keep in mind that when the impression is calculated, none of the vertices of the mesh that receives the impression should be located inside the target before it moves. If that happens it is possible for a vertex to be swept along with the movement of the target, distorting the source mesh along the way. For example, to make the illustration of the wheel track in the mud, we animate a rolling <a class="indexterm" id="id369"/>wheel along a path, calculating the impressions it makes at every frame. In the first frame that we animate we should make sure that the wheel is not touching the floor plane that will be distorted because if a vertex of the floor plane is inside the wheel and close to the inner rim, it will be moved to the closest vertex on that rim. If the wheel rolls slowly, this vertex will stay close to that inner rim and will thereby be effectively glued to that moving inner rim, ripping up the floor plane in the process. The same disruptive process may occur if the target object is very small compared to the source mesh or moving very fast. In these circumstances a vertex may penetrate the target object so fast that the closest vertex will not be on the leading surface making the impression but somewhere else in the target which will result in vertices being pulled outward instead of pushed inward. In the illustration of the rolling tractor tire, we carefully positioned the tire at frame one to sit just to the right of the subdivided plane before we key framed the rolling motion towards the left. The picture shown is taken at frame 171 without any smoothing or materials applied to the plane.</p><div><img alt="Calculating an impression" src="img/0400-05-08.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Summary</h1></div></div></div><p>In this chapter, we learned how to link change to the progress of the animation frames and how to associate state information with an object. We also saw how to change layers, for example to render an object invisible. Specifically we saw:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What script links and space handlers are</li><li class="listitem" style="list-style-type: disc">How to perform activities on each frame change in an animation</li><li class="listitem" style="list-style-type: disc">How to associate additional information with an object</li><li class="listitem" style="list-style-type: disc">How to make an object appear or disappear by changing lay or changing its transparency</li><li class="listitem" style="list-style-type: disc">How to implement a scheme to associate a different mesh with an object on each frame</li><li class="listitem" style="list-style-type: disc">How to augment the functionality of the 3DView</li></ul></div><p>Next up: adding shape keys and IPOs.</p></div></body></html>