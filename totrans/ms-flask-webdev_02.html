<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Creating Models with SQLAlchemy</h1>
                </header>
            
            <article>
                
<p>As we saw in the last chapter, models are a means of abstracting and providing a common interface to access data. In most web applications, data is stored and retrieved from a <strong>relational database management system</strong> (<strong>RDBMS</strong>), which is a database that holds data in a tabular format with rows and columns and is able to implement a relational model with data across tables. Some examples include MySQL, Postgres, Oracle, and MSSQL.</p>
<p>In order to create models on top of our database, we will use a Python package named <strong>SQLAlchemy</strong>. SQLAlchemy is a database API at its lowest level, and performs <strong>object relational mapping</strong> at its highest level. An <span><strong>ORM</strong> (<strong>object relational mapper</strong>) is a tool that allows developers to store and retrieve data using object-oriented approaches and solve object-relational mismatches—a set of conceptual and technical difficulties that are often encountered when a relational database management system is being used by a program that is written in an object-oriented programming language. Relational and object-oriented models are so different that additional code and functionalities are required to make them work together efficiently.</span> This creates a virtual object database and converts data between the large number of types in databases into the mix of types and objects in Python. Also, a programming language, such as Python, allows you to have different objects that hold references to each other, and to get and set their attributes. An ORM, such as SQLAlchemy, helps translate these when inserting them into a traditional database.</p>
<p>In order to tie SQLAlchemy into our application context, we will use <strong>Flask SQLAlchemy</strong>. Flask SQLAlchemy is a convenience layer on top of SQLAlchemy that provides useful defaults and Flask-specific functions. If you are already familiar with SQLAlchemy, then you are free to use it without Flask SQLAlchemy.</p>
<p>By the end of this chapter, we will have a full database schema of our blogging application, as well as models that interact with that schema.</p>
<p class="mce-root"/>
<p>In this chapter, we'll cover the following topics: </p>
<ul>
<li>Designing database tables and relationships using SQLAlchemy</li>
<li>Creating, reading, updating, and deleting models</li>
<li>Learning to define model relationships, constraints, and indexes</li>
<li>Creating automatic database migrations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up SQLAlchemy</h1>
                </header>
            
            <article>
                
<p>In order to go through the exercises in this chapter, you will need a running database, if you do not already have one. If you have never installed a database, or you do not have a preference, then <strong>SQLite</strong> is the best option for beginners, or if you want to quickly bootstrap a proof of concept.</p>
<p><strong>SQLite</strong> is an SQL-embedded database engine that is fast, works without a server, and is entirely contained in one file. SQLite is also natively supported in Python, so if you choose to go with SQLite, an SQLite database will be <span><span>automatically</span></span> created for you during the exercise in the <em>Our first model</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Python packages</h1>
                </header>
            
            <article>
                
<p>Flask SQLAlchemy can be used with multiple database engines, such as ORACLE, MSSQL, MySQL, PostgreSQL, SQLite, and Sybase, but we need to install additional specific packages for these engines. N<span>ow it is time to bootstrap our project by creating a new virtual environment for all our application's dependencies. This virtual environment will be used for our blogging application. Enter the following code:</span></p>
<pre><strong>$ virtualenv env</strong></pre>
<p>Then, in <kbd>requirements.txt</kbd>, add the following code to install the package:</p>
<pre>flask-sqlalchemy</pre>
<p>You will also need to install specific packages for your chosen database that will act as the connector for SQLAlchemy, so add the specific packages for your engine in <kbd>requirements.txt</kbd>, as shown in the following code. SQLite users can skip this step:</p>
<pre>    <strong># MySQL</strong>
    <strong>PyMySQL</strong>
    <strong># Postgres</strong>
    <strong>psycopg2</strong>
    <strong># MSSQL</strong>
    <strong>pyodbc</strong>
    <strong># Oracle</strong>
    <strong>cx_Oracle</strong></pre>
<p><span><span>Finally, activate and install the dependencies using the following code:</span></span></p>
<pre><strong>$ source env/bin/activate<br/>$ pip install -r requirements.txt</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Flask SQLAlchemy</h1>
                </header>
            
            <article>
                
<p>Before we can abstract our data, we need to set up Flask SQLAlchemy. SQLAlchemy creates its database connection through a special database URI. This is a string that looks like a URL that contains all the information that SQLAlchemy needs to connect. It takes the general form of the following code:</p>
<pre>databasetype+driver://user:password@host:port/db_name </pre>
<p>For each driver that you installed previously, the URI would be as follows:</p>
<pre># SQLite <span>connection string/uri is a path to the database file - relative or absolute.</span>
<strong>sqlite:///database.db</strong> 
# MySQL 
<strong>mysql+pymysql://user:password@ip:port/db_name</strong> 
# Postgres 
<strong>postgresql+psycopg2://user:password@ip:port/db_name</strong> 
# MSSQL 
<strong>mssql+pyodbc://user:password@dsn_name</strong> 
# Oracle 
<strong>oracle+cx_oracle://user:password@ip:port/db_name</strong> </pre>
<p>In our <kbd>config.py</kbd> file, add the URI to the <kbd>DevConfig</kbd> file with the following:</p>
<pre>class DevConfig(Config): 
  debug = True 
  SQLALCHEMY_DATABASE_URI = "YOUR URI" </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Our first model</h1>
                </header>
            
            <article>
                
<p>You may have noticed that we did not actually create any tables in our database to abstract from. This is because SQLAlchemy allows us to create either models from tables or tables from our models. We will look at this after we have created the first model.</p>
<p class="mce-root"/>
<p>In our <kbd>main.py</kbd> file, SQLAlchemy must first be initialized with our app as follows:</p>
<pre>from flask import Flask<br/>from flask_sqlalchemy import SQLAlchemy<br/>from config import DevConfig<br/><br/>app = Flask(__name__)<br/>app.config.from_object(DevConfig)<br/>db = SQLAlchemy(app) </pre>
<p>SQLAlchemy will read our app's configuration and automatically connect to our database. Let's create a <kbd>User</kbd> model to interact with a user table in the <kbd>main.py</kbd> file, as follows:</p>
<pre>class User(db.Model): 
  id = db.Column(db.Integer(), primary_key=True) 
  username = db.Column(db.String(255)) 
  password = db.Column(db.String(255)) 
 
  def __init__(self, username): 
    self.username = username 
 
  def __repr__(self): 
    return "&lt;User '{}'&gt;".format(self.username) </pre>
<p>What have we accomplished? We now have a model that is based on a user table with three columns. When we inherit from <kbd>db.Model</kbd>, the entire connection and communication with the database will <span>already</span><span> </span><span>be handled for us.</span></p>
<p>Each class variable that is the <kbd>db.Column</kbd> instance represents a column in the database. There is an optional first argument in the <kbd>db.Column</kbd> instance that allows us to specify the name of the column in the database. Without it, SQLAlchemy will assume that the name of the variable is the same as the name of the column. Using this, optional variable would look like the following:</p>
<pre>username = db.Column('user_name', db.String(255))</pre>
<p>The second argument to <kbd>db.Column</kbd> tells SQLAlchemy what type the column should be treated as. The main types that we will work with in this book are as follows:</p>
<ul>
<li><kbd>db.String</kbd></li>
<li><kbd>db.Text</kbd></li>
<li><kbd><kbd>db.Integer</kbd></kbd></li>
<li><kbd>db.Float</kbd></li>
<li><kbd><kbd>db.Boolean</kbd></kbd></li>
<li><kbd>db.Date</kbd></li>
<li><kbd>db.DateTime</kbd></li>
<li><kbd>db.Time</kbd></li>
</ul>
<p>What each type represents is rather simple, as shown in the following list:</p>
<ul>
<li>The <kbd>String</kbd> and <kbd>Text</kbd> types take Python strings and translate them to the <kbd>varchar</kbd> and <kbd>text</kbd> type columns, respectively.</li>
<li>The <kbd>Integer</kbd> and <kbd>Float</kbd> types take any Python number and translates it into the correct type before inserting it into the database.</li>
<li>Boolean takes Python <kbd>True</kbd> or <kbd>False</kbd> statements and, if the database has a <kbd>boolean</kbd> type, inserts a Boolean into the database. If there is no <kbd>boolean</kbd> type in the database, SQLAlchemy automatically translates between Python Booleans and a 0 or a 1 in the database.</li>
<li>The <kbd>Date</kbd>, <kbd>DateTime</kbd>, and <kbd>Time</kbd> types use the Python types of the same names from the <kbd>datetime</kbd> native library and translates them into the database.</li>
</ul>
<p>The <kbd>String</kbd>, <kbd>Integer</kbd>, and <kbd>Float</kbd> types take an extra argument that tells SQLAlchemy the length limit of our column.</p>
<div class="packt_infobox">If you wish to truly understand how SQLAlchemy translates your code into SQL queries, add the following to the <kbd>DevConfig</kbd> file, <kbd>SQLALCHEMY_ECHO = True</kbd>.<br/>
This will print out the created queries to the Terminal. You may wish to turn this feature off as you get further along in the book, as dozens of queries could be printed to the terminal with every page load.</div>
<p>The <kbd>primary_key</kbd> <span>argument</span><span> </span><span>tells SQLAlchemy that this column has the</span> <strong>primary key index</strong> <span>on it. Each SQLAlchemy model</span> requires <span>a primary key to function. </span><span>All object-relationally mapped objects are linked to their database rows </span><span>within the session </span><span>via an identity map, a pattern central to the unit of work mechanism implemented in SQLAlchemy. That's why we need primary keys to be declared in the model.</span></p>
<p>SQLAlchemy will assume that the name of your table is the lowercase version of your model class name. However, what if we want our table to be called something other than <kbd>user</kbd>? To tell SQLAlchemy what name to use, add the <kbd>__tablename__</kbd> class variable.</p>
<p class="mce-root"/>
<p>This is also how you connect to tables that already exist in your database. Just place the name of the table in the following string:</p>
<pre>class User(db.Model): 
  __tablename__ = 'user_table_name' 
 
  id = db.Column(db.Integer(), primary_key=True) 
  username = db.Column(db.String(255)) 
  password = db.Column(db.String(255)) </pre>
<p>We don't have to include the <kbd>__init__</kbd> or <kbd>__repr__</kbd> functions. If we don't, then SQLAlchemy will automatically create an <kbd>__init__</kbd> function that accepts the names and values of your columns as keyword arguments.</p>
<div class="packt_infobox"><span>Naming a table <kbd>user</kbd> using an ORM may lead to problems, since in MySQL, <kbd>user</kbd> is a reserved word. One of the advantages of using an ORM is that you can easily migrate your engine from SQLite to MySQL and then to ORACLE, for example. One very easy fix would be to prefix your schema and use. </span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the user table</h1>
                </header>
            
            <article>
                
<p>Using SQLAlchemy to do the heavy lifting, we will now create the user table in our database. Update <kbd>manage.py</kbd> to the following:</p>
<pre>from main import app, db, User 

@app.shell_context_processor
def make_shell_context():
  return dict(app=app, db=db, User=User) </pre>
<div class="packt_tip">From now on, whenever we create a new model, we will import it and add it to the returned <kbd>dict</kbd>.</div>
<p>This will allow us to work with our models in the Flask shell, because we are injecting. Run the shell now and use <kbd>db.create_all()</kbd> to create all of the tables, as shown in the following code:</p>
<pre>    <strong># Tell Flask where to load our shell context<br/></strong>    <strong>$ export FLASK_APP=manage.py</strong><br/><strong>    $ flask shell</strong>
    <strong>&gt;&gt;&gt; db.create_all()</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span>In your database, y</span>ou should now see a table called <kbd>users</kbd> with the columns specified. Also, if you are using SQLite, you should now see a file named <kbd>database.db</kbd> in your file structure, as shown in the following code:</p>
<pre><strong>$ sqlite3 database.db .tables<br/></strong>user</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CRUD</h1>
                </header>
            
            <article>
                
<p>In every storage mechanism for data, there are four basic types of functions: <strong>create</strong>, <strong>read</strong>, <strong>update</strong>, and <strong>delete</strong> (<strong>CRUD</strong>). These allow us to perform all the basic ways of manipulating and viewing the data that is needed for our web apps. To use these functions, we will use an object in the database named a <strong>session</strong>. Sessions will be explained later in the chapter, but for now, think of them as a storage location for all of our changes to the database.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating models</h1>
                </header>
            
            <article>
                
<p>To create a new row in your database using our models, add the model to the <kbd>session</kbd> and <kbd>commit</kbd> objects. Adding an object to the session marks its changes for saving. Committing is when the session is saved to the database, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; user = User(username='fake_name')</strong>
    <strong>&gt;&gt;&gt; db.session.add(user)</strong>
    <strong>&gt;&gt;&gt; db.session.commit()</strong></pre>
<p>As you can see, adding a new row to our table is simple.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading models</h1>
                </header>
            
            <article>
                
<p>After we have added data to our database, data can be queried using <kbd>Model.query</kbd>. For those who use SQLAlchemy, this is shorthand for <kbd>db.session.query(Model)</kbd>.</p>
<p>For our first example, use <kbd>all()</kbd> to get all rows from the user table as a list, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; users = User.query.all()</strong>
    <strong>&gt;&gt;&gt; users</strong>
    [&lt;User 'fake_name'&gt;]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>When the number of items in the database increases, this query process becomes slower. In SQLAlchemy, as in SQL, we have the <kbd>limit</kbd> function to specify the total number of rows we wish to work with:</p>
<pre>    <strong>&gt;&gt;&gt; users = User.query.limit(10).all()</strong></pre>
<p>By default, SQLAlchemy returns the records ordered by their primary keys. To control this, we have the <kbd>order_by</kbd> function, which is given as follows:</p>
<pre>    <strong># ascending</strong>
    <strong>&gt;&gt;&gt; users = User.query.order_by(User.username).all()</strong>
    <strong># descending</strong>
    <strong>&gt;&gt;&gt; users = User.query.order_by(User.username.desc()).all()</strong></pre>
<p>To return just one record, we use <kbd>first()</kbd> instead of <kbd>all()</kbd>, as follows:</p>
<pre><strong>&gt;&gt;&gt; user = User.query.first()</strong>
<strong>&gt;&gt;&gt; user.username</strong>
fake_name</pre>
<p>To return one model by its primary key, use <kbd>query.get()</kbd>, as follows:</p>
<pre><strong>&gt;&gt;&gt; user = User.query.get(1)</strong>
<strong>&gt;&gt;&gt; </strong><strong>user.username</strong>
fake_name</pre>
<p>All these functions are chainable, which means that they can be appended onto each other to modify the returned result. Those of you who are fluent in JavaScript will find the following syntax familiar:</p>
<pre><strong>&gt;&gt;&gt; users = User.query.order_by(</strong>
    <strong>        User.username.desc()</strong>
<strong>    ).limit(10).first()</strong></pre>
<p>The <kbd>first()</kbd> and <kbd>all()</kbd> methods return a value, and therefore end the chain.</p>
<p>There is also a Flask-SQLAlchemy-specific method, called <strong>pagination</strong>, that can be used rather than <kbd>first()</kbd> or <kbd>all()</kbd>. This is a convenient method that is designed to enable the pagination feature that most websites use while displaying a long list of items. The first parameter defines which page the query should return to and the second parameter defines the number of items per page. So, if we passed <kbd>1</kbd> and <kbd>10</kbd> as the parameters, the first 10 objects would be returned.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>If we instead passed <kbd>2</kbd> and <kbd>10</kbd>, then objects 11–20 would be returned, and so on. The pagination method is different from the <kbd>first()</kbd> and <kbd>all()</kbd> methods because it returns a pagination object rather than a list of models. For example, if we want to get the first 10 items of a fictional <kbd>Post</kbd> object for the first page in our blog, we would use the following:</p>
<pre><strong>&gt;&gt;&gt; User.query.paginate(1, 10)</strong>
&lt;flask_sqlalchemy.Pagination at 0x105118f50&gt;</pre>
<p>This object has several useful properties, as follows:</p>
<pre><strong>&gt;&gt;&gt; page = User.query.paginate(1, 10)</strong>
<strong># returns the entities in the page</strong>
<strong>&gt;&gt;&gt; page.items</strong>
[&lt;User 'fake_name'&gt;]
<strong># what page does this object represent</strong>
<strong>&gt;&gt;&gt; page.page</strong>
1
<strong># How many pages are there</strong>
<strong>&gt;&gt;&gt; page.pages</strong>
1
<strong># are there enough models to make the next or previous page</strong>
<strong>&gt;&gt;&gt; page.has_prev, page.has_next</strong>
(False, False)
<strong># return the next or previous page pagination object</strong>
<strong># if one does not exist returns the current page</strong>
<strong>&gt;&gt;&gt; page.prev(), page.next()</strong>
(&lt;flask_sqlalchemy.Pagination at 0x10812da50&gt;,
&lt;flask_sqlalchemy.Pagination at 0x1081985d0&gt;)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filtering queries</h1>
                </header>
            
            <article>
                
<p>Now we get to the actual power of SQL—that is, filtering results by a set of rules. To get a list of models that satisfy a set of qualities, we use the <kbd>query.filter_by</kbd> filter. The <kbd>query.filter_by</kbd> filter takes named arguments that represent the values we are looking for in each column in the database. To get a list of all users with a username of <kbd>fake_name</kbd>, we would use the following:</p>
<pre>    <strong>&gt;&gt;&gt; users = User.query.filter_by(username='fake_name').all()</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This example is filtering on one value, but multiple values can be passed to the <kbd>filter_by</kbd> filter. Just like our previous functions, <kbd>filter_by</kbd> is chainable, as shown in the following code:</p>
<pre>    <strong>&gt;&gt;&gt; users = User.query.order_by(User.username.desc())</strong>
    <strong>        .filter_by(username='fake_name')</strong>
    <strong>        .limit(2)</strong>
    <strong>        .all()</strong></pre>
<p>The <kbd>query.filter_by</kbd> phrase only works if you know the exact values that you are looking for. This is avoided by passing Python comparison statements to the query with <kbd>query.filter</kbd>, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; user = User.query.filter(</strong>
    <strong>        User.id &gt; 1</strong>
    <strong>    ).all()</strong></pre>
<p>This is a simple example, but <kbd>query.filter</kbd> accepts any Python comparison. With common Python types, such as <kbd>integers</kbd>, <kbd>strings</kbd>, and <kbd>dates</kbd>, the <kbd>==</kbd> operator can be used for equality comparisons. If you had an <kbd>integer</kbd>, <kbd>float</kbd>, or <kbd>date</kbd> column, an inequality statement could also be passed with the <kbd>&gt;</kbd>, <kbd>&lt;</kbd>, <kbd>&lt;=</kbd>, and <kbd>&gt;=</kbd> operators.</p>
<p>We can also translate complex SQL queries with SQLAlchemy functions. For example, to use <kbd>IN</kbd>, <kbd>OR</kbd>, or <kbd>NOT</kbd> SQL comparisons, we would use the following:</p>
<pre>    <strong>&gt;&gt;&gt; from sqlalchemy.sql.expression import not_, or_</strong>
    <strong>&gt;&gt;&gt; user = User.query.filter(</strong>
    <strong>    User.username.in_(['fake_name']),</strong>
    <strong>    User.password == None</strong>
    <strong>).first()</strong>
    <strong># find all of the users with a password</strong>
    <strong>&gt;&gt;&gt; user = User.query.filter(</strong>
    <strong>    not_(User.password == None)</strong>
    <strong>).first()</strong>
    <strong># all of these methods are able to be combined</strong>
    <strong>&gt;&gt;&gt; user = User.query.filter(</strong>
    <strong>    or_(not_(User.password == None), User.id &gt;= 1)</strong>
    <strong>).first()</strong></pre>
<p>In SQLAlchemy, comparisons to <kbd>None</kbd> are translated to comparisons to <kbd>NULL</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating models</h1>
                </header>
            
            <article>
                
<p>To update the values of models that already exist, apply the <kbd>update</kbd> method to a query object—that is, before you return the models with a method such as <kbd>first()</kbd> or <kbd>all()</kbd>, as shown in the following code:</p>
<pre><strong>&gt;&gt;&gt; User.query.filter_by(username='fake_name').update({</strong>
<strong>    'password': 'test'</strong>
<strong>})</strong>
<strong># The updated models have already been added to the session</strong>
<strong>&gt;&gt;&gt; db.session.commit()</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting models</h1>
                </header>
            
            <article>
                
<p>If we wish to remove a model from the database, we would use the following code:</p>
<pre><strong>&gt;&gt;&gt; user = User.query.filter_by(username='fake_name').first()</strong>
<strong>&gt;&gt;&gt; db.session.delete(user)</strong>
<strong>&gt;&gt;&gt; db.session.commit()</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Relationships between models</h1>
                </header>
            
            <article>
                
<p>Relationships between models in SQLAlchemy are links between two or more models that allow models to reference each other automatically. This allows naturally related data, such as comments on posts, to be easily retrieved from the database with its related data. This is where the R in RDBMS comes from, and it gives this type of database a large amount of power.</p>
<p>Let's create our first relation. Our blogging website is going to need some blog posts. Each blog post is going to be written by one user, so it makes sense to link posts back to the user who wrote them so that we can easily get all the posts by a user. This is an example of a <strong>one-to-many</strong> relationship, as shown in the following code:</p>
<div class="packt_infobox">SQLite and MySQL/MyISAM engines do not enforce relationship constraints. This might cause problems if you are using SQLite on your development environment and a different engine on production (MySQL with innodb), but you can tell SQLite to enforce foreign key constraints (with a performance penalty).</div>
<pre><span>@event.listens_for(Engine, "connect")<br/>def set_sqlite_pragma(dbapi_connection, connection_record):<br/>    cursor = dbapi_connection.cursor()<br/>    cursor.execute("PRAGMA foreign_keys=ON")<br/>    cursor.close()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">One-to-many relationship</h1>
                </header>
            
            <article>
                
<p>Let's add a model to represent the blog posts on our website:</p>
<pre>class Post(db.Model): 
  id = db.Column(db.Integer(), primary_key=True) 
  title = db.Column(db.String(255)) 
  text = db.Column(db.Text()) 
  publish_date = db.Column(db.DateTime()) 
  user_id = db.Column(db.Integer(), db.ForeignKey('user.id')) 
 
  def __init__(self, title): 
    self.title = title 
 
  def __repr__(self): 
    return "&lt;Post '{}'&gt;".format(self.title) </pre>
<p>Note the <kbd>user_id </kbd><span>column</span><span>. Those who are familiar with RDBMSes will know that this represents a</span> <strong>foreign key constraint</strong><span>. A foreign key constraint is a rule in the database that forces the value of</span> <kbd>user_id</kbd> <span>to exist in the</span> <kbd>id</kbd> <span>column in the user table. This is a check in the database to make sure that</span> <kbd>Post</kbd> <span>will always refer to an existing user. The parameter to</span> <kbd>db.ForeignKey</kbd> <span>is a string representation of the user ID field. If you have decided to call your user table with</span> <kbd>__table_name__</kbd><span>, then you must change this string. This string is used instead of a direct reference with</span> <kbd>User.id</kbd> <span>because during initialization of SQLAlchemy, the</span> <kbd>User</kbd> <span>object might not exist yet.</span></p>
<p>The <kbd>user_id</kbd> column itself is not enough to tell SQLAlchemy that we have a relationship. We must modify our <kbd>User</kbd> model as follows:</p>
<pre>class User(db.Model): 
  id = db.Column(db.Integer(), primary_key=True) 
  username = db.Column(db.String(255)) 
  password = db.Column(db.String(255)) 
  posts = db.relationship( 
    'Post', 
    backref='user', 
    lazy='dynamic' 
  ) </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The <kbd>db.relationship</kbd> function creates an <span><span>attribute</span></span> in SQLAlchemy that connects with <kbd>db.ForeignKey</kbd> in our <kbd>Post</kbd> model. The first parameter is the name of the class that we are referencing. We will cover what <kbd>backref</kbd> does soon, but what is the <kbd>lazy</kbd> parameter? The <kbd>lazy</kbd> parameter controls how SQLAlchemy will load our related objects. The <kbd>subquery</kbd> phrase would load our relations as soon as our <kbd>Post</kbd> object is loaded. This cuts down the number of queries, but will slow down when the number of returned items grows larger. In contrast, with the <kbd>dynamic</kbd> option, the related objects will be loaded upon access and can be filtered down before returning. This is best if the number of returned objects is or will become large.</p>
<p>We may now access the <kbd>User.posts</kbd> variable that will return a list of all the posts whose <kbd>user_id</kbd> field equals our <kbd>User.id</kbd>. Let's try this now in our shell, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; user = User.query.get(1)</strong>
    <strong>&gt;&gt;&gt; new_post = Post('Post Title')</strong>
    <strong>&gt;&gt;&gt; new_post.user_id = user.id</strong>
    <strong>&gt;&gt;&gt; user.posts</strong>
    []
    <strong>&gt;&gt;&gt; db.session.add(new_post)</strong>
    <strong>&gt;&gt;&gt; db.session.commit()</strong>
    <strong>&gt;&gt;&gt; user.posts</strong>
    [&lt;Post 'Post Title'&gt;]</pre>
<p>Note that we were not able to access our post from our relationship without committing our changes to the database.</p>
<p>The <kbd>backref</kbd> <span>parameter</span><span> </span><span>gives us the ability to access and set our</span> <kbd>User</kbd> <span>class via</span> <kbd>Post.user</kbd><span>. This is given by the following code:</span></p>
<pre>    <strong>&gt;&gt;&gt; second_post = Post('Second Title')</strong>
    <strong>&gt;&gt;&gt; second_post.user = user</strong>
    <strong>&gt;&gt;&gt; db.session.add(second_post)</strong>
    <strong>&gt;&gt;&gt; db.session.commit()</strong>
    <strong>&gt;&gt;&gt; user.posts</strong>
    [&lt;Post 'Post Title'&gt;, &lt;Post 'Second Title'&gt;]</pre>
<p>Because <kbd>user.posts</kbd> is a list, we could have also added our <kbd>Post</kbd> model to the list to save it automatically, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; second_post = Post('Second Title')</strong>
    <strong>&gt;&gt;&gt; user.posts.append(second_post)</strong>
    <strong>&gt;&gt;&gt; db.session.add(user)</strong>
    <strong>&gt;&gt;&gt; db.session.commit()</strong>
    <strong>&gt;&gt;&gt; user.posts</strong>
    [&lt;Post 'Post Title'&gt;, &lt;Post 'Second Title'&gt;]</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>With the <kbd>backref</kbd> option as dynamic, we can treat our relation column as a query as well as a list, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; user.posts</strong>
    [&lt;Post 'Post Title'&gt;, &lt;Post 'Second Title'&gt;]<strong>
    &gt;&gt;&gt; user.posts.order_by(Post.publish_date.desc()).all()</strong>
    [&lt;Post 'Second Title'&gt;, &lt;Post 'Post Title'&gt;]</pre>
<p>Before we move on to our next relationship type, let's add another model for user comments with a one-to-many relationship, which will be used in the book later on. We can do this using the following code:</p>
<pre>class Post(db.Model): 
    id = db.Column(db.Integer(), primary_key=True) 
    title = db.Column(db.String(255)) 
    text = db.Column(db.Text()) 
    publish_date = db.Column(db.DateTime()) 
    comments = db.relationship( 
      'Comment', 
      backref='post', 
      lazy='dynamic' 
    ) 
    user_id = db.Column(db.Integer(), db.ForeignKey('user.id'))<br/>    def __init__(self, title): 
        self.title = title<br/>    def __repr__(self): 
        return "&lt;Post '{}'&gt;".format(self.title)<br/> </pre>
<p>Note the <kbd>__repr__</kbd> method signature in the preceding code. This is a built-in function in Python that is used to return the string representation of the object. Next is the <kbd>Comment</kbd> model, as shown in the following code:</p>
<pre>class Comment(db.Model): 
    id = db.Column(db.Integer(), primary_key=True) 
    name = db.Column(db.String(255)) 
    text = db.Column(db.Text()) 
    date = db.Column(db.DateTime()) 
    post_id = db.Column(db.Integer(), db.ForeignKey('post.id'))<br/>    def __repr__(self): 
        return "&lt;Comment '{}'&gt;".format(self.text[:15]) </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Many-to-many relationship</h1>
                </header>
            
            <article>
                
<p>What if we have two models that can reference each other, but each model needs to reference more than one of each type? In our example, our blog posts will need tags in order for our users to easily group similar posts. Each tag can refer to many posts, but each post can have multiple tags. This type of relationship is called a <strong>many-to-many</strong> relationship. Consider the following example:</p>
<pre>tags = db.Table('post_tags', 
    db.Column('post_id', db.Integer, db.ForeignKey('post.id')), 
    db.Column('tag_id', db.Integer, db.ForeignKey('tag.id')) 
) 
 
<strong>class Post(db.Model): </strong>
    id = db.Column(db.Integer(), primary_key=True) 
    title = db.Column(db.String(255)) 
    text = db.Column(db.Text()) 
    publish_date = db.Column(db.DateTime()) 
    comments = db.relationship( 
      'Comment', 
      backref='post', 
      lazy='dynamic' 
    ) 
    user_id = db.Column(db.Integer(), db.ForeignKey('user.id')) 
    tags = db.relationship( 
        'Tag', 
        secondary=tags, 
        backref=db.backref('posts', lazy='dynamic') 
    ) <br/><br/>    def __init__(self, title): 
        self.title = title<br/>    def __repr__(self): 
        return "&lt;Post '{}'&gt;".format(self.title) 
 
<strong>class Tag(db.Model):</strong> 
    id = db.Column(db.Integer(), primary_key=True) 
    title = db.Column(db.String(255))<br/>  <br/>    def __init__(self, title): 
        self.title = title 
  <br/>    def __repr__(self): 
        return "&lt;Tag '{}'&gt;".format(self.title) </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The <kbd>db.Table</kbd> object is a lower-level access to the database than the abstraction of <kbd>db.Model</kbd>. The <kbd>db.Model</kbd> object rests on top of <kbd>db.Table</kbd> and provides a representation of specific rows in the table. The <kbd>db.Table</kbd> object is used because there is no need to access the individual rows of the table.</p>
<p>The <kbd>tags</kbd> variable is used to represent the <kbd>post_tags</kbd> table, which contains two rows: one that represents an ID of a post, and another that represents the ID of a tag. To illustrate how this works, let's look at an example. Say that the table had the following data:</p>
<pre>post_id   tag_id 
1         1 
1         3 
2         3 
2         4 
2         5 
3         1 
3         2 </pre>
<p>SQLAlchemy would translate this to the following:</p>
<ul>
<li>A post with an ID of <kbd>1</kbd> has the tags with the IDs of <kbd>1</kbd> and <kbd>3</kbd></li>
<li>A post with an ID of <kbd>2</kbd> has the tags with the IDs of <kbd>3</kbd>, <kbd>4</kbd>, and <kbd>5</kbd></li>
<li>A post with an ID of <kbd>3</kbd> has the tags with the IDs of <kbd>1</kbd> and <kbd>2</kbd></li>
</ul>
<p>You may describe this data as easily as tags being related to posts.</p>
<p>Before the <kbd>db.relationship</kbd> function sets up our relationship, this time it has the secondary parameter. The secondary parameter tells SQLAlchemy that this relationship is stored in the <kbd>tags</kbd> table, as shown in the following code:</p>
<pre>    <strong>&gt;&gt;&gt; post_one = Post.query.filter_by(title='Post Title').first()</strong>
    <strong>&gt;&gt;&gt; post_two = Post.query.filter_by(title='Second Title').first()</strong>
    <strong>&gt;&gt;&gt; tag_one = Tag('Python')</strong>
    <strong>&gt;&gt;&gt; tag_two = Tag('SQLAlchemy')</strong>
    <strong>&gt;&gt;&gt; tag_three = Tag('Flask')</strong>
    <strong>&gt;&gt;&gt; post_one.tags = [tag_two]</strong>
    <strong>&gt;&gt;&gt; post_two.tags = [tag_one, tag_two, tag_three]</strong>
    <strong>&gt;&gt;&gt; tag_two.posts</strong>
    [&lt;Post 'Post Title'&gt;, &lt;Post 'Second Title'&gt;]<strong>
    &gt;&gt;&gt; db.session.add(post_one)</strong>
    <strong>&gt;&gt;&gt; db.session.add(post_two)</strong>
    <strong>&gt;&gt;&gt; db.session.commit()</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>As given in the one-to-many relationship, the main relationship column is just a list, the main difference being that the <kbd>backref</kbd> option is now also a list. Because it's a list, we may add posts to tags from the <kbd>tag</kbd> object, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; tag_one.posts.append(post_one)</strong>
    [&lt;Post 'Post Title'&gt;, &lt;Post 'Second Title'&gt;]<strong>
    &gt;&gt;&gt; post_one.tags</strong>
    [&lt;Tag 'SQLAlchemy'&gt;, &lt;Tag 'Python'&gt;]
    <strong>&gt;&gt;&gt; db.session.add(tag_one)</strong>
    <strong>&gt;&gt;&gt; db.session.commit()</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Constraints and indexing</h1>
                </header>
            
            <article>
                
<p>Using constraints is considered a good practice. This way, you can restrict the domain of a certain model attribute and ensure data integrity and quality. There are many types of constraints that you can use; primary key and foreign key constraints<strong> </strong>were already covered in the previous sections. The other kinds of constraints that are supported by SQLAlchemy are shown in the following list:</p>
<ul>
<li>Not NULL (ensures that a certain attribute contains data)</li>
<li>UNIQUE (ensures that a certain attribute value is always unique in the database table, which contains the model data<span>)</span></li>
<li>DEFAULT (sets a default value for the attribute when no values were provided)</li>
<li>CHECK (used to specify range of values)</li>
</ul>
<p>Using SQLAlchemy, you can ensure that your data's domain restrictions are explicit and all in the same place, not spread across your application code.</p>
<p>Let's improve our models by setting some constraints on the data. First, we should not accept NULL values for usernames on the user model, and ensure that a username is always unique. We do this using the following code:</p>
<pre>...<br/>class User(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    username = db.Column(db.String(255), <strong>nullable=False, unique=True</strong>)<br/>...</pre>
<p>The same principle applies to the rest of our models: A <kbd>Post</kbd> must always have a title, a <kbd>Comment</kbd> is always made by someone, and a <kbd>Tag</kbd> always has a title, and this title value is unique. We put these constraints in place using the following code:</p>
<pre>...<br/>class Post(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    title = db.Column(db.String(255), <strong>nullable=False</strong>)<br/>...<br/>class Comment(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    name = db.Column(db.String(255), <strong>nullable=False</strong>)<br/>...<br/>class Tag(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    title = db.Column(db.String(255), <strong>nullable=True, unique=True</strong>)<br/>...</pre>
<p>Default values are really nice; they ensure data quality, and make your code shorter. We can let SQLAlchemy handle the date timestamp of when a comment or post was made using the following code:</p>
<pre>class Comment(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>...<br/>    date = db.Column(db.DateTime(), <strong><span class="pl-v">default</span><span class="pl-k">=</span><span>datetime.datetime.now</span></strong>)<br/>...<br/><br/>class Post(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>...<br/>    publish_date = db.Column(db.DateTime(), <strong><span class="pl-v">default</span><span class="pl-k">=</span><span>datetime.datetime.now</span></strong>)</pre>
<p>Note how SQLAlchemy handles the default definitions. This is a powerful feature. We are passing a reference to a Python function, so we can use any Python function we want as long as no parameters are required (except for partials). This function will be called upon the creation of a record or an update, and its return value is used for the column's value. Of course, SQLAlchemy also supports simple scalar values on default definitions.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>RDBMS indexes are used to improve query performance, yet you should be careful about using them as this comes at a cost of additional writes on <kbd>INSERT</kbd>, <kbd>UPDATE</kbd>, and <kbd>DELETE</kbd> functions, as well as an increase in storage. Careful index choice and configuration is out of the scope of this book, but take into account the fact that an index is used to reduce the O(N) lookup on certain table columns that may be frequently used, or that are in tables with a huge number of rows where a linear lookup is simply not possible in production. Index query performance can go from logarithmic to O(1). This is possible at a cost of additional writes and checks.</p>
<p>An example of creating an index using Flask SQLAlchemy, can be seen in the following code:</p>
<pre>...<br/>class User(db.Model):<br/>    id = db.Column(db.Integer(), primary_key=True)<br/>    username = db.Column(db.String(255), <strong>nullable=False, index=True, unique=True</strong>)<br/>...</pre>
<p>The following code shows an example of using an <span>index</span><span> for </span><span>multiple columns:</span></p>
<p> </p>
<pre>db.Index(<span class="s1">'idx_col_example'</span><span class="p">,</span> <span class="n">User</span><span class="o">.username</span><span class="p">,</span> <span class="n">User</span><span class="o">.password</span><span class="p">)</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The convenience of SQLAlchemy sessions</h1>
                </header>
            
            <article>
                
<p>Now you understand the power of SQLAlchemy and what the SQLAlchemy session object is, and why web apps should never be made without them. As stated before, the session can be simply described as an object that tracks the changes in our models and commits them to the database when we tell it to. However, there is a bit more to it than this.</p>
<p>First, the session is also the handler for <strong>transactions</strong>. Transactions are sets of changes that are flushed to the database on commit. Transactions provide a lot of hidden functionality. For example, transactions automatically determine which objects are to be saved first when objects have relations. You might have noted this when we were saving tags in the previous section. When we added tags to the posts, the session automatically knew to save the tags first despite the fact that we did not add them to be committed. If we are working with raw SQL queries and a database connection, we will have to keep track of which rows are related to which other rows to avoid saving a foreign key reference to an object that does not exist.</p>
<p class="mce-root"/>
<p>Transactions also automatically mark data as stale when changes to an object are saved to the database. The next time we access the object, a query is made to the database to update the data, but all of this happens behind the scenes. If we are not using SQLAlchemy, we will also need to manually track which rows need to be updated. If we want to be resource efficient, we only need to query and update those rows.</p>
<p>Second, the session makes it impossible for there to be two different references to the same row in the database. This is accomplished by ensuring that all queries go through the session (<kbd>Model.query</kbd> is actually <kbd>db.session.query(Model)</kbd>), and if the row has already been queried in this transaction, that the pointer to that object will be returned and not a new object. If this check did not exist, two objects that represent the same row could be saved to the database with different changes. This creates subtle bugs that might not be caught instantly.</p>
<p>Keep in mind that Flask SQLAlchemy creates a new session for every request and discards any changes that were not committed at the end of the request, so always remember to save your work.</p>
<div class="packt_infobox">For an in-depth look at sessions, the creator of SQLAlchemy, Mike Bayer, gave a talk at PyCon Canada 2012. Refer to <em>The SQLAlchemy Session - In Depth</em>, at <a href="https://www.youtube.com/watch?v=PKAdehPHOMo"><span class="URLPACKT">https://www.youtube.com/watch?v=PKAdehPHOMo</span></a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Database migrations with Alembic</h1>
                </header>
            
            <article>
                
<p>The functionality of web apps changes all the time, and with every new functionality, we need to change the structure of our database. Whether it's adding or dropping new columns or creating new tables, our models will change throughout the life cycle of our app. However, problems quickly arise when the database changes often. When moving our changes from development to production, how can you be sure that you carried over every change without manually comparing each model and its corresponding table? Let's say that you want to go back into your Git history to see whether an earlier version of your app had the same bug that you are now encountering in production. How will you change your database back to the correct schema without a lot of extra work?</p>
<p>As programmers, we hate extra work. Thankfully, there is a tool called <strong>Alembic</strong>, which automatically creates and tracks database migrations from the changes in our SQLAlchemy models. <strong>Database migrations</strong> are records of all the changes of our schema. Alembic allows us to upgrade or downgrade our database to a specific saved version. Upgrading or downgrading by several versions will execute all the files between the two selected versions. The best thing about Alembic is that its history files are only Python files. When we create our first migration, we can see how simple the Alembic syntax is.</p>
<div class="packt_infobox">Alembic does not capture every possible change—for example, it does not record changes on the SQL indexes. After every migration, the reader is encouraged to review the migration file and make any necessary corrections.</div>
<p>We won't work directly with Alembic. Instead, we will use <strong>Flask-Migrate</strong>, which is an extension created specifically for SQLAlchemy, and which works with the Flask CLI. You will find it in the <kbd>requirements.txt</kbd> file, as shown in the following code:</p>
<pre><strong>Flask-Migrate</strong></pre>
<p>To get started, we don't need to add anything to our <kbd>manage.py</kbd> file since Flask-Migrate already extends the Flask CLI with its own CLI options, as shown in the following code:</p>
<pre>from main import app, db, User, Post, Tag, migrate<br/><br/><br/>@app.shell_context_processor<br/>def make_shell_context():<br/>    return dict(app=app, db=db, User=User, Post=Post, Tag=Tag, migrate=migrate)</pre>
<p>And on our <kbd>main.py</kbd>:</p>
<pre>import datetime<br/><br/>from flask import Flask<br/>from flask_sqlalchemy import SQLAlchemy<br/><strong>from flask_migrate import Migrate</strong><br/>from config import DevConfig<br/><br/>app = Flask(__name__)<br/>app.config.from_object(DevConfig)<br/><br/>db = SQLAlchemy(app)<br/><strong>migrate = Migrate(app, db)</strong></pre>
<p>To initialize the <kbd>Migrate</kbd> object with our app and our SQLAlchemy instance, run the following code:</p>
<pre>    # Tell Flask where is our app<br/>    <strong>$ export FLASK_APP=main.py<br/></strong>    <strong>$ flask db</strong></pre>
<p>To start tracking our changes, we use the <kbd>init</kbd> command, as follows:</p>
<pre>    <strong>$ flask db init</strong></pre>
<p>This will create a new folder in our directory named <kbd>migrations</kbd> that will hold all of our history. Now we start with our first migration, as shown in the following code:</p>
<pre>    <strong>$ flask db migrate -m"initial migration"</strong>
  </pre>
<p>This command will cause Alembic to scan our SQLAlchemy object and find all the tables and columns that did not exist before this commit. As this is our first commit, the migration file will be rather long. Be sure to specify the migration message with <kbd>-m</kbd>, as it's the easiest way to identify what each migration is doing. Each migration file is stored in the <kbd>migrations/versions/</kbd> folder.</p>
<p>To apply the migration to your database and change your schema, run the following code:</p>
<pre><strong>$ flask db upgrade</strong></pre>
<p>If we want to check out all the SQLAlchemy generated DDL code, then we use the following code:</p>
<pre><strong>$ flask db upgrade --sql</strong></pre>
<p>To return to the previous version, find the version number with the <kbd>history</kbd> command and pass it to the <kbd>downgrade</kbd> command, as follows:</p>
<pre><strong>$ flask db history</strong>
&lt;base&gt; -&gt; 7ded34bc4fb (head), initial migration
<strong>$ flask db downgrade 7ded34bc4fb</strong></pre>
<p>Like Git, a hash marks each migration. This is the main functionality of Alembic, but it is only surface level. Try to align your migrations with your Git commits in order to make it easier to downgrade or upgrade when reverting commits.</p>
<p>In the code for this book, you will find in each chapter an initialization script that will create a Python virtual environment, install all declared dependencies, and initialize the database. Take a look at the <kbd>init.sh</kbd> Bash script.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Now that we have <span>mastered </span><span>data control, we may move on to displaying our data in our application. The next chapter,</span> <kbd><span class="ChapterrefPACKT">Chapter 3</span></kbd><span>,</span> <em>Creating Views with Templates</em><span>, will dynamically cover creating HTML based on our models and adding models from our web interface.</span></p>


            </article>

            
        </section>
    </body></html>