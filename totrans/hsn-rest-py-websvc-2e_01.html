<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing RESTful APIs and Microservices with Flask 1.0.2</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will start our journey toward RESTful Web APIs with Python 3.7 and four different web frameworks. Python is one of the most popular and versatile programming languages. There are thousands of Python packages, and these allow you to extend Python capabilities to any kind of domain you can imagine, such as web development, <strong>Internet of Things</strong> (<strong>IoT</strong>), artificial intelligence, machine learning, and scientific computing. We can work with many different web frameworks and packages to easily build simple and complex RESTful Web APIs with Python, and we can combine these frameworks with other Python packages.</p>
<p>We can leverage our existing knowledge of Python and all of its ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing a RESTful API to interact with a simple data source</h1>
                </header>
            
            <article>
                
<p>Imagine that we have to configure the notification messages to be displayed in an <strong>OLED</strong> (short for <strong>Organic Light Emitting Diode</strong>) display wired to an IoT device. The IoT device is capable of running Python 3.7.1, Flask 1.0.2, and other Python packages. There is a team writing code that retrieves string messages that represent notifications from a dictionary and displays them in the OLED display wired to the IoT device. We have to start working on a mobile app and a website that has to interact with a RESTful API to perform CRUD operations with string messages that represent notifications.</p>
<p>We don't need an <strong>ORM</strong> (short for <strong>Object-Relational Mapping</strong>) because we won't persist the notifications on a database. We will just work with an in-memory dictionary as our data source. It is one of the requirements we have for this RESTful API. In this case, the RESTful Web Service will be running on the IoT device; that is, we will run the Flask development service on the IoT device.</p>
<div class="packt_tip">We will definitely lose scalability for our RESTful API because we have the in-memory data source in the service, and therefore we cannot run the RESTful API in another IoT device. However, we will work with another example that is related to a more complex data source that will be able to scale in the RESTful way later. The first example is going to allow us to understand how Flask and Flask-RESTful work together with a very simple in-memory data source.</div>
<p class="mce-root"/>
<p>We have chosen Flask because it is an extremely lightweight framework, we don't need to configure an ORM, and we want to start running the RESTful API on the IoT device as soon as possible to allow all the teams to interact with it. We consider that there will be a website that will be coded with Flask too, and therefore, we want to use the same web micro-framework to power the website and the RESTful Web Service. In addition, Flask is an appropriate choice to create a microservice that can run our RESTful API on the cloud.</p>
<p>There are many extensions available for Flask that make it easier to perform specific tasks with the Flask micro-framework. We will take advantage of Flask-RESTful, an extension that will allow us to encourage best practices while building our RESTful API. In this case, we will work with a Python dictionary as the data source. As previously explained, we will work with more complex data sources in forthcoming examples.</p>
<p>First, we must specify the requirements for our main resource—a notification. We need the following attributes or fields for a notification:</p>
<ul>
<li>An integer identifier.</li>
<li>A string message.</li>
<li>A <strong>TTL</strong> (short for <strong>Time to Live</strong>), that is, a duration in seconds that will indicate the time the notification message has to be displayed on the OLED display.</li>
<li>A creation date and time. The timestamp will be added automatically when adding a new notification to the collection.</li>
<li>A notification category description, such as <em>Warning</em> or <em>Information</em>.</li>
<li>An integer counter that indicates the times when the notification message has been displayed on the OLED display.</li>
<li>A Boolean value that indicates whether the notification message was displayed at least once on the OLED display.</li>
</ul>
<p>The following table shows the HTTP verbs, the scope, and the semantics for the methods that our first version of the API must support. Each method is composed of an HTTP verb and a scope, and all the methods have a well-defined meaning for all notifications and collections. In our API, each notification has its own unique URL:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>HTTP verb</p>
</td>
<td>
<p>Scope</p>
</td>
<td>
<p>Semantics</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Collection of notifications</p>
</td>
<td>
<p>Retrieve all the stored notifications in the collection.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>GET</kbd></p>
</td>
<td>
<p>Notification</p>
</td>
<td>
<p>Retrieve a single notification.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>POST</kbd></p>
</td>
<td>
<p>Collection of notifications</p>
</td>
<td>
<p>Create a new notification in the collection.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>PATCH</kbd></p>
</td>
<td>
<p>Notification</p>
</td>
<td>
<p>Update one or more fields for an existing notification.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DELETE</kbd></p>
</td>
<td>
<p>Notification</p>
</td>
<td>
<p>Delete an existing notification.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding the tasks performed by each HTTP method</h1>
                </header>
            
            <article>
                
<p>Let's consider that <kbd>http://localhost:5000/service/notifications/</kbd> is the URL for the collection of notifications. If we add a number to the previous URL, we identify a specific notification whose ID is equal to the specified numeric value. For example, <kbd>http://localhost:5000/service/notifications/5</kbd> identifies the notification whose ID is equal to <kbd>5</kbd>.</p>
<div class="packt_tip">We want our API to differentiate collections from a single resource of the collection in the URLs. When we refer to a collection, we will use a slash (<kbd>/</kbd>) as the last character for the URL, as in <kbd>http://localhost:5000/service/notifications/</kbd>. When we refer to a single resource of the collection, we won't use a slash (<kbd>/</kbd>) as the last character for ...</div></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding microservices</h1>
                </header>
            
            <article>
                
<p>In the last few years, many large and complex applications started shifting from a monolithic architecture to a microservices architecture. Instead of working with large and extremely complex web services, the microservices architecture proposes developing a collection of smaller, loosely-coupled services to implement all the features required by complex applications in a way that enables and simplifies continuous delivery.</p>
<p class="mce-root"/>
<p>RESTful APIs are essential pieces of the microservices architecture, and Python is extremely popular when shifting to this architecture. Each microservice can encapsulate a RESTful API that fulfills a specific and limited purpose. The microservice is self-contained, it is easy to maintain, and it helps to support continuous delivery.</p>
<p>As happens with any architecture, there are several ways to implement the microservices architecture. We will learn to encapsulate a RESTful API developed with Flask and Python into a microservice. This way, we will be able to leverage our skills by developing RESTful APIs and using them as the essential pieces to build self-contained and easy-to-maintain microservices.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with lightweight virtual environments</h1>
                </header>
            
            <article>
                
<p>Throughout this book, we will be working with different frameworks, packages, and libraries to create RESTful Web APIs and microservices, and therefore, it is convenient to work with Python virtual environments to isolate each development environment. Python 3.3 introduced lightweight virtual environments and they were improved in subsequent Python versions. We will work with these virtual environments and, therefore, you will need Python 3.7.1 or higher. You can read more about the PEP 405 Python virtual environment, which introduced the <kbd>venv</kbd> module, at <a href="https://www.python.org/dev/peps/pep-0405"><span class="URLPACKT">https://www.python.org/dev/peps/pep-0405</span></a>. All the examples for this book were tested on Python 3.7.1 on Linux, macOS, and Windows.</p>
<div class="packt_tip">In case you ...</div></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up a virtual environment with Flask and Flask-RESTful</h1>
                </header>
            
            <article>
                
<p>We have followed the necessary steps to create and activate a virtual environment. Now, we will create a <kbd>requirements.txt</kbd> file to specify the set of packages that our application requires to be installed in any supported platform. This way, it will be extremely easy to repeat the installation of the specified packages with their versions in any new virtual environment.</p>
<p>Use your favorite editor to create a new text file, named <kbd>requirements.txt</kbd>, within the root folder of the recently created virtual environment. The following lines show the content of the file that declares the packages and the versions that our API requires. The code file for the sample is included in the <kbd>restful_python_2_01_01</kbd> folder, in the <kbd>Flask01/requirements.txt</kbd> file:</p>
<pre>Flask==1.0.2 
flask-restful==0.3.6 
httpie==1.0.0</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Each line in the <kbd>requirements.txt</kbd> file indicates the package and the version that needs to be installed. In this case, we are working with exact versions by using the <kbd>==</kbd> operator because we want to make sure that the specified version is installed. The following table summarizes the packages and the version numbers that we specified as requirements:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>
<p>Package name</p>
</td>
<td>
<p>Version to be installed</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Flask</kbd></p>
</td>
<td>
<p>1.0.2</p>
</td>
</tr>
<tr>
<td>
<p><kbd>flask-restful</kbd></p>
</td>
<td>
<p>0.3.6</p>
</td>
</tr>
<tr>
<td>
<p><kbd>httpie</kbd></p>
</td>
<td>
<p>1.0.0</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now, we must run the following command on macOS, Linux, or Windows to install the packages and the versions explained in the previous table with <kbd>pip</kbd> by using the recently created <kbd>requirements.txt</kbd> file. Notice that Flask is a dependency for Flask-RESTful. Make sure you are located in the folder that has the <kbd>requirements.txt</kbd> file before running the following command:</p>
<pre><strong>pip install -r requirements.txt</strong>     </pre>
<p>The last lines for the output will indicate all the packages that have been successfully installed, including <kbd>Flask</kbd>, <kbd>flask-restful</kbd>, and <kbd>httpie</kbd>:</p>
<pre><strong>Installing collected packages: itsdangerous, click, MarkupSafe, Jinja2, Werkzeug, Flask, aniso8601, six, pytz, flask-restful, chardet, certifi, idna, urllib3, requests, Pygments, httpie</strong>
    <strong>  Running setup.py install for itsdangerous ... done</strong>
    <strong>  Running setup.py install for MarkupSafe ... done</strong>
<strong>Successfully installed Flask-1.0.2 Jinja2-2.10 MarkupSafe-1.0<br/>Pygments-2.2.0 Werkzeug-0.14.1 aniso8601-3.0.2 certifi-2018.8.24 chardet-3.0.4 click-7.0 flask-restful-0.3.6 httpie-1.0.0 idna-2.7 itsdangerous-0.24 pytz-2018.5 requests-2.19.1 six-1.11.0 urllib3-1.23</strong>
  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Declaring status codes for the responses with an enumerable</h1>
                </header>
            
            <article>
                
<p>Neither Flask nor Flask-RESTful includes the declaration of variables for the different HTTP status codes. We don't want to return numbers as status codes. We want our code to be easy to read and understand, and therefore, we will use descriptive HTTP status codes. Specifically, we will take advantage of the support for enumerations added in Python 3.4 to declare a class that defines unique sets of names and values that represent the different HTTP status codes.</p>

<p>First, create a <kbd>service</kbd> folder within the root folder for the recently created virtual environment. Create a new <kbd>http_status.py</kbd> file within the <kbd>service</kbd> folder. The following lines show the code that declares the <kbd>HttpStatus ...</kbd></p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the model</h1>
                </header>
            
            <article>
                
<p>Now, we will create a simple <kbd>NotificationModel</kbd> class that we will use to represent notifications. Remember that we won't be persisting the model in any database or file, and therefore, in this case, our class will just provide the required attributes and no mapping information. Create a new <kbd>models.py</kbd> file in the <kbd>service</kbd> folder. The following lines show the code that creates a <kbd>NotificationModel</kbd> class in the <kbd>service/models.py</kbd> file. The code file for the sample is included in the <kbd>restful_python_2_01_01</kbd> folder, in the <kbd>Flask01/service/models.py</kbd> file:</p>
<pre>class NotificationModel: 
    def __init__(self, message, ttl, creation_date, notification_category): 
        # We will automatically generate the new id 
        self.id = 0 
        self.message = message 
        self.ttl = ttl 
        self.creation_date = creation_date 
        self.notification_category = notification_category 
        self.displayed_times = 0 
        self.displayed_once = False </pre>
<p>The <kbd>NotificationModel</kbd> class just declares a constructor, that is, the <kbd>__init__</kbd> method. This method receives many arguments and uses them to initialize the attributes with the same names: <kbd>message</kbd>, <kbd>ttl</kbd>, <kbd>creation_date</kbd>, and <kbd>notification_category</kbd>. The <kbd>id</kbd> attribute is set to <kbd>0</kbd>, <kbd>displayed_times</kbd> is set to <kbd>0</kbd>, and <kbd>displayed_once</kbd> is set to <kbd>False</kbd>. We will automatically increment the identifier for each new notification generated with API calls.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using a dictionary as a repository</h1>
                </header>
            
            <article>
                
<p>Now, we will create a <kbd>NotificationManager</kbd> class that we will use to persist the <kbd>NotificationModel</kbd> instances in an in-memory dictionary. Our API methods will call methods for the <kbd>NotificationManager</kbd> class to retrieve, insert, update, and delete <kbd>NotificationModel</kbd> instances. Create a new <kbd>service.py</kbd> file in the <kbd>service</kbd> folder. The following lines show the code that creates a <kbd>NotificationManager</kbd> class in the <kbd>service/service.py</kbd> file. In addition, the following lines declare all the <kbd>imports</kbd> we will need for all the code we will write in this file. The code file for the sample is included in the <kbd>restful_python_2_01_01</kbd> folder, in the <kbd>Flask01/service/service.py</kbd> file:</p>
<pre>from flask import Flask from flask_restful import ...</pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring output fields</h1>
                </header>
            
            <article>
                
<p>Now, we will create a <kbd>notification_fields</kbd> dictionary that we will use to control the data that we want Flask-RESTful to render in our responses when we return <kbd>NotificationModel</kbd> instances. Open the <kbd>service/service.py</kbd> file created previously and add the following lines to the existing code. The code file for the sample is included in the <kbd>restful_python_2_01_01</kbd> folder, in the <kbd>Flask01/service/service.py</kbd> file:</p>
<pre>notification_fields = { 
    'id': fields.Integer, 
    'uri': fields.Url('notification_endpoint'), 
    'message': fields.String, 
    'ttl': fields.Integer, 
    'creation_date': fields.DateTime, 
    'notification_category': fields.String, 
    'displayed_times': fields.Integer, 
    'displayed_once': fields.Boolean 
} 
 
 
notification_manager = NotificationManager() </pre>
<p>We declared the <kbd>notification_fields</kbd> dictionary (<kbd>dict</kbd>) with key-value pairs of strings and classes declared in the <kbd>flask_restful.fields</kbd> module. The keys are the names of the attributes we want to render from the <kbd>NotificationModel</kbd> class, and the values are the classes that format and return the value for the field. In the previous code, we worked with the following classes that format and return the value for the specified field in the key:</p>
<ul>
<li><kbd>fields.Integer</kbd>: Outputs an integer value.</li>
<li><kbd>fields.Url</kbd>: Generates a string representation of a URL. By default, this class generates a relative URI for the resource that is being requested. The code specifies <kbd>'notification_endpoint'</kbd> for the <kbd>endpoint</kbd> argument. This way, the class will use the specified endpoint name. We will declare this endpoint later in the <kbd>service.py</kbd> file. We don't want to include the hostname in the generated URI and, therefore, we use the default value for the <kbd>absolute</kbd> Boolean attribute, which is <kbd>False</kbd>.</li>
<li><kbd>fields.DateTime</kbd>: Outputs a formatted date and time string in UTC, in the default RFC 822 format.</li>
<li><kbd>fields.Boolean</kbd>: Generates a string representation of a Boolean value.</li>
</ul>
<p>The <kbd>'uri'</kbd> field uses <kbd>fields.Url</kbd> and is related to the specified endpoint instead of being associated with an attribute of the <kbd>NotificationModel</kbd> class. It is the only case in which the specified field name doesn't have an attribute in the <kbd>NotificationModel</kbd> class. The other strings specified as keys indicate all the attributes we want to be rendered in the output when we use the <kbd>notification_fields</kbd> dictionary to make up the final serialized response output.</p>
<p>After we declare the <kbd>notification_fields</kbd> dictionary, the next line of code creates an instance of the <kbd>NotificationManager</kbd> class <span>created previously</span>, named <kbd>notification_manager</kbd>. We will use this instance to create, retrieve, and delete <kbd>NotificationModel</kbd> instances.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with resourceful routing on top of Flask pluggable views</h1>
                </header>
            
            <article>
                
<p>Flask-RESTful uses resources built on top of Flask pluggable views as the main building block for a RESTful API. We just need to create a subclass of the <kbd>flask_restful.Resource</kbd> class and declare the methods for each supported HTTP verb.</p>
<div class="packt_tip">A subclass of <kbd>flask_restful.Resource</kbd> represents a RESTful resource and, therefore, we will have to declare one class to represent the collection of notifications and another one to represent the notification resource.</div>
<p>First, we will create a <kbd>Notification</kbd> class that we will use to represent the notification resource. Open the <kbd>service/service.py</kbd> file created previously and add the following lines. The code file for the sample is included in the ...</p></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring resource routing and endpoints</h1>
                </header>
            
            <article>
                
<p>We must make the necessary resource routing configurations to call the appropriate methods and pass them all the necessary arguments by defining URL rules. The following lines create the main entry point for the application, initialize it with a Flask application, and configure the resource routing for the service. Open the previously created <kbd>service/service.py</kbd> file and add the following lines. The code file for the sample is included in the <kbd>restful_python_2_01_01</kbd> folder, in the <kbd>Flask01/service/service.py</kbd> file:</p>
<pre>app = Flask(__name__) 
service = Api(app) 
service.add_resource(NotificationList, '/service/notifications/') 
service.add_resource(Notification, '/service/notifications/&lt;int:id&gt;', endpoint='notification_endpoint') 
 
 
if __name__ == '__main__': 
    app.run(debug=True) </pre>
<p>The code creates an instance of the <kbd>flask_restful.Api</kbd> class and saves it in the <kbd>service</kbd> variable. Each call to the <kbd>service.add_resource</kbd> method routes a URL to a resource, specifically to one of the previously declared subclasses of the <kbd>flask_restful.Resource</kbd> superclass. When there is a request to the service and the URL matches one of the URLs specified in the <kbd>service.add_resource</kbd> method, Flask will call the method that matches the HTTP verb in the request for the specified class. The method follows standard Flask routing rules.</p>
<p>For example, the following line will make an HTTP <kbd>GET</kbd> request to <kbd>/service/notifications/</kbd> without any additional parameters to call the <kbd>NotificationList.get</kbd> method:</p>
<pre>service.add_resource(NotificationList, '/service/notifications/') </pre>
<p>Flask will pass the URL variables to the called method as arguments. For example, the following line will make an HTTP <kbd>GET</kbd> request to <kbd>/service/notifications/26</kbd> to call the <kbd>Notification.get</kbd> method, with <kbd>26</kbd> passed as the value for the <kbd>id</kbd> argument:</p>
<pre>service.add_resource(Notification, '/service/notifications/&lt;int:id&gt;', endpoint='notification_endpoint')</pre>
<p>In addition, we can specify a string value for the endpoint argument to make it easy to reference the specified route in the <kbd>fields.Url</kbd> fields. We pass the same endpoint name, <kbd>'notification_endpoint'</kbd>, as an argument in the <kbd>uri</kbd> field declared as <kbd>fields.Url</kbd> in the <kbd>notification_fields</kbd> dictionary that we use to render each <kbd>NotificationModel</kbd> instance. This way, <kbd>fields.Url</kbd> will generate a URI that considers this route.</p>
<p>We just required a few lines of code to configure resource routing and endpoints. The last line just calls the <kbd>app.run</kbd> method to start the Flask application, with the <kbd>debug</kbd> argument set to <kbd>True</kbd> to enable debugging. In this case, we start the application by calling the <kbd>run</kbd> method to immediately launch a local server. We could also achieve the same goal by using the <kbd>flask</kbd> command-line script. However, this option would require us to configure environment variables and the instructions are different for the platforms that we are covering in this book: macOS, Windows, and Linux.</p>
<div class="packt_tip">As with any other web framework, you should never enable debugging in a production environment.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP requests to the Flask API</h1>
                </header>
            
            <article>
                
<p>Now, we can run the <kbd>service/service.py</kbd> script that launches Flask's development server to compose and send HTTP requests to our unsecured and simple web API (we will definitely add security later). Execute the following command. Make sure you have the virtual environment activated:</p>
<pre>    <strong>python service/service.py</strong></pre>
<p>The following lines show the output after we execute the previous command. The development server is listening at port <kbd>5000</kbd>:</p>
<pre>    <strong> * Serving Flask app "service" (lazy loading)</strong>
    <strong> * Environment: production</strong>
    <strong>   WARNING: Do not use the development server in a production environment.</strong>
    <strong>   Use a production WSGI server instead.</strong>
    <strong> * Debug mode: on</strong>
    <strong> * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</strong>
    <strong> * Restarting ...</strong></pre></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with the curl and httpie command-line tools</h1>
                </header>
            
            <article>
                
<p>We will start with command-line tools. One of the key advantages of command-line tools is that we can easily run again the HTTP requests after we build them for the first time, and we don't need to use the mouse or to tap the screen to run requests. We can also easily build a script with batch requests and run them. As happens with any command-line tool, it can take more time to perform the first requests compared with GUI tools, but it becomes easier once we've performed many requests and we can easily reuse the commands we have written in the past to compose new requests.</p>
<p><strong>Curl</strong>, also known as <strong>cURL</strong>, is a very popular open source command-line tool and library that allows us to easily transfer data. We can use the <kbd>curl</kbd> command-line tool to easily compose and send HTTP requests and check their responses.</p>
<p>In macOS or Linux, you can open a Terminal and start using <kbd>curl</kbd> from the command line.</p>
<p>In Windows, you can work with <kbd>curl</kbd> in the Command Prompt or you can install <kbd>curl</kbd> as part of the Cygwin package installation option and execute it from the Cygwin terminal. In case you decide to use the <kbd>curl</kbd> command within the Command Prompt, download and unzip the latest version at <a href="http://curl.haxx.se/download.html"><span class="URLPACKT">http://curl.haxx.se/download.html</span></a>. Then, make sure you include the folder in which the <kbd>curl.exe</kbd> file is included in your path to make it easy to run the command.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>You can read more about the Cygwin terminal and its installation procedure at <a href="http://cygwin.com/install.html"><span class="URLPACKT">http://cygwin.com/install.html</span></a>. In case you decide to use the Cygwin terminal, use it whenever you have to run the <kbd>curl</kbd> command instead of working with the Command Prompt.</p>
<div class="packt_tip">Notice that Windows PowerShell includes the <kbd>curl</kbd> alias that calls the <kbd>Inovoke-WebRequest</kbd> command. Thus, in case you decide to work with Windows PowerShell, you will have to remove the <kbd>curl</kbd> alias to use the <kbd>curl</kbd> utility we use in this book.</div>
<p>We used the <kbd>requirements.txt</kbd> file to install the packages for our virtual environment. In this file, we specified <kbd>httpie</kbd> as one of the required packages. This way, we installed <strong>HTTPie</strong>, a command-line HTTP client written in Python that makes it easy to send HTTP requests and uses a syntax that is easier than <kbd>curl</kbd>. One of the great advantages of HTTPie is that it displays colorized output and uses multiple lines to display the response details. Thus, HTTPie makes it easier to understand the responses than the <kbd>curl</kbd> utility. However, it is very important to mention that HTTPie is slower than <kbd>curl</kbd>.</p>
<div class="packt_tip">Whenever we compose HTTP requests with the command line, we will use two versions of the same command: the first one with HTTPie, and the second one with <kbd>curl</kbd>. This way, you will be able to use the one that is most convenient for you.</div>
<p>Make sure you leave the Flask development server running. Don't close the Terminal or Command Prompt that is running this development server. Open a new Terminal in macOS or Linux, or a Command Prompt in Windows, and run the following command. It is very important that you enter the ending slash (<kbd>/</kbd>) when specified because <kbd>/service/notifications</kbd> won't match any of the configured URL routes. Thus, we must enter <kbd>/service/notifications/</kbd>, including the ending slash (<kbd>/</kbd>). We will compose and send an HTTP request to create a new notification. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd01.txt</kbd> file:</p>
<pre><strong>http POST ":5000/service/notifications/" message='eSports competition starts in 2 minutes' ttl=20 notification_category='Information'</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. It is very important to use the <kbd>-H "Content-Type: application/json"</kbd> option to tell <kbd>curl</kbd> to send the data specified after the <kbd>-d</kbd> option as <kbd>application/json</kbd> instead of the default <kbd>application/x-www-form-urlencoded</kbd> option.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd02.txt</kbd> file:</p>
<pre><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"eSports competition starts in 2 minutes", "ttl":20, "notification_category": "Information"}' "localhost:5000/service/notifications/"</strong></pre>
<p>The previous commands will compose and send the <kbd>POST http://localhost:5000/service/notifications/</kbd> HTTP request with the following JSON key-value pairs:</p>
<pre>{  
   "message": "eSports competition starts in 2 minutes",  
   "ttl": 20,  
   "notification_category": "Information" 
} </pre>
<p>The request specifies <kbd>/service/notifications/</kbd> and, therefore, it will match <kbd>'/service/notifications/'</kbd> and run the <kbd>NotificationList.post</kbd> method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <kbd>POST</kbd>, Flask calls the <kbd>post</kbd> method. If the new <kbd>NotificationModel</kbd> was successfully persisted in the dictionary, the function returns an HTTP <kbd>201 Created</kbd> status code and the recently persisted <kbd>NotificationModel</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <kbd>NotificationModel</kbd> object in the JSON response:</p>
<pre>    <strong>HTTP/1.0 201 CREATED</strong>
    <strong>Content-Length: 283</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 10 Oct 2018 01:01:44 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong>
    
    <strong>{</strong>
    <strong>    "creation_date": "Wed, 10 Oct 2018 01:01:44 -0000",</strong>
    <strong>    "displayed_once": false,</strong>
    <strong>    "displayed_times": 0,</strong>
    <strong>    "id": 1,</strong>
    <strong>    "message": "eSports competition starts in 2 minutes",</strong>
    <strong>    "notification_category": "Information",</strong>
    <strong>    "ttl": 20,</strong>
    <strong>    "uri": "/service/notifications/1"</strong>
    <strong>}</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>We will compose and send an HTTP request to create another notification. Go back to the Command Prompt in Windows, or the Terminal in macOS or Linux, and run the following command. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd03.txt</kbd> file:</p>
<pre><strong>http POST ":5000/service/notifications/" message='Ambient temperature is above the valid range' ttl=15 notification_category='Warning'</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd04.txt</kbd> file:</p>
<pre><strong>curl -iX POST -H "Content-Type: application/json" -d '{"message":"Ambient temperature is above the valid range", "ttl":15, "notification_category": "Warning"}' "localhost:5000/service/notifications/"</strong>
  </pre>
<p>The previous commands will compose and send the <kbd>POST http://localhost:5000/service/notifications/</kbd> HTTP request with the following JSON key-value pairs:</p>
<pre>{  
   "message": "Ambient temperature is above the valid range",  
   "ttl": 15,  
   "notification_category": "Warning" 
} </pre>
<p>The following lines show an example response for the HTTP request, with the new <kbd>NotificationModel</kbd> object in the JSON response:</p>
<pre>    <strong>HTTP/1.0 201 CREATED</strong>
    <strong>Content-Length: 280</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 10 Oct 2018 21:07:40 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong>
    
    <strong>{</strong>
    <strong>    "creation_date": "Wed, 10 Oct 2018 21:07:40 -0000",</strong>
    <strong>    "displayed_once": false,</strong>
    <strong>    "displayed_times": 0,</strong>
    <strong>    "id": 2,</strong>
    <strong>    "message": "Ambient temperature is above valid range",</strong>
    <strong>    "notification_category": "Warning",</strong>
    <strong>    "ttl": 15,</strong>
    <strong>    "uri": "/service/notifications/2"</strong>
    <strong>}</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>We will compose and send an HTTP request to retrieve all the notifications. Go back to the Command Prompt in Windows, or the Terminal in macOS or Linux, and run the following command. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd05.txt</kbd> file:</p>
<pre>    <strong>http ":5000/service/notifications/"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd06.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:5000/service/notifications/"</strong></pre>
<p>The previous commands will compose and send the <kbd>GET http://localhost:5000/service/notifications/</kbd> HTTP request. The request specifies <kbd>/service/notifications/</kbd> and, therefore, it will match <kbd>'/service/notifications/'</kbd> and run the <kbd>NotificationList.get</kbd> method. The method doesn't receive arguments because the URL route doesn't include any parameters. As the HTTP verb for the request is <kbd>GET</kbd>, Flask calls the <kbd>get</kbd> method. The method retrieves all the <kbd>NotificationModel</kbd> objects and generates a JSON response with all of these <kbd>NotificationModel</kbd> objects serialized.</p>
<p>The following lines show an example response for the HTTP request. The first lines show the HTTP response headers, including the status (<kbd>200 OK)</kbd> and the content type (<kbd>application/json</kbd>). After the HTTP response headers, we can see the details for the two <kbd>NotificationModel</kbd> objects in the JSON response:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Content-Length: 648</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 10 Oct 2018 21:09:43 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong>
    
    <strong>[</strong>
    <strong>    {</strong>
    <strong>        "creation_date": "Wed, 10 Oct 2018 21:07:31 -0000",</strong>
    <strong>        "displayed_once": false,</strong>
    <strong>        "displayed_times": 0,</strong>
    <strong>        "id": 1,</strong>
    <strong>        "message": "eSports competition starts in 2 minutes",</strong>
    <strong>        "notification_category": "Information",</strong>
    <strong>        "ttl": 20,</strong>
    <strong>        "uri": "/service/notifications/1"</strong>
    <strong>    },</strong>
    <strong>    {</strong>
    <strong>        "creation_date": "Wed, 10 Oct 2018 21:07:40 -0000",</strong>
    <strong>        "displayed_once": false,</strong>
    <strong>        "displayed_times": 0,</strong>
    <strong>        "id": 2,</strong>
    <strong>        "message": "Ambient temperature is above valid range",</strong>
    <strong>        "notification_category": "Warning",</strong>
    <strong>        "ttl": 15,</strong>
    <strong>        "uri": "/service/notifications/2"</strong>
    <strong>    }</strong>
    <strong>]</strong>
  </pre>
<p>After we run the three requests, we will see the following lines in the window that is running the Flask development server. The output indicates that the service received three HTTP requests, specifically two <kbd>POST</kbd> requests and one <kbd>GET</kbd> request with <kbd>/service/notifications/</kbd> as the URI. The service processed the three HTTP requests, and returned the <kbd>201</kbd> status code for the first two requests and <kbd>200</kbd> for the last request:</p>
<pre><strong>127.0.0.1 - - [10/Oct/2018 18:07:31] "POST /service/notifications/ HTTP/1.1" 201 -</strong>
<strong>127.0.0.1 - - [10/Oct/2018 18:07:40] "POST /service/notifications/ HTTP/1.1" 201 -</strong>
<strong>127.0.0.1 - - [10/Oct/2018 18:09:43] "GET /service/notifications/ HTTP/1.1" 200 -</strong>
  </pre>
<p>The following screenshot shows two Terminal windows side by side on macOS. The Terminal window on the left-hand side is running the Flask development server and displays the received and processed HTTP requests. The Terminal window on the right-hand side is running <kbd>http</kbd> commands to generate the HTTP requests. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/d02d1b9f-018b-4800-9f1b-1ba875372560.png" width="1212" height="825"/></div>
<p>Now, we will compose and send an HTTP request to retrieve a notification that doesn't exist. For example, in the previous list, there is no notification with an <kbd>id</kbd> value equal to <kbd>78</kbd>. Run the following command to try to retrieve this notification. Make sure you use an <kbd>id</kbd> value that doesn't exist. We must make sure that the utilities display the headers as part of the response to see the returned status code. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd07.txt</kbd> file:</p>
<pre>    <strong>http ":5000/service/notifications/78"</strong> </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd08.txt</kbd> file:</p>
<pre>    <strong>curl -iX GET "localhost:5000/service/notifications/78"</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>The previous commands will compose and send the <kbd>GET http://localhost:5000/service/notifications/78</kbd> HTTP request. The request is the same as the previous one we analyzed, with a different number for the <kbd>id</kbd> parameter. The service will run the <kbd>Notification.get</kbd> method, with <kbd>78</kbd> as the value for the <kbd>id</kbd> argument. The method will execute the code that retrieves the <kbd>NotificationModel</kbd> object whose ID matches the <kbd>id</kbd> value received as an argument. However, the first line in the <kbd>NotificationList.get</kbd> method calls the <kbd>abort_if_notification_not_found</kbd> method, which won't find the ID in the dictionary keys, and it will call the <kbd>flask_restful.abort</kbd> function because there is no notification with the specified <kbd>id</kbd> value. Thus, the code will return an HTTP <kbd>404 Not Found</kbd> status code. The following lines show an example header response for the HTTP request and the message included in the body. In this case, we just leave the default message. Of course, we can customize it based on our specific needs:</p>
<pre>    <strong>HTTP/1.0 404 NOT FOUND</strong>
    <strong>Content-Length: 155</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Wed, 10 Oct 2018 21:24:32 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong>
    
    <strong>{</strong>
    <strong>    "message": "Notification 78 not found. You have requested this     <br/>    URI [/service/notifications/78] but did you mean <br/>    /service/notifications/&lt;int:id&gt; ?"</strong>
    <strong>}</strong>
  </pre>
<p>We provide an implementation for the <kbd>PATCH</kbd> method to make it possible for our API to update a single field for an existing resource. For example, we can use the <kbd>PATCH</kbd> method to update two fields for an existing notification and set the value for its <kbd>displayed_once</kbd> field to <kbd>true</kbd> and <kbd>displayed_times</kbd> to <kbd>1</kbd>. We don't want to use the <kbd>PUT</kbd> method because this method is meant to replace an entire notification.</p>
<div class="packt_tip">The <kbd>PATCH</kbd> method is meant to apply a delta to an existing notification and, therefore, it is the appropriate method to just change the value of the <kbd>displayed_once</kbd> and <kbd>displayed_times</kbd> fields.</div>
<p>Now, we will compose and send an HTTP request to update an existing notification, specifically, to update the value of two fields. Make sure you replace <kbd>2</kbd> with the ID of an existing notification in your configuration. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd09.txt</kbd> file:</p>
<pre><strong>http PATCH ":5000/service/notifications/2" displayed_once=true <br/>displayed_times=1</strong>
  </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd10.txt</kbd> file:</p>
<pre><strong>curl -iX PATCH -H "Content-Type: application/json" -d '{"displayed_once":"true", "displayed_times":1}' "localhost:5000/service/notifications/2"</strong>
  </pre>
<p>The previous command will compose and send a <kbd>PATCH</kbd> HTTP request with the specified JSON key-value pairs. The request has a number after <kbd>/service/notifications/</kbd> and, therefore, it will match <kbd>'/service/notifications/&lt;int:id&gt;'</kbd> and run the <kbd>Notification.patch</kbd> method, that is, the <kbd>patch</kbd> method for the <kbd>Notification</kbd> class. If a <kbd>NotificationModel</kbd> instance with the specified ID exists and was successfully updated, the call to the method will return an HTTP <kbd>200 OK</kbd> status code and the recently updated <kbd>NotificationModel</kbd> instance serialized to JSON in the response body. The following lines show a sample response:</p>
<pre><strong>HTTP/1.0 200 OK 
Content-Length: 279 
Content-Type: application/json 
Date: Thu, 11 Oct 2018 02:15:13 GMT 
Server: Werkzeug/0.14.1 Python/3.7.1 
 
{ 
    "creation_date": "Thu, 11 Oct 2018 02:15:05 -0000", 
    "displayed_once": true, 
    "displayed_times": 1, 
    "id": 2, 
    "message": "Ambient temperature is above valid range", 
    "notification_category": "Warning", 
    "ttl": 15, 
    "uri": "/service/notifications/2" 
}</strong> </pre>
<div class="packt_tip">The IoT device will execute the previously explained HTTP request when it displays the notification for the first time. Then, it will make additional <kbd>PATCH</kbd> requests to update the value for the <kbd>displayed_times</kbd> field.</div>
<p>Now, we will compose and send an HTTP request to delete an existing notification, specifically, the last one we added. As happened in our last HTTP requests, we have to check the value assigned to <kbd>id</kbd> in the previous response and replace <kbd>2</kbd> in the command with the returned value. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd11.txt</kbd> file:</p>
<pre>    <strong>http DELETE ":5000/service/notifications/2"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. The code file for the sample is included in the <kbd>restful_python_2_01_02</kbd> folder, in the <kbd>Flask01/cmd12.txt</kbd> file:</p>
<pre>    <strong>curl -iX DELETE "localhost:5000/service/notifications/2"</strong></pre>
<p>The previous commands will compose and send the <kbd>DELETE http://localhost:5000/service/notifications/2</kbd> HTTP request. The request has a number after <kbd>/service/notifications/</kbd> and, therefore, it will match <kbd>'/service/notifications/&lt;int:id&gt;'</kbd> and run the <kbd>Notification.delete</kbd> method, that is, the <kbd>delete</kbd> method for the <kbd>Notification</kbd> class. If a <kbd>NotificationModel</kbd> instance with the specified ID exists and was successfully deleted, the call to the method will return an HTTP <kbd>204 No Content</kbd> status code. The following lines show a sample response:</p>
<pre>    <strong>HTTP/1.0 204 NO CONTENT</strong>
    <strong>Content-Length: 3</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Thu, 11 Oct 2018 02:22:09 GMT</strong>
    <strong>Server: Werkzeug/0.14.1 Python/3.7.1</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Working with GUI tools – Postman and others</h1>
                </header>
            
            <article>
                
<p>So far, we have been working with two terminal-based, or command-line, tools to compose and send HTTP requests to our Flask development server: cURL and HTTPie. Now, we will work with a <strong>GUI</strong> (short for <strong>Graphical User Interface</strong>) tool.</p>
<p>Postman is a very popular API testing suite GUI tool that allows us to easily compose and send HTTP requests, among other features. Postman is available as a Chrome App and as a Macintosh App. We can execute it in Windows, Linux, and macOS as a native app. You can download the versions of the Postman app at <a href="https://www.getpostman.com/apps"><span class="URLPACKT">https://www.getpostman.com/apps</span></a>.</p>
<div class="packt_tip">You can download and install Postman for free to compose and send HTTP requests to our RESTful APIs. You just need to sign up to ...</div></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Consuming the API with other programming languages</h1>
                </header>
            
            <article>
                
<p>We've built our first RESTful Web Service that is capable of running as a microservice with Flask and Python. We can consume the API with any modern programming language that can compose and send HTTP requests to the resources and verbs supported by the API and work <span>easily </span>with JSON content.</p>
<p>It is extremely important to make sure that we set the content type for the HTTP request as we did when working with the <kbd>curl</kbd> and <kbd>http</kbd> command-line utilities. We just need to check which is the most convenient way of doing so in the programming language that we have to use as a client.</p>
<p>The fact that we can easily run a Flask development server and check its console output whenever a new request is processed makes it easy to check which requests arrive at the server. In this case, we are working with a basic and unsecured API. However, we will work with secure and more advanced APIs in the forthcoming chapters.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>HTTPie is a:
<ol>
<li>Command-line HTTP server written in Python that makes it easy to create a RESTful Web Server</li>
<li>Command-line utility that allows us to run queries against a SQLite database</li>
<li>Command-line HTTP client written in Python that makes it easy to compose and send HTTP requests</li>
</ol>
</li>
</ol>
<ol start="2">
<li>Flask-RESTful uses which of the following as the main building block for a RESTful API:
<ol>
<li>Resources built on top of Flask pluggable views</li>
<li>Statuses built on top of Flask resource views</li>
<li>Resources built on top of Flask pluggable controllers</li>
</ol>
</li>
</ol>


<ol start="3">
<li>To process an HTTP <kbd>PATCH</kbd> request on a resource, which method should we declare in a subclass of <kbd>flask_restful.Resource</kbd>?
<ol>
<li><kbd>patch_restful ...</kbd></li></ol></li></ol></article></section></div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we designed a RESTful API to interact with a simple dictionary that acted as a data repository and performed CRUD operations with notifications, to be used as a baseline for a microservice. We defined the requirements for our API and understood the tasks performed by each HTTP method. We set up a virtual environment with Flask and Flask-RESTful. We followed best practices to generate a reproducible virtual environment.</p>
<p>We created a model to represent and persist notifications. We learned how to configure the serialization of notifications into JSON representations with the features included in Flask-RESTful. We wrote classes that represent resources and process the different HTTP requests, and we configured the URL patterns to route URLs to classes.</p>
<p>Finally, we started the Flask development server and we used command-line tools to compose and send HTTP requests to our RESTful API and analyzed how each HTTP requests was processed in our code. We also worked with many useful GUI tools to compose and send HTTP requests.</p>
<p>Now that we understand the basics of the combination of Flask and Flask-RESTful to create RESTful APIs that we can encapsulate in microservices, in the next chapter, we will expand the capabilities of the RESTful Web API by taking advantage of the advanced features included in Flask-RESTful and related ORMs.</p>


            </article>

            
        </section>
    </div>



  </body></html>