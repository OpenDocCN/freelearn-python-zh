- en: Essential RESTful API Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provides both the concepts and code examples of common and fundamental
    design patterns of the RESTful API so that you can pick up these examples and
    replicate and power their RESTful API services.
  prefs: []
  type: TYPE_NORMAL
- en: As design patterns provide generic, time-tested, proven, and reusable solutions
    to familiar yet recurring design problems, API design patterns are essential for
    software designers to learn and adapt in their RESTful API applications. API design
    patterns provide a description or templates to solve specific, recurring API design
    problems that any software architects and API designers would like to adopt in
    their API designs. Adopting patterns provides much flexibility to developers and
    helps them focus on business logic implementation and deliver the service with
    high quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this chapter, we will learn the following common yet essential API
    design patterns, along with a few sample pieces of code as well. However, please
    note that there is no specific order to the following patterns and each pattern
    addresses the RESTful constraints. We also need to ensure that these essential
    patterns are accounted and ingrained as needed for our API designs and implementation
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URI templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design for intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discoverability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error and exception logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will take a plunge into the code and samples, and a few pattern implementations
    in this chapter, the readers are expected to have a Java programming language
    and understand the basic concepts of Java 1.8\. Our examples are implemented with
    Spring Boot and we have provided instructions to download and run the sample codes
    anywhere. However, for those who want to execute and test the code samples provided
    in this chapter, they may need to have the basic and necessary understanding of
    data formats such as JSON and XML, and also have a basic understanding of a Maven
    build process and client-server or web services development.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the GitHub link for this chapter: [https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git).[ ](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices.git)
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code to run in your computer, you need Java 8, Spring 4 (1.4.4), and
    Maven 3.x. Please follow the following instructions to get started. The following
    are the prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 1.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your favorite IDE (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start with, please download or clone the samples from GitHub. There are various
    online help resources available in case anyone needs help in downloading the samples
    to their local machines.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with the installations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't have JDK or Maven installed in your environment yet, you may want
    to install it now by following their respective installation instructions. We
    need Maven installed on our machines, and we can run the program with IDEs as
    well. The following instructions cover how to run these samples with Windows command-line,
    along with the maven command line.
  prefs: []
  type: TYPE_NORMAL
- en: If you need Maven installation instructions, please follow the link and steps
    defined in the installation document. The Maven installation guide is available
    at [https://maven.apache.org/install.html](https://maven.apache.org/install.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section provides instructions on how to run the examples of this
    chapter, along with screenshots that the author was able to set up and run in
    his Windows-based laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the build script from [Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/buildMyExamples.bat](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/buildMyExamples.bat).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the downloaded `buildMyExample.bat` script in your Windows Command Prompt
    and observe your output, which should be similar to what you can see in the following
    screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d40a8af4-84ea-4596-9bd5-16caaf99956e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Download the run script from [Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/scripts/runMyExamples.bat](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/runMyExamples.bat).
    Observe the following screenshot and match it with your Windows command-line output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/28f94f2a-1a74-4c7c-a51b-2d2bee315512.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once your local server has started, you can download the sample Postman collections
    for this book from the following GitHub link: [https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json](https://github.com/PacktPublishing/Hands-On-RESTful-API-Design-Patterns-and-Best-Practices/blob/master/scripts/book-examples.postman_collection.json).
    Import the collection to your local Postman tool, then run the mentioned examples
    in this chapter and witness the results in your Postman as you see in the following
    screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/41d14f24-6cec-45f9-b738-1bc4dc5363d2.png)'
  prefs: []
  type: TYPE_IMG
- en: If you need help on installing Postman, you may find this link useful: [https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/](https://learning.getpostman.com/docs/postman/launching_postman/installation_and_updates/).
    If you need help importing the Postman collections to your local Postman installation,
    you may find this link useful: [https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data](https://learning.getpostman.com/docs/postman/collections/data_formats/#exporting-and-importing-postman-data).
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with RESTful API patterns – part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the most common and necessary REST services design patterns
    to aid API designers and developers in API development in various domains. The
    design patterns included in this section are as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URI templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design for intent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discoverability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error and exception logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Statelessness refers to servers being free from application states, that is,
    the states that are stored at the server side and help to identify the client's
    requests, client's last interaction details, and their current context information.
  prefs: []
  type: TYPE_NORMAL
- en: The REST architecture enforces the server *not* to maintain any client states
    at the server side and insists on statelessness between the server and the calling
    client. Any API developer certainly does not want to store state information at
    the application server side. So, the application server should always be designed
    as state-free (in most cases).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s observe a few responsibilities for both the client and server so that
    we can achieve statelessness:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Client** | **Server** |'
  prefs: []
  type: TYPE_TB
- en: '| A client should provide all necessary information to the server as part of
    its request to the server. | The server understands the client''s request and
    should include all the necessary information as a response that a client needs
    to create a session on its side. |'
  prefs: []
  type: TYPE_TB
- en: '| Session states should entirely be managed and kept at the client side. |
    The server does not store the client state and doesn''t rely on its stored context.
    |'
  prefs: []
  type: TYPE_TB
- en: '| The client is responsible for storing and handling all its states and sends
    state information to the server whenever it is needed. | No session affinity or
    session stickiness on the server is to be maintained. |'
  prefs: []
  type: TYPE_TB
- en: To comply with RESTful constraints, and for the service to be genuinely stateless,
    the servers don't even store the authentication/authorization information of the
    client and make clients provide credentials with their request. So, each request
    is understood separately by the server and there is no impact on the current request
    due to previous requests from the same clients.
  prefs: []
  type: TYPE_NORMAL
- en: In our chapter code example, we can observe that none of our requests and responses
    are associated with/carry any state information and they are entirely independent.
    Even in later sections when we will develop authentication examples, our code
    will still evolve and maintain statelessness across its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'For stateless constraints, how do we code? Spring Boot''s REST API framework
    provides out-of-the-box implementation; our responsibility as a developer is to
    ensure we follow URI constraints and provide the necessary implementation for
    the URI. In the following code snippet from our example, `InvestorController.java`,
    we have a URI (`/investors/{investorId}/stocks` ) defined for fetching the stock
    of an investor by the investor ID; that''s all—we do not have any specific implementation,
    session validation, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As the path element doesn't have any indications of state, and the code expects
    an `investorId` along with a few other parameters, our implementation is fulfilling
    the stateless constraints. This will be more interesting when we deal with authentication
    (also with statelessness) in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also observe the necessities and a few advantages of enforcing statelessness
    in RESTful services through the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Advantages** | **Details** |'
  prefs: []
  type: TYPE_TB
- en: '| Scalability | Achieve scalability by having server code that''s been deployed
    to multiple servers so that any server can handle any requests as there is no
    session stickiness/affinity to be maintained by the server. This occurs since
    the client''s requests will have all the necessary information in each request
    for to the server manage. |'
  prefs: []
  type: TYPE_TB
- en: '| Reduced complexity | There is reduced complexity as the server can get rid
    of server-side state synchronization logic and implementations (leads to simplified
    application design). |'
  prefs: []
  type: TYPE_TB
- en: '| Easy cache-ability, so improved performance | The intermediate software can
    cache the results of specific HTTP requests by looking at the client''s requests.
    Also, there are no uncertainties and concerns about the state information of the
    previous requests. |'
  prefs: []
  type: TYPE_TB
- en: '| Traceability | The server never loses track of where each client is in the
    application as the client requests themselves have all the necessary information.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Best use of HTTP/HTTPS | As HTTP itself is a stateless protocol. REST implementation
    becomes seamless with HTTP protocols (it adheres well to REST constraints). |'
  prefs: []
  type: TYPE_TB
- en: Content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resources in the RESTful APIs need to deal with different type of representations—not
    just XML or **JavaScript Object Notation** (**JSON**), as different clients may
    need different representations. In fact, as we build our complex APIS, we may
    find that XML/JSON is too limiting, and we may need to move to another type of
    content in an entirely different format (Instagram and Flickr use JPEG and PNG
    images, while media houses use MP3/MP4), and that's how we get to content negotiation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Content-negotiation** is a mechanism or process that services and clients
    can select as their resources representation format for their communication and
    handshakes during their usual course of communication.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml), *Design
    Strategy, Guidelines, and Best Practices*, in the *HTTP headers* section, the
    HTTP specification comes up with a set of standard headers, through which the
    client can get information about a requested resource and carry the messages that
    indicate its representations.
  prefs: []
  type: TYPE_NORMAL
- en: So, for content negotiation, REST services need to use HTTP headers; that is,
    when the client makes requests, it includes the accepts header, the list of file
    types that the client and server can handle with no additional steps to the client
    requests, the server processes, and replies.
  prefs: []
  type: TYPE_NORMAL
- en: If the response representation selection is determined at the server-side, then
    it is server-driven negotiation or proactive negotiation using request-headers.
    If the same selection is at the client side, then it is agent-driven content negotiation
    or reactive negotiation using distinct a URI. For most practical purposes, server-side
    negotiations are more complex and lead to make many assumptions about client requirements.
    So, most of the REST API implementations follow agent-driven content negotiations
    that rely on the HTTP request headers or resource URI patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a quick and live example of content negotiation by going to
    the following link: [http://www.w3.org/StyleSheets/TR/logo-REC](http://www.w3.org/StyleSheets/TR/logo-REC).
    Observe that logo-REC is an image file; however, it does not have any file extension
    (that is, w3.org serving images without a file suffix), and the log-REC is not
    just one file, but two—`loge-REC.gif` and `logo-REC.png`. So, with content-negotiation
    the w3.org server serves two different files. The following screenshot explains
    a bit more about the request and response headers for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d792f267-caa2-472d-b23c-e5e38478daf2.png)'
  prefs: []
  type: TYPE_IMG
- en: Please observe the highlighted pieces from the preceding screenshot. The URL
    path, [http://www.w3.org/StyleSheets/TR/logo-REC](http://www.w3.org/StyleSheets/TR/logo-REC),
    does not say any file extension; however, in the response headers, observe the
    **content-location** and the **content-type** as `image/png`. The highlighted
    rectangles are quick examples of some of the content negotiation. Also please
    observe reactive negotiation through the request header accept.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into the details about content negotiation and the way the services/clients
    use them in the following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: Content negotiation with HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our earlier example, we have seen that the server understands the content-types
    of incoming requests and entities with HTTP request header content-types.
  prefs: []
  type: TYPE_NORMAL
- en: In our code example, we have implemented the following content type and, by
    default `application/JSON`, and to represent what content type that the client
    desired to get, we use `application/JSON`  as the Accept header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that if no Accept header is present in the request, the server
    will send a pre-configured default representation type. In our example, it is
    always `application/JSON`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8cc437e-5741-4487-91eb-e2c1aa9fda2a.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot depicts the Content-Type and Accept headers from our
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to implement our earlier example of a w3c image within our investor
    service application  in a similar fashion, all we need to do is add the following
    dependency to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `@GetMapping` annotation in the controller class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, by using the accept request header, the client either gets the response
    as XML or as JSON. Cool, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'With Postman, we will get either a XML or JSON response according to the `application/XML`
    or `application/JSON` Accept header value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9587bcd8-1b89-49d5-b386-e154834fbaa8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Two other ways that we can pass the content type information to the server
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using specific extensions in resource URIs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://xxx.api.com/v1/students/course.xml](https://xxx.api.com/v1/students/course.xml)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://xxx.api.com/v1/students/courses.json](https://xxx.api.com/v1/students/courses.json)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using parameters for representing an extension:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://xxx.api.com/v1/students/course?forrmat=xml](https://xxx.api.com/v1/students/course?forrmat=xml)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://xxx.api.com/v1/students/courses?forrmat=json](https://xxx.api.com/v1/students/courses?forrmat=json)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table provides a quick reference guide of a few other content-negotiation
    examples as server and client may need to deal with many other aspects of content-negotiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Content-Negotiation** | **Implementation** |'
  prefs: []
  type: TYPE_TB
- en: '| Indicate client preference—allows clients to indicate their capabilities
    (such as media types and languages) | `Accept:application/json,application/xml;q=0.9,*/*;q=0.8``(support
    json or xml, q -> preference order)` |'
  prefs: []
  type: TYPE_TB
- en: '| Implement media type—how to decide which media type to use for representation
    in a response | According to the Accept header from the client (Accept: `application/atom+xml`),
    the server can respond with a content-type, that is, `Content-Type: application/atom+xml`; `charset=UTF-8`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Implement character encoding—know what character encoding to use for textual
    representations in responses | `Content-Type: charset=UTF-8` (use content-type
    charset) |'
  prefs: []
  type: TYPE_TB
- en: '| Support compression—know when to enable the compression of representations
    | # Request `Accept-Encoding: gzip`# Response `Content-Encoding: gzip Vary: Accept-Encoding`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Send Vary header—know how to use the Vary header to indicate to clients how
    the server chooses a particular representation | # Response `Content-Language:
    en Vary: Accept-Language` |'
  prefs: []
  type: TYPE_TB
- en: '| Handling negotiation failures—know whether to serve a default representation
    or return an error | # Request`Accept: application/json,*/*;q=0.0` (client cannot
    process anything other than JSON)# Response`406 Not Acceptable` (the server returns
    an error code as it does not support JSON. `@GetMapping` our chapter examples
    throws this error when the client expects only an XML responses as our example
    serves the JSON and not XML, except for one—a `GET` mapping)Link: `<http://www.example.org/errors/mediatypes.html>`;`rel="help"`{`"message":
    "This server does not support JSON. See help for alternatives."`} (additional
    help) |'
  prefs: []
  type: TYPE_TB
- en: URI templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction
    to the Basics of RESTful Architecture,* a**Uniform Resource** **Identifier** (**URI**)
    is often used to identify a specific resource within a common space of similar
    resources. For instance, if we pick up the Star Wars API example from [Chapter
    1](ce158181-8265-4afb-b858-348cc775d6d8.xhtml), *Introduction to the Basics of
    RESTful Architecture*, the films resource is represented by the URIs [https://swapi.co/api/films/2](https://swapi.co/api/films/2), [https://swapi.co/api/films/3](https://swapi.co/api/films/3),
    and so on. It is always the case that the client may need to include some additional
    information in their request, and how the server lets the client include that
    information about resources in the URIs. Server-side developers require the ability
    to describe the layout of the URIs that their services will respond to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this is URI templates. URI templates provide a way to describe
    a set of resources as variables. So, let''s observe the following table with our
    more general examples before we move on go to this chapter''s code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resources** | **URI templates** |'
  prefs: []
  type: TYPE_TB
- en: '| People: [https://swapi.co/api/people/](https://swapi.co/api/people/)Planets:
    [https://swapi.co/api/planets/](https://swapi.co/api/planets/)Films: [https://swapi.co/api/films/](https://swapi.co/api/films/)Species:
    [https://swapi.co/api/species/](https://swapi.co/api/species/) | `https://swapi.co/api/{resource_id}/`
    |'
  prefs: []
  type: TYPE_TB
- en: '| [https://swapi.co/api/films/2/](https://swapi.co/api/films/2/)[https://swapi.co/api/films/6/](https://swapi.co/api/films/6/)
    | `https://swapi.co/api/{resource_id1}/{resource_id2}` |'
  prefs: []
  type: TYPE_TB
- en: So, it is clear that if we need to define the URI template for the preceding
    list with variables or resource identifiers, we need to provide those variables
    within curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will see examples from the code implementation of this chapter which
    have been picked up from the investor-service controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `@GetMapping("/investors/{investorId}/stocks")``@GetMapping("/investors/{investorId}/stocks/{symbol}")`
    | The client would need to send an investor ID and a stock symbol for `GET` |'
  prefs: []
  type: TYPE_TB
- en: '| `@DeleteMapping("/investors/{investorId}/stocks/{symbol}")` | The client
    would need to send an investor ID and a stock symbol for `Delete` |'
  prefs: []
  type: TYPE_TB
- en: 'The`@PathVariable` annotation of spring boot does the magic of applying the
    URI template for the resources that the client needs. Please take note of the
    following code snippet from our code (`InvestorController.java`) as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `@PathVariable` annotation provided by Spring Boot help us implement the
    URI template pattern in our code seamlessly. As we can see, `investorId` and the
    symbol variables are picked up as parameters by our methods.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that there are other REST frameworks that do a good job and provide
    out-of-the-box URI templating.
  prefs: []
  type: TYPE_NORMAL
- en: Design for intent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine our car getting repaired without even taking it to an automobile service
    centre. A few years back, Tesla, the car manufacturing company, famously did that
    when it issued an over-the-air repair to their cars. Tesla's software got updated
    to detect charging problems and help decrease the charging rates (cascading effect)
    to avoid overheating and hence avoid engine fires.
  prefs: []
  type: TYPE_NORMAL
- en: Design for intent is a term that's used in structural and automobile fields
    for parameterized changes, and we will learn how it benefits REST API services
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Design for intent is a method that expresses the different relationships between
    objects so that changes to one object automatically propagates changes to others.
    In Tesla's case, the decreased number of charging cycles (cascading effect) helped
    to avoid overheating of the engine.
  prefs: []
  type: TYPE_NORMAL
- en: In a RESTful API world, the API should be developed to ensure they meet the
    requirements of the use cases, provided and faced by the users, but without exposing
    the internal business objects. Design for intent is a strategic design pattern
    that's intended to influence or result in specific and additional user behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To relate the design for intent implementation within our investor service
    example, we should provide the mechanism to update the investor''s portfolio automatically
    whenever the new (type) stocks get added to the investor object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/701f6963-a5cf-45ae-aa21-dd2f7e67d290.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, the intention of the API is to add
    a new stock; however, it should have a cascading effect on the investor's portfolio
    as well—maybe a new stock type should get added, the total number of stocks needs
    to be updated, and so on. This is abstract to the app developer. The same applies
    when stocks are deleted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please recollect the granularity of APIs discussion from [Chapter 2](edae86df-d90e-4b4c-9ada-4de80edaef71.xhtml),
    *Design Strategy, Guidelines, and Best Practices*, as choosing the right granularity
    of APIs plays a vital role in the design for intent strategy. In this chapter''s
    example, we have provided a simple update method for adding the stock types to
    the investor''s portfolio, and readers are encouraged to develop more functionalities
    as part of this pattern ensures having the right granularity (coarse-grained versus
    fine-grained) of APIs for the update and delete stock types within an investor''s
    portfolio. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74b87bb0-0108-4c6d-adbc-5cc5fb182bca.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot and code is the sample implementation (code snippets)
    that we can see in `InvestorService.java`. This also shows a console message when
    the `Delete` and `Add` APIs are called with the Postman tool.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a client tries to fetch a list of objects that run into pages, we have
    to think about how the server can manage to serve the clients with such a massive
    response without hampering its performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pagination** is a concept that helps in serving only part of the data as
    a response, however, with information about how to access all the data from the
    server, page by page, without much load and high computation for the server to
    serve the whole data.'
  prefs: []
  type: TYPE_NORMAL
- en: Should we consider a page (of results) as a resource or just a representation
    of resources? Considering the page as a representation and not as a resource is
    what we are going to discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: As we decided pagination is a resource representation, we will include the pagination
    information as part of the URI query, that is, `xxx.api.com/stocks?page=2`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that pagination as part of the URI path is not an option (as we
    consider that it is not a resource but resource representation), that is, `xxx.api.com/stocks/page/2`,
    as we may not be able to uniquely find the resource between calls.
  prefs: []
  type: TYPE_NORMAL
- en: One problem that we need to solve in the case of pagination for URI queries
    is encoding, and we can use the standard way of encoding the paging information
     to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into the code, let's have a look at some better API pagination
    examples in the industry and a few pagination types as well.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook's API uses offset and limit (`fields=id`, `message& amp;limit=5`),
    linkedIn uses start and count (`.../{service}?start=10&count=10`), and Twitter
    uses records per page or count (`api.twitter.com/2/accounts/abc1/campaigns?cursor=c-3yvu1pzhd3i7&count=50`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three variants of resource representation ways of pagination, and
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Offset-based**: When a client needs responses based on page count and page
    number. For example, `GET /investor/{id}/stocks?offset=2&limit=5 (returns stocks
    2 through 7 )`**.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time-based**: When a client needs responses between a specified timeframe
    and can have a limit as well as part of the parameter to represent the max number
    of results per page. For example, `GET /investor/{id}/stocks?since=xxxxxx&until=yyyyy`
    `(returns stocks between a given dates)`*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cursor-based**: A technique where a pointer (a built-in bookmark with breadcrumbs)
    reference of the remaining data is served a specific subset of data as a response
    and is let off. However, the rest of the data is still needed for later requests
    until the cursor reaches the end of the records. For example, `GET slack.com/api/users.list?limit=2&token=xoxp-1234-5678-90123`.
    The following code explains this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0047d1f-8cca-42d8-b2cd-97129061ee0e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding blocks shows offset-based pagination implementation within our
    investor service code. We will implement and touch upon other pagination methods,
    along with sorting and filtering in the next chapter when we discuss versioning
    and other patterns involving a database.
  prefs: []
  type: TYPE_NORMAL
- en: Discoverability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have discussed in the earlier chapter, API developers are the raison d'être
    of APIs. Helping them find the right APIs and helping them figure out programmatically
    whether the site that's being accessed has an API enabled or not will be the most
    critical responsibility of the API.
  prefs: []
  type: TYPE_NORMAL
- en: The primary step to connect with a site is to find out if the site is API enabled
    by simple URLs that are be using as user input to help us verify the API's availability.
    They also help us find out how to access them.
  prefs: []
  type: TYPE_NORMAL
- en: Discoverability of the API is all about the descriptive capability of the server
    to instruct the client on the usage of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the two types of discoverability in the following section and
    their implementation in our code examples (as screenshots):'
  prefs: []
  type: TYPE_NORMAL
- en: '**By valid HTTP methods**: When clients call REST services with invalid HTTP
    methods, the response of that request should end up in the `405` HTTP error code;
    that is, `405 Method Not Allowed`. In addition to the error code, the response
    header should provide flexibility to the client to find the supported methods
    that allow headers in its response. The code for this is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db97037f-37e9-4eca-ba46-7b0a3ab7032d.png)'
  prefs: []
  type: TYPE_IMG
- en: '**By providing the URI of the newly created resource**: Including the URI as
    part of the location header as the response to the newly created resource is another
    method of discoverability. The returned URI as a location will be available through
    `GET`. The code for it is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a65b4b72-7c56-46a8-8bff-b5a1af3e4a06.png)'
  prefs: []
  type: TYPE_IMG
- en: Please note that, as our examples are using spring boot, we are leveraging the
    capabilities of spring boot's seamless and out-of-the-box implementations for
    discoverability (with `@GetMapping`, the servlets URI components builder, and
    so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'One more type of discoverability (yet to be standardized, though) can be implemented
    through valid link headers. While responding to the client''s particular resources
    through `GET`, you must provide the client with clues about what they can do next
    as well; that is, providing a list of all available resources as a list through
    the link header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eacff5f9-49e7-4ca5-ac31-51f758a4e1d1.png)'
  prefs: []
  type: TYPE_IMG
- en: As a live example of discoverability, the preceding screenshot depicts one of
    Google's APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Error and exception logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we keep on emphasizing when we discuss the importance of API developers when
    it comes to the consumption of our services, error handling and exception handling
    should be taken care of without any compromises. Services are the black boxes
    to the API developers, and therefore service providing errors and exceptions provide
    clients with a clear context and visibility to use our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take some real-world and very popular APIs and how they are handling
    these errors in a sample error scenario. This is shown in the following table.
    We will also look at the way we handle these errors and exceptions within our
    investor service code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **APIs** | **HTTP code** | **Sample message** | **Remarks** |'
  prefs: []
  type: TYPE_TB
- en: '| Facebook | `200` | `{"type":"OAUTH exception","message":"...."}` | Note that `200`
    indicates success. However, the API decides to send an error message as a response
    and still provide a success (`200`) code for an API call. |'
  prefs: []
  type: TYPE_TB
- en: '| Twilio | `401` | `{"status":401,"message":"Authenticate","code":"...."..}`
    | Leverages the existing HTTP code as it is. |'
  prefs: []
  type: TYPE_TB
- en: '| InvestorService | `405` | `{"Status":405,"error":"Method Not Allowed"....`
    | Leverages the existing HTTP code as it is. |'
  prefs: []
  type: TYPE_TB
- en: 'We also have a sample implementation of a custom exception class called `InvestorNotFoundException`
    in our sample repository. The code snippet and output sample (from Postman) is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1fe1000-aba7-4237-a270-23baef5c0a6b.png)'
  prefs: []
  type: TYPE_IMG
- en: From our earlier examples, we can observe we have done a fair job regarding
    managing errors and exceptions with existing HTTP standard error codes. However,
    we can go further by providing more customized errors and messages to the caller;
    for instance, it would be more proper for the caller to receive a `404` error
    instead of a `500` error. Maybe we will implement a few customized error messages
    in the next chapter while we build some more patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple yet powerful way to make our API support multiple languages is to enable
    the API to support Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicode** is an encoding standard that support an international character
    set. It has a unique number for every character across multiple languages including
    Chinese, Korean, and Arabic and their scripts. The unique number makes almost
    all characters identifiable and accessible across platforms, programs, and devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in short, we can simplify our REST API that supports multiple languages
    by supporting Unicode as part of their headers. The following code depicts this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68bf55e0-448a-48e2-a53c-b31382c485bd.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the code snippet of the (`InvestorController.java`)
    accept-encoding charset in the header and the Postman results for the same.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a sense of our hands dealing with real code examples of statelessness,
    content-negotiation practices, URI templates definitions, service design for intent,
    discoverability, and a type of pagination. Then, we discussed error and exception
    handling in detail before finally concluded with a Unicode implementation for
    internationalization (supporting multiple languages with our services).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter should be an excellent start for anyone who wants to get their
    hands on the RESTful services; not just the basics, but the essential patterns
    as well. In the next chapter, we will see more advanced pattern implementation
    and examples to enable our readers to increasingly utilize best practices and
    implementations.
  prefs: []
  type: TYPE_NORMAL
