- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: String Matching Algorithms
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串匹配算法
- en: 'There are many popular string matching algorithms. String matching algorithms
    have very important applications, such as searching for an element in a text document,
    plagiarism detection, text editing programs, and so on. In this chapter, we will
    study the pattern matching algorithms that find the locations of a given pattern
    or substring in any given text. We will discuss the **brute force algorithm**,
    along with the **Rabin-Karp**, **Knuth-Morris-Pratt** (**KMP**), and **Boyer-Moore
    pattern matching algorithms**. This chapter aims to discuss algorithms that are
    related to strings. The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多流行的字符串匹配算法。字符串匹配算法有非常重要的应用，例如在文本文档中搜索元素、抄袭检测、文本编辑程序等。在本章中，我们将研究寻找给定模式或子串在任意给定文本中的位置的模式匹配算法。我们将讨论**暴力算法**，以及**Rabin-Karp**、**Knuth-Morris-Pratt**（**KMP**）和**Boyer-Moore**模式匹配算法。本章旨在讨论与字符串相关的算法。本章将涵盖以下主题：
- en: Learning pattern matching algorithms and their implementation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习模式匹配算法及其实现
- en: Understanding and implementing the **Rabin-Karp pattern matching algorithm**
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现**Rabin-Karp**模式匹配算法
- en: Understanding and implementing the **Knuth-Morris-Pratt** (**KMP**) **algorithm**
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现**Knuth-Morris-Pratt**（**KMP**）算法
- en: Understanding and implementing the **Boyer-Moore pattern matching algorithm**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现**Boyer-Moore**模式匹配算法
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All of the programs based on the concepts and algorithms discussed in this
    chapter are provided in the book as well as in the GitHub repository at the following
    link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的概念和算法的所有程序都包含在书中，以及以下链接的 GitHub 仓库中：[https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Third-Edition/tree/main/Chapter13)。
- en: String notations and concepts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串表示法和概念
- en: Strings are sequences of characters. Python provides a rich set of operations
    and functions that can be applied to the string data type. Strings are textual
    data and are handled very efficiently in Python. The following is an example of
    a string `(s)`—`"packt publishing"`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符序列。Python 提供了一组丰富的操作和函数，可以应用于字符串数据类型。字符串是文本数据，在 Python 中处理得非常高效。以下是一个字符串
    `(s)` 的示例——“`packt publishing`"。
- en: A substring is a sequence of characters that’s part of the given string, i.e.,
    specified indices in the string in a continuous order. For example, “`packt`"
    is a substring of the string “`packt publishing`". On the other hand, a subsequence
    is also a sequence of characters that can be obtained from the given string by
    removing some of the characters from the string by keeping the order of occurrence
    of the characters. For example, “`pct pblishing`" is a valid subsequence for the
    string “`packt publishing`" that is obtained by removing the characters `a`, `k`,
    and `u`. However, this is not a substring since “`pct pblishing`" is not a continuous
    sequence of characters. Hence, a subsequence is different from a substring, and
    it can be considered a generalization of substrings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 子串是指给定字符串中字符序列的一部分，即字符串中连续顺序的指定索引。例如，“`packt`" 是字符串 “`packt publishing`" 的子串。另一方面，子序列也是从给定字符串中通过删除一些字符（同时保持字符出现的顺序）得到的字符序列。例如，“`pct
    pblishing`" 是从字符串 “`packt publishing`" 中删除字符 `a`、`k` 和 `u` 后得到的有效子序列。然而，这并不是子串，因为
    “`pct pblishing`" 不是一个连续的字符序列。因此，子序列与子串不同，它可以被认为是子串的推广。
- en: The prefix `(p)` is a substring of the string `(s)` in that it is present at
    the start of the string. There is also another string `(u)` that exists in the
    string `(s)` after the prefix. For example, the substring “`pack`" is a prefix
    for the string `(s) = "packt publishing"` as it is the starting substring and
    there is another substring `u = "publishing"` after it. Thus, the prefix plus
    string `(u)` makes “`packt publishing`", which is the whole string.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀 `(p)` 是字符串 `(s)` 的子串，因为它位于字符串的开头。在字符串 `(s)` 中也存在另一个字符串 `(u)`，它在前缀之后。例如，子串
    “`pack`" 是字符串 `(s) = "packt publishing"` 的前缀，因为它是最初的子串，并且在其后还有另一个子串 `u = "publishing"`。因此，前缀加上字符串
    `(u)` 构成了 “`packt publishing`"，这就是整个字符串。
- en: 'The suffix `(d)` is a substring that is present at the end of the string `(s)`.
    For example, the substring “`shing`" is one of the many possible suffixes for
    the string “`packt publishing`". Python has built-in functions to check whether
    a string starts or ends with a specific string, as shown in the following code
    snippet:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀（`d`）是出现在字符串（`s`）末尾的子字符串。例如，子字符串“`shing`”是字符串“`packt publishing`”的许多可能后缀之一。Python有内置函数可以检查字符串是否以特定字符串开始或结束，如下面的代码片段所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the above code is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the above example of the given string, we can see that the given text string
    ends with another substring “`publisher`", which is a valid suffix, and that also
    has another substring “`this`", which is a substring of the string start and is
    also a valid prefix.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述给定的字符串示例中，我们可以看到给定的文本字符串以另一个子字符串“`publisher`”结尾，这是一个有效的后缀，并且还有一个子字符串“`this`”，它是字符串的开始部分的一个子字符串，也是一个有效的前缀。
- en: Note that the pattern matching algorithms discussed here are not to be confused
    with the matching statements of Python 3.10\.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里讨论的模式匹配算法不要与Python 3.10的匹配语句混淆。
- en: Pattern matching algorithms are the most important string processing algorithms
    and we will discuss them in the subsequent sections, starting with pattern matching
    algorithms.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配算法是最重要的字符串处理算法，我们将在后续章节中讨论它们，从模式匹配算法开始。
- en: Pattern matching algorithms
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配算法
- en: A pattern matching algorithm is used to determine the index positions where
    a given pattern string (`P`) is matched in a text string (`T`). Thus, the pattern
    matching algorithm finds and returns the index where a given string pattern appears
    in a text string. It returns `"pattern not found"` if the pattern does not have
    a match in the text string.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配算法用于确定给定模式字符串（`P`）在文本字符串（`T`）中匹配的索引位置。因此，模式匹配算法找到并返回给定字符串模式在文本字符串中出现的索引。如果模式在文本字符串中没有匹配项，则返回`"pattern
    not found"`。
- en: 'For example, for the given text string `(s) = "packt publisher"` and the pattern
    string `(p) = "publisher"`, the pattern-matching algorithm returns the index position
    where the pattern string is matched in the text string. An example of a string
    matching problem is shown in *Figure 13.1*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于给定的文本字符串`(s) = "packt publisher"`和模式字符串`(p) = "publisher"`，模式匹配算法返回模式字符串在文本字符串中匹配的索引位置。一个字符串匹配问题的示例如图*13.1*所示：
- en: '![](img/B17217_13_01.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_01.png)'
- en: 'Figure 13.1: An example of a string matching problem'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1：字符串匹配问题的示例
- en: We will discuss four pattern matching algorithms, that is, the brute force method,
    Rabin-Karp algorithm, and the **Knuth-Morris-Pratt** (**KMP**) and Boyer-Moore
    pattern-matching algorithms. We start with the brute force pattern matching algorithm.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论四种模式匹配算法，即贪心方法、Rabin-Karp算法，以及**Knuth-Morris-Pratt**（**KMP**）和Boyer-Moore模式匹配算法。我们首先从贪心模式匹配算法开始。
- en: The brute force algorithm
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪心算法
- en: The brute force algorithm is also called the naive approach to pattern matching
    algorithms. Naive approach means that it is a very basic and simple algorithm.
    In this approach, we match all the possible combinations of the input pattern
    in the given text string to find the position of the occurrence of the pattern.
    This algorithm is very naive and is not suitable if the text is very long.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法也被称为模式匹配算法的朴素方法。朴素方法意味着它是一个非常基础且简单的算法。在这种方法中，我们在给定的文本字符串中匹配所有可能的输入模式的组合，以找到模式出现的位置。这个算法非常朴素，如果文本非常长，则不适合使用。
- en: In this algorithm, we start by comparing the characters of the pattern string
    and the text string one by one, and if all the characters of the pattern are matched
    with the text, we return the index position of the text where the first character
    of the pattern is located. If any character of the pattern is mismatched with
    the text string, we shift the pattern by one position to check if the pattern
    appears at the next index position. We continue comparing the pattern and text
    string by shifting the pattern by one index position.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，我们首先逐个比较模式字符串和文本字符串中的字符，如果模式的所有字符都与文本匹配，我们就返回文本中模式第一个字符所在的位置索引。如果模式中的任何字符与文本字符串不匹配，我们就将模式向右移动一个位置，以检查模式是否出现在下一个索引位置。我们通过将模式向右移动一个索引位置来继续比较模式和文本字符串。
- en: 'To better understand how the brute force algorithm works, let’s look at an
    example. Suppose we have a text string `(T)` = “**acbcabccababcaacbcac**”, and
    the pattern string `(P)` is “**acbcac**”. Now, the objective of the pattern matching
    algorithm is to determine the index position of the pattern string in the given
    text, `T`, as shown in *Figure 13.2*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解暴力算法的工作原理，让我们看一个例子。假设我们有一个文本字符串`(T)` = “**acbcabccababcaacbcac**”，模式字符串`(P)`是“**acbcac**”。现在，模式匹配算法的目标是在给定的文本`T`中确定模式字符串的索引位置，如图*13.2*所示：
- en: '![](img/B17217_13_02.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_02.png)'
- en: 'Figure 13.2: An example of the brute force algorithm for string matching'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2：字符串匹配的暴力算法示例
- en: We start by comparing the first character of the text, that is, **a**, and the
    first character of the pattern. Here, the initial five characters of the pattern
    are matched, and then there is a mismatch in the last character of the pattern.
    This is a mismatch, so we shift the pattern by one place. We again start comparing
    the first character of the pattern and the second character of the text string
    one by one. Here, character **c** of the text string does not match with the character
    **a** of the pattern. So, this is also a mismatch, and we shift the pattern by
    one space, as shown in *Figure 13.2*. We continue comparing the characters of
    the pattern and the text string until we traverse the whole text string. In this
    example, we find a match at index position `14`, which is shown in *Figure 13.2*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先比较文本的第一个字符，即**a**，和模式的第一个字符。在这里，模式的前五个字符被匹配，然后在模式的最后一个字符处出现不匹配。这是一个不匹配，因此我们将模式向右移动一个位置。我们再次从比较模式的第一个字符和文本字符串的第二个字符开始逐个比较。在这里，文本字符串中的字符**c**与模式的字符**a**不匹配。因此，这也是一个不匹配，我们将模式向右移动一个空格，如图*13.2*所示。我们继续比较模式和文本字符串中的字符，直到我们遍历整个文本字符串。在这个例子中，我们在索引位置`14`找到一个匹配，如图*13.2*所示。
- en: 'Let’s consider the Python implementation of the brute force algorithm for pattern
    matching:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑模式匹配的暴力算法的Python实现：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the above function call is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数调用输出如下：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code for the brute force approach, we start by computing the
    length of the given text strings and pattern. We also initialize the looping variables
    with `0` and set the flag to `False`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的暴力方法代码中，我们首先计算给定文本字符串和模式的长度。我们还用`0`初始化循环变量，并将标志设置为`False`。
- en: This variable is used to continue searching for a match of the pattern in the
    string. If the `flag` variable is `False` by the end of the text string, it means
    that there is no match for the pattern at all in the text string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量用于在字符串中继续搜索模式的匹配。如果`flag`变量在文本字符串结束时为`False`，则意味着在文本字符串中根本找不到模式的匹配。
- en: 'Next, we start the searching loop from the `0`^(th) index to the end of the
    text string. In this loop, we have a `count` variable that is used to keep track
    of the length up to which the pattern and the text have been matched. Next, we
    have another nested loop that runs from the `0`^(th) index to the length of the
    pattern. Here, the variable `i` keeps track of the index position in the text
    string and the variable `j` keeps track of the characters in the pattern. Next,
    we compare the characters of the patterns and the text string using the following
    code fragment:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从文本字符串的`0`^(th)索引开始搜索循环，直到文本字符串的末尾。在这个循环中，我们有一个`count`变量，用于跟踪模式和文本匹配到的长度。接下来，我们有一个嵌套循环，从`0`^(th)索引运行到模式的长度。在这里，变量`i`跟踪文本字符串中的索引位置，变量`j`跟踪模式中的字符。接下来，我们使用以下代码片段比较模式和文本字符串中的字符：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Furthermore, we increment the `count` variable after every match of the character
    of the pattern in the text string. Then, we continue matching the characters of
    the pattern and text string. If the length of the pattern becomes equal to the
    `count` variable, it means there is a match.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在文本字符串中模式字符的每次匹配后增加`count`变量。然后，我们继续匹配模式和文本字符串中的字符。如果模式的长度等于`count`变量，则表示有一个匹配。
- en: We print the index position of the text string if there is a match for the pattern
    string in the text string and keep the `flag` variable as to `True` as we wish
    to continue searching for more matches of the patterns in the text string. Finally,
    if the value of the variable `flag` is `False`, it means that there was not a
    match for the pattern in the text string at all.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在文本字符串中找到与模式字符串匹配的索引位置，我们将打印文本字符串的索引位置，并将`flag`变量保持为`True`，因为我们希望继续在文本字符串中搜索更多模式的匹配。最后，如果`flag`变量的值为`False`，则表示在文本字符串中根本找不到该模式的匹配。
- en: The best-case and worst-case time complexities for the naive string matching
    algorithms are `O(n)` and `O(m*(n-m+1))`, respectively. The best-case scenario
    occurs when the pattern is not found in the text and the first character of the
    pattern is not present in the text at all, for example, if the text string is
    `ABAACEBCCDAAEE`, and the pattern is `FAA`. Here, as the first character of the
    pattern will not find a match anywhere in the text, it will have comparisons equal
    to the length of the text (`n`).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串匹配算法的最佳和最坏情况时间复杂度分别为`O(n)`和`O(m*(n-m+1))`。最佳情况发生在模式在文本中找不到，并且模式的第一个字符根本不在文本中，例如，如果文本字符串是`ABAACEBCCDAAEE`，而模式是`FAA`。在这里，由于模式的第一个字符将在文本的任何地方都找不到匹配项，它将进行的比较等于文本的长度（`n`）。
- en: The worst-case scenario occurs when all characters of the text string and the
    pattern are the same and we want to find out all the occurrences of the given
    pattern string in the text string, for example, if the text string is `AAAAAAAAAAAAAAAA`,
    and the pattern string is `AAAA`. Another worst-case scenario occurs when only
    the last character is different, for example, if the text string is `AAAAAAAAAAAAAAAF`
    and the pattern is `AAAAF`. Thus, the total number of comparisons will be `m*(n-m+1)`
    and the worst-case time complexity will be `O(m*(n-m+1))`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况发生在文本字符串和模式的全部字符都相同，并且我们想要找出文本字符串中给定模式字符串的所有出现，例如，如果文本字符串是`AAAAAAAAAAAAAAAA`，而模式字符串是`AAAA`。另一个最坏情况发生在只有最后一个字符不同，例如，如果文本字符串是`AAAAAAAAAAAAAAAF`，而模式是`AAAAF`。因此，比较的总数将是`m*(n-m+1)`，最坏情况时间复杂度将是`O(m*(n-m+1))`。
- en: Next, we discuss the Rabin-Karp pattern matching algorithm.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论Rabin-Karp模式匹配算法。
- en: The Rabin-Karp algorithm
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rabin-Karp算法
- en: The Rabin-Karp pattern matching algorithm is an improved version of the brute
    force approach to find the location of the given pattern in the text string. The
    performance of the Rabin-Karp algorithm is improved by reducing the number of
    comparisons with the help of hashing. We discussed the concept of hashing in *Chapter
    8*, *Hash Tables*. The hashing function returns a unique numeric value for a given
    string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp模式匹配算法是寻找给定模式在文本字符串中位置的暴力方法的改进版本。通过哈希减少比较次数来提高Rabin-Karp算法的性能。我们在*第8章*，*哈希表*中讨论了哈希的概念。哈希函数为给定的字符串返回一个唯一的数值。
- en: This algorithm is faster than the brute force approach as it avoids unnecessary
    comparisons. In this algorithm, we compare the hash value of the pattern with
    the hash value of the substring of the text string. If the hash values are not
    matched, the pattern is shifted forward one position. This is a better algorithm
    as compared to the brute-force algorithm since there is no need to compare all
    the characters of the pattern one by one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与暴力方法相比，此算法更快，因为它避免了不必要的比较。在此算法中，我们比较模式与文本字符串子字符串的哈希值。如果哈希值不匹配，则将模式向前移动一个位置。与暴力算法相比，这是一个更好的算法，因为不需要逐个比较模式的全部字符。
- en: This algorithm is based on the concept that if the hash values of the two strings
    are equal, then it is assumed that both the strings are also equal. However, it
    is also possible that there can be two different strings whose hash values are
    equal. In that case, the algorithm will not work; this situation is known as a
    spurious hit and happens due to a collision in hashing. To avoid this with the
    Rabin-Karp algorithm, after matching the hash values of the pattern and the substring,
    we ensure that the pattern is actually matched in the string by comparing the
    pattern and the substring character by character.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法基于以下概念：如果两个字符串的哈希值相等，则假设这两个字符串也相等。然而，也可能存在两个不同的字符串，它们的哈希值相等。在这种情况下，算法将不起作用；这种情况被称为虚假匹配，是由于哈希中的冲突引起的。为了避免这种情况，在Rabin-Karp算法中，在匹配模式和子字符串的哈希值之后，我们通过逐字符比较模式和子字符串来确保模式实际上在字符串中匹配。
- en: 'The Rabin-Karp pattern matching algorithm works as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp 模式匹配算法的工作原理如下：
- en: First, we preprocess the pattern before starting the search, that is, we compute
    the hash value of the pattern of length `m` and the hash values of all the possible
    substrings of the text of length `m`. The total number of possible substrings
    would be (`n-m+1`). Here, `n` is the length of the text.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们在开始搜索之前对模式进行预处理，即计算长度为 `m` 的模式及其所有可能的长度为 `m` 的文本子串的哈希值。可能的子串总数将是 (`n-m+1`)。在这里，`n`
    是文本的长度。
- en: We compare the hash value of the pattern with the hash value of the substrings
    of the text one by one.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们逐个比较模式与文本子串的哈希值。
- en: If the hash values are not matched, then we shift the pattern by one position.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果哈希值不匹配，则我们将模式向右移动一个位置。
- en: If the hash value of the pattern and the hash value of the substring of the
    text match, then we compare the pattern and substring character by character to
    ensure that the pattern is actually matched in the text.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果模式和文本子串的哈希值匹配，则我们逐字符比较模式和子串，以确保模式实际上在文本中匹配。
- en: We continue the process of *steps 2-5* until we reach the end of the given text
    string.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续执行 *步骤 2-5* 的过程，直到达到给定文本字符串的末尾。
- en: In this algorithm, we compute the numerical hash values using Horner’s rule
    (any other hashing function can also be used) that returns a unique value for
    the given string. We also compute the hash value using the sum of the ordinal
    values of all the characters of the string.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在此算法中，我们使用霍纳法则（任何其他哈希函数也可以使用）计算数值哈希值，该法则为给定字符串返回一个唯一值。我们还使用字符串中所有字符的序数值之和来计算哈希值。
- en: 'Let’s consider an example to understand the **Rabin-Karp algorithm**. Let’s
    say we have a text string `(T) = "publisher paakt packt"`, and the pattern `(P)
    = "packt"`. First, we compute the hash values of the pattern (length `m`) and
    all the substrings (of length `m`) of the text string. The functionality of the
    **Rabin-Karp algorithm** is shown in *Figure 13.3*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解 **Rabin-Karp 算法**。假设我们有一个文本字符串 `(T) = "publisher paakt packt"`，以及模式
    `(P) = "packt"`。首先，我们计算模式（长度 `m`）和文本字符串的所有子串（长度 `m`）的哈希值。**Rabin-Karp 算法** 的功能在
    *图 13.3* 中展示：
- en: '![](img/B17217_13_03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_03.png)'
- en: 'Figure 13.3: An example of the Rabin-Karp algorithm for string matching'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：Rabin-Karp 字符串匹配算法的示例
- en: We start comparing the hash value of the pattern `"packt"` with the first substring
    `"publi"`. Since the hash values do not match, we shift the pattern by one position,
    and then we compare the hash value of pattern with the hash value of the next
    substring of the text, i.e. `"ublis"`. As these hash values also do not match,
    we again shift the pattern by one position. We shift the pattern by one position
    at a time if the hash values do not match. And, if the hash value of the pattern
    and the hash value of the substring match, we compare the pattern and substring
    character by character and we return the location of the text string if they match.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始比较模式 `"packt"` 的哈希值与第一个子串 `"publi"` 的哈希值。由于哈希值不匹配，我们将模式向右移动一个位置，然后我们比较模式与文本的下一个子串的哈希值，即
    `"ublis"`。由于这些哈希值也不匹配，我们再次将模式向右移动一个位置。如果哈希值不匹配，我们每次移动一个位置。如果模式和子串的哈希值匹配，我们逐字符比较模式和子串，并在它们匹配时返回文本字符串的位置。
- en: In the example shown in *Figure 13.3*, hash values of the pattern and the substring
    of the text are matched at location `17`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 13.3* 所示的示例中，模式和文本子串的哈希值在位置 `17` 匹配。
- en: It is important to note that there can be a different string whose hash value
    can match with the hash of the pattern, i.e. a spurious hit.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，可能存在不同的字符串，其哈希值可以与模式的哈希值匹配，即虚假匹配。
- en: Next, let us discuss the implementation of the **Rabin-Karp pattern matching
    algorithm**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论 **Rabin-Karp 模式匹配算法** 的实现。
- en: Implementing the Rabin-Karp algorithm
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Rabin-Karp算法
- en: 'The implementation of the **Rabin-Karp algorithm** is done in two steps:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rabin-Karp 算法** 的实现分为两个步骤：'
- en: We implement the `generate_hash()` method, which is used to compute the hash
    value of the pattern and all the possible combinations of the substrings of length
    equal to the length of the pattern.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了 `generate_hash()` 方法，用于计算模式及其所有可能的长度等于模式长度的子串组合的哈希值。
- en: We implement the **Rabin-Karp algorithm**, which uses the `generate_hash()`
    method to identify the substring whose hash value matches the hash value of the
    pattern. Finally, we match them character by character to ensure we have correctly
    found the pattern.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们实现了 **Rabin-Karp 算法**，该算法使用 `generate_hash()` 方法来识别与模式哈希值匹配的子字符串。最后，我们逐字符匹配它们以确保正确找到了模式。
- en: Let us first discuss the implementation of generating hash values for the patterns
    and substrings of the text. For this, we need to first decide on the hash function.
    Here, we use the sum of all the ordinal values of all the characters of the string
    as the hashing function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论生成模式和文本子字符串的哈希值的实现。为此，我们首先需要决定哈希函数。在这里，我们使用字符串中所有字符的序数值之和作为哈希函数。
- en: 'The complete Python implementation to compute the hashing values is given below:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Python 实现来计算哈希值如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the above code, we start by storing the ordinal values of all the characters
    of the text and the pattern in the `ord_text` and `ord_pattern` variables. Next,
    we store the length of the text and the pattern in the `len_text` and `len_pattern`
    variables.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先将文本和模式的全部字符的序数值存储在 `ord_text` 和 `ord_pattern` 变量中。接下来，我们将文本和模式的长度存储在
    `len_text` 和 `len_pattern` 变量中。
- en: 'Next, we create a variable called `len_hash_array` that stores the number of
    all the possible substrings of length (equal to the length of the pattern) using
    `len_text - len_pattern + 1`, and we create an array called `hash_text` that stores
    the hash value for all the possible substrings. This is shown in the following
    code snippet:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `len_hash_array` 的变量，它存储了长度（等于模式的长度）的所有可能子字符串的数量，使用 `len_text -
    len_pattern + 1`，并且我们创建一个名为 `hash_text` 的数组，它存储了所有可能子字符串的哈希值。这在上面的代码片段中显示：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we compute the hash value for the pattern by summing up the ordinal values
    of all the characters in the pattern using the following code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过以下代码片段计算模式的哈希值，即通过求模式中所有字符的序数值之和：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we start a loop that executes for all the possible substrings of the
    text. For this, initially, we compute the hash value for the first substring by
    summing the ordinal values of all of its characters using `sum(ord_text[:len_pattern])`.
    Further, the hash values for all of the substrings are computed using the hash
    value of the previous substrings as shown in the following code snippet:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始一个循环，该循环对文本的所有可能子字符串执行。为此，最初，我们通过使用 `sum(ord_text[:len_pattern])` 求所有字符的序数值来计算第一个子字符串的哈希值。进一步，使用前一个子字符串的哈希值来计算所有子字符串的哈希值，如以下代码片段所示：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, we have precomputed the hash values for the pattern and all the substrings
    of the text that we will use for comparing the pattern and the text in the implementation
    of the **Rabin-Karp algorithm**. The **Rabin-Karp algorithm** works as follows.
    Firstly, we compare the hash values of the pattern and substrings of the text.
    Next, we take the substring for which the hash matches with the hash of the pattern
    and compare them both character by character.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 **Rabin-Karp 算法** 的实现中预先计算了模式的哈希值和文本的所有子字符串的哈希值，这些我们将用于比较模式和文本。**Rabin-Karp
    算法**的工作原理如下。首先，我们比较模式和文本子字符串的哈希值。接下来，我们取与模式哈希值匹配的子字符串，并逐字符比较它们。
- en: 'The complete Python implementation of the **Rabin-Karp algorithm** is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rabin-Karp 算法**的完整 Python 实现如下所示：'
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the above code, firstly, we convert the given text and pattern into string
    format as the ordinal values can only be computed for strings. Next, we use the
    `generate_hash` function to compute the hash values of patterns and texts. We
    store the length of the text and patterns in the `len_text` and `len_pattern`
    variables. We also initialize the `flag` variable to `False` so that it keeps
    track of whether the pattern is present in the text at least once.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，首先，我们将给定的文本和模式转换为字符串格式，因为只有字符串才能计算序数值。然后，我们使用 `generate_hash` 函数来计算模式和文本的哈希值。我们在
    `len_text` 和 `len_pattern` 变量中存储文本和模式的长度。我们还初始化 `flag` 变量为 `False`，以便跟踪模式是否至少在文本中出现一次。
- en: Next, we start a loop that implements the main concept of the algorithm. This
    loop executes for the length of `hash_text`, which is the total number of possible
    substrings. Initially, we compare the hash value of the first substring with the
    hash of the pattern by using `if hash_text[i] == hash_pattern`. If they do not
    match; we move one index position and look for another substring. We iteratively
    move further until we get a match.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动一个循环，该循环实现了算法的主要概念。这个循环执行`hash_text`的长度，即可能的子字符串总数。最初，我们通过使用`if hash_text[i]
    == hash_pattern`比较第一个子字符串的哈希值与模式的哈希值。如果它们不匹配，我们移动一个索引位置并寻找另一个子字符串。我们迭代地移动，直到我们得到一个匹配项。
- en: If we find a match, we compare the substring and the pattern character by character
    through a loop by using `if pattern[j] == text[i+j]`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到一个匹配项，我们通过使用`if pattern[j] == text[i+j]`通过循环逐个字符比较子字符串和模式。
- en: 'We then create a `count` variable to keep track of how many characters match
    in the pattern and the substring. If the length of the count and the length of
    the pattern are equal, this means that all of the characters match, and the index
    location where the pattern was found is returned. Finally, if the `flag` variable
    remains `False`, this means that the pattern does not match at all with the text.
    The following code snippets can be used to execute the **Rabin-Karp matching algorithm**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`count`变量来跟踪模式与子字符串匹配的字符数量。如果`count`的长度与模式的长度相等，这意味着所有字符都匹配，并且返回模式被找到的索引位置。最后，如果`flag`变量保持`False`，这意味着模式与文本完全不匹配。以下代码片段可以用来执行**Rabin-Karp匹配算法**：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the above code is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above code, we first check whether the pattern “`1011`" appears in the
    given text string “`101110000011010010101101`". The output shows that the given
    pattern occurs at index position `0` and `18`. Next, the pattern “`ACCE`" occurs
    at index position `11` in the text string “`ABBACCADABBACCEDF`".
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先检查模式“`1011`"是否出现在给定的文本字符串“`101110000011010010101101`"中。输出显示，给定模式出现在索引位置`0`和`18`。接下来，模式“`ACCE`"在文本字符串“`ABBACCADABBACCEDF`"中的索引位置`11`出现。
- en: The Rabin-Karp pattern matching algorithm preprocesses the pattern before the
    searching; that is, it computes the hash value for the pattern that has the complexity
    of `O(m)`. Also, the worst-case running time complexity of the Rabin-Karp algorithm
    is `O(m *(n-m+1))`. The worst-case scenario is when the pattern does not occur
    in the text at all. The average-case scenario is when the pattern occurs at least
    once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin-Karp模式匹配算法在搜索之前预处理模式；也就是说，它计算具有复杂度`O(m)`的模式的哈希值。此外，Rabin-Karp算法的最坏情况运行时间复杂度为`O(m
    *(n-m+1))`。最坏的情况是模式根本不在文本中出现。平均情况是模式至少出现一次。
- en: Next, we will discuss the KMP string matching algorithm.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论KMP字符串匹配算法。
- en: The Knuth-Morris-Pratt algorithm
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knuth-Morris-Pratt算法
- en: The KMP algorithm is a pattern matching algorithm based on the idea that the
    overlapping text in the pattern itself can be used to immediately know at the
    time of any mismatch how much the pattern should be shifted to skip unnecessary
    comparisons. In this algorithm, we will precompute the `prefix` function that
    indicates the required number of shifts of the pattern whenever we get a mismatch.
    The KMP algorithm preprocesses the pattern to avoid unnecessary comparisons using
    the `prefix` function. So, the algorithm utilizes the `prefix` function to estimate
    how much the pattern should be shifted to search the pattern in the text string
    whenever we get a mismatch. The **KMP algorithm** is efficient as it minimizes
    the number of comparisons of the given patterns with respect to the text string.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: KMP算法是一种基于重叠文本在模式本身可以用来立即知道在任何不匹配时模式应该移动多少以跳过不必要的比较的匹配算法。在这个算法中，我们将预计算`prefix`函数，该函数指示在发生不匹配时模式所需的移动次数。KMP算法通过使用`prefix`函数预处理模式来避免不必要的比较。因此，该算法利用`prefix`函数来估计在发生不匹配时模式应该移动多少以在文本字符串中搜索模式。**KMP算法**效率高，因为它最小化了给定模式与文本字符串的比较次数。
- en: 'The motivation behind the **KMP algorithm** can be observed in *Figure 13.4*.
    In this example, it can be seen that the mismatch occurred at the 6^(th) position
    with the last character “d” after matching the initial 5 characters. It is also
    known from the `prefix` function that the character “d” did not appear before
    in the pattern, and utilizing this information, the pattern can be shifted by
    six places:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: KMP算法背后的动机可以在*图13.4*中观察到。在这个例子中，可以看到在匹配了前5个字符后，在第6个位置发生了不匹配，最后一个字符是“d”。从`prefix`函数中也可以知道，字符“d”在模式中之前没有出现过，利用这一信息，模式可以向前移动六个位置：
- en: '![](img/B17217_13_04.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_04.png)'
- en: 'Figure 13.4: Example of the KMP algorithm'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4：KMP算法的示例
- en: 'So, in this example, the pattern has shifted six positions instead of one.
    Let us discuss another example to understand the concept of the **KMP algorithm**,
    as shown in *Figure 13.5*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，模式移动了六个位置而不是一个。让我们讨论另一个例子来理解KMP算法的概念，如图*图13.5*所示：
- en: '![](img/B17217_13_05.png)Figure 13.5: Second example of the KMP algorithm'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/B17217_13_05.png)图13.5：KMP算法的第二个示例'
- en: In the above example, the mismatch occurs at the last character of the pattern.
    Since the pattern at the location of the mismatch has a partial match of the prefix
    **bc**, this information is given by the `prefix` function. Here, the pattern
    can be shifted to align with the other occurrence of the matched prefix **bc**
    in the pattern.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，不匹配发生在模式的最后一个字符处。由于不匹配位置的模式有一个前缀**bc**的部分匹配，这个信息由`prefix`函数提供。在这里，模式可以移动以与模式中匹配的前缀**bc**的其他出现对齐。
- en: We will look into the `prefix` function next for a better understanding of how
    we use it to know by how much we should shift the pattern.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在了解如何使用`prefix`函数来确定应该移动模式多少之后，进一步探讨`prefix`函数。
- en: The prefix function
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前缀函数
- en: The `prefix` function (also known as the failure function) finds the pattern
    within the pattern. It finds out how much the previous comparisons can be reused
    due to repetition in the pattern itself when there is a mismatch. The `prefix`
    function returns a value for each position wherever we get a mismatch, which tells
    us by how much the pattern should be shifted.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix`函数（也称为失败函数）在模式中找到模式。它找出由于模式本身的重复而在不匹配时可以重用多少前一次的比较。`prefix`函数为每个发生不匹配的位置返回一个值，这告诉我们模式应该移动多少。'
- en: 'Let us understand how we use the `prefix` function to find the required shift
    amount with the following examples. Consider the first example: if we had a `prefix`
    function for a pattern where all of the characters are different, the `prefix`
    function would have a value of `0`. This means that if we find any mismatch, the
    pattern will be shifted by the number of characters compared up to that position
    in the pattern.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来了解我们如何使用`prefix`函数来找到所需的移动量。考虑第一个例子：如果我们有一个所有字符都不同的模式的`prefix`函数，那么`prefix`函数的值将是`0`。这意味着如果我们找到任何不匹配，模式将根据模式中该位置之前的字符数进行移动。
- en: 'Consider an example with the pattern **abcde**, which contains all different
    characters. We start comparing the first character of the pattern with the first
    character of the text string, as shown in *Figure 13.6*. As shown in the figure,
    the mismatch occurs at the 4^(th) character in the pattern. Since the prefix function
    has the value 0, it means that there is no overlap in the pattern and no previous
    comparisons would be reused, so the pattern will be shifted to the number of characters
    compared up until that point:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个模式**abcde**的例子，其中包含所有不同的字符。我们开始将模式的第一个字符与文本字符串的第一个字符进行比较，如图*图13.6*所示。如图所示，模式在第4个字符处发生不匹配。由于前缀函数的值为0，这意味着模式中没有重叠，并且不会重用之前的比较，因此模式将移动到那个点之前比较的字符数：
- en: '![](img/B17217_13_06.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_06.png)'
- en: 'Figure 13.6: Prefix function in the KMP algorithm'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：KMP算法中的前缀函数
- en: 'Let’s consider another example to better understand how the `prefix` function
    works for the pattern `(P)` **abcabbcab** as shown in *Figure 13.7*:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子来更好地理解`prefix`函数是如何对模式`(P)`**abcabbcab**工作的，如图*图13.7*所示：
- en: '![](img/B17217_13_07.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_07.png)'
- en: 'Figure 13.7: Example of the prefix function in the KMP algorithm'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：KMP算法中前缀函数的示例
- en: 'In *Figure 13.7*, we start calculating the values of the `prefix` function
    starting from index `1`. We assign the value **0** if there is no repetition of
    the characters in the pattern. So, in this example, we assign **0** to the `prefix`
    function for index positions 1 to 3\. Next, at index position `4`, we can see
    that there is a character, **a**, which is a repetition of the first character
    of the pattern itself, so we assign the value **1** here, as shown in *Figure
    13.8*:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.7*中，我们从索引`1`开始计算`prefix`函数的值。如果没有字符在模式中重复，我们赋值为**0**。因此，在这个例子中，我们将**0**赋给索引位置1到3的`prefix`函数。接下来，在索引位置`4`，我们可以看到一个字符，**a**，它是模式本身第一个字符的重复，所以我们在这里赋值为**1**，如图*图13.8*所示：
- en: '![](img/B17217_13_08.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_08.png)'
- en: 'Figure 13.8: Value of the prefix function at index 4 in the KMP algorithm'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8：KMP算法中索引4处的`prefix`函数值
- en: 'Next, we look at the next character at position 5\. It has the longest suffix
    pattern, **ab**, and so it would have a value of **2**, as shown in *Figure 13.9*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们查看位置5的下一个字符。它具有最长的后缀模式**ab**，因此它的值应该是**2**，如图*图13.9*所示：
- en: '![](img/B17217_13_09.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_09.png)'
- en: 'Figure 13.9: Value of the prefix function at index 5 in the KMP algorithm'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9：KMP算法中索引5处的`prefix`函数值
- en: Similarly, we look at the next index position of `6`. Here, the character is
    **b**. This character does not have the longest suffix in the pattern, so it has
    the value **0**. Next, we assign value **0** at index position `7`. Then, we look
    at the index position `8`, and we assign the value **1** as it has the longest
    suffix of length **1**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们查看下一个索引位置`6`。在这里，字符是**b**。这个字符在模式中没有最长的后缀，因此它的值是**0**。接下来，我们在索引位置`7`赋值**0**。然后，我们查看索引位置`8`，我们将其赋值为**1**，因为它有长度为**1**的最长后缀。
- en: 'Finally, at the index position of `9`, we have the longest suffix of **2**.
    This is shown in *Figure 13.10*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在索引位置`9`，我们有**2**的最长后缀。这如图*图13.10*所示：
- en: '![](img/B17217_13_10.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_10.png)'
- en: 'Figure 13.10: Value of the prefix function at index 6 to 9 in the KMP algorithm'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10：KMP算法中索引6到9的`prefix`函数值
- en: The value of the `prefix` function shows how much of the start of the string
    can be reused if there is a mismatch. For example, if the comparison fails at
    index position `5`, the `prefix` function value is **2**, which means that the
    two starting characters don’t need to be compared, and the pattern can be shifted
    accordingly.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`prefix`函数的值显示了如果发生不匹配，字符串的开始部分可以重用多少。例如，如果比较在索引位置`5`处失败，`prefix`函数的值是**2**，这意味着两个起始字符不需要比较，模式可以相应地移动。'
- en: Next, we discuss the details of the **KMP algorithm**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论**KMP算法**的细节。
- en: Understanding the KMP algorithm
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解KMP算法
- en: 'The **KMP pattern matching algorithm** detects overlaps in the pattern itself
    so that it avoids unnecessary comparisons. The main idea behind the **KMP algorithm**
    is to detect how much the pattern should be shifted, based on the overlaps in
    the patterns. The algorithm works as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**KMP模式匹配算法**检测模式本身的重叠，从而避免不必要的比较。**KMP算法**背后的主要思想是根据模式的重叠检测模式应该移动多少。算法的工作方式如下：'
- en: First, we precompute the `prefix` function for the given pattern and initialize
    a counter **q** that represents the number of characters that matched.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们为给定的模式预计算`prefix`函数，并初始化一个计数器**q**，它代表匹配的字符数。
- en: We start by comparing the first character of the pattern with the first character
    of the text string, and if this matches, then we increment the counter **q** for
    the pattern and the counter for the text string, and we compare the next character.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先比较模式的第一个字符与文本字符串的第一个字符，如果匹配，则增加模式计数器**q**和文本字符串计数器，并比较下一个字符。
- en: If there is a mismatch, then we assign the value of the precomputed `prefix`
    function for `q` to the index value of `q`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在不匹配，则我们将预计算的`prefix`函数的值赋给`q`的索引值。
- en: We continue searching the pattern in the text string until we reach the end
    of the text, that is, if we do not find any matches. If all of the characters
    in the pattern are matched in the text string, we return the position where the
    pattern is matched in the text and continue to search for another match.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续在文本字符串中搜索模式，直到达到文本的末尾，即如果我们没有找到任何匹配。如果模式中的所有字符都在文本字符串中匹配，我们返回模式在文本中匹配的位置，并继续搜索另一个匹配。
- en: 'Let’s consider the following example to understand the working of the **KMP
    algorithm**. We have a pattern `acacac` along with index positions from `1` to
    `6` (just for simplicity, we have index positions starting from 1 instead of 0),
    shown in *Figure 13.11*. The `prefix` function for the given pattern is constructed
    as shown in *Figure 13.11*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下例子来理解 **KMP 算法**的工作原理。我们有一个模式 `acacac`，以及从 `1` 到 `6` 的索引位置（为了简单起见，我们将索引位置从
    `1` 开始而不是 `0`），如图 *图 13.11* 所示。给定模式的 `prefix` 函数如图 *图 13.11* 所示构建：
- en: '![](img/B17217_13_11.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_11.png)'
- en: 'Figure 13.11: The prefix function for pattern “acacac”'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11：模式 “acacac” 的前缀函数
- en: 'Let us take an example to understand how we use the `prefix` function to shift
    the pattern according to the **KMP algorithm** for the text string and pattern
    given in *Figure 13.12*. We start comparing the pattern and the text character
    by character. When we mismatch at index position `6`, we see the prefix value
    for this position is **2**. Then we shift the pattern according to the return
    value of the `prefix` function. Next, we start comparing the pattern and text
    string from the index position of `2` on the pattern (character **c**), and the
    character **b** of the text string. Since this is a mismatch, the pattern will
    be shifted according to the value of the `prefix` function at this position. This
    description is depicted in *Figure 13.12*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解我们如何使用 `prefix` 函数根据 *图 13.12* 中给出的文本字符串和模式来偏移模式，以理解 **KMP 算法**。我们从逐个比较模式和文本字符开始。当我们在第
    `6` 个索引位置不匹配时，我们看到该位置的偏移值是 **2**。然后我们根据 `prefix` 函数的返回值偏移模式。接下来，我们从模式上的索引位置 `2`（字符
    **c**）开始，比较模式和文本字符串，并与文本字符串中的字符 **b** 进行比较。由于这是一个不匹配，模式将根据该位置的 `prefix` 函数值进行偏移。这一描述如图
    *图 13.12* 所示：
- en: '![](img/B17217_13_12.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_12.png)'
- en: 'Figure 13.12: The pattern is shifted according to the return value of the prefix
    function'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12：模式根据前缀函数的返回值进行偏移
- en: Now let’s take another example shown in *Figure 13.13* where the position of
    the pattern over the text is shown. When we start comparing the characters **b**
    and **a**, these do not match, and we see the `prefix` function for index position
    `1` shows a value of **0**, meaning no overlapping of text in the pattern has
    occurred. Therefore, we shift the pattern by **1** place as shown in *Figure 13.12*.
    Next, we compare the pattern and text string character by character, and we find
    a mismatch at index position 10 in the text between characters **b** and **c**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再看一个如图 *图 13.13* 所示的例子，其中显示了模式在文本上的位置。当我们开始比较字符 **b** 和 **a** 时，它们不匹配，我们看到索引位置
    `1` 的 `prefix` 函数显示的值是 **0**，这意味着模式中没有文本重叠。因此，我们将模式偏移 **1** 个位置，如图 *图 13.12* 所示。接下来，我们逐个比较模式和文本字符串，并在文本的索引位置
    `10` 之间找到字符 **b** 和 **c** 之间的不匹配。
- en: 'Here, we use the precomputed `prefix` function to shift the pattern – as the
    `prefix_function(4)` is **2**, we shift the pattern to align over the text at
    index position `2` of the pattern. After that, we compare characters **b** and
    **c** at index position `10`, and since they do not match, we shift the pattern
    by one place. This process is shown in *Figure 13.13*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用预先计算的前缀函数来偏移模式——因为 `prefix_function(4)` 的返回值是 **2**，我们将模式偏移以使其与文本对齐，位于模式索引位置
    `2` 的文本。之后，我们在索引位置 `10` 比较字符 **b** 和 **c**，由于它们不匹配，我们将模式偏移一个位置。这一过程如图 *图 13.13*
    所示：
- en: '![](img/B17217_13_13.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_13.png)'
- en: 'Figure 13.13: Shifting of the pattern according to the return value of the
    prefix function'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13：根据前缀函数的返回值偏移模式
- en: 'Let us continue our searching from index position `11`, as shown in *Figure
    13.14*. Next, we compare the characters at index `11` in the text and continue
    until a mismatch is found. We find a mismatch between characters **b** and **c**
    at index position `12`, as shown in *Figure 13.14*. We shift the pattern and move
    it next to the mismatched character since the `prefix_function(2)` is `0`. We
    repeat the same process until we reach the end of the string. We find a match
    of the pattern in the text string at index location **13** in the text string,
    as in *Figure 13.14*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从索引位置 `11` 继续搜索，如图 *图 13.14* 所示。接下来，我们比较文本中索引位置 `11` 的字符，并继续比较，直到找到不匹配。我们在索引位置
    `12` 找到字符 **b** 和 **c** 之间的不匹配，如图 *图 13.14* 所示。由于 `prefix_function(2)` 的返回值是 `0`，我们将模式偏移并移动到不匹配字符旁边。我们重复相同的过程，直到达到字符串的末尾。我们在文本字符串中找到模式匹配的位置，位于文本字符串的索引位置
    **13**，如图 *图 13.14* 所示：
- en: '![](img/B17217_13_14.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_14.png)'
- en: 'Figure 13.14: Shifting of the pattern for index positions of 11 to 18'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14：索引位置11到18的模式移动
- en: 'The **KMP algorithm** has two phases: first, the preprocessing phase, which
    is where we compute the `prefix` function, which has the space and time complexity
    of `O(m)`. Further, the second phase involves searching, for which the **KMP algorithm**
    has a time complexity of `O(n)`. So, the worst-case time complexity of the **KMP
    algorithm** is `O(m +n)`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**KMP算法**有两个阶段：首先，预处理阶段，在这里我们计算`prefix`函数，它具有`O(m)`的空间和时间复杂度。其次，第二阶段涉及搜索，**KMP算法**的搜索时间复杂度为`O(n)`。因此，**KMP算法**的最坏情况时间复杂度为`O(m
    + n)`。'
- en: Now, we will discuss the implementation of the **KMP algorithm** using Python.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论使用Python实现**KMP算法**。
- en: Implementing the KMP algorithm
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现KMP算法
- en: 'The Python implementation of the KMP algorithm is explained here. We start
    by implementing the `prefix` function for the given pattern. The code for the
    `prefix` function is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这里解释了KMP算法的Python实现。我们首先实现给定模式的`prefix`函数。`prefix`函数的代码如下：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the above code, we first compute the length of the pattern using the `len()`
    function, and then we initialize a list to store the values computed by the `prefix`
    function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先使用`len()`函数计算模式的长度，然后初始化一个列表来存储`prefix`函数计算出的值。
- en: Next, we start the loop that executes from 2 to the length of the pattern. Then,
    we have a nested loop that is executed until we have processed the whole pattern.
    The variable `k` is initialized to `0`, which is the `prefix` function for the
    first element of the pattern. If the `k`^(th) element of the pattern is equal
    to the `q`^(th) element, then we increment the value of `k` by `1`. The value
    of `k` is the value computed by the `prefix` function, and so we assign it at
    the index position of `q` in the pattern. Finally, we return the list of the `prefix`
    function that has the computed value for each character of the pattern.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始一个从2到模式长度的循环。然后，我们有一个嵌套循环，它执行直到我们处理完整个模式。变量`k`被初始化为`0`，这是模式的第一个元素的`prefix`函数。如果模式的`k`^(th)元素等于`q`^(th)元素，那么我们将`k`的值增加`1`。`k`的值是`prefix`函数计算出的值，因此我们将它赋值给模式中的`q`索引位置。最后，我们返回包含模式每个字符计算值的`prefix`函数的列表。
- en: 'Once we have created the `prefix` function, we implement the main **KMP matching
    algorithm**. The following code shows this in detail:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了`prefix`函数，我们就实现主要的**KMP匹配算法**。以下代码详细展示了这一点：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the above code, we start by computing the length of the text string and the
    pattern, which are stored in the variables `m` and `n`, respectively. Next, we
    define a variable `flag` to indicate whether the pattern has found a match or
    not. Further, we add a dummy character `-` in the text and pattern to make the
    indexing start from index `1` instead of index `0`. Next, we call the `pfun()`
    method to construct the array containing the prefix values for all the positions
    of the pattern using `prefix_fun = pfun(pattern)`. Next, we execute a loop starting
    from `1` to `m+1`, where `m` is the length of the pattern. Further, for each iteration
    of the `for` loop, we compare the pattern and text in a `while` loop until we
    finish searching the pattern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先计算文本字符串和模式的长度，分别存储在变量`m`和`n`中。接下来，我们定义一个变量`flag`来指示模式是否找到匹配。进一步，我们在文本和模式中添加一个虚拟字符`-`，以便从索引`1`而不是索引`0`开始索引。接下来，我们调用`pfun()`方法，使用`prefix_fun
    = pfun(pattern)`构建包含模式所有位置的`prefix`值的数组。接下来，我们执行一个从`1`到`m+1`的循环，其中`m`是模式的长度。进一步，对于`for`循环的每次迭代，我们使用`while`循环比较模式和文本，直到我们完成模式的搜索。
- en: If we get a mismatch, we use the value of the `prefix` function at index `q`
    (here, `q` is the index where the mismatch occurs) to find out by how much we
    have to shift the pattern. If the pattern and text are equal, then the value of
    `1` and `n` will be equal, and we can return the index where the pattern was matched
    in the text. Further, we update the `flag` variable to `True` when the pattern
    is found in the text. If we finished searching the whole text string and still
    the variable `flag` was `False`, it would mean the pattern was not present in
    the given text.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生不匹配，我们使用索引`q`处的`prefix`函数的值（在这里，`q`是不匹配发生的索引）来确定我们需要将模式移动多少位。如果模式和文本相等，那么`1`和`n`的值将相等，并且我们可以返回模式在文本中匹配的索引。此外，当在文本中找到模式时，我们将`flag`变量更新为`True`。如果我们已经搜索了整个文本字符串，但变量`flag`仍然是`False`，这意味着模式在给定的文本中不存在。
- en: 'The following code snippet can be used to execute the KMP algorithm for string
    matching:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段可以用来执行字符串匹配的KMP算法：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the above code is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the above output, we see that the pattern is present at index positions 0
    and 9 in the given text string.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们看到模式在给定文本字符串中的索引位置为0和9。
- en: Next, we will discuss another pattern matching algorithm, the Boyer-Moore algorithm.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论另一种模式匹配算法，即Boyer-Moore算法。
- en: The Boyer-Moore algorithm
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boyer-Moore算法
- en: As we have already discussed, the main objective of the string pattern matching
    algorithm is to find ways of skipping comparisons as much as possible by avoiding
    unnecessary comparisons.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，字符串模式匹配算法的主要目标是尽可能通过避免不必要的比较来找到跳过比较的方法。
- en: 'The Boyer-Moore pattern matching algorithm is another such algorithm (along
    with the KMP algorithm) that further improves the performance of pattern matching
    by skipping comparisons using different methods. We have to understand the following
    concepts in order to understand the Boyer-Moore algorithm:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore模式匹配算法是另一种这样的算法（与KMP算法一起），通过使用不同的方法跳过比较来进一步提高模式匹配的性能。为了理解Boyer-Moore算法，我们必须理解以下概念：
- en: In this algorithm, we shift the pattern in the direction from left to right,
    similar to the KMP algorithm.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个算法中，我们像KMP算法一样从左到右移动模式。
- en: We compare the characters of the pattern and the text string from right to left,
    which is the opposite of what we do in the case of the KMP algorithm.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从右到左比较模式和文本字符串的字符，这与我们在KMP算法中的做法相反。
- en: The algorithm skips the unnecessary comparisons by using the good suffix and
    bad character shift heuristics. These heuristics themselves find the possible
    number of comparisons that can be skipped. We slide the pattern over the given
    text with the greatest offsets suggested by both of these heuristics.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该算法通过使用好的后缀和坏字符偏移启发式方法来跳过不必要的比较。这些启发式方法本身找到可以跳过的可能比较次数。我们使用这两个启发式方法建议的最大偏移量在给定文本上滑动模式。
- en: Let us understand all about these heuristics and the details of how the Boyer-Moore
    pattern matching algorithm works.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解所有关于这些启发式方法以及Boyer-Moore模式匹配算法的工作细节。
- en: Understanding the Boyer-Moore algorithm
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Boyer-Moore算法
- en: The Boyer-Moore algorithm compares the pattern with the text from right to left,
    meaning that in this algorithm if the end of the pattern does not match with the
    text, the pattern can be shifted rather than checking every character of the text.
    The key idea is that the pattern is aligned with the text and the last character
    of the pattern is compared with the text, and if they do not match, then it is
    not required to continue comparing each character and we can rather shift the
    pattern.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法从右到左比较模式与文本，这意味着在这个算法中，如果模式的末尾与文本不匹配，则可以移动模式，而不是检查文本中的每个字符。关键思想是模式与文本对齐，并且比较模式的最后一个字符与文本，如果不匹配，则不需要继续逐个字符比较，我们可以直接移动模式。
- en: Here, how much we shift the pattern depends upon the mismatched character. If
    the mismatched character of the text does not appear in the pattern, it means
    we can shift the pattern by the whole length of the pattern, whereas if the mismatched
    character appears in the pattern somewhere, then we partially shift the pattern
    in such a way that the mismatched character is aligned with the other occurrence
    of that character in the pattern.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们移动模式的大小取决于不匹配的字符。如果文本中的不匹配字符不在模式中，这意味着我们可以通过整个模式长度来移动模式，而如果模式中某处有不匹配的字符，那么我们部分地移动模式，使得不匹配的字符与模式中该字符的其他出现对齐。
- en: In addition, in this algorithm, we can also see what portion of the pattern
    has matched (with the matched suffix), so we utilize this information and align
    the text and pattern by skipping any unnecessary comparisons. Making the pattern
    jump along the text to reduce the number of comparisons rather than checking every
    character of the pattern with the text is the main idea of an efficient string
    matching algorithm.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个算法中，我们还可以看到模式匹配的部分（与匹配的后缀一起），因此我们利用这一信息，通过跳过任何不必要的比较来对齐文本和模式。通过在文本上跳过模式，以减少比较次数，而不是将模式中的每个字符与文本中的每个字符进行比较，这是高效字符串匹配算法的主要思想。
- en: 'The concept behind the Boyer-Moore algorithm is demonstrated in *Figure 13.15*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法背后的概念在*图13.15*中展示：
- en: '![](img/B17217_13_15.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_15.png)'
- en: 'Figure 13.15: A example to demonstrate the concept of the Boyer-Moore algorithm'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15：Boyer-Moore算法概念示例
- en: In the example shown in *Figure 13.15*, where character **b** of the pattern
    mismatches with character **d** of the text, we can shift the entire pattern since
    the mismatched character **d** is not present in the pattern anywhere. In the
    second mismatch, we can see that the mismatched character **a** in the text is
    present in the pattern, so we shift the pattern to align with that character.
    This example shows how we can skip unnecessary comparisons. Next, we will discuss
    further the details of the algorithm.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在图13.15所示的示例中，模式中的字符**b**与文本中的字符**d**不匹配，由于不匹配的字符**d**在模式中任何地方都没有出现，因此我们可以将整个模式进行位移。在第二次不匹配中，我们可以看到文本中的不匹配字符**a**在模式中存在，因此我们将模式位移以与该字符对齐。这个例子展示了我们如何跳过不必要的比较。接下来，我们将进一步讨论算法的细节。
- en: 'The Boyer-Moore algorithm has two heuristics to determine the maximum shift
    possible for the pattern when we find a mismatch:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们找到不匹配时，Boyer-Moore算法有两个启发式算法来确定模式可能的最大位移：
- en: Bad character heuristic
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坏字符启发式算法
- en: Good suffix heuristic
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好后缀启发式算法
- en: At the time of a mismatch, each of these heuristics suggests possible shifts,
    and the Boyer-Moore algorithm shifts the pattern over the text string by a longer
    distance considering the maximum shift given by bad character and good suffix
    heuristics. The details of the bad character and good suffix heuristics are explained
    in detail with examples in the following subsections.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在不匹配时，这些启发式算法都会建议可能的位移，而Boyer-Moore算法会根据坏字符和好后缀启发式算法给出的最大位移，将模式在文本字符串上移动更长的距离。坏字符和好后缀启发式算法的详细内容将在以下小节中用示例进行解释。
- en: Bad character heuristic
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坏字符启发式算法
- en: The Boyer-Moore algorithm compares the pattern and the text string in the direction
    of right to left. It uses the bad character heuristic to shift the pattern, where
    we start comparing character by character from the end of the pattern, and if
    they match then we compare the second to-last character, and if that also matches,
    then the process is repeated until the entire pattern is matched or we get a mismatch.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法以从右到左的方向比较模式和文本字符串。它使用坏字符启发式算法来移动模式，我们从模式末尾开始逐个字符比较，如果它们匹配，则比较倒数第二个字符，如果这也匹配，则重复此过程，直到整个模式匹配或出现不匹配。
- en: 'The mismatched character of the text is also known as a bad character. If we
    get any mismatch in this process, we shift the pattern according to one of the
    following conditions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 文本中的不匹配字符也称为坏字符。如果在过程中出现任何不匹配，我们将根据以下条件之一将模式进行位移：
- en: If the mismatched character of the text does not occur in the pattern, then
    we shift the pattern next to the mismatched character.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文本中的不匹配字符在模式中不存在，则将模式移至不匹配字符旁边。
- en: If the mismatched character has one occurrence in the pattern, then we shift
    the pattern in such a way that we align with the mismatched character.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不匹配的字符在模式中只有一个出现，那么我们将模式移动到与不匹配字符对齐的位置。
- en: If the mismatched character has more than one occurrence in the pattern, then
    we make the most minimal shift possible to align the pattern with that character.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不匹配的字符在模式中出现了多次，那么我们将进行最小的位移，以使模式与该字符对齐。
- en: 'Let us understand these three cases with examples. Consider a text string (`T`)
    and the pattern = {**acacac**}. We start by comparing the characters from right
    to left, that is, character **c** of the pattern and character **b** of the text
    string. Since they do not match, we look for the mismatched character of the text
    string (that is **b**) in the pattern. Since the bad character **b** does not
    appear in the pattern, we shift the pattern next to the mismatched character,
    as shown in *Figure 13.16*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例来理解这三种情况。考虑一个文本字符串（`T`）和模式 = {**acacac**}。我们首先从右到左比较字符，即模式中的字符**c**和文本字符串中的字符**b**。由于它们不匹配，我们在模式中寻找文本字符串的不匹配字符（即**b**）。由于坏字符**b**在模式中不存在，我们将模式移至不匹配字符旁边，如图13.16所示：
- en: '![](img/B17217_13_16.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_16.png)'
- en: 'Figure 13.16: Example of the bad character heuristic in the Boyer-Moore algorithm'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.16：Boyer-Moore算法中坏字符启发式算法的示例
- en: 'Let’s take another example with a given text string and the pattern = {**acacac**}
    as shown in *Figure 13.17*. For the given example, we compare the characters of
    the text string and the pattern from right to left, and we get a mismatch for
    the character **d** of the text. Here, the suffix **ac** is matched, but the characters
    **d** and **c** do not match, and the mismatched character **d** does not appear
    in the pattern. Therefore, we shift the pattern next to the mismatched character,
    as shown in *Figure 13.17*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子，给定一个文本字符串和模式={**acacac**}，如图*图13.17*所示。对于这个例子，我们从右到左比较文本字符串和模式的字符，并得到文本中字符**d**的不匹配。在这里，后缀**ac**是匹配的，但字符**d**和**c**不匹配，不匹配的字符**d**没有出现在模式中。因此，我们将模式移到不匹配字符旁边，如图*图13.17*所示：
- en: '![](img/B17217_13_17.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_17.png)'
- en: 'Figure 13.17: Second example of the bad character heuristic in the Boyer-Moore
    algorithm'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.17：Boyer-Moore算法中坏字符启发式的第二个例子
- en: 'Let’s consider an example to understand the second and third cases of the bad
    character heuristic for the given text string and the pattern as shown in *Figure
    13.18*. Here, the suffix **ac** is matched, but the next characters, **a** and
    **c**, do not match, so we search for the occurrences of the mismatched character
    **a** in the pattern. Since it has two occurrences in the pattern, we have two
    options for shifting the pattern to align it with the mismatched character. Both
    of these options are shown in *Figure 13.18*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子来理解给定文本字符串和模式（如图*图13.18*所示）的坏字符启发式的第二和第三种情况。在这里，后缀**ac**是匹配的，但接下来的字符**a**和**c**不匹配，因此我们在模式中搜索不匹配字符**a**的出现。由于它在模式中有两个出现，我们有两种选择来改变模式以使其与不匹配的字符对齐。这两种选择都如图*图13.18*所示：
- en: 'In such situations where we have more than one option to shift the pattern,
    we apply the least possible number of shifts to prevent missing any possible match.
    If on the other hand we have only one occurrence of the mismatched character in
    the pattern, we can easily shift the pattern in such a way that the mismatched
    character is aligned. So, in this example, we would prefer option 1 to shift the
    pattern as shown in *Figure 13.18*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有多于一个选项来改变模式的情况下，我们应用尽可能少的改变次数以防止错过任何可能的匹配。另一方面，如果我们模式中只有一个不匹配字符的出现，我们可以轻松地改变模式，使不匹配的字符对齐。因此，在这个例子中，我们更倾向于选择1号选项来改变模式，如图*图13.18*所示：
- en: '![](img/B17217_13_18.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_13_18.png)'
- en: 'Figure 13.18: Third example of the bad character heuristic in the Boyer-Moore
    algorithm'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.18：Boyer-Moore算法中坏字符启发式的第三个例子
- en: We have discussed the bad character heuristic so far, and we consider the good
    suffix heuristic in the next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了坏字符启发式，接下来我们将考虑好的后缀启发式。
- en: Good suffix heuristic
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 好的后缀启发式
- en: The bad character heuristic does not always provide good suggestions for shifting
    the pattern. The Boyer-Moore algorithm also uses the good suffix heuristic to
    shift the pattern over the text string, which is based on the matched suffix.
    In this method, we shift the pattern to the right in such a way that the matched
    suffix of the pattern is aligned with another occurrence of the same suffix in
    the pattern.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 坏字符启发式并不总是为模式改变提供好的建议。Boyer-Moore算法也使用好的后缀启发式来在文本字符串上改变模式，这是基于匹配的后缀。在这个方法中，我们将模式向右移动，使得模式的匹配后缀与模式中相同后缀的另一个出现对齐。
- en: 'It works like this: we start by comparing the pattern and the text string from
    right to left, and if we find any mismatch, then we check the occurrence of the
    suffix in the pattern that has been matched so far, which is known as a good suffix.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的：我们首先从右到左比较模式和文本字符串，如果我们发现任何不匹配，然后我们检查模式中已经匹配的后缀的出现，这被称为好的后缀。
- en: 'In such situations, we shift the pattern in such a way that we align another
    occurrence of the good suffix to the text. The good suffix heuristic has two main
    cases:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们改变模式的方式是使另一个好的后缀的出现与文本对齐。好的后缀启发式有两个主要情况：
- en: The matching suffix has one or more occurrences in the pattern
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配后缀在模式中有一个或多个出现
- en: Some part of the matching suffix is present at the start of the pattern (this
    means that the suffix of the matched suffix exists as the prefix of the pattern)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配后缀的一部分出现在模式的开始处（这意味着匹配后缀的后缀作为模式的词首存在）
- en: 'Let’s understand these cases with the following examples. Suppose we have a
    given text string and the pattern **acabac** as shown in *Figure 13.19*. We start
    comparing the characters from right to left, and we get a mismatch with the character
    **a** of the text string and **b** of the pattern. By the point of this mismatch,
    we have already matched the suffix **ac**, which is called the “good suffix.”
    Now, we search for another occurrence of the good suffix **ac** in the pattern
    (which is present at the starting position of the pattern in this example) and
    we shift the pattern to align it with that suffix, as shown in *Figure 13.19*:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下示例来理解这些情况。假设我们有一个给定的文本字符串和如图 *图 13.19* 所示的模式 **acabac**。我们从右向左比较字符，并且我们在文本字符串的
    **a** 字符和模式的 **b** 字符之间得到一个不匹配。在这个不匹配的点，我们已经有了一个匹配的尾部 **ac**，这被称为“良好后缀”。现在，我们在模式中搜索另一个良好后缀
    **ac** 的出现（在这个例子中，它在模式的起始位置），并将模式移动以与该后缀对齐，如图 *图 13.19* 所示：
- en: '![](img/B17217_13_19.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_19.png)'
- en: 'Figure 13.19: Example of the good suffix heuristic in the Boyer-Moore algorithm'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.19：Boyer-Moore 算法中良好后缀启发式算法的示例
- en: Let’s take another example to understand the good suffix heuristic. Consider
    the text string and pattern given in *Figure 13.18*. Here, we get a mismatch between
    characters **a** and **c**, and we get a good suffix **ac**. Here, we have two
    options for shifting the pattern to align it with the good suffix string.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子来理解良好后缀启发式算法。考虑 *图 13.18* 中给出的文本字符串和模式。在这里，我们在字符 **a** 和 **c** 之间得到一个不匹配，并且我们得到一个良好后缀
    **ac**。在这里，我们有两种将模式移动以与良好后缀字符串对齐的选项。
- en: 'In a situation where we have more than one option to shift the pattern, we
    take the option with the lower number of shifts. For this reason, we take option
    1 in this example, as shown in *Figure 13.20*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有多个移动模式选项的情况下，我们选择移动次数较少的选项。因此，在这个例子中，我们选择选项 1，如图 *图 13.20* 所示：
- en: '![](img/B17217_13_20.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_20.png)'
- en: 'Figure 13.20: Second example of the good suffix heuristic in the Boyer-Moore
    algorithm'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.20：Boyer-Moore 算法中良好后缀启发式算法的第二个示例
- en: Let’s take a look at another example of the text string and pattern shown in
    *Figure 13.19*. In this example, we get a good suffix string **aac**, and we get
    a mismatch for the characters **b** of the text string and **a** of the pattern.
    Now, we search for the good suffix **aac** in the pattern, but we do not find
    another occurrence of it. When this happens, we check whether the prefix of the
    pattern matches the suffix of the good suffix, and if so, we shift the pattern
    to align with it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 *图 13.19* 中显示的文本字符串和模式的另一个示例。在这个例子中，我们得到一个良好后缀字符串 **aac**，并且文本字符串的 **b**
    字符与模式的 **a** 字符不匹配。现在，我们在模式中搜索良好后缀 **aac**，但没有找到另一个出现。当这种情况发生时，我们检查模式的前缀是否与良好后缀的尾部匹配，如果是，我们将模式移动以与它对齐。
- en: 'For this example, we find that the prefix **ac** at the start of the pattern
    does not match with the full good suffix, but does match the suffix **ac** of
    the good suffix **aac**. In such a situation, we shift the pattern by aligning
    with the suffix of **aac** that is also a prefix of the pattern as shown in *Figure
    13.21*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们发现模式开头的 **ac** 前缀与完整的好后缀不匹配，但与良好后缀 **aac** 的尾部 **ac** 匹配。在这种情况下，我们将模式通过与也是模式前缀的
    **aac** 尾部对齐来移动，如图 *图 13.21* 所示：
- en: '![](img/B17217_13_21.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_21.png)'
- en: 'Figure 13.21: Third example of the good suffix heuristic in the Boyer-Moore
    algorithm'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.21：Boyer-Moore 算法中良好后缀启发式算法的第三个示例
- en: Another case for the good suffix heuristic for the given text string and pattern
    is shown in *Figure 13.22*. In this example, we compare the text and pattern and
    find the good suffix **aac**, and we get a mismatch with character **b** of the
    text and **a** of the pattern.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的文本字符串和模式，良好后缀启发式算法的另一个情况如图 *图 13.22* 所示。在这个例子中，我们比较文本和模式，并找到良好后缀 **aac**，并且文本的
    **b** 字符与模式的 **a** 字符不匹配。
- en: 'Next, we search for the matched good suffix in the pattern, but there is no
    occurrence of the suffix in the pattern, nor does any prefix of the pattern match
    the suffix of the good suffix. So, in this kind of situation, we shift the pattern
    after the matched good suffix as shown in *Figure 13.22*:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在模式中搜索匹配的良好后缀，但模式中没有后缀的出现，也没有任何模式的前缀与良好后缀的尾部匹配。因此，在这种情况下，我们将模式在匹配的良好后缀之后进行移动，如图
    *图 13.22* 所示：
- en: '![](img/B17217_13_22.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_13_22.png)'
- en: 'Figure 13.22: Fourth example of the good suffix heuristic in the Boyer-Moore
    algorithm'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.22：Boyer-Moore 算法中良好后缀启发式算法的第四个示例
- en: In the Boyer-Moore algorithm, we compute the shifts given by the bad character
    and good suffix heuristics. Further, we shift the pattern by the longer of the
    distances given by the bad character and good suffix heuristics.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Boyer-Moore算法中，我们计算由坏字符和良好后缀启发式方法给出的位移。进一步地，我们通过坏字符和良好后缀启发式方法给出的距离中的较长者来移动模式。
- en: The Boyer-Moore algorithm has a time complexity of `O(m)` for the preprocessing
    of the pattern, and the searching has a time complexity of `O(mn)`, where `m`
    is the length of the pattern and `n` is the length of the text.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Boyer-Moore算法在模式预处理阶段的时间复杂度为`O(m)`，搜索阶段的时间复杂度为`O(mn)`，其中`m`是模式的长度，`n`是文本的长度。
- en: Next, let us discuss the implementation of the Boyer-Moore algorithm.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论Boyer-Moore算法的实现。
- en: Implementing the Boyer-Moore algorithm
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Boyer-Moore算法
- en: 'Let’s understand the implementation of the Boyer-Moore algorithm. The complete
    implementation of the Boyer-Moore algorithm is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解Boyer-Moore算法的实现。Boyer-Moore算法的完整实现如下：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An explanation of each of the statements of the preceding code is presented
    here. Initially, we have the text string and the pattern. After initializing the
    variables, we start with a `while` loop that starts by comparing the last character
    of the pattern with the corresponding character of the text.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码中每个语句的解释。最初，我们有文本字符串和模式。初始化变量后，我们开始一个`while`循环，首先比较模式的最后一个字符与文本的相应字符。
- en: Then, the characters are compared from right to left by the use of the nested
    loop from the last index of the pattern to the first character of the pattern.
    This uses `range(len(pattern)-1, -1, -1)`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过使用从模式的最后一个索引到模式第一个字符的嵌套循环，从右到左比较字符。这使用了`range(len(pattern)-1, -1, -1)`。
- en: The outer `while` loop keeps track of the index in the text string while the
    inner `for` loop keeps track of the index position in the pattern.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 外部`while`循环跟踪文本字符串中的索引，而内部`for`循环跟踪模式中的索引位置。
- en: Next, we start comparing the characters by using `pattern[j] != text[i+j]`.
    If they are mismatched, we make the `flag` variable `False`, denoting that there
    is a mismatch.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用`pattern[j] != text[i+j]`来按字符比较。如果它们不匹配，我们将`flag`变量设置为`False`，表示存在不匹配。
- en: Now, we check whether the good suffix is present using the condition `j == len(pattern)-1`.
    If this condition is true, it means that there is no good suffix possible, so
    we check for the bad character heuristics, that is, whether a mismatched character
    is present in the pattern using the condition `text[i+j] in pattern[0:j]`, and
    if the condition is true, then it means that the bad character is present in the
    pattern. In this case, we move the pattern to align this bad character to the
    other occurrence of this character in the pattern by using `i=i+j-pattern[0:j].rfind(text[i+j])`.
    Here, `(i+j)` is the index of the bad character.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用条件`j == len(pattern)-1`来检查良好的后缀是否存在。如果这个条件为真，这意味着不可能存在良好的后缀，因此我们检查坏字符启发式方法，即使用条件`text[i+j]
    in pattern[0:j]`检查模式中是否存在不匹配的字符，如果条件为真，那么这意味着坏字符存在于模式中。在这种情况下，我们使用`i=i+j-pattern[0:j].rfind(text[i+j])`将模式移动以对齐这个坏字符，使其与模式中该字符的其他出现对齐。在这里，`(i+j)`是坏字符的索引。
- en: If the bad character is not present in the pattern (it isn’t in the `else` part
    of it), we move the whole pattern next to the mismatched character by using the
    index `i=i+j+1`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果坏字符不在模式中（它不在模式的`else`部分），我们使用索引`i=i+j+1`将整个模式移动到不匹配字符的旁边。
- en: 'Next, we go into the `else` part of the condition to check the good suffix.
    When we find the mismatch, we further test to see whether we have any subpart
    of a good suffix present in the prefix of the pattern. We do this using the following
    condition:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们进入条件的`else`部分来检查良好的后缀。当我们发现不匹配时，我们进一步测试是否在模式的词首部分存在任何良好的后缀的子部分。我们使用以下条件来完成这项工作：
- en: '[PRE18]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Furthermore, we check whether the length of the good suffix is `1` or not. If
    the length of the good suffix is `1`, we do not consider this shift. If the good
    suffix is more than `1`, we find out the number of shifts by using the good suffix
    heuristics and store this in the `gsshift` variable. This is the pattern, which
    leads to a position where the good suffix of the pattern matches the good suffix
    in the text using the instruction `gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])`.
    Furthermore, we computed the number of shifts possible due to the bad character
    heuristic and stored this in the `bcshift` variable. The number of shifts possible
    is `i+j-pattern[0:j].rfind(text[i+j])` when the bad character is present in the
    pattern, and the number of shifts possible would be `i+j+1` in the case of the
    bad character not being present in the pattern.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们检查好后缀的长度是否为 `1`。如果好后缀的长度为 `1`，我们不考虑这个位移。如果好后缀超过 `1`，我们使用好后缀启发式找出位移的数量，并将其存储在
    `gsshift` 变量中。这是模式，它通过指令 `gsshift=i+j+k-pattern[0:len(pattern)-1].rfind(text[i+j+k:i+len(pattern)])`
    将模式的好后缀与文本中的好后缀匹配到一起。此外，我们计算了由于坏字符启发式导致的可能位移的数量，并将其存储在 `bcshift` 变量中。当模式中存在坏字符时，可能的位移数量是
    `i+j-pattern[0:j].rfind(text[i+j])`，而在模式中不存在坏字符的情况下，可能的位移数量将是 `i+j+1`。
- en: Next, we shift the pattern on the text string by the maximum number of moves
    given by the bad character and good suffix heuristics by using the instruction
    `i=max((bcshift, gsshift))`. Finally, we check whether the `flag` variable is
    `True` or not. If it is `True`, this means that the pattern has been found and
    that the matched index has been stored in the `matched_indexes` variable.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用指令 `i=max((bcshift, gsshift))` 通过坏字符和好后缀启发式给出的最大移动次数在文本字符串上移动模式。最后，我们检查
    `flag` 变量是否为 `True`。如果是 `True`，这意味着已经找到了模式，并且匹配的索引已经存储在 `matched_indexes` 变量中。
- en: We have discussed the concept of the Boyer-Moore pattern matching algorithm,
    which is an efficient algorithm that skips unnecessary comparisons using the bad
    character and good suffix heuristics.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 Boyer-Moore 模式匹配算法的概念，这是一个高效的算法，它通过使用坏字符和好后缀启发式来跳过不必要的比较。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have discussed the most popular and important string matching
    algorithms that have a wide range of applications in real-time scenarios. We discussed
    the brute force, Rabin-Karp, KMP, and Boyer-Moore pattern matching algorithms.
    In string matching algorithms, we try to uncover ways to skip unnecessary comparisons
    and move the pattern over the text as fast as possible. The **KMP algorithm**
    detects unnecessary comparisons by looking at the overlapping substrings in the
    pattern itself to avoid redundant comparisons. Furthermore, we discussed the **Boyer-Moore
    algorithm**, which is very efficient when the text and pattern are long. It is
    the most popular algorithm used for string matching in practice.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在实时场景中有广泛应用的最多和最重要的字符串匹配算法。我们讨论了暴力、Rabin-Karp、KMP 和 Boyer-Moore 模式匹配算法。在字符串匹配算法中，我们试图揭示跳过不必要的比较并将模式尽可能快地移动到文本上的方法。**KMP
    算法**通过查看模式本身中的重叠子串来检测不必要的比较，以避免冗余比较。此外，我们还讨论了**Boyer-Moore 算法**，当文本和模式很长时，它非常高效。这是实际应用中用于字符串匹配的最流行算法。
- en: Exercise
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Show the KMP `prefix` function for the pattern `"aabaabcab"`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展示模式 `"aabaabcab"` 的 KMP `prefix` 函数。
- en: If the expected number of valid shifts is small and the modulus is larger than
    the length of the pattern, then what is the matching time of the Rabin-Karp algorithm?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果期望的有效位移数量很小，且模数大于模式的长度，那么 Rabin-Karp 算法的匹配时间是多少？
- en: Theta (m)
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Θ(m)
- en: Big O (n+m)
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大 O(n+m)
- en: Theta (n-m)
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Θ(n-m)
- en: Big O (n)
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大 O(n)
- en: How many spurious hits does the Rabin-Karp string matching algorithm encounter
    in the text `T = "3141512653849792"` when looking for all occurrences of the pattern
    `P = "26"`, working modulo `q = 11`, and over the alphabet set `Σ = {0, 1, 2,...,
    9}`?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在文本 `T = "3141512653849792"` 中寻找模式 `P = "26"` 的所有出现时，Rabin-Karp 字符串匹配算法在模 `q
    = 11` 和字母表集合 `Σ = {0, 1, 2,..., 9}` 上遇到多少个虚假匹配？
- en: What is the basic formula applied in the Rabin-Karp algorithm to get the computation
    time as Theta (m)?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rabin-Karp 算法中用于将计算时间作为 Θ(m) 的基本公式是什么？
- en: Halving rule
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二分法
- en: Horner’s rule
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Horner 规则
- en: Summation lemma
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求和引理
- en: Cancellation lemma
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抵消引理
- en: The Rabin-Karp algorithm can be used for discovering plagiarism in text documents.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Rabin-Karp 算法可用于在文本文档中检测剽窃。
- en: 'True'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: Join our community on Discord
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1421249772551223062.png)'
