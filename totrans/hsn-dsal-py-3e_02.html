<html><head></head><body>
  <div id="_idContainer046" class="Basic-Text-Frame">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-50" class="chapterTitle">Introduction to Algorithm Design</h1>
    <p class="normal">The objective of this chapter is to understand the principles of designing algorithms, and the importance of analyzing algorithms in solving real-world problems. Given input data, an algorithm is a step-by-step set of instructions that should be executed in sequence to solve a given problem.</p>
    <p class="normal">In this chapter, we will also learn how to compare different algorithms and determine the best algorithm for the given use-case. There can be many possible correct solutions for a given problem, for example, we can have several algorithms for the problem of sorting <em class="italic">n</em> numeric values. So, there is no one algorithm to solve any real-world problem.</p>
    <p class="normal">In this chapter, we will look at the following topics:</p>
    <ul>
      <li class="bulletList">Introducing algorithms</li>
      <li class="bulletList">Performance analysis of an algorithm</li>
      <li class="bulletList">Asymptotic notation</li>
      <li class="bulletList">Amortized analysis</li>
      <li class="bulletList">Choosing complexity classes</li>
      <li class="bulletList">Computing the running time complexity of an algorithm</li>
    </ul>
    <h1 id="_idParaDest-51" class="heading-1">Introducing algorithms</h1>
    <p class="normal">An algorithm<a id="_idIndexMarker143"/> is a sequence of steps that should be followed in order to complete a given task/problem. </p>
    <p class="normal">It is a well-defined procedure that takes input data, processes it, and produces the desired output. A representation of this is shown in <em class="italic">Figure 2.1</em>.</p>
    <figure class="mediaobject"><img src="../Images/B17217_02_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 2.1: Introduction to algorithms</p>
    <p class="normal">Summarized <a id="_idIndexMarker144"/>below are some important reasons for studying algorithms:</p>
    <ul>
      <li class="bulletList">Essential for computer science and engineering</li>
      <li class="bulletList">Important in many other domains (such as computational biology, economics, ecology, communications, ecology, physics, and so on)</li>
      <li class="bulletList">They play a role in technology innovation</li>
      <li class="bulletList">They improve problem-solving and analytical thinking</li>
    </ul>
    <p class="normal">There are two aspects that are of prime importance in solving a given problem. Firstly, we need an efficient mechanism to store, manage, and retrieve data, which is required to solve a problem (this comes under data structures); secondly, we require an efficient algorithm that is a finite set of instructions to solve that problem. Thus, the study of data structures and algorithms is key to solving any problem using computer programs. An efficient algorithm should have the<a id="_idIndexMarker145"/> following characteristics:</p>
    <ul>
      <li class="bulletList">It should be as specific as possible</li>
      <li class="bulletList">It should have each instruction properly defined</li>
      <li class="bulletList">There should not be any ambiguous instructions</li>
      <li class="bulletList">All the instructions of the algorithm should be executable in a finite amount of time and in a finite number of steps</li>
      <li class="bulletList">It should<a id="_idIndexMarker146"/> have clear input and output to solve the problem</li>
      <li class="bulletList">Each instruction of the algorithm should be integral in solving the given problem</li>
    </ul>
    <p class="normal">Consider an<a id="_idIndexMarker147"/> example of an algorithm (an analogy) to complete a task in our daily lives; let us take the example of preparing a cup of tea. The algorithm to prepare a cup of tea can include the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Pour water into the pan</li>
      <li class="numberedList">Put the pan on the stove and light the stove</li>
      <li class="numberedList">Add crushed ginger to the warming water</li>
      <li class="numberedList">Add tea leaves to the pan</li>
      <li class="numberedList">Add milk</li>
      <li class="numberedList">When it starts boiling, add sugar to it</li>
      <li class="numberedList">After 2-3 minutes, the tea can be served</li>
    </ol>
    <p class="normal">The above procedure is one of the possible ways to prepare tea. In the same way, the solution to a real-world problem can be converted into an algorithm, which can be developed into computer software using a programming language. Since it is possible to have several solutions for a given problem, it should be as efficient as possible when it is to be implemented using software. Given a problem, there may be more than one correct algorithm, defined as the one that produces exactly the desired output for all valid input values. The costs of executing different algorithms may be different; it may be measured in terms of the time required to run the algorithm on a computer system and the memory space required for it.</p>
    <p class="normal">There are primarily two things that one should keep in mind while designing an efficient algorithm:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The algorithm should be correct and should produce the results as expected for all valid input values</li>
      <li class="numberedList">The algorithm should be optimal in the sense that it should be executed on the computer within the desired time limit, in line with an optimal memory space requirement</li>
    </ol>
    <p class="normal">Performance analysis <a id="_idIndexMarker148"/>of the algorithm is very important for deciding the best solution for a given problem. If the performance of an algorithm is within the desired time and space requirements, it is optimal. One of the most popular and common methods of estimating the performance of an algorithm is through analyzing its complexity. Analysis of the algorithm helps us to determine which one is most efficient in terms of the time and space consumed.</p>
    <h1 id="_idParaDest-52" class="heading-1">Performance analysis of an algorithm</h1>
    <p class="normal">The performance<a id="_idIndexMarker149"/> of an algorithm is generally measured by the size of its input data, <em class="italic">n</em>, and the time and the memory space used by the algorithm. The time required is measured by the key operations to be performed by the algorithm (such as comparison operations), where key operations are instructions that take a significant amount of time during execution. Whereas the space requirement of an algorithm is measured by the memory needed to store the variables, constants, and instructions during the execution of the program.</p>
    <h2 id="_idParaDest-53" class="heading-2">Time complexity</h2>
    <p class="normal">The<a id="_idIndexMarker150"/> time complexity of the algorithm is the amount of time that an algorithm will take to execute on a computer system to <a id="_idIndexMarker151"/>produce the output. The aim of analyzing the time complexity of the algorithm is to determine, for a given problem and more than one algorithm, which one of the algorithms is the most efficient with respect to the time required to execute. The running time required by an algorithm depends on the input size; as the input size, <em class="italic">n</em>, increases, the runtime also increases. Input size is measured as the number of items in the input, for example, the input size for a sorting algorithm will be the number of items in the input. So, a sorting algorithm will have an increased runtime to sort a list of input size 5,000 than that of a list of input size 50.</p>
    <p class="normal">The<a id="_idIndexMarker152"/> runtime of an algorithm for a specific input depends on the key operations to be executed in the algorithm. For example, the key operation for a sorting algorithm is a comparison operation that will take up most of the runtime, compared to assignment or any other operation. Ideally, these key operations should not depend upon the hardware, the operating system, or the programming language being used to implement the algorithm.</p>
    <p class="normal">A <a id="_idIndexMarker153"/>constant amount of time is required to execute each line of code; however, each line may take a different amount of time to execute. In order to understand the running time required for an algorithm, consider the below code as an example:</p>
    <table id="table001-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Code</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Time required (Cost)</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span> || n == <span class="hljs-number">3</span>             <span class="hljs-comment">#constant time</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"data"</span>)
<span class="hljs-keyword">else</span>:
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(             <span class="hljs-comment">#loop run for n times</span>
     <span class="hljs-built_in">print</span>(<span class="hljs-string">"structure"</span>)
</code></pre>
          </td>
          <td class="table-cell">
            <pre class="programlisting code"><code class="hljs-code">c1
c2
c3
c4
c5
</code></pre>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Here, in statement 1 of the above example, if the condition is true then <code class="inlineCode">"data"</code> will be printed, and if the condition is not true then the <code class="inlineCode">for</code> loop will execute <code class="inlineCode">n</code> times. The time required <a id="_idIndexMarker154"/>by the algorithm depends on the time required for each statement, and how many times a statement is executed. The<a id="_idIndexMarker155"/> running time of the algorithm is the sum of time required by all the statements. For the above code, assume statement 1 takes <code class="inlineCode">c1</code> amount of time, statement 2 takes <code class="inlineCode">c2</code> amount of time, and so on. So, if the <em class="italic">i</em><sup class="superscript-italic" style="font-style: italic;">th</sup> statement takes a constant amount of time <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">i</sub><sub class="subscript"> </sub>and if the <em class="italic">i</em><sup class="superscript-italic" style="font-style: italic;">th</sup> statement is executed <code class="inlineCode">n</code> times, then it will take <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">i</sub><em class="italic">n</em> time. The total running time <code class="inlineCode">T(n)</code> of the algorithm for a given value of <em class="italic">n</em> (assuming the value of <em class="italic">n</em> is not zero or three) will be as follows.</p>
    <p class="center"><em class="italic">T</em>(<em class="italic">n</em>) = <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">1</sub> + <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">3</sub> + <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">4</sub> x <em class="italic">n</em> + <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">5</sub> x <em class="italic">n</em></p>
    <p class="normal">If the value of <code class="inlineCode">n</code> is equal to zero or three, then the time required by the algorithm will be as follows.</p>
    <p class="center"><em class="italic">T</em>(<em class="italic">n</em>) = <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">1</sub> + <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">2</sub></p>
    <p class="normal">Therefore, the running time required for an algorithm also depends upon what input is given in addition to the size of the input given. For the given example, the best case will be when the input is either zero or three, and in that case, the running time of the algorithm will be constant. In the worst case, the value of <code class="inlineCode">n</code> is not equal to zero or three, then, the running time of the algorithm can be represented as <em class="italic">a</em> x <em class="italic">n</em> + <em class="italic">b</em>. Here, the values of <code class="inlineCode">a</code> and <code class="inlineCode">b</code> are constants that depend on the statement costs, and the constant times are not considered in the final time complexity. In the worst case, the runtime required by the algorithm is a linear function of <em class="italic">n</em>.</p>
    <p class="normal">Let us consider another example, linear search:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">linear_search</span><span class="hljs-function">(</span><span class="hljs-params">input_list, element</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(input_list):
        <span class="hljs-keyword">if</span> value == element:
            <span class="hljs-keyword">return</span> index
        
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>
input_list = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">14</span>]  
element = <span class="hljs-number">4</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Index position for the element x is:"</span>, linear_search(input_list,element))
</code></pre>
    <p class="normal">The output in this instance will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Index position for the element x is: 1
</code></pre>
    <p class="normal">The <strong class="keyWord">worst-case running time</strong> of<a id="_idIndexMarker156"/> the algorithm is the upper-bound complexity; it is the maximum runtime required for an algorithm to execute for any given input. The worst-case time complexity is very useful in that it guarantees that for any input data, the runtime required will not take more time as compared to the worst-case running time. For example, in the linear search problem, the worst case occurs when the element to be searched is found in the last comparison or not found in the list. In this case, the running time required will linearly depend upon the length of the list, whereas, in the best case, the search element will be found in the first comparison.</p>
    <p class="normal">The <strong class="keyWord">average-case running time</strong> is the <a id="_idIndexMarker157"/>average running time required for an algorithm to execute. In this analysis, we compute the average over the running time for all possible input values. Generally, probabilistic analysis is used to analyze the average-case running time of an algorithm, which is computed by averaging the cost over the distribution of all the possible inputs. For example, in the linear search, the number of comparisons at all positions would be 1 if the element to be searched was found at the 0<sup class="superscript">th</sup> index; and similarly, the number of comparisons would be 2, 3, and so forth, up to <code class="inlineCode">n</code>, respectively, for elements found at the <code class="inlineCode">1, 2, 3, … (</code><em class="italic">n</em><code class="inlineCode">-1)</code> index positions. Thus, the average-case running time will be as follows.</p>
    <p class="center"><img src="../Images/B17217_02_001.png" alt="" style="height: 3.10em !important;"/></p>
    <p class="normal">For average-case, the running time required is also linearly dependent upon the value of <em class="italic">n</em>. However, in most real-world applications, worst-case analysis is mostly used, since it gives a guarantee that the running time will not take any longer than the worst-case running time of the algorithm for any input value.</p>
    <p class="normal"><strong class="keyWord">Best-case running time</strong> is <a id="_idIndexMarker158"/>the minimum time needed for an algorithm to run; it is the lower bound on the running time required for an algorithm; in the example above, the input data is organized in such a way that it takes its minimum running time to execute the given algorithm.</p>
    <h2 id="_idParaDest-54" class="heading-2">Space complexity</h2>
    <p class="normal">The <a id="_idIndexMarker159"/>space complexity of the algorithm estimates the memory requirement to execute it on a computer to produce the output<a id="_idIndexMarker160"/> as a function of input data. The memory space requirement of an algorithm is one of the criteria used to decide how efficient it is. While executing the algorithm on the computer system, storage of the input is required, along with intermediate and temporary data in data structures, which are stored in the memory of the computer. In order to write a programming solution for any problem, some memory is required for storing variables, program instructions, and executing the program on the computer. The space complexity of an algorithm is the amount of memory required for executing and producing the result.</p>
    <p class="normal">For computing the space complexity, consider the following example, in which, given a list of integer values, the function returns the square value of the corresponding integer number.</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">squares</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>
    square_numbers = []
<span class="hljs-keyword">    for</span> number <span class="hljs-keyword">in</span> n:
        square_numbers.append(number * number)
<span class="hljs-keyword">    return</span> square_numbers
 
nums = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span> ]
<span class="hljs-built_in">print</span>(squares(nums))
</code></pre>
    <p class="normal">The output of the code is:</p>
    <pre class="programlisting con"><code class="hljs-con">[4, 9, 25, 64]
</code></pre>
    <p class="normal">In the above code, the algorithm will require allocating memory for the number of items in the input list. Say the number of elements in the input is <code class="inlineCode">n</code>, then the space requirement increases with the input size, therefore, the space complexity of the algorithm becomes <code class="inlineCode">O(n)</code>.</p>
    <p class="normal">Given two<a id="_idIndexMarker161"/> algorithms to solve a given problem, with all other requirements being equal, then the algorithm that requires less <a id="_idIndexMarker162"/>memory can be considered more efficient. For example, suppose there are two search algorithms, one has <code class="inlineCode">O(n)</code> and another algorithm has <code class="inlineCode">O(nlogn)</code> space complexity. The first algorithm is the better algorithm as compared to the second with respect to the space requirements. Space complexity analysis is important to understand the efficiency of an algorithm, especially for applications where the memory space requirement is high.</p>
    <p class="normal">When the input size becomes large enough, the order of growth also becomes important. In such situations, we study the asymptotic efficiency of algorithms. Generally, algorithms that are asymptotically efficient are considered to be better algorithms for large-size inputs. In the next section, we will study asymptotic notation.</p>
    <h1 id="_idParaDest-55" class="heading-1">Asymptotic notation</h1>
    <p class="normal">To <a id="_idIndexMarker163"/>analyze the time complexity of an algorithm, the rate of growth (order of growth) is very important when the input size is large. When the input size becomes large, we only consider the higher-order terms and ignore the insignificant terms. In asymptotic analysis, we analyze the efficiency of algorithms for large input sizes considering the higher order of growth and ignoring the multiplicative constants and lower-order terms. </p>
    <p class="normal">We compare two algorithms with respect to input size rather than the actual runtime and measure how the time taken increases with an increased input size. The algorithm which is more efficient asymptotically is generally considered a better algorithm as compared to the other algorithm. The following asymptotic notations are commonly <a id="_idIndexMarker164"/>used to calculate the running time complexity of an algorithm:</p>
    <ul>
      <li class="bulletList">θ notation: It denotes the worst-case running time complexity with a tight bound.</li>
      <li class="bulletList">Ο notation: It denotes the worst-case running time complexity with an upper bound, which ensures that the function never grows faster than the upper bound.</li>
      <li class="bulletList">Ω notation: It denotes the lower bound of an algorithm’s running time. It measures the <a id="_idIndexMarker165"/>best amount of time to execute the algorithm.</li>
    </ul>
    <h2 id="_idParaDest-56" class="heading-2">Theta notation</h2>
    <p class="normal">The<a id="_idIndexMarker166"/> following function characterizes the worst-case running time for the first example discussed in the <em class="italic">Time complexity</em> section:</p>
    <p class="center"><em class="italic">T</em>(<em class="italic">n</em>) = <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">1</sub> + <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">3</sub> x <em class="italic">n</em> + <em class="italic">c</em><sub class="subscript-italic" style="font-style: italic;">5</sub> x <em class="italic">n</em></p>
    <p class="normal">Here, for a<a id="_idIndexMarker167"/> large input size, the worst-case running time will be <code class="inlineCode">ϴ(n)</code> (pronounced as theta of <code class="inlineCode">n</code>). We usually consider one algorithm to be more efficient than another if its worst-case running time has a lower order of growth. Due to constant factors and lower-order terms, an algorithm whose running time has a higher order of growth might take less time for small inputs than an algorithm whose running time has a lower order of growth. For example, once the input size <code class="inlineCode">n</code> becomes large enough, the merge sort algorithm performs better as compared to insertion sort with worst-case running times of <code class="inlineCode">ϴ(logn)</code> and <code class="inlineCode">ϴ(n<sup class="superscript">2</sup><code class="inlineCode">)</code></code> respectively.</p>
    <p class="normal">Theta notation (<code class="inlineCode">ϴ</code>) denotes the worst-case running time for an algorithm with a tight bound. For a given function <em class="italic">F</em>(<em class="italic">n</em>), the asymptotic worst-case running time complexity can be defined as follows.</p>
    <p class="center"><img src="../Images/B17217_02_002.png" alt="" style="height: 1.6em !important;"/></p>
    <p class="normal">iff there exists constants <em class="italic">n</em><sub class="subscript">0</sub>, <em class="italic">c</em><sub class="subscript">1</sub>, and <em class="italic">c</em><sub class="subscript">2</sub> such that:</p>
    <p class="center"><img src="../Images/B17217_02_003.png" alt="" style="height: 1.6em !important;"/></p>
    <p class="normal">The function <em class="italic">T</em>(<em class="italic">n</em>) belongs to a set of functions <em class="italic">ϴ</em>(<em class="italic">F</em>(<em class="italic">n</em>)) if there exists positive constants <em class="italic">c</em><sub class="subscript">1</sub> and c<sub class="subscript">2</sub> such that the value of <em class="italic">T</em>(<em class="italic">n</em>) always lies in between <em class="italic">c</em><sub class="subscript">1</sub><em class="italic">F</em>(<em class="italic">n</em>) and <em class="italic">c</em><sub class="subscript">2</sub><em class="italic">F</em>(<em class="italic">n</em>) for all large values of <em class="italic">n</em>. If this condition is true, then we say <em class="italic">F</em>(<em class="italic">n</em>) is asymptotically tight bound for <em class="italic">T</em>(<em class="italic">n</em>).</p>
    <p class="normal"><em class="italic">Figure 2.2</em> shows the graphic example of the theta notation (<em class="italic">ϴ</em>). It can be observed from the figure that the value of <em class="italic">T</em>(<em class="italic">n</em>) always lies in between <em class="italic">c</em><sub class="subscript">1</sub><em class="italic">F</em>(<em class="italic">n</em>) and <em class="italic">c</em><sub class="subscript">2</sub><em class="italic">F</em>(<em class="italic">n</em>) for values of n greater than <em class="italic">n</em><sub class="subscript">0</sub>.</p>
    <figure class="mediaobject"><img src="../Images/B17217_02_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 2.2: Graphical example of theta notation (ϴ)</p>
    <p class="normal">Let us consider<a id="_idIndexMarker168"/> an example to understand what should be <a id="_idIndexMarker169"/>the worst case running time complexity with the formal definition of theta notation for a given function:</p>
    <p class="center"><img src="../Images/B17217_02_004.png" alt="" style="height: 1.4em !important;"/></p>
    <p class="normal">In order to determine the time complexity with the <em class="italic">ϴ</em> notation definition, we have to first identify the constants c<sub class="subscript">1</sub>, c<sub class="subscript">2</sub>, n<sub class="subscript">0</sub> such that</p>
    <p class="center"><img src="../Images/B17217_02_005.png" alt="" style="height: 1.4em !important;"/></p>
    <p class="normal">Dividing by n<sup class="superscript">2</sup> will produce:</p>
    <p class="center"><img src="../Images/B17217_02_006.png" alt="" style="height: 2.6em !important;"/></p>
    <p class="normal">By choosing c<sub class="subscript">1 </sub>= 1, c<sub class="subscript">2 </sub>= 2, and n<sub class="subscript">0 </sub>= 1, the following condition can satisfy the definition of theta notation.</p>
    <p class="center"><img src="../Images/B17217_02_007.png" alt="" style="height: 1.6em !important;"/></p>
    <p class="normal">That gives:</p>
    <p class="center"><img src="../Images/B17217_02_008.png" alt="" style="height: 1.4em !important;"/></p>
    <p class="normal">Consider <a id="_idIndexMarker170"/>another example to find out the asymptotically tight bound (<code class="inlineCode">ϴ</code>) for another function:</p>
    <p class="center"><img src="../Images/B17217_02_009.png" alt="" style="height: 2.4em !important;"/></p>
    <p class="normal">In order to<a id="_idIndexMarker171"/> identify the constants c<sub class="subscript">1</sub>, c<sub class="subscript">2</sub>, and n<sub class="subscript">0</sub>, such that they satisfy the condition:</p>
    <p class="center"><img src="../Images/B17217_02_010.png" alt="" style="height: 2.6em !important;"/></p>
    <p class="normal">By choosing c<sub class="subscript">1 </sub>= 1/5, c<sub class="subscript">2 </sub>=1, and n<sub class="subscript">0 </sub>= 1, the following condition can satisfy the definition of theta notation:</p>
    <p class="center"><img src="../Images/B17217_02_011.png" alt="" style="height: 2.6em !important;"/></p>
    <p class="center"><img src="../Images/B17217_02_012.png" alt="" style="height: 2.6em !important;"/></p>
    <p class="normal">So, the following is true:</p>
    <p class="center"><img src="../Images/B17217_02_013.png" alt="" style="height: 2.6em !important;"/></p>
    <p class="normal">It shows that the given function has the complexity of <code class="inlineCode">ϴ</code>(n<sup class="superscript">2</sup>) as per the definition of theta notation.</p>
    <p class="normal">So, the theta notation provides a tight bound for the time complexity of an algorithm. In the next section, we will discuss Big O notation.</p>
    <h2 id="_idParaDest-57" class="heading-2">Big O notation</h2>
    <p class="normal">We <a id="_idIndexMarker172"/>have seen that the theta notation is asymptotically <a id="_idIndexMarker173"/>bound from the upper and lower sides of the function whereas the Big O notation characterizes the worst-case running time complexity, which is only the asymptotic upper bound of the function. Big O notation is defined as follows. Given a function <em class="italic">F</em>(<em class="italic">n</em>), the <em class="italic">T</em>(<em class="italic">n</em>) is a Big O of function <em class="italic">F</em>(<em class="italic">n</em>), and we define this as follows:</p>
    <p class="center"><em class="italic">T</em>(<em class="italic">n</em>) = O(<em class="italic">F</em>(<em class="italic">n</em>))</p>
    <p class="normal">iff there exists constants n<sub class="subscript">0</sub> and <em class="italic">c</em> such that:</p>
    <p class="center"><img src="../Images/B17217_02_014.png" alt="" style="height: 1.4em !important;"/></p>
    <p class="normal">In Big O notation, a constant multiple of <em class="italic">F</em>(<em class="italic">n</em>) is an asymptotic upper bound on <em class="italic">T</em>(<em class="italic">n</em>), and the positive constants n<sub class="subscript">0</sub> and <em class="italic">c </em>should be in such a way that all values of <code class="inlineCode">n</code> greater than n<sub class="subscript">0 </sub>always lie on or below function <em class="italic">c</em>*<em class="italic">F</em>(<em class="italic">n</em>). </p>
    <p class="normal">Moreover, we only care what happens at higher values of <em class="italic">n</em>. The variable n<sub class="subscript">0</sub> represents the threshold below which the rate of growth is not important. The plot shown in <em class="italic">Figure 2.3</em> shows a graphical representation of function <em class="italic">T</em>(<em class="italic">n</em>) with a varying value of <code class="inlineCode">n</code>. We can see that <em class="italic">T</em>(<em class="italic">n</em>) = n<sup class="superscript">2</sup> + 500 = O(n<sup class="superscript">2</sup>), with <em class="italic">c</em> = 2 and n<sub class="subscript">0</sub> being approximately <code class="inlineCode">23</code>.</p>
    <figure class="mediaobject"><img src="../Images/B17217_02_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 2.3: Graphical example of O notation</p>
    <p class="normal">In O <a id="_idIndexMarker174"/>notation, <em class="italic">O</em>(<em class="italic">F</em>(<em class="italic">n</em>)) is really a set of functions that includes all<a id="_idIndexMarker175"/> functions with the same or smaller rates of growth than <em class="italic">F</em>(<em class="italic">n</em>). For example, <em class="italic">O</em>(n<sup class="superscript">2</sup>) also includes <em class="italic">O</em>(<em class="italic">n</em>), <em class="italic">O</em>(log <em class="italic">n</em>), and so on. However, Big O notation should characterize a function as closely as possible, for example, it is true that function <em class="italic">F</em>(<em class="italic">n</em>) = 2n<sup class="superscript">3</sup>+2n<sup class="superscript">2</sup>+5 is O(n<sup class="superscript">4</sup>), however, it is more accurate that <em class="italic">F</em>(<em class="italic">n</em>) is <em class="italic">O</em>(n<sup class="superscript">3</sup>).</p>
    <p class="normal">In the following table, we list the most common growth rates in order from lowest to highest.</p>
    <table id="table002-1" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Time Complexity</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Name</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(1)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Constant</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(logn)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Logarithmic</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Linear</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(nlogn)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Linear-logarithmic</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n2)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Quadratic</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(n3)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Cubic</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">O(2n)</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Exponential</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 2.1: Runtime complexity of different functions</p>
    <p class="normal">Using <a id="_idIndexMarker176"/>Big O notation, the running time of an algorithm can be computed by analyzing the structure of <a id="_idIndexMarker177"/>the algorithm. For example, a double nested loop in an algorithm will have an upper bound on the worst-case running time of O(n<sup class="superscript">2</sup>), since the values of <code class="inlineCode">i</code> and <code class="inlineCode">j</code> will be at most <em class="italic">n</em>, and both the loops will run n<sup class="superscript">2</sup> times as shown in the below example code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): 
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): 
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"data"</span>)
</code></pre>
    <p class="normal">Let us consider a few examples in order to compute the upper bound of a function using the O-notation:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Find the upper bound for the function: <p class="normal">T(n) = 2n + 7</p>
        <p class="normal"><strong class="keyWord">Solution</strong>: Using O notation, the condition for the upper bound is:</p>
        <p class="center"><em class="italic">T</em>(<em class="italic">n</em>) &lt;= <em class="italic">c</em> * <em class="italic">F</em>(<em class="italic">n</em>)</p>
        <p class="normal">This condition holds true for all values of n &gt; 7 and <em class="italic">c</em>=3.</p>
        <p class="normal"><em class="italic">2n + 7 &lt;= 3n</em> This is true for all values of n, with <em class="italic">c</em>=3, n<sub class="subscript">0</sub>=7</p>
        <p class="normal"><em class="italic">T(n) = 2n+7 = O(n)</em></p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Find F(n) for functions <em class="italic">T(n) =2n+5 such that T(n) = O(F(n))</em>. <p class="normal"><strong class="keyWord">Solution</strong>: Using O notation, the condition for the upper bound is <em class="italic">T(n) &lt;=c * F(n)</em>.</p>
        <p class="normal">Since, 2n+5 ≤ 3n, for all n ≥ 5.</p>
        <p class="normal">The condition is true for <em class="italic">c</em>=3, n<sub class="subscript">0</sub>=5.</p>
        <p class="normal"><em class="italic">2n + 5 ≤ O(n)</em></p>
        <p class="normal"><em class="italic">F(n) = n</em></p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Find F(n) for the function <em class="italic">T(n) = n</em><sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">2</sup><em class="italic"> +n, such that T(n) = O(F(n))</em>. <p class="normal"><strong class="keyWord">Solution</strong>: Using O notation, since, <em class="italic">n</em><sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">2</sup><em class="italic">+ n ≤ 2n</em><sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">2</sup><em class="italic">, for all n ≥ 1 (with c = 2, n</em><sub class="subscript-italic" style="font-style: italic;">0</sub><em class="italic">=2)</em></p>
        <p class="normal">n<sup class="superscript">2</sup>+ n ≤ O(n<sup class="superscript">2</sup>)</p>
        <p class="normal">F(n) = n<sup class="superscript">2</sup></p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Prove that f(n) =2n<sup class="superscript">3 </sup>- 6n ≠ O(n<sup class="superscript">2</sup>). <p class="normal"><strong class="keyWord">Solution</strong>: Clearly, 2n<sup class="superscript">3</sup>-6n ≥ n<sup class="superscript">2</sup>, for n ≥ 2. So it cannot be true that 2n<sup class="superscript">3</sup> - 6n ≠ O(n<sup class="superscript">2</sup>).</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Prove that: 20n<sup class="superscript">2</sup>+2n+5 = O(n<sup class="superscript">2</sup>). <p class="normal"><strong class="keyWord">Solution</strong>: It is clear that:</p>
        <p class="normal">20n<sup class="superscript">2</sup> + 2n + 5 &lt;= 21n<sup class="superscript">2</sup> for all n &gt; 4 (let c = 21 and n<sub class="subscript">0</sub> = 4)</p>
        <p class="normal">n<sup class="superscript">2</sup> &gt; 2n + 5 for all n &gt; 4</p>
        <p class="normal">So, the complexity is O(n<sup class="superscript">2</sup>).</p>
      </li>
    </ol>
    <p class="normal">So, Big-O notation <a id="_idIndexMarker178"/>provides an upper bound on a function, which <a id="_idIndexMarker179"/>ensures that the function never grows faster than the upper-bounded function. In the next section, we will discuss Omega notation.</p>
    <h2 id="_idParaDest-58" class="heading-2">Omega notation</h2>
    <p class="normal">Omega notation (Ω) describes<a id="_idIndexMarker180"/> an asymptotic <a id="_idIndexMarker181"/>lower bound on algorithms, similar to the way in which Big O notation describes an upper bound. Omega notation computes the best-case runtime complexity of the algorithm. The Ω notation (<em class="italic">Ω</em>(<em class="italic">F</em>(<em class="italic">n</em>)) is pronounced as omega of F of n), is a set of functions in such a way that there are positive constants n<sub class="subscript">0</sub> and c such that for all values of n greater than n<sub class="subscript">0</sub>, <em class="italic">T</em>(<em class="italic">n</em>) always lies on or above a function to <em class="italic">c</em>*<em class="italic">F</em>(<em class="italic">n</em>).</p>
    <p class="center"><em class="italic">T</em>(<em class="italic">n</em>) = <em class="italic">Ω</em> (<em class="italic">F</em>(<em class="italic">n</em>))</p>
    <p class="normal">Iff constants n<sub class="subscript">0</sub> and c are present, then:</p>
    <p class="center"><img src="../Images/B17217_02_015.png" alt="" style="height: 1.6em !important;"/></p>
    <p class="normal"><em class="italic">Figure 2.4</em> shows the graphical representation of the omega (Ω) notation. It can be observed from the figure that the value of <em class="italic">T</em>(<em class="italic">n</em>) always lies above cF(n) for values of <em class="italic">n</em> greater than n<sub class="subscript">0</sub>.</p>
    <figure class="mediaobject"><img src="../Images/B17217_02_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 2.4: The graphical representation of Ω notation</p>
    <p class="normal">If the <a id="_idIndexMarker182"/>running time of an algorithm is <em class="italic">Ω</em>(<em class="italic">F</em>(<em class="italic">n</em>)), it means<a id="_idIndexMarker183"/> that the running time of the algorithm is at least a constant multiplier of <em class="italic">F</em>(<em class="italic">n</em>) for sufficiently large values of input size (n). The Ω notation gives a lower bound on the best-case running time complexity of a given algorithm. It means that the running time for a given algorithm will be at least <em class="italic">F</em>(<em class="italic">n</em>) without depending upon the input.</p>
    <p class="normal">In order to understand the Ω notation and how to compute the lower bound on the best-case runtime complexity of an algorithm:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Find <em class="italic">F</em>(<em class="italic">n</em>) for the function <em class="italic">T</em>(<em class="italic">n</em>) =2n<sup class="superscript">2</sup> +3 such that <em class="italic">T</em>(<em class="italic">n</em>) = <em class="italic">Ω</em>(<em class="italic">F</em>(<em class="italic">n</em>)). <p class="normal"><strong class="keyWord">Solution</strong>: Using the Ω notation, the condition for the lower bound is:</p>
        <p class="normal">c*F(n) ≤ T(n)</p>
        <p class="normal">This condition holds true for all values of n greater than 0, and c=1.</p>
        <p class="normal">0 ≤ cn<sup class="superscript">2 </sup>≤ 2n<sup class="superscript">2</sup> +3, for all n ≥ 0</p>
        <p class="normal">2n<sup class="superscript">2</sup> +3 = Ω(n<sup class="superscript">2</sup>)</p>
        <p class="normal">F(n)=n<sup class="superscript">2</sup></p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Find the lower bound for T(n) = 3n<sup class="superscript">2</sup>. <p class="normal"><strong class="keyWord">Solution</strong>: Using the Ω notation, the condition for the lower bound is:</p>
        <p class="normal">c*F(n) ≤ T(n)</p>
        <p class="normal">Consider 0 ≤ cn<sup class="superscript">2</sup> ≤ 3n<sup class="superscript">2</sup>. The condition for Ω notation holds true for all values of n greater than 1, and c=2.</p>
        <p class="normal">cn<sup class="superscript">2</sup> ≤ 3n<sup class="superscript">2</sup> (for c = 2 and n<sub class="subscript">0</sub> = 1)</p>
        <p class="normal">3n<sup class="superscript">2 </sup>= Ω(n<sup class="superscript">2</sup>)</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Prove that 3n = Ω(n). <p class="normal"><strong class="keyWord">Solution</strong>: Using the Ω notation, the condition for the lower bound is: </p>
        <p class="normal">c*F(n) ≤ T(n)</p>
        <p class="normal">Consider 0 ≤ c*n<sup class="superscript"> </sup> ≤ 3n. The condition for Ω notation holds true for all values of n greater than 1, and c=1.</p>
        <p class="normal">cn<sup class="superscript">2 </sup> ≤ 3n<sup class="superscript">2 </sup>( for c = 2 and n<sub class="subscript">0</sub> = 1)</p>
        <p class="normal">3n = Ω(n)</p>
      </li>
    </ol>
    <p class="normal">The Ω notation <a id="_idIndexMarker184"/>is used to describe that at least a certain <a id="_idIndexMarker185"/>amount of running time will be taken by an algorithm for a large input size. In the next section, we will discuss amortized analysis.</p>
    <h1 id="_idParaDest-59" class="heading-1">Amortized analysis</h1>
    <p class="normal">In the amortized analysis <a id="_idIndexMarker186"/>of an algorithm, we average the time required to execute a sequence of operations with all the operations of the algorithm. This is called amortized analysis. Amortized analysis is important when we are not interested in the time complexity of individual operations but we are interested in the average runtime of sequences of operations. In an algorithm, each operation requires a different amount of time to execute. Certain operations require significant amounts of time and resources while some operations are not costly at all. In amortized analysis, we analyze algorithms considering both the costly and less costly <a id="_idIndexMarker187"/>operations in order to analyze all the sequences of operations. So, an amortized analysis is the average performance of each operation in the worst case considering the cost of the complete sequence of all the operations. Amortized analysis is different from average-case analysis since the distribution of the input values is not considered. An amortized analysis gives the average performance of each operation in the worst case.</p>
    <p class="normal">There are three commonly used methods for amortized analysis:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Aggregate analysis</strong>. In <a id="_idIndexMarker188"/>aggregate analysis, the amortized cost is the average cost of all the sequences of operations. For a given sequence of n operations, the amortized cost of each operation can be computed by dividing the upper bound on the total cost of n operations with n.</li>
      <li class="bulletList"><strong class="keyWord">The accounting method</strong>. In <a id="_idIndexMarker189"/>the accounting method, we assign an amortized cost to each operation, which may be different than their actual cost. In this, we impose an extra charge on early operations in the sequence and save “credit cost,” which is used to pay expensive operations later in the sequence.</li>
      <li class="bulletList"><strong class="keyWord">The potential method</strong>. The <a id="_idIndexMarker190"/>potential method is like the accounting method. We determine the amortized cost of each operation and impose an extra charge to early operations that may be used later in the sequence. Unlike the accounting method, the potential method accumulates the overcharged credit as “potential energy” of the data structure as a whole instead of storing credit for individual operations.</li>
    </ul>
    <p class="normal">In this section, we had an overview of amortized analysis. Now we will discuss how to compute the complexity of different functions with examples in the next section.</p>
    <h1 id="_idParaDest-60" class="heading-1">Composing complexity classes</h1>
    <p class="normal">Normally, we<a id="_idIndexMarker191"/> need to find the total running time of complex operations and algorithms. It turns out that we can combine the complexity classes of simple operations to find the complexity class of more complex, combined operations. The goal is to analyze the combined statements in a function or method to understand the total time complexity of executing several operations. The simplest way to combine two complexity classes is to add them. This occurs when we have two sequential operations. For example, consider the two operations of inserting an element into a list and then sorting that list. Assuming that inserting an item occurs in O(n) time, and sorting in O(nlogn) time, then we can write the total time complexity as O(n + nlogn); that is, we bring the two functions inside the O(…), as per Big O computation. Considering only the highest-order term, the final worst-case complexity becomes O(nlogn).</p>
    <p class="normal">If we repeat an <a id="_idIndexMarker192"/>operation, for example in a <code class="inlineCode">while</code> loop, then we multiply the complexity class by the number of times the operation is carried out. If an operation with time complexity O(<em class="italic">f</em>(<em class="italic">n</em>)) is repeated O(<em class="italic">n</em>) times, then we multiply the two complexities: O(<em class="italic">f</em>(<em class="italic">n</em>) * O(<em class="italic">n</em>)) = O(<em class="italic">nf</em>(<em class="italic">n</em>)). For example, suppose the function <em class="italic">f</em>(<em class="italic">n</em>) has a time complexity of O(<em class="italic">n</em><sup class="superscript">2</sup>) and it is executed <em class="italic">n</em> times in a <code class="inlineCode">for</code> loop, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
        f(...)
</code></pre>
    <p class="normal">The time complexity of the above code then becomes:</p>
    <p class="center">O(<em class="italic">n</em><sup class="superscript">2</sup>) x O(<em class="italic">n</em>) = O(<em class="italic">n</em> x <em class="italic">n</em><sup class="superscript">2</sup>) = O(<em class="italic">n</em><sup class="superscript">3</sup>)</p>
    <p class="normal">Here, we are multiplying the time complexity of the inner function by the number of times this function executes. The runtime of a loop is at most the runtime of the statements inside the loop multiplied by the number of iterations. A single nested loop, that is, one loop nested inside another loop, will run <em class="italic">n</em><sup class="superscript-italic" style="font-style: italic;">2</sup> times, such as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)
        <span class="hljs-comment">#statements</span>
</code></pre>
    <p class="normal">If each execution of the statements takes constant time, <em class="italic">c</em>, i.e. O(1), executed <em class="italic">n</em> x <em class="italic">n</em> times, we can express the running time as follows:</p>
    <p class="center"><em class="italic">c</em> x <em class="italic">n</em> x <em class="italic">n</em> = <em class="italic">c</em> x <em class="italic">n</em><sup class="superscript">2</sup> = O(<em class="italic">n</em><sup class="superscript">2</sup>)</p>
    <p class="normal">For consecutive statements within nested loops, we add the time complexities of each statement and multiply by the number of times the statement is executed—as in the following code, for example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">fun</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>
   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment">#executes n times</span>
      <span class="hljs-built_in">print</span>(i)     <span class="hljs-comment">#c1</span>
   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): 
      <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
         <span class="hljs-built_in">print</span>(j)  <span class="hljs-comment">#c2</span>
</code></pre>
    <p class="normal">This can be written as: <em class="italic">c</em><sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">1</sup><em class="italic">n + c</em><sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">2</sup><em class="italic"> *n</em><sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">2</sup><em class="italic"> = O(n</em><sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">2</sup><em class="italic">)</em>.</p>
    <p class="normal">We can define (base 2) logarithmic complexity, reducing the size of the problem by half, in constant time. For example, consider the following snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code">i = <span class="hljs-number">1</span>
<span class="hljs-keyword">while</span> i &lt;= n:
    i = i*<span class="hljs-number">2</span>
    <span class="hljs-built_in">print</span>(i)
</code></pre>
    <p class="normal">Notice that <code class="inlineCode">i</code> is doubling <a id="_idIndexMarker193"/>in each iteration. If we run this code with n = 10, we see that it prints out four numbers: 2, 4, 8, and 16. If we double n, we see it prints out five numbers. With each subsequent doubling of n, the number of iterations is only increased by 1. If we assume that the loop has k iterations, then the value of n will be 2<sup class="superscript">n</sup>. We can write this as follows:</p>
    <p class="center"><img src="../Images/B17217_02_016.png" alt="" style="height: 1.4em !important;"/></p>
    <p class="center"><img src="../Images/B17217_02_017.png" alt="" style="height: 1.4em !important;"/></p>
    <p class="center"><img src="../Images/B17217_02_018.png" alt="" style="height: 1.4em !important;"/></p>
    <p class="normal">From this, the worst-case runtime complexity of the above code is equal to O(log(n)).</p>
    <p class="normal">In this section, we have seen examples to compute the running time complexity of different functions. In the next section, we will take examples to understand how to compute the running time complexity of an algorithm.</p>
    <h1 id="_idParaDest-61" class="heading-1">Computing the running time complexity of an algorithm</h1>
    <p class="normal">To analyze an <a id="_idIndexMarker194"/>algorithm with respect to the best-, worst-, and average-case runtime of the algorithm, it is not always possible to compute these for every given function or algorithm. However, it is always important to know the upper-bound worst-case runtime <a id="_idIndexMarker195"/>complexity of an algorithm in practical situations; therefore, we focus on computing the upper-bound Big O notation to compute the worst-case runtime complexity of an algorithm:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Find the worst-case runtime complexity of the following Python snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># loop will run n times</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
<span class="hljs-built_in">    print</span>(<span class="hljs-string">"data"</span>)  <span class="hljs-comment">#constant time</span>
</code></pre>
        <p class="normal"><strong class="keyWord">Solution</strong>: The runtime for a loop, in general, takes the time taken by all statements in the loop, multiplied by the number of iterations. Here, total runtime is defined as follows:</p>
        <p class="normal">T(n) = constant time (c) * n = c*n = O(n)</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Find the time complexity of the following Python snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n): 
<span class="hljs-keyword">    for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment"># This loop will also run for n times</span>
<span class="hljs-built_in">        print</span>(<span class="hljs-string">"run"</span>)
</code></pre>
        <p class="normal"><strong class="keyWord">Solution</strong>: O(n<sup class="superscript-bold-italic" style="font-style: italic; font-weight: bold;">2</sup>). The <code class="inlineCode">print</code> statement will be executed n<sup class="superscript">2</sup> times, n times for the inner loop, and, for each iteration of the outer loop, the inner loop will be executed.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Find the time complexity of the following Python snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
<span class="hljs-keyword">    for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
<span class="hljs-built_in">        print</span>(<span class="hljs-string">"run fun"</span>)
<span class="hljs-built_in">       </span><span class="hljs-keyword">break</span>
</code></pre>
        <p class="normal"><strong class="keyWord">Solution</strong>: The worst-case complexity will be O(n) since the <code class="inlineCode">print</code> statement will run <em class="italic">n</em> times because the inner loop executes only once due to a <code class="inlineCode">break</code> statement.</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Find the time complexity of the following Python snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">fun</span><span class="hljs-function">(</span><span class="hljs-params">n</span><span class="hljs-function">):</span>
<span class="hljs-keyword">    for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
<span class="hljs-built_in">        print</span>(<span class="hljs-string">"data"</span>)  <span class="hljs-comment">#constant time</span>
 <span class="hljs-comment">#outer loop execute for n times</span>
<span class="hljs-keyword">    for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):
<span class="hljs-keyword">        for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):  <span class="hljs-comment">#inner loop execute n times</span>
<span class="hljs-built_in">            print</span>(<span class="hljs-string">"run fun"</span>)  <span class="hljs-comment">#constant time</span>
</code></pre>
        <p class="normal"><strong class="keyWord">Solution</strong>: Here, the <code class="inlineCode">print</code> statements will execute <em class="italic">n</em> times in the first loop and <em class="italic">n</em><sup class="superscript-italic" style="font-style: italic;">2</sup> times for the second nested loop. Here, the total time required is defined<a id="_idIndexMarker196"/> as the following:</p>
        <p class="normal">T(n) = constant time (c<sub class="subscript">1</sub>) * n + c<sub class="subscript">2</sub>*n*n</p>
        <p class="normal">c<sub class="subscript">1</sub> n + c<sub class="subscript">2</sub> n<sup class="superscript">2</sup> = O(n<sup class="superscript">2</sup>)</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Find <a id="_idIndexMarker197"/>the time complexity of the following Python snippet:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span>  n == <span class="hljs-number">0</span>:     <span class="hljs-comment">#constant time</span>
<span class="hljs-built_in">    print</span>(<span class="hljs-string">"data"</span>)
<span class="hljs-keyword">else</span>: 
<span class="hljs-keyword">    for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):    <span class="hljs-comment">#loop run for n times </span>
<span class="hljs-built_in">      print</span>(<span class="hljs-string">"structure"</span>)
</code></pre>
        <p class="normal"><strong class="keyWord">Solution</strong>: O(n). Here, the worst-case runtime complexity will be the time required for the execution of all the statements; that is, the time required for the execution of the <code class="inlineCode">if-else</code> conditions, and the <code class="inlineCode">for</code> loop. The time required is defined as the following:</p>
        <p class="normal">T(n) = c<sub class="subscript">1</sub> + c<sub class="subscript">2</sub> n = O(n)</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Find the time complexity of the following Python snippet:
        <pre class="programlisting code"><code class="hljs-code">i = <span class="hljs-number">1</span>
j = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i*i &lt; n: 
    j = j +<span class="hljs-number">1</span> 
    i = i+<span class="hljs-number">1</span> 
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"data"</span>)
</code></pre>
        <p class="normal"><strong class="keyWord">Solution</strong>: O(<img src="../Images/Eqn_02_notation4.png" alt="" style="height: 1.25em !important; vertical-align: -0.10em !important;"/>). The loop will terminate based on the value of <code class="inlineCode">i</code>; the loop will iterate based on the condition:</p>
        <p class="normal"><img src="../Images/Eqn_02_notation5.png" alt="" style="height: 1.2em !important; vertical-align: -0.0em !important;"/></p>
        <p class="normal">T(n) = O(<img src="../Images/Eqn_02_notation41.png" alt="" style="height: 1.25em !important; vertical-align: -0.10em !important;"/>)</p>
      </li>
    </ol>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="7">Find the<a id="_idIndexMarker198"/> time complexity of the following Python snippet:
        <pre class="programlisting code"><code class="hljs-code">i = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(n/<span class="hljs-number">2</span>), n):
    j = <span class="hljs-number">1</span>
<span class="hljs-keyword">    while</span> j+n/<span class="hljs-number">2</span> &lt;= n:
    k = <span class="hljs-number">1</span>
         <span class="hljs-keyword">while</span> k &lt; n:
         k *= <span class="hljs-number">2</span>
         <span class="hljs-built_in">print</span>(<span class="hljs-string">"data"</span>)
         j += <span class="hljs-number">1</span>
</code></pre>
        <p class="normal"><strong class="keyWord">Solution</strong>: Here, the <a id="_idIndexMarker199"/>outer loop will execute n/2 times, the middle loop will also run n/2 times, and the innermost loop will run for log(n) time. So, the total running time complexity will be O(n*n*logn):</p>
        <p class="normal">O(n<sup class="superscript">2</sup>logn)</p>
      </li>
    </ol>
    <h1 id="_idParaDest-62" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we have looked at an overview of algorithm design. The study of algorithms is important because it trains us to think very specifically about certain problems. It is conducive to increasing our problem-solving abilities by isolating the components of a problem and defining the relationships between them. In this chapter, we discussed different methods for analyzing algorithms and comparing algorithms. We also discussed asymptotic notations, namely: Big Ο, Ω, and θ notation. </p>
    <p class="normal">In the next chapter, we will discuss algorithm design techniques and strategies.</p>
    <h1 id="_idParaDest-63" class="heading-1">Exercises</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Find the time complexity of the following Python snippets:</li>
    </ol>
    <ol class="alphabeticList" style="list-style-type: lower-alpha;">
      <li class="alphabeticList" value="1">
        <pre class="programlisting code"><code class="hljs-code">i=<span class="hljs-number">1</span>
<span class="hljs-keyword">while</span>(i&lt;n):
    i*=<span class="hljs-number">2</span>
<span class="hljs-built_in">    print</span>("data")
</code></pre>
      </li>
      <li class="alphabeticList">
        <pre class="programlisting code"><code class="hljs-code">i =n
<span class="hljs-keyword">while</span>(i&gt;<span class="hljs-number">0</span>):
    <span class="hljs-built_in">print</span>('complexity')
    i/ = <span class="hljs-number">2</span>
</code></pre>
      </li>
      <li class="alphabeticList">
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,n):
    j = i
    <span class="hljs-keyword">while</span>(j&lt;n):
        j*=<span class="hljs-number">2</span>
</code></pre>
      </li>
      <li class="alphabeticList">
        <pre class="programlisting code"><code class="hljs-code">i=<span class="hljs-number">1</span>
<span class="hljs-keyword">while</span>(i&lt;n):
    <span class="hljs-built_in">print</span>('python')
        i = i**<span class="hljs-number">2</span>
</code></pre>
      </li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4"><span class="url">https://packt.link/MEvK4</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>