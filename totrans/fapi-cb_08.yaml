- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Advanced Features and Best Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级特性和最佳实践
- en: Welcome to [*Chapter 8*](B21025_08.xhtml#_idTextAnchor262), where we explore
    advanced techniques and best practices to optimize the functionality, performance,
    and scalability of FastAPI applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 [*第 8 章*](B21025_08.xhtml#_idTextAnchor262)，我们将探讨优化 FastAPI 应用程序功能、性能和可扩展性的高级技术和最佳实践。
- en: In this chapter, by building a trip agency platform, you’ll delve into essential
    topics such as dependency injection, custom middleware, internationalization,
    performance optimization, rate limiting, and background task execution. By mastering
    these advanced features, you’ll be equipped to build robust, efficient, and high-performing
    APIs with FastAPI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过构建一个旅行社平台，您将深入了解依赖注入、自定义中间件、国际化、性能优化、速率限制和后台任务执行等基本主题。通过掌握这些高级特性，您将能够使用
    FastAPI 构建强大、高效和高性能的 API。
- en: By the end of this chapter, you’ll have a comprehensive understanding of the
    advanced FastAPI features and best practices, empowering you to build efficient,
    scalable, and secure APIs that meet the demands of modern web applications. Let’s
    dive in and explore these advanced techniques to elevate your FastAPI development
    skills.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对高级 FastAPI 功能和最佳实践有一个全面的理解，这将使您能够构建高效、可扩展和安全的 API，以满足现代 Web 应用程序的需求。让我们深入探讨这些高级技术，以提升您的
    FastAPI 开发技能。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Implementing dependency injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现依赖注入
- en: Creating custom middleware
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义中间件
- en: Internationalization and localization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: Optimizing application performance
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化应用程序性能
- en: Implementing rate limiting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现速率限制
- en: Implementing background tasks
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现后台任务
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To be able to follow the recipes in this chapter, you must have a good grasp
    of the following essentials:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够跟随本章的配方，您必须对以下基本概念有很好的掌握：
- en: '**Python**: You should have a good understanding of Python version 3.7 or higher.
    You should know how annotation works and about basic class inheritance.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：您应该对 Python 3.7 或更高版本有很好的理解。您应该了解注解的工作原理以及基本类继承。'
- en: '`fastapi``asyncio``async`/`await` syntax.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fastapi`、`asyncio`、`async`/`await` 语法。'
- en: The code used in the chapter is hosted on GitHub at [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码托管在 GitHub 上，网址为 [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08)。
- en: 'To manage dependencies more efficiently and keep your project isolated, consider
    creating a virtual environment within the `project` root folder. You can easily
    install all the dependencies simultaneously by using the `requirements.txt` file
    provided on the GitHub repository in the `project` folder:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效地管理依赖项并保持项目隔离，考虑在 `project` 根目录下创建一个虚拟环境。您可以通过使用 GitHub 仓库中 `project` 文件夹提供的
    `requirements.txt` 文件，轻松地同时安装所有依赖项：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can then start with the first recipe and efficiently implement dependency
    injection in your FastAPI application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从第一个配方开始，高效地在您的 FastAPI 应用程序中实现依赖注入。
- en: Implementing dependency injection
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现依赖注入
- en: '**Dependency injection** is a powerful design pattern used in software development
    to manage dependencies between components. In the context of FastAPI, dependency
    injection allows you to efficiently manage and inject dependencies, such as database
    connections, authentication services, and configuration settings, into your application’s
    endpoints and middleware. Although we have already used dependency injection in
    previous recipes, such as *Setting up SQL databas**es* in [*Chapter 2*](B21025_02.xhtml#_idTextAnchor052),
    *Working with Data*, or *Setting up user registration* in [*Chapter 4*](B21025_04.xhtml#_idTextAnchor122),
    *Authentication and Authorization*, this recipe will show you how to implement
    dependency injections in FastAPI and how to tackle trickier use cases with nested
    dependency injections.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖注入**是一种在软件开发中用于管理组件之间依赖关系的强大设计模式。在 FastAPI 的上下文中，依赖注入允许您高效地管理和注入依赖项，例如数据库连接、认证服务和配置设置，到您的应用程序的端点和中间件中。尽管我们已经在之前的配方中使用了依赖注入，例如在
    [*第 2 章*](B21025_02.xhtml#_idTextAnchor052) *设置 SQL 数据库*、*处理数据* 或在 [*第 4 章*](B21025_04.xhtml#_idTextAnchor122)
    *设置用户注册*、*认证和授权* 中，这个配方将向您展示如何在 FastAPI 中实现依赖注入，以及如何处理具有嵌套依赖注入的更复杂的使用案例。'
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To follow along with the recipe, you only need to have Python installed with
    the `fastapi` and `uvicorn` packages installed in your environment, as well as
    `pytest`. If you haven’t installed the packages with the `requirements.txt` file
    provided in the GitHub repository, you can install them with `pip` from the command
    line:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个配方，你只需要在你的环境中安装了 Python，并且安装了 `fastapi` 和 `uvicorn` 包，以及 `pytest`。如果你还没有使用
    GitHub 仓库中提供的 `requirements.txt` 文件安装这些包，你可以从命令行使用 `pip` 安装它们：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also, it would be beneficial to know already how to create a simple server in
    FastAPI. You can refer to the *Creating a* *new* *FastAPI* *project* recipe in
    [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020), *First Steps with FastAPI*, for
    more details.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解如何在 FastAPI 中创建一个简单的服务器将很有帮助。你可以参考 [*第 1 章*](B21025_01.xhtml#_idTextAnchor020)
    中的 *Creating a* *new* *FastAPI* *project* 配方，了解更多详情。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: Let's start by creating the project root folder called `trip_platform` containing
    the `app` folder. Then let's continue the recipe through the following steps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个名为 `trip_platform` 的项目根文件夹开始，该文件夹包含 `app` 文件夹。然后按照以下步骤继续进行。
- en: 'In the `app` folder, create the `main.py` module that will contain the server
    as:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹中，创建一个包含服务器的 `main.py` 模块，如下所示：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will write the dependencies in a separate module called `dependencies.py`
    inside the `app` folder.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在 `app` 文件夹内创建一个名为 `dependencies.py` 的单独模块来编写依赖项。
- en: Let’s imagine we need to create an endpoint to retrieve all the trips between
    a start date and an end date. We need to handle two parameters, the start date
    and end date, and check that the start date is earlier than the end date. Both
    parameters can be optional; if the start date is not provided, it defaults to
    the current day.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们假设我们需要创建一个端点来检索从开始日期到结束日期之间的所有行程。我们需要处理两个参数，即开始日期和结束日期，并检查开始日期是否早于结束日期。这两个参数都可以是可选的；如果未提供开始日期，则默认为当前日期。
- en: 'In a dedicated module, `dependencies.py` in the `app` folder, let’s define
    the condition function, which checks that the start date is earlier than the end
    date:'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹的 `dependencies.py` 专用模块中，让我们定义一个条件函数，该函数检查开始日期是否早于结束日期：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We use the `check_start_end_condition` function to define the `dependable`
    function – namely, the function that will be used as a dependency – as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `check_start_end_condition` 函数来定义 `dependable` 函数——即用作依赖项的函数——如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Query` object is used to manage metadata of the query parameters, such
    as the default value, description, and example used when generating the documentation.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Query` 对象用于管理查询参数的元数据，例如在生成文档时使用的默认值、描述和示例。'
- en: 'We can use the dependable `time_range` function to create the endpoint in the
    `main.py` module. To specify that it is a dependency, we use the `Depends` object
    like this:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用可信赖的 `time_range` 函数在 `main.py` 模块中创建端点。为了指定它是一个依赖项，我们使用 `Depends` 对象，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can alternatively use the `Annotated` class from the `typing` package to
    define the dependency as follows:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还可以使用 `typing` 包中的 `Annotated` 类来如下定义依赖项：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The use of `Annotated` in FastAPI is currently evolving to avoid duplicates
    and improve readability; take a look at the dedicated documentation section: [https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 中 `Annotated` 的使用目前正在演变，以避免重复并提高可读性；请参阅专门的文档部分：[https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies)。
- en: For the rest of the chapter, we will use the latest `Annotated` convention.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的其余部分，我们将使用最新的 `Annotated` 习惯用法。
- en: Now, if you spin up the server by running `uvicorn app.main:app` on the terminal,
    you will find the endpoint in the interactive documentation at `http://localhost:8000/docs`.
    You will see that you just created the endpoint with the parameters correctly
    documented. The database logic is replaced by a string construction returning
    a significant message in the example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在终端中运行 `uvicorn app.main:app` 来启动服务器，你将在交互式文档的 `http://localhost:8000/docs`
    中找到端点。你会看到你刚刚创建的端点，参数得到了正确的文档说明。示例中用字符串构造替换了数据库逻辑，返回了一条重要信息。
- en: You have just implemented a dependency injection strategy to define query parameters
    for the endpoint. You can use the same strategy to write path or body parameters
    to write modular and readable code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚实现了一个依赖注入策略来定义端点的查询参数。你可以使用相同的策略来编写路径或体参数，以编写模块化和可读的代码。
- en: One of the advantages of using dependency injection is to logically separate
    pieces of code that can be replaced by something else, like in testing. Let’s
    have a look at how to do it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用依赖注入的一个优点是逻辑上分离可以替换为其他东西的代码片段，比如在测试中。让我们看看如何做到这一点。
- en: Overriding dependency injections in tests
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在测试中覆盖依赖注入
- en: 'Let’s create a test for the `GET /v1/trips` endpoint. If you don’t have `pytest`
    in the environment, install it with `pip install pytest`. Then, under the project
    root folder, create the `pytest.ini` file containing `pythonpath` for `pytest`,
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`GET /v1/trips`端点创建一个测试。如果你环境中没有`pytest`，请使用`pip install pytest`进行安装。然后，在项目根目录下创建`pytest.ini`文件，包含`pytest`的`pythonpath`，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The test will be in the test module, `test_main.py`, under the `tests` folder.
    Let’s write a unit test by overriding the client’s dependency:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试将在`tests`文件夹下的`test_main.py`测试模块中进行。让我们通过覆盖客户端的依赖来编写一个单元测试：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By overriding the `time_range` dependency, we won’t need to pass the parameters
    when calling the endpoint, and the response will depend on the lambda function
    defined.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过覆盖`time_range`依赖，我们不需要在调用端点时传递参数，响应将取决于定义的lambda函数。
- en: 'Then, you can run the test from the command line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以从命令行运行测试：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This technique is very useful when writing tests that should not interfere with
    a production database. Also, an eventual heavy computation logic can be mocked
    if it is not in the test’s interest.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写不应干扰生产数据库的测试时，这项技术非常有用。如果测试不关心，最终的重计算逻辑也可以被模拟。
- en: The use of dependency injection can significantly improve test quality by enabling
    modularity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的使用可以通过提高模块化程度显著提高测试质量。
- en: How it works…
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `Depends` object and dependency injection leverage Python’s powerful function
    annotations and type hinting features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Depends`对象和依赖注入利用Python强大的函数注解和类型提示功能。'
- en: When you define a dependency function and annotate it with `Depends`, FastAPI
    interprets it as a dependency that needs to be resolved before executing the endpoint
    function. When a request is made to an endpoint that depends on one or more dependencies,
    FastAPI introspects the endpoint function signature, identifies the dependencies,
    and resolves them by invoking the corresponding dependency functions in the correct
    order.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个依赖函数并用`Depends`进行注解时，FastAPI将其解释为在执行端点函数之前需要解决的依赖。当对依赖于一个或多个依赖项的端点发出请求时，FastAPI会检查端点函数的签名，识别依赖项，并通过调用正确的顺序中的相应依赖函数来解析它们。
- en: FastAPI uses Python’s type hinting mechanism to determine the type of each dependency
    parameter and automatically injects the resolved dependency into the endpoint
    function. This process ensures that the required data or services are available
    to the endpoint function at runtime, enabling seamless integration of external
    services, database connections, authentication mechanisms, and other dependencies
    into FastAPI applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI使用Python的类型提示机制来确定每个依赖参数的类型，并自动将解析后的依赖注入到端点函数中。这个过程确保了所需的数据或服务在运行时对端点函数可用，从而实现了外部服务、数据库连接、身份验证机制和其他依赖与FastAPI应用程序的无缝集成。
- en: Overall, the `Depends` class and dependency injection in FastAPI provide a clean
    and efficient way to manage dependencies and promote modular, maintainable code
    architecture. One of the advantages is that they can be overwritten in testing
    to be easily mocked or replaced.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，`Depends`类和FastAPI中的依赖注入提供了一种干净且高效的方式来管理依赖项，并促进模块化和可维护的代码架构。一个优点是它们可以在测试中重写，以便轻松模拟或替换。
- en: There’s more…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We can push things further by leveraging sub-dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用子依赖来进一步推进。
- en: Let’s create an endpoint that returns the trips for one of the three categories
    (cruises, city breaks, and resort stays) and, simultaneously, checks the coupon
    validity for the category.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个端点，该端点返回三个类别（巡游、城市之旅和度假住宿）之一的行程，并同时检查该类别的优惠券有效性。
- en: In the `dependencies.py` module, let’s create the `dependable` function for
    the category.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dependencies.py`模块中，让我们为该类别创建一个`dependable`函数。
- en: 'Imagine we can group our trips into three categories – cruises, city breaks,
    and resort stays. We need to add a parameter to retrieve trips only for a specific
    category. We will need a `dependable` function, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们可以将我们的旅行分为三类——邮轮之旅、城市短途游和度假村住宿。我们需要添加一个参数来检索特定类别的旅行。我们需要一个`dependable`函数，如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, let’s imagine we need to validate a coupon for a discount.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象我们需要验证一个优惠券以获取折扣。
- en: 'The `dependable` function will be used as a dependency for another `dependable`
    function that will check the coupon. Let’s define it, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependable`函数将作为另一个用于检查优惠券的`dependable`函数的依赖项。让我们定义它，如下所示：'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `main.py` module, let’s define a new endpoint, `GET /v2/trips/{category}`,
    that returns the trips for the specified category:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.py`模块中，让我们定义一个新的端点，`GET /v2/trips/{category}`，它返回指定类别的旅行：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you run the server with the `uvicorn app.main:app` command and open the interactive
    documentation at `http://localhost:8000/docs`, you will see the new endpoint.
    The accepted parameters, `category` and `code`, both come from the dependencies,
    and the `category` parameter is not repeated within the code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`uvicorn app.main:app`命令运行服务器，并在`http://localhost:8000/docs`打开交互式文档，你会看到新的端点。接受的参数`category`和`code`都来自依赖项，并且`category`参数在代码中不会重复。
- en: Important note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use both `def` and `async def` keywords to declare dependencies, whether
    they are synchronous or asynchronous functions respectively. FastAPI will handle
    them automatically.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`def`和`async def`关键字来声明依赖项，无论是同步函数还是异步函数。FastAPI将自动处理它们。
- en: You have just created an endpoint that uses nested dependencies. By using nested
    dependencies and sub-dependencies, you will be able to write clear and modular
    code that is easier to read and maintain.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚创建了一个使用嵌套依赖项的端点。通过使用嵌套依赖项和子依赖项，你将能够编写清晰且模块化的代码，这使得代码更容易阅读和维护。
- en: Exercise
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: In FastAPI, dependencies can be also created as a class. Check out the documentation
    at [https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies),
    and create a new endpoint that uses all the parameters we defined in the recipe
    (`time_range`, `category`, and `code`).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在FastAPI中，依赖项也可以作为一个类来创建。查看[https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies)的文档，并创建一个新的端点，该端点使用我们在配方中定义的所有参数（`time_range`、`category`和`code`）。
- en: Group all the parameters into a class, and define and use it as a dependency
    for the endpoint.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有参数组合到一个类中，并定义和使用它作为端点的依赖项。
- en: See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'We have used `Query` and `Path` descriptor objects to set metadata and documentation-related
    data for `query` and `path` parameters, respectively. You can discover more about
    their potential at these documentation links:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`Query`和`Path`描述符对象来设置`query`和`path`参数的元数据和文档相关数据。你可以在这些文档链接中了解更多关于它们潜力的信息：
- en: '*Query Parameters and String* *Validations*: [https://fastapi.tiangolo.com/tutorial/query-params-str-validations/](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/)'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查询参数和字符串* *验证*：[https://fastapi.tiangolo.com/tutorial/query-params-str-validations/](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/)'
- en: '*Path Parameters and Numeric* *Validations*: [https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/)'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*路径参数和数字* *验证*：[https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/)'
- en: 'For dependency injections in FastAPI, you can find extensive documentation
    covering all the possible usages, explaining the potential of this powerful feature:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FastAPI中的依赖注入，你可以找到广泛的文档，涵盖了所有可能的用法，解释了这一强大功能的潜力：
- en: '*Dependencies*: [https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖项*：[https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)'
- en: '*Advanced* *Dependencies*: [https://fastapi.tiangolo.com/advanced/advanced-dependencies/](https://fastapi.tiangolo.com/advanced/advanced-dependencies/)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高级* *依赖项*：[https://fastapi.tiangolo.com/advanced/advanced-dependencies/](https://fastapi.tiangolo.com/advanced/advanced-dependencies/)'
- en: '*Testing Dependencies with* *Overrides*: [https://fastapi.tiangolo.com/advanced/testing-dependencies/](https://fastapi.tiangolo.com/advanced/testing-dependencies/)'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用* *覆盖* *测试依赖项*：[https://fastapi.tiangolo.com/advanced/testing-dependencies/](https://fastapi.tiangolo.com/advanced/testing-dependencies/)'
- en: Creating custom middleware
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Middleware** is an API component that allows you to intercept and modify
    incoming requests and outgoing responses, making it a powerful tool for implementing
    cross-cutting concerns such as authentication, logging, and error handling.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore how to develop custom middleware to process requests
    and responses in FastAPI applications and retrieve information on the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need is to have a running FastAPI application. The recipe will use our
    trip platform defined in the previous recipe, *Implementing dependency injection*.
    However, middleware works for a generic running application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will show you how to create a custom middleware object class that we will
    use in our application through the following steps.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a dedicated module in the app folder called `middleware.py`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the middleware to intercept the request and print the host client and
    the method on the output terminal. In a real application scenario, this information
    can be stored in a database for analytics or used for security inspection purposes.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s use the same `uvicorn` logger used by FastAPI by default:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, let’s create our `ClientInfoMiddleware` class, as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we need to add our middleware to the FastAPI server in `main.py`. After
    defining the app server, we can add the middleware with the `add_middleware` method:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, spin up the server with the `uvicorn app.main:app` command, and try to
    connect to a subpath of `http://localhost:8000/v1/trips`. You don’t even need
    to call an existing endpoint. You will see the log messages in the application
    output terminal:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You have just implemented a basic custom middleware to retrieve information
    about the client. You can increase the complexity by adding more operations, such
    as redirecting requests based on the IP and integrating IP blocking or filtering.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI uses the `BasicHTTPMiddleware` class from the `Starlette` library. The
    strategy shown in the recipe creates a class derived from `BasicHTTPMiddleware`,
    with a specific `dispatch` method that implements the interception operation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: To create a middleware in FastAPI, you can add a decorator from the FastAPI
    class methods to a simple function. However, it is recommended to create a class,
    as it allows for better modularity and organization of the code. By creating a
    class, you can eventually create your collection module of middleware.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can have a look at how to create a custom middleware on the official documentation
    page at the following link:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '*FastAPI Middleware* *documentation*: [https://fastapi.tiangolo.com/tutorial/middleware/](https://fastapi.tiangolo.com/tutorial/middleware/)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interesting discussion on how to create middleware classes in FastAPI can
    be found on the **Stack** **Overflow** website:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '*Create FastAPI Custom Middleware Class* *Discussion*: [https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class](https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建FastAPI自定义中间件类* *讨论*：[https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class](https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class)'
- en: Internationalization and localization
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化和本地化
- en: '**Internationalization** (**i18n**) and **localization** (**l10n**) are fundamental
    concepts in software development that enable applications to be adapted for different
    languages, regions, and cultures.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**国际化**（**i18n**）和**本地化**（**l10n**）是软件开发中的基本概念，它使得应用程序能够适应不同的语言、地区和文化。'
- en: '**i18n** refers to the process of designing and developing software or products
    that can be adapted to different languages and cultures. This process mainly involves
    providing content in a specific language. Conversely, **l10n** involves adapting
    a product or content for a specific locale or market, such as currency or a unit
    of measure.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**i18n**指的是设计和开发能够适应不同语言和文化的软件或产品的过程。这个过程主要涉及提供特定语言的内容。相反，**l10n**涉及将产品或内容适应特定地区或市场，例如货币或度量单位。'
- en: The `Accept-Language` header to implement i18n and l10n in our trip platform.
    This will enable our platform to provide targeted content to the client.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅行平台中实现i18n和l10n的`Accept-Language`头。这将使我们的平台能够向客户端提供有针对性的内容。
- en: Getting ready
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'It would be beneficial to have some knowledge of the `Accept-Language` header;
    take a look at this interesting article from Mozilla’s documentation: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`Accept-Language`头信息会有所帮助；请查看Mozilla文档中的这篇有趣文章：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).
- en: You need to have a running FastAPI application to follow the recipe. You can
    follow along with the trip platform application used throughout the chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要有一个正在运行的FastAPI应用程序来遵循这个配方。你可以跟随本章中使用的旅行平台应用程序。
- en: We will make use of dependency injection, so it will be beneficial to complete
    the *Implementing dependency injection* recipe from this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用依赖注入，因此完成本章的*实现依赖注入*配方会有所帮助。
- en: 'Also, we will use the `babel` package to resolve language code references,
    so if haven’t installed the packages with the `requirements.txt` file, make sure
    to have `babel` in your environment by running the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用`babel`包来解析语言代码引用，所以如果你还没有通过`requirements.txt`文件安装这些包，请确保通过运行以下命令在你的环境中安装`babel`：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the installation is completed, you have all you need to start the recipe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你将拥有启动所需的一切。
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现它...
- en: To begin with, we must determine which regions and languages we wish to cater
    to. For this example, we will focus on two – **American English** (**en_US**)
    and **French from France** (**fr_FR**). All content pertaining to language will
    be in one of these two languages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确定我们希望服务哪些地区和语言。在这个例子中，我们将关注两个——**美国英语**（**en_US**）和**来自法国的法语**（**fr_FR**）。所有与语言相关的内
    容都将使用这两种语言之一。
- en: It is necessary to manage the `Accept-Language` header on the host client side,
    which is a list of languages with a preference weight parameter.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机客户端侧管理`Accept-Language`头是必要的，它是一个带有偏好权重参数的语言列表。
- en: 'Examples of the header are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该头的示例如下：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We need a function that takes as an argument the header and the list of available
    languages in our app, returning the most appropriate one Let's implement it by
    applying the following steps.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个函数，它接受头信息和我们的应用程序中可用的语言列表作为参数，并返回最合适的一个。让我们通过以下步骤来实现它。
- en: Create a dedicated module, `internationalization.py`, under the `app` folder.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹下创建一个专门的模块，`internationalization.py`。
- en: 'First, we store the supported languages in a variable, as follows:'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们将支持的语言存储在一个变量中，如下所示：
- en: '[PRE19]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we start defining the `resolve_accept_lanugage` function, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们开始定义`resolve_accept_language`函数，如下所示：
- en: '[PRE20]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Within the function, we parse the string into a list:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内部，我们将字符串解析成一个列表：
- en: '[PRE21]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We then sort the string according to the preference `q` parameter:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们根据偏好`q`参数对字符串进行排序：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we use `negotiate_locale` from the `babel` package to get the most suited
    language:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`babel`包中的`negotiate_locale`来获取最合适的语言：
- en: '[PRE23]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If there is no match, we return `en_US` as default:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `resolve_accept_language` function will be used as a dependency for the
    endpoints that return content based on the language.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same `internationalization.py` module, let’s create a `GET /homepage`
    endpoint that returns a welcome string, depending on the language. We will do
    it in a separate `APIRouter`, so the router will be as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `tags` parameter specifies that the router’s endpoint will be grouped separately
    in the interactive documentation under a specified tag name.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `GET /home` endpoint will be as follows:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the example, the content has been hardcoded as a `dict` object with language
    code as a dictionary key.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In a real-world scenario, the content should be stored in a database for each
    language.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, you define a localization strategy to retrieve the currency.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a `GET /show/currency` endpoint as an example that uses a dependency
    to retrieve the currency from the `Accept-Language` header. The `dependency` function
    can be defined as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The endpoint will then be as follows:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To use both endpoints, we will need to add the router to the FastAPI object
    in `main.py`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is all you need to implement internationalization and localization. To
    test it, spin up the server from the command line by running:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: $ pip install pyinstrument
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: from pyinstrument import Profiler
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler = Profiler(
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: interval=0.001, async_mode="enabled"
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: from starlette.middleware.base import (
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BaseHTTPMiddleware
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: class ProfileEndpointsMiddleWare(
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BaseHTTPMiddleware
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def dispatch(
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'self, request: Request, call_next'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not profiler.is_running:'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.start()
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response = await call_next(request)
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if profiler.is_running:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.stop()
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.write_html(
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: os.getcwd() + "/profiler.xhtml"
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.start()
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return response
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: app.add_middleware(ProfileEndpointsMiddleWare)
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: $ pip install slowapi
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: from slowapi import Limiter
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from slowapi.util import get_remote_address
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: limiter = Limiter(
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: key_func=get_remote_address,
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: from slowapi import _rate_limit_exceeded_handler
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from slowapi.errors import RateLimitExceeded
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rest of the code
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: app.state.limiter = limiter
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.add_exception_handler(
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RateLimitExceeded, _rate_limit_exceeded_handler
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rest of the code
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: from fastapi import Request
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from app.rate_limiter import limiter
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@router.get("/homepage")'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@limiter.limit("2/minute")'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def home(
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'request: Request,'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'language: Annotated['
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: resolve_accept_language, Depends()
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '],'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return {"message": home_page_content[language]}'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'http://localhost:8000/homepage; you will get the home page content, and by
    the third call, you will get a 429 response with the following content:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You’ve just added a limit rate to the `GET /homepage` endpoint. With the same
    strategy, you can add a specific rate limiter to each endpoint.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: You can do more by adding a global rate limit to the entire application, as
    follows.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.py`, you need to add a dedicated middleware, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, you simply need to specify the default limit in the `Limiter` object
    instantiation in the `rate_limiter.py` module:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你只需在 `rate_limiter.py` 模块的 `Limiter` 对象实例化中指定默认限制即可：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And that’s it. Now, if you rerun the server and call any of the endpoints more
    than five times consecutively, you will get a `429` response.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，如果你重新启动服务器并连续调用任何端点超过五次，你将收到 `429` 响应。
- en: You have successfully set up a global rate limiter for your FastAPI application.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功为你的 FastAPI 应用程序设置了一个全局速率限制器。
- en: See also
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'You can find more on **Slowapi** features such as shared limits, limiting policies,
    and more in the official documentation at this link:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中找到更多关于 **Slowapi** 功能的信息，例如共享限制、限制策略等，链接如下：
- en: '*SlowApi* *documentation*: [https://slowapi.readthedocs.io/en/latest/](https://slowapi.readthedocs.io/en/latest/)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SlowApi* *文档*：[https://slowapi.readthedocs.io/en/latest/](https://slowapi.readthedocs.io/en/latest/)'
- en: 'You can check out more on the syntax of rate limit notation in the **Limits**
    project documentation at this link:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 **Limits** 项目文档中找到更多关于速率限制表示法语法的详细信息，链接如下：
- en: '*Rate limit string* *notation*: [https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation](https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*速率限制字符串* *表示法*：[https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation](https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation)'
- en: Implementing background tasks
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 实现背景任务
- en: Background tasks are a useful feature that enables you to delegate resource-intensive
    operations to separate processes. With background tasks, your application can
    remain responsive and handle multiple requests simultaneously. They are particularly
    important for handling long-running processes without blocking the main request-response
    cycle. This improves the overall efficiency and scalability of your application.
    In this recipe, we will explore how you can execute background tasks in FastAPI
    applications.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 背景任务是一个有用的功能，它允许你将资源密集型操作委托给单独的进程。使用背景任务，你的应用程序可以保持响应性并同时处理多个请求。这对于处理长时间运行的过程而不阻塞主请求-响应周期尤为重要。这提高了应用程序的整体效率和可扩展性。在本教程中，我们将探讨如何在
    FastAPI 应用程序中执行背景任务。
- en: Getting ready
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow this recipe, all you need is a FastAPI application running with at
    least one endpoint to apply the background task. However, we will implement the
    background task into our trip platform into the `GET /v2/trips/{category}` endpoint,
    defined in the *Implementing dependency* *injection* recipe.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循这个教程，你只需要一个运行着至少一个端点以应用背景任务 FastAPI 应用程序。然而，我们将把背景任务实现到我们的行程平台中的 `GET /v2/trips/{category}`
    端点，该端点在 *实现依赖注入* 教程中定义。
- en: How to do it…
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let’s imagine we want to store the message of the `GET /v2/trips/{category}`
    endpoint in an external database for analytics purposes. Let's do it in two simple
    steps.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们想要将 `GET /v2/trips/{category}` 端点的消息存储在外部数据库中，用于分析目的。让我们分两步简单完成。
- en: 'First, we define a function that mocks the storing operation in a dedicated
    module, `background_tasks.py`, in the `app` folder. The function will look like
    the following:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数，在 `app` 文件夹中的专用模块 `background_tasks.py` 中模拟存储操作。该函数看起来如下：
- en: '[PRE42]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The storing operation is mocked by an `asyncio.sleep` non-blocking operation.
    We have also added some log messages to keep track of the execution.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存储操作通过 `asyncio.sleep` 非阻塞操作进行模拟。我们还添加了一些日志消息以跟踪执行情况。
- en: '2.  Now, we need to execute the `store_query_to_external_db` function as a
    background task of our endpoint. In `main.py`, let’s modify the `GET /v2/trips/cruises`,
    as follows:'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 2.  现在，我们需要将 `store_query_to_external_db` 函数作为我们端点的背景任务执行。在 `main.py` 中，让我们修改
    `GET /v2/trips/cruises`，如下所示：
- en: '[PRE43]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, if you spin up the server with `uvicorn app.main:app` and try to call
    the `GET /v2/trips/cruises` endpoint, you will see the logs from the `store_query_to_external_db`
    function on the terminal output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用 `uvicorn app.main:app` 启动服务器并尝试调用 `GET /v2/trips/cruises` 端点，你将在终端输出中看到
    `store_query_to_external_db` 函数的日志。
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That is all you need to implement background tasks in FastAPI! However, if you
    have to perform extensive background computations, you might want to use dedicated
    tools to handle queued task execution. This would allow you to run the tasks in
    a separate process and avoid any performance issues that may arise from running
    them in the same process.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在FastAPI中实现后台任务所需的所有内容！然而，如果你必须执行大量的后台计算，你可能想要使用专门的工具来处理队列任务执行。这将允许你在单独的进程中运行任务，避免在相同进程中运行时可能出现的任何性能问题。
- en: How it works…
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When a request is made to the endpoint, the background task is enqueued to the
    `BackgroundTasks` object. All the tasks are passed to the event loop so that they
    can be executed concurrently, allowing for non-blocking I/O operations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当对端点发起请求时，后台任务会被排队到`BackgroundTasks`对象。所有任务都会传递给事件循环，以便它们可以并发执行，从而允许非阻塞I/O操作。
- en: If you have a task that requires a lot of processing power and doesn’t necessarily
    need to be completed by the same process, you might want to consider using larger
    tools such as Celery.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个需要大量处理能力且不一定需要由相同过程完成的任务，你可能想要考虑使用像Celery这样的大型工具。
- en: See also
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can find more on creating background tasks in FastAPI on the official documentation
    page at this link:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档页面上的此链接找到更多关于在FastAPI中创建后台任务的信息：
- en: '*Background* *Tasks*: [https://fastapi.tiangolo.com/tutorial/background-tasks/](https://fastapi.tiangolo.com/tutorial/background-tasks/)'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*后台* *任务*：[https://fastapi.tiangolo.com/tutorial/background-tasks/](https://fastapi.tiangolo.com/tutorial/background-tasks/)'
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
