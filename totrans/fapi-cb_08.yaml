- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Features and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 8*](B21025_08.xhtml#_idTextAnchor262), where we explore
    advanced techniques and best practices to optimize the functionality, performance,
    and scalability of FastAPI applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, by building a trip agency platform, you’ll delve into essential
    topics such as dependency injection, custom middleware, internationalization,
    performance optimization, rate limiting, and background task execution. By mastering
    these advanced features, you’ll be equipped to build robust, efficient, and high-performing
    APIs with FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have a comprehensive understanding of the
    advanced FastAPI features and best practices, empowering you to build efficient,
    scalable, and secure APIs that meet the demands of modern web applications. Let’s
    dive in and explore these advanced techniques to elevate your FastAPI development
    skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing application performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing background tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to follow the recipes in this chapter, you must have a good grasp
    of the following essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Python**: You should have a good understanding of Python version 3.7 or higher.
    You should know how annotation works and about basic class inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fastapi``asyncio``async`/`await` syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code used in the chapter is hosted on GitHub at [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage dependencies more efficiently and keep your project isolated, consider
    creating a virtual environment within the `project` root folder. You can easily
    install all the dependencies simultaneously by using the `requirements.txt` file
    provided on the GitHub repository in the `project` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can then start with the first recipe and efficiently implement dependency
    injection in your FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dependency injection** is a powerful design pattern used in software development
    to manage dependencies between components. In the context of FastAPI, dependency
    injection allows you to efficiently manage and inject dependencies, such as database
    connections, authentication services, and configuration settings, into your application’s
    endpoints and middleware. Although we have already used dependency injection in
    previous recipes, such as *Setting up SQL databas**es* in [*Chapter 2*](B21025_02.xhtml#_idTextAnchor052),
    *Working with Data*, or *Setting up user registration* in [*Chapter 4*](B21025_04.xhtml#_idTextAnchor122),
    *Authentication and Authorization*, this recipe will show you how to implement
    dependency injections in FastAPI and how to tackle trickier use cases with nested
    dependency injections.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To follow along with the recipe, you only need to have Python installed with
    the `fastapi` and `uvicorn` packages installed in your environment, as well as
    `pytest`. If you haven’t installed the packages with the `requirements.txt` file
    provided in the GitHub repository, you can install them with `pip` from the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Also, it would be beneficial to know already how to create a simple server in
    FastAPI. You can refer to the *Creating a* *new* *FastAPI* *project* recipe in
    [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020), *First Steps with FastAPI*, for
    more details.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by creating the project root folder called `trip_platform` containing
    the `app` folder. Then let's continue the recipe through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `app` folder, create the `main.py` module that will contain the server
    as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will write the dependencies in a separate module called `dependencies.py`
    inside the `app` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s imagine we need to create an endpoint to retrieve all the trips between
    a start date and an end date. We need to handle two parameters, the start date
    and end date, and check that the start date is earlier than the end date. Both
    parameters can be optional; if the start date is not provided, it defaults to
    the current day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a dedicated module, `dependencies.py` in the `app` folder, let’s define
    the condition function, which checks that the start date is earlier than the end
    date:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `check_start_end_condition` function to define the `dependable`
    function – namely, the function that will be used as a dependency – as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Query` object is used to manage metadata of the query parameters, such
    as the default value, description, and example used when generating the documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can use the dependable `time_range` function to create the endpoint in the
    `main.py` module. To specify that it is a dependency, we use the `Depends` object
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can alternatively use the `Annotated` class from the `typing` package to
    define the dependency as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of `Annotated` in FastAPI is currently evolving to avoid duplicates
    and improve readability; take a look at the dedicated documentation section: [https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/#share-annotated-dependencies).'
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of the chapter, we will use the latest `Annotated` convention.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you spin up the server by running `uvicorn app.main:app` on the terminal,
    you will find the endpoint in the interactive documentation at `http://localhost:8000/docs`.
    You will see that you just created the endpoint with the parameters correctly
    documented. The database logic is replaced by a string construction returning
    a significant message in the example.
  prefs: []
  type: TYPE_NORMAL
- en: You have just implemented a dependency injection strategy to define query parameters
    for the endpoint. You can use the same strategy to write path or body parameters
    to write modular and readable code.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using dependency injection is to logically separate
    pieces of code that can be replaced by something else, like in testing. Let’s
    have a look at how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding dependency injections in tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a test for the `GET /v1/trips` endpoint. If you don’t have `pytest`
    in the environment, install it with `pip install pytest`. Then, under the project
    root folder, create the `pytest.ini` file containing `pythonpath` for `pytest`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The test will be in the test module, `test_main.py`, under the `tests` folder.
    Let’s write a unit test by overriding the client’s dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By overriding the `time_range` dependency, we won’t need to pass the parameters
    when calling the endpoint, and the response will depend on the lambda function
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can run the test from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This technique is very useful when writing tests that should not interfere with
    a production database. Also, an eventual heavy computation logic can be mocked
    if it is not in the test’s interest.
  prefs: []
  type: TYPE_NORMAL
- en: The use of dependency injection can significantly improve test quality by enabling
    modularity.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Depends` object and dependency injection leverage Python’s powerful function
    annotations and type hinting features.
  prefs: []
  type: TYPE_NORMAL
- en: When you define a dependency function and annotate it with `Depends`, FastAPI
    interprets it as a dependency that needs to be resolved before executing the endpoint
    function. When a request is made to an endpoint that depends on one or more dependencies,
    FastAPI introspects the endpoint function signature, identifies the dependencies,
    and resolves them by invoking the corresponding dependency functions in the correct
    order.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI uses Python’s type hinting mechanism to determine the type of each dependency
    parameter and automatically injects the resolved dependency into the endpoint
    function. This process ensures that the required data or services are available
    to the endpoint function at runtime, enabling seamless integration of external
    services, database connections, authentication mechanisms, and other dependencies
    into FastAPI applications.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the `Depends` class and dependency injection in FastAPI provide a clean
    and efficient way to manage dependencies and promote modular, maintainable code
    architecture. One of the advantages is that they can be overwritten in testing
    to be easily mocked or replaced.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can push things further by leveraging sub-dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create an endpoint that returns the trips for one of the three categories
    (cruises, city breaks, and resort stays) and, simultaneously, checks the coupon
    validity for the category.
  prefs: []
  type: TYPE_NORMAL
- en: In the `dependencies.py` module, let’s create the `dependable` function for
    the category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we can group our trips into three categories – cruises, city breaks,
    and resort stays. We need to add a parameter to retrieve trips only for a specific
    category. We will need a `dependable` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s imagine we need to validate a coupon for a discount.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dependable` function will be used as a dependency for another `dependable`
    function that will check the coupon. Let’s define it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main.py` module, let’s define a new endpoint, `GET /v2/trips/{category}`,
    that returns the trips for the specified category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you run the server with the `uvicorn app.main:app` command and open the interactive
    documentation at `http://localhost:8000/docs`, you will see the new endpoint.
    The accepted parameters, `category` and `code`, both come from the dependencies,
    and the `category` parameter is not repeated within the code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You can use both `def` and `async def` keywords to declare dependencies, whether
    they are synchronous or asynchronous functions respectively. FastAPI will handle
    them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: You have just created an endpoint that uses nested dependencies. By using nested
    dependencies and sub-dependencies, you will be able to write clear and modular
    code that is easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs: []
  type: TYPE_NORMAL
- en: In FastAPI, dependencies can be also created as a class. Check out the documentation
    at [https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies](https://fastapi.tiangolo.com/tutorial/dependencies/classes-as-dependencies/#classes-as-dependencies),
    and create a new endpoint that uses all the parameters we defined in the recipe
    (`time_range`, `category`, and `code`).
  prefs: []
  type: TYPE_NORMAL
- en: Group all the parameters into a class, and define and use it as a dependency
    for the endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used `Query` and `Path` descriptor objects to set metadata and documentation-related
    data for `query` and `path` parameters, respectively. You can discover more about
    their potential at these documentation links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Query Parameters and String* *Validations*: [https://fastapi.tiangolo.com/tutorial/query-params-str-validations/](https://fastapi.tiangolo.com/tutorial/query-params-str-validations/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Path Parameters and Numeric* *Validations*: [https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/](https://fastapi.tiangolo.com/tutorial/path-params-numeric-validations/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For dependency injections in FastAPI, you can find extensive documentation
    covering all the possible usages, explaining the potential of this powerful feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dependencies*: [https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Advanced* *Dependencies*: [https://fastapi.tiangolo.com/advanced/advanced-dependencies/](https://fastapi.tiangolo.com/advanced/advanced-dependencies/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Testing Dependencies with* *Overrides*: [https://fastapi.tiangolo.com/advanced/testing-dependencies/](https://fastapi.tiangolo.com/advanced/testing-dependencies/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Middleware** is an API component that allows you to intercept and modify
    incoming requests and outgoing responses, making it a powerful tool for implementing
    cross-cutting concerns such as authentication, logging, and error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore how to develop custom middleware to process requests
    and responses in FastAPI applications and retrieve information on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All you need is to have a running FastAPI application. The recipe will use our
    trip platform defined in the previous recipe, *Implementing dependency injection*.
    However, middleware works for a generic running application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will show you how to create a custom middleware object class that we will
    use in our application through the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a dedicated module in the app folder called `middleware.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want the middleware to intercept the request and print the host client and
    the method on the output terminal. In a real application scenario, this information
    can be stored in a database for analytics or used for security inspection purposes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s use the same `uvicorn` logger used by FastAPI by default:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let’s create our `ClientInfoMiddleware` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to add our middleware to the FastAPI server in `main.py`. After
    defining the app server, we can add the middleware with the `add_middleware` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, spin up the server with the `uvicorn app.main:app` command, and try to
    connect to a subpath of `http://localhost:8000/v1/trips`. You don’t even need
    to call an existing endpoint. You will see the log messages in the application
    output terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You have just implemented a basic custom middleware to retrieve information
    about the client. You can increase the complexity by adding more operations, such
    as redirecting requests based on the IP and integrating IP blocking or filtering.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FastAPI uses the `BasicHTTPMiddleware` class from the `Starlette` library. The
    strategy shown in the recipe creates a class derived from `BasicHTTPMiddleware`,
    with a specific `dispatch` method that implements the interception operation.
  prefs: []
  type: TYPE_NORMAL
- en: To create a middleware in FastAPI, you can add a decorator from the FastAPI
    class methods to a simple function. However, it is recommended to create a class,
    as it allows for better modularity and organization of the code. By creating a
    class, you can eventually create your collection module of middleware.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can have a look at how to create a custom middleware on the official documentation
    page at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*FastAPI Middleware* *documentation*: [https://fastapi.tiangolo.com/tutorial/middleware/](https://fastapi.tiangolo.com/tutorial/middleware/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An interesting discussion on how to create middleware classes in FastAPI can
    be found on the **Stack** **Overflow** website:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Create FastAPI Custom Middleware Class* *Discussion*: [https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class](https://stackoverflow.com/questions/71525132/how-to-write-a-custom-fastapi-middleware-class)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization and localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Internationalization** (**i18n**) and **localization** (**l10n**) are fundamental
    concepts in software development that enable applications to be adapted for different
    languages, regions, and cultures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**i18n** refers to the process of designing and developing software or products
    that can be adapted to different languages and cultures. This process mainly involves
    providing content in a specific language. Conversely, **l10n** involves adapting
    a product or content for a specific locale or market, such as currency or a unit
    of measure.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Accept-Language` header to implement i18n and l10n in our trip platform.
    This will enable our platform to provide targeted content to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It would be beneficial to have some knowledge of the `Accept-Language` header;
    take a look at this interesting article from Mozilla’s documentation: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language).'
  prefs: []
  type: TYPE_NORMAL
- en: You need to have a running FastAPI application to follow the recipe. You can
    follow along with the trip platform application used throughout the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will make use of dependency injection, so it will be beneficial to complete
    the *Implementing dependency injection* recipe from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we will use the `babel` package to resolve language code references,
    so if haven’t installed the packages with the `requirements.txt` file, make sure
    to have `babel` in your environment by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation is completed, you have all you need to start the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To begin with, we must determine which regions and languages we wish to cater
    to. For this example, we will focus on two – **American English** (**en_US**)
    and **French from France** (**fr_FR**). All content pertaining to language will
    be in one of these two languages.
  prefs: []
  type: TYPE_NORMAL
- en: It is necessary to manage the `Accept-Language` header on the host client side,
    which is a list of languages with a preference weight parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of the header are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We need a function that takes as an argument the header and the list of available
    languages in our app, returning the most appropriate one Let's implement it by
    applying the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: Create a dedicated module, `internationalization.py`, under the `app` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we store the supported languages in a variable, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we start defining the `resolve_accept_lanugage` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the function, we parse the string into a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then sort the string according to the preference `q` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use `negotiate_locale` from the `babel` package to get the most suited
    language:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there is no match, we return `en_US` as default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `resolve_accept_language` function will be used as a dependency for the
    endpoints that return content based on the language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the same `internationalization.py` module, let’s create a `GET /homepage`
    endpoint that returns a welcome string, depending on the language. We will do
    it in a separate `APIRouter`, so the router will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `tags` parameter specifies that the router’s endpoint will be grouped separately
    in the interactive documentation under a specified tag name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `GET /home` endpoint will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the example, the content has been hardcoded as a `dict` object with language
    code as a dictionary key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In a real-world scenario, the content should be stored in a database for each
    language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similarly, you define a localization strategy to retrieve the currency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a `GET /show/currency` endpoint as an example that uses a dependency
    to retrieve the currency from the `Accept-Language` header. The `dependency` function
    can be defined as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The endpoint will then be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use both endpoints, we will need to add the router to the FastAPI object
    in `main.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is all you need to implement internationalization and localization. To
    test it, spin up the server from the command line by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: $ pip install pyinstrument
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: from pyinstrument import Profiler
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler = Profiler(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: interval=0.001, async_mode="enabled"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from starlette.middleware.base import (
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BaseHTTPMiddleware
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: class ProfileEndpointsMiddleWare(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: BaseHTTPMiddleware
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def dispatch(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'self, request: Request, call_next'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if not profiler.is_running:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.start()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: response = await call_next(request)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'if profiler.is_running:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.stop()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.write_html(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: os.getcwd() + "/profiler.xhtml"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: profiler.start()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: app.add_middleware(ProfileEndpointsMiddleWare)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ pip install slowapi
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: from slowapi import Limiter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from slowapi.util import get_remote_address
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: limiter = Limiter(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: key_func=get_remote_address,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from slowapi import _rate_limit_exceeded_handler
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from slowapi.errors import RateLimitExceeded
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rest of the code
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: app.state.limiter = limiter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app.add_exception_handler(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RateLimitExceeded, _rate_limit_exceeded_handler
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: rest of the code
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: from fastapi import Request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: from app.rate_limiter import limiter
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@router.get("/homepage")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '@limiter.limit("2/minute")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: async def home(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'request: Request,'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'language: Annotated['
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: resolve_accept_language, Depends()
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '],'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'return {"message": home_page_content[language]}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'http://localhost:8000/homepage; you will get the home page content, and by
    the third call, you will get a 429 response with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You’ve just added a limit rate to the `GET /homepage` endpoint. With the same
    strategy, you can add a specific rate limiter to each endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs: []
  type: TYPE_NORMAL
- en: You can do more by adding a global rate limit to the entire application, as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.py`, you need to add a dedicated middleware, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you simply need to specify the default limit in the `Limiter` object
    instantiation in the `rate_limiter.py` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it. Now, if you rerun the server and call any of the endpoints more
    than five times consecutively, you will get a `429` response.
  prefs: []
  type: TYPE_NORMAL
- en: You have successfully set up a global rate limiter for your FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more on **Slowapi** features such as shared limits, limiting policies,
    and more in the official documentation at this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*SlowApi* *documentation*: [https://slowapi.readthedocs.io/en/latest/](https://slowapi.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can check out more on the syntax of rate limit notation in the **Limits**
    project documentation at this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Rate limit string* *notation*: [https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation](https://limits.readthedocs.io/en/stable/quickstart.xhtml#rate-limit-string-notation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing background tasks
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks are a useful feature that enables you to delegate resource-intensive
    operations to separate processes. With background tasks, your application can
    remain responsive and handle multiple requests simultaneously. They are particularly
    important for handling long-running processes without blocking the main request-response
    cycle. This improves the overall efficiency and scalability of your application.
    In this recipe, we will explore how you can execute background tasks in FastAPI
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs: []
  type: TYPE_NORMAL
- en: To follow this recipe, all you need is a FastAPI application running with at
    least one endpoint to apply the background task. However, we will implement the
    background task into our trip platform into the `GET /v2/trips/{category}` endpoint,
    defined in the *Implementing dependency* *injection* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine we want to store the message of the `GET /v2/trips/{category}`
    endpoint in an external database for analytics purposes. Let's do it in two simple
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a function that mocks the storing operation in a dedicated
    module, `background_tasks.py`, in the `app` folder. The function will look like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The storing operation is mocked by an `asyncio.sleep` non-blocking operation.
    We have also added some log messages to keep track of the execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '2.  Now, we need to execute the `store_query_to_external_db` function as a
    background task of our endpoint. In `main.py`, let’s modify the `GET /v2/trips/cruises`,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you spin up the server with `uvicorn app.main:app` and try to call
    the `GET /v2/trips/cruises` endpoint, you will see the logs from the `store_query_to_external_db`
    function on the terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That is all you need to implement background tasks in FastAPI! However, if you
    have to perform extensive background computations, you might want to use dedicated
    tools to handle queued task execution. This would allow you to run the tasks in
    a separate process and avoid any performance issues that may arise from running
    them in the same process.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs: []
  type: TYPE_NORMAL
- en: When a request is made to the endpoint, the background task is enqueued to the
    `BackgroundTasks` object. All the tasks are passed to the event loop so that they
    can be executed concurrently, allowing for non-blocking I/O operations.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a task that requires a lot of processing power and doesn’t necessarily
    need to be completed by the same process, you might want to consider using larger
    tools such as Celery.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more on creating background tasks in FastAPI on the official documentation
    page at this link:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Background* *Tasks*: [https://fastapi.tiangolo.com/tutorial/background-tasks/](https://fastapi.tiangolo.com/tutorial/background-tasks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
