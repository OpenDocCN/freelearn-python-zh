<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Class and Objects</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Class and Objects</h1>
            </header>

            <article>
                
<p>Before we delve deeper into classes&#160;and objects, let's first try to understand what they are and why they form part of Python programming. Python language also supports object-oriented programming. For beginners, this might be a little confusing topic but be assured it is not that difficult to understand the concept of object-oriented programming (OOP). Let's try to understand what object-oriented programming is. Before this concept was introduced, we were primarily slave to writing procedural programming, that is, going line by line. At this level, you need not understand what is procedural programming but certainly there is one example to illustrate it,&#160;that is, C language. In procedural programming, there were a lot of complexities and above all procedural programming had negligible code reuse concept.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Object-oriented programming overview</h1>
            </header>

            <article>
                
<p>The concept of object-oriented programming was seen to solve many problems, which procedural programming did not solve. In object-oriented programming, everything mimics just like a real-world object. In the real world, everything is an object. An object can have state and behavior. An object in the real world can communicate with another object. For example, a dog object in the real world has state and behavior. OOPs is based on four pillars. They are:</p>
<ul>
<li>Polymorphism</li>
<li>Inheritance</li>
<li>Abstraction</li>
<li>Encapsulation</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Key concepts</h1>
            </header>

            <article>
                
<p>OOPs is a vast topic that needs to be covered at the intermediate level. In case of Python programming, however, we will cover some key concepts in this chapter.</p>
<ul>
<li><strong>Class</strong>: Class is considered as a blueprint for object creation. It can be understood as a factory to produce objects. It provides a template for creating an object and specifying its behavior through means of methods and state through means of variable instance name.</li>
<li><strong>Objects</strong>: They can be considered as an instance of a class. An object can have state and behavior or attributes. The objects basically bundles a set of related states and behaviors, for example, a dog has state (<em>name</em>) and behavior (<em>barking</em>).</li>
<li><strong>Inheritance</strong>: Inheritance is a feature supported by many programming languages, it can be correlated in real life as properties passed on by parents to their children. In object-oriented programming, the child class can inherit many properties from the parent class. Here, we mean that the child class can use an&#160;existing method or behavior, which the parent class has defined and use them accordingly in their class. Inheritance can be a single inheritance or multiple inheritance. Single inheritance, as the name suggests, refers to only one parent, while multiple inheritance refers to inheriting the property from multiple parents.</li>
<li><strong>Polymorphism</strong>: Well, this literally means something, which has many forms. In OOPs, an object can have many forms through means of different attributes. To simplify, in our case, we can understand it by methods with the same name but having different outputs.</li>
<li><strong>Abstraction</strong>: Here, we hide the necessary details and are only interested in&#160;showing the relevant details to the other intended user. Here, by other intended user we mean another software application, or another class, or other client who will be the end users of the program.</li>
<li><strong>Encapsulation</strong>: This&#160;refers to hiding the necessary methods and their relevant details from the outside world. A class can be treated as a best example, which provides encapsulation to the methods and relevant instances.</li>
</ul>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Creating a class</h1>
            </header>

            <article>
                
<p>Now, after understanding some basic concepts of OOPs, let's understand them with some programming.</p>
<p>Creating a class in Python is quite easy. Refer to&#160;the following syntax:</p>
<pre> class &lt;class name &gt;(&lt;parent class name&gt;):<br/>      &lt;method definition-1&gt;<br/>      &lt;method definition-n&gt;
</pre>
<p>Let's create a&#160;<kbd>class1.py</kbd>&#160;program. In this program, we are creating an empty class:</p>
<pre>class Leapx_org():<br/> pass
</pre>
<p>We have just created a&#160;<kbd>Leapx_org</kbd>&#160;class. This class is empty, the class body just contains the pass statement. Basically, the class is a blueprint to create instances. Let's create the instances:</p>
<pre>L_obj1 = Leapx_org()<br/>L_obj2 = Leapx_org() <br/>print L_obj1<br/>print L_obj2
</pre>
<p>Let's run the&#160;<kbd>class1.py</kbd>&#160;program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="137" width="474" class="image-border" src="images/class1.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program class1.py</div>
<p>In the preceding screenshot, you can see both the instances of the&#160;<kbd>Leapx_org</kbd> class at different locations in memory.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Instance variables</h1>
            </header>

            <article>
                
<p>Instance variables refer to the data that&#160;are unique to instances (objects). Let's create an instance variable. We will&#160;write a new&#160;<kbd>class2.py</kbd>&#160;program:</p>
<pre>class Leapx_org():<br/>  pass<br/>L_obj1 = Leapx_org()<br/>L_obj2 = Leapx_org() <br/>L_obj1.f_name = "Mohit"<br/>L_obj1.L_name = "RAJ"<br/>L_obj1.pamount = "60000"<br/>L_obj2.f_name = "Ravender"<br/>L_obj2.L_name = "Dahiya"<br/>L_obj2.pamount = "70000"<br/>print L_obj1.f_name+ " "+ L_obj1.L_name<br/>print L_obj2.f_name+ " "+ L_obj2.L_name
</pre>
<p>In the preceding code, <kbd>L_obj1.f_name</kbd>, <kbd>L_obj1.L_name</kbd>, and <kbd>L_obj1.pamount</kbd> are the instance variables, which are unique to the&#160;<kbd>L_obj1</kbd>&#160;instance. Similarly,&#160;<kbd>L_obj2.f_name</kbd>, <kbd>L_obj2.L_name</kbd>, and <kbd>L_obj2.pamount</kbd> are the instance variables of the&#160;<kbd>L_obj2</kbd>&#160;instance.</p>
<p>Let's run the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="133" width="400" class="image-border" src="images/class2.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code class2.py</div>
<p>If we create an instance variable, as shown in the code, then we would not get benefit of making a class. You can see repeatable code for both the instances. So we would not have to set the variable all the time. In order to make it automatically, we will&#160;use the special <kbd>method __init__()</kbd>&#160;function.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">The __init__ method</h1>
            </header>

            <article>
                
<p>The <kbd>__init__()</kbd> method must begin and end with two consecutive underscores. Here <kbd>__init__</kbd> works as the class's constructor. When a user instantiates the class, it runs automatically. Let's see and understand this concept with the help of code. Here we will write the full code for&#160;<kbd>classinit.py</kbd> and then we will understand it line by line:</p>
<pre>class Leapx_org():<br/>  def __init__(self,first,last,pay):<br/>    self.f_name = first<br/>    self.l_name = last<br/>    self.pay_amt = pay <br/>    self.full_name = first+" "+last<br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print L_obj1.full_name<br/>print L_obj2.full_name<br/><br/>
</pre>
<p>So, from preceding code,&#160;it seems difficult; let's understand it by line by line. The first line defines a class as we already know. When we create the&#160;<kbd>__init__(self,first,last, pay)</kbd> method inside the class then first argument, self, <kbd>of __init__()</kbd> method receives the instance of the class automatically. By convention we call it <kbd>self</kbd>, you can use another name, but it is a good idea to stick to the convention. After declaring the&#160;<kbd>self</kbd>&#160;variable, we can specify other arguments that we want to accept. So we will&#160;accept three values <kbd>first</kbd>, <kbd>last</kbd>, and <kbd>pay</kbd>. Inside the <kbd>__init__()</kbd> method we will&#160;declare the instance variable. So the <kbd>self.f_name</kbd>, <kbd>self.l_name</kbd>, <kbd>self.pay_amt</kbd>, and <kbd>self.full_name</kbd> are instance variables. The <kbd>self</kbd> variable receives the instance. The&#160;<kbd>self.f_name = first</kbd> statement is the same thing as we saw&#160;<kbd>L_obj1.f_name = "Mohit"</kbd> in the previous code <kbd>class2.py</kbd>. The <kbd>L_obj</kbd> is the instance of the class and the variable is self referred to instance of the class, which is more or less&#160;similar. When we create an instance like <kbd>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)</kbd> the values <kbd>('mohit', 'RAJ', 60000)</kbd>&#160;are automatically passed to the&#160;<kbd>__init__(self, first, last, pay)</kbd> method. We don’t need to pass the value of the&#160;<kbd>self</kbd>&#160;variable, because the&#160;<kbd>L_obj1</kbd> instance is passed automatically. Similar things happens for the&#160;<kbd>L_obj2</kbd>&#160;instance. If &#160;your doubt still persists for the self and instance variables, you can refer to&#160;the following figure for clarification:</p>
<div class="CDPAlignCenter CDPAlign"><img height="248" width="417" class="image-border" src="images/class3.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Self linking with object</div>
<p>Now you got an&#160;idea of the instance variable: the <kbd>self.f_name</kbd>, <kbd>self.l_name</kbd>, <kbd>self_pay_amt</kbd>, and <kbd>self.full_name</kbd> are the instance variables, unique to instance <kbd>L_obj1</kbd> and <kbd>L_obj2</kbd>. The <kbd>self.f_name</kbd>, <kbd>self.l_name</kbd>, &#160;<kbd>self_pay_amt</kbd>, and <kbd>self.full_name</kbd> contain values <kbd>mohit</kbd>, <kbd>RAJ</kbd>, and <kbd>60000</kbd>, for instance,&#160;<kbd>L_obj1</kbd> and <kbd>Ravender</kbd>, <kbd>Dahiya</kbd>&#160;and&#160;<kbd>70000</kbd>, for instance,&#160;<kbd>L_obj2</kbd>, respectively.</p>
<p>Let's run the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="118" width="398" class="image-border" src="images/class4.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of classinit.py</div>
<p>You can see that the preceding result and the result from&#160;<kbd>class2.py</kbd>&#160;are the same. But we reduce few&#160;lines from the code <kbd>classinit.py</kbd>.</p>
<p>Let's create the method inside the class. We want a functionality to generate the e-mail address for users. We will write&#160;the full code for&#160;<kbd>classmethod1.py</kbd>&#160;and discuss it:</p>
<pre>class Leapx_org():<br/>  def __init__(self,first,last,pay):<br/>    self.f_name = first<br/>    self.l_name = last<br/>    self.pay_amt = pay <br/>    self.full_name = first+" "+last<br/>  def make_email(self):<br/>    return self.f_name+ "."+self.l_name+"@xyz.com"<br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print L_obj1.full_name<br/>print L_obj1.make_email()<br/>print L_obj2.full_name<br/>print L_obj2.make_email()
</pre>
<p>The code is very much similar to the previous code. We added the&#160;<kbd>make_email()</kbd> method here, which used the instance variables <kbd>self.f_name</kbd> and <kbd>self.l_name</kbd>. By using the <kbd>L_obj1.make_email()</kbd>&#160;syntax the <kbd>L_obj1</kbd>&#160;instance calls the <kbd>method make_email()</kbd>&#160;method.</p>
<p>The <kbd>make_email()</kbd> is the regular method. What is the regular method? The regular methods in the class automatically take the instances as the first argument. That's why, by convention, we use self as the first argument which expects an instance.</p>
<p>If you remember, in string, list we did the same thing as we did in&#160;<kbd>list1.append()</kbd>. If you relate list with the preceding&#160;class, then <kbd>list1</kbd> is the instance and <kbd>append()</kbd> is the method of the class list. You can also define the list as shown here:</p>
<pre>List1 = list()
</pre>
<p>Let's go deeper to explore the&#160;<kbd>self</kbd>&#160;variable. If you are still in doubt, the next example will clear it. Refer to&#160;the code in&#160;<kbd>classmethod2.py</kbd>&#160;as follows:</p>
<pre>class Leapx_org():<br/>  def __init__(self,first,last,pay):<br/>    self.f_name = first<br/>    self.l_name = last<br/>    self.pay_amt = pay <br/>    self.full_name = first+" "+last<br/>  def make_email():<br/>    return self.f_name+ "."+self.l_name+"@xyz.com"<br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>print L_obj1.make_email()
</pre>
<p>The preceding code is very much similar to <kbd>classmethod2.py</kbd>. In order to experiment, we used just one instance <kbd>L_obj1</kbd>. In the&#160;<kbd>make_email()</kbd>&#160;method, the argument self has been removed. Let's run the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="135" width="447" class="image-border" src="images/class5.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classmethod2.py</div>
<p>You can see that error <kbd>make_email() takes no arguments (1 given)</kbd>. This can be confusing as we have not passed any argument in the syntax <kbd>L_obj1.make_email()</kbd>. What is the&#160;<kbd>make_email()</kbd>&#160;method expecting? In this case, the <kbd>L_obj1</kbd>&#160;instance is passed automatically. That’s why we use the&#160;<kbd>self</kbd> argument to the methods of the class.</p>
<p>Let's see following code <kbd>classmethod3.py</kbd>&#160;in order to understand this better:</p>
<pre>class Leapx_org():<br/>  def __init__(self,first,last,pay):<br/>    self.f_name = first<br/>    self.l_name = last<br/>    self.pay_amt = pay <br/>    self.full_name = first+" "+last <br/>  def make_email(self):<br/>    return self.f_name+ "."+self.l_name+"@xyz.com"<br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>print L_obj1.make_email()<br/>print Leapx_org.make_email(L_obj1)
</pre>
<p>In the preceding code, the <kbd>self</kbd>&#160;variable has been put in the&#160;<kbd>make_email(self)</kbd>&#160;method. In the last line,&#160;<kbd>Leapx_org.make_email(L_obj1)</kbd> signifies what is running in the background. The syntax <kbd>L_obj1.make_email()</kbd> and <kbd>Leapx_org.make_email(L_obj1)</kbd> both are one and the same.</p>
<p>The syntax <kbd>Leapx_org.make_email(L_obj1)</kbd> states <kbd>class.method(instance)</kbd>. In this syntax, we pass&#160;the instance to the&#160;<kbd>make_email()</kbd> method and the&#160;<kbd>self</kbd> argument accepts that instance. So,&#160;<kbd>L_obj1.make_email()</kbd> is transformed into <kbd>Leapx_org.make_email(L_obj1)</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Class variables</h1>
            </header>

            <article>
                
<p>Class variables are the ones, which are sharable among all the instances of the class. The class variable must be the same for all the instances. To understand with example, let's assume that <kbd>leapx_org</kbd> gives 5 percent increment based upon <kbd>pay_amt</kbd>. Let's use&#160;another method to calculate the increment. Refer to&#160;the&#160;<kbd>classinstance1.py</kbd>&#160;program:</p>
<pre>class Leapx_org():<br/>  def __init__(self,first,last,pay):<br/>    self.f_name = first<br/>    self.l_name = last<br/>    self.pay_amt = pay <br/>    self.full_name = first+" "+last<br/>  def make_email(self):<br/>    return self.f_name+ "."+self.l_name+"@xyz.com"<br/>  def incrementpay(self):<br/>    self.pay_amt = int(self.pay_amt*1.20)<br/>    return self.pay_amt<br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print L_obj1.pay_amt<br/>print L_obj1.incrementpay()
</pre>
<p>There are a couple of things that are new in the preceding program. We added <kbd>incrementpay()</kbd> which returns the raised <kbd>pay_amt amount</kbd>. The last line <kbd>print L_obj1.incrementpay()</kbd> states that the&#160;<kbd>L_obj1</kbd> instance calls the&#160;<kbd>incrementpay()</kbd>&#160;method. Let's run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="101" width="497" class="image-border" src="images/class6.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of classinstance1.py</div>
<p>The preceding program runs successfully but most of its content is logically wrong. In the&#160;<kbd>incrementpay()</kbd> method, we used the multiplication number <kbd>1.20</kbd>, which would be same for all the instances. So we can make the multiplication number <kbd>1.20</kbd> as the class variable.</p>
<p>Let's write the new code <kbd>classinstance2.py</kbd> with amendments:</p>
<pre>class Leapx_org():<br/>    mul_num = 1.20<br/>    def __init__(self,first,last,pay):<br/>       self.f_name = first<br/>       self.l_name = last<br/>       self.pay_amt = pay <br/>       self.full_name = first+" "+last<br/>   def make_email(self):<br/>       return self.f_name+ "."+self.l_name+"@xyz.com"<br/>   def incrementpay(self):<br/>       self.pay_amt = int(self.pay_amt*self.mul_num)<br/>       return self.pay_amt<br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print L_obj1.pay_amt<br/>print L_obj1.incrementpay()
</pre>
<p>In the preceding program, we made a&#160;<kbd>mul_num</kbd> class variable that contains the value <kbd>1.20</kbd>. In the&#160;<kbd>incrementpay()</kbd>&#160;method, we access the&#160;<kbd>mul_num</kbd> class variable with the help of&#160;<kbd>self</kbd> means instance. You can use either <kbd>self</kbd> or class name with the <kbd>mul_num</kbd>. If you use the class name with <kbd>mul_num</kbd>, then it would be <kbd>Leapx_org. mul_num</kbd>. If you don't use any of them, then the interpreter throws an error. You might be confused, if it is a class variable, then how can we access the class variable with the instance. Let's add some lines to understand it better. Add the following lines at the end of the code:</p>
<pre>print L_obj1.mul_num<br/>print L_obj2.mul_num<br/>print Leapx_org.mul_num
</pre>
<p>Run the program and see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="137" width="424" class="image-border" src="images/class7.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program classinstance2 with added lines</div>
<p>As you can see, we are accessing the&#160;<kbd>mul_num</kbd> class variable with the help of instances <kbd>L_obj1</kbd>, <kbd>L_obj2</kbd>, and the&#160;<kbd>Leapx_org</kbd>&#160;class. All are showing the same value <kbd>1.2</kbd>. So what happens when we try to access an attribute by an instance? The instance first checks whether&#160;the instance contains the attribute. If the instance does not contain the attribute, then it checks the class or its parent class contains that attribute. So the instances&#160;<kbd>L_obj1</kbd> and <kbd>L_obj2</kbd> access the <kbd>mul_num</kbd> from the class. For more clarification, you can view the attribute of the class and instances.</p>
<p>The following is&#160;the full code of <kbd>classinstance3.py</kbd>:</p>
<pre>class Leapx_org():<br/>   mul_num = 1.20<br/>   def __init__(self,first,last,pay):<br/>        self.f_name = first<br/>        self.l_name = last<br/>        self.pay_amt = pay <br/>        self.full_name = first+" "+last<br/><br/>   def make_email(self):<br/>       return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>   def incrementpay(self):<br/>      self.pay_amt = int(self.pay_amt*self.mul_num)<br/>      return self.pay_amt<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print "instance space ",L_obj1.__dict__<br/>print "class space ",Leapx_org.__dict__
</pre>
<p>Except for the last two lines, the rest of the code is similar to the previous one. The&#160;<kbd>L_obj1.__dict__</kbd> syntax prints all the attributes of the&#160;<kbd>L_obj1</kbd> instance and <kbd>Leapx_org.__dict__</kbd> prints all the attributes of the&#160;<kbd>Leapx_org</kbd>&#160;class. Run the program to see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="131" width="594" class="image-border" src="images/class8.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classinstance3.py</div>
<p>You can see that the instance name space does not contain the&#160;<kbd>mul_num</kbd> class variable, but the class name space contains&#160;<kbd>mul_num</kbd>. Let's add <kbd>mul_num</kbd> to the name space of the&#160;<kbd>L_obj1</kbd>&#160;instance. &#160;To avoid confusion, we will&#160;write <kbd>classinstance4.py</kbd>:</p>
<pre>class Leapx_org():<br/>    mul_num = 1.20<br/>    def __init__(self,first,last,pay):<br/>       self.f_name = first<br/>       self.l_name = last<br/>       self.pay_amt = pay <br/>       self.full_name = first+" "+last<br/><br/>   def make_email(self):<br/>       return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>   def incrementpay(self):<br/>       self.pay_amt = int(self.pay_amt*self.mul_num)<br/>       return self.pay_amt<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>L_obj1.mul_num = 1.3<br/><br/>print "instance space L_obj1 n",L_obj1.__dict__<br/>print "ninstance space L_obj2 n",L_obj2.__dict__<br/>print "nclass space n",Leapx_org.__dict__<br/><br/>print L_obj1.mul_num <br/>print L_obj2.mul_num <br/>print Leapx_org.mul_num
</pre>
<p>In the preceding code, line <kbd>L_obj1.mul_num = 1.3</kbd> adds the&#160;<kbd>mul_num</kbd> variable in the name space of the&#160;<kbd>L_obj1</kbd>&#160;instance. The last three lines of code print the name of space of the instance <kbd>L_obj1</kbd>, <kbd>L_obj2</kbd> and the&#160;<kbd>Leapx_org</kbd>&#160;class. Let's run the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="202" width="608" class="image-border" src="images/class9.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classinstance4.py</div>
<p>The preceding output shows that the&#160;<kbd>L_obj1</kbd> instance finds the <kbd>mul_num</kbd> first with its own namespace before searching in the class namespace. That's why <kbd>L_obj1</kbd> shows&#160;<kbd>1.3</kbd>. We did not set <kbd>mul_num</kbd>, for instance,&#160;<kbd>L_obj2</kbd>, so <kbd>L_obj2</kbd> is still getting the value from the class namespace. In the&#160;<kbd>incrementpay()</kbd>&#160;method, we use <kbd>self.mul_num</kbd> instead of <kbd>Leapx_org.mul_num</kbd> because <kbd>self.mul_num</kbd> gives the ability to change <kbd>mul_num</kbd> value for single instance, if we want to. Let's create one more class variable to count the number of employees.</p>
<p>Let us see the next code <kbd>classinstance5.py</kbd>:</p>
<pre>class Leapx_org():<br/>    mul_num = 1.20<br/>    count= 0<br/>    def __init__(self,first,last,pay):<br/>        self.f_name = first<br/>        self.l_name = last<br/>        self.pay_amt = pay <br/>        self.full_name = first+" "+last<br/>        Leapx_org.count = Leapx_org.count+1<br/><br/>    def make_email(self):<br/>        return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>    def incrementpay(self):<br/>        self.pay_amt = int(self.pay_amt*self.mul_num)<br/>        return self.pay_amt<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>L_obj3 = Leapx_org('Bhaskar', 'DAS',70000)<br/>print "Number of Employees are : ", Leapx_org.count
</pre>
<p>Earlier we created new class variables count initializing with <kbd>0</kbd>. The syntax <kbd>Leapx_org.count = Leapx_org.count+1</kbd> increases the class variable by one. We have created three instances. Whenever we create a new instance, the <kbd>count</kbd> variable is incremented by one. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="108" width="474" class="image-border" src="images/class10.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classinstance5.py</div>
<p>Now you got the idea of the class variable. If you set <kbd>self.count = self.count+1</kbd> instead of <kbd>Leapx_org.count = Leapx_org.count+1</kbd>, then you would get <kbd>0</kbd> employees.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Class inheritance</h1>
            </header>

            <article>
                
<p>In this section, we will&#160;learn about inheritance. Inheritance allows us to inherit methods and attributes of the parent class. By inheritance, a new child class automatically gets all of the methods and attributes of the existing parent class. The syntax is given as follows:</p>
<pre>class DerivedClassName(BaseClassName):<br/>   &lt;statement-1&gt;<br/>   .<br/>   . .<br/>   &lt;statement-N&gt;
</pre>
<p>If you remember, in&#160;<a href="lrn-py-7d_ch09.html">Chapter 10</a>, <em>File Handling&#160;and Exceptions</em>, we had inherited the built-in class exception. Starting with the existing code, let's make the&#160;<kbd>instructor</kbd>&#160;class, which would inherit the method of the&#160;<kbd>Leapx_org</kbd> class. Refer to&#160;the code in&#160;<kbd>classinheri1.py</kbd>:</p>
<pre>class Leapx_org():<br/>   mul_num = 1.20<br/>   count= 0<br/>   def __init__(self,first,last,pay):<br/>      self.f_name = first<br/>      self.l_name = last<br/>      self.pay_amt = pay <br/>      self.full_name = first+" "+last<br/>      Leapx_org.count = Leapx_org.count+1<br/><br/>   def make_email(self):<br/>      return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>   def incrementpay(self):<br/>      self.pay_amt = int(self.pay_amt*self.mul_num)<br/>      return self.pay_amt<br/><br/>class instructor(Leapx_org):<br/>      pass<br/>I_obj1 = instructor('mohit', 'RAJ', 60000)<br/>I_obj2 = instructor('Ravender', 'Dahiya',70000) <br/>print "number of employees ", instructor.count<br/>print I_obj1.make_email()<br/>print I_obj2.make_email()
</pre>
<p>In preceding code, we create a new class instructor which inherits the method and attributes from the&#160;<kbd>Leapx_org</kbd>&#160;class. The <kbd>Leapx_org</kbd>&#160;class is the base class and the instructor class is the&#160;child class. We left the body of the instructor class&#160;blank. We created two instances of the instructor class, then we printed the e-mails. Let's run the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="117" width="392" class="image-border" src="images/class11.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classinheri1.py</div>
<p>The preceding result shows that the child class is successfully accessing the attributes of the parent class. When we instantiate the instructor class, it first looks up the <kbd>__init__</kbd> method of the instructor class. As the instructor class is empty, the interpreter checks the chain of inheritance. If you want to check the chain of inheritance, you need to use the&#160;<kbd>help()</kbd> function. Add the following lines in the <kbd>classinheri1.py</kbd> code and run it:</p>
<div class="CDPAlignCenter CDPAlign"><img height="288" width="421" class="image-border" src="images/class12.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of the help function</div>
<p>In the preceding screenshot, you can easily see which methods, data, and attributes inherit from the base class. You can say that the base class is generic class and the child class is a specific class. Let's proceed to more complicated examples. In the instructor class, we will&#160;add one more thing, which instructor teaches which subject. In order to do that, we need&#160;to add the&#160;<kbd>__init__</kbd> method to the instructor class. Let's see the code <kbd>classinheri2.py</kbd> and discuss the additions:</p>
<pre>class Leapx_org():<br/>   mul_num = 1.20<br/>   count= 0<br/>   def __init__(self,first,last,pay):<br/>      self.f_name = first<br/>      self.l_name = last<br/>      self.pay_amt = pay <br/>      self.full_name = first+" "+last<br/>      Leapx_org.count = Leapx_org.count+1<br/><br/>   def make_email(self):<br/>      return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>   def incrementpay(self):<br/>      self.pay_amt = int(self.pay_amt*self.mul_num)<br/>      return self.pay_amt<br/><br/>class instructor(Leapx_org):<br/>   def __init__(self,first,last,pay, subject):<br/>   Leapx_org.__init__(self,first,last,pay)<br/>   self.subject = subject<br/><br/>I_obj1 = instructor('mohit', 'RAJ', 60000, "Python")<br/>I_obj2 = instructor('Ravender', 'Dahiya',70000, "Data Analytic") <br/>print I_obj1.make_email()<br/>print I_obj1.subject<br/>print I_obj2.make_email()<br/>print I_obj2.subject
</pre>
<p>In the class instructor, we have created a <kbd>new __init__</kbd> method, which accepts the data <kbd>first</kbd>, <kbd>last</kbd>, <kbd>pay</kbd>, and <kbd>subject</kbd>. Now, there is no need to copy and paste the code of the&#160;<kbd>__init__</kbd> method from the&#160;<kbd>Leapx_org</kbd>&#160;base class. In order to get the data of the first, last, and pay arguments, we have used the&#160;<kbd>Leapx_org.__init__(self,first,last,pay)</kbd>&#160;syntax. This syntax passes the <kbd>first</kbd>, <kbd>last</kbd>, and <kbd>pay</kbd> arguments to the&#160;<kbd>Leapx_org</kbd>&#160;base class. The arguments&#160;<kbd>first</kbd>, <kbd>last</kbd>, and <kbd>pay</kbd>&#160;are handled by the&#160;<kbd>Leapx_org</kbd> class and the subject argument is handled by the class instructor.</p>
<p>We created two instances <kbd>I_obj1</kbd> and <kbd>l_obj2</kbd>, which pass the data to the instructor class. Let's run the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="165" width="501" class="image-border" src="images/class13.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classinheri2.py</div>
<p>Now you can understand that by using this class we can avoid repeating a lot of code.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Multiple inheritance</h1>
            </header>

            <article>
                
<p>In multiple inheritance, a class inherits the attributes and methods from more than one parent class. Let's take a simple example <kbd>classmultiple.py</kbd>:</p>
<pre>class A():<br/>   def sum1(self,a,b):<br/>     c = a+b<br/>     return c<br/>class B():<br/>   def sub1(self,a,b):<br/>     c = a-b <br/>     return c<br/>class C(A,B):<br/>   pass<br/>c_obj = C()<br/>print "Sum is ", c_obj.sum1(12,4)<br/>print "After substraction ",c_obj.sub1(45,5)
</pre>
<p>In the preceding code, we have created three classes. Class <kbd>A</kbd> contains a&#160;<kbd>sum1()</kbd> method, which performs the sum of two numbers. Class <kbd>B</kbd> contains a&#160;<kbd>sub1()</kbd> method, which performs the subtraction of two numbers. Class <kbd>C</kbd>&#160;is the class that inherits classes&#160;<kbd>A</kbd> and <kbd>B</kbd>. The <kbd>c_obj</kbd>&#160;instance is an instance of class <kbd>C</kbd>. The statement <kbd>c_obj.sum1(12,4)</kbd> calls the <kbd>sum1()</kbd> method of class <kbd>A</kbd>. The&#160;<kbd>c_obj.sub1(45,5)</kbd> statement calls the <kbd>sub1()</kbd> method of class <kbd>B</kbd>. Let's run the code <kbd>classmultiple.py</kbd>:</p>
<div class="CDPAlignCenter CDPAlign"><img height="116" width="469" class="image-border" src="images/class14.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program classmultiple.py</div>
<p>The preceding output shows that the program is running successfully.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Multilevel inheritance</h1>
            </header>

            <article>
                
<p>In this type of inheritance, a class can inherit from a child class or derived class. Let's take a simple example code <kbd>classmultilevel.py</kbd> to understand:</p>
<pre>class A():<br/>  def sum1(self,a,b):<br/>    c = a+b<br/>    return c<br/><br/>class B(A):<br/>  pass<br/><br/>class C(B):<br/>  pass<br/><br/>c_obj = C()<br/>print "Sum is ", c_obj.sum1(12,4)
</pre>
<p>In the preceding example, you can see that class <kbd>B</kbd> inherited from class <kbd>A</kbd> and class <kbd>C</kbd> inherited from class <kbd>B</kbd>. The instance of class <kbd>C</kbd> can call the method of class <kbd>A</kbd>. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="101" width="422" class="image-border" src="images/class15.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classmultilevel.py</div>
<p>The preceding output shows that the code is running successfully.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Overriding methods</h1>
            </header>

            <article>
                
<p>Overriding the methods allows a user to override the parent class method. Sometimes the class provides a generic method, but in the child class, the user wants a specific implementation of the method. The name of the method must be the same in the parent class and the child class.</p>
<p>Let's see the program <kbd>classover1.py</kbd>:</p>
<pre>class A():<br/>  def sum1(self,a,b):<br/>    print "In class A"<br/>    c = a+b<br/>    return c<br/><br/>class B(A):<br/>  def sum1(self,a,b):<br/>    print "In class B"<br/>    c= a*a+b*b<br/>    return c<br/><br/>b_obj = B()<br/>print B.__dict__<br/>print b_obj.sum1(4,5)
</pre>
<p>In the preceding example, classes&#160;<kbd>A</kbd> and <kbd>B</kbd> both have the same method <kbd>sum1()</kbd> with different implementations. We also have printed the class name space using <kbd>B.__dict__</kbd>. Let's see the output of the code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="132" width="642" class="image-border" src="images/class16a.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classover1.py</div>
<p>In the preceding output, you can see the <kbd>sum1</kbd> function. The Interpreter first checks the instance’s class name space: if the method is found, the interpreter uses it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Operator overloading</h1>
            </header>

            <article>
                
<p>In this section, we will learn about&#160;operator overloading with special methods. Generally, people call them magic methods. We will use these methods in operator overloading. First, let's understand what operator overloading is. Using a special method, we'll able to change the built-in behavior of the operator. The special method is surrounded by double underscores (<kbd>__</kbd>). Some people called it the dunder method. Let's take an example of the&#160;<kbd>+</kbd>&#160;operator, as shown in the following example:</p>
<pre>&gt;&gt;&gt; "M"+"R"<br/>'MR'<br/>&gt;&gt;&gt; 4+6<br/>10<br/>&gt;&gt;&gt;
</pre>
<p>You can see a different behavior of the&#160;<kbd>+</kbd> operator. The integer number is&#160;added and the strings are concatenated. Depending&#160;upon the object you are working with, the <kbd>+</kbd>&#160;operator has different behavior. However,&#160;the <kbd>+</kbd>&#160;calling is a special method that runs in the background. In order to do addition of two integers, the&#160;<kbd>+</kbd> operator calls&#160;<kbd>int.__add__(1,2)</kbd> and for string addition <kbd>+</kbd>&#160;calls&#160;<kbd>str.__add__(“a”, “b”)</kbd>. Refer to&#160;the following example:</p>
<pre>&gt;&gt;&gt; int.__add__(4,6)<br/>10<br/>&gt;&gt;&gt; str.__add__("M","R")<br/>'MR'<br/>&gt;&gt;&gt;
</pre>
<p>So we can customize the addition using the&#160;<kbd>__add__()</kbd> method. Let's take an example of the following&#160;code <kbd>classoperator1.py</kbd>, which is very much similar to the earlier code snippets:</p>
<pre>class Leapx_org():<br/>   def __init__(self,first,last,pay):<br/>      self.f_name = first<br/>      self.l_name = last<br/>      self.pay_amt = pay <br/>      self.full_name = first+" "+last<br/><br/>   def make_email(self):<br/>      return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print L_obj1+L_obj2
</pre>
<p>We will&#160;add two instances <kbd>L_obj1</kbd> and <kbd>L_obj2</kbd>. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="131" width="589" class="image-border" src="images/class16.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classoperator1.py</div>
<p>The preceding output shows an error in the code. Error for the&#160;<kbd>+</kbd> operator <kbd>L_obj1</kbd> and <kbd>L_obj2</kbd> are unsupported. We don't know what we want to get from the addition. Consider we want to add the pay amount of both the instances. When I use <kbd>obj1+L_obj2</kbd>, the <kbd>+</kbd>&#160;operator should add the pay amount, which means <em>60000+70000</em>. Let's refer to&#160;the program and see how to overload the&#160;<kbd>+</kbd> operator:</p>
<pre>class Leapx_org():<br/>   def __init__(self,first,last,pay):<br/>     self.f_name = first<br/>     self.l_name = last<br/>     self.pay_amt = pay <br/>     self.full_name = first+" "+last<br/><br/>   def make_email(self):<br/>     return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>   def __add__(self,other):<br/>     result = self.pay_amt+ other.pay_amt<br/>     return result<br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print L_obj1+L_obj2
</pre>
<p>The preceding program is the same as the previous one except for the&#160;<kbd>magic __add__()</kbd> method. When we use <kbd>L_obj1+L_obj2</kbd>, then the <kbd>+</kbd> operator calls the <kbd>__add__()</kbd> method. The <kbd>__add__()</kbd> method accepts&#160;two instances as arguments. The syntax <kbd>result = self.pay_amt+ other.pay_amt</kbd> signifies the addition of <kbd>pay_amt</kbd> of two instances, which are <kbd>L_obj1</kbd> and <kbd>L_obj2</kbd>, in our case. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="92" width="457" class="image-border" src="images/class17.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of classoperator2.py</div>
<p>Let's do one more program, which compares <kbd>pay_amt</kbd>&#160;for both the instances. Here is the code for&#160;<kbd>classoperator3.py</kbd>:</p>
<pre>class Leapx_org():<br/>   def __init__(self,first,last,pay):<br/>      self.f_name = first<br/>      self.l_name = last<br/>      self.pay_amt = pay <br/>      self.full_name = first+" "+last<br/><br/>   def make_email(self):<br/>      return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>   def __gt__(self,other):<br/>      return self.pay_amt&gt;=other.pay_amt<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ',60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000) <br/>print L_obj1&gt;L_obj2
</pre>
<p>In the preceding program, the last statement <kbd>L_obj1&gt;L_obj2</kbd> would call the <kbd>__gt__()</kbd> method which accepts&#160;two instances; in this method, we perform a comparison based on their <kbd>pay_amt</kbd>. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="109" width="497" class="image-border" src="images/class18.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program classoperator3.py</div>
<p>Do your experiment with different <kbd>pay_amt</kbd> values.</p>
<p>Let's use the same program and print the instance length and instance. Refer to&#160;the code for&#160;<kbd>classoperator4.py</kbd>:</p>
<pre>class Leapx_org():<br/>   def __init__(self,first,last,pay):<br/>      self.f_name = first<br/>      self.l_name = last<br/>      self.pay_amt = pay <br/>      self.full_name = first+" "+last<br/><br/>   def make_email(self):<br/>      return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ',60000)<br/>print L_obj1<br/>print "n"<br/>print "Lenght is ",len(L_obj1)<br/><br/><br/>
</pre>
<p>In the preceding code, we have printed the instance and length of the instance. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="167" width="632" class="image-border" src="images/class19.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classoperator4.py</div>
<p>We need to use two magic methods: to customize the instance print, we will use <kbd>__str__()</kbd> and to find out the length, we will use <kbd>__len__()</kbd>. For the&#160;<kbd>__len__()</kbd> method, we will use the length of the full name. See the code <kbd>classoperator5.py</kbd>:</p>
<pre>class Leapx_org():<br/>    def __init__(self,first,last,pay):<br/>        self.f_name = first<br/>        self.l_name = last<br/>        self.pay_amt = pay <br/>        self.full_name = first+" "+last<br/><br/>    def make_email(self):<br/>        return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>    def __str__(self):<br/>        str1 = "instance belongs to "+self.full_name<br/>        return str1<br/><br/>    def __len__(self):<br/>        return len(self.f_name+self.l_name)<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ',60000)<br/>print L_obj1<br/>print "n"<br/>print "Lenght is ",len(L_obj1)
</pre>
<p>As discussed earlier, we need to use two methods: one is <kbd>__str__()</kbd> and the second one is <kbd>__len__()</kbd>. We used the customize output <kbd>instance is belong to</kbd>. The <kbd>__len__()</kbd> function returns the combined length of the first name and the second name. Refer to&#160;the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="136" width="479" class="image-border" src="images/class20.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of code classoperator5.py</div>
<p>Bingo! So both our purposes are served, the customized output and the length of the instance are being printed. I hope you got an&#160;idea how to use operator overloading and magic methods.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">The class method</h1>
            </header>

            <article>
                
<p>You have seen the regular class methods of the class. The regular method automatically takes an instance as the first argument, and, by convention, we called it <kbd>self.</kbd> How can we pass the class as an argument so that we can change the class variable in the method? To do that, we use the class method. The class method takes the class as first argument. To turn the regular method into the class method, we will&#160;use decorator (<kbd>@classmethod</kbd>) at the top of the method. Let's see the&#160;<kbd>methodclass1.py</kbd>&#160;example:</p>
<pre>class Leapx_org():<br/>    mul_num = 1.20<br/>    def __init__(self,first,last,pay):<br/>       self.f_name = first<br/>       self.l_name = last<br/>       self.pay_amt = pay <br/>       self.full_name = first+" "+last<br/><br/>    def make_email(self):<br/>       return self.f_name+ "."+self.l_name+"@xyz.com"<br/><br/>    def incrementpay(self):<br/>       self.pay_amt = int(self.pay_amt*self.mul_num)<br/>       return self.pay_amt<br/><br/>    @classmethod<br/>    def mul_num_set(cls, amt):<br/>       cls.mul_num=amt<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ', 60000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000)<br/>Leapx_org.mul_num_set(1.40)<br/>print L_obj1.mul_num<br/>print L_obj2.mul_num
</pre>
<p>In the&#160;<span>preceding</span> program, a couple of things are new. The regular method <kbd>mul_num_set()</kbd> has been converted into the class method using the decorator <kbd>@classmethod</kbd>&#160;at the top. In the&#160;<kbd>mul_num_set(cls,amt)</kbd> method, the first argument <kbd>cls</kbd>&#160;represents the class. By convention, we are using <kbd>cls</kbd>. Don't use <kbd>class</kbd> as the argument because <kbd>class</kbd> is the keyword, use it to define a class. The syntax <kbd>cls.mul_num=amt</kbd> sets the&#160;<kbd>mul_num</kbd> class variable to the&#160;<kbd>amt</kbd> value, which is passed by the line <kbd>Leapx_org.mul_num_set(1.40)</kbd>. The line <kbd>Leapx_org.mul_num_set(1.40)</kbd> calls the class method <kbd>mul_num_set()</kbd>&#160;using the class. You can also use an instance to call the class method as shown in&#160;<kbd>L_obj1.mul_num_set(1.40)</kbd>:</p>
<p>Let's run the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="121" width="495" class="image-border" src="images/class21.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program methodclass1.py</div>
<p>The same thing can be achieved using the&#160;<kbd>Leapx_org.mul_num= 1.40</kbd>&#160;line. But here&#160;we used the&#160;class method.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">The static method</h1>
            </header>

            <article>
                
<p>The static method doesn't&#160;take an instance or class as the first argument. They are just simple functions. But we include them in class because they have some logical connection with the class. Consider a situation in the&#160;<kbd>methodclass1.py</kbd> program, when the pay of a person is less than <kbd>50000</kbd>, then the incremented pay amount would be &#160;<kbd>1.30</kbd>of pay amount , otherwise <kbd>1.20</kbd>. To turn a regular method into a class method, we will&#160;use decorator (<kbd>@staticmethod</kbd>) at the top of the method.</p>
<p>Let's make the program:</p>
<pre>class Leapx_org():<br/>   mul_num = 1.20<br/>   mul_num2 = 1.30<br/>   def __init__(self,first,last,pay):<br/>      self.f_name = first<br/>      self.l_name = last<br/>      self.pay_amt = pay <br/>      self.full_name = first+" "+last<br/>   @staticmethod<br/>   def check_amt(amt):<br/>      if amt &lt;50000:<br/>         return True<br/>      else :<br/>         return False<br/>   def incrementpay(self):<br/>      if self.check_amt(self.pay_amt):<br/>         self.pay_amt = int(self.pay_amt*self.mul_num2)<br/>      else :<br/>         self.pay_amt = int(self.pay_amt*self.mul_num)<br/>         return self.pay_amt<br/><br/>L_obj1 = Leapx_org('mohit', 'RAJ', 40000)<br/>L_obj2 = Leapx_org('Ravender', 'Dahiya',70000)<br/>L_obj1.incrementpay()<br/>L_obj2.incrementpay()<br/>print L_obj1.pay_amt<br/>print L_obj2.pay_amt
</pre>
<p>In the <span>preceding</span> program, the&#160;<kbd>check_amt()</kbd> method is a static method as specified by the decorator <kbd>@staticmethod</kbd>. The&#160;<kbd>check_amt()</kbd> method checks whether <kbd>amt</kbd> is greater than <kbd>50000</kbd> or not. The&#160;<kbd>incrementpay()</kbd> method uses the&#160;<kbd>check_amt()</kbd>&#160;static method. The <kbd>check_amt()</kbd>&#160;method does not change the class and instance variable. But it has some logical connection with regular method <kbd>incrementpay()</kbd>.</p>
<p>Refer to&#160;the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="134" width="465" class="image-border" src="images/class22.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program staticmethod1.py</div>
<p>Hope you understood the static method.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">The private variable</h1>
            </header>

            <article>
                
<p>Python doesn't have real private methods, so two underlines&#160;at&#160;the beginning make a variable and a method private. Let's see a very simple example:</p>
<pre>class A:<br/>     __amount = 45<br/>    def __info(self):<br/>        print "I am in Class A"<br/>    def hello(self):<br/>        print "Amount is ",A.__amount<br/>a = A()<br/>a.hello()<br/>a.__info()<br/>a.__amount
</pre>
<p>In the&#160;<span>preceding</span> program, <kbd>__info()</kbd> is the private method and <kbd>__amount</kbd> is the private variable. Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="179" width="511" class="image-border" src="images/class23.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program private1.py</div>
<p>You can see the benefit of the private variable. Outside the class, you cannot access the private method as well as the private variable, but inside the class, you can access the private variables. In the&#160;<kbd>hello()</kbd> method, the <kbd>__amount</kbd>&#160;variable can be accessed as shown in the output (<kbd>Amount is printed</kbd>).</p>
<p>However, you can access private variables and the private method from outside the class. Use the syntax like instance <kbd>_class-name__private-attribute</kbd>.</p>
<p>Now, let's rewrite&#160;the program with the correct syntax:</p>
<pre>class A:<br/>    __amount = 45<br/><br/>    def __info(self):<br/>       print "I am in Class A"<br/><br/>    def hello(self):<br/>       print "Amount is ",A.__amount<br/><br/>a = A()<br/>a.hello()<br/>a._A__info()<br/>print a._A__amount
</pre>
<p>Let's see the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="161" width="464" class="image-border" src="images/class24.jpg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Output of program private1.py</div>
<p>So what is the benefit of&#160;accessing private variable outside the class. The benefit is to prevent the class method and variable being changed by others accidentally. Hope you get the idea of private methods.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>


  <div id="sbo-rt-content"><section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we have learned what is class and the benefits of creating a class. We&#160;learned how to create an instance or an object. Instance and object are the same thing. We&#160;learned the difference between class variable and instance variable. Class variables are shareable among all the regular methods. Static methods are unique to instances. In class inheritance, we learned the benefit of inheritance and code reuse. By using method overriding, we&#160;can override the method of the parent class. In operator overloading, we learned how to change the behavior of the built-in operator. We&#160;learned why to create static and class methods. The class methods are created to change class attributes. In the end,&#160;we learned the benefits of private methods and private variables.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </div>
</body>
</html>