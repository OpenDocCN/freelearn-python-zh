<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08" class="calibre1"/>Chapter 8. Adding External File Servers</h1></div></div></div><p class="calibre8">Salt Master<a id="id214" class="calibre1"/> normally keeps its resources locally on the machine that hosts it. This involves, among other things, files that are served to Minions. The file server loader allows you to use an external resource to store those files, and treat them as if they are local to the Master. In this chapter, we'll discuss:</p><div><ul class="itemizedlist"><li class="listitem">Understanding how Salt uses files</li><li class="listitem">Abstracting external sources to deliver files to Salt</li><li class="listitem">Using Salt's cache system</li><li class="listitem">Troubleshooting external file servers</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec44" class="calibre1"/>How Salt uses files</h1></div></div></div><p class="calibre8">There<a id="id215" class="calibre1"/> are two ways that Salt's built-in file server uses files when communicating with Minions. They can be served whole and intact, or they can be processed by a templating engine, using a renderer module as discussed in <a class="calibre1" title="Chapter 5. Rendering Data" href="part0033_split_000.html#VF2I1-d9976ffc65994572ad672a3ef48f1135">Chapter 5</a>, <em class="calibre9">Rendering Data</em>.</p><p class="calibre8">In either case, these files are stored in one or more sets of directories, as configured with the <code class="email">file_roots</code> directive in the master configuration file. These directories are grouped by environment. When Salt is looking for a file, it will search through the directories in the order in which they are listed. The default environment, <code class="email">base</code>, normally uses <code class="email">/srv/salt/</code> to store files. Such a configuration would look like:</p><div><pre class="programlisting">file_roots:
  base:
    - /srv/salt/</pre></div><p class="calibre8">What many users don't realize is that the <code class="email">file_roots</code> directive is actually a configuration option that is specific to a file server module called <code class="email">roots</code>. This module, along with all other file server modules, is configured using the <code class="email">fileserver_backend</code> directive:</p><div><pre class="programlisting">fileserver_backend:
  - roots</pre></div><p class="calibre8">This is where you configure any other file server modules to be used within Salt. Once again, modules are configured in the order in which they are to be used. When the Master requests a file for a Minion, Salt will check with each of these modules until it finds a match. When it does, it will stop looking, and serve the file that it has found. That means that if you have the following configuration:</p><div><pre class="programlisting">fileserver_backend:
  - git
  - roots</pre></div><p class="calibre8">And <a id="id216" class="calibre1"/>Salt finds the requested file inside of Git, it will ignore any files that would otherwise be found on the local filesystem.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec65" class="calibre1"/>Mimicking a filesystem</h2></div></div></div><p class="calibre8">If you <a id="id217" class="calibre1"/>have ever written a FUSE filesystem before, you will recognize some of the functions used inside a Salt file server module. Many of the operations used to request a file from an operating system are very similar to the files used by Salt to request a file. When it comes down to it, a Salt file server module is effectively a virtual filesystem, but with an API designed specifically for Salt, rather than for an operating system.</p><p class="calibre8">As you do development with file server modules, you may also notice another trend. While the data that is used may be stored in a remote location, it may be costly in terms of resources to repeatedly retrieve those files. Because of this, a number of file server modules will retrieve files from that remote location and then cache them locally on the Master, only updating them as necessary.</p><p class="calibre8">In this respect, when you are writing a file server module, you are often only implementing a means of retrieving and caching files, and serving them from the cache. This is not always the best thing to do; a truly dynamic file server based purely on database queries might perform best by always performing a lookup. You need to decide from the beginning what the most appropriate strategy is.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec45" class="calibre1"/>Looking at each function</h1></div></div></div><p class="calibre8">The file <a id="id218" class="calibre1"/>server that we will be writing will be based on SFTP. Because SFTP calls can be expensive to make, we will use a caching implementation that relies on a popular Python library called Paramiko to retrieve files. For simplicity, we will only allow one SFTP server to be configured, but if you find yourself using this module, you may want to consider allowing multiple endpoints to be configured.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec66" class="calibre1"/>Setting up our module</h2></div></div></div><p class="calibre8">Before <a id="id219" class="calibre1"/>we go over the functions that are used, we start setting up the module itself. We will implement a few functions that provide objects that we will use throughout the rest of our module:</p><div><pre class="programlisting">'''
The backend for serving files from an SFTP account.

To enable, add ``sftp`` to the :conf_master:`fileserver_backend` option in the
Master config file.

.. code-block:: yaml

    fileserver_backend:
      - sftp

Each environment is configured as a directory inside the SFTP account. The name
of the directory must match the name of the environment.

.. code-block:: yaml

    sftpfs_host: sftp.example.com
    sftpfs_port: 22
    sftpfs_username: larry
    sftpfs_password: 123pass
    sftpfs_root: /srv/sftp/salt/
'''
import os
import os.path
import logging
import time
import salt.fileserver
import salt.utils
import salt.syspaths

try:
    import fcntl
    HAS_FCNTL = True
except ImportError:
    HAS_FCNTL = False

try:
    import paramiko
    from paramiko import AuthenticationException
    HAS_LIBS = True
except ImportError:
    HAS_LIBS = False

__virtualname__ = 'sftp'

log = logging.getLogger()

transport = None
client = None


def __virtual__():
    '''
    Only load if proper conditions are met
    '''
    if __virtualname__ not in __opts__['fileserver_backend']:
        return False

    if not HAS_LIBS:
        return False

    if __opts__.get('sftpfs_root', None) is None:
        return False

    global client
    global transport

    host = __opts__.get('sftpfs_host')
    port = __opts__.get('sftpfs_port', 22)
    username = __opts__.get('sftpfs_username')
    password = __opts__.get('sftpfs_password')
    try:
        transport = paramiko.Transport((host, port))
        transport.connect(username=username, password=password)
        client = paramiko.SFTPClient.from_transport(transport)
    except AuthenticationException:
        return False

    return True</pre></div><p class="calibre8">There's <a id="id220" class="calibre1"/>quite a bit going on already! Fortunately, you should recognize most of this by now, so this part should go by quickly.</p><p class="calibre8">We've included a docstring that's a bit longer than usual, but which explains how to configure Salt to use our module. We will see these parameters used when we get to the <code class="email">__virtual__()</code> function.</p><p class="calibre8">Next, we <a id="id221" class="calibre1"/>set up our imports. The usage of most of these will be covered as we go through individual functions, but there are a couple that we have wrapped in <code class="email">try/except</code> blocks. The first of these is <code class="email">fcntl</code>, which is a Unix system call that handles file descriptors. This library is useful for locking files in Unix and Linux, but does not exist in Windows. However, the rest of our module is usable in Windows, so we set a flag now that can be used later, when we need to lock files.</p><p class="calibre8">The second <a id="id222" class="calibre1"/>import is Paramiko. This is one of the most popular connection libraries available for SSH and SFTP in Python, and simple to use for our purposes. If it has not been installed, then we can return <code class="email">False</code> in the <code class="email">__virtual__()</code> function.</p><p class="calibre8">We've added <code class="email">__virtualname__</code>, even though it's not strictly necessary, just so that we have a central and easy-to-find place to name our module. We will use this variable in the <code class="email">__virtual__() </code>function. We've also added a little logging, which we'll make use of.</p><p class="calibre8">Before even loading the <code class="email">__virtual__()</code> function, we've defined two variables to be used for connecting to the SFTP server. We'll assign a connection to them inside <code class="email">__virtual__()</code>, and it will be used throughout the rest of the module.</p><p class="calibre8">Finally, we have our <code class="email">__virtual__()</code> function. First, we check to see if our module has even been configured for use. If not, there's no point in going any further. We also check to make sure Paramiko is installed. Then we make sure a root directory has been specified for the SFTP server. It's not evident now, but this directory will be required elsewhere. If it's not there, then we're not even going to bother trying to connect to the server.</p><p class="calibre8">If it is defined, then we can go ahead and try to make our connection. Paramiko will raise <code class="email">AuthenticationException</code> if the rest of our parameters have been incorrectly defined, and in that case of course, we will consider this module unavailable and return <code class="email">False</code>. But if all of those stars line up, then we're ready for business!</p><p class="calibre8">Let's go over the functions that we should find inside any given file server module. In each section, we will implement and explain that function.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec67" class="calibre1"/>envs()</h2></div></div></div><p class="calibre8">We <a id="id223" class="calibre1"/>start off by reporting which environments have been configured for this file server. At the very least, the <code class="email">base</code> environment should be supported and reported, but it's best to offer a mechanism to support other environments as well. Because we're effectively abstracting a file management mechanism, it's often easiest to just do this by separating environments into directories:</p><div><pre class="programlisting">def envs():
    '''
    Treat each directory as an environment
    '''
    ret = []
    root = __opts__.get('sftpfs_root')
    for entry in client.listdir_attr(root):
        if str(oct(entry.st_mode)).startswith('04'):
            ret.append(entry.filename)
    return ret</pre></div><p class="calibre8">This <a id="id224" class="calibre1"/>function needs to return a list. Because we've separated out environments into their own directories, all that we need to do for our module is return a list of directories at the root directory that we've configured.</p><p class="calibre8">This function is tricky to test, because there's no direct interface for it in any Salt modules. However, it can be tested once the next two functions are in place.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec68" class="calibre1"/>file_list() and dir_list()</h2></div></div></div><p class="calibre8">These<a id="id225" class="calibre1"/> two functions are pretty self-explanatory; they connect to the remote <a id="id226" class="calibre1"/>endpoint and return a list of all files and directories for that environment:</p><div><pre class="programlisting">def file_list(load):
    '''
    Return a list of all files on the file server in a specified environment
    '''
    root = __opts__.get('sftpfs_root')
    path = os.path.join(root, load['saltenv'], load['prefix'])
    return _recur_path(path, load['saltenv'])


def dir_list(load):
    '''
    Return a list of all directories on the master
    '''
    root = __opts__.get('sftpfs_root')
    path = os.path.join(root, load['saltenv'], load['prefix'])
    return _recur_path(path, load['saltenv'], True)


def _recur_path(path, saltenv, only_dirs=False):
    '''
    Recurse through the remote directory structure
    '''
    root = __opts__.get('sftpfs_root')
    ret = []
    try:
        for entry in client.listdir_attr(path):
            full = os.path.join(path, entry.filename)
            if str(oct(entry.st_mode)).startswith('04'):
                ret.append(full)
                ret.extend(_recur_path(full, saltenv, only_dirs))
            else:
                if only_dirs is False:
                    ret.append(full)
        return ret
    except IOError:
        return []</pre></div><p class="calibre8">What is<a id="id227" class="calibre1"/> needed by these two functions is exactly the same, except for<a id="id228" class="calibre1"/> whether or not to include files. Because recursion is usually needed anyway, we've added a recursive function called <code class="email">_recur_path()</code> that can report either just directories or both files and directories. You may notice the check against <code class="email">entry.st_mode</code>. You may think of a Unix file mode as a set of permissions, which <a id="id229" class="calibre1"/>can be changed using the <code class="email">chmod</code> (<strong class="calibre2">ch</strong>ange <strong class="calibre2">mod</strong>e) command. However, the mode also stores which kind of file it is:</p><div><pre class="programlisting">0100755  # This is a file, with 0755 permissions
040755  # This is a directory, with 0755 permissions</pre></div><p class="calibre8">We could use another try/except block to see if we can descend into a directory. But it's a little less work to check the mode. If it starts with <code class="email">04</code>, then we know that it is a directory.</p><p class="calibre8">Each of these functions requires a <code class="email">load</code> argument. If you were to look inside, you would find a dictionary that looks like this:</p><div><pre class="programlisting">{'cmd': '_file_list', 'prefix': '', 'saltenv': 'base'}</pre></div><p class="calibre8">The <code class="email">cmd</code> field stores what kind of command was used. <code class="email">prefix</code> will contain the directory path, inside the environment, which contains any requested files, and <code class="email">saltenv</code> tells you the name of the requested environment itself. You will see this argument throughout the module, but it looks largely the same.</p><p class="calibre8">Let's go ahead and look at a couple of Salt commands:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-call --local cp.list_master</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    - testdir</strong>
<strong class="calibre2">    - testfile</strong>
<strong class="calibre2"># salt-call --local cp.list_master_dirs</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    - testdir</strong>
</pre></div><p class="calibre8">Keep in mind that <code class="email">--local</code> will tell <code class="email">salt-call</code> to pretend that it is its own Master. In that case, it <a id="id230" class="calibre1"/>will look to the <code class="email">minion</code> configuration file for the connection <a id="id231" class="calibre1"/>parameters.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec69" class="calibre1"/>find_file()</h2></div></div></div><p class="calibre8">Like <code class="email">file_list()</code> and <code class="email">dir_list()</code>, this function checks a requested path. It then reports <a id="id232" class="calibre1"/>whether or not the specified file exists:</p><div><pre class="programlisting">'''
def find_file(path, saltenv='base', **kwargs):
    '''
    Search the environment for the relative path
    '''
    fnd = {'path': '',
           'rel': ''}

    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', saltenv, path)

    if os.path.isfile(full) and not salt.fileserver.is_file_ignored(__opts__, full):
        fnd['path'] = full
        fnd['rel'] = path

    return fnd</pre></div><p class="calibre8">You may have noticed that no SFTP calls are being made in this function. That's because we're using a caching file server, and all that we need to check for right now is to see if the file has been cached. If it has, then Salt will just serve the file from the cache.</p><p class="calibre8">If you are writing a file server module that does not keep a local cache, then this function should check the remote endpoint to ensure that the file exists.</p><p class="calibre8">Speaking of the cache, one of the more important lines in this function is the one that defines the <code class="email">full</code> variable. This sets up the directory structure that is to be used for this caching file server. It makes use of <code class="email">salt.syspaths</code> to determine the correct directory for your platform; normally, this will be <code class="email">/var/cache/salt/</code>.</p><p class="calibre8">Note that a <code class="email">load</code> is not passed into this function, but <code class="email">saltenv</code> that would normally be in the <code class="email">load</code> is. Previous versions of Salt passed in <code class="email">saltenv</code> as just <code class="email">env</code>, and the <code class="email">**kwargs</code> functions as a catch-all to keep Python from choking on old implementations.</p><p class="calibre8">Once again, there is no way to test this function directly. It will be used by the <code class="email">update()</code> function later on in this section.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec70" class="calibre1"/>serve_file()</h2></div></div></div><p class="calibre8">Once <a id="id233" class="calibre1"/>a file has been found using <code class="email">find_file()</code>, its data is passed to this function in order to return the actual file contents:</p><div><pre class="programlisting">def serve_file(load, fnd):
    '''
    Return a chunk from a file based on the data received
    '''
    ret = {'data': '',
           'dest': ''}

    if 'path' not in load or 'loc' not in load or 'saltenv' not in load:
        return ret

    if not fnd['path']:
        return ret

    ret['dest'] = fnd['rel']
    gzip = load.get('gzip', None)

    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', fnd['path'])

    with salt.utils.fopen(fnd['path'], 'rb') as fp_:
        fp_.seek(load['loc'])
        data = fp_.read(__opts__['file_buffer_size'])
        if gzip and data:
            data = salt.utils.gzip_util.compress(data, gzip)
            ret['gzip'] = gzip
        ret['data'] = data
    return ret</pre></div><p class="calibre8">This function is used directly by Salt's own internal file server, which splits files into chunks before delivering them to Minions. If the <code class="email">gzip</code> flag is set to <code class="email">True</code> in the master configuration file, then each of these chunks will be individually compressed.</p><p class="calibre8">Since, in our case, this function is serving files from the cache, you can probably get away with using this function as it is printed here, except for the line that defines the <code class="email">full</code> variable. If you are not using a caching file server, then you will need to have a way to access and deliver each chunk of a file, as requested.</p><p class="calibre8">You can test this function using the <code class="email">cp.get_file</code> function. This function requires both a filename to download, and a full path to save the file locally:</p><div><pre class="programlisting">
<strong class="calibre2"># salt-call --local cp.get_file salt://testfile /tmp/testfile</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    /tmp/testfile</strong>
</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch08lvl2sec71" class="calibre1"/>update()</h2></div></div></div><p class="calibre8">At regular intervals, Salt will request that an external file server perform maintenance on itself. This<a id="id234" class="calibre1"/> function will compare the local file cache (if it is being used) with the remote endpoint, and update Salt with new information:</p><div><pre class="programlisting">def update():
    '''
    Update the cache, and reap old entries
    '''
    base_dir = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs')
    if not os.path.isdir(base_dir):
        os.makedirs(base_dir)

    try:
        salt.fileserver.reap_fileserver_cache_dir(
            os.path.join(base_dir, 'hash'),
            find_file
        )
    except (IOError, OSError):
        # Hash file won't exist if no files have yet been served up
        pass

    # Find out what the latest file is, so that we only update files more
    # recent than that, and not the entire filesystem
    if os.listdir(base_dir):
        all_files = []
        for root, subFolders, files in os.walk(base_dir):
            for fn_ in files:
                full_path = os.path.join(root, fn_)
                all_files.append([
                    os.path.getmtime(full_path),
                    full_path,
                ])

    # Pull in any files that have changed
    for env in envs():
        path = os.path.join(__opts__['sftpfs_root'], env)
        result = client.listdir_attr(path)
        for fileobj in result:
            file_name = os.path.join(base_dir, env, fileobj.filename)

            # Make sure the directory exists first
            comps = file_name.split('/')
            file_path = '/'.join(comps[:-1])
            if not os.path.exists(file_path):
                os.makedirs(file_path)

            if str(oct(fileobj.st_mode)).startswith('04'):
                # Create the directory
                if not os.path.exists(file_name):
                    os.makedirs(file_name)
            else:
                # Write out the file
                if fileobj.st_mtime &gt; all_files[file_name]:
                    client.get(os.path.join(path, fileobj.filename), file_name)
            os.utime(file_name, (fileobj.st_atime, fileobj.st_mtime))</pre></div><p class="calibre8">Whew! This<a id="id235" class="calibre1"/> is a long one! First, we define the cache directory, and if it is not there, then we create it. This is important for caching file servers. Then we ask Salt to clean up old entries, using the built-in <code class="email">salt.fileserver.reap_fileserver_cache_dir()</code> function. This passes in a reference to <code class="email">find_file()</code> to help with the work.</p><p class="calibre8">The next section walks through the remaining files to check their timestamps. Files will only be downloaded if they either have not yet been downloaded, or if there is a more recent copy on the remote SFTP server.</p><p class="calibre8">Finally, we loop through each environment to see which files have changed, and download them if necessary. Any directories that don't exist in the local cache will be created. And whether we create a file or a directory, we make sure to update its timestamp so that the cache matches what's on the server.</p><p class="calibre8">This function will be run periodically by the Salt Master, but you can force it to run by manually deleting a file from the local cache, and then requesting a copy:</p><div><pre class="programlisting">
<strong class="calibre2"># rm /var/cache/salt/sftpfs/base/testfile</strong>
<strong class="calibre2"># salt-call --local cp.get_file salt://testfile /tmp/testfile</strong>
<strong class="calibre2">local:</strong>
<strong class="calibre2">    /tmp/testfile</strong>
</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_7"><a id="ch08lvl2sec72" class="calibre1"/>file_hash()</h2></div></div></div><p class="calibre8">One of the ways that Salt knows that a file has been changed is by keeping track of the file's hash <a id="id236" class="calibre1"/>signature. If a hash changes, then Salt will know that it is time to serve a new copy of the file from the cache:</p><div><pre class="programlisting">def file_hash(load, fnd):
    '''
    Return a file hash, the hash type is set in the master config file
    '''
    path = fnd['path']
    ret = {}

    # if the file doesn't exist, we can't get a hash
    if not path or not os.path.isfile(path):
        return ret

    # set the hash_type as it is determined by config
    ret['hash_type'] = __opts__['hash_type']

    # Check if the hash is cached
    # Cache file's contents should be 'hash:mtime'
    cache_path = os.path.join(
        salt.syspaths.CACHE_DIR,
        'sftpfs',
        'hash',
        load['saltenv'],
        '{0}.hash.{1}'.format(
            fnd['rel'],
            ret['hash_type']
        )
    )

    # If we have a cache, serve that if the mtime hasn't changed
    if os.path.exists(cache_path):
        try:
            with salt.utils.fopen(cache_path, 'rb') as fp_:
                try:
                    hsum, mtime = fp_.read().split(':')
                except ValueError:
                    log.debug(
                        'Fileserver attempted to read incomplete cache file. Retrying.'
                    )
                    file_hash(load, fnd)
                    return ret
                if os.path.getmtime(path) == mtime:
                    # check if mtime changed
                    ret['hsum'] = hsum
                    return ret
        except os.error:
            # Can't use Python select() because we need Windows support
            log.debug(
                'Fileserver encountered lock when reading cache file. Retrying.'
            )
            file_hash(load, fnd)
            return ret

    # If we don't have a cache entry-- lets make one
    ret['hsum'] = salt.utils.get_hash(path, __opts__['hash_type'])
    cache_dir = os.path.dirname(cache_path)

    # Make cache directory if it doesn't exist
    if not os.path.exists(cache_dir):
        os.makedirs(cache_dir)

    # Save the cache object 'hash:mtime'
    if HAS_FCNTL:
        with salt.utils.flopen(cache_path, 'w') as fp_:
            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))
            fcntl.flock(fp_.fileno(), fcntl.LOCK_UN)
        return ret
    else:
        with salt.utils.fopen(cache_path, 'w') as fp_:
            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))
        return ret</pre></div><p class="calibre8">This is<a id="id237" class="calibre1"/> the longest function in our example, but thankfully it also needs the least amount of modification, for a caching file server. As with the other examples in this book, you can download a copy of this module from Packt Publishing's website. Once you have it downloaded, you will likely only need to change the value of <code class="email">cache_path</code>. However, we will go through this function briefly anyway.</p><p class="calibre8">After setting up a few basics, including the path of the file being hashed, check for the existence of said path, and define where in the cache to keep a copy of the hash. In our case, we've set up another directory structure inside the cache, mirroring the original, but with <code class="email">.hash.&lt;hash_type&gt;</code> appended to the filename. Resulting files will have names like this:</p><div><pre class="programlisting">/var/cache/salt/sftpfs/hash/base/testfile.hash.md5</pre></div><p class="calibre8">The next section checks to see if the hash file has been created, and if so, whether or not the timestamp matches the local copy. If the timestamp on the existing hash file is too old, then a new hash will be generated.</p><p class="calibre8">If we <a id="id238" class="calibre1"/>get past all of that, then we know it's time to generate a new hash. After determining the hash type to use and setting up a directory to put it in, we get to the section that actually writes the hash to disk. Remember the check for <code class="email">fcntl</code> at the beginning of the module? On a busy Salt Master, it's possible that multiple attempts may be made simultaneously to work on the same file. With <code class="email">fcntl</code> in place, we can lock that file before writing to it, to avoid corruption.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec46" class="calibre1"/>The final module</h1></div></div></div><p class="calibre8">With all <a id="id239" class="calibre1"/>of our functions in place, the final module will look like this:</p><div><pre class="programlisting">'''
The backend for serving files from an SFTP account.

To enable, add ``sftp`` to the :conf_master:`fileserver_backend` option in the
Master config file.

.. code-block:: yaml

    fileserver_backend:
      - sftp

Each environment is configured as a directory inside the SFTP account. The name
of the directory must match the name of the environment.

.. code-block:: yaml

    sftpfs_host: sftp.example.com
    sftpfs_port: 22
    sftpfs_username: larry
    sftpfs_password: 123pass
    sftpfs_root: /srv/sftp/salt/
'''
import os
import os.path
import logging
import time

try:
    import fcntl
    HAS_FCNTL = True
except ImportError:
    # fcntl is not available on windows
    HAS_FCNTL = False

import salt.fileserver
import salt.utils
import salt.syspaths

try:
    import paramiko
    from paramiko import AuthenticationException
    HAS_LIBS = True
except ImportError:
    HAS_LIBS = False

__virtualname__ = 'sftp'

log = logging.getLogger() 
transport = None
client = None


def __virtual__():
    '''
    Only load if proper conditions are met
    '''
    if __virtualname__ not in __opts__['fileserver_backend']:
        return False

    if not HAS_LIBS:
        return False

    if __opts__.get('sftpfs_root', None) is None:
        return False

    global client
    global transport

    host = __opts__.get('sftpfs_host')
    port = __opts__.get('sftpfs_port', 22)
    username = __opts__.get('sftpfs_username')
    password = __opts__.get('sftpfs_password')
    try:
        transport = paramiko.Transport((host, port))
        transport.connect(username=username, password=password)
        client = paramiko.SFTPClient.from_transport(transport)
    except AuthenticationException:
        return False

    return True


def envs():
    '''
    Treat each directory as an environment
    '''
    ret = []
    root = __opts__.get('sftpfs_root')
    for entry in client.listdir_attr(root):
        if str(oct(entry.st_mode)).startswith('04'):
            ret.append(entry.filename)
    return ret


def file_list(load):
    '''
    Return a list of all files on the file server in a specified environment
    '''
    root = __opts__.get('sftpfs_root')
    path = os.path.join(root, load['saltenv'], load['prefix'])
    return _recur_path(path, load['saltenv'])


def dir_list(load):
    '''
    Return a list of all directories on the master
    '''
    root = __opts__.get('sftpfs_root')
    path = os.path.join(root, load['saltenv'], load['prefix'])
    return _recur_path(path, load['saltenv'], True)


def _recur_path(path, saltenv, only_dirs=False):
    '''
    Recurse through the remote directory structure
    '''
    root = __opts__.get('sftpfs_root')
    ret = []
    try:
        for entry in client.listdir_attr(path):
            full = os.path.join(path, entry.filename)
            if str(oct(entry.st_mode)).startswith('04'):
                ret.append(full)
                ret.extend(_recur_path(full, saltenv, only_dirs))
            else:
                if only_dirs is False:
                    ret.append(full)
        return ret
    except IOError:
        return []


def find_file(path, saltenv='base', env=None, **kwargs):
    '''
    Search the environment for the relative path
    '''
    fnd = {'path': '',
           'rel': ''}

    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', saltenv, path)

    if os.path.isfile(full) and not salt.fileserver.is_file_ignored(__opts__, full):
        fnd['path'] = full
        fnd['rel'] = path

    return fnd


def serve_file(load, fnd):
    '''
    Return a chunk from a file based on the data received
    '''
    ret = {'data': '',
           'dest': ''}

    if 'path' not in load or 'loc' not in load or 'saltenv' not in load:
        return ret

    if not fnd['path']:
        return ret

    ret['dest'] = fnd['rel']
    gzip = load.get('gzip', None)

    full = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs', fnd['path'])

    with salt.utils.fopen(fnd['path'], 'rb') as fp_:
        fp_.seek(load['loc'])
        data = fp_.read(__opts__['file_buffer_size'])
        if gzip and data:
            data = salt.utils.gzip_util.compress(data, gzip)
            ret['gzip'] = gzip
        ret['data'] = data
    return ret


def update():
    '''
    Update the cache, and reap old entries
    '''
    base_dir = os.path.join(salt.syspaths.CACHE_DIR, 'sftpfs')
    if not os.path.isdir(base_dir):
        os.makedirs(base_dir)

    try:
        salt.fileserver.reap_fileserver_cache_dir(
            os.path.join(base_dir, 'hash'),
            find_file
        )
    except (IOError, OSError):
        # Hash file won't exist if no files have yet been served up
        pass

    # Find out what the latest file is, so that we only update files more
    # recent than that, and not the entire filesystem
    if os.listdir(base_dir):
        all_files = {}
        for root, subFolders, files in os.walk(base_dir):
            for fn_ in files:
                full_path = os.path.join(root, fn_)
                all_files[full_path] = os.path.getmtime(full_path)

    # Pull in any files that have changed
    for env in envs():
        path = os.path.join(__opts__['sftpfs_root'], env)
        result = client.listdir_attr(path)
        for fileobj in result:
            file_name = os.path.join(base_dir, env, fileobj.filename)

            # Make sure the directory exists first
            comps = file_name.split('/')
            file_path = '/'.join(comps[:-1])
            if not os.path.exists(file_path):
                os.makedirs(file_path)

            if str(oct(fileobj.st_mode)).startswith('04'):
                # Create the directory
                if not os.path.exists(file_name):
                    os.makedirs(file_name)
            else:
                # Write out the file
                if fileobj.st_mtime &gt; all_files[file_name]:
                    client.get(os.path.join(path, fileobj.filename), file_name)
            os.utime(file_name, (fileobj.st_atime, fileobj.st_mtime))


def file_hash(load, fnd):
    '''
    Return a file hash, the hash type is set in the master config file
    '''
    path = fnd['path']
    ret = {}

    # if the file doesn't exist, we can't get a hash
    if not path or not os.path.isfile(path):
        return ret

    # set the hash_type as it is determined by config
    # -- so mechanism won't change that
    ret['hash_type'] = __opts__['hash_type']

    # Check if the hash is cached
    # Cache file's contents should be 'hash:mtime'
    cache_path = os.path.join(
        salt.syspaths.CACHE_DIR,
        'sftpfs',
        'hash',
        load['saltenv'],
        '{0}.hash.{1}'.format(
            fnd['rel'],
            ret['hash_type']
        )
    )

    # If we have a cache, serve that if the mtime hasn't changed
    if os.path.exists(cache_path):
        try:
            with salt.utils.fopen(cache_path, 'rb') as fp_:
                try:
                    hsum, mtime = fp_.read().split(':')
                except ValueError:
                    log.debug(
                        'Fileserver attempted to read'
                        'incomplete cache file. Retrying.'
                    )
                    file_hash(load, fnd)
                    return ret
                if os.path.getmtime(path) == mtime:
                    # check if mtime changed
                    ret['hsum'] = hsum
                    return ret
        except os.error:
            # Can't use Python select() because we need Windows support
            log.debug(
                'Fileserver encountered lock when reading cache file. Retrying.'
            )
            file_hash(load, fnd)
            return ret

    # If we don't have a cache entry-- lets make one
    ret['hsum'] = salt.utils.get_hash(path, __opts__['hash_type'])
    cache_dir = os.path.dirname(cache_path)

    # Make cache directory if it doesn't exist
    if not os.path.exists(cache_dir):
        os.makedirs(cache_dir)

    # Save the cache object 'hash:mtime'
    if HAS_FCNTL:
        with salt.utils.flopen(cache_path, 'w') as fp_:
            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))
            fcntl.flock(fp_.fileno(), fcntl.LOCK_UN)
        return ret
    else:
        with salt.utils.fopen(cache_path, 'w') as fp_:
            fp_.write('{0}:{1}'.format(ret['hsum'], os.path.getmtime(path)))
        return ret</pre></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec47" class="calibre1"/>Troubleshooting file servers</h1></div></div></div><p class="calibre8">File server<a id="id240" class="calibre1"/> modules can be tricky to troubleshoot, because so many of the pieces need to be in place before others are usable. But there are some tricks that you can keep in mind.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec73" class="calibre1"/>Start small</h2></div></div></div><p class="calibre8">I've tried to present the functions that are necessary, in the order that is easiest for writing and troubleshooting. While <code class="email">envs()</code> cannot be called directly, it is easy to write, and can be debugged while working on <code class="email">file_list()</code> and <code class="email">dir_list()</code>. And those two functions are easy to troubleshoot using the <code class="email">cp.list_master</code> and <code class="email">cp.list_master_dirs</code> functions, respectively.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec74" class="calibre1"/>Test on a Minion</h2></div></div></div><p class="calibre8">While file server modules are designed to be used on the Master, it is possible to test them on a Minion. Be sure to define all of the appropriate configurations in the <code class="email">minion</code> configuration file instead of the <code class="email">master</code> file. Use <code class="email">salt-call --local</code> to issue commands, and regularly wipe both the local cache (in <code class="email">/var/salt/cache/</code>) and any files that were downloaded using <code class="email">cp.get_file</code>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec48" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">File server modules can be used to present resources on an external endpoint as if they were files sitting on the Master. The default file server module, called <code class="email">roots</code>, does in fact use local files on the Master. Many file server modules cache files locally on the Master, to avoid making too many calls to the external source, but this is not always appropriate.</p><p class="calibre8">There are a number of functions inside a file server module, which work in concert to present a file-server-like interface. Some of these functions cannot be tested directly, but they can still be tested in tandem with other functions that do have a direct external interface.</p><p class="calibre8">Despite all of the functions involved, file server modules are relatively easy to write. In the next chapter, we'll talk about cloud modules, which have even more required functions, but which are even easier to write.</p></div></body></html>