<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer086">
<h1 class="chapter-number" id="_idParaDest-68"><a id="_idTextAnchor068"/>4</h1>
<h1 id="_idParaDest-69"><a id="_idTextAnchor069"/>Building an IoT Information Display</h1>
<p>In this chapter, we will build an IoT information display using a Raspberry Pi-branded 7-inch touchscreen. We will use this information display to show real-time weather information and local <span class="No-Break">traffic information.</span></p>
<p>We will start the chapter by exploring screens compatible for use with our Raspberry Pi. We will look at small <strong class="bold">Organic Light-Emitting Diode</strong> (<strong class="bold">OLED</strong>) screens, dot-matrix displays, seven-segment<a id="_idIndexMarker322"/> displays, and small LCD monitors for the <span class="No-Break">Raspberry Pi.</span></p>
<p>For our project, we will build an IoT information display with Raspberry Pi’s 7-inch touchscreen. This <em class="italic">dashboard</em> will not only show weather details but will also feature a map depicting local <span class="No-Break">traffic conditions.</span></p>
<p>The insights gained in this chapter will equip us with a versatile toolkit, fostering creativity and innovation in future Raspberry Pi and <span class="No-Break">IoT projects.</span></p>
<p>The following are the topics we <span class="No-Break">will cover:</span></p>
<ul>
<li>Investigating displays compatible with our Raspberry Pi and exploring <span class="No-Break">screen types</span></li>
<li>Creating an IoT <span class="No-Break">information display</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-70"><a id="_idTextAnchor070"/>Technical requirements</h1>
<p>The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>A late-model Raspberry Pi, preferably a Raspberry Pi 5 with at least 4 GB <span class="No-Break">of RAM</span></li>
<li>A Raspberry Pi branded 7-inch touchscreen with a compatible <span class="No-Break">case (optional)</span></li>
</ul>
<p>The code for this chapter may be <span class="No-Break">found here:</span></p>
<p><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4%0D"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4</span></a></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor071"/>Investigating displays compatible with our Raspberry Pi and exploring screen types</h1>
<p>Raspberry Pi offers<a id="_idIndexMarker323"/> the flexibility to interface with various external<a id="_idIndexMarker324"/> screens, catering to different applications and requirements. In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>, we see examples of small screens that we may hook up to our <span class="No-Break">Raspberry Pi:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 4.1 – Small displays that may be used with the Raspberry Pi" height="487" src="image/B21282_04_1.jpg" width="1248"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Small displays that may be used with the Raspberry Pi</p>
<p><span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em> shows different small screens tailored for various uses: OLED screens (<em class="italic">B</em>, <em class="italic">C</em>, <em class="italic">D</em>) for fine detail; a 16 x 2 LCD (<em class="italic">F</em>) for concise text; and dot-matrix (<em class="italic">A</em>) and segment-style displays (<em class="italic">E</em>) for clear numbers and characters. These options offer a versatile range of <span class="No-Break">visual representations.</span></p>
<p>There are several larger screen options for the Raspberry Pi, including standard 4K computer monitors, as well as smaller monitor-style screens, as we see in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="Figure 4.2 – Encased Raspberry Pi’s 7-inch touchscreen (A) and 3.5-inch LCD screen (B)" height="451" src="image/B21282_04_2.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Encased Raspberry Pi’s 7-inch touchscreen (A) and 3.5-inch LCD screen (B)</p>
<p>The screen in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em> <em class="italic">A</em> is the Raspberry Pi<a id="_idIndexMarker325"/> branded 7-inch touchscreen. It is shown<a id="_idIndexMarker326"/> here in a case specifically designed to house it. In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em> <em class="italic">B</em>, we see a 3.5-inch LCD screen that connects to the GPIO port of the <span class="No-Break">Raspberry Pi.</span></p>
<p>Let’s take a closer look at each type of screen to understand their unique characteristics <span class="No-Break">and applications.</span></p>
<p>Each screen shown in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em> and <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em> offers unique advantages for specific applications, and understanding these can enhance our Raspberry Pi projects. The following are descriptions of <span class="No-Break">each screen/display:</span></p>
<ul>
<li><strong class="bold">Small OLED screens</strong>: OLED screens (see <em class="italic">B</em>, <em class="italic">C</em>, and <em class="italic">D</em> in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>) are known for their crisp<a id="_idIndexMarker327"/> detail and energy efficiency. Small OLED screens (0. to 1.3 inches) are commonly used in projects that require minimal space and low <span class="No-Break">power consumption.</span><p class="list-inset">OLED screens are used to display system status or in small gadgets such as fitness trackers. Ideal for showing limited information such as icons, temperature, or time, their compact size and energy efficiency make them a perfect choice for clear, concise displays without using much power <span class="No-Break">or space.</span></p></li>
<li><strong class="bold">16 x 2 LCD screens</strong>: 16 x 2 LCD screens (see <em class="italic">F</em> in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>) consist of 16 columns and 2 rows<a id="_idIndexMarker328"/> of characters. They offer a simple interface<a id="_idIndexMarker329"/> for text-based information and are ideal for applications where concise textual data needs to be displayed, such as in industrial settings where they may be used to present vital information such as error messages or production counts. Additionally, these screens are often found in 3D printers and are used to display control information to <span class="No-Break">the user.</span></li>
<li><strong class="bold">8 x 8 dot-matrix display</strong>: An 8 x 8 dot-matrix display (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>), consisting<a id="_idIndexMarker330"/> of 64 individual LEDs arranged<a id="_idIndexMarker331"/> in an 8x8 grid. This grid enables the creation of simple images, characters, or animations by controlling each LED independently. Large versions of these displays are frequently found in public information boards for scrolling text messages. Of note, this type of display is featured on the Raspberry Pi Sense HAT, a device we used in <em class="italic">Chapters 1</em> <span class="No-Break">and </span><span class="No-Break"><em class="italic">2</em></span><span class="No-Break">.</span></li>
<li><strong class="bold">7-segment display</strong>: A 7-segment display (see <em class="italic">E</em> in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>) consists<a id="_idIndexMarker332"/> of 7 or sometimes 8 individual<a id="_idIndexMarker333"/> segments (including a decimal point). This display can form the digit shapes for numbers and some letters by controlling which segments are illuminated. First invented in the early 20th century, 7-segment displays initially found use in devices such as calculators and digital clocks, and their application has since expanded with enhanced features such as improved brightness and energy efficiency, making them still relevant in modern digital clocks and <span class="No-Break">industrial counters.</span></li>
<li><strong class="bold">The Raspberry Pi 7-inch Touch Display</strong> (see <em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em>) is a versatile<a id="_idIndexMarker334"/> accessory<a id="_idIndexMarker335"/> for Raspberry Pi projects. This touchscreen<a id="_idIndexMarker336"/> seamlessly connects through the <strong class="bold">DSI</strong> (short for <strong class="bold">Digital Serial Interface</strong>) port, requiring no extra drivers for touch functionality, and has an 800 x <span class="No-Break">480-pixel resolution.</span></li>
<li><strong class="bold">3.5-inch</strong> LCD screens (see <em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em>) connect<a id="_idIndexMarker337"/> to the Raspberry Pi via the GPIO<a id="_idIndexMarker338"/> port. With a resolution of 320 x 480 pixels, this compact display offers solutions for handheld devices and IoT projects. These screens also come in 5-inch sizes, often connecting to the HDMI and <span class="No-Break">GPIO ports.</span></li>
</ul>
<p>Now that we understand the various screens we may use with the Raspberry Pi, it is time to focus on this chapter’s project: creating an IoT information display using the 7-inch Raspberry Pi touchscreen (see A in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor072"/>Creating an IoT information display</h1>
<p>As outlined at the beginning<a id="_idIndexMarker339"/> of this chapter, our IoT information display will display real-time weather forecasts and a <span class="No-Break">traffic map.</span></p>
<p>We will develop our IoT information display using the Raspberry Pi branded 7-inch touchscreen installed in a compatible case with a mouse and <span class="No-Break">keyboard connected:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 4.3 – Raspberry Pi development environment using a 7-inch touchscreen" height="686" src="image/B21282_04_3.jpg" width="1118"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Raspberry Pi development environment using a 7-inch touchscreen</p>
<p>The key benefit of the Raspberry Pi branded<a id="_idIndexMarker340"/> 7-inch screen is its connection to the <strong class="bold">MIPI </strong>(short for <strong class="bold">Mobile Industry Processor Interface</strong>) port on the Raspberry Pi 5 and not the GPIO or HDMI ports. This ensures seamless integration, eliminating the need to download and install additional drivers for touch functionality. We will not be using the touch feature for <span class="No-Break">this project.</span></p>
<p class="callout-heading">Using our standard monitor</p>
<p class="callout">While the Raspberry Pi-branded 7-inch monitor<a id="_idIndexMarker341"/> offers impressive features, it is not essential for creating our IoT information display. We can utilize a standard monitor already connected to our Raspberry Pi. However, using a standard monitor may result in a large border around the display, as the positions of components in our code will <span class="No-Break">be hardcoded.</span></p>
<p><span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.4</em> outlines the software architecture<a id="_idIndexMarker342"/> we will follow to create our IoT <span class="No-Break">information display:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 4.4 – Software architecture for the IoT information display" height="438" src="image/B21282_04_4.jpg" width="1146"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Software architecture for the IoT information display</p>
<p>We will use the <strong class="source-inline">WeatherData</strong> class to pull weather information from the <span class="No-Break"><strong class="source-inline">OpenWeatherMap</strong></span><span class="No-Break"> API.</span></p>
<p>The <strong class="source-inline">Dashboard</strong> class centralizes display information<a id="_idIndexMarker343"/> for our application, and we will leverage the <strong class="bold">Kivy</strong> library to create the GUI. By displaying our GUI in fullscreen mode, we create a <span class="No-Break">kiosk-like effect.</span></p>
<p>Just as we use the <strong class="source-inline">WeatherData</strong> class to make calls to the <strong class="source-inline">OpenWeatherMap</strong> API, we use the <strong class="source-inline">TrafficMap</strong> class to call the MapQuest Traffic API for traffic data. Unlike the <strong class="source-inline">WeatherData</strong> class, the <strong class="source-inline">TrafficMap</strong> class generates an image file representing traffic conditions using GPS coordinates. This visual depiction of traffic not only adds value to the information<a id="_idIndexMarker344"/> being presented but also serves as the focal point of our IoT <span class="No-Break">information display.</span></p>
<p>We will start our coding by setting up our <span class="No-Break">development environment.</span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor073"/>Setting up our development environment</h2>
<p>We will use a Python virtual environment<a id="_idIndexMarker345"/> for our development. As there are libraries that only work with the root installation of Python, we will use system packages in our Python virtual environment. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>On our Raspberry Pi 5, we open a <span class="No-Break">Terminal application.</span></li>
<li>To store our project files, we create a new directory with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">mkdir chapter4</strong></pre></li> <li>We then navigate to the new directory with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">cd chapter4</strong></pre></li> <li>We require a subfolder for our project. We create this folder with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">mkdir IoTInformationDisplay</strong></pre></li> <li>We create a new Python virtual environment for our project with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">python -m venv ch4-env --system-site-packages</strong></pre></li> <li>With this command, we create a new Python virtual environment called <strong class="source-inline">ch4-env</strong> and enable access to the system site packages. This allows the virtual environment to inherit packages from the global Python environment, which can be useful when certain libraries are installed system wide. Once the environment is set up, we can activate it and begin installing project-specific packages without affecting the global <span class="No-Break">Python environment.</span></li>
<li>With our new Python virtual environment created, we source into it with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ch4-env/bin/activate</strong></pre></li> <li>Our Terminal application should now show that we are using the <strong class="source-inline">ch4-env</strong> Python <span class="No-Break">virtual environment:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 4.5 – Terminal using dashboard-env environment" height="264" src="image/B21282_04_5.jpg" width="1030"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Terminal using dashboard-env environment</p>
<ol>
<li value="9">We install the Python packages required for our code with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">pip install requests kivy</strong></pre></li> <li> <strong class="source-inline">requests</strong> is a Python library<a id="_idIndexMarker346"/> simplifying HTTP requests, ideal for web service interactions. Kivy enables the development of multitouch, cross-platform applications with a focus on rich user interfaces. With the Python packages installed, we may close the Terminal with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">exit</strong></pre></li> <li>We are now ready to load up Thonny. We do so by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating to the <strong class="bold">Programming</strong> category, and <span class="No-Break">selecting </span><span class="No-Break"><strong class="bold">Thonny</strong></span><span class="No-Break">.</span></li>
<li>By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our project, we will use the Python virtual environment we just created. To start, we need to view the project files by clicking on <strong class="bold">View</strong> and selecting <strong class="bold">Files</strong> if it is not <span class="No-Break">already selected.</span></li>
<li>In the <strong class="source-inline">Files</strong> section, we locate the <span class="No-Break"><strong class="source-inline">ch4-env</strong></span><span class="No-Break"> directory.</span></li>
<li>We then right-click on the folder<a id="_idIndexMarker347"/> and select the <strong class="bold">Activate virtual </strong><span class="No-Break"><strong class="bold">environment</strong></span><span class="No-Break"> option:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 4.6 – Activating a Python virtual environment in Thonny" height="497" src="image/B21282_04_6.jpg" width="320"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Activating a Python virtual environment in Thonny</p>
<p>With our project folder created, our Python virtual environment<a id="_idIndexMarker348"/> set up and activated, and the packages we need for our project installed, we may now start <span class="No-Break">writing code.</span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor074"/>Creating a WeatherData class</h2>
<p>We use a <strong class="source-inline">WeatherData</strong> class<a id="_idIndexMarker349"/> to encapsulate<a id="_idIndexMarker350"/> calls to the <strong class="source-inline">OpenWeatherMap</strong> API. In addition to temperature and weather conditions, the weather portion of our IoT information display shows a weather conditions icon as well as an attire image. In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.7</em>, we see images used <span class="No-Break">for attire:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 4.7 – Attire images used in our IoT information display" height="262" src="image/B21282_04_7.jpg" width="985"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Attire images used in our IoT information display</p>
<p>The attire images should look familiar to us as we used the same ones when we created our weather indicator in <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. With our IoT information display these graphics will be presented based on a factor determined by a calculation of temperature and <span class="No-Break">wind speed.</span></p>
<p>In this section, we’ll cover the <strong class="source-inline">WeatherData</strong> <span class="No-Break">class code.</span></p>
<p>So, let’s <span class="No-Break">get started:</span></p>
<ol>
<li>In Thonny, we create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">the keyboard.</span></li>
<li>In our code, we start by entering <span class="No-Break">our imports:</span><pre class="source-code">
import requests
import json</pre></li> <li>We then define our class name, <strong class="source-inline">WeatherData</strong>, and our <span class="No-Break">class variables:</span><pre class="source-code">
class WeatherData:
    temperature = 0
    weather_conditions = ''
    wind_speed = 0
    city = ''</pre></li> <li>From here, we define<a id="_idIndexMarker351"/> our <span class="No-Break">initialization</span><span class="No-Break"><a id="_idIndexMarker352"/></span><span class="No-Break"> method:</span><pre class="source-code">
    def __init__(self, city):
        self.city = city
        api_key = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
        base_url = "http://api.openweathermap.org/data/2.5/weather"
         complete_url = f"{base_url}?q={self.city}&amp;appid={api_key}&amp;units=metric"
        response = requests.get(complete_url)
        data = response.json()
        if data["cod"] != "404":
            main = data["main"]
            wind = data["wind"]
            weather = data["weather"]
            self.temperature = main["temp"]
            self.weather_conditions = weather[0][" main"]
            self.wind_speed = wind["speed"]
            self.icon = weather[0]["icon"]</pre></li> <li>We then<a id="_idIndexMarker353"/> define<a id="_idIndexMarker354"/> the <strong class="source-inline">get_temperature()</strong> and <span class="No-Break"><strong class="source-inline">get_conditions()</strong></span><span class="No-Break"> methods:</span><pre class="source-code">
    def get_conditions(self):
        return self.weather_conditions
    def get_temperature(self):
        return str(int(self.temperature))</pre></li> <li>To accommodate the addition of a weather conditions icon, we add a method <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">get_weather_conditions_icon()</strong></span><span class="No-Break">:</span><pre class="source-code">
    def get_weather_conditions_icon(self):
        return f"http://openweathermap.org/img/wn/{self.icon}.png"</pre><p class="list-inset">This method constructs and returns a URL using an f-string, a feature in Python that allows for embedded expressions inside string literals. By appending the value of <strong class="source-inline">self.icon</strong> to the base URL from OpenWeatherMap, (<strong class="source-inline">f"http://openweathermap.org/img/wn/{self.icon}.png"</strong>), it forms a complete URL that leads to a PNG image representing the current weather conditions, such as sunny, cloudy, or rainy. This will allow us to embed an icon representing the current weather conditions into our IoT <span class="No-Break">information display.</span></p></li> <li>To determine the attire image<a id="_idIndexMarker355"/> to display, we require two additional methods. The first method uses wind speed and temperature to return a factor appropriately <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">wind_temp_factor</strong></span><span class="No-Break">:</span><pre class="source-code">
    def get_wind_temp_factor(self):
        if self.temperature &lt; 0:
            temp_factor = 0
        elif self.temperature &gt; 30:
            temp_factor = 30
        else:
            temp_factor = self.temperature
        wind_factor = self.wind_speed / 20
        wind_temp_factor = temp_factor - wind_factor
        return wind_temp_factor</pre><p class="list-inset">This method calculates a wind temperature factor by first constraining the <strong class="source-inline">self.temperature</strong> value between <strong class="source-inline">0</strong> and <strong class="source-inline">30</strong> (assigning it to <strong class="source-inline">temp_factor</strong>), then dividing the wind speed by <strong class="source-inline">20</strong> (assigning it to <strong class="source-inline">wind_factor</strong>), and finally subtracting <strong class="source-inline">wind_factor</strong> from <strong class="source-inline">temp_factor</strong>, returning the resulting value as <strong class="source-inline">wind_temp_factor</strong>. These values are all arbitrary and may <span class="No-Break">be changed.</span></p></li> <li>The final method in our <strong class="source-inline">WeatherData</strong> class returns<a id="_idIndexMarker356"/> the image path<a id="_idIndexMarker357"/> for the attire image based <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">wind_temp_factor</strong></span><span class="No-Break">:</span><pre class="source-code">
    def get_attire_image(self):
        factor = self.get_wind_temp_factor()
        if factor &lt; 8:
            return "images/gloves.png"
        elif factor &lt; 18:
            return "images/long-shirt.png"
        elif factor &lt; 25:
            return "images/short-shirt.png"
        else:
            return "images/shorts.png"</pre></li> <li>The final part of our code sits outside the <strong class="source-inline">WeatherMap</strong> class and allows us to test <span class="No-Break">the class:</span><pre class="source-code">
if __name__=="__main__":
    weather = WeatherData('Toronto')
    print(weather.get_temperature())
    print(weather.get_attire_image())
    print(weather.get_conditions())
    print(weather.get_weather_conditions_icon())</pre><p class="list-inset">This snippet creates an instance of the <strong class="source-inline">WeatherData</strong> class for Toronto and then prints various weather-related information to <span class="No-Break">our console.</span></p></li> <li>We save our code as <strong class="source-inline">WeatherData.py</strong> inside the <strong class="source-inline">IoTInformationDisplay</strong> <span class="No-Break">project subfolder.</span></li>
</ol>
<p>We are now prepared <a id="_idIndexMarker358"/>to construct a <strong class="source-inline">TrafficMap</strong> class, which<a id="_idIndexMarker359"/> will encapsulate the code used to create a map of <span class="No-Break">local traffic.</span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor075"/>Creating a TrafficMap class</h2>
<p>We utilize a <strong class="source-inline">TrafficMap</strong> class to interface<a id="_idIndexMarker360"/> with the MapQuest API, enabling<a id="_idIndexMarker361"/> the generation of a traffic map for our application. To make the connection to the MapQuest API, we must first create an account and generate an <span class="No-Break">API key.</span></p>
<h3>Generating an API key for our application</h3>
<p>MapQuest Developer<a id="_idIndexMarker362"/> offers various tools and services<a id="_idIndexMarker363"/> that enable developers to access maps, routing information, and more. For our project, we will need to obtain an API key from MapQuest to access their web services, particularly traffic map data. Here’s how to set up a free account and get the <span class="No-Break">API key:</span></p>
<ol>
<li>We start by navigating<a id="_idIndexMarker364"/> to the MapQuest Developer site (<a href="https://developer.mapquest.com/plans">https://developer.mapquest.com/plans</a>) to access the <span class="No-Break">developer’s portal.</span></li>
<li>For our application, the <strong class="bold">MapQuestGo</strong> plan will be sufficient. This plan will give us 15,000 starter transactions. To create a plan, we click on the <strong class="bold">Subscribe</strong> button and follow the <span class="No-Break">steps outlined.</span></li>
<li>Once our profile is created, we may generate<a id="_idIndexMarker365"/> a new API key by going to the following <span class="No-Break">URL: </span><a href="https://developer.mapquest.com/user/me/apps"><span class="No-Break">https://developer.mapquest.com/user/me/apps</span></a><span class="No-Break">.</span></li>
<li>We click on the <strong class="bold">Create a New Key</strong> button and enter an <span class="No-Break">app name:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer083">
<img alt="Figure 4.8 – Creating a new API key in MapQuest Developer" height="230" src="image/B21282_04_8.jpg" width="948"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Creating a new API key in MapQuest Developer</p>
<ol>
<li value="5">A new API key will be generated, and it can be viewed under the <strong class="bold">Managed </strong><span class="No-Break"><strong class="bold">Keys</strong></span><span class="No-Break"> section:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 4.9 – Viewing API keys in MaqQuest Developer" height="235" src="image/B21282_04_9.jpg" width="842"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Viewing API keys in MaqQuest Developer</p>
<p>We will be using this key to call the MapQuest Traffic API. It is a good idea to copy and paste the API key into a text document that can be accessed later. With the API key<a id="_idIndexMarker366"/> generated, we may now create<a id="_idIndexMarker367"/> our <span class="No-Break"><strong class="source-inline">TrafficMap</strong></span><span class="No-Break"> class.</span></p>
<h3>Coding the TrafficMap class</h3>
<p>We use Thonny<a id="_idIndexMarker368"/> to code our <span class="No-Break"><strong class="source-inline">TrafficMap</strong></span><span class="No-Break"> class:</span></p>
<ol>
<li>We launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar. Then, we navigate to the <strong class="bold">Programming</strong> category and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Thonny</strong></span><span class="No-Break">.</span></li>
<li>Once inside Thonny, we activate the <strong class="source-inline">ch4-env</strong> <span class="No-Break">virtual environment.</span></li>
<li>We create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">the keyboard.</span></li>
<li>In our code, we start by entering <span class="No-Break">our imports:</span><pre class="source-code">
import requests</pre></li> <li>For our <strong class="source-inline">TrafficMap</strong> class, we only need to import the <strong class="source-inline">requests</strong> package. We define our class name, <strong class="source-inline">TrafficMap</strong>, and our <span class="No-Break">initialization method:</span><pre class="source-code">
class TrafficMap:
    def __init__(self, latitude, longitude, zoom):
        self.latitude = latitude
        self.longitude = longitude
        self.zoom = zoom
        self.size = "500,325"
        self.api_key = "xxxxxxxxxxxxxxxxxxxxxxxxxxxx"</pre><p class="list-inset">Let’s look at what<a id="_idIndexMarker369"/> we <span class="No-Break">just added:</span></p><ul><li><strong class="source-inline">self.latitude</strong>: Specifies the latitude of the location on the map, used to center the map at <span class="No-Break">that latitude.</span></li><li><strong class="source-inline">self.longitude</strong>: Specifies the longitude of the location on the map, used to center the map at <span class="No-Break">that longitude.</span></li><li><strong class="source-inline">self.zoom</strong>: Sets the zoom level for the map, controlling how much of the map is visible (for example, higher values might show a closer, more <span class="No-Break">detailed view).</span></li><li><strong class="source-inline">self.size</strong>: Sets a fixed size for the map, defining the width and height in pixels. The size is set as a string with dimensions <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">"500,325"</strong></span><span class="No-Break">.</span></li><li><strong class="source-inline">self.api_key</strong>: Stores a hardcoded API key, which is required to authenticate requests to <span class="No-Break">the API.</span></li></ul></li> <li>At the heart of our <strong class="source-inline">TrafficMap</strong> class is the <strong class="source-inline">get_traffic_map()</strong> method. We use this method to make the call to the MapQuest Traffic web service and use the response to create our <span class="No-Break">traffic map:</span><pre class="source-code">
def get_traffic_map(self):
        base_url = "http://www.mapquestapi.com\
                    /staticmap/v5/map"
        params = {
            'key': self.api_key,
            'center': f"{self.latitude},
                        {self.longitude}",
            'zoom': self.zoom,
            'size': self.size,
            'traffic': 'flow|cons|inc'
        }
        response = requests.get(base_url,
                                params=params)
        if response.status_code == 200:
            with open('images/traffic_map.png', 'wb') as f:
                f.write(response.content)
            return "images/traffic_map.png"
        else:
            return "images/error.png"</pre><p class="list-inset">Let’s look at what we <span class="No-Break">just added:</span></p><ul><li><strong class="source-inline">base_url</strong>: The URL endpoint<a id="_idIndexMarker370"/> for the MapQuest static <span class="No-Break">map API.</span></li><li><strong class="source-inline">params</strong>: We use this dictionary containing the necessary parameters for the <span class="No-Break">API request:</span><ul><li><strong class="source-inline">self.api_key</strong>: Specifies the API key for authentication with the MapQuest static <span class="No-Break">map API</span></li><li><strong class="source-inline">center</strong> – <strong class="source-inline">f"{self.latitude},{self.longitude}"</strong>: Defines the center of the map using the <strong class="source-inline">latitude</strong> and <strong class="source-inline">longitude</strong> attributes of <span class="No-Break">the object</span></li><li><strong class="source-inline">self.zoom</strong>: Specifies the zoom level for the map, controlling the scale or detail visible on <span class="No-Break">the map</span></li><li><strong class="source-inline">self.size</strong>: Sets the size of the map, using the previously defined size attribute of the object, likely defining the width and height <span class="No-Break">in pixels</span></li><li><strong class="source-inline">traffic: 'flow|cons|inc'</strong>: Specifies the traffic information to be included on the map, representing different types of traffic data such as flow, congestion, <span class="No-Break">and incidents</span></li></ul></li><li><strong class="source-inline">response = requests.get(base_url, params=params)</strong>: Sends a <strong class="source-inline">GET</strong> request to the URL stored in <strong class="source-inline">base_url</strong> with the parameters defined in <strong class="source-inline">params</strong> and stores the response in the <span class="No-Break"><strong class="source-inline">response</strong></span><span class="No-Break"> variable.</span></li><li>If the request<a id="_idIndexMarker371"/> is successful (<strong class="source-inline">response.status_code == 200</strong>), the <span class="No-Break">following happens:</span><ul><li>An image file (<strong class="source-inline">traffic_map.png</strong>) is created or overwritten in the <span class="No-Break"><strong class="source-inline">images</strong></span><span class="No-Break"> directory.</span></li><li>The content of the response (which is image data) is written to <span class="No-Break">the file.</span></li><li>The method returns the path to the saved <span class="No-Break">image: </span><span class="No-Break"><strong class="source-inline">"images/traffic_map.png"</strong></span></li></ul></li><li>If the request is not successful, the method returns the path to a predefined <strong class="source-inline">error.png</strong> image in the <strong class="source-inline">images</strong> directory. This image contains an <strong class="source-inline">Error loading traffic </strong><span class="No-Break"><strong class="source-inline">map</strong></span><span class="No-Break"> message.</span></li></ul></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">The main takeaway from this method is that, unlike many API responses that require a JSON library to parse, the response from the <strong class="source-inline">GET</strong> request to the MapQuest Traffic API directly contains image data for the traffic map, so it can be saved as an image file without needing to <span class="No-Break">parse JSON.</span></p>
<ol>
<li value="7">We save our code as <strong class="source-inline">TrafficMap.py</strong> inside the <strong class="source-inline">IoTWeatherDisplay</strong> <span class="No-Break">project subfolder.</span></li>
</ol>
<p>With the creation<a id="_idIndexMarker372"/> of the <strong class="source-inline">WeatherData</strong> and <strong class="source-inline">TrafficMap</strong> classes complete, we can now proceed to write a <strong class="source-inline">Dashboard</strong> class that will handle the display of information retrieved from these <span class="No-Break">web services.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor076"/>Adding Dashboard and MyApp classes</h2>
<p>For the <strong class="source-inline">Dashboard</strong> class, we use<a id="_idIndexMarker373"/> the Kivy library. Kivy<a id="_idIndexMarker374"/> is an open source Python framework<a id="_idIndexMarker375"/> designed for developing multitouch applications<a id="_idIndexMarker376"/> that can run on various platforms, including Windows, macOS, Linux, iOS, <span class="No-Break">and Android.</span></p>
<p>In the same Python file where we define the Dashboard class, we will add a Kivy App class we call MyApp. The MyApp class in this code is a subclass of Kivy’s App class, defining the main entry point for the application by creating an instance of the Dashboard class in its <span class="No-Break">build() method.</span></p>
<p>To do this, we do <span class="No-Break">the following:</span></p>
<ol>
<li>We launch Thonny by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar. Then, we navigate to the <strong class="bold">Programming</strong> category and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Thonny</strong></span><span class="No-Break">.</span></li>
<li>Once inside Thonny, we activate the <strong class="source-inline">ch4-env</strong> <span class="No-Break">virtual environment.</span></li>
<li>We create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">the keyboard.</span></li>
<li>We start our code by configuring Kivy to run in fullscreen and <span class="No-Break">borderless mode:</span><pre class="source-code">
from kivy.config import Config
Config.set('graphics', 'fullscreen', 'auto')
Config.set('graphics', 'borderless', '1')</pre></li> </ol>
<p class="callout-heading">Why do we configure our Kivy application before adding other imports?</p>
<p class="callout">We configure our application before importing other packages in Kivy to ensure that the settings are applied at the beginning of the application’s life cycle. If configuration were done after importing the packages, some settings might not be applied or could lead to unexpected behavior, as Kivy components might be initialized with the default configurations before the custom settings <span class="No-Break">are set.</span></p>
<ol>
<li value="5">After configuration, we import<a id="_idIndexMarker377"/> the other<a id="_idIndexMarker378"/> packages we require<a id="_idIndexMarker379"/> for <span class="No-Break">our</span><span class="No-Break"><a id="_idIndexMarker380"/></span><span class="No-Break"> application:</span><pre class="source-code">
from kivy.app import App
from kivy.uix.floatlayout import FloatLayout
from kivy.uix.label import Label
from kivy.uix.image import Image, AsyncImage
from kivy.clock import Clock
from WeatherData import WeatherData
from TrafficMap import TrafficMap</pre><p class="list-inset">Let’s look at what we <span class="No-Break">just added:</span></p><ul><li><strong class="source-inline">from kivy.app import App</strong>: Imports the main application class from the Kivy framework, which is necessary for building and running <span class="No-Break">the app.</span></li><li><strong class="source-inline">from kivy.uix.floatlayout import FloatLayout</strong>: Imports the <strong class="source-inline">FloatLayout</strong> class from Kivy, which allows for positioning and resizing of widgets in a free-form manner. We do this so that we may position our GUI components in exact locations on <span class="No-Break">our screen.</span></li><li><strong class="source-inline">from kivy.uix.label import Label</strong>: Imports the <strong class="source-inline">Label</strong> class from Kivy, which is used to display text on <span class="No-Break">the screen.</span></li><li><strong class="source-inline">from kivy.uix.image import Image, AsyncImage</strong>: Imports the <strong class="source-inline">Image</strong> and <strong class="source-inline">AsyncImage</strong> classes from Kivy, allowing for the display of both static and asynchronous images within <span class="No-Break">the application.</span></li><li><strong class="source-inline">from kivy.clock import Clock</strong>: Imports the <strong class="source-inline">Clock</strong> class from Kivy, enabling the scheduling of periodic functions within the app. We will be using this class to update our dashboard every <span class="No-Break">30 minutes.</span></li><li><strong class="source-inline">from WeatherData import WeatherData</strong>: Imports our custom <strong class="source-inline">WeatherData</strong> class, which is used to handle <span class="No-Break">weather-related information.</span></li><li><strong class="source-inline">from TrafficMap import TrafficMap</strong>: Imports the custom <strong class="source-inline">TrafficMap</strong> class, used to manage traffic map data <span class="No-Break">and images.</span></li></ul></li> <li>After our<a id="_idIndexMarker381"/> imports, we define<a id="_idIndexMarker382"/> our <strong class="source-inline">Dashboard</strong> class<a id="_idIndexMarker383"/> and its <span class="No-Break">initialization</span><span class="No-Break"><a id="_idIndexMarker384"/></span><span class="No-Break"> method:</span><pre class="source-code">
class Dashboard(FloatLayout):
    def __init__(self,
                 city,
                 latitude,
                 longitude,
                 zoom):
        super(Dashboard, self).__init__()
        self.city = city
        self.traffic_map = TrafficMap(latitude,
                                      longitude,
                                      zoom)
        self.init_widgets()
        Clock.schedule_interval(self.update_status, 1800)
        self.update_status(0)</pre><p class="list-inset">Let’s look at what we <span class="No-Break">just added:</span></p><ol><li class="upper-roman">Our <strong class="source-inline">Dashboard</strong> class inherits from Kivy’s <strong class="source-inline">FloatLayout</strong> class, allowing positioning and <span class="No-Break">layout features.</span></li><li class="upper-roman">We initialize our class with specific parameters (<strong class="source-inline">city</strong>, <strong class="source-inline">latitude</strong>, <strong class="source-inline">longitude</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">zoom</strong></span><span class="No-Break">).</span></li><li class="upper-roman">We call the <strong class="source-inline">__init__()</strong> method of the <strong class="source-inline">FloatLayout</strong> superclass through <strong class="source-inline">super(Dashboard, self).__init__()</strong>, ensuring proper initialization and inheriting behaviors from the <span class="No-Break">parent class.</span></li><li class="upper-roman">We then set up the traffic map with the given <strong class="source-inline">latitude</strong>, <strong class="source-inline">longitude</strong>, and <span class="No-Break"><strong class="source-inline">zoom</strong></span><span class="No-Break"> parameters.</span></li><li class="upper-roman">We utilize Kivy’s <strong class="source-inline">Clock</strong> class to schedule regular updates every <strong class="source-inline">1800</strong> seconds (<span class="No-Break"><strong class="source-inline">30</strong></span><span class="No-Break"> minutes).</span></li><li class="upper-roman">We call the <strong class="source-inline">self.init_widgets()</strong> method to create and position widgets inside <span class="No-Break">the layout.</span></li><li class="upper-roman">We then call <strong class="source-inline">self.update_status(0)</strong> once during initialization to set the initial state of the dashboard. If this method was not called, the initial state of the dashboard might not be set, possibly leading to a delay in displaying the initial content until the scheduled update occurs, which is set to happen every <strong class="source-inline">1800</strong> seconds or <span class="No-Break"><strong class="source-inline">30</strong></span><span class="No-Break"> minutes.</span></li></ol></li> <li>With the initialization<a id="_idIndexMarker385"/> of the class in place, we initialize<a id="_idIndexMarker386"/> the state<a id="_idIndexMarker387"/> of the widgets. We start<a id="_idIndexMarker388"/> with the <strong class="source-inline">Temperature</strong>, <strong class="source-inline">Conditions</strong>, and <span class="No-Break"><strong class="source-inline">Attire</strong></span><span class="No-Break"> widgets:</span><pre class="source-code">
def init_widgets(self):
        self.add_widget(Label(text="Temperature",
                              pos=(-275, 175),
                              color=(1, 1, 1, 1),
                              font_size=22,
                              font_name='fonts/
                              ArialBlack.ttf'))
        self.add_widget(Label(
                         text="Conditions",
                         pos=(-275, 60),
                         color=(1, 1, 1, 1),
                         font_size=22,
                         font_name='fonts/
                         ArialBlack.ttf'))
        self.add_widget(Label(text="Attire",
                         pos=(-280, -80),
                         color=(1, 1, 1, 1),
                         font_size=22,
                         font_name='fonts/
                         ArialBlack.ttf'))
        self.add_widget(Image(source='images/box.png',
                              pos=(-275, 145)))
        self.add_widget(Image(source='images/box.png',
                              pos=(-275, 10)))
        self.add_widget(Image(source='images/box.png',
                              pos=(-275, -127)))</pre></li> <li>We then add<a id="_idIndexMarker389"/> a <strong class="source-inline">city</strong> field, weather<a id="_idIndexMarker390"/> conditions, and<a id="_idIndexMarker391"/> a <span class="No-Break">traffic</span><span class="No-Break"><a id="_idIndexMarker392"/></span><span class="No-Break"> map:</span><pre class="source-code">
self.city_label = Label(text=self.city,
                                pos=(250, 185),
                                color=(1, 1, 1, 1),
                                font_size=30,
                                font_name='fonts/
                                ArialBlack.ttf')
        self.add_widget(self.city_label)
        self.temperature_label = Label(pos=(-275,
                                            125),
                                 color=(1, 1, 1, 1),
                                 font_size=40,
                                 font_name='fonts/
                                 ArialBlack.ttf')
        self.add_widget(self.temperature_label)
        self.conditions_image = AsyncImage(pos=(-278,
                                                20))
        self.add_widget(self.conditions_image)
        self.weather_conditions_label = Label(
                                        pos=(-280,
                                             -25),
                                        color=(1, 1,
                                               1, 1),
                                        font_size=20,
                                     font_name='fonts/
                                     ArialBlack.ttf')
        self.add_widget(self.weather_conditions_label)
        self.traffic_map_image = AsyncImage(pos=(120,
                                                -30))
        self.add_widget(self.traffic_map_image)
        self.attire_image = Image(pos=(-280, -140))
        self.add_widget(self.attire_image)</pre><p class="list-inset">The <strong class="source-inline">init_widgets()</strong> method<a id="_idIndexMarker393"/> is responsible for initializing<a id="_idIndexMarker394"/> and adding both static<a id="_idIndexMarker395"/> and dynamic widgets<a id="_idIndexMarker396"/> to the <strong class="source-inline">Dashboard</strong> layout, which is a subclass of Kivy’s <span class="No-Break"><strong class="source-inline">FloatLayout</strong></span><span class="No-Break"> class.</span></p></li> </ol>
<p class="callout-heading">Important note</p>
<p class="callout">Static widgets are components<a id="_idIndexMarker397"/> that remain the same throughout the life cycle of the application and don’t need to be updated dynamically. This includes adding labels displaying Temperature, Conditions, and Attire text at specified positions with specific colors, font sizes, and fonts. It also includes three image widgets displaying an image located at ‘images/box.png’, placed at different positions on <span class="No-Break">the layout.</span></p>
<p class="callout"><strong class="bold">Dynamic widgets</strong> are components that may need<a id="_idIndexMarker398"/> to be updated as the application runs, such as to display new data. This includes creating and adding a label that displays the city name (which could be made dynamic if you want to change the city later), a label for displaying the current temperature, an <strong class="source-inline">AsyncImage</strong> widget to display a weather conditions icon, a label for displaying weather conditions text, another <strong class="source-inline">AsyncImage</strong> widget to display a traffic map, and an image<a id="_idIndexMarker399"/> widget to display appropriate attire for the current <span class="No-Break">weather conditions.</span></p>
<p class="list-inset">The <strong class="source-inline">init_widgets()</strong> method leverages the <strong class="source-inline">add_widget()</strong> method provided by Kivy’s <strong class="source-inline">FloatLayout</strong> classto add each widget to the layout. The dynamic widgets are also stored as attributes of the <strong class="source-inline">Dashboard</strong> class so that they can be easily accessed and <span class="No-Break">updated later.</span></p>
<ol>
<li value="9">We use the <strong class="source-inline">update_status()</strong> method<a id="_idIndexMarker400"/> of the <strong class="source-inline">Dashboard</strong> class to provide<a id="_idIndexMarker401"/> new values<a id="_idIndexMarker402"/> for our screen <a id="_idIndexMarker403"/>every <strong class="source-inline">30</strong> minutes (as set in the <span class="No-Break">initialization method):</span><pre class="source-code">
    def update_status(self, *args):
        weather_data = WeatherData(self.city)
        self.traffic_map_image.source =
                     self.traffic_map.
                     get_traffic_map()
        self.attire_image.source = weather_data.
                                   get_attire_image()
        self.temperature_label.text = weather_data.
                                     get_temperature()
                                     + "\u00B0C"
        self.weather_conditions_label.text =
                     weather_data.get_conditions()
        self.conditions_image.source =
                     weather_data.
                     get_weather_conditions_icon()</pre><p class="list-inset">The <strong class="source-inline">update_status()</strong> method within the <strong class="source-inline">Dashboard</strong> class plays a major role in updating the dynamic widgets to reflect current data. Initially, it creates an instance of the <strong class="source-inline">WeatherData</strong> class using the current city. The method then proceeds to update the source of the <strong class="source-inline">traffic_map_image</strong> widget with a new traffic map image reflecting current conditions, obtained from the <strong class="source-inline">get_traffic_map()</strong> method of the <strong class="source-inline">TrafficMap</strong> class. It also changes the source of the <strong class="source-inline">attire_image</strong> widget to represent suitable clothing for the current weather, utilizing the <strong class="source-inline">get_attire_image()</strong> method of the <span class="No-Break"><strong class="source-inline">WeatherData</strong></span><span class="No-Break"> class.</span></p><p class="list-inset">The temperature label’s text<a id="_idIndexMarker404"/> is updated<a id="_idIndexMarker405"/> with the current<a id="_idIndexMarker406"/> temperature<a id="_idIndexMarker407"/> from the <strong class="source-inline">WeatherData</strong> class, appending the degree symbol and the letter <em class="italic">C</em> to represent Celsius. The text of the <strong class="source-inline">weather_conditions_label</strong> widget is modified to provide a description of the present weather conditions, also obtained from the <span class="No-Break"><strong class="source-inline">WeatherData</strong></span><span class="No-Break"> class.</span></p><p class="list-inset">Finally, the source of the <strong class="source-inline">conditions_image</strong> widget is updated with an icon that symbolizes the current weather conditions, using the <strong class="source-inline">get_weather_conditions_icon()</strong> method from the <span class="No-Break"><strong class="source-inline">WeatherData</strong></span><span class="No-Break"> class.</span></p></li> <li>Having completed our <strong class="source-inline">Dashboard</strong> class, we’ll next develop the <strong class="source-inline">MyApp</strong> class. This class will serve as the entry point for our Kivy application, handling both the initialization and management of the dashboard interface. We’ll create this class immediately following the <strong class="source-inline">Dashboard</strong> class in the <span class="No-Break">same file:</span><pre class="source-code">
class MyApp(App):
    def build(self):
        city = 'Toronto'
        latitude = 43.6426
        longitude = -79.3871
        zoom = 12
        return Dashboard(city,
                         latitude,
                         longitude,
                          zoom)
if __name__ == '__main__':
    MyApp().run()</pre><p class="list-inset">The <strong class="source-inline">MyApp</strong> class is inherited from Kivy’s <strong class="source-inline">App</strong> class and is responsible for initializing and running the main application. Within the <strong class="source-inline">build()</strong> method of <strong class="source-inline">MyApp</strong>, the city of <strong class="source-inline">Toronto</strong>, along with its corresponding latitude and longitude coordinates (<strong class="source-inline">43.6426</strong> and <strong class="source-inline">-79.3871</strong>), and zoom level are specified. These GPS coordinates point to the location in Toronto (downtown Toronto near the <span class="No-Break">CN Tower).</span></p><p class="list-inset">A <strong class="source-inline">Dashboard</strong> object is then created and returned with these parameters. The <strong class="source-inline">if __name__ == '__main__':</strong> line ensures that the code following it is only executed if the script is being run directly (not imported as a module in another script). When run directly, it creates an instance of the <strong class="source-inline">MyApp</strong> class and calls its <strong class="source-inline">run()</strong> method, starting the Kivy application and displaying the initialized dashboard with specified details related <span class="No-Break">to Toronto.</span></p></li> <li>We save<a id="_idIndexMarker408"/> our code<a id="_idIndexMarker409"/> as <strong class="source-inline">Dashboard.py</strong> inside<a id="_idIndexMarker410"/> the <strong class="source-inline">IoTWeatherDisplay</strong> <span class="No-Break">project</span><span class="No-Break"><a id="_idIndexMarker411"/></span><span class="No-Break"> subfolder.</span></li>
</ol>
<p>With all this code written, it is time to run it on our <span class="No-Break">7-inch screen.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor077"/>Running the IoT information display application</h2>
<p>To execute our IoT information display<a id="_idIndexMarker412"/> through the <strong class="source-inline">Dashboard.py</strong> script, we use Thonny. We can either click on the green run button and hit <em class="italic">F5</em> on the keyboard or click on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></p>
<p>With all the aforementioned code entered without errors (or cloned from the GitHub repository at <a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter4</a>), we should see our IoT information display run full screen on our <span class="No-Break">7-inch monitor:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="Figure 4.10 – IoT information display showing weather and traffic for Toronto, Canada" height="436" src="image/B21282_04_10.jpg" width="765"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – IoT information display showing weather and traffic for Toronto, Canada</p>
<p>As we can see, it is a relatively warm day in Toronto. In terms of traffic flow, there is construction and other areas to avoid. The weather is clear, and it is suggested we wear short-sleeved shirts today. If we were to run this on a standard computer monitor, we may see a large black border around <span class="No-Break">our display.</span></p>
<p>In a specific application such as creating an IoT information display, the mouse and keyboard can be removed<a id="_idIndexMarker413"/> from the Raspberry Pi, allowing the device to be used as a kiosk with a <span class="No-Break">7-inch touchscreen.</span></p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor078"/>Summary</h1>
<p>In this chapter, we explored various small screens compatible with the Raspberry Pi. We then used Raspberry Pi’s 7-inch touchscreen to create a versatile IoT information display that included weather forecasts and traffic maps for a <span class="No-Break">specific city.</span></p>
<p>By utilizing and optimizing web service data, we demonstrated the flexibility of Raspberry Pi in handling complex information display tasks. The principles and code developed in this chapter can be adapted for other uses, such as home automation dashboards, public information kiosks, or industrial monitoring systems for <span class="No-Break">manufacturing processes.</span></p>
<p>We have focused primarily on displaying information – in particular, weather information via web services – over the last few chapters. In the next chapter, we will start exploring sensory information with our Raspberry Pi as we work toward building an IoT <span class="No-Break">security application.</span></p>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer087">
<h1 id="_idParaDest-79" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor079"/>Part 2: Building an IoT Home Security Dashboard</h1>
<p>In <em class="italic">Part 2</em>, we explore the general-purpose input/output (GPIO) ports on the Raspberry Pi and Raspberry Pi Pico, build an IoT alarm module with a Raspberry Pi Pico W and a PIR motion sensor, create an IoT button using the M5Stack ATOM Matrix and Raspberry Pi Pico W, and develop an IoT alarm dashboard on a Raspberry Pi 5 with a 7-inch touchscreen for control <span class="No-Break">and monitoring.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B21282_05.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring the GPIO</em></li>
<li><a href="B21282_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>, <em class="italic">Building an IoT Alarm Module</em></li>
<li><a href="B21282_07.xhtml#_idTextAnchor107"><em class="italic">Chapter 7</em></a>, <em class="italic">Building an IoT Button</em></li>
<li><a href="B21282_08.xhtml#_idTextAnchor125"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating an IoT Alarm Dashboard</em></li>
</ul>
</div>
<div>
<div id="_idContainer088">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer089">
</div>
</div>
</div></body></html>