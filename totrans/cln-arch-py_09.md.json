["```py\n# Framework example - requires multiple adapter components\n@app.route(\"/tasks\", methods=[\"POST\"])\ndef create_task():\n    \"\"\"Framework requires full Interface Adapters stack\"\"\"\n    result = task_controller.handle_create(  # Controller from Ch.6\n        title=request.json[\"title\"],\n        description=request.json[\"description\"]\n    )\n    return task_presenter.present(result)    # Presenter from Ch.6 \n```", "```py\n# Driver example - only needs interface and implementation\nclass SQLiteTaskRepository(TaskRepository):  # Interface from Ch.5\n    \"\"\"Driver needs only basic interface implementation\"\"\"\n    def save(self, task: Task) -> None:\n        self.connection.execute(\n            \"INSERT INTO tasks (id, title) VALUES (?, ?)\",\n            (str(task.id), task.title)\n        ) \n```", "```py\nclass ClickCli:\n    def __init__(self, app: Application):\n        self.app = app\n        self.current_projects = []  # Cached list of projects for display\n    def run(self) -> int:\n        \"\"\"Entry point for running the Click CLI application\"\"\"\n        try:\n            while True:\n                self._display_projects()\n                self._handle_selection()\n        except KeyboardInterrupt:\n            click.echo(\"\\nGoodbye!\", err=True)\n            return 0\n    # ... additional methods \n```", "```py\ndef _display_task_menu(self, task_id: str) -> None:\n    \"\"\"Display and handle task menu.\"\"\"\n    result = self.app.task_controller.handle_get(task_id)\n    if not result.is_success:\n        click.secho(result.error.message, fg=\"red\", err=True)\n        return\n    task = result.success\n    click.clear()\n    click.echo(\"\\nTASK DETAILS\")\n    click.echo(\"=\" * 40)\n    click.echo(f\"Title:       {task.title}\")\n    click.echo(f\"Description: {task.description}\")\n    click.echo(f\"Status:      {task.status_display}\")\n    click.echo(f\"Priority:    {task.priority_display}\") \n```", "```py\ndef _handle_selection(self) -> None:\n    \"\"\"Handle project/task selection.\"\"\"\n    selection = click.prompt(\n        \"\\nSelect a project or task (e.g., '1' or '1.a')\",\n        type=str,\n        show_default=False\n    ).strip().lower()\n    if selection == \"np\":\n        self._create_new_project()\n        return\n    try:\n        if \".\" in selection:\n            project_num, task_letter = selection.split(\".\")\n            self._handle_task_selection(int(project_num),\n                                        task_letter)\n        else:  # Project selection\n            self._handle_project_selection(int(selection))\n    except (ValueError, IndexError):\n        click.secho(\n            \"Invalid selection. Use '1' for project or '1.a' for task.\",\n            fg=\"red\",\n            err=True,\n        ) \n```", "```py\ndef _create_new_project(self) -> None:\n    \"\"\"Create a new project.\"\"\"\n    name = click.prompt(\"Project name\", type=str)\n    description = click.prompt(\"Description (optional)\",\n                               type=str, default=\"\")\n    result = self.app.project_controller.handle_create(\n        name, description)\n    if not result.is_success:\n        click.secho(result.error.message,\n                    fg=\"red\", err=True) \n```", "```py\n# 1\\. Domain Layer: Add ProjectType and update entities\nclass ProjectType(Enum):\n    REGULAR = \"REGULAR\"\n    INBOX = \"INBOX\"\n@dataclass\nclass Project(Entity):\n    name: str\n    description: str = \"\"\n    project_type: ProjectType = field(default=ProjectType.REGULAR)\n    @classmethod\n    def create_inbox(cls) -> \"Project\":\n        return cls(\n            name=\"INBOX\",\n            description=\"Default project for unassigned tasks\",\n            project_type=ProjectType.INBOX\n        )\n@dataclass\nclass Task(Entity):\n    title: str\n    description: str\n    project_id: UUID  # No longer optional \n```", "```py\n# 2\\. Application Layer: Update repository interface and use cases\nclass ProjectRepository(ABC):\n    @abstractmethod\n    def get_inbox(self) -> Project:\n        \"\"\"Get the INBOX project.\"\"\"\n        pass\n@dataclass\nclass CreateTaskUseCase:\n    task_repository: TaskRepository\n    project_repository: ProjectRepository\n\n    def execute(self, request: CreateTaskRequest) -> Result:\n        try:\n            params = request.to_execution_params()\n            project_id = params.get(\"project_id\")\n            if not project_id:\n                project_id = self.project_repository.get_inbox().id\n            # ... remainder of implementation \n```", "```py\ndef _create_task(self) -> None:\n    \"\"\"Handle task creation command.\"\"\"\n    title = click.prompt(\"Task title\", type=str)\n    description = click.prompt(\"Description\", type=str)\n\n    # Project selection is optional - defaults to Inbox\n    if click.confirm(\"Assign to a specific project?\", default=False):\n        project_id = self._select_project()\n\n    result = self.app.task_controller.handle_create(\n        title=title,\n        description=description,\n        project_id=project_id  # Inbox handling in use case\n    ) \n```", "```py\nclass TaskRepository(ABC):\n    \"\"\"Repository interface for Task entity persistence.\"\"\"\n\n    @abstractmethod\n    def get(self, task_id: UUID) -> Task:\n        \"\"\"Retrieve a task by its ID.\"\"\"\n        pass\n    @abstractmethod\n    def save(self, task: Task) -> None:\n        \"\"\"Save a task to the repository.\"\"\"\n        pass\n    # ... remaining methods of interface \n```", "```py\nclass InMemoryTaskRepository(TaskRepository):\n    \"\"\"In-memory implementation of TaskRepository.\"\"\"\n    def __init__(self) -> None:\n        self._tasks: Dict[UUID, Task] = {}\n    def get(self, task_id: UUID) -> Task:\n        \"\"\"Retrieve a task by ID.\"\"\"\n        if task := self._tasks.get(task_id):\n            return task\n        raise TaskNotFoundError(task_id)\n    def save(self, task: Task) -> None:\n        \"\"\"Save a task.\"\"\"\n        self._tasks[task.id] = task\n    # additional interface method implementations \n```", "```py\nclass FileTaskRepository(TaskRepository):\n    \"\"\"JSON file-based implementation of TaskRepository.\"\"\"\n    def __init__(self, data_dir: Path):\n        self.tasks_file = data_dir / \"tasks.json\"\n        self._ensure_file_exists()\n    def get(self, task_id: UUID) -> Task:\n        \"\"\"Retrieve a task by ID.\"\"\"\n        tasks = self._load_tasks()\n        for task_data in tasks:\n            if UUID(task_data[\"id\"]) == task_id:\n                return self._dict_to_task(task_data)\n        raise TaskNotFoundError(task_id)\n    def save(self, task: Task) -> None:\n        \"\"\"Save a task.\"\"\"\n        # ... remainder of implementation \n```", "```py\n# Works identically with either repository\ntask = repository.get(task_id)\ntask.complete()\nrepository.save(task) \n```", "```py\nclass Config:\n    @classmethod\n    def get_repository_type(cls) -> RepositoryType:\n        repo_type_str = os.getenv(\n            \"TODO_REPOSITORY_TYPE\",\n            cls.DEFAULT_REPOSITORY_TYPE.value\n        )\n        try:\n            return RepositoryType(repo_type_str.lower())\n        except ValueError:\n            raise ValueError(f\"Invalid repository type: {repo_type_str}\") \n```", "```py\ndef create_repositories() -> Tuple[TaskRepository, ProjectRepository]:\n    repo_type = Config.get_repository_type()\n    if repo_type == RepositoryType.FILE:\n        data_dir = Config.get_data_directory()\n        task_repo = FileTaskRepository(data_dir)\n        project_repo = FileProjectRepository(data_dir)\n        project_repo.set_task_repository(task_repo)\n        return task_repo, project_repo\n    elif repo_type == RepositoryType.MEMORY:\n        task_repo = InMemoryTaskRepository()\n        project_repo = InMemoryProjectRepository()\n        project_repo.set_task_repository(task_repo)\n        return task_repo, project_repo\n    else:\n        raise ValueError(f\"Invalid repository type: {repo_type}\") \n```", "```py\nclass NotificationPort(ABC):\n    \"\"\"Interface for sending notifications about task events.\"\"\"\n\n    @abstractmethod\n    def notify_task_completed(self, task: Task) -> None:\n        \"\"\"Notify when a task is completed.\"\"\"\n        pass\n    @abstractmethod\n    def notify_task_high_priority(self, task: Task) -> None:\n        \"\"\"Notify when a task is set to high priority.\"\"\"\n        pass \n```", "```py\nclass SendGridNotifier(NotificationPort):\n    def __init__(self) -> None:\n        self.api_key = Config.get_sendgrid_api_key()\n        self.notification_email = Config.get_notification_email()\n        self._init_sg_client()\n    def notify_task_completed(self, task: Task) -> None:\n        \"\"\"Send email notification for completed task if configured.\"\"\"\n        if not (self.client and self.notification_email):\n            return \n        try:\n            message = Mail(\n                from_email=self.notification_email,\n                to_emails=self.notification_email,\n                subject=f\"Task Completed: {task.title}\",\n                plain_text_content=f\"Task '{task.title}' has been \n                                     completed.\"\n            )\n            self.client.send(message)\n        except Exception as e:\n            # Log error but don't disrupt business operations\n            # ... \n```", "```py\nclass Config:\n    \"\"\"Application configuration.\"\"\"\n    # Previous repository settings omitted...\n\n    @classmethod\n    def get_sendgrid_api_key(cls) -> str:\n        \"\"\"Get the SendGrid API key.\"\"\"\n        return os.getenv(\"TODO_SENDGRID_API_KEY\", \"\")\n    @classmethod\n    def get_notification_email(cls) -> str:\n        \"\"\"Get the notification recipient email.\"\"\"\n        return os.getenv(\"TODO_NOTIFICATION_EMAIL\", \"\")\n    # ... remainder of implementation \n```", "```py\n@dataclass\nclass CompleteTaskUseCase:\n    task_repository: TaskRepository\n    notification_service: NotificationPort  \n    def execute(self, request: CompleteTaskRequest) -> Result:\n        try:\n            task = self.task_repository.get(request.task_id)\n            task.complete(notes=request.completion_notes)\n            self.task_repository.save(task)\n            self.notification_service.notify_task_completed(task)\n            # ... remainder of implementation \n```", "```py\n@dataclass\nclass Application:\n    \"\"\"Container which wires together all components.\"\"\"\n    task_repository: TaskRepository\n    project_repository: ProjectRepository\n    notification_service: NotificationPort\n    task_presenter: TaskPresenter\n    project_presenter: ProjectPresenter \n```", "```py\ndef __post_init__(self):\n    \"\"\"Wire up use cases and controllers.\"\"\"\n    # Configure task use cases\n    self.create_task_use_case = CreateTaskUseCase(\n      self.task_repository, self.project_repository)\n    self.complete_task_use_case = CompleteTaskUseCase(\n        self.task_repository, self.notification_service\n    )\n    self.get_task_use_case = GetTaskUseCase(self.task_repository)\n    self.delete_task_use_case = DeleteTaskUseCase(self.task_repository)\n    self.update_task_use_case = UpdateTaskUseCase(\n        self.task_repository, self.notification_service\n    )\n    # Wire up task controller\n    self.task_controller = TaskController(\n        create_use_case=self.create_task_use_case,\n        complete_use_case=self.complete_task_use_case,\n        update_use_case=self.update_task_use_case,\n        delete_use_case=self.delete_task_use_case,\n        get_use_case=self.get_task_use_case,\n        presenter=self.task_presenter,\n    )\n    # ... construction of Project use cases and controller \n```", "```py\ndef create_application(\n    notification_service: NotificationPort,\n    task_presenter: TaskPresenter,\n    project_presenter: ProjectPresenter,\n) -> \"Application\":\n    \"\"\" Factory function for the Application container. \"\"\"\n    # Call the factory methods\n    task_repository, project_repository = create_repositories()\n    notification_service = create_notification_service()\n    return Application(\n        task_repository=task_repository,\n        project_repository=project_repository,\n        notification_service=notification_service,\n        task_presenter=task_presenter,\n        project_presenter=project_presenter,\n    ) \n```", "```py\ndef main() -> int:\n    \"\"\"Main entry point for the CLI application.\"\"\"\n    try:\n        # Create application with dependencies\n        app = create_application(\n            notification_service=NotificationRecorder(),\n            task_presenter=CliTaskPresenter(),\n            project_presenter=CliProjectPresenter(),\n        )\n        # Create and run CLI implementation\n        cli = ClickCli(app)\n        return cli.run()\n\n    except KeyboardInterrupt:\n        print(\"\\nGoodbye!\")\n        return 0\n    except Exception as e:\n        print(f\"Error: {str(e)}\", file=sys.stderr)\n        return 1\nif __name__ == \"__main__\":\n    sys.exit(main()) \n```"]