<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread-Based Parallelism</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Currently, the most widely used programming paradigm for the management of concurrency in software applications is based on multithreading. </span><span class="koboSpan" id="kobo.2.2">Generally, an application is made by a single process</span><em><span class="koboSpan" id="kobo.3.1"> </span></em><span class="koboSpan" id="kobo.4.1">that is divided into multiple independent threads, which represent activities of different types that run in parallel</span><em><span class="koboSpan" id="kobo.5.1"> </span></em><span class="koboSpan" id="kobo.6.1">and compete with each other.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Nowadays, modern applications that use multithreading have been adopted on a massive scale. </span><span class="koboSpan" id="kobo.7.2">In fact, all current processors are multicore, just so they can perform parallel operations and exploit the computer's computational resources.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Hence, </span><em><span class="koboSpan" id="kobo.9.1">multithreaded programming</span></em><strong><span class="koboSpan" id="kobo.10.1"> </span></strong><span class="koboSpan" id="kobo.11.1">is definitely a good way to achieve concurrent applications. </span><span class="koboSpan" id="kobo.11.2">However, multithreaded programming often hides some non-trivial difficulties, which must be managed appropriately to avoid errors such as deadlocks</span><em><span class="koboSpan" id="kobo.12.1"> </span></em><span class="koboSpan" id="kobo.13.1">or synchronization issues.</span></p>
<p><span><span class="koboSpan" id="kobo.14.1">We will first define the concepts of thread-based and multithreaded programming and then introduce the </span><kbd><span class="koboSpan" id="kobo.15.1">multithreading</span></kbd><span class="koboSpan" id="kobo.16.1"> library. </span><span class="koboSpan" id="kobo.16.2">We will learn about the main directives for thread definition, management, and communication.</span></span></p>
<p><span><span class="koboSpan" id="kobo.17.1">Through the </span><kbd><span class="koboSpan" id="kobo.18.1">multithreading</span></kbd><span class="koboSpan" id="kobo.19.1"> library, we will see how to solve problems through different techniques, such as </span><em><span class="koboSpan" id="kobo.20.1">lock</span></em><span class="koboSpan" id="kobo.21.1">, </span><em><span class="koboSpan" id="kobo.22.1">RLock</span></em><span class="koboSpan" id="kobo.23.1">, </span><em><span class="koboSpan" id="kobo.24.1">semaphores</span></em><span class="koboSpan" id="kobo.25.1">, </span><em><span class="koboSpan" id="kobo.26.1">condition</span></em><span class="koboSpan" id="kobo.27.1">, </span><em><span class="koboSpan" id="kobo.28.1">event</span></em><span class="koboSpan" id="kobo.29.1">, </span><em><span class="koboSpan" id="kobo.30.1">barrier, </span></em><span class="koboSpan" id="kobo.31.1">and </span><em><span class="koboSpan" id="kobo.32.1">queue</span></em></span><span class="koboSpan" id="kobo.33.1">.</span></p>
<p><span class="koboSpan" id="kobo.34.1">In this chapter, we will cover the following recipes:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.35.1">What is a thread?</span></li>
<li><span class="koboSpan" id="kobo.36.1">How to define a thread</span></li>
<li><span class="koboSpan" id="kobo.37.1">How to determine the current thread</span></li>
<li><span class="koboSpan" id="kobo.38.1">How to use a thread in a subclass</span></li>
<li><span class="koboSpan" id="kobo.39.1">Thread synchronization with a lock</span></li>
<li><span class="koboSpan" id="kobo.40.1">Thread synchronization with an RLock</span></li>
</ul>
<p class="mce-root"/>
<ul>
<li><span class="koboSpan" id="kobo.41.1">Thread synchronization with semaphores</span></li>
<li><span class="koboSpan" id="kobo.42.1">Thread synchronization with a condition</span></li>
<li><span class="koboSpan" id="kobo.43.1">Thread synchronization with an event</span></li>
<li><span class="koboSpan" id="kobo.44.1">Thread synchronization with a barrier</span></li>
<li><span class="koboSpan" id="kobo.45.1">Thread communication using a queue</span></li>
</ul>
<p><span><span class="koboSpan" id="kobo.46.1">We will also explore the main options offered by Python to program with threads. </span><span class="koboSpan" id="kobo.46.2">To do this, we will focus on using the </span><kbd><span class="koboSpan" id="kobo.47.1">threading</span></kbd><span class="koboSpan" id="kobo.48.1"> module.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">What is a thread?</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><em><span class="koboSpan" id="kobo.3.1">thread</span></em><span class="koboSpan" id="kobo.4.1"> is an independent execution flow that can be executed in parallel and concurrently with other threads in the system.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Multiple threads can share data and resources, taking advantage of the so-called space of shared information. </span><span class="koboSpan" id="kobo.5.2">The specific implementation of threads and processes depends on the OS on which you plan to run the application, but, in general, it can be stated that a thread is contained inside a process and that different threads in the same process conditions share some resources. </span><span class="koboSpan" id="kobo.5.3">In contrast to this, different processes do not share their own resources with other processes.</span></p>
<p><span class="koboSpan" id="kobo.6.1">A thread is composed of three elements: program counters, registers, and stack. </span><span class="koboSpan" id="kobo.6.2">Shared resources with other threads of the same process essentially include </span><em><span class="koboSpan" id="kobo.7.1">data</span></em><span class="koboSpan" id="kobo.8.1"> and </span><em><span class="koboSpan" id="kobo.9.1">OS resources</span></em><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">Moreover, threads have their own state of execution, namely, </span><em><span class="koboSpan" id="kobo.11.1">thread state</span></em><span class="koboSpan" id="kobo.12.1">, and can be </span><em><span class="koboSpan" id="kobo.13.1">synchronized</span></em><span class="koboSpan" id="kobo.14.1"> with other threads.</span></p>
<p><span class="koboSpan" id="kobo.15.1">A thread state can be ready, running, or blocked:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.16.1">When a thread is created, it enters the </span><strong><span class="koboSpan" id="kobo.17.1">Ready </span></strong><span class="koboSpan" id="kobo.18.1">state.</span></li>
<li><span class="koboSpan" id="kobo.19.1">A thread is scheduled for execution by the OS (or by the runtime support system) and, when its turn arrives, it begins execution by going into the </span><strong><span class="koboSpan" id="kobo.20.1">Running </span></strong><span class="koboSpan" id="kobo.21.1">state.</span></li>
<li><span class="koboSpan" id="kobo.22.1">The thread can wait for a condition to occur, passing from the </span><strong><span class="koboSpan" id="kobo.23.1">Running </span></strong><span class="koboSpan" id="kobo.24.1">state to the </span><strong><span class="koboSpan" id="kobo.25.1">Blocked </span></strong><span class="koboSpan" id="kobo.26.1">state. </span><span class="koboSpan" id="kobo.26.2">Once the locked condition is terminated, the </span><strong><span class="koboSpan" id="kobo.27.1">Blocked </span></strong><span class="koboSpan" id="kobo.28.1">thread returns to the </span><strong><span class="koboSpan" id="kobo.29.1">Ready </span></strong><span class="koboSpan" id="kobo.30.1">state:</span></li>
</ul>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.31.1"><img src="assets/1c9d8391-719e-4277-a1ae-dd4155345659.png" style="width:43.00em;height:19.58em;"/></span></p>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.32.1">Thread life cycle</span></div>
<p><span class="koboSpan" id="kobo.33.1">The main advantage of multithreading programming lies in performances, as the context switch between processes turns out to be much heavier than the switch context between threads that belong to the same process.</span></p>
<p><span class="koboSpan" id="kobo.34.1">In the next recipes, until the end of the chapter, we will examine the Python </span><kbd><span class="koboSpan" id="kobo.35.1">threading</span></kbd><span class="koboSpan" id="kobo.36.1"> module, introducing its main functions through programming examples.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Python threading module</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Python manages threads with the </span><kbd><span class="koboSpan" id="kobo.3.1">threading</span></kbd><span class="koboSpan" id="kobo.4.1"> module provided by the Python standard library. </span><span class="koboSpan" id="kobo.4.2">This module provides some very interesting features that make the threading-based approach a whole lot easier; in fact, the </span><kbd><span class="koboSpan" id="kobo.5.1">threading</span></kbd><span class="koboSpan" id="kobo.6.1"> module provides several synchronization mechanisms that are very simple to implement.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The major components of the threading module are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">The </span><kbd><span class="koboSpan" id="kobo.9.1">thread</span></kbd><span class="koboSpan" id="kobo.10.1"> object</span></li>
<li><span class="koboSpan" id="kobo.11.1">The </span><kbd><span class="koboSpan" id="kobo.12.1">lock</span></kbd><span class="koboSpan" id="kobo.13.1"> object</span></li>
<li><span class="koboSpan" id="kobo.14.1">The </span><kbd><span class="koboSpan" id="kobo.15.1">RLock</span></kbd><span class="koboSpan" id="kobo.16.1"> object</span></li>
<li><span class="koboSpan" id="kobo.17.1">The </span><kbd><span class="koboSpan" id="kobo.18.1">semaphore</span></kbd><span class="koboSpan" id="kobo.19.1"> object</span></li>
<li><span class="koboSpan" id="kobo.20.1">The </span><kbd><span class="koboSpan" id="kobo.21.1">condition</span></kbd><span class="koboSpan" id="kobo.22.1"> object</span></li>
<li><span class="koboSpan" id="kobo.23.1">The </span><kbd><span class="koboSpan" id="kobo.24.1">event</span></kbd><span class="koboSpan" id="kobo.25.1"> object</span></li>
</ul>
<p><span class="koboSpan" id="kobo.26.1">In the following recipes, we examine the features offered by the </span><kbd><span class="koboSpan" id="kobo.27.1">threading</span></kbd><span class="koboSpan" id="kobo.28.1"> library with different application examples. </span><span class="koboSpan" id="kobo.28.2">For the examples that follow, we will refer to the Python 3.5.0 distribution (</span><a href="https://www.python.org/downloads/release/python-350/"><span class="koboSpan" id="kobo.29.1">https://www.python.org/downloads/release/python-350/</span></a><span class="koboSpan" id="kobo.30.1">).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Defining a thread</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The simplest way to use a thread is to instantiate it with a target function and then call the start method to let it begin the job.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The Python </span><kbd><span class="koboSpan" id="kobo.3.1">threading</span></kbd> <span><span class="koboSpan" id="kobo.4.1">module</span></span><span class="koboSpan" id="kobo.5.1"> provides a </span><kbd><span class="koboSpan" id="kobo.6.1">Thread</span></kbd><span class="koboSpan" id="kobo.7.1"> class that is used to run processes and functions in a different thread:</span></p>
<pre><span class="koboSpan" id="kobo.8.1">class threading.Thread(group=None, 
                       target=None, 
                       name=None, 
                       args=(), 
                       kwargs={})  </span></pre>
<p><span class="koboSpan" id="kobo.9.1">Here are the parameters of the </span><kbd><span class="koboSpan" id="kobo.10.1">Thread</span></kbd><span class="koboSpan" id="kobo.11.1"> class:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.12.1">group</span></kbd><span class="koboSpan" id="kobo.13.1">: This is the </span><kbd><span class="koboSpan" id="kobo.14.1">group</span></kbd> <span><span class="koboSpan" id="kobo.15.1">value,</span></span> <span><span class="koboSpan" id="kobo.16.1">which</span></span><span class="koboSpan" id="kobo.17.1"> should be </span><kbd><span class="koboSpan" id="kobo.18.1">None</span></kbd><span class="koboSpan" id="kobo.19.1">; this is reserved for future implementations.</span></li>
<li><kbd><span class="koboSpan" id="kobo.20.1">target</span></kbd><span class="koboSpan" id="kobo.21.1">: This is the function that is to be executed when you start a thread activity.</span></li>
<li><kbd><span class="koboSpan" id="kobo.22.1">name</span></kbd><span class="koboSpan" id="kobo.23.1">: This is the name of the thread; by default, a unique name of the form of </span><kbd><span class="koboSpan" id="kobo.24.1">Thread-N</span></kbd><span class="koboSpan" id="kobo.25.1"> is assigned to it.</span></li>
<li><kbd><span class="koboSpan" id="kobo.26.1">args</span></kbd><span class="koboSpan" id="kobo.27.1">: This is the tuple of arguments that are to be passed to a target.</span></li>
<li><kbd><span class="koboSpan" id="kobo.28.1">kwargs</span></kbd><span class="koboSpan" id="kobo.29.1">: This is the dictionary of keyword arguments that are to be used for the </span><kbd><span class="koboSpan" id="kobo.30.1">target</span></kbd><span class="koboSpan" id="kobo.31.1"> function.</span></li>
</ul>
<p><span><span class="koboSpan" id="kobo.32.1">In the next section,</span></span><span class="koboSpan" id="kobo.33.1"> let's learn about how to define a thread.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We'll define a thread by passing it a number, which represents the thread number, and finally, the result will be printed out:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">Import the </span><kbd><span class="koboSpan" id="kobo.4.1">threading</span></kbd><span class="koboSpan" id="kobo.5.1"> module by using the following Python command:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.6.1">import threading</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.7.1">In the </span><kbd><span class="koboSpan" id="kobo.8.1">main</span></kbd><span class="koboSpan" id="kobo.9.1"> program, a </span><kbd><span class="koboSpan" id="kobo.10.1">Thread</span></kbd><span class="koboSpan" id="kobo.11.1"> object is instantiated with a </span><kbd><span class="koboSpan" id="kobo.12.1">target</span></kbd><span class="koboSpan" id="kobo.13.1"> function called </span><kbd><span class="koboSpan" id="kobo.14.1">my_func</span></kbd><span class="koboSpan" id="kobo.15.1">. </span><span class="koboSpan" id="kobo.15.2">Then, an argument to the function that will be included in the output message is passed:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.16.1">t = threading.Thread(target=function , args=(i,))</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.17.1">The thread does not start running until the start method is called, and the </span><kbd><span class="koboSpan" id="kobo.18.1">join</span></kbd><span class="koboSpan" id="kobo.19.1"> method makes the calling thread and waits until the thread has finished the execution, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.20.1">import threading</span><br/><br/><span class="koboSpan" id="kobo.21.1">def my_func(thread_number):</span><br/><span class="koboSpan" id="kobo.22.1">    return print('my_func called by thread N°\</span><br/><span class="koboSpan" id="kobo.23.1">        {}'.format(thread_number))</span><br/><br/><br/><span class="koboSpan" id="kobo.24.1">def main():</span><br/><span class="koboSpan" id="kobo.25.1">    threads = []</span><br/><span class="koboSpan" id="kobo.26.1">    for i in range(10):</span><br/><span class="koboSpan" id="kobo.27.1">        t = threading.Thread(target=my_func, args=(i,))</span><br/><span class="koboSpan" id="kobo.28.1">        threads.append(t)</span><br/><span class="koboSpan" id="kobo.29.1">        t.start()</span><br/><span class="koboSpan" id="kobo.30.1">        t.join()</span><br/><br/><span class="koboSpan" id="kobo.31.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.32.1">    main()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the </span><kbd><span class="koboSpan" id="kobo.3.1">main</span></kbd><span class="koboSpan" id="kobo.4.1"> program, we initialize the thread's list, to which we add the instance of each thread that is created. </span><span class="koboSpan" id="kobo.4.2">The total number of threads created is 10, while the </span><strong><span class="koboSpan" id="kobo.5.1">i</span></strong><span class="koboSpan" id="kobo.6.1">-index for the i</span><sup><span class="koboSpan" id="kobo.7.1">th</span></sup><span class="koboSpan" id="kobo.8.1"> thread is passed as an argument to the i</span><sup><span class="koboSpan" id="kobo.9.1">th</span></sup><span class="koboSpan" id="kobo.10.1"> thread:</span></p>
<pre><strong><span class="koboSpan" id="kobo.11.1">my_func called by thread N°0</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">my_func called by thread N°1</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">my_func called by thread N°2</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">my_func called by thread N°3</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">my_func called by thread N°4</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">my_func called by thread N°5</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">my_func called by thread N°6</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">my_func called by thread N°7</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">my_func called by thread N°8</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">my_func called by thread N°9</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">All current processors are multicore, thus offering the possibility of performing multiple parallel operations and making the most of the computer's computational resources. </span><span class="koboSpan" id="kobo.2.2">Although this is true, multithread programming hides a number of non-trivial difficulties, which must be managed appropriately to avoid errors such as deadlocks or synchronization problems.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Determining the current thread</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Using arguments to identify or name the thread is cumbersome and unnecessary. </span><span class="koboSpan" id="kobo.2.2">Each </span><kbd><span class="koboSpan" id="kobo.3.1">Thread</span></kbd><span class="koboSpan" id="kobo.4.1"> instance has a </span><em><span class="koboSpan" id="kobo.5.1">name</span></em><span class="koboSpan" id="kobo.6.1"> with a default value that can be changed as the thread is created.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Naming threads is useful in server proc</span><em><span class="koboSpan" id="kobo.8.1">esses</span></em><span class="koboSpan" id="kobo.9.1"> with multiple service threads that handle different operations.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">This </span><kbd><span class="koboSpan" id="kobo.3.1">threading</span></kbd><span class="koboSpan" id="kobo.4.1"> module provides the </span><kbd><span class="koboSpan" id="kobo.5.1">currentThread().getName()</span></kbd><span class="koboSpan" id="kobo.6.1"> method, which returns the name of the current thread.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The following section shows us how to use this function to determine which thread is running.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's have a look at the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">To determine which thread is running, we create three </span><kbd><span class="koboSpan" id="kobo.4.1">target</span></kbd><span class="koboSpan" id="kobo.5.1"> functions and import the </span><kbd><span class="koboSpan" id="kobo.6.1">time</span></kbd><span class="koboSpan" id="kobo.7.1"> module to introduce a suspended execution of two seconds:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.8.1">import threading</span><br/><span class="koboSpan" id="kobo.9.1">import time</span><br/><br/><span class="koboSpan" id="kobo.10.1">def function_A():</span><br/><span class="koboSpan" id="kobo.11.1">    print (threading.currentThread().getName()+str('--&gt;\</span><br/><span class="koboSpan" id="kobo.12.1">        starting \n'))</span><br/><span class="koboSpan" id="kobo.13.1">    time.sleep(2)</span><br/><span class="koboSpan" id="kobo.14.1">    print (threading.currentThread().getName()+str( '--&gt;\</span><br/><span class="koboSpan" id="kobo.15.1">        exiting \n'))</span><br/>  <br/><span class="koboSpan" id="kobo.16.1">def function_B():</span><br/><span class="koboSpan" id="kobo.17.1">    print (threading.currentThread().getName()+str('--&gt;\</span><br/><span class="koboSpan" id="kobo.18.1">        starting \n'))</span><br/><span class="koboSpan" id="kobo.19.1">    time.sleep(2)</span><br/><span class="koboSpan" id="kobo.20.1">    print (threading.currentThread().getName()+str( '--&gt;\</span><br/><span class="koboSpan" id="kobo.21.1">        exiting \n'))</span><br/>  <br/><span class="koboSpan" id="kobo.22.1">def function_C():</span><br/><span class="koboSpan" id="kobo.23.1">    print (threading.currentThread().getName()+str('--&gt;\</span><br/><span class="koboSpan" id="kobo.24.1">        starting \n'))</span><br/><span class="koboSpan" id="kobo.25.1">    time.sleep(2)</span><br/><span class="koboSpan" id="kobo.26.1">    print (threading.currentThread().getName()+str( '--&gt;\</span><br/><span class="koboSpan" id="kobo.27.1">        exiting \n'))</span><br/>    </pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.28.1">Three threads are instantiated with a </span><kbd><span class="koboSpan" id="kobo.29.1">target</span></kbd><span class="koboSpan" id="kobo.30.1"> function. </span><span class="koboSpan" id="kobo.30.2">Then, we pass the name that is to be printed and, if it is not defined, then the default name will be used. </span><span class="koboSpan" id="kobo.30.3">Then, the </span><kbd><span class="koboSpan" id="kobo.31.1">start()</span></kbd><span class="koboSpan" id="kobo.32.1"> and </span><kbd><span class="koboSpan" id="kobo.33.1">join()</span></kbd><span class="koboSpan" id="kobo.34.1"> methods are called </span><span><span class="koboSpan" id="kobo.35.1">for each thread</span></span><span class="koboSpan" id="kobo.36.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.37.1">if __name__ == "__main__":</span><br/><br/><span class="koboSpan" id="kobo.38.1">    t1 = threading.Thread(name='function_A', target=function_A)</span><br/><span class="koboSpan" id="kobo.39.1">    t2 = threading.Thread(name='function_B', target=function_B)</span><br/><span class="koboSpan" id="kobo.40.1">    t3 = threading.Thread(name='function_C',target=function_C) </span><br/><br/><span class="koboSpan" id="kobo.41.1">    t1.start()</span><br/><span class="koboSpan" id="kobo.42.1">    t2.start()</span><br/><span class="koboSpan" id="kobo.43.1">    t3.start()</span><br/><br/><span class="koboSpan" id="kobo.44.1">    t1.join()</span><br/><span class="koboSpan" id="kobo.45.1">    t2.join()</span><br/><span class="koboSpan" id="kobo.46.1">    t3.join()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We are going to set up three threads, each of which is assigned a </span><kbd><span class="koboSpan" id="kobo.3.1">target</span></kbd><span class="koboSpan" id="kobo.4.1"> function. </span><span class="koboSpan" id="kobo.4.2">When the </span><kbd><span class="koboSpan" id="kobo.5.1">target</span></kbd><span class="koboSpan" id="kobo.6.1"> function is executed and terminated, the function name is appropriately printed out.</span></p>
<p><span><span class="koboSpan" id="kobo.7.1">For this example, t</span></span><span class="koboSpan" id="kobo.8.1">he output should look like this (even if the order shown cannot be the same):</span></p>
<pre><strong><span class="koboSpan" id="kobo.9.1">function_A--&gt; starting </span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">function_B--&gt; starting </span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">function_C--&gt; starting </span></strong><br/><br/><br/><strong><span class="koboSpan" id="kobo.12.1">function_A--&gt; exiting </span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">function_B--&gt; exiting </span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">function_C--&gt; exiting</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Defining a thread subclass</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Creating a thread can require the definition of a subclass, which inherits from the </span><kbd><span class="koboSpan" id="kobo.3.1">Thread</span></kbd><span class="koboSpan" id="kobo.4.1"> class. </span><span class="koboSpan" id="kobo.4.2">The latter, as explained in </span><em><span class="koboSpan" id="kobo.5.1">Defining a thread</span></em><span class="koboSpan" id="kobo.6.1"> section, is included in the </span><kbd><span class="koboSpan" id="kobo.7.1">threading</span></kbd><span class="koboSpan" id="kobo.8.1"> module, which must then be imported.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The class that we will define in the next section, which represents our thread, respects a precise structure: we will first have to define the </span><strong><kbd><span class="koboSpan" id="kobo.3.1">__init__</span></kbd></strong><span class="koboSpan" id="kobo.4.1"> method, but, above all, we will have to override the </span><kbd><span class="koboSpan" id="kobo.5.1">run</span></kbd><span class="koboSpan" id="kobo.6.1"> method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The steps involved are as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">We defined the </span><kbd><span class="koboSpan" id="kobo.4.1">MyThreadClass</span></kbd> <span><span class="koboSpan" id="kobo.5.1">class,</span></span><span class="koboSpan" id="kobo.6.1"> which we can use to create all the threads we want. </span><span class="koboSpan" id="kobo.6.2">Each thread of this type will be characterized by the operations defined in the </span><kbd><span class="koboSpan" id="kobo.7.1">run</span></kbd><span class="koboSpan" id="kobo.8.1"> method, which, in this simple example, limits itself to printing a string at the beginning and at the end of its execution:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.9.1">import time</span><br/><span class="koboSpan" id="kobo.10.1">import os</span><br/><span class="koboSpan" id="kobo.11.1">from random import randint</span><br/><span class="koboSpan" id="kobo.12.1">from threading import Thread</span><br/><br/><span class="koboSpan" id="kobo.13.1">class MyThreadClass (Thread):</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.14.1">Furthermore, in the </span><kbd><span class="koboSpan" id="kobo.15.1">__init__</span></kbd><span class="koboSpan" id="kobo.16.1"> method, we have specified two initialization parameters, respectively, </span><kbd><span class="koboSpan" id="kobo.17.1">name</span></kbd><span class="koboSpan" id="kobo.18.1"> and </span><kbd><span class="koboSpan" id="kobo.19.1">duration</span></kbd><span class="koboSpan" id="kobo.20.1">, that will be used in the </span><kbd><span class="koboSpan" id="kobo.21.1">run</span></kbd><span class="koboSpan" id="kobo.22.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.23.1">def __init__(self, name, duration):</span><br/><span class="koboSpan" id="kobo.24.1">      Thread.__init__(self)</span><br/><span class="koboSpan" id="kobo.25.1">      self.name = name</span><br/><span class="koboSpan" id="kobo.26.1">      self.duration = duration </span><br/><br/><span class="koboSpan" id="kobo.27.1">   def run(self):</span><br/><span class="koboSpan" id="kobo.28.1">      print ("---&gt; " + self.name +\</span><br/><span class="koboSpan" id="kobo.29.1">             " running, belonging to process ID "\</span><br/><span class="koboSpan" id="kobo.30.1">             + str(os.getpid()) + "\n")</span><br/><span class="koboSpan" id="kobo.31.1">      time.sleep(self.duration)</span><br/><span class="koboSpan" id="kobo.32.1">      print ("---&gt; " + self.name + " over\n")</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.33.1">These parameters will </span><span><span class="koboSpan" id="kobo.34.1">then</span></span><span class="koboSpan" id="kobo.35.1"> be set during the creation of the thread. </span><span class="koboSpan" id="kobo.35.2">In particular, the </span><kbd><span class="koboSpan" id="kobo.36.1">duration</span></kbd><span class="koboSpan" id="kobo.37.1"> parameter is computed using the </span><kbd><span class="koboSpan" id="kobo.38.1">randint</span></kbd><span class="koboSpan" id="kobo.39.1"> function that outputs a random integer between </span><kbd><span class="koboSpan" id="kobo.40.1">1</span></kbd><span class="koboSpan" id="kobo.41.1"> and </span><kbd><span class="koboSpan" id="kobo.42.1">10</span></kbd><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">Starting from the definition of </span><kbd><span class="koboSpan" id="kobo.44.1">MyThreadClass</span></kbd><span class="koboSpan" id="kobo.45.1">, let's see how to instantiate more threads, as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.46.1">def main():</span><br/><br/><span class="koboSpan" id="kobo.47.1">    start_time = time.time()</span><br/><br/><span class="koboSpan" id="kobo.48.1">    # Thread Creation</span><br/><span class="koboSpan" id="kobo.49.1">    thread1 = MyThreadClass("Thread#1 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.50.1">    thread2 = MyThreadClass("Thread#2 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.51.1">    thread3 = MyThreadClass("Thread#3 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.52.1">    thread4 = MyThreadClass("Thread#4 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.53.1">    thread5 = MyThreadClass("Thread#5 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.54.1">    thread6 = MyThreadClass("Thread#6 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.55.1">    thread7 = MyThreadClass("Thread#7 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.56.1">    thread8 = MyThreadClass("Thread#8 ", randint(1,10)) </span><br/><span class="koboSpan" id="kobo.57.1">    thread9 = MyThreadClass("Thread#9 ", randint(1,10))</span><br/><br/><span class="koboSpan" id="kobo.58.1">    # Thread Running</span><br/><span class="koboSpan" id="kobo.59.1">    thread1.start()</span><br/><span class="koboSpan" id="kobo.60.1">    thread2.start()</span><br/><span class="koboSpan" id="kobo.61.1">    thread3.start()</span><br/><span class="koboSpan" id="kobo.62.1">    thread4.start()</span><br/><span class="koboSpan" id="kobo.63.1">    thread5.start()</span><br/><span class="koboSpan" id="kobo.64.1">    thread6.start()</span><br/><span class="koboSpan" id="kobo.65.1">    thread7.start()</span><br/><span class="koboSpan" id="kobo.66.1">    thread8.start()</span><br/><span class="koboSpan" id="kobo.67.1">    thread9.start()</span><br/><br/><span class="koboSpan" id="kobo.68.1">    # Thread joining</span><br/><span class="koboSpan" id="kobo.69.1">    thread1.join()</span><br/><span class="koboSpan" id="kobo.70.1">    thread2.join()</span><br/><span class="koboSpan" id="kobo.71.1">    thread3.join()</span><br/><span class="koboSpan" id="kobo.72.1">    thread4.join()</span><br/><span class="koboSpan" id="kobo.73.1">    thread5.join()</span><br/><span class="koboSpan" id="kobo.74.1">    thread6.join()</span><br/><span class="koboSpan" id="kobo.75.1">    thread7.join()</span><br/><span class="koboSpan" id="kobo.76.1">    thread8.join()</span><br/><span class="koboSpan" id="kobo.77.1">    thread9.join()</span><br/><br/><span class="koboSpan" id="kobo.78.1">    # End </span><br/><span class="koboSpan" id="kobo.79.1">    print("End")</span><br/><br/><span class="koboSpan" id="kobo.80.1">    #Execution Time</span><br/><span class="koboSpan" id="kobo.81.1">    print("--- %s seconds ---" % (time.time() - start_time))</span><br/><br/><span class="koboSpan" id="kobo.82.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.83.1">    main()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, we created nine threads, each with their own </span><kbd><span class="koboSpan" id="kobo.3.1">name</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">duration</span></kbd><span class="koboSpan" id="kobo.6.1"> property, according to the definition of the </span><kbd><span class="koboSpan" id="kobo.7.1">__init__</span></kbd><span class="koboSpan" id="kobo.8.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.9.1">We then run them using the </span><kbd><span class="koboSpan" id="kobo.10.1">start</span></kbd><span class="koboSpan" id="kobo.11.1"> method, which is limited to executing the contents of the </span><span><span class="koboSpan" id="kobo.12.1">previously defined</span></span> <kbd><span class="koboSpan" id="kobo.13.1">run</span></kbd><span class="koboSpan" id="kobo.14.1"> method. </span><span class="koboSpan" id="kobo.14.2">Note that the process ID for each thread is the same, meaning that we are in a multithreaded process.</span></p>
<p><span class="koboSpan" id="kobo.15.1">Also, note that the start method </span><em><span class="koboSpan" id="kobo.16.1">is not blocking</span></em><span class="koboSpan" id="kobo.17.1">: when it is executed, the control immediately goes to the next line, while the thread is started in the background. </span><span class="koboSpan" id="kobo.17.2">In fact, as you can see, the creation of threads </span><em><span class="koboSpan" id="kobo.18.1">does not take place</span></em><span class="koboSpan" id="kobo.19.1"> in the order specified by the code. </span><span class="koboSpan" id="kobo.19.2">Likewise, thread termination is constrained to the value of the </span><kbd><span class="koboSpan" id="kobo.20.1">duration</span></kbd><span class="koboSpan" id="kobo.21.1"> parameter, evaluated using the </span><kbd><span class="koboSpan" id="kobo.22.1">randint</span></kbd><span class="koboSpan" id="kobo.23.1"> function, and passed by the parameter for each thread creation instance. </span><span class="koboSpan" id="kobo.23.2">To wait for a thread to finish, a </span><kbd><span class="koboSpan" id="kobo.24.1">join</span></kbd><span class="koboSpan" id="kobo.25.1"> operation must be performed.</span></p>
<p><span class="koboSpan" id="kobo.26.1">The output looks like this:</span></p>
<pre><strong><span class="koboSpan" id="kobo.27.1">---&gt; Thread#1 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">---&gt; Thread#5 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">---&gt; Thread#2 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">---&gt; Thread#6 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">---&gt; Thread#7 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">---&gt; Thread#3 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">---&gt; Thread#4 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">---&gt; Thread#8 running, belonging to process ID 13084</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">---&gt; Thread#9 running, belonging to process ID 13084</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.36.1">---&gt; Thread#6 over</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">---&gt; Thread#9 over</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">---&gt; Thread#5 over</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">---&gt; Thread#2 over</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">---&gt; Thread#7 over</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">---&gt; Thread#4 over</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">---&gt; Thread#3 over</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">---&gt; Thread#8 over</span></strong><br/><strong><span class="koboSpan" id="kobo.44.1">---&gt; Thread#1 over</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.45.1">End</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.46.1">--- 9.117518663406372 seconds ---</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The feature that is most frequently associated with OOP is </span><em><span class="koboSpan" id="kobo.3.1">inheritance</span></em><span class="koboSpan" id="kobo.4.1">, which is the ability to define a new class as a modified version of an already existing class. </span><span class="koboSpan" id="kobo.4.2">The main advantage of inheritance is that you can add new methods to a class without having to change the original definition.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The original class is often referred to as the parent class and the derived class, subclass. </span><span class="koboSpan" id="kobo.5.2">Inheritance is a powerful feature, and some programs can be written much more easily and concisely, providing the possibility to customize the behavior of a class without modifying the original class. </span><span class="koboSpan" id="kobo.5.3">The very fact that the inheritance structure can reflect that of the problem can, in some cases, make the program easier to understand.</span></p>
<p><span class="koboSpan" id="kobo.6.1">However (to put the user on guard!), inheritance can make it more difficult to read the program. </span><span class="koboSpan" id="kobo.6.2">This is because, when invoking a method, it is not always clear where this has been defined within the code that must be traced within multiple modules, instead of being in a single well-defined place.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Many of the things that can be done with inheritance can usually be managed elegantly even without it, so it is appropriate to </span><span><span class="koboSpan" id="kobo.8.1">only</span></span><span class="koboSpan" id="kobo.9.1"> use inheritance if the structure of the problem requires it. </span><span class="koboSpan" id="kobo.9.2">If used at the wrong time, then the harm </span><span><span class="koboSpan" id="kobo.10.1">inheritance</span></span><span class="koboSpan" id="kobo.11.1"> can cause can outweigh the benefits of using it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread synchronization with a lock</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">threading</span></kbd><span class="koboSpan" id="kobo.4.1"> module also includes a simple lock mechanism, which allows us to implement synchronization between threads.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><em><span class="koboSpan" id="kobo.3.1">lock</span></em><span class="koboSpan" id="kobo.4.1"> is nothing more than an object that is typically accessible by multiple threads, which a thread </span><span><span class="koboSpan" id="kobo.5.1">must possess</span></span><span class="koboSpan" id="kobo.6.1"> before it can proceed to the execution of a protected section of a program. </span><span class="koboSpan" id="kobo.6.2">These locks are created by executing the </span><kbd><span class="koboSpan" id="kobo.7.1">Lock()</span></kbd><span class="koboSpan" id="kobo.8.1"> method, which is defined in the </span><kbd><span class="koboSpan" id="kobo.9.1">threading</span></kbd><span class="koboSpan" id="kobo.10.1"> module.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Once the lock has been created, we can use two methods that allow us to synchronize the execution of two (or more) threads: the </span><kbd><span class="koboSpan" id="kobo.12.1">acquire()</span></kbd><span class="koboSpan" id="kobo.13.1"> method to acquire the lock control, and the </span><kbd><span class="koboSpan" id="kobo.14.1">release()</span></kbd><span class="koboSpan" id="kobo.15.1"> method to release it.</span></p>
<p><span class="koboSpan" id="kobo.16.1">The </span><kbd><span class="koboSpan" id="kobo.17.1">acquire()</span></kbd><span class="koboSpan" id="kobo.18.1"> method accepts an optional parameter that, if not specified or set to </span><kbd><span class="koboSpan" id="kobo.19.1">True</span></kbd><span class="koboSpan" id="kobo.20.1">, forces the thread to suspend its execution until the lock is released and can then be acquired. </span><span class="koboSpan" id="kobo.20.2">If, on the other hand, the </span><kbd><span class="koboSpan" id="kobo.21.1">acquire()</span></kbd><span class="koboSpan" id="kobo.22.1"> method is executed with an argument equal to </span><kbd><span class="koboSpan" id="kobo.23.1">False</span></kbd><span class="koboSpan" id="kobo.24.1">, then it immediately returns a Boolean result, which is </span><kbd><span class="koboSpan" id="kobo.25.1">True</span></kbd><span class="koboSpan" id="kobo.26.1"> if the lock has been acquired, or </span><kbd><span class="koboSpan" id="kobo.27.1">False</span></kbd><span class="koboSpan" id="kobo.28.1"> otherwise.</span></p>
<p><span class="koboSpan" id="kobo.29.1">In the following example, we show the lock mechanism by modifying the code introduced in the previous recipe, </span><em><span class="koboSpan" id="kobo.30.1">Defining a thread subclass</span></em><span class="koboSpan" id="kobo.31.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The steps involved are as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">As shown in the following code block, the </span><kbd><span class="koboSpan" id="kobo.4.1">MyThreadClass</span></kbd> <span><span class="koboSpan" id="kobo.5.1">class</span></span><span class="koboSpan" id="kobo.6.1"> has been modified, introducing the </span><kbd><span class="koboSpan" id="kobo.7.1">acquire()</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">release()</span></kbd><span class="koboSpan" id="kobo.10.1"> methods within the </span><strong><kbd><span class="koboSpan" id="kobo.11.1">run</span></kbd></strong><span class="koboSpan" id="kobo.12.1"> method, while the </span><kbd><span class="koboSpan" id="kobo.13.1">Lock()</span></kbd><span class="koboSpan" id="kobo.14.1"> definition is outside the definition of the class itself:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.15.1">import threading</span><br/><span class="koboSpan" id="kobo.16.1">import time</span><br/><span class="koboSpan" id="kobo.17.1">import os</span><br/><span class="koboSpan" id="kobo.18.1">from threading import Thread</span><br/><span class="koboSpan" id="kobo.19.1">from random import randint</span><br/><br/><span class="koboSpan" id="kobo.20.1"># Lock Definition</span><br/><span class="koboSpan" id="kobo.21.1">threadLock = threading.Lock()</span><br/><br/><span class="koboSpan" id="kobo.22.1">class MyThreadClass (Thread):</span><br/><span class="koboSpan" id="kobo.23.1">   def __init__(self, name, duration):</span><br/><span class="koboSpan" id="kobo.24.1">      Thread.__init__(self)</span><br/><span class="koboSpan" id="kobo.25.1">      self.name = name</span><br/><span class="koboSpan" id="kobo.26.1">      self.duration = duration</span><br/><span class="koboSpan" id="kobo.27.1">   def run(self):</span><br/><span class="koboSpan" id="kobo.28.1">      #Acquire the Lock</span><br/><span class="koboSpan" id="kobo.29.1">      threadLock.acquire() </span><br/><span class="koboSpan" id="kobo.30.1">      print ("---&gt; " + self.name + \</span><br/><span class="koboSpan" id="kobo.31.1">             " running, belonging to process ID "\</span><br/><span class="koboSpan" id="kobo.32.1">             + str(os.getpid()) + "\n")</span><br/><span class="koboSpan" id="kobo.33.1">      time.sleep(self.duration)</span><br/><span class="koboSpan" id="kobo.34.1">      print ("---&gt; " + self.name + " over\n")</span><br/><span class="koboSpan" id="kobo.35.1">      #Release the Lock</span><br/><span class="koboSpan" id="kobo.36.1">      threadLock.release()</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.37.1">The </span><kbd><span class="koboSpan" id="kobo.38.1">main()</span></kbd><span class="koboSpan" id="kobo.39.1"> function has not changed with respect to the previous code sample:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.40.1">def main():</span><br/><span class="koboSpan" id="kobo.41.1">    start_time = time.time()</span><br/><span class="koboSpan" id="kobo.42.1">    # Thread Creation</span><br/><span class="koboSpan" id="kobo.43.1">    thread1 = MyThreadClass("Thread#1 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.44.1">    thread2 = MyThreadClass("Thread#2 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.45.1">    thread3 = MyThreadClass("Thread#3 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.46.1">    thread4 = MyThreadClass("Thread#4 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.47.1">    thread5 = MyThreadClass("Thread#5 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.48.1">    thread6 = MyThreadClass("Thread#6 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.49.1">    thread7 = MyThreadClass("Thread#7 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.50.1">    thread8 = MyThreadClass("Thread#8 ", randint(1,10))</span><br/><span class="koboSpan" id="kobo.51.1">    thread9 = MyThreadClass("Thread#9 ", randint(1,10))</span><br/><br/><span class="koboSpan" id="kobo.52.1">    # Thread Running</span><br/><span class="koboSpan" id="kobo.53.1">    thread1.start()</span><br/><span class="koboSpan" id="kobo.54.1">    thread2.start()</span><br/><span class="koboSpan" id="kobo.55.1">    thread3.start()</span><br/><span class="koboSpan" id="kobo.56.1">    thread4.start()</span><br/><span class="koboSpan" id="kobo.57.1">    thread5.start()</span><br/><span class="koboSpan" id="kobo.58.1">    thread6.start()</span><br/><span class="koboSpan" id="kobo.59.1">    thread7.start()</span><br/><span class="koboSpan" id="kobo.60.1">    thread8.start()</span><br/><span class="koboSpan" id="kobo.61.1">    thread9.start()</span><br/><br/><span class="koboSpan" id="kobo.62.1">    # Thread joining</span><br/><span class="koboSpan" id="kobo.63.1">    thread1.join()</span><br/><span class="koboSpan" id="kobo.64.1">    thread2.join()</span><br/><span class="koboSpan" id="kobo.65.1">    thread3.join()</span><br/><span class="koboSpan" id="kobo.66.1">    thread4.join()</span><br/><span class="koboSpan" id="kobo.67.1">    thread5.join()</span><br/><span class="koboSpan" id="kobo.68.1">    thread6.join()</span><br/><span class="koboSpan" id="kobo.69.1">    thread7.join()</span><br/><span class="koboSpan" id="kobo.70.1">    thread8.join()</span><br/><span class="koboSpan" id="kobo.71.1">    thread9.join()</span><br/><br/><span class="koboSpan" id="kobo.72.1">    # End </span><br/><span class="koboSpan" id="kobo.73.1">    print("End")</span><br/><span class="koboSpan" id="kobo.74.1">    #Execution Time</span><br/><span class="koboSpan" id="kobo.75.1">    print("--- %s seconds ---" % (time.time() - start_time))</span><br/><br/><span class="koboSpan" id="kobo.76.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.77.1">    main()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have modified the code of the previous section by using a lock so that the threads will be executed in sequence.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The first thread acquires the lock and performs its task while the other eight remain </span><em><span class="koboSpan" id="kobo.4.1">on hold.</span></em><span class="koboSpan" id="kobo.5.1"> At the end of the execution of the first thread, that is, when the </span><kbd><span class="koboSpan" id="kobo.6.1">release()</span></kbd><span class="koboSpan" id="kobo.7.1"> method is executed, the second one will get the lock and the threads from three to eight will still be waiting until the end of the execution (that is, once again, only after running the </span><kbd><span class="koboSpan" id="kobo.8.1">release()</span></kbd><span class="koboSpan" id="kobo.9.1"> method).</span></p>
<p><span class="koboSpan" id="kobo.10.1">The </span><em><span class="koboSpan" id="kobo.11.1">lock-acquire</span></em><span class="koboSpan" id="kobo.12.1"> and </span><em><span class="koboSpan" id="kobo.13.1">lock-release</span></em><span class="koboSpan" id="kobo.14.1"> execution are repeated until the ninth thread, with the final result that as a result of the lock mechanism, this execution takes place in a sequential mode, as can be seen in the following output:</span></p>
<pre><strong><span class="koboSpan" id="kobo.15.1">---&gt; Thread#1 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">---&gt; Thread#1 over</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">---&gt; Thread#2 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">---&gt; Thread#2 over</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">---&gt; Thread#3 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">---&gt; Thread#3 over</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">---&gt; Thread#4 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">---&gt; Thread#4 over</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">---&gt; Thread#5 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">---&gt; Thread#5 over</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">---&gt; Thread#6 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">---&gt; Thread#6 over</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">---&gt; Thread#7 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">---&gt; Thread#7 over</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">---&gt; Thread#8 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">---&gt; Thread#8 over</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">---&gt; Thread#9 running, belonging to process ID 10632</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">---&gt; Thread#9 over</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.33.1">End</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.34.1">--- 47.3672661781311 seconds ---</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The insertion points of the </span><kbd><span class="koboSpan" id="kobo.3.1">acquire()</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">release()</span></kbd><span class="koboSpan" id="kobo.6.1"> methods determine the entire execution of the code. </span><span class="koboSpan" id="kobo.6.2">For this reason, it is very important that you take the time to analyze what threads you want to use and how you want to synchronize them.</span></p>
<p><span class="koboSpan" id="kobo.7.1">For example, we can change the insertion point of the </span><kbd><span class="koboSpan" id="kobo.8.1">release()</span></kbd><span class="koboSpan" id="kobo.9.1"> method in the </span><kbd><span class="koboSpan" id="kobo.10.1">MyThreadClass</span></kbd><span class="koboSpan" id="kobo.11.1"> class like so:</span></p>
<pre><span class="koboSpan" id="kobo.12.1">import threading</span><br/><span class="koboSpan" id="kobo.13.1">import time</span><br/><span class="koboSpan" id="kobo.14.1">import os</span><br/><span class="koboSpan" id="kobo.15.1">from threading import Thread</span><br/><span class="koboSpan" id="kobo.16.1">from random import randint</span><br/><br/><span class="koboSpan" id="kobo.17.1"># Lock Definition</span><br/><span class="koboSpan" id="kobo.18.1">threadLock = threading.Lock()</span><br/><br/><span class="koboSpan" id="kobo.19.1">class MyThreadClass (Thread):</span><br/><span class="koboSpan" id="kobo.20.1">   def __init__(self, name, duration):</span><br/><span class="koboSpan" id="kobo.21.1">      Thread.__init__(self)</span><br/><span class="koboSpan" id="kobo.22.1">      self.name = name</span><br/><span class="koboSpan" id="kobo.23.1">      self.duration = duration</span><br/><span class="koboSpan" id="kobo.24.1">   def run(self):</span><br/><span class="koboSpan" id="kobo.25.1">      #Acquire the Lock</span><br/><span class="koboSpan" id="kobo.26.1">      threadLock.acquire() </span><br/><span class="koboSpan" id="kobo.27.1">      print ("---&gt; " + self.name + \</span><br/><span class="koboSpan" id="kobo.28.1">             " running, belonging to process ID "\ </span><br/><span class="koboSpan" id="kobo.29.1">             + str(os.getpid()) + "\n")</span><br/><span class="koboSpan" id="kobo.30.1">      #Release the Lock in this new point</span><br/><span class="koboSpan" id="kobo.31.1">      threadLock.release()</span><br/><span class="koboSpan" id="kobo.32.1">      time.sleep(self.duration)</span><br/><span class="koboSpan" id="kobo.33.1">      print ("---&gt; " + self.name + " over\n")</span></pre>
<p><span class="koboSpan" id="kobo.34.1">In this case, the output changes quite significantly:</span></p>
<pre><strong><span class="koboSpan" id="kobo.35.1">---&gt; Thread#1 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">---&gt; Thread#2 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">---&gt; Thread#3 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.38.1">---&gt; Thread#4 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.39.1">---&gt; Thread#5 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.40.1">---&gt; Thread#6 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.41.1">---&gt; Thread#7 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.42.1">---&gt; Thread#8 running, belonging to process ID 11228</span></strong><br/><strong><span class="koboSpan" id="kobo.43.1">---&gt; Thread#9 running, belonging to process ID 11228</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.44.1">---&gt; Thread#2 over</span></strong><br/><strong><span class="koboSpan" id="kobo.45.1">---&gt; Thread#4 over</span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">---&gt; Thread#6 over</span></strong><br/><strong><span class="koboSpan" id="kobo.47.1">---&gt; Thread#5 over</span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">---&gt; Thread#1 over</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">---&gt; Thread#3 over</span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">---&gt; Thread#9 over</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">---&gt; Thread#7 over</span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">---&gt; Thread#8 over</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.53.1">End</span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">--- 6.11468243598938 seconds ---</span></strong></pre>
<p><span class="koboSpan" id="kobo.55.1">As you can see, only the thread creation happens in sequential mode. </span><span class="koboSpan" id="kobo.55.2">Once thread creation is complete, the new thread acquires the lock, while the previous one continues the computation in the background.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread synchronization with RLock</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A reentrant lock, or simply an RLock, is a synchronization primitive that can be acquired multiple times by the same thread.</span></p>
<p><span class="koboSpan" id="kobo.3.1">It uses the concept of the proprietary thread. </span><span class="koboSpan" id="kobo.3.2">This means that in the </span><em><span class="koboSpan" id="kobo.4.1">locked state</span></em><span class="koboSpan" id="kobo.5.1">, some threads own the lock, while in the </span><em><span class="koboSpan" id="kobo.6.1">unlocked state</span></em><span class="koboSpan" id="kobo.7.1">, the lock is not owned by any thread.</span></p>
<p><span class="koboSpan" id="kobo.8.1">The next example demonstrates how to manage threads through the </span><kbd><span class="koboSpan" id="kobo.9.1">RLock()</span></kbd><span class="koboSpan" id="kobo.10.1"> mechanism.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">An RLock is implemented through the </span><kbd><span class="koboSpan" id="kobo.3.1">threading.RLock()</span></kbd><span class="koboSpan" id="kobo.4.1"> class. </span><span class="koboSpan" id="kobo.4.2">It provides the </span><kbd><span class="koboSpan" id="kobo.5.1">acquire()</span></kbd><span class="koboSpan" id="kobo.6.1"> and </span><kbd><span class="koboSpan" id="kobo.7.1">release()</span></kbd><span class="koboSpan" id="kobo.8.1"> methods that have the same syntax as the </span><kbd><span class="koboSpan" id="kobo.9.1">threading.Lock()</span></kbd><span class="koboSpan" id="kobo.10.1"> class.</span></p>
<p><span class="koboSpan" id="kobo.11.1">An </span><kbd><span class="koboSpan" id="kobo.12.1">RLock</span></kbd><span class="koboSpan" id="kobo.13.1"> block can be acquired multiple times by the same thread. </span><span class="koboSpan" id="kobo.13.2">Other threads will not be able to acquire the </span><kbd><span class="koboSpan" id="kobo.14.1">RLock</span></kbd><span class="koboSpan" id="kobo.15.1"> block until the thread that owns it has made a </span><kbd><span class="koboSpan" id="kobo.16.1">release()</span></kbd><span class="koboSpan" id="kobo.17.1"> call for every previous </span><kbd><span class="koboSpan" id="kobo.18.1">acquire()</span></kbd><span class="koboSpan" id="kobo.19.1"> call. </span><span class="koboSpan" id="kobo.19.2">Indeed, the </span><kbd><span class="koboSpan" id="kobo.20.1">RLock</span></kbd><span class="koboSpan" id="kobo.21.1"> block must be released, but only by the thread that acquired it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The steps involved are as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">We introduced the </span><kbd><span class="koboSpan" id="kobo.4.1">Box</span></kbd><span class="koboSpan" id="kobo.5.1"> class, which provides the </span><kbd><span class="koboSpan" id="kobo.6.1">add()</span></kbd><span class="koboSpan" id="kobo.7.1"> and </span><kbd><span class="koboSpan" id="kobo.8.1">remove()</span></kbd><span class="koboSpan" id="kobo.9.1"> methods that access the </span><kbd><span class="koboSpan" id="kobo.10.1">execute()</span></kbd><span class="koboSpan" id="kobo.11.1"> method in order to perform the action to add or delete an item, </span><span><span class="koboSpan" id="kobo.12.1">respectively</span></span><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">Access to the </span><kbd><span class="koboSpan" id="kobo.14.1">execute()</span></kbd><span class="koboSpan" id="kobo.15.1"> method is regulated by </span><kbd><span class="koboSpan" id="kobo.16.1">RLock()</span></kbd><span class="koboSpan" id="kobo.17.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.18.1">import threading</span><br/><span class="koboSpan" id="kobo.19.1">import time</span><br/><span class="koboSpan" id="kobo.20.1">import random</span><br/><br/><span class="koboSpan" id="kobo.21.1">class Box:</span><br/><span class="koboSpan" id="kobo.22.1">    def __init__(self):</span><br/><span class="koboSpan" id="kobo.23.1">        self.lock = threading.RLock()</span><br/><span class="koboSpan" id="kobo.24.1">        self.total_items = 0</span><br/><br/><span class="koboSpan" id="kobo.25.1">    def execute(self, value):</span><br/><span class="koboSpan" id="kobo.26.1">        with self.lock:</span><br/><span class="koboSpan" id="kobo.27.1">            self.total_items += value</span><br/><br/><span class="koboSpan" id="kobo.28.1">    def add(self):</span><br/><span class="koboSpan" id="kobo.29.1">        with self.lock:</span><br/><span class="koboSpan" id="kobo.30.1">            self.execute(1)</span><br/><br/><span class="koboSpan" id="kobo.31.1">    def remove(self):</span><br/><span class="koboSpan" id="kobo.32.1">        with self.lock:</span><br/><span class="koboSpan" id="kobo.33.1">            self.execute(-1)</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.34.1">The following functions are called by the two threads. </span><span class="koboSpan" id="kobo.34.2">They have the </span><kbd><span class="koboSpan" id="kobo.35.1">box</span></kbd><span><span class="koboSpan" id="kobo.36.1"> class </span></span><span class="koboSpan" id="kobo.37.1">and the total number of </span><kbd><span class="koboSpan" id="kobo.38.1">items</span></kbd><span class="koboSpan" id="kobo.39.1"> to add or to remove as parameters:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.40.1">def adder(box, items):</span><br/><span class="koboSpan" id="kobo.41.1">    print("N° {} items to ADD \n".format(items))</span><br/><span class="koboSpan" id="kobo.42.1">    while items:</span><br/><span class="koboSpan" id="kobo.43.1">        box.add()</span><br/><span class="koboSpan" id="kobo.44.1">        time.sleep(1)</span><br/><span class="koboSpan" id="kobo.45.1">        items -= 1</span><br/><span class="koboSpan" id="kobo.46.1">        print("ADDED one item --&gt;{} item to ADD \n".format(items))</span><br/><br/><span class="koboSpan" id="kobo.47.1">def remover(box, items):</span><br/><span class="koboSpan" id="kobo.48.1">    print("N° {} items to REMOVE\n".format(items))</span><br/><span class="koboSpan" id="kobo.49.1">    while items:</span><br/><span class="koboSpan" id="kobo.50.1">        box.remove()</span><br/><span class="koboSpan" id="kobo.51.1">        time.sleep(1)</span><br/><span class="koboSpan" id="kobo.52.1">        items -= 1</span><br/><span class="koboSpan" id="kobo.53.1">        print("REMOVED one item --&gt;{} item to REMOVE\</span><br/><span class="koboSpan" id="kobo.54.1">            \n".format(items))</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.55.1">Here, the total number of items to add or to remove from the box is set. </span><span class="koboSpan" id="kobo.55.2">As you can see, these two numbers will be different. </span><span class="koboSpan" id="kobo.55.3">The execution ends when both the </span><kbd><span class="koboSpan" id="kobo.56.1">adder</span></kbd><span class="koboSpan" id="kobo.57.1"> and </span><kbd><span class="koboSpan" id="kobo.58.1">remover</span></kbd> <span><span class="koboSpan" id="kobo.59.1">methods</span></span><span class="koboSpan" id="kobo.60.1"> accomplish their tasks:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.61.1">def main():</span><br/><span class="koboSpan" id="kobo.62.1">    items = 10</span><br/><span class="koboSpan" id="kobo.63.1">    box = Box()</span><br/><br/><span class="koboSpan" id="kobo.64.1">    t1 = threading.Thread(target=adder, \</span><br/><span class="koboSpan" id="kobo.65.1">                          args=(box, random.randint(10,20)))</span><br/><span class="koboSpan" id="kobo.66.1">    t2 = threading.Thread(target=remover, \</span><br/><span class="koboSpan" id="kobo.67.1">                          args=(box, random.randint(1,10)))</span><br/>    <br/><span class="koboSpan" id="kobo.68.1">    t1.start()</span><br/><span class="koboSpan" id="kobo.69.1">    t2.start()</span><br/><br/><span class="koboSpan" id="kobo.70.1">    t1.join()</span><br/><span class="koboSpan" id="kobo.71.1">    t2.join()</span><br/>    <br/><span class="koboSpan" id="kobo.72.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.73.1">    main()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In the </span><kbd><span class="koboSpan" id="kobo.3.1">main</span></kbd><span class="koboSpan" id="kobo.4.1"> program, the two threads of </span><kbd><span class="koboSpan" id="kobo.5.1">t1</span></kbd><span class="koboSpan" id="kobo.6.1"> and </span><kbd><span class="koboSpan" id="kobo.7.1">t2</span></kbd><span class="koboSpan" id="kobo.8.1"> have been associated with the </span><kbd><span class="koboSpan" id="kobo.9.1">adder()</span></kbd><span class="koboSpan" id="kobo.10.1"> and </span><kbd><span class="koboSpan" id="kobo.11.1">remover()</span></kbd> <span><span class="koboSpan" id="kobo.12.1">functions.</span></span><span class="koboSpan" id="kobo.13.1"> The functions are active if the number of items is greater than zero.</span></p>
<p><span class="koboSpan" id="kobo.14.1">The call to </span><kbd><span class="koboSpan" id="kobo.15.1">RLock()</span></kbd><span class="koboSpan" id="kobo.16.1"> is carried out inside the </span><kbd><span class="koboSpan" id="kobo.17.1">__init__</span></kbd><span class="koboSpan" id="kobo.18.1"> method of the </span><strong><kbd><span class="koboSpan" id="kobo.19.1">Box</span></kbd></strong><span class="koboSpan" id="kobo.20.1"> class:</span></p>
<pre><span class="koboSpan" id="kobo.21.1">class Box:</span><br/><span class="koboSpan" id="kobo.22.1">    def __init__(self):</span><br/><span class="koboSpan" id="kobo.23.1">        self.lock = threading.RLock()</span><br/><span class="koboSpan" id="kobo.24.1">        self.total_items = 0</span></pre>
<p><span class="koboSpan" id="kobo.25.1">The two </span><kbd><span class="koboSpan" id="kobo.26.1">adder()</span></kbd><span class="koboSpan" id="kobo.27.1"> and </span><kbd><span class="koboSpan" id="kobo.28.1">remover()</span></kbd> <span><span class="koboSpan" id="kobo.29.1">functions</span></span><span class="koboSpan" id="kobo.30.1"> interact with the items of the </span><kbd><span class="koboSpan" id="kobo.31.1">Box</span></kbd><span class="koboSpan" id="kobo.32.1"> class, respectively, and call the </span><kbd><span class="koboSpan" id="kobo.33.1">Box</span></kbd><span class="koboSpan" id="kobo.34.1"> class methods of </span><kbd><span class="koboSpan" id="kobo.35.1">add()</span></kbd><span class="koboSpan" id="kobo.36.1"> and </span><kbd><span class="koboSpan" id="kobo.37.1">remove()</span></kbd><span class="koboSpan" id="kobo.38.1">.</span></p>
<p><span class="koboSpan" id="kobo.39.1">In each method call, a resource is captured and then released using the </span><kbd><span class="koboSpan" id="kobo.40.1">lock</span></kbd><span class="koboSpan" id="kobo.41.1"> parameter that is set in the </span><kbd><span class="koboSpan" id="kobo.42.1">_init_</span></kbd><span class="koboSpan" id="kobo.43.1"> method.</span></p>
<p><span class="koboSpan" id="kobo.44.1">Here is the output:</span></p>
<pre><strong><span class="koboSpan" id="kobo.45.1">N° 16 items to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.46.1">N° 1 items to REMOVE </span></strong><br/><br/><br/><strong><span class="koboSpan" id="kobo.47.1">ADDED one item --&gt;15 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.48.1">REMOVED one item --&gt;0 item to REMOVE </span></strong><br/><br/><br/><strong><span class="koboSpan" id="kobo.49.1">ADDED one item --&gt;14 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.50.1">ADDED one item --&gt;13 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">ADDED one item --&gt;12 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.52.1">ADDED one item --&gt;11 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">ADDED one item --&gt;10 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.54.1">ADDED one item --&gt;9 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">ADDED one item --&gt;8 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.56.1">ADDED one item --&gt;7 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">ADDED one item --&gt;6 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.58.1">ADDED one item --&gt;5 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.59.1">ADDED one item --&gt;4 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.60.1">ADDED one item --&gt;3 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.61.1">ADDED one item --&gt;2 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.62.1">ADDED one item --&gt;1 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.63.1">ADDED one item --&gt;0 item to ADD </span></strong><br/><strong><span class="koboSpan" id="kobo.64.1">&gt;&gt;&gt;</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p class="packt_figure"><span class="koboSpan" id="kobo.2.1">The differences between </span><em><span class="koboSpan" id="kobo.3.1">lock</span></em><span class="koboSpan" id="kobo.4.1"> and </span><em><span class="koboSpan" id="kobo.5.1">RLock</span></em><span class="koboSpan" id="kobo.6.1"> are as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">A </span><em><span class="koboSpan" id="kobo.8.1">lock</span></em><span class="koboSpan" id="kobo.9.1"> can only be acquired once before it must be released. </span><span class="koboSpan" id="kobo.9.2">However, </span><kbd><span class="koboSpan" id="kobo.10.1">RLock</span></kbd><span class="koboSpan" id="kobo.11.1"> can be acquired multiple times from the same thread; it must be released the same number of times in order to be released.</span></li>
<li><span class="koboSpan" id="kobo.12.1">Another difference is that an acquired lock can be released by any thread, whereas an acquired </span><kbd><span class="koboSpan" id="kobo.13.1">RLock</span></kbd><span class="koboSpan" id="kobo.14.1"> can only be released by the thread that acquired it.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread synchronization with semaphores</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><strong><span class="koboSpan" id="kobo.3.1">semaphore</span></strong><span class="koboSpan" id="kobo.4.1"> is an abstract data type managed by the OS to synchronize access by multiple threads to shared resources and data. </span><span class="koboSpan" id="kobo.4.2">It consists of an internal variable that identifies the amount of concurrent access to a resource with which it is associated.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The operation of a semaphore is based on two </span><span><span class="koboSpan" id="kobo.3.1">functions:</span></span> <kbd><span class="koboSpan" id="kobo.4.1">acquire()</span></kbd><span class="koboSpan" id="kobo.5.1"> and </span><kbd><span class="koboSpan" id="kobo.6.1">release()</span></kbd><span class="koboSpan" id="kobo.7.1">, as explained here:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Whenever a thread wants to access a given or a resource that is associated with a semaphore, it must invoke the </span><kbd><span class="koboSpan" id="kobo.9.1">acquire()</span></kbd><span class="koboSpan" id="kobo.10.1"> operation, which </span><em><span class="koboSpan" id="kobo.11.1">decreases the internal variable of the semaphore</span></em><span class="koboSpan" id="kobo.12.1"> and allows access to the resource if the value of this variable appears to be non-negative. </span><span class="koboSpan" id="kobo.12.2">If the value is negative, then the thread will be suspended and the release of the resource by another thread will be placed on hold.</span></li>
<li><span class="koboSpan" id="kobo.13.1">Having finished using shared resources, the thread frees resources through the </span><kbd><span class="koboSpan" id="kobo.14.1">release()</span></kbd><span class="koboSpan" id="kobo.15.1"> instruction. </span><span class="koboSpan" id="kobo.15.2">In this way, the internal variable of the semaphore is increased, allowing, for a </span><em><span class="koboSpan" id="kobo.16.1">waiting</span></em><span class="koboSpan" id="kobo.17.1"> thread (if any), the opportunity to access the newly freed resource.</span></li>
</ul>
<p><span><span class="koboSpan" id="kobo.18.1">The semaphore is one of the oldest synchronization primitives in the history of computer science, invented by the early Dutch computer scientist Edsger W. </span><span class="koboSpan" id="kobo.18.2">Dijkstra</span></span><span><span class="koboSpan" id="kobo.19.1">.</span></span></p>
<p><span><span class="koboSpan" id="kobo.20.1">The following example shows how to synchronize threads through a semaphore.</span></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The following code describes a problem where we have two threads, </span><kbd><span class="koboSpan" id="kobo.3.1">producer()</span></kbd><span class="koboSpan" id="kobo.4.1"> and </span><kbd><span class="koboSpan" id="kobo.5.1">consumer()</span></kbd><span class="koboSpan" id="kobo.6.1">, that share a common resource, which is the item. </span><span class="koboSpan" id="kobo.6.2">The task of </span><kbd><span class="koboSpan" id="kobo.7.1">producer()</span></kbd><span class="koboSpan" id="kobo.8.1"> is to generate the item while the </span><kbd><span class="koboSpan" id="kobo.9.1">consumer()</span></kbd><span class="koboSpan" id="kobo.10.1"> thread's task is to use the item that has been produced.</span></p>
<p><span class="koboSpan" id="kobo.11.1">If the item has not yet produced the </span><kbd><span class="koboSpan" id="kobo.12.1">consumer()</span></kbd><span class="koboSpan" id="kobo.13.1"> thread, then it has to wait. </span><span class="koboSpan" id="kobo.13.2">As soon as the item is produced, the </span><kbd><span class="koboSpan" id="kobo.14.1">producer()</span></kbd><span class="koboSpan" id="kobo.15.1"> thread notifies the consumer that the resource should be used:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.16.1">By initializing a semaphore to </span><kbd><span class="koboSpan" id="kobo.17.1">0</span></kbd><span class="koboSpan" id="kobo.18.1">, we obtain a so-called semaphore event whose sole purpose is to synchronize the computation of two or more threads. </span><span class="koboSpan" id="kobo.18.2">Here, a thread must make use of data or common resources simultaneously:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.19.1">semaphore = threading.Semaphore(0)</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.20.1">This operation is very similar to that described in the lock mechanism of the lock. </span><span class="koboSpan" id="kobo.20.2">The </span><kbd><span class="koboSpan" id="kobo.21.1">producer()</span></kbd><span class="koboSpan" id="kobo.22.1"> thread creates the item and, after that, it frees the resource by calling the </span><kbd><span class="koboSpan" id="kobo.23.1">release()</span></kbd><span class="koboSpan" id="kobo.24.1"> method:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.25.1">semaphore.release()</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.26.1">Similarly, the </span><kbd><span class="koboSpan" id="kobo.27.1">consumer()</span></kbd> <span><span class="koboSpan" id="kobo.28.1">thread</span></span><span class="koboSpan" id="kobo.29.1"> acquires the data by the </span><kbd><span class="koboSpan" id="kobo.30.1">acquire()</span></kbd><span class="koboSpan" id="kobo.31.1"> method. </span><span class="koboSpan" id="kobo.31.2">If the semaphore's counter is equal to </span><kbd><span class="koboSpan" id="kobo.32.1">0</span></kbd><span class="koboSpan" id="kobo.33.1">, then it blocks the condition's </span><kbd><span class="koboSpan" id="kobo.34.1">acquire()</span></kbd><span class="koboSpan" id="kobo.35.1"> method until it gets notified by a different thread. </span><span class="koboSpan" id="kobo.35.2">If the semaphore's counter is greater than </span><kbd><span class="koboSpan" id="kobo.36.1">0</span></kbd><span class="koboSpan" id="kobo.37.1">, then it decrements the value. </span><span class="koboSpan" id="kobo.37.2">When the producer creates an item, it releases the semaphore, and then the consumer acquires it and consumes </span><span><span class="koboSpan" id="kobo.38.1">the shared resource:</span></span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.39.1">semaphore.acquire()</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.40.1">The synchronization process that is done via the semaphores is shown in the following code block:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.41.1">import logging</span><br/><span class="koboSpan" id="kobo.42.1">import threading</span><br/><span class="koboSpan" id="kobo.43.1">import time</span><br/><span class="koboSpan" id="kobo.44.1">import random</span><br/><br/><span class="koboSpan" id="kobo.45.1">LOG_FORMAT = '%(asctime)s %(threadName)-17s %(levelname)-8s %\</span><br/><span class="koboSpan" id="kobo.46.1">              (message)s'</span><br/><span class="koboSpan" id="kobo.47.1">logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)</span><br/><br/><span class="koboSpan" id="kobo.48.1">semaphore = threading.Semaphore(0)</span><br/><span class="koboSpan" id="kobo.49.1">item = 0</span><br/><br/><span class="koboSpan" id="kobo.50.1">def consumer():</span><br/><span class="koboSpan" id="kobo.51.1">    logging.info('Consumer is waiting')</span><br/><span class="koboSpan" id="kobo.52.1">    semaphore.acquire()</span><br/><span class="koboSpan" id="kobo.53.1">    logging.info('Consumer notify: item number {}'.format(item))</span><br/><br/><span class="koboSpan" id="kobo.54.1">def producer():</span><br/><span class="koboSpan" id="kobo.55.1">    global item</span><br/><span class="koboSpan" id="kobo.56.1">    time.sleep(3)</span><br/><span class="koboSpan" id="kobo.57.1">    item = random.randint(0, 1000)</span><br/><span class="koboSpan" id="kobo.58.1">    logging.info('Producer notify: item number {}'.format(item))</span><br/><span class="koboSpan" id="kobo.59.1">    semaphore.release()</span><br/><br/><span class="koboSpan" id="kobo.60.1">#Main program</span><br/><span class="koboSpan" id="kobo.61.1">def main():</span><br/><span class="koboSpan" id="kobo.62.1">    for i in range(10):</span><br/><span class="koboSpan" id="kobo.63.1">        t1 = threading.Thread(target=consumer)</span><br/><span class="koboSpan" id="kobo.64.1">        t2 = threading.Thread(target=producer)</span><br/><br/><span class="koboSpan" id="kobo.65.1">        t1.start()</span><br/><span class="koboSpan" id="kobo.66.1">        t2.start()</span><br/><br/><span class="koboSpan" id="kobo.67.1">        t1.join()</span><br/><span class="koboSpan" id="kobo.68.1">        t2.join()</span><br/><br/><span class="koboSpan" id="kobo.69.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.70.1">    main()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The data </span><span><span class="koboSpan" id="kobo.3.1">acquired </span></span><span class="koboSpan" id="kobo.4.1">is then printed on the standard output:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">print ("Consumer notify : consumed item number %s " %item)</span></pre>
<p><span class="koboSpan" id="kobo.6.1">This is the result that we get after 10 runs:</span></p>
<pre><strong><span class="koboSpan" id="kobo.7.1">2019-01-27 19:21:19,354 Thread-1 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.8.1">2019-01-27 19:21:22,360 Thread-2 INFO Producer notify: item number 388</span></strong><br/><strong><span class="koboSpan" id="kobo.9.1">2019-01-27 19:21:22,385 Thread-1 INFO Consumer notify: item number 388</span></strong><br/><strong><span class="koboSpan" id="kobo.10.1">2019-01-27 19:21:22,395 Thread-3 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.11.1">2019-01-27 19:21:25,398 Thread-4 INFO Producer notify: item number 939</span></strong><br/><strong><span class="koboSpan" id="kobo.12.1">2019-01-27 19:21:25,450 Thread-3 INFO Consumer notify: item number 939</span></strong><br/><strong><span class="koboSpan" id="kobo.13.1">2019-01-27 19:21:25,453 Thread-5 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.14.1">2019-01-27 19:21:28,459 Thread-6 INFO Producer notify: item number 388</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">2019-01-27 19:21:28,468 Thread-5 INFO Consumer notify: item number 388</span></strong><br/><strong><span class="koboSpan" id="kobo.16.1">2019-01-27 19:21:28,476 Thread-7 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.17.1">2019-01-27 19:21:31,478 Thread-8 INFO Producer notify: item number 700</span></strong><br/><strong><span class="koboSpan" id="kobo.18.1">2019-01-27 19:21:31,529 Thread-7 INFO Consumer notify: item number 700</span></strong><br/><strong><span class="koboSpan" id="kobo.19.1">2019-01-27 19:21:31,538 Thread-9 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.20.1">2019-01-27 19:21:34,539 Thread-10 INFO Producer notify: item number 685</span></strong><br/><strong><span class="koboSpan" id="kobo.21.1">2019-01-27 19:21:34,593 Thread-9 INFO Consumer notify: item number 685</span></strong><br/><strong><span class="koboSpan" id="kobo.22.1">2019-01-27 19:21:34,603 Thread-11 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.23.1">2019-01-27 19:21:37,604 Thread-12 INFO Producer notify: item number 503</span></strong><br/><strong><span class="koboSpan" id="kobo.24.1">2019-01-27 19:21:37,658 Thread-11 INFO Consumer notify: item number 503</span></strong><br/><strong><span class="koboSpan" id="kobo.25.1">2019-01-27 19:21:37,668 Thread-13 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">2019-01-27 19:21:40,670 Thread-14 INFO Producer notify: item number 690</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">2019-01-27 19:21:40,719 Thread-13 INFO Consumer notify: item number 690</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">2019-01-27 19:21:40,729 Thread-15 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">2019-01-27 19:21:43,731 Thread-16 INFO Producer notify: item number 873</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">2019-01-27 19:21:43,788 Thread-15 INFO Consumer notify: item number 873</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">2019-01-27 19:21:43,802 Thread-17 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">2019-01-27 19:21:46,807 Thread-18 INFO Producer notify: item number 691</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">2019-01-27 19:21:46,861 Thread-17 INFO Consumer notify: item number 691</span></strong><br/><strong><span class="koboSpan" id="kobo.34.1">2019-01-27 19:21:46,874 Thread-19 INFO Consumer is waiting</span></strong><br/><strong><span class="koboSpan" id="kobo.35.1">2019-01-27 19:21:49,876 Thread-20 INFO Producer notify: item number 138</span></strong><br/><strong><span class="koboSpan" id="kobo.36.1">2019-01-27 19:21:49,924 Thread-19 INFO Consumer notify: item number 138</span></strong><br/><strong><span class="koboSpan" id="kobo.37.1">&gt;&gt;&gt;</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A particular use of semaphores is the </span><em><span class="koboSpan" id="kobo.3.1">mutex</span></em><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">A mutex is nothing but a semaphore with an internal variable initialized to the value of </span><kbd><span class="koboSpan" id="kobo.5.1">1</span></kbd><span class="koboSpan" id="kobo.6.1">, which allows the realization of mutual exclusion in access to data and resources.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Semaphores are still commonly used in programming languages that are multithreaded; however, they have two major problems, which we have discussed, as follows:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">They do not prevent the possibility of a thread performing more </span><span><span class="koboSpan" id="kobo.9.1">wait</span></span><span class="koboSpan" id="kobo.10.1"> operations on the same semaphore. </span><span class="koboSpan" id="kobo.10.2">It is very easy to forget to do all the necessary signals in relation to the number of waits performed.</span></li>
<li><span class="koboSpan" id="kobo.11.1">You can run into situations of deadlock. </span><span class="koboSpan" id="kobo.11.2">For example, a deadlock situation </span><span><span class="koboSpan" id="kobo.12.1">is</span></span><span class="koboSpan" id="kobo.13.1"> created when the </span><kbd><span class="koboSpan" id="kobo.14.1">t1</span></kbd> <span><span class="koboSpan" id="kobo.15.1">thread</span></span><span class="koboSpan" id="kobo.16.1"> executes a wait on the </span><kbd><span class="koboSpan" id="kobo.17.1">s1</span></kbd> <span><span class="koboSpan" id="kobo.18.1">semaphore,</span></span><span class="koboSpan" id="kobo.19.1"> while the </span><strong><kbd><span class="koboSpan" id="kobo.20.1">t2</span></kbd></strong><span class="koboSpan" id="kobo.21.1"> thread executes a wait on the thread </span><kbd><span class="koboSpan" id="kobo.22.1">t1</span></kbd><span class="koboSpan" id="kobo.23.1">, executes a wait on </span><kbd><span class="koboSpan" id="kobo.24.1">s2</span></kbd><span class="koboSpan" id="kobo.25.1"> and </span><kbd><span class="koboSpan" id="kobo.26.1">t2</span></kbd><span class="koboSpan" id="kobo.27.1">, and then executes a wait on </span><kbd><span class="koboSpan" id="kobo.28.1">s1</span></kbd><span class="koboSpan" id="kobo.29.1">.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread synchronization with a condition</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A </span><em><span class="koboSpan" id="kobo.3.1">condition</span></em><span class="koboSpan" id="kobo.4.1"> identifies a change of state in the application. </span><span class="koboSpan" id="kobo.4.2">It is a synchronization mechanism where a thread waits for a specific condition and another thread notifies that this </span><em><span class="koboSpan" id="kobo.5.1">condition has taken place</span></em><span class="koboSpan" id="kobo.6.1">.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Once the condition takes place, the thread </span><em><span class="koboSpan" id="kobo.8.1">acquires</span></em><span class="koboSpan" id="kobo.9.1"> the lock in order to get </span><em><span class="koboSpan" id="kobo.10.1">exclusive access</span></em><span class="koboSpan" id="kobo.11.1"> to the shared resource.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">A good way to illustrate this mechanism is by looking again at a producer/consumer problem. </span><span class="koboSpan" id="kobo.2.2">The class producer writes to a buffer if it is not full, and the class consumer takes the data from the buffer (eliminating them from the latter) if the buffer is full. </span><span class="koboSpan" id="kobo.2.3">The class producer will notify the consumer that the buffer is not empty, while the consumer will report to the producer that the buffer is not full.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The steps involved are as follows:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.3.1">The class consumer acquires the shared resource that is modelled through the </span><strong><kbd><span class="koboSpan" id="kobo.4.1">items[]</span></kbd></strong><span class="koboSpan" id="kobo.5.1"> list:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.6.1">condition.acquire()</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.7.1">If the length of the list is equal to </span><kbd><span class="koboSpan" id="kobo.8.1">0</span></kbd><span class="koboSpan" id="kobo.9.1">, then the consumer is placed in a waiting state:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.10.1">if len(items) == 0:</span><br/><span class="koboSpan" id="kobo.11.1">   condition.wait()</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.12.1">Then it makes </span><span class="hps"><span class="koboSpan" id="kobo.13.1">a </span></span><strong><kbd><span class="koboSpan" id="kobo.14.1">pop</span></kbd></strong><span class="koboSpan" id="kobo.15.1"> operation from the items list:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.16.1">items.pop()</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.17.1">So, the consumer's state is notified to the producer and the shared resource is released:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.18.1">condition.notify()</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.19.1">The class producer acquires the shared resource and then it verifies that the list is completely full (in our example, we place the maximum number of items, </span><kbd><span class="koboSpan" id="kobo.20.1">10</span></kbd><span class="koboSpan" id="kobo.21.1">, that can be contained in the items list). </span><span class="koboSpan" id="kobo.21.2">If the list is full, then the producer is placed in the wait state until the list is consumed:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.22.1">condition.acquire()</span><br/><span class="koboSpan" id="kobo.23.1">if len(items) == 10:</span><br/><span class="koboSpan" id="kobo.24.1">   condition.wait()</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.25.1">If the list is not full, then a single item is added. </span><span class="koboSpan" id="kobo.25.2">The state is notified and the resource is released:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.26.1">condition.notify()</span><br/><span class="koboSpan" id="kobo.27.1">condition.release()</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.28.1">To show you the condition mechanism, we will use the </span><em><span class="koboSpan" id="kobo.29.1">consumer/producer</span></em><span class="koboSpan" id="kobo.30.1"> model </span><span><span class="koboSpan" id="kobo.31.1">again</span></span><span class="koboSpan" id="kobo.32.1">:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.33.1">import logging</span><br/><span class="koboSpan" id="kobo.34.1">import threading</span><br/><span class="koboSpan" id="kobo.35.1">import time</span><br/><br/><span class="koboSpan" id="kobo.36.1">LOG_FORMAT = '%(asctime)s %(threadName)-17s %(levelname)-8s %\</span><br/><span class="koboSpan" id="kobo.37.1">             (message)s'</span><br/><span class="koboSpan" id="kobo.38.1">logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)</span><br/><br/><span class="koboSpan" id="kobo.39.1">items = []</span><br/><span class="koboSpan" id="kobo.40.1">condition = threading.Condition()</span><br/><br/><br/><span class="koboSpan" id="kobo.41.1">class Consumer(threading.Thread):</span><br/><span class="koboSpan" id="kobo.42.1">    def __init__(self, *args, **kwargs):</span><br/><span class="koboSpan" id="kobo.43.1">        super().__init__(*args, **kwargs)</span><br/><br/><span class="koboSpan" id="kobo.44.1">    def consume(self):</span><br/><br/><span class="koboSpan" id="kobo.45.1">        with condition:</span><br/><br/><span class="koboSpan" id="kobo.46.1">            if len(items) == 0:</span><br/><span class="koboSpan" id="kobo.47.1">                logging.info('no items to consume')</span><br/><span class="koboSpan" id="kobo.48.1">                condition.wait()</span><br/><br/><span class="koboSpan" id="kobo.49.1">            items.pop()</span><br/><span class="koboSpan" id="kobo.50.1">            logging.info('consumed 1 item')</span><br/><br/><span class="koboSpan" id="kobo.51.1">            condition.notify()</span><br/><br/><span class="koboSpan" id="kobo.52.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.53.1">        for i in range(20):</span><br/><span class="koboSpan" id="kobo.54.1">            time.sleep(2)</span><br/><span class="koboSpan" id="kobo.55.1">            self.consume()</span><br/><br/><br/><span class="koboSpan" id="kobo.56.1">class Producer(threading.Thread):</span><br/><span class="koboSpan" id="kobo.57.1">    def __init__(self, *args, **kwargs):</span><br/><span class="koboSpan" id="kobo.58.1">        super().__init__(*args, **kwargs)</span><br/><br/><span class="koboSpan" id="kobo.59.1">    def produce(self):</span><br/><br/><span class="koboSpan" id="kobo.60.1">        with condition:</span><br/><br/><span class="koboSpan" id="kobo.61.1">            if len(items) == 10:</span><br/><span class="koboSpan" id="kobo.62.1">                logging.info('items produced {}.\</span><br/><span class="koboSpan" id="kobo.63.1">                    Stopped'.format(len(items)))</span><br/><span class="koboSpan" id="kobo.64.1">                condition.wait()</span><br/><br/><span class="koboSpan" id="kobo.65.1">            items.append(1)</span><br/><span class="koboSpan" id="kobo.66.1">            logging.info('total items {}'.format(len(items)))</span><br/><br/><span class="koboSpan" id="kobo.67.1">            condition.notify()</span><br/><br/><span class="koboSpan" id="kobo.68.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.69.1">        for i in range(20):</span><br/><span class="koboSpan" id="kobo.70.1">            time.sleep(0.5)</span><br/><span class="koboSpan" id="kobo.71.1">            self.produce()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">producer</span></kbd><span class="koboSpan" id="kobo.3.1"> generates the item and stores it in the buffer continuously. </span><span class="koboSpan" id="kobo.3.2">At the same time, </span><kbd><span class="koboSpan" id="kobo.4.1">consumer</span></kbd><span class="koboSpan" id="kobo.5.1"> uses the data produced, removing it </span><span><span class="koboSpan" id="kobo.6.1">from the buffer</span></span><span class="koboSpan" id="kobo.7.1"> from time to time.</span></p>
<p><span class="koboSpan" id="kobo.8.1">As soon as </span><kbd><span class="koboSpan" id="kobo.9.1">consumer</span></kbd><span class="koboSpan" id="kobo.10.1"> has picked up an object from the buffer, it will wake up </span><kbd><span class="koboSpan" id="kobo.11.1">producer</span></kbd><span class="koboSpan" id="kobo.12.1">, who will start to fill the buffer again.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Similarly, </span><kbd><span class="koboSpan" id="kobo.14.1">consumer</span></kbd><span class="koboSpan" id="kobo.15.1"> will suspend if the buffer is empty. </span><span class="koboSpan" id="kobo.15.2">As soon as </span><kbd><span class="koboSpan" id="kobo.16.1">producer</span></kbd><span class="koboSpan" id="kobo.17.1"> has downloaded the data into the buffer, </span><kbd><span class="koboSpan" id="kobo.18.1">consumer</span></kbd><span class="koboSpan" id="kobo.19.1"> will wake up.</span></p>
<p><span class="koboSpan" id="kobo.20.1">As you can see, even in this case, the use of the </span><kbd><span class="koboSpan" id="kobo.21.1">condition</span></kbd><span class="koboSpan" id="kobo.22.1"> directive allows the threads to be properly synchronized.</span></p>
<p><span class="koboSpan" id="kobo.23.1">The result that we get after a single run is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.24.1">2019-08-05 14:33:44,285 Producer INFO total items 1</span><br/><span class="koboSpan" id="kobo.25.1">2019-08-05 14:33:44,786 Producer INFO total items 2</span><br/><span class="koboSpan" id="kobo.26.1">2019-08-05 14:33:45,286 Producer INFO total items 3</span><br/><span class="koboSpan" id="kobo.27.1">2019-08-05 14:33:45,786 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.28.1">2019-08-05 14:33:45,787 Producer INFO total items 3</span><br/><span class="koboSpan" id="kobo.29.1">2019-08-05 14:33:46,287 Producer INFO total items 4</span><br/><span class="koboSpan" id="kobo.30.1">2019-08-05 14:33:46,788 Producer INFO total items 5</span><br/><span class="koboSpan" id="kobo.31.1">2019-08-05 14:33:47,289 Producer INFO total items 6</span><br/><span class="koboSpan" id="kobo.32.1">2019-08-05 14:33:47,787 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.33.1">2019-08-05 14:33:47,790 Producer INFO total items 6</span><br/><span class="koboSpan" id="kobo.34.1">2019-08-05 14:33:48,291 Producer INFO total items 7</span><br/><span class="koboSpan" id="kobo.35.1">2019-08-05 14:33:48,792 Producer INFO total items 8</span><br/><span class="koboSpan" id="kobo.36.1">2019-08-05 14:33:49,293 Producer INFO total items 9</span><br/><span class="koboSpan" id="kobo.37.1">2019-08-05 14:33:49,788 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.38.1">2019-08-05 14:33:49,794 Producer INFO total items 9</span><br/><span class="koboSpan" id="kobo.39.1">2019-08-05 14:33:50,294 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.40.1">2019-08-05 14:33:50,795 Producer INFO items produced 10. </span><span class="koboSpan" id="kobo.40.2">Stopped</span><br/><span class="koboSpan" id="kobo.41.1">2019-08-05 14:33:51,789 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.42.1">2019-08-05 14:33:51,790 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.43.1">2019-08-05 14:33:52,290 Producer INFO items produced 10. </span><span class="koboSpan" id="kobo.43.2">Stopped</span><br/><span class="koboSpan" id="kobo.44.1">2019-08-05 14:33:53,790 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.45.1">2019-08-05 14:33:53,790 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.46.1">2019-08-05 14:33:54,291 Producer INFO items produced 10. </span><span class="koboSpan" id="kobo.46.2">Stopped</span><br/><span class="koboSpan" id="kobo.47.1">2019-08-05 14:33:55,790 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.48.1">2019-08-05 14:33:55,791 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.49.1">2019-08-05 14:33:56,291 Producer INFO items produced 10. </span><span class="koboSpan" id="kobo.49.2">Stopped</span><br/><span class="koboSpan" id="kobo.50.1">2019-08-05 14:33:57,791 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.51.1">2019-08-05 14:33:57,791 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.52.1">2019-08-05 14:33:58,292 Producer INFO items produced 10. </span><span class="koboSpan" id="kobo.52.2">Stopped</span><br/><span class="koboSpan" id="kobo.53.1">2019-08-05 14:33:59,791 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.54.1">2019-08-05 14:33:59,791 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.55.1">2019-08-05 14:34:00,292 Producer INFO items produced 10. </span><span class="koboSpan" id="kobo.55.2">Stopped</span><br/><span class="koboSpan" id="kobo.56.1">2019-08-05 14:34:01,791 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.57.1">2019-08-05 14:34:01,791 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.58.1">2019-08-05 14:34:02,291 Producer INFO items produced 10. </span><span class="koboSpan" id="kobo.58.2">Stopped</span><br/><span class="koboSpan" id="kobo.59.1">2019-08-05 14:34:03,791 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.60.1">2019-08-05 14:34:03,792 Producer INFO total items 10</span><br/><span class="koboSpan" id="kobo.61.1">2019-08-05 14:34:05,792 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.62.1">2019-08-05 14:34:07,793 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.63.1">2019-08-05 14:34:09,794 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.64.1">2019-08-05 14:34:11,795 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.65.1">2019-08-05 14:34:13,795 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.66.1">2019-08-05 14:34:15,833 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.67.1">2019-08-05 14:34:17,833 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.68.1">2019-08-05 14:34:19,833 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.69.1">2019-08-05 14:34:21,834 Consumer INFO consumed 1 item</span><br/><span class="koboSpan" id="kobo.70.1">2019-08-05 14:34:23,835 Consumer INFO consumed 1 item</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's interesting to see the Python internals for the condition synchronization mechanism. </span><span class="koboSpan" id="kobo.2.2">The internal </span><kbd><span class="koboSpan" id="kobo.3.1">class _Condition</span></kbd><span class="koboSpan" id="kobo.4.1"> creates an </span><kbd><span class="koboSpan" id="kobo.5.1">RLock()</span></kbd><span class="koboSpan" id="kobo.6.1"> object if no existing lock has been passed to the class's constructor. </span><span class="koboSpan" id="kobo.6.2">Also, the lock will be managed when </span><kbd><span class="koboSpan" id="kobo.7.1">acquire()</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">released()</span></kbd><span class="koboSpan" id="kobo.10.1"> are called:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">class _Condition(_Verbose):</span><br/><span class="koboSpan" id="kobo.12.1">    def __init__(self, lock=None, verbose=None):</span><br/><span class="koboSpan" id="kobo.13.1">        _Verbose.__init__(self, verbose)</span><br/><span class="koboSpan" id="kobo.14.1">        if lock is None:</span><br/><span class="koboSpan" id="kobo.15.1">            lock = RLock()</span><br/><span class="koboSpan" id="kobo.16.1">        self.__lock = lock</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread synchronization with an event</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">An event is an object that is used for communication between threads. </span><span class="koboSpan" id="kobo.2.2">A thread waits for a signal while another thread outputs it. </span><span class="koboSpan" id="kobo.2.3">Basically, an </span><kbd><span class="koboSpan" id="kobo.3.1">event</span></kbd><span class="koboSpan" id="kobo.4.1"> object manages an internal flag that can be set to </span><kbd><span class="koboSpan" id="kobo.5.1">false</span></kbd><span class="koboSpan" id="kobo.6.1"> with </span><kbd><span class="koboSpan" id="kobo.7.1">clear()</span></kbd><span class="koboSpan" id="kobo.8.1">, set to </span><kbd><span class="koboSpan" id="kobo.9.1">true</span></kbd><span class="koboSpan" id="kobo.10.1"> with </span><kbd><span class="koboSpan" id="kobo.11.1">set()</span></kbd><span class="koboSpan" id="kobo.12.1">, and tested with </span><kbd><span class="koboSpan" id="kobo.13.1">is_set()</span></kbd><span class="koboSpan" id="kobo.14.1">.</span></p>
<p><span class="koboSpan" id="kobo.15.1">A thread can hold a signal by means of the </span><kbd><span class="koboSpan" id="kobo.16.1">wait()</span></kbd> <span><span class="koboSpan" id="kobo.17.1">method,</span></span><span class="koboSpan" id="kobo.18.1"> which sends the call with the </span><kbd><span class="koboSpan" id="kobo.19.1">set()</span></kbd><span class="koboSpan" id="kobo.20.1"> method.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">To understand thread synchronization through the </span><kbd><span class="koboSpan" id="kobo.3.1">event</span></kbd><span class="koboSpan" id="kobo.4.1"> object, let's take a look at the producer/consumer problem.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Again, to explain how to synchronize threads through events, we will refer to the </span><em><span class="koboSpan" id="kobo.3.1">producer/consumer</span></em><span class="koboSpan" id="kobo.4.1"> problem. </span><span class="koboSpan" id="kobo.4.2">The problem describes two processes, a producer and a consumer, who share a common buffer of a fixed size. </span><span class="koboSpan" id="kobo.4.3">The producer's task is to generate items and deposit them in the continuous buffer. </span><span class="koboSpan" id="kobo.4.4">At the same time, the consumer will use the items produced, removing them from the buffer from time to time.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The problem is to ensure that the producer does not process new data if the buffer is full and that the consumer does not look for data if the buffer is empty.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Now, let's see how to implement the consumer/producer problem by using thread synchronization with an </span><kbd><span class="koboSpan" id="kobo.7.1">event</span></kbd><span class="koboSpan" id="kobo.8.1"> statement:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.9.1">Here, the relevant libraries are imported as follows:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.10.1">import logging</span><br/><span class="koboSpan" id="kobo.11.1">import threading</span><br/><span class="koboSpan" id="kobo.12.1">import time</span><br/><span class="koboSpan" id="kobo.13.1">import random</span></pre>
<ol start="2">
<li><span class="koboSpan" id="kobo.14.1">Then, we define the log output format. </span><span class="koboSpan" id="kobo.14.2">It is useful to clearly visualize what's happening:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.15.1">LOG_FORMAT = '%(asctime)s %(threadName)-17s %(levelname)-8s %\</span><br/><span class="koboSpan" id="kobo.16.1">             (message)s'</span><br/><span class="koboSpan" id="kobo.17.1">logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)</span></pre>
<ol start="3">
<li><span class="koboSpan" id="kobo.18.1">Set the </span><kbd><span class="koboSpan" id="kobo.19.1">items</span></kbd><span class="koboSpan" id="kobo.20.1"> list. </span><span class="koboSpan" id="kobo.20.2">This parameter will be used by the </span><kbd><span class="koboSpan" id="kobo.21.1">Consumer</span></kbd><span class="koboSpan" id="kobo.22.1"> and </span><kbd><span class="koboSpan" id="kobo.23.1">Producer</span></kbd><span class="koboSpan" id="kobo.24.1"> classes:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.25.1">items = []</span></pre>
<ol start="4">
<li><span class="koboSpan" id="kobo.26.1">The </span><kbd><span class="koboSpan" id="kobo.27.1">event</span></kbd><span class="koboSpan" id="kobo.28.1"> parameter is defined as follows. </span><span class="koboSpan" id="kobo.28.2">This parameter will be used to synchronize the communication between threads:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.29.1">event = threading.Event()</span></pre>
<ol start="5">
<li><span class="koboSpan" id="kobo.30.1">The </span><kbd><span class="koboSpan" id="kobo.31.1">Consumer</span></kbd><span class="koboSpan" id="kobo.32.1"> class is initialized with the list of items and the </span><kbd><span class="koboSpan" id="kobo.33.1">Event()</span></kbd><span class="koboSpan" id="kobo.34.1"> function. </span><span class="koboSpan" id="kobo.34.2">In the </span><kbd><span class="koboSpan" id="kobo.35.1">run</span></kbd><span class="koboSpan" id="kobo.36.1"> method, the consumer waits for a new item to consume. </span><span class="koboSpan" id="kobo.36.2">When the item arrives, it is popped from the </span><kbd><span class="koboSpan" id="kobo.37.1">item</span></kbd><span class="koboSpan" id="kobo.38.1"> list:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.39.1">class Consumer(threading.Thread):</span><br/><span class="koboSpan" id="kobo.40.1">    def __init__(self, *args, **kwargs):</span><br/><span class="koboSpan" id="kobo.41.1">        super().__init__(*args, **kwargs)</span><br/><br/><span class="koboSpan" id="kobo.42.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.43.1">        while True:</span><br/><span class="koboSpan" id="kobo.44.1">            time.sleep(2)</span><br/><span class="koboSpan" id="kobo.45.1">            event.wait()</span><br/><span class="koboSpan" id="kobo.46.1">            item = items.pop()</span><br/><span class="koboSpan" id="kobo.47.1">            logging.info('Consumer notify: {} popped by {}'\</span><br/><span class="koboSpan" id="kobo.48.1">                        .format(item, self.name))</span></pre>
<ol start="6">
<li><span class="koboSpan" id="kobo.49.1">The </span><kbd><span class="koboSpan" id="kobo.50.1">Producer</span></kbd><span class="koboSpan" id="kobo.51.1"> class is initialized with the list of items and the </span><kbd><span class="koboSpan" id="kobo.52.1">Event()</span></kbd><span class="koboSpan" id="kobo.53.1"> function. </span><span class="koboSpan" id="kobo.53.2">Unlike the example with </span><kbd><span class="koboSpan" id="kobo.54.1">condition</span></kbd><span class="koboSpan" id="kobo.55.1"> objects, the item list is not global, but it is passed as a parameter:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.56.1">class Producer(threading.Thread):</span><br/><span class="koboSpan" id="kobo.57.1">    def __init__(self, *args, **kwargs):</span><br/><span class="koboSpan" id="kobo.58.1">        super().__init__(*args, **kwargs)</span></pre>
<ol start="7">
<li><span class="koboSpan" id="kobo.59.1">In the </span><kbd><span class="koboSpan" id="kobo.60.1">run</span></kbd><span class="koboSpan" id="kobo.61.1"> method for each item that is created, the </span><kbd><span class="koboSpan" id="kobo.62.1">Producer</span></kbd><span class="koboSpan" id="kobo.63.1"> class appends it to the list of items and then notifies the event:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.64.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.65.1">        for i in range(5):</span><br/><span class="koboSpan" id="kobo.66.1">            time.sleep(2)</span><br/><span class="koboSpan" id="kobo.67.1">            item = random.randint(0, 100)</span><br/><span class="koboSpan" id="kobo.68.1">            items.append(item)</span><br/><span class="koboSpan" id="kobo.69.1">            logging.info('Producer notify: item {} appended by\ </span><br/><span class="koboSpan" id="kobo.70.1">                         {}'\.format(item, self.name))</span></pre>
<ol start="8">
<li><span class="koboSpan" id="kobo.71.1">There are two steps that you need to take for this and the first step, which are as follows:</span></li>
</ol>
<pre><span class="koboSpan" id="kobo.72.1">            event.set()</span><br/><span class="koboSpan" id="kobo.73.1">            event.clear()</span></pre>
<ol start="9">
<li><span class="koboSpan" id="kobo.74.1">The </span><kbd><span class="koboSpan" id="kobo.75.1">t1</span></kbd><span class="koboSpan" id="kobo.76.1"> thread appends a value to the list and then sets the event to notify the consumer. </span><span class="koboSpan" id="kobo.76.2">The consumer's call to </span><kbd><span class="koboSpan" id="kobo.77.1">wait()</span></kbd><span class="koboSpan" id="kobo.78.1"> stops blocking and the integer is retrieved from the list:</span></li>
</ol>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.79.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.80.1">    t1 = Producer()</span><br/><span class="koboSpan" id="kobo.81.1">    t2 = Consumer()</span><br/><br/><span class="koboSpan" id="kobo.82.1">    t1.start()</span><br/><span class="koboSpan" id="kobo.83.1">    t2.start()</span><br/><br/><span class="koboSpan" id="kobo.84.1">    t1.join()</span><br/><span class="koboSpan" id="kobo.85.1">    t2.join()</span></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">All the operations between the </span><kbd><span class="koboSpan" id="kobo.3.1">Producer</span></kbd><span class="koboSpan" id="kobo.4.1"> and the </span><kbd><span class="koboSpan" id="kobo.5.1">Consumer</span></kbd><span class="koboSpan" id="kobo.6.1"> classes can be easily resumed with the help of the following schema:</span></p>
<p class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img src="assets/915fcac0-899f-465a-9fd2-ce18a24bb0f0.png" style="width:35.83em;height:20.25em;"/></span></p>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.8.1">Thread synchronization with event objects</span></div>
<p><span class="koboSpan" id="kobo.9.1">In particular, the </span><kbd><span class="koboSpan" id="kobo.10.1">Producer</span></kbd><span class="koboSpan" id="kobo.11.1"> and the </span><kbd><span class="koboSpan" id="kobo.12.1">Consumer</span></kbd> <span><span class="koboSpan" id="kobo.13.1">classes </span></span><span class="koboSpan" id="kobo.14.1">have the following behavior:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.15.1">Producer</span></kbd><span class="koboSpan" id="kobo.16.1"> acquires a lock, adds an item to the queue, and notifies this event to </span><kbd><span class="koboSpan" id="kobo.17.1">Consumer</span></kbd><span class="koboSpan" id="kobo.18.1"> (</span><kbd><span class="koboSpan" id="kobo.19.1">set event</span></kbd><span class="koboSpan" id="kobo.20.1">). </span><span class="koboSpan" id="kobo.20.2">It then sleeps until it receives a new item to add.</span></li>
<li><kbd><span class="koboSpan" id="kobo.21.1">Consumer</span></kbd><span class="koboSpan" id="kobo.22.1"> acquires a block and then begins to listen to the elements in a continuous cycle. </span><span class="koboSpan" id="kobo.22.2">The moment the event arrives, the consumer abandons the block, thus allowing other producers/consumers to enter and acquire the block. </span><span class="koboSpan" id="kobo.22.3">If </span><kbd><span class="koboSpan" id="kobo.23.1">Consumer</span></kbd><span class="koboSpan" id="kobo.24.1"> is reactivated, then it reacquires the lock by safely processing new items from the queue:</span></li>
</ul>
<pre style="padding-left: 60px"><strong><span class="koboSpan" id="kobo.25.1">2019-02-02 18:23:35,125 Thread-1 INFO Producer notify: item 68 appended by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.26.1">2019-02-02 18:23:35,133 Thread-2 INFO Consumer notify: 68 popped by Thread-2</span></strong><br/><strong><span class="koboSpan" id="kobo.27.1">2019-02-02 18:23:37,138 Thread-1 INFO Producer notify: item 45 appended by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.28.1">2019-02-02 18:23:37,143 Thread-2 INFO Consumer notify: 45 popped by Thread-2</span></strong><br/><strong><span class="koboSpan" id="kobo.29.1">2019-02-02 18:23:39,148 Thread-1 INFO Producer notify: item 78 appended by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.30.1">2019-02-02 18:23:39,153 Thread-2 INFO Consumer notify: 78 popped by Thread-2</span></strong><br/><strong><span class="koboSpan" id="kobo.31.1">2019-02-02 18:23:41,158 Thread-1 INFO Producer notify: item 22 appended by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.32.1">2019-02-02 18:23:43,173 Thread-1 INFO Producer notify: item 48 appended by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.33.1">2019-02-02 18:23:43,178 Thread-2 INFO Consumer notify: 48 popped by Thread-2</span></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread synchronization with a barrier</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Sometimes, an application can be divided into phases with the rule that no process can continue if first, all threads of the process have completed their own task. </span><span class="koboSpan" id="kobo.2.2">A </span><strong><span class="koboSpan" id="kobo.3.1">barrier</span></strong><span class="koboSpan" id="kobo.4.1"> implements this concept: a thread that has finished its phase calls a primitive barrier and stops. </span><span class="koboSpan" id="kobo.4.2">When all the threads involved have finished their stage of execution and have also invoked the primitive barrier, the system unlocks them all, allowing threads to move to a later stage.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Python's threading module implements barriers through the </span><strong><kbd><span class="koboSpan" id="kobo.3.1">Barrier</span></kbd></strong><span class="koboSpan" id="kobo.4.1"> class. In the next section, let's learn about how to use this synchronization mechanism in a very simple example.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, we simulate a run with three participants, </span><kbd><span class="koboSpan" id="kobo.3.1">Huey</span></kbd><span class="koboSpan" id="kobo.4.1">, </span><kbd><span class="koboSpan" id="kobo.5.1">Dewey</span></kbd><span class="koboSpan" id="kobo.6.1">, and </span><kbd><span class="koboSpan" id="kobo.7.1">Louie</span></kbd><span class="koboSpan" id="kobo.8.1">, in which a barrier is assimilated to that of a finish line.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Moreover, the race can end on its own when all three participants cross the finish line.</span></p>
<p><span class="koboSpan" id="kobo.10.1">The barrier is implemented through the </span><kbd><span class="koboSpan" id="kobo.11.1">Barrier</span></kbd><span><span class="koboSpan" id="kobo.12.1"> class, </span></span><span class="koboSpan" id="kobo.13.1">in which the number of threads to be completed must be specified as an argument to move to the next stage:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">from random import randrange</span><br/><span class="koboSpan" id="kobo.15.1">from threading import Barrier, Thread</span><br/><span class="koboSpan" id="kobo.16.1">from time import ctime, sleep</span><br/><br/><span class="koboSpan" id="kobo.17.1">num_runners = 3</span><br/><span class="koboSpan" id="kobo.18.1">finish_line = Barrier(num_runners)</span><br/><span class="koboSpan" id="kobo.19.1">runners = ['Huey', 'Dewey', 'Louie']</span><br/><br/><span class="koboSpan" id="kobo.20.1">def runner():</span><br/><span class="koboSpan" id="kobo.21.1">    name = runners.pop()</span><br/><span class="koboSpan" id="kobo.22.1">    sleep(randrange(2, 5))</span><br/><span class="koboSpan" id="kobo.23.1">    print('%s reached the barrier at: %s \n' % (name, ctime()))</span><br/><span class="koboSpan" id="kobo.24.1">    finish_line.wait()</span><br/><br/><span class="koboSpan" id="kobo.25.1">def main():</span><br/><span class="koboSpan" id="kobo.26.1">    threads = []</span><br/><span class="koboSpan" id="kobo.27.1">    print('START RACE!!!!')</span><br/><span class="koboSpan" id="kobo.28.1">    for i in range(num_runners):</span><br/><span class="koboSpan" id="kobo.29.1">        threads.append(Thread(target=runner))</span><br/><span class="koboSpan" id="kobo.30.1">        threads[-1].start()</span><br/><span class="koboSpan" id="kobo.31.1">    for thread in threads:</span><br/><span class="koboSpan" id="kobo.32.1">        thread.join()</span><br/><span class="koboSpan" id="kobo.33.1">    print('Race over!')</span><br/><br/><span class="koboSpan" id="kobo.34.1">if __name__ == "__main__":</span><br/><span class="koboSpan" id="kobo.35.1">    main()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">First, we set the number of runners to </span><kbd><span class="koboSpan" id="kobo.3.1">num_runners = 3</span></kbd><span class="koboSpan" id="kobo.4.1"> in order to set the final goal on the next line through the </span><kbd><span class="koboSpan" id="kobo.5.1">Barrier</span></kbd><span class="koboSpan" id="kobo.6.1"> directive. </span><span class="koboSpan" id="kobo.6.2">The runners are set in the runners' list; each of them will have an arrival time that is determined in the </span><kbd><span class="koboSpan" id="kobo.7.1">runner</span></kbd><span class="koboSpan" id="kobo.8.1"> function, using the </span><kbd><span class="koboSpan" id="kobo.9.1">randrange</span></kbd><span class="koboSpan" id="kobo.10.1"> directive.</span></p>
<p><span class="koboSpan" id="kobo.11.1">When a runner arrives at the finish line, call the </span><kbd><span class="koboSpan" id="kobo.12.1">wait</span></kbd><span class="koboSpan" id="kobo.13.1"> method, which will block all the runners (the threads) that have made that call. </span><span class="koboSpan" id="kobo.13.2">The output for this is as follows:</span></p>
<pre><strong><span class="koboSpan" id="kobo.14.1">START RACE!!!!</span></strong><br/><strong><span class="koboSpan" id="kobo.15.1">Dewey reached the barrier at: Sat Feb 2 21:44:48 2019 </span></strong><br/><br/><strong><span class="koboSpan" id="kobo.16.1">Huey reached the barrier at: Sat Feb 2 21:44:49 2019 </span></strong><br/><br/><strong><span class="koboSpan" id="kobo.17.1">Louie reached the barrier at: Sat Feb 2 21:44:50 2019 </span></strong><br/><br/><strong><span class="koboSpan" id="kobo.18.1">Race over!</span></strong></pre>
<p><span class="koboSpan" id="kobo.19.1">In this case, </span><kbd><span class="koboSpan" id="kobo.20.1">Dewey</span></kbd><span class="koboSpan" id="kobo.21.1"> won the race.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Thread communication using a queue</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Multithreading can be complicated when threads need to share data or resources. </span><span class="koboSpan" id="kobo.2.2">Luckily, the threading module provides many synchronization primitives, including semaphores, condition variables, events, and locks.</span></p>
<p><span class="koboSpan" id="kobo.3.1">However, it is considered a best practice to use the </span><kbd><span class="koboSpan" id="kobo.4.1">queue</span></kbd><span><span class="koboSpan" id="kobo.5.1"> module. </span></span><span class="koboSpan" id="kobo.6.1">In fact, a queue is much easier to deal with and makes threaded programming considerably safer, as it effectively funnels all access to a resource of a single thread and allows for a cleaner and more readable design pattern.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Getting ready</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We will simply consider these queue methods:</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.3.1">put()</span></kbd><span class="koboSpan" id="kobo.4.1">: Puts an item in the queue</span></li>
<li><kbd><span class="koboSpan" id="kobo.5.1">get()</span></kbd><span class="koboSpan" id="kobo.6.1">: Removes and returns an item from the queue</span></li>
<li><kbd><span class="koboSpan" id="kobo.7.1">task_done()</span></kbd><span class="koboSpan" id="kobo.8.1">: Needs to be called each time an item has been processed</span></li>
<li><kbd><span class="koboSpan" id="kobo.9.1">join()</span></kbd><span class="koboSpan" id="kobo.10.1">: Blocks until all items have been processed</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How to do it...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this example, we will see how to use the </span><kbd><span class="koboSpan" id="kobo.3.1">threading</span></kbd><span class="koboSpan" id="kobo.4.1"> module with the </span><kbd><span class="koboSpan" id="kobo.5.1">queue</span></kbd><span class="koboSpan" id="kobo.6.1"> module. </span><span class="koboSpan" id="kobo.6.2">Also, we have two entities here that try to share a common resource, a queue. </span><span class="koboSpan" id="kobo.6.3">The code is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">from threading import Thread</span><br/><span class="koboSpan" id="kobo.8.1">from queue import Queue</span><br/><span class="koboSpan" id="kobo.9.1">import time</span><br/><span class="koboSpan" id="kobo.10.1">import random</span><br/><br/><span class="koboSpan" id="kobo.11.1">class Producer(Thread):</span><br/><span class="koboSpan" id="kobo.12.1">    def __init__(self, queue):</span><br/><span class="koboSpan" id="kobo.13.1">        Thread.__init__(self)</span><br/><span class="koboSpan" id="kobo.14.1">        self.queue = queue</span><br/><span class="koboSpan" id="kobo.15.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.16.1">        for i in range(5):</span><br/><span class="koboSpan" id="kobo.17.1">            item = random.randint(0, 256)</span><br/><span class="koboSpan" id="kobo.18.1">            self.queue.put(item)</span><br/><span class="koboSpan" id="kobo.19.1">            print('Producer notify : item N°%d appended to queue by\ </span><br/><span class="koboSpan" id="kobo.20.1">                  %s\n'\</span><br/><span class="koboSpan" id="kobo.21.1">                  % (item, self.name))</span><br/><span class="koboSpan" id="kobo.22.1">            time.sleep(1)</span><br/><br/><span class="koboSpan" id="kobo.23.1">class Consumer(Thread):</span><br/><span class="koboSpan" id="kobo.24.1">    def __init__(self, queue):</span><br/><span class="koboSpan" id="kobo.25.1">        Thread.__init__(self)</span><br/><span class="koboSpan" id="kobo.26.1">        self.queue = queue</span><br/><br/><span class="koboSpan" id="kobo.27.1">    def run(self):</span><br/><span class="koboSpan" id="kobo.28.1">        while True:</span><br/><span class="koboSpan" id="kobo.29.1">            item = self.queue.get()</span><br/><span class="koboSpan" id="kobo.30.1">            print('Consumer notify : %d popped from queue by %s'\</span><br/><span class="koboSpan" id="kobo.31.1">                  % (item, self.name))</span><br/><span class="koboSpan" id="kobo.32.1">            self.queue.task_done()</span><br/><br/><span class="koboSpan" id="kobo.33.1">if __name__ == '__main__':</span><br/><span class="koboSpan" id="kobo.34.1">    queue = Queue()</span><br/><span class="koboSpan" id="kobo.35.1">    t1 = Producer(queue)</span><br/><span class="koboSpan" id="kobo.36.1">    t2 = Consumer(queue)</span><br/><span class="koboSpan" id="kobo.37.1">    t3 = Consumer(queue)</span><br/><span class="koboSpan" id="kobo.38.1">    t4 = Consumer(queue)</span><br/><br/><span class="koboSpan" id="kobo.39.1">    t1.start()</span><br/><span class="koboSpan" id="kobo.40.1">    t2.start()</span><br/><span class="koboSpan" id="kobo.41.1">    t3.start()</span><br/><span class="koboSpan" id="kobo.42.1">    t4.start()</span><br/><br/><span class="koboSpan" id="kobo.43.1">    t1.join()</span><br/><span class="koboSpan" id="kobo.44.1">    t2.join()</span><br/><span class="koboSpan" id="kobo.45.1">    t3.join()</span><br/><span class="koboSpan" id="kobo.46.1">    t4.join()</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">How it works...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">First, with the </span><kbd><span class="koboSpan" id="kobo.3.1">producer</span></kbd><span class="koboSpan" id="kobo.4.1"> class, we don't need to pass the integers list because we use the queue to store the integers that are generated.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The thread in the </span><kbd><span class="koboSpan" id="kobo.6.1">producer</span></kbd><span class="koboSpan" id="kobo.7.1"> class generates integers and puts them in the queue in a </span><kbd><span class="koboSpan" id="kobo.8.1">for</span></kbd><span class="koboSpan" id="kobo.9.1"> loop. </span><span class="koboSpan" id="kobo.9.2">The </span><kbd><span class="koboSpan" id="kobo.10.1">producer</span></kbd><span class="koboSpan" id="kobo.11.1"> class uses </span><kbd><span class="koboSpan" id="kobo.12.1">Queue.put(item[, block[, timeout]])</span></kbd><span class="koboSpan" id="kobo.13.1"> to insert data in the queue. </span><span class="koboSpan" id="kobo.13.2">It has the logic to acquire the lock before inserting data in a queue.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span class="koboSpan" id="kobo.14.1">There are two possibilities:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">If the optional arguments </span><kbd><span class="koboSpan" id="kobo.16.1">block</span></kbd><span class="koboSpan" id="kobo.17.1"> is </span><kbd><span class="koboSpan" id="kobo.18.1">true</span></kbd><span class="koboSpan" id="kobo.19.1"> and </span><kbd><span class="koboSpan" id="kobo.20.1">timeout</span></kbd><span class="koboSpan" id="kobo.21.1"> is </span><kbd><span class="koboSpan" id="kobo.22.1">None</span></kbd><span class="koboSpan" id="kobo.23.1"> (this is the default case that we used in the example), then it is necessary for us to block until a free slot is available. </span><span class="koboSpan" id="kobo.23.2">If the timeout is a positive number, then it blocks at most timeout seconds and raises the full exception if no free slot is available within that time.</span></li>
<li><span class="koboSpan" id="kobo.24.1">If the block is </span><kbd><span class="koboSpan" id="kobo.25.1">false</span></kbd><span class="koboSpan" id="kobo.26.1">, then put an item in the queue if a free slot is immediately available, otherwise, raise the full exception (timeout is ignored in this case). </span><span class="koboSpan" id="kobo.26.2">Here, </span><kbd><span class="koboSpan" id="kobo.27.1">put</span></kbd><span class="koboSpan" id="kobo.28.1"> checks whether the queue is full and then calls </span><kbd><span class="koboSpan" id="kobo.29.1">wait</span></kbd><span class="koboSpan" id="kobo.30.1"> internally, after which, the producer starts waiting.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.31.1">Next is the </span><kbd><span class="koboSpan" id="kobo.32.1">consumer</span></kbd><span class="koboSpan" id="kobo.33.1"> class. </span><span class="koboSpan" id="kobo.33.2">The thread gets the integer from the queue and indicates that it is done working on it by using </span><kbd><span class="koboSpan" id="kobo.34.1">task_done</span></kbd><span class="koboSpan" id="kobo.35.1">. </span><span class="koboSpan" id="kobo.35.2">The </span><kbd><span class="koboSpan" id="kobo.36.1">consumer</span></kbd><span class="koboSpan" id="kobo.37.1"> class uses </span><kbd><span class="koboSpan" id="kobo.38.1">Queue.get([block[, timeout]])</span></kbd><span class="koboSpan" id="kobo.39.1"> and acquires the lock before removing data from the queue. </span><span class="koboSpan" id="kobo.39.2">The consumer is placed in a waiting state, in case the queue is empty. </span><span class="koboSpan" id="kobo.39.3">Finally, in the </span><kbd><span class="koboSpan" id="kobo.40.1">main</span></kbd><span class="koboSpan" id="kobo.41.1"> function, we create four threads, one for the </span><kbd><span class="koboSpan" id="kobo.42.1">producer</span></kbd><span class="koboSpan" id="kobo.43.1"> class and three for the </span><kbd><span class="koboSpan" id="kobo.44.1">consumer</span></kbd> <span><span class="koboSpan" id="kobo.45.1">class, </span></span><span class="koboSpan" id="kobo.46.1">respectively.</span></p>
<p><span class="koboSpan" id="kobo.47.1">The output should be like this:</span></p>
<pre><strong><span class="koboSpan" id="kobo.48.1">Producer notify : item N°186 appended to queue by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.49.1">Consumer notify : 186 popped from queue by Thread-2</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.50.1">Producer notify : item N°16 appended to queue by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.51.1">Consumer notify : 16 popped from queue by Thread-3</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.52.1">Producer notify : item N°72 appended to queue by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.53.1">Consumer notify : 72 popped from queue by Thread-4</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.54.1">Producer notify : item N°178 appended to queue by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.55.1">Consumer notify : 178 popped from queue by Thread-2</span></strong><br/><br/><strong><span class="koboSpan" id="kobo.56.1">Producer notify : item N°214 appended to queue by Thread-1</span></strong><br/><strong><span class="koboSpan" id="kobo.57.1">Consumer notify : 214 popped from queue by Thread-3</span></strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">There's more...</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">All the operations between the </span><kbd><span class="koboSpan" id="kobo.3.1">producer</span></kbd><span class="koboSpan" id="kobo.4.1"> class and the </span><kbd><span class="koboSpan" id="kobo.5.1">consumer</span></kbd><span class="koboSpan" id="kobo.6.1"> class can easily be resumed with the following schema:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img src="assets/cb11a94d-258a-485f-a1b4-8954a860b41a.png" style="width:35.83em;height:18.83em;"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1">Thread synchronization with the queue module</span></div>
<ul>
<li><span class="koboSpan" id="kobo.9.1">The </span><kbd><span class="koboSpan" id="kobo.10.1">Producer</span></kbd><span class="koboSpan" id="kobo.11.1"> thread acquires the lock and then inserts data in the </span><strong><span class="koboSpan" id="kobo.12.1">QUEUE</span></strong><span class="koboSpan" id="kobo.13.1"> data structure.</span></li>
<li><span class="koboSpan" id="kobo.14.1">The </span><kbd><span class="koboSpan" id="kobo.15.1">Consumer</span></kbd><span class="koboSpan" id="kobo.16.1"> threads get the integers from the </span><strong><span class="koboSpan" id="kobo.17.1">QUEUE</span></strong><span class="koboSpan" id="kobo.18.1">. </span><span class="koboSpan" id="kobo.18.2">These threads acquire the lock before removing data from the </span><strong><span class="koboSpan" id="kobo.19.1">QUEUE</span></strong><span class="koboSpan" id="kobo.20.1">.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.21.1">If the </span><strong><span class="koboSpan" id="kobo.22.1">QUEUE</span></strong><span class="koboSpan" id="kobo.23.1"> is empty, then the </span><kbd><span class="koboSpan" id="kobo.24.1">consumer</span></kbd><span class="koboSpan" id="kobo.25.1"> threads get in a </span><strong><span class="koboSpan" id="kobo.26.1">waiting</span></strong><span class="koboSpan" id="kobo.27.1"> state.</span></p>
<p><span class="koboSpan" id="kobo.28.1">With this recipe, the chapter dedicated to thread-based parallelism comes to an end.</span></p>


            </article>

            
        </section>
    </body></html>