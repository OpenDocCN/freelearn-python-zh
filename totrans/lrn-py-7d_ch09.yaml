- en: File Handling and Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far you have seen the various Python programs, which took the input from
    the keyboard and delivered the output on the screen. In this chapter, you will,
    however, learn to take input from files and write result to the files. Also, we
    will go through the concept of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Reading text from a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to read and write into a file, we will use the `open()` built-in function
    to open the file. The `open()` function creates an `file_object` object. What
    is an object?  You will understand in  [Chapter 11](lrn-py-7d_ch11.html), *Class
    and Objects*.  The Syntax is given as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first argument,`file_name`, specifies the filename that you want to open.
    The second argument, `access_mode`, determines in which mode the file has to be
    opened, that is, read, write, append, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The read() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will read a file by a program. The access mode for reading is `r`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the sample of a text file containing famous quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sample file
  prefs: []
  type: TYPE_NORMAL
- en: I have saved the preceding file with the name `sample1.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a `readfile.py` program to read the earlier file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the given code, first we created a `file_input` file object, then we called
    `file_input.read()` to read the file content. After reading, the `file_input`
    file object is closed by `file_input.close()`.  To be sure the sample file and
    the code `readfile.py` must be in the same directory. Let''s check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reading a file
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is running successfully. In order to read character from
    the file, you can pass the argument to the `read()` function, for example, `read(5)`
    would read the first five characters of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the sample code `readcount1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code read
  prefs: []
  type: TYPE_NORMAL
- en: The second line of code reads the first `20` characters of the file, the third
    line reads the next `15` characters, and the fourth line reads the next `10` characters
    of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The readline() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to read the file line by line, use `readline()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the sample code `readline1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the output of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In code, we have printed three lines. What happens, if you specify `count`
    in `readline(count)`. See the code `readlinecount.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the `file_input.readline(100)` syntax prints `100` characters of the first
    line. But the first line contains only 48 characters. The syntax file`_input.readline(20)`
    prints the `20` characters from the second line of `sample1.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The readlines() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider the situation where you want to make a list of lines of a file; in
    that case, the `readlines()` method allows you to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the code in `readlines1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can easily see the list of lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reading purposes, you can loop over the file object. Let''s analyze the
    code in `readfileforloop.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see all the lines. This is memory efficient, fast, and leads to simple
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's do an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: See the given file, `batman.txt`, containing the quotes from famous Hollywood
    movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our aim is to write a program to find a given word from the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure_burce.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of batman.txt
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a program to find the particular word from the file. We are making
    the assumption that the program should be case insensitive, which means it does
    not matter whether the characters are in uppercase or lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the code in `findword.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The program is very easy to understand. Let''s see the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of findword.py
  prefs: []
  type: TYPE_NORMAL
- en: The program `findword.py` is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: Writing text to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to write a new file using Python.
  prefs: []
  type: TYPE_NORMAL
- en: This time we'll use the write mode `'w'` in `open()`. The `'w'` mode creates
    a new file. If the file already exists, then the file would be overwritten.  We
    will use the `write()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss the code in `filewrite1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see that I have written the famous WWE star John Cena's quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code filewrite.py
  prefs: []
  type: TYPE_NORMAL
- en: 'We wrote lines one by one by adding a new line character `n`.  You can supply
    all of them in one go as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next, I will use the `writelines()` function. This method writes a Python list
    of strings to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, Python list, `list1`, contains some motivational lines,
    and we want to save that in a file. We could use the `writelines()` function for
    our requirement. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of filewriteline.py
  prefs: []
  type: TYPE_NORMAL
- en: Every time you run the program, the file gets overwritten, means a new file
    would be created. Consider the situation where you want to add content to the
    previous file; you can use access mode `'a'`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the preceding program `filewritea.py` with access mode `'a'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of filewritea.py
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the program with different lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program filewritea1.py
  prefs: []
  type: TYPE_NORMAL
- en: The `newmotivation.txt` file has been successfully appended.
  prefs: []
  type: TYPE_NORMAL
- en: There are other access modes too.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `"r+"` opens a file for reading and writing. This mode places the pointer
    at the beginning of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The `"w+"` opens a file for reading and writing. If the file doesn't exist,
    then a new file is created.  If the file exists, then the file is overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: The `"a+"` opens a file for appending and reading. If the file doesn't exist,
    it creates a new file. If the file already exists, the pointer is placed at the
    end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Pickling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Text files are convenient to use because you can read, write, and append them
    with any text editor, but they are limited to storing a series of characters.
    Sometimes you may want to store complex information such as list and dictionary.
    Here we would use Python''s `pickle` module. The `pickle` module is used to store
    complex data such as list and dictionary. Let''s discuss with the help of an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The program seems complex to understand. Let's understand the code line by line.
  prefs: []
  type: TYPE_NORMAL
- en: The `name` and `skill` are two lists which we have to store.
  prefs: []
  type: TYPE_NORMAL
- en: The `pickle_file = open("emp1.dat","w")` syntax creates a `pickle_file` object
    in write mode as we have done earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pickle.dump()` is used to dump and store the lists `name` and `skill` in
    the `pick.dat` file. The `pickle.dump()` requires two arguments, first the data
    (like list) to `pickle` and second the file to store it. The `pickle_file.close()`
    finally close the file. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of pickle file
  prefs: []
  type: TYPE_NORMAL
- en: Now you must have an idea how to store complex data.
  prefs: []
  type: TYPE_NORMAL
- en: Unpickling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unpickling means retrieving the data from the `pickle` file. In the previous
    topic, you learned how to store `(list, dictionary)` data in the `pickle` file;
    now it's time to retrieve the stored data. In order to perform unpickling, we
    will use `pickle.load()`. The `pickle.load()` takes one file object as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's understand the program line by line. The `pickle_file = open("emp1.dat",'r')`
    syntax creates a file object in read mode. The `name_list = pickle.load(pickle_file)`
    syntax reads the first pickled object in the file and unpickles it to produce
    the `['mohit', 'bhaskar', 'manish']` list. Similarly,  `skill_list =pickle.load(pickle_file)`
    reads the second pickled object in the file and unpickles it to produce the `['Python',
    'Python', 'Java']` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output to clear up any confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of filepickle2.py
  prefs: []
  type: TYPE_NORMAL
- en: In `pickle,` you can not access the data randomly. `Pickle` stores and retrieves
    the list sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: The data you dump in the `pickle` file first, would be retrieved first. This
    is the limitation of the `pickle` file.
  prefs: []
  type: TYPE_NORMAL
- en: Given the limitation of the `pickle` file, you can't access the list randomly,
    but you can use the dictionary with lists to retrieve the lists randomly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: By dumping this dictionary, you can access any list randomly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we have dumped a dictionary referred by name `leapx_team`.
    Run the preceding program and check the directory. A file named `emp2.dat` must
    be formed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's retrieve the content of the `emp2.dat` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, `all_data` is the dictionary and we are accessing
    the values of the dictionary by keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are accessing the list randomly.
  prefs: []
  type: TYPE_NORMAL
- en: The `pickle` module is written in Python, while the `cPickle` module is written
    in C language, which is faster than the `pickle` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the example code in `filecpickle1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider you have created a program `calc.py` and that it is running successfully.
    After some time, a third person edits the program `calc.py`. While executing the
    program, the interpreter throws some error. Due to the error, the whole program
    stops working. How can we avoid this situation, where, if any error occurs, then
    the whole program execution does not suffer?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple: just use exception handling. Errors detected during execution
    are called exceptions. In the next section, you will see the example in detail,
    where we will see how to use exception handling with the `try...except` clause.'
  prefs: []
  type: TYPE_NORMAL
- en: The try statement with an except clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will see how to use the `try...except` block to handle
    the exceptions. Let's understand the usage of the `try...except` block with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider that a third person edits the program `calc.py`; the full program
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of calc.py
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, the program is showing an error because we performed
    division by `0`. Due to one error, the whole program stop. In order to deal with
    the situation, we use the `try and except` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the program `calc.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure_calc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of calc.py
  prefs: []
  type: TYPE_NORMAL
- en: Now the `sum1()` function is giving the output `Error occurred in divide function`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss `try...except` in detail. First see the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the `calc.py` program, a call to divide raises an exception; the exception
    is caught and the crafted message is displayed: `Error in divide function`. If
    no exception is raised, the program skips the except clause, continuing with the
    rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple exception blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous example, you learned how to catch the exceptions. But you don''t
    know the type of error that occurred. Every exception has a certain type. The
    types in the example are `ZeroDivisionError`, `NameError`, and `TypeError.` Type
    is written in the error message. Consider a different program `divide1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the given program, when we give the input from the keyboard, the input string
    will be converted into int type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run program with different inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program divied.py
  prefs: []
  type: TYPE_NORMAL
- en: When we give the input `5`, then the program returns `9`. When we supply a string
    instead of a number, then the interpreter returns a message with a  `ValueError`
    error as highlighted under red line. When number `0` is supplied, then `ZeroDivisionError`
    is returned.  By using multiple exception blocks, you can handle both the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the program `divide1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding program, multiple exceptions have been handled and a crafted
    message has been displayed. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program divide1.py
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, customized messages have been displayed so that the
    user can understand his mistake.
  prefs: []
  type: TYPE_NORMAL
- en: The try...finally statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a situation where you are completely sure that a certain block of code will
    be executed whether the program throws exceptions or not, `try...finally` is useful.
    Consider the situation when you open a file and read the input, but for some reason
    the program throws an exception and the file you want is closed whether the exception
    occurs or not, then `try...finally` will solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of the statement should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s discuss the code in `finally1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we used `try`, `except`, `else`, and `finally` blocks.
    Let''s discuss the functionality by executing the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of finally1.py
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, in the first run, `10` has been provided as the input
    and  `try`, `else`, and `finally` blocks have been executed. In the second run,
    a string `Mohit` has been supplied. Due to error in type conversion `except` and
    `finally` blocks have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: With this you have seen the importance of the `finally` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The exception argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you write a program, it is very mundane and tedious to write each and
    every exception type. Instead of writing each exception, you could use just one
    line. See the code in `exceptiontype.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code catches the exception as `e` and `type(e)` displays its
    exception type. Let''s see the output. In the code, `e` is the argument of the
    exception: the contents referred by the argument vary by exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program exceptiontype.py
  prefs: []
  type: TYPE_NORMAL
- en: You can see that we run the program three times. The first time we passed the
    value `10`. It runs successfully. In the second run, we passed string `'mohit'`,
    which is when the interpreter handled the exception and showed the exception message
    and its type. In third run, we passed `0`, which is when interpreter showed the
    corresponding exception message and its type.
  prefs: []
  type: TYPE_NORMAL
- en: Raising exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `raise` statement allows the programmer to trigger specific exceptions explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the specific exception `IOError` has been raised
    by the `raise` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, a string `"Hi there"` argument has been passed, which
    is printed with the exception.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use classes, as you have not read the [Chapter 11](lrn-py-7d_ch11.html),
    *Class and Objects*, you can skip the topic and get back once you complete the
    class and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Python allows you to define your own exceptions. Exceptions should be inherited
    from the `Exception` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Do not be afraid to see the full code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the class part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defined the `MyException` class, which inherits the base
    class `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `default __init__()` exception has been overridden.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code raises the user-defined exception if you pass the value `2`.
    The raised exception is handled by the `except` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the output of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of code userdefined.py
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, if you pass the value `2`, then it gives a user-defined
    custom error. If you pass a number other than `2`, then no error occurs. Let's
    make some changes in the code to understand the example clearly.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the program `userdefined2.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Just the `except` block has been changed. Now, the `except` block is only handling
    `IOError` not `MyException`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/file_figure22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output of program userdefind2.py
  prefs: []
  type: TYPE_NORMAL
- en: When you pass a value other than `2`, then the `MyException` exception is raised
    and the except block does not handle the raised exception. The interpreter shows
    the error with an exception type.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want to print an exception message, you can use pass the statement `except:
    pass`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to read data from text files. You learned how
    to write data to the text files. Text files are not a good choice to store complex
    data such as list and dictionary. In order to store complex data, we have used
    `pickle` files. After that, you learned to handle exceptions. Without handling
    exceptions you cannot write standard code. In exceptions, you learned how to handle
    multiple exceptions and how to print its exception type. In end of the chapter, you
    learned how to create your own exception.
  prefs: []
  type: TYPE_NORMAL
