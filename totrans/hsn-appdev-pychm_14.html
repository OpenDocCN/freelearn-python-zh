<html><head></head><body>
<div id="_idContainer464">
<h1 class="chapter-number" id="_idParaDest-333"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-334"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.2.1">Building a Data Pipeline in PyCharm</span></h1>
<p><span class="koboSpan" id="kobo.3.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.4.1">data pipeline</span></em><span class="koboSpan" id="kobo.5.1"> generally denotes a step-wise procedure that entails collecting, processing, and analyzing data. </span><span class="koboSpan" id="kobo.5.2">This term is widely used in the industry to express the need for a reliable workflow that takes raw data and converts it into actionable insights. </span><span class="koboSpan" id="kobo.5.3">Some data pipelines work at massive scales, such as a </span><strong class="bold"><span class="koboSpan" id="kobo.6.1">marketing technology</span></strong><span class="koboSpan" id="kobo.7.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.8.1">MarTech</span></strong><span class="koboSpan" id="kobo.9.1">) company ingesting millions of data points from Kafka streams, storing them in large data stores such as </span><strong class="bold"><span class="koboSpan" id="kobo.10.1">Hadoop</span></strong><span class="koboSpan" id="kobo.11.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.12.1">Clickhouse</span></strong><span class="koboSpan" id="kobo.13.1">, and then cleansing, enriching, and visualizing that data. </span><span class="koboSpan" id="kobo.13.2">Other times, the data is smaller but far more impactful, such as the project we’ll be working on in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">How to work with and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">maintain datasets</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">How to clean and </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">preprocess data</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">How to </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">visualize data</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">How to utilize </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">machine </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.25.1">learning</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.26.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.27.1">ML</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">Throughout this chapter, you will be able to apply what you have learned about the topic of scientific computing so far to a real project with PyCharm. </span><span class="koboSpan" id="kobo.29.2">This serves as a hands-on discussion to conclude this topic of working with scientific computing and data </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">science projects.</span></span></p>
<p><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.31.1">I want to specifically point out that I am heavily leveraging the text, code, and data from the first edition, which was written by a different author, Quan Nguyen. </span><span class="koboSpan" id="kobo.31.2">In this second edition, my main job was to update the existing content. </span><span class="koboSpan" id="kobo.31.3">Quan’s treatment in this chapter was excellent, so most of what I did to update this chapter was use the newer version of PyCharm, update the libraries used to the latest versions, and then re-write this chapter in my own words so that the writing style matches the rest of this book. </span><span class="koboSpan" id="kobo.31.4">There is no way I could have pulled this off without Quan’s original work and I wanted to tip my hat to the original Python data science kung </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">fu master.</span></span></p>
<h1 id="_idParaDest-335"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.33.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.34.1">To proceed through this chapter, you will need </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">Anaconda, which is a Python distribution tailored to data science workloads. </span><span class="koboSpan" id="kobo.36.2">You can find it, along with installation instructions for your OS, </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">at </span></span><a href="https://anaconda.com"><span class="No-Break"><span class="koboSpan" id="kobo.38.1">https://anaconda.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Likewise, instead of the usual </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">pip</span></strong><span class="koboSpan" id="kobo.42.1">, I’ll be leveraging </span><strong class="source-inline"><span class="koboSpan" id="kobo.43.1">conda</span></strong><span class="koboSpan" id="kobo.44.1">, which is Anaconda’s package manager. </span><span class="koboSpan" id="kobo.44.2">It is installed </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">alongside Anaconda.</span></span></li>
<li><span class="koboSpan" id="kobo.46.1">An installed and working copy of PyCharm. </span><span class="koboSpan" id="kobo.46.2">Its installation was covered in </span><a href="B19644_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.47.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.48.1">, </span><em class="italic"><span class="koboSpan" id="kobo.49.1">Installation and Configuration</span></em><span class="koboSpan" id="kobo.50.1">, in case you are jumping into the middle of </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">this book.</span></span></li>
<li><span class="koboSpan" id="kobo.52.1">This book’s sample source code from GitHub. </span><span class="koboSpan" id="kobo.52.2">We covered cloning the code in </span><a href="B19644_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.53.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.54.1">, </span><em class="italic"><span class="koboSpan" id="kobo.55.1">Installation and Configuration</span></em><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">You’ll find this chapter’s code </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">at </span></span><a href="https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-14"><span class="No-Break"><span class="koboSpan" id="kobo.58.1">https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-14</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.59.1">.</span></span></li>
</ul>
<h1 id="_idParaDest-336"><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.60.1">Working with datasets</span></h1>
<p><span class="koboSpan" id="kobo.61.1">Datasets are the</span><a id="_idIndexMarker1183"/><span class="koboSpan" id="kobo.62.1"> backbone of any data science project. </span><span class="koboSpan" id="kobo.62.2">With a good, well-structured dataset, we have the opportunity to explore, ideate, and discover important insights from the data. </span><span class="koboSpan" id="kobo.62.3">The terms </span><em class="italic"><span class="koboSpan" id="kobo.63.1">good</span></em><span class="koboSpan" id="kobo.64.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.65.1">well-structured</span></em><span class="koboSpan" id="kobo.66.1"> are key. </span><span class="koboSpan" id="kobo.66.2">In the real world, this rarely happens by accident. </span><span class="koboSpan" id="kobo.66.3">I am the lead developer on a project that does data science every day. </span><span class="koboSpan" id="kobo.66.4">We ingest diagnostic, utilization, and performance data from various hardware platforms such as storage arrays, switches, virtualization nodes (such as VMware), backup devices, and more. </span><span class="koboSpan" id="kobo.66.5">We collect it for the entire enterprise; every device in every data center. </span><span class="koboSpan" id="kobo.66.6">Our software then turns that raw data into visualizations that provide insights, allowing organizations to effectively manage their IT estate through consolidating health monitoring, utilization and performance reporting, and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">capacity planning.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">I’ve been at it for 10 years now and we’re always looking to support new devices and systems. </span><span class="koboSpan" id="kobo.68.2">Our challenge, though, is getting the data we need. </span><span class="koboSpan" id="kobo.68.3">When I started 10 years ago, getting data out of a NetApp storage array was very hard because its diagnostic data is dumped as unstructured text. </span><span class="koboSpan" id="kobo.68.4">Contrast that with more modern arrays, which dump data in XML or JSON, or even better, have their own SDKs for interfacing with hardware and extracting the data </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">we need.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">A great deal of effort goes into taking data from various sources and working to mold the raw data into something useful. </span><span class="koboSpan" id="kobo.70.2">Sometimes it’s easy, and sometimes it is very difficult. </span><span class="koboSpan" id="kobo.70.3">Poorly formatted data can lead to erroneous conclusions and </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">false insights.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">A great cautionary tale comes from a large shoe manufacturer. </span><span class="koboSpan" id="kobo.72.2">About 20 years ago, I worked for a company that sold software designed to manage factory production. </span><span class="koboSpan" id="kobo.72.3">We consulted with the shoe company and told them exactly how to model their data for the best results. </span><span class="koboSpan" id="kobo.72.4">They ignored us and </span><a id="_idIndexMarker1184"/><span class="koboSpan" id="kobo.73.1">went a different way. </span><span class="koboSpan" id="kobo.73.2">We told them it wouldn’t work. </span><span class="koboSpan" id="kobo.73.3">They thanked us for our input. </span><span class="koboSpan" id="kobo.73.4">Their projections were galactically wrong, so they did what any big company with boards and shareholders would do – they blamed the software. </span><span class="koboSpan" id="kobo.73.5">Our CEO did the circuit on the business shows, but the damage was done. </span><span class="koboSpan" id="kobo.73.6">Our company stock tanked and a lot of people lost their jobs that year, including me. </span><span class="koboSpan" id="kobo.73.7">To this day, I won’t wear their shoes. </span><span class="koboSpan" id="kobo.73.8">Bad data can cost livelihoods, reputations, and, beyond the context of shoes, even lives. </span><span class="koboSpan" id="kobo.73.9">We must have tools and processes at our disposal that help us get </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">things right.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Let’s go over a few steps of </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">that process.</span></span></p>
<h1 id="_idParaDest-337"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.77.1">Starting with a question</span></h1>
<p><span class="koboSpan" id="kobo.78.1">Everything in science starts with a </span><a id="_idIndexMarker1185"/><span class="koboSpan" id="kobo.79.1">question. </span><span class="koboSpan" id="kobo.79.2">For our purposes, we’ll consider two </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">possible scenarios:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.81.1">We have a specific question in mind and we need to collect and analyze appropriate data to answer </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">that question</span></span></li>
<li><span class="koboSpan" id="kobo.83.1">We already have data, and during exploration, a question </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">has arisen</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.85.1">In our case, we’re going to recreate the data analysis phase of a potentially important breakthrough in the field of medical diagnosis. </span><span class="koboSpan" id="kobo.85.2">I’ll be presenting an example from Kaggle taken from a paper titled </span><em class="italic"><span class="koboSpan" id="kobo.86.1">High-accuracy detection of early Parkinson’s Disease using multiple characteristics of finger movement while typing,</span></em><span class="koboSpan" id="kobo.87.1"> which was conducted by Warwick Adams in 2017. </span><span class="koboSpan" id="kobo.87.2">You’ll find the full study paper and the dataset links in the </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Further reading</span></em><span class="koboSpan" id="kobo.89.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">this chapter.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.91.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.92.1">Kaggle is an online data community designed for data scientists and ML engineers. </span><span class="koboSpan" id="kobo.92.2">The site provides competitions, datasets, playgrounds, and other educational activities to promote the growth of data science, both in academia and the industry. </span><span class="koboSpan" id="kobo.92.3">More information about the website can be found on its home </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">page: </span></span><a href="https://www.kaggle.com/"><span class="No-Break"><span class="koboSpan" id="kobo.94.1">https://www.kaggle.com/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.95.1">.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.96.1">Parkinson’s Disease</span></strong><span class="koboSpan" id="kobo.97.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.98.1">PD</span></strong><span class="koboSpan" id="kobo.99.1">) is a condition that affects</span><a id="_idIndexMarker1186"/><span class="koboSpan" id="kobo.100.1"> the brain and causes problems with movement. </span><span class="koboSpan" id="kobo.100.2">It’s a progressive disease, which means it gets worse over time. </span><span class="koboSpan" id="kobo.100.3">More than 6 million people around the world have this disease. </span><span class="koboSpan" id="kobo.100.4">In PD, a specific type of brain cell that produces a chemical called </span><em class="italic"><span class="koboSpan" id="kobo.101.1">dopamine</span></em><span class="koboSpan" id="kobo.102.1"> starts to die</span><a id="_idIndexMarker1187"/><span class="koboSpan" id="kobo.103.1"> off. </span><span class="koboSpan" id="kobo.103.2">This leads to a variety of symptoms, including difficulty with movement and other </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">non-movement-related issues.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">At the time of writing, doctors don’t have a definite test to diagnose PD, especially in the early stages when the symptoms might not be very obvious. </span><span class="koboSpan" id="kobo.105.2">This results in mistakes in diagnosing the disease, with up to 25% of cases being misdiagnosed by doctors who aren’t specialists in PD. </span><span class="koboSpan" id="kobo.105.3">Some people can have PD for many </span><a id="_idIndexMarker1188"/><span class="koboSpan" id="kobo.106.1">years before they are </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">correctly diagnosed.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.108.1">This leads us to a question…</span></p>
<p class="callout"><span class="koboSpan" id="kobo.109.1">How can we effectively and accurately diagnose PD using some test, metric, or diagnostic data point without specialized </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">clinical training?</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Adams suggested a test that uses computer typing data collected over time. </span><span class="koboSpan" id="kobo.111.2">Since typing involves fine motor movement, and since this fine motor movement is the first thing to go during the early onset of PD, Adams hoped it would be possible to use the mundane task of typing as a diagnostic tool. </span><span class="koboSpan" id="kobo.111.3">The researchers tested this method on 103 people; 32 of them had mild PD and the rest, the control group, didn’t have PD. </span><span class="koboSpan" id="kobo.111.4">The computer analysis of their typing patterns was able to tell the difference between the people with early-stage PD and those without it. </span><span class="koboSpan" id="kobo.111.5">This method correctly identified PD with 96% accuracy in detecting those who had it, and 97% accuracy in correctly identifying those who didn’t. </span><span class="koboSpan" id="kobo.111.6">This suggests that this method might be good at distinguishing between the two groups. </span><span class="koboSpan" id="kobo.111.7">Let’s see whether we can draw the same conclusion given their </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">study’s data.</span></span></p>
<h2 id="_idParaDest-338"><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.113.1">Archived user data</span></h2>
<p><span class="koboSpan" id="kobo.114.1">Within this chapter’s source code, you’ll find a data science project called </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">pipeline</span></strong><span class="koboSpan" id="kobo.116.1">. </span><span class="koboSpan" id="kobo.116.2">The project contains a data folder</span><a id="_idIndexMarker1189"/><span class="koboSpan" id="kobo.117.1"> containing our datasets in two folders: </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">Archived users</span></strong><span class="koboSpan" id="kobo.119.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">Tappy Data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.122.1">The data within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Archived users</span></strong><span class="koboSpan" id="kobo.124.1"> folder is in text file format and appears </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.126.1">
BirthYear: 1952
Gender: Female
Parkinsons: True
Tremors: True
DiagnosisYear: 2000
Sided: Left
UPDRS: Don't know
Impact: Severe
Levodopa: True
DA: True
MAOB: False
Other: False</span></pre> <p><span class="koboSpan" id="kobo.127.1">For the sake of immersion, let’s demystify this a little bit. </span><span class="koboSpan" id="kobo.127.2">These are the fields we have in </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">each record:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Birth Year: 1952</span></strong><span class="koboSpan" id="kobo.130.1">: This person was born </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">in 1952.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">Gender: Female</span></strong><span class="koboSpan" id="kobo.133.1">: This person identifies </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">as female.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">Parkinsons: True</span></strong><span class="koboSpan" id="kobo.136.1">: The person has been diagnosed </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">with PD.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">Tremors: True</span></strong><span class="koboSpan" id="kobo.139.1">: Tremors, which are involuntary shaking movements, are present in this person. </span><span class="koboSpan" id="kobo.139.2">Tremors are a common symptom </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">of PD.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">DiagnosisYear: 2000</span></strong><span class="koboSpan" id="kobo.142.1">: The person was diagnosed with PD </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">in 2000.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">Sided: Left</span></strong><span class="koboSpan" id="kobo.145.1">: The term </span><em class="italic"><span class="koboSpan" id="kobo.146.1">sided</span></em><span class="koboSpan" id="kobo.147.1"> in this context likely refers to the side of the body where the symptoms are more pronounced. </span><span class="koboSpan" id="kobo.147.2">In this case, the symptoms are more noticeable on the left-hand side of </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">the body.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">UPDRS: Don't know</span></strong><span class="koboSpan" id="kobo.150.1">: The </span><strong class="bold"><span class="koboSpan" id="kobo.151.1">Unified Parkinson’s Disease Rating Scale</span></strong><span class="koboSpan" id="kobo.152.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.153.1">UPDRS</span></strong><span class="koboSpan" id="kobo.154.1">) is a tool that’s used to</span><a id="_idIndexMarker1190"/><span class="koboSpan" id="kobo.155.1"> assess the severity of PD. </span><span class="koboSpan" id="kobo.155.2">In this case, it’s not known what the specific UPDRS score is for</span><a id="_idIndexMarker1191"/> <span class="No-Break"><span class="koboSpan" id="kobo.156.1">this individual.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Impact: Severe</span></strong><span class="koboSpan" id="kobo.158.1">: The impact of PD on this person’s life is considered severe, indicating that the symptoms have a significant effect on their daily activities and quality </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">of life.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Levodopa: True</span></strong><span class="koboSpan" id="kobo.161.1">: Levodopa is a common medication used to manage the symptoms of PD. </span><span class="koboSpan" id="kobo.161.2">This person is taking Levodopa as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">their treatment.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">DA: True</span></strong><span class="koboSpan" id="kobo.164.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.165.1">Dopamine agonists</span></strong><span class="koboSpan" id="kobo.166.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.167.1">DAs</span></strong><span class="koboSpan" id="kobo.168.1">) are another</span><a id="_idIndexMarker1192"/><span class="koboSpan" id="kobo.169.1"> type of medication used to manage Parkinson’s symptoms. </span><span class="koboSpan" id="kobo.169.2">This person is taking dopamine agonists as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">their treatment.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">MAOB: False</span></strong><span class="koboSpan" id="kobo.172.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.173.1">Monoamine oxidase B inhibitors</span></strong><span class="koboSpan" id="kobo.174.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.175.1">MOABs</span></strong><span class="koboSpan" id="kobo.176.1">) are medications that can help manage Parkinson’s symptoms</span><a id="_idIndexMarker1193"/><span class="koboSpan" id="kobo.177.1"> by increasing dopamine levels in the brain. </span><span class="koboSpan" id="kobo.177.2">In this case, the person is not </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">taking MAOBs.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Other: False</span></strong><span class="koboSpan" id="kobo.180.1">: If I were recreating this study for real, I would likely contact the original researcher if this data point wasn’t explained directly in the publication. </span><span class="koboSpan" id="kobo.180.2">Since I’m not, I’ll guess that it won’t affect our project. </span><span class="koboSpan" id="kobo.180.3">This likely refers to other specific medications or treatments for PD, indicating that the person is not undergoing any other specialized treatments beyond Levodopa </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">and DAs.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.182.1">In summary, this individual was a 65-year-old woman at the time of the study who was diagnosed with PD in 2000. </span><span class="koboSpan" id="kobo.182.2">She experiences tremors, particularly on the left-hand side of her body. </span><span class="koboSpan" id="kobo.182.3">The impact of the disease on her life is severe. </span><span class="koboSpan" id="kobo.182.4">She is undergoing treatment with Levodopa and DAs to manage her symptoms, but she is not using MAOBs or any other specialized treatments. </span><span class="koboSpan" id="kobo.182.5">The specific severity of her symptoms, as measured by the UPDRS, is not provided in the </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">given information.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">The filenames in the folder are important. </span><span class="koboSpan" id="kobo.184.2">It isn’t ethical to publish </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">personally identifiable information</span></strong><span class="koboSpan" id="kobo.186.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.187.1">PII</span></strong><span class="koboSpan" id="kobo.188.1">). </span><span class="koboSpan" id="kobo.188.2">In many </span><a id="_idIndexMarker1194"/><span class="koboSpan" id="kobo.189.1">countries, it is explicitly illegal. </span><span class="koboSpan" id="kobo.189.2">So, each subject in the study is assigned an ID number, which</span><a id="_idIndexMarker1195"/><span class="koboSpan" id="kobo.190.1"> is reflected in the filename. </span><span class="koboSpan" id="kobo.190.2">This data sample came from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">User_0EA27ICBLF.txt</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.192.1"> file.</span></span></p>
<h2 id="_idParaDest-339"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.193.1">Tappy data</span></h2>
<p><span class="koboSpan" id="kobo.194.1">The study methodology uses an </span><a id="_idIndexMarker1196"/><span class="koboSpan" id="kobo.195.1">application called Tappy, which runs on Windows and records each subject’s keypress timing, along with positional data about each key. </span><span class="koboSpan" id="kobo.195.2">If you remember from our earlier discussion of the user data, the sidedness is a factor. </span><span class="koboSpan" id="kobo.195.3">The motor cortex is the region of the brain that is responsible for planning, controlling, and executing voluntary movements. </span><span class="koboSpan" id="kobo.195.4">It’s located in the cerebral cortex, which is the outermost layer of </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">the brain.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">The motor cortex, along with most of the rest of the brain, is divided into two hemispheres: the left hemisphere and the right hemisphere. </span><span class="koboSpan" id="kobo.197.2">Each hemisphere controls the voluntary movements of the opposite side of the body. </span><span class="koboSpan" id="kobo.197.3">In other words, the left hemisphere of the motor cortex controls movements on the right-hand side of the body, and the right hemisphere controls movements on the left-hand side of the body. </span><span class="koboSpan" id="kobo.197.4">Since this is true, knowing which side of the keyboard the keypress data is coming from is potentially of </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">diagnostic importance.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">Let’s open a Tappy dataset and see </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">what’s inside:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer438">
<span class="koboSpan" id="kobo.201.1"><img alt="Figure 14.1: I’ve opened the first file in the Tappy data folder and I can see it is tab-separated data" src="image/B19644_14_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">Figure 14.1: I’ve opened the first file in the Tappy data folder and I can see it is tab-separated data</span></p>
<p><span class="koboSpan" id="kobo.203.1">I can see a warning at the top stating the file is large, by code editor standards, and that code insight is not available. </span><span class="koboSpan" id="kobo.203.2">This is spurious since the data folder in a scientific project in PyCharm is excluded from indexing and code insights anyway. </span><span class="koboSpan" id="kobo.203.3">You can safely ignore </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the warning.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">I can also see that the file is </span><a id="_idIndexMarker1197"/><span class="koboSpan" id="kobo.206.1">tab-delimited, which will play nicely in a data pipeline. </span><span class="koboSpan" id="kobo.206.2">It is always encouraging to see your data come to you in an easily parsable format. </span><span class="koboSpan" id="kobo.206.3">This is effectively structured data that would be suitable for import into a spreadsheet or database table. </span><span class="koboSpan" id="kobo.206.4">That isn’t necessarily what we will do with this data, but if we can do those kinds of imports with a given data file, we can pretty much do anything with </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">As before, the filenames are significant. </span><span class="koboSpan" id="kobo.208.2">The first part of the file, delineated by an underscore, is the ID of the subject from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">Archived users</span></strong><span class="koboSpan" id="kobo.210.1"> folder. </span><span class="koboSpan" id="kobo.210.2">We will be able to relate each subject’s performance data found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">Tappy Data</span></strong><span class="koboSpan" id="kobo.212.1"> folder with their demographical data found in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">Archived </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">users</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.215.1"> folder.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">The fields from the Tappy data file are </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.218.1">Patient ID</span></span></li>
<li><span class="koboSpan" id="kobo.219.1">The date of </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">data collection</span></span></li>
<li><span class="koboSpan" id="kobo.221.1">The timestamp of </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">each keystroke</span></span></li>
<li><span class="koboSpan" id="kobo.223.1">Which hand performed the keystroke (</span><em class="italic"><span class="koboSpan" id="kobo.224.1">L</span></em><span class="koboSpan" id="kobo.225.1"> for left and </span><em class="italic"><span class="koboSpan" id="kobo.226.1">R</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.227.1">for right)</span></span></li>
<li><span class="koboSpan" id="kobo.228.1">Hold time (time between press and release, </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">in milliseconds)</span></span></li>
<li><span class="koboSpan" id="kobo.230.1">The transition from the </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">last keystroke</span></span></li>
<li><span class="koboSpan" id="kobo.232.1">Latency time (time from pressing the previous key, </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">in milliseconds)</span></span></li>
<li><span class="koboSpan" id="kobo.234.1">Flight time (time from releasing the previous key, </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">in milliseconds)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.236.1">We have established that we have raw data in a workable format. </span><span class="koboSpan" id="kobo.236.2">Honestly, I’d call this a good day. </span><span class="koboSpan" id="kobo.236.3">It isn’t completely perfect; we’ll still </span><a id="_idIndexMarker1198"/><span class="koboSpan" id="kobo.237.1">need to do some munging, but it’s a very good </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">starting point.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.239.1">Jargon alert – munging</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.240.1">Munging</span></strong><span class="koboSpan" id="kobo.241.1"> is a colloquial term used in computer programming and data processing to describe the process of manipulating, cleaning, or transforming data from one format into another. </span><span class="koboSpan" id="kobo.241.2">It often involves </span><a id="_idIndexMarker1199"/><span class="koboSpan" id="kobo.242.1">altering the structure or content of data to make it more suitable for a particular purpose, such as analysis, storage, or presentation. </span><span class="koboSpan" id="kobo.242.2">Munging can include activities such as </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">the following:</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.244.1">- </span><strong class="bold"><span class="koboSpan" id="kobo.245.1">Data cleaning</span></strong><span class="koboSpan" id="kobo.246.1">: Removing errors, inconsistencies, or irrelevant</span><a id="_idIndexMarker1200"/><span class="koboSpan" id="kobo.247.1"> information </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">from datasets</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.249.1">- </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">Data transformation</span></strong><span class="koboSpan" id="kobo.251.1">: Changing the format, structure, or </span><a id="_idIndexMarker1201"/><span class="koboSpan" id="kobo.252.1">representation of data to fit a </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">specific requirement</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.254.1">- </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">Data parsing</span></strong><span class="koboSpan" id="kobo.256.1">: Extracting specific pieces </span><a id="_idIndexMarker1202"/><span class="koboSpan" id="kobo.257.1">of information from a </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">larger dataset</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.259.1">- </span><strong class="bold"><span class="koboSpan" id="kobo.260.1">Data aggregation</span></strong><span class="koboSpan" id="kobo.261.1">: Combining multiple </span><a id="_idIndexMarker1203"/><span class="koboSpan" id="kobo.262.1">sets of data into a </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">single dataset</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.264.1">- </span><strong class="bold"><span class="koboSpan" id="kobo.265.1">Data filtering</span></strong><span class="koboSpan" id="kobo.266.1">: Selecting or</span><a id="_idIndexMarker1204"/><span class="koboSpan" id="kobo.267.1"> excluding data based on </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">certain criteria</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.269.1">- </span><strong class="bold"><span class="koboSpan" id="kobo.270.1">Data formatting</span></strong><span class="koboSpan" id="kobo.271.1">: Changing the way data is</span><a id="_idIndexMarker1205"/><span class="koboSpan" id="kobo.272.1"> presented or encoded for compatibility with a certain system </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">or software</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.274.1">The term </span><em class="italic"><span class="koboSpan" id="kobo.275.1">munging</span></em><span class="koboSpan" id="kobo.276.1"> is informal and comes from a blend of </span><em class="italic"><span class="koboSpan" id="kobo.277.1">mangle</span></em><span class="koboSpan" id="kobo.278.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.279.1">modify</span></em><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">It’s often used in a context where data needs to be </span><a id="_idIndexMarker1206"/><span class="koboSpan" id="kobo.281.1">prepared or adjusted for analysis, integration, or some other </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">data-related task.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">We have a good start for our project, but </span><a id="_idIndexMarker1207"/><span class="koboSpan" id="kobo.284.1">we have a question: can we detect early-onset PD using a typing test? </span><span class="koboSpan" id="kobo.284.2">We have raw data from a study that implemented such a typing test. </span><span class="koboSpan" id="kobo.284.3">We’re ready to roll up our sleeves and get </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">into it!</span></span></p>
<h1 id="_idParaDest-340"><a id="_idTextAnchor348"/><span class="koboSpan" id="kobo.286.1">Data collection</span></h1>
<p><span class="koboSpan" id="kobo.287.1">We’re lucky. </span><span class="koboSpan" id="kobo.287.2">I’ve already found our data and included it for your consideration. </span><span class="koboSpan" id="kobo.287.3">In the real world, we would have needed to</span><a id="_idIndexMarker1208"/><span class="koboSpan" id="kobo.288.1"> have performed the normal step of data collection. </span><span class="koboSpan" id="kobo.288.2">While there are entire tomes on this topic – most 4-year scientific university degree programs focus heavily on this topic – I don’t plan on doing a deep dive here. </span><span class="koboSpan" id="kobo.288.3">However, I will at least give you an overview should you be new to what we’re trying </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">to accomplish.</span></span></p>
<h2 id="_idParaDest-341"><a id="_idTextAnchor349"/><span class="koboSpan" id="kobo.290.1">Downloading from an external source</span></h2>
<p><span class="koboSpan" id="kobo.291.1">This is the case for our example dataset</span><a id="_idIndexMarker1209"/><span class="koboSpan" id="kobo.292.1"> since I downloaded it from Kaggle. </span><span class="koboSpan" id="kobo.292.2">When using a dataset downloaded from the internet, we should always make sure to check its copyright license. </span><span class="koboSpan" id="kobo.292.3">Most of the time, if it is in the public domain, we can freely use and distribute it without any worry. </span><span class="koboSpan" id="kobo.292.4">The example dataset we are using is an instance of this. </span><span class="koboSpan" id="kobo.292.5">On the other hand, if the dataset is copyrighted, we might still be able to use it by asking for permission from the author/owner of the dataset. </span><span class="koboSpan" id="kobo.292.6">I have found that, after reaching out to them via email and explaining how their datasets will be used in detail, dataset owners are often willing to share their data </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">with others.</span></span></p>
<h2 id="_idParaDest-342"><a id="_idTextAnchor350"/><span class="koboSpan" id="kobo.294.1">Manually collecting/web scraping</span></h2>
<p><span class="koboSpan" id="kobo.295.1">If the data we want is available online but not formatted in tables or CSV files, most of the time, we need to collect it and</span><a id="_idIndexMarker1210"/><span class="koboSpan" id="kobo.296.1"> manually put it in a dataset ourselves. </span><span class="koboSpan" id="kobo.296.2">At most, we can write a web scraper that can send requests to the websites containing the target data and parse the returned HTML text. </span><span class="koboSpan" id="kobo.296.3">When you have to collect your data this way, it is also important to ensure that you are not doing it illegally. </span><span class="koboSpan" id="kobo.296.4">For example, it is against the law to have a program scrape data off some websites; sometimes, you might need to design the scraper so that only a certain number of requests are made at a given point. </span><span class="koboSpan" id="kobo.296.5">An example of this was when LinkedIn filed a lawsuit against many people who anonymously scraped their data in 2016. </span><span class="koboSpan" id="kobo.296.6">For this reason, it is always a good practice to find the terms of use for the data you are trying to collect </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">this way.</span></span></p>
<h2 id="_idParaDest-343"><a id="_idTextAnchor351"/><span class="koboSpan" id="kobo.298.1">Collecting data via third parties</span></h2>
<p><span class="koboSpan" id="kobo.299.1">Students and researchers who </span><a id="_idIndexMarker1211"/><span class="koboSpan" id="kobo.300.1">find that the data they are looking for in their study cannot be collected online often rely on third-party services to collect that data for them (for example, via crowd-sourcing). </span><span class="koboSpan" id="kobo.300.2">Amazon </span><strong class="bold"><span class="koboSpan" id="kobo.301.1">Mechanical Turk</span></strong><span class="koboSpan" id="kobo.302.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.303.1">MTurk</span></strong><span class="koboSpan" id="kobo.304.1">) is one such service – you can enter any type of question to make a survey and MTurk will introduce that</span><a id="_idIndexMarker1212"/><span class="koboSpan" id="kobo.305.1"> survey to its users. </span><span class="koboSpan" id="kobo.305.2">Participants receive money for taking the survey, which is paid by the owner of the survey. </span><span class="koboSpan" id="kobo.305.3">This option is, again, specifically applicable when you want a representative dataset that is not available </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">online anywhere.</span></span></p>
<h2 id="_idParaDest-344"><a id="_idTextAnchor352"/><span class="koboSpan" id="kobo.307.1">Database exports</span></h2>
<p><span class="koboSpan" id="kobo.308.1">This is most likely the case if you are </span><a id="_idIndexMarker1213"/><span class="koboSpan" id="kobo.309.1">working with data from your company or organization. </span><span class="koboSpan" id="kobo.309.2">Luckily, PyCharm offers many useful features in terms of working with databases and their data sources. </span><span class="koboSpan" id="kobo.309.3">This process was discussed in </span><a href="B19644_11.xhtml#_idTextAnchor266"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.310.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.311.1">, and I highly recommend you check it out if you </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">haven’t already.</span></span></p>
<h1 id="_idParaDest-345"><a id="_idTextAnchor353"/><span class="koboSpan" id="kobo.313.1">Version control for datasets</span></h1>
<p><span class="koboSpan" id="kobo.314.1">Since we took a quick little side</span><a id="_idIndexMarker1214"/><span class="koboSpan" id="kobo.315.1"> journey to discuss data collection, I hope you’ll indulge me once more while we talk about using data in a version control system such as Git. </span><span class="koboSpan" id="kobo.315.2">A little earlier, we opened a data file and PyCharm immediately complained about the size of the file. </span><span class="koboSpan" id="kobo.315.3">By modern standards, an 8 MB file isn’t very big. </span><span class="koboSpan" id="kobo.315.4">However, consider that most code files, PyCharm’s raison d’être, are on average well under 100K in size. </span><span class="koboSpan" id="kobo.315.5">If your files are very large, that’s a code smell and you should figure out what you’re </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">doing wrong.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Here, we’re presenting PyCharm with a file that is about 8,000% bigger than what it is used to. </span><span class="koboSpan" id="kobo.317.2">Git is also primarily used to deal with small files coming out of an IDE. </span><span class="koboSpan" id="kobo.317.3">I’m bringing this up because there is somewhat of a crisis of reproducibility in the data science and scientific computing community. </span><span class="koboSpan" id="kobo.317.4">This is when one data team can extract a specific insight from a dataset but others cannot, even when using the same methods. </span><span class="koboSpan" id="kobo.317.5">Many instances of this are because the data used across these different teams is not compatible with each other. </span><span class="koboSpan" id="kobo.317.6">Some might be using the same but outdated dataset, while other datasets might have been collected from a </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">different source.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Version control for datasets is an</span><a id="_idIndexMarker1215"/><span class="koboSpan" id="kobo.320.1"> important topic to consider. </span><span class="koboSpan" id="kobo.320.2">Git normally has a hard limit of 100 MB for any file, and I can tell you from experience there is an upper limit to the total size of your projects in total on GitHub. </span><span class="koboSpan" id="kobo.320.3">The same limitations exist in other version control systems. </span><span class="koboSpan" id="kobo.320.4">I used to teach game development with a tool called Unity 3D, and we were always struggling with these limitations since video games typically have very large assets in the projects that aren’t necessarily code, but that could benefit from </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">revision control.</span></span></p>
<h2 id="_idParaDest-346"><a id="_idTextAnchor354"/><span class="koboSpan" id="kobo.322.1">Using Git Large File Support</span></h2>
<p><span class="koboSpan" id="kobo.323.1">Since the problem is endemic, Git (and others) have added the ability to track larger assets through </span><strong class="bold"><span class="koboSpan" id="kobo.324.1">Git Large File Support</span></strong><span class="koboSpan" id="kobo.325.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.326.1">Git LFS</span></strong><span class="koboSpan" id="kobo.327.1">). </span><span class="koboSpan" id="kobo.327.2">When we add a file using Git LFS, the system will replace that file</span><a id="_idIndexMarker1216"/><span class="koboSpan" id="kobo.328.1"> with a pointer that simply references it. </span><span class="koboSpan" id="kobo.328.2">When the file is placed under version control, Git will only have a reference to the actual file, which is now stored in an external filesystem, possibly on another server. </span><span class="koboSpan" id="kobo.328.3">Git LFS allows us to apply version control to large files (in this case, datasets) with Git, without actually storing the files </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">in Git.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">This feature is normally installed with modern Git installers. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.331.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.332.1">.2</span></em><span class="koboSpan" id="kobo.333.1"> shows me installing Git for Windows, where LFS is part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">default installation:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer439">
<span class="koboSpan" id="kobo.335.1"><img alt="Figure 14.2: LFS is installed by default in Windows" src="image/B19644_14_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.336.1">Figure 14.2: LFS is installed by default in Windows</span></p>
<p><span class="koboSpan" id="kobo.337.1">You can check your installation, regardless</span><a id="_idIndexMarker1217"/><span class="koboSpan" id="kobo.338.1"> of which OS you use, using the </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">command line:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
git lfs version</span></pre> <p><span class="koboSpan" id="kobo.341.1">My result from running this command in GitBash in Windows 11 is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.342.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.343.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer440">
<span class="koboSpan" id="kobo.345.1"><img alt="Figure 14.3: If LFS is installed, it should tell you the version number" src="image/B19644_14_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.346.1">Figure 14.3: If LFS is installed, it should tell you the version number</span></p>
<p><span class="koboSpan" id="kobo.347.1">The only reason I have Windows (besides Ghost Recon and Steam in general) is so I can use Microsoft Word to write this book. </span><span class="koboSpan" id="kobo.347.2">This wasn’t my idea. </span><span class="koboSpan" id="kobo.347.3">I was going to write the whole thing in raw LaTeX using vi. </span><span class="koboSpan" id="kobo.347.4">Not vim. </span><span class="koboSpan" id="kobo.347.5">Not neovim. </span><span class="koboSpan" id="kobo.347.6">Original gangsta vi, which I naturally would be compiling from source. </span><span class="koboSpan" id="kobo.347.7">My editor said no. </span><span class="koboSpan" id="kobo.347.8">She’s so super polite! </span><span class="koboSpan" id="kobo.347.9">If our roles were reversed, who knows</span><a id="_idIndexMarker1218"/><span class="koboSpan" id="kobo.348.1"> what would have been said? </span><span class="koboSpan" id="kobo.348.2">Anyway, the rest of my real work is</span><a id="_idIndexMarker1219"/><span class="koboSpan" id="kobo.349.1"> done on </span><strong class="bold"><span class="koboSpan" id="kobo.350.1">Pop_OS</span></strong><span class="koboSpan" id="kobo.351.1">, which is a variant of Ubuntu Linux. </span><span class="koboSpan" id="kobo.351.2">When I throw the command into that environment, I get a less hospitable answer, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.352.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.353.1">.4</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer441">
<span class="koboSpan" id="kobo.355.1"><img alt="Figure 14.4: My installer is not modern enough to have LFS pre-installed" src="image/B19644_14_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.356.1">Figure 14.4: My installer is not modern enough to have LFS pre-installed</span></p>
<p><span class="koboSpan" id="kobo.357.1">I don’t have it! </span><span class="koboSpan" id="kobo.357.2">I have to install it using </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">these commands:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.359.1">
sudo apt update
sudo apt install git-lfs</span></pre> <p><span class="koboSpan" id="kobo.360.1">With that done, I can </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">test again:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer442">
<span class="koboSpan" id="kobo.362.1"><img alt="Figure 14.5: Success! If you use some other Linux distribution, check your package management system for the git-lfs package if your installation lacks it" src="image/B19644_14_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">Figure 14.5: Success! </span><span class="koboSpan" id="kobo.363.2">If you use some other Linux distribution, check your package management system for the git-lfs package if your installation lacks it</span></p>
<p><span class="koboSpan" id="kobo.364.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.365.1">apt</span></strong><span class="koboSpan" id="kobo.366.1"> installer is unique to Ubuntu and other Debian variants of Linux. </span><span class="koboSpan" id="kobo.366.2">If you’re using something such as CentOS, Arch, SUSE, or Photon (just kidding), check your package manager and locate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">git-lfs</span></strong><span class="koboSpan" id="kobo.368.1"> package specific to your </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">Linux distribution.</span></span></p>
<h3><span class="koboSpan" id="kobo.370.1">Using Git LFS</span></h3>
<p><span class="koboSpan" id="kobo.371.1">We’re getting a little ahead of </span><a id="_idIndexMarker1220"/><span class="koboSpan" id="kobo.372.1">ourselves. </span><span class="koboSpan" id="kobo.372.2">If you’re going to follow along in this little sidetrack exercise, it would be best if you made a new folder somewhere outside of this book’s code repository. </span><span class="koboSpan" id="kobo.372.3">Let’s assume you’ve something like this in your </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">OS’s terminal:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.374.1">
cd ~/
mkdir git-lfs-test
cd git-lfs-test
git init</span></pre> <p><span class="koboSpan" id="kobo.375.1">This series of commands will work in any of the popular OSs (Windows, macOS, or Linux). </span><span class="koboSpan" id="kobo.375.2">If you are using Windows, this series of commands can be run in PowerShell and assumes you have the Git client for Windows installed. </span><span class="koboSpan" id="kobo.375.3">The installer is available </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">at </span></span><a href="https://git-scm.com/downloads"><span class="No-Break"><span class="koboSpan" id="kobo.377.1">https://git-scm.com/downloads</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.378.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.379.1">The first command takes you to your </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">home</span></strong><span class="koboSpan" id="kobo.381.1"> folder. </span><span class="koboSpan" id="kobo.381.2">The second creates a new folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">git-lfs-test</span></strong><span class="koboSpan" id="kobo.383.1">. </span><span class="koboSpan" id="kobo.383.2">Next, we change the directory to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">git-lfs-test</span></strong><span class="koboSpan" id="kobo.385.1"> folder we just made and we initialize a new repository. </span><span class="koboSpan" id="kobo.385.2">Now, we are ready to set up support for </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">Git LFS.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.387.1">Don’t forget the chapter files are already in a Git repo</span></p>
<p class="callout"><span class="koboSpan" id="kobo.388.1">If you’re following along with this chapter’s source, don’t forget that the files are already in a Git repo. </span><span class="koboSpan" id="kobo.388.2">Creating a second repo within the existing repo won’t work. </span><span class="koboSpan" id="kobo.388.3">If you want to practice, make a completely separate folder outside of this book’s repo, and copy the project files into your folder. </span><span class="koboSpan" id="kobo.388.4">When you copy, you specifically want to avoid copying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">.git</span></strong><span class="koboSpan" id="kobo.390.1"> folder into </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">your target.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">In our project, we’re going to use Git LFS to track files of a given extension, specifically text files with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">.txt</span></strong><span class="koboSpan" id="kobo.394.1"> extension. </span><span class="koboSpan" id="kobo.394.2">Given these files are naturally plain text, you could get creative with the extension without affecting how they are used, but we’ll stick to just </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">.txt</span></strong><span class="koboSpan" id="kobo.396.1">. </span><span class="koboSpan" id="kobo.396.2">I’ll run this command in my </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">terminal window:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
git lfs track "*.txt"</span></pre> <p><span class="koboSpan" id="kobo.399.1">You can see my test run in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.400.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.401.1">.6</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer443">
<span class="koboSpan" id="kobo.403.1"><img alt="Figure 14.6: Git LFS is now tracking all files with the .txt extension" src="image/B19644_14_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.404.1">Figure 14.6: Git LFS is now tracking all files with the .txt extension</span></p>
<p><span class="koboSpan" id="kobo.405.1">To complete my LFS test, I’ll copy the file we examined earlier, </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">0EA27ICBLF_1607.txt</span></strong><span class="koboSpan" id="kobo.407.1">, from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">Tappy Data</span></strong><span class="koboSpan" id="kobo.409.1"> folder into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">git-lfs-test</span></strong><span class="koboSpan" id="kobo.411.1"> folder we’re using for the experiment. </span><span class="koboSpan" id="kobo.411.2">Just to be clear, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.412.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.413.1">.7</span></em><span class="koboSpan" id="kobo.414.1"> shows my folder. </span><span class="koboSpan" id="kobo.414.2">We’re not doing this within any </span><a id="_idIndexMarker1221"/><span class="koboSpan" id="kobo.415.1">sub-folder within this book’s code repository since creating a repository inside another repository is a </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">big no</span><a id="_idTextAnchor355"/><span class="koboSpan" id="kobo.417.1">-no:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer444">
<span class="koboSpan" id="kobo.418.1"><img alt="Figure 14.7: I’ve copied 0EA27ICBLF_1607.txt into the git-lfs-test folder" src="image/B19644_14_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.419.1">Figure 14.7: I’ve copied 0EA27ICBLF_1607.txt into the git-lfs-test folder</span></p>
<p><span class="koboSpan" id="kobo.420.1">Now, let’s add the newly copied text file to </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">the repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.422.1">
git add 0EA27ICBLF_1607.txt
git commit -m "adding big file"
git lfs ls-files</span></pre> <p><span class="koboSpan" id="kobo.423.1">We covered the first two Git commands extensively in </span><a href="B19644_05.xhtml#_idTextAnchor112"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.424.1">Chapter 5</span></em></span></a><span class="koboSpan" id="kobo.425.1">. </span><span class="koboSpan" id="kobo.425.2">The last command will list all files being tracked by LFS in this repository. </span><span class="koboSpan" id="kobo.425.3">You can see my output in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.426.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.427.1">.8</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer445">
<span class="koboSpan" id="kobo.429.1"><img alt="Figure 14.8: I can see that my text file is being tracked by LFS" src="image/B19644_14_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.430.1">Figure 14.8: I can see that my text file is being tracked by LFS</span></p>
<p><span class="koboSpan" id="kobo.431.1">You now understand how to use Git LFS to track large files. </span><span class="koboSpan" id="kobo.431.2">If this were a real repository we were interested in </span><a id="_idIndexMarker1222"/><span class="koboSpan" id="kobo.432.1">keeping, there’s one last thing we’d need to do. </span><span class="koboSpan" id="kobo.432.2">When we commanded Git to track our text files, a special file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">.gitattributes</span></strong><span class="koboSpan" id="kobo.434.1"> was created on our behalf. </span><span class="koboSpan" id="kobo.434.2">We should add and commit </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">that file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
Git add .gitattributes
Git commit -m "Added .gitattributes to repo"</span></pre> <p><span class="koboSpan" id="kobo.437.1">You’re all set! </span><span class="koboSpan" id="kobo.437.2">Let’s move on to our next formal step in the process of data analysis, which entails data cleansing </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">and preprocessing.</span></span></p>
<h1 id="_idParaDest-347"><a id="_idTextAnchor356"/><span class="koboSpan" id="kobo.439.1">Data cleansing and preprocessing</span></h1>
<p><span class="koboSpan" id="kobo.440.1">As I mentioned earlier, we’ve been pretty lucky. </span><span class="koboSpan" id="kobo.440.2">Some of the data my team works with can be downright filthy. </span><span class="koboSpan" id="kobo.440.3">When we use</span><a id="_idIndexMarker1223"/><span class="koboSpan" id="kobo.441.1"> terms such as “dirty," “filthy,” and “cleansing” concerning data, what we’re talking about is addressing the format of the data, as well as the fitness of the data for processing. </span><span class="koboSpan" id="kobo.441.2">Data is only useful if it’s in a format we can work with. </span><span class="koboSpan" id="kobo.441.3">Structured data is what we </span><span class="No-Break"><span class="koboSpan" id="kobo.442.1">always prefer.</span></span></p>
<p><span class="koboSpan" id="kobo.443.1">Structured data refers to data that is split into identifiable fields. </span><span class="koboSpan" id="kobo.443.2">We’ve seen comma-separated and tab-separated text. </span><span class="koboSpan" id="kobo.443.3">Other examples of structured data include formats such as XML, JSON, Parquet, and HDF5. </span><span class="koboSpan" id="kobo.443.4">The first two, XML and JSON, are very common and have the advantage of being text formats. </span><span class="koboSpan" id="kobo.443.5">The latter two, Parquet and HDF5, are binary files and are specialized for storing larger datasets than would be comfortable when working with text. </span><span class="koboSpan" id="kobo.443.6">As we’ve seen, most tools, including PyCharm, buckle when they try to read very large text files. </span><span class="koboSpan" id="kobo.443.7">You</span><a id="_idIndexMarker1224"/><span class="koboSpan" id="kobo.444.1"> need tools specialized for working with large files if you want to peruse or edit them </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">in place.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">When I talk about dirty versus clean data, I’m looking for things such as missing or invalid field data. </span><span class="koboSpan" id="kobo.446.2">Recall our earlier </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">data sample:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.448.1">
BirthYear: 1952
Gender: Female
Parkinsons: True
Tremors: True
DiagnosisYear: 2000
Sided: Left
UPDRS: Don't know
Impact: Severe
Levadopa: True
DA: True
MAOB: False
Other: False</span></pre> <p><span class="koboSpan" id="kobo.449.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">UPDRS</span></strong><span class="koboSpan" id="kobo.451.1"> field is marked as unknown. </span><span class="koboSpan" id="kobo.451.2">This isn’t ideal. </span><span class="koboSpan" id="kobo.451.3">If the field is included, I’d like to see a value there. </span><span class="koboSpan" id="kobo.451.4">In this case, there’s no way to backfill it, but in a perfect world, that might be a candidate for an exercise in </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">data cleansing.</span></span></p>
<h2 id="_idParaDest-348"><a id="_idTextAnchor357"/><span class="koboSpan" id="kobo.453.1">A toxic data example peripherally involving ninjas</span></h2>
<p><span class="koboSpan" id="kobo.454.1">The most relatable example I’ve ever </span><a id="_idIndexMarker1225"/><span class="koboSpan" id="kobo.455.1">encountered with dirty – or in this case, toxic – data came from the corporate world rather than from a data science experiment. </span><span class="koboSpan" id="kobo.455.2">My company was consulting for a large aviation company, which is also a contractor for the US Department of Defense. </span><span class="koboSpan" id="kobo.455.3">I won’t be naming real names here because I am generally averse to government ninjas kicking in my door at 2 A.M., or worse, being flagged for a tax audit for what I’ve written here. </span><span class="koboSpan" id="kobo.455.4">So, we’ll keep this more or </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">less theoretical.</span></span></p>
<p><span class="koboSpan" id="kobo.457.1">The aviation company did business with lots of vendors, and when you do business with vendors at scale, it isn’t uncommon to see discounts applied to whatever you might be buying based on volume. </span><span class="koboSpan" id="kobo.457.2">If you or I go to Hammers R Us and buy a hammer, we might pay $12.95 for a hammer. </span><span class="koboSpan" id="kobo.457.3">But if the aviation company buys 5,000 hammers across many orders in a single quarter, they might get a discount of up to 60%. </span><span class="koboSpan" id="kobo.457.4">It is the aviation company’s job to track what they buy and from whom so that they can cash in on whatever bulk purchasing deals their company has negotiated with </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">their suppliers.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">When it’s time to run the discount reports, an accounting analyst might query a database filled with data entered by hundreds or even thousands of people working in the field on behalf of the aviation company. </span><span class="koboSpan" id="kobo.459.2">Since these operatives are human, their ability to enter clean, standardized data into a poorly designed system without any kind of validation is virtually nil. </span><span class="koboSpan" id="kobo.459.3">In this case, the software used for order entry allowed users to type the name of the company into a text field, which was never validated against any sort of approved </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">vendors list.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">One guy enters a purchase</span><a id="_idIndexMarker1226"/><span class="koboSpan" id="kobo.462.1"> with the vendor listed as “Hammers R Us.” </span><span class="koboSpan" id="kobo.462.2">Another enters it as "HRUS" (naturally that’s the stock symbol), and another as "H.R.U.S." </span><span class="koboSpan" id="kobo.462.3">Someone else misspells it as “Hammers Are Us” and yet another as “Hammers-R-Us.” </span><span class="koboSpan" id="kobo.462.4">Now, we have five different references to the same company, which dilutes our ability to figure out how much of a discount we can ask for. </span><span class="koboSpan" id="kobo.462.5">If there are 5 spellings and the purchase quantities are even across 5 orders, each order will only be for 1,000 hammers and our discount is only 20% instead of 60%. </span><span class="koboSpan" id="kobo.462.6">Our toxic data problem is costing the company </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">serious money!</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">The aviation company hired my </span><a id="_idIndexMarker1227"/><span class="koboSpan" id="kobo.465.1">company to do </span><strong class="bold"><span class="koboSpan" id="kobo.466.1">data cleansing</span></strong><span class="koboSpan" id="kobo.467.1">. </span><span class="koboSpan" id="kobo.467.2">It was our job to clean all the data up and standardize all the references to Hammers R Us. </span><span class="koboSpan" id="kobo.467.3">The project was successful for us because all we had to do was charge the client a few dollars less than what they were losing, which was substantial. </span><span class="koboSpan" id="kobo.467.4">Then, we helped them fix their software to make it impossible to enter toxic data after that. </span><span class="koboSpan" id="kobo.467.5">It was a win for everyone! </span><span class="koboSpan" id="kobo.467.6">I even got a free hammer from Hammers R Us, at least in my version of the story that entails me not getting audited or visited </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">by ninjas.</span></span></p>
<h2 id="_idParaDest-349"><a id="_idTextAnchor358"/><span class="koboSpan" id="kobo.469.1">Exploratory analysis in PyCharm</span></h2>
<p><span class="koboSpan" id="kobo.470.1">While data cleansing in a data science project isn’t usually financially profitable, it is a very necessary step. </span><span class="koboSpan" id="kobo.470.2">As you begin to examine your data for the first time, you will often hear this process referred to as </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">exploratory data analysis</span></strong><span class="koboSpan" id="kobo.472.1">, where we are exploring and analyzing the data at the same time. </span><span class="koboSpan" id="kobo.472.2">What </span><a id="_idIndexMarker1228"/><span class="koboSpan" id="kobo.473.1">we’re doing though is taking stock to see what we can do with our data. </span><span class="koboSpan" id="kobo.473.2">It would be very difficult to perform a tabulation, such as computing sums, means, and standard deviations, without first making sure all our necessary data is both there and in a usable numerical format. </span><span class="koboSpan" id="kobo.473.3">We might also look for outliers. </span><span class="koboSpan" id="kobo.473.4">Maybe a hammer order was misentered and we have an order for a million hammers that was canceled via a separate transaction. </span><span class="koboSpan" id="kobo.473.5">These kinds of outliers would likely need to be removed before we begin our analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">in earnest.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">In the case of our data, a few things are </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">bothering me:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.477.1">The study says it examined 103 subjects; however, there are 277 user files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">Archived users</span></strong><span class="koboSpan" id="kobo.479.1"> folder. </span><span class="koboSpan" id="kobo.479.2">I suspect that not every user has matching collected data. </span><span class="koboSpan" id="kobo.479.3">We’ll need a way to check that each user in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.480.1">Archived users</span></strong><span class="koboSpan" id="kobo.481.1"> folder has a related dataset in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">Tappy </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">Data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.484.1"> folder.</span></span></li>
<li><span class="koboSpan" id="kobo.485.1">Our raw data is purely textual, which means when we import it into Python by reading the files, the data will be expressed as strings. </span><span class="koboSpan" id="kobo.485.2">This is not ideal for data analysis. </span><span class="koboSpan" id="kobo.485.3">I’d like numbers to be converted into number types, dates into date types, Booleans into Boolean, and </span><span class="No-Break"><span class="koboSpan" id="kobo.486.1">so on.</span></span></li>
<li><span class="koboSpan" id="kobo.487.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">Impact</span></strong><span class="koboSpan" id="kobo.489.1"> column should be fully standardized to account for missing values in the data. </span><span class="koboSpan" id="kobo.489.2">Naturally, this applies to any other column where I can see or suspect the data might contain </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">missing values.</span></span></li>
<li><span class="koboSpan" id="kobo.491.1">We can convert some of the fields in the user datasets into a binary format to make analysis easier. </span><span class="koboSpan" id="kobo.491.2">Specific examples include </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">Parkinsons</span></strong><span class="koboSpan" id="kobo.493.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">Tremors</span></strong><span class="koboSpan" id="kobo.495.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.496.1">Levadopa</span></strong><span class="koboSpan" id="kobo.497.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">DA</span></strong><span class="koboSpan" id="kobo.499.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">MAOB</span></strong><span class="koboSpan" id="kobo.501.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">Other</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.505.1">We can use a process called one-hot encoding to more easily process the fields labeled </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">Sided</span></strong><span class="koboSpan" id="kobo.507.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">UPDRS</span></strong><span class="koboSpan" id="kobo.509.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">Impact</span></strong><span class="koboSpan" id="kobo.511.1">. </span><span class="koboSpan" id="kobo.511.2">I’ll go into detail on one-hot encoding once we’re ready to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">this process.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.513.1">This is just what I see at first glance. </span><span class="koboSpan" id="kobo.513.2">There may be other opportunities for cleansing that present themselves once we </span><a id="_idIndexMarker1229"/><span class="No-Break"><span class="koboSpan" id="kobo.514.1">get underway.</span></span></p>
<h3><span class="koboSpan" id="kobo.515.1">Reading the data from text files</span></h3>
<p><span class="koboSpan" id="kobo.516.1">Let’s look at what we need to do with</span><a id="_idIndexMarker1230"/><span class="koboSpan" id="kobo.517.1"> preprocessing our data. </span><span class="koboSpan" id="kobo.517.2">If you open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">data_clean.py</span></strong><span class="koboSpan" id="kobo.519.1"> file, you’ll see our clean-up script, which uses the cell mode discussed in </span><a href="B19644_12.xhtml#_idTextAnchor298"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.520.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.521.1">. </span><span class="koboSpan" id="kobo.521.2">Our first cell handles </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">our imports:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.523.1">
import pandas as pd
import numpy as np
import os
import gc</span></pre> <p><span class="koboSpan" id="kobo.524.1">If you’re following along with this chapter’s code, don’t forget to create a virtual environment using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">requirements.txt</span></strong><span class="koboSpan" id="kobo.526.1"> file. </span><span class="koboSpan" id="kobo.526.2">Here we’re importing a few old friends. </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">numpy</span></strong><span class="koboSpan" id="kobo.528.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">pandas</span></strong><span class="koboSpan" id="kobo.530.1"> are standard analysis libraries. </span><span class="koboSpan" id="kobo.530.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">os</span></strong><span class="koboSpan" id="kobo.532.1"> package will be needed for working with the file directories, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">gc</span></strong><span class="koboSpan" id="kobo.534.1"> package allows us to control the </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">garbage collection</span></strong><span class="koboSpan" id="kobo.536.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.537.1">GC</span></strong><span class="koboSpan" id="kobo.538.1">) process. </span><span class="koboSpan" id="kobo.538.2">If you’ve</span><a id="_idIndexMarker1231"/><span class="koboSpan" id="kobo.539.1"> never heard of this before, it is because most programming languages, including Python, handle GC automatically. </span><span class="koboSpan" id="kobo.539.2">One common occurrence of GC happens when a variable, which will have memory allocated to store its value, goes out of scope and is no longer needed. </span><span class="koboSpan" id="kobo.539.3">In the C programming language, you would need to allocate that memory yourself before you could use the variable. </span><span class="koboSpan" id="kobo.539.4">When you were finished with the variable, you’d need to deallocate that memory “by hand.” </span><span class="koboSpan" id="kobo.539.5">If you didn’t, you’d be using more memory than you needed, and that’s the kind of thing that gets you uninvited to the Pi Day </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">pizza party.</span></span></p>
<p><span class="koboSpan" id="kobo.541.1">Most modern languages handle this allocation and deallocation automatically in a process called GC. </span><span class="koboSpan" id="kobo.541.2">However, there are times, especially when you are loading and manipulating large amounts of data, that it makes sense to take a more active role when the garbage gets taken out, which frees up memory for </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">further exploits.</span></span></p>
<p><span class="koboSpan" id="kobo.543.1">With our imports out of the way, let’s read some data with the </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">following cell:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.545.1">
#%% Read in data
user_file_list = os.listdir('data/Archived users/')
user_set_v1 = set(map(lambda x: x[5: 15], user_file_list)) # [5: 15] to return just the user IDs</span></pre> <p><span class="koboSpan" id="kobo.546.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">os.listdir</span></strong><span class="koboSpan" id="kobo.548.1"> method takes our </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">data/Archived users/</span></strong><span class="koboSpan" id="kobo.550.1"> folder and gives us an iterable list of files from that folder. </span><span class="koboSpan" id="kobo.550.2">This is important because we need a list of the IDs for each user, which is contained in </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">the filename.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">We create a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">user_set_v1</span></strong><span class="koboSpan" id="kobo.554.1">, and we instantiate a set. </span><span class="koboSpan" id="kobo.554.2">In Python, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">set</span></strong><span class="koboSpan" id="kobo.556.1"> is a built-in data type that represents an unordered collection of unique elements. </span><span class="koboSpan" id="kobo.556.2">This means that a set cannot contain duplicate values, and the order in which elements are stored is not guaranteed to be the same as the order in which they </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">were added.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">We fill this </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">set</span></strong><span class="koboSpan" id="kobo.560.1"> with data using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">map</span></strong><span class="koboSpan" id="kobo.562.1"> statement, which iterates over our list of files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">Archived users</span></strong><span class="koboSpan" id="kobo.564.1"> folder. </span><span class="koboSpan" id="kobo.564.2">For each iteration of the map, we use a lambda function to extract a portion of each filename in </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">user_file_list</span></strong><span class="koboSpan" id="kobo.566.1">. </span><span class="koboSpan" id="kobo.566.2">Specifically, it takes a substring from the 5th to the </span><a id="_idIndexMarker1232"/><span class="koboSpan" id="kobo.567.1">15th character of each filename. </span><span class="koboSpan" id="kobo.567.2">This is intended to extract user IDs from the filenames. </span><span class="koboSpan" id="kobo.567.3">Next, we’ll need to do roughly the same thing to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">Tappy </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.570.1"> files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
tappy_file_list = os.listdir('data/Tappy Data/')
user_set_v2 = set(map(lambda x: x[: 10], tappy_file_list)) # [: 10] to return just the user IDs</span></pre> <p><span class="koboSpan" id="kobo.572.1">Now, we have two sets, one from the user files and one from the Tappy data files. </span><span class="koboSpan" id="kobo.572.2">We need to find the intersection between </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">the sets.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">In </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">set theory</span></strong><span class="koboSpan" id="kobo.576.1">, the term </span><em class="italic"><span class="koboSpan" id="kobo.577.1">intersection</span></em><span class="koboSpan" id="kobo.578.1"> refers to an operation that combines two sets to create a new set containing only the elements that are common to both of the original sets. </span><span class="koboSpan" id="kobo.578.2">The intersection of two sets, often denoted by the ∩ symbol, represents the overlap or shared elements between </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">the sets.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Mathematically, if you have two sets, A and B, the intersection of A and B is a new set that contains all the elements that are both in set A and </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">set B.</span></span></p>
<p><span class="koboSpan" id="kobo.582.1">I know all you math geeks out there love your symbols, and I also know that your brains are wired to scan for patterns rather than word-for-word reading, so I’ll help you out. </span><span class="koboSpan" id="kobo.582.2">Symbolically, it is represented as </span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.583.1">A</span></span> <span class="_-----MathTools-_Math_Operator_Extended"><span class="koboSpan" id="kobo.584.1">∩</span></span> <span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.585.1">B</span></span><span class="koboSpan" id="kobo.586.1"> = {</span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.587.1">x</span></span> <span class="_-----MathTools-_Math_Operator_Extended"><span class="koboSpan" id="kobo.588.1">∣</span></span> <span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.589.1">x</span></span> <span class="_-----MathTools-_Math_Operator_Extended"><span class="koboSpan" id="kobo.590.1">∈</span></span> <span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.591.1">A</span></span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.592.1">a</span></span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.593.1">n</span></span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.594.1">d</span></span><span class="_-----MathTools-_Math_Space"> </span><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.595.1">x</span></span> <span class="_-----MathTools-_Math_Operator_Extended"><span class="koboSpan" id="kobo.596.1">∈</span></span> <span class="No-Break"><span class="_-----MathTools-_Math_Variable_v-normal"><span class="koboSpan" id="kobo.597.1">B</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">}</span></span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.600.1">In the context of programming in Python, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">intersection()</span></strong><span class="koboSpan" id="kobo.602.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">set</span></strong><span class="koboSpan" id="kobo.604.1"> performs this mathematical operation. </span><span class="koboSpan" id="kobo.604.2">Given two sets, it returns a new set containing only the elements that exist in </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">both sets.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">For example, let’s say you have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">two sets:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.608.1">Set A = {</span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">1,2,3,4}</span></span></li>
<li><span class="koboSpan" id="kobo.610.1">Set B = {</span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">3,4,5,6}</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.612.1">The intersection of A and B would be A </span><span class="_-----MathTools-_Math_Operator_Extended"><span class="koboSpan" id="kobo.613.1">∩</span></span><span class="koboSpan" id="kobo.614.1"> B = {</span><span class="_-----MathTools-_Math_Number"><span class="koboSpan" id="kobo.615.1">3</span></span><span class="koboSpan" id="kobo.616.1">, </span><span class="_-----MathTools-_Math_Number"><span class="koboSpan" id="kobo.617.1">4</span></span><span class="koboSpan" id="kobo.618.1">} since 3 and 4 are in both sets. </span><span class="koboSpan" id="kobo.618.2">In our case, it is important to get the intersection because the study text stated it examined 103 subjects, yet there are 227 subjects listed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.619.1">Archived users</span></strong><span class="koboSpan" id="kobo.620.1"> folder. </span><span class="koboSpan" id="kobo.620.2">I could make a list, and then go through and visually compare the contents of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">Tappy Data</span></strong><span class="koboSpan" id="kobo.622.1"> folder to make sure</span><a id="_idIndexMarker1233"/><span class="koboSpan" id="kobo.623.1"> everyone is accounted for, but that would be boring, time-consuming, and error-prone. </span><span class="koboSpan" id="kobo.623.2">I’ll just have Python do it </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">for me:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.625.1">
user_set = user_set_v1.intersection(user_set_v2)</span></pre> <p><span class="koboSpan" id="kobo.626.1">Don’t you just love Python’s one-liners? </span><span class="koboSpan" id="kobo.626.2">Sure, there was some setup (hee hee, </span><strong class="bold"><span class="koboSpan" id="kobo.627.1">set</span></strong><span class="koboSpan" id="kobo.628.1"> up), but then bada-bing with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">intersection</span></strong><span class="koboSpan" id="kobo.630.1"> method and we have our new set, which is all funk and no junk! </span><span class="koboSpan" id="kobo.630.2">Let’s see what we’ve got by printing out </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">the length:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.632.1">
print(len(user_set))</span></pre> <p><span class="koboSpan" id="kobo.633.1">I’m going to run the first two cells using the green arrows indicated in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.634.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.635.1">.9</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer446">
<span class="koboSpan" id="kobo.637.1"><img alt="Figure 14.9: I’m running the first two cells we’ve covered so far using the green arrows at the top of each cell" src="image/B19644_14_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.638.1">Figure 14.9: I’m running the first two cells we’ve covered so far using the green arrows at the top of each cell</span></p>
<p><span class="koboSpan" id="kobo.639.1">The result of the run is</span><a id="_idIndexMarker1234"/><span class="koboSpan" id="kobo.640.1"> shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.641.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.642.1">.10</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer447">
<span class="koboSpan" id="kobo.644.1"><img alt="Figure 14.10: I have a relatively clean list of users after our first steps of cleaning the data" src="image/B19644_14_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.645.1">Figure 14.10: I have a relatively clean list of users after our first steps of cleaning the data</span></p>
<p><span class="koboSpan" id="kobo.646.1">We got 217 users with </span><a id="_idIndexMarker1235"/><span class="koboSpan" id="kobo.647.1">correlated data between the two sets, so we’ve managed to eliminate 60 user files we aren’t going to use. </span><span class="koboSpan" id="kobo.647.2">The number doesn’t match the 103 subjects reported in the test, but that’s OK – the day is still young, and we might eliminate more later. </span><span class="koboSpan" id="kobo.647.3">Even if we don’t, there might be other reasons to eliminate properly matched data later on. </span><span class="koboSpan" id="kobo.647.4">Our new set can be used to iterate over data in either data folder since the filenames in both use the ID as a major part of the filename. </span><span class="koboSpan" id="kobo.647.5">This will be very useful in the next step in our data </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">preparation process.</span></span></p>
<p><span class="koboSpan" id="kobo.649.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.650.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.651.1">.10</span></em><span class="koboSpan" id="kobo.652.1">, I’m clicking on the view link to see my list with the </span><strong class="bold"><span class="koboSpan" id="kobo.653.1">SciView</span></strong><span class="koboSpan" id="kobo.654.1"> panel. </span><span class="koboSpan" id="kobo.654.2">It isn’t particularly exciting since it’s just a list of IDs, but the ability to easily inspect as we work without performing </span><a id="_idIndexMarker1236"/><span class="koboSpan" id="kobo.655.1">additional prints is </span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">very useful.</span></span></p>
<h3><span class="koboSpan" id="kobo.657.1">Getting our data into a pandas DataFrame</span></h3>
<p><span class="koboSpan" id="kobo.658.1">Our next cell contains code designed to</span><a id="_idIndexMarker1237"/><span class="koboSpan" id="kobo.659.1"> take our loaded dataset and pull that data into a pandas DataFrame. </span><span class="koboSpan" id="kobo.659.2">pandas is a library that allows for easy analysis of tabular data and even provides a lot of very useful methods for loading data directly into a DataFrame, which is a tabular structure within pandas. </span><span class="koboSpan" id="kobo.659.3">A DataFrame object is a lot like an in-memory spreadsheet without the editor. </span><span class="koboSpan" id="kobo.659.4">You can perform all kinds of calculations with </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">minimal effort.</span></span></p>
<p><span class="koboSpan" id="kobo.661.1">Let’s examine the code from the </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">next cell:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.663.1">
#%% Format into a Pandas dataframe</span></pre> <p><span class="koboSpan" id="kobo.664.1">Don’t forget that </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">#%%</span></strong><span class="koboSpan" id="kobo.666.1"> is a special formatting comment in PyCharm. </span><span class="koboSpan" id="kobo.666.2">It isn’t part of Python. </span><span class="koboSpan" id="kobo.666.3">We covered this back in </span><a href="B19644_13.xhtml#_idTextAnchor318"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.667.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">These characters are used to split cells in our code, which allows us to use one script but operate step-wise from one cell to the next. </span><span class="koboSpan" id="kobo.668.3">At the end of the day, it is still a comment, so we should include some documentation to explain what is happening in </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">the cell.</span></span></p>
<p><span class="koboSpan" id="kobo.670.1">Next, we’ll create a function that reads the data from the files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.671.1">Archived </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">users</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.673.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.674.1">
def read_user_file(file_name):
  f = open('data/Archived users/' + file_name)
  data = [line.split(': ')[1][:-1] for line in f.readlines()]
  f.close()
  return data</span></pre> <p><span class="koboSpan" id="kobo.675.1">The function simply takes a filename as an argument and opens the file. </span><span class="koboSpan" id="kobo.675.2">It then reads the file line by line. </span><span class="koboSpan" id="kobo.675.3">For each line, we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.676.1">split</span></strong><span class="koboSpan" id="kobo.677.1"> string function to split the line into chunks as a list. </span><span class="koboSpan" id="kobo.677.2">This allows us to grab only the parts we need. </span><span class="koboSpan" id="kobo.677.3">As you may recall, a few lines of data for these files look </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.679.1">
BirthYear: 1952
Gender: Female
Parkinsons: True</span></pre> <p><span class="koboSpan" id="kobo.680.1">The separation between the field name and the data is a colon and a space (</span><strong class="source-inline"><span class="koboSpan" id="kobo.681.1">: </span></strong><span class="koboSpan" id="kobo.682.1">). </span><span class="koboSpan" id="kobo.682.2">We’re using that as our splitter, so if you split </span><strong class="source-inline"><span class="koboSpan" id="kobo.683.1">"BirthYear: 1952".split(': ')</span></strong><span class="koboSpan" id="kobo.684.1">, you’ll get back a list: </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">["BirthYear", "1952"]</span></strong><span class="koboSpan" id="kobo.686.1">. </span><span class="koboSpan" id="kobo.686.2">We don’t care about the field name right now, we care about the value. </span><span class="koboSpan" id="kobo.686.3">To get that, we grab </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">[1]</span></strong><span class="koboSpan" id="kobo.688.1">, which gives us </span><strong class="source-inline"><span class="koboSpan" id="kobo.689.1">"1952"</span></strong><span class="koboSpan" id="kobo.690.1">, which is the value, but there is a newline character at the end of each line, and that was included in our split. </span><span class="koboSpan" id="kobo.690.2">The last thing we do, then, before moving on with the next iteration, is clear off the newline</span><a id="_idIndexMarker1238"/><span class="koboSpan" id="kobo.691.1"> character with the Python split operator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">[:-1]</span></strong><span class="koboSpan" id="kobo.693.1">, which effectively says “go to the end of the string,” as evidenced by the fact that the number is after the colon, “and slice off one character from the end,” as denoted by the negative number. </span><span class="koboSpan" id="kobo.693.2">Rather than using a loop, we’ve used list comprehension, which is an alternative way to iterate a list. </span><span class="koboSpan" id="kobo.693.3">These are generally more performant than a normal </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">for</span></strong><span class="koboSpan" id="kobo.695.1"> loop. </span><span class="koboSpan" id="kobo.695.2">The result of the list comprehension is a new list that contains only the data </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">we want.</span></span></p>
<p><span class="koboSpan" id="kobo.697.1">The next few lines are setting us up for filling in a pandas DataFrame. </span><span class="koboSpan" id="kobo.697.2">First, we get a list of files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">Archived </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">users</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.700.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.701.1">
files = os.listdir('data/Archived users/')</span></pre> <p><span class="koboSpan" id="kobo.702.1">Next, we create a list of fields. </span><span class="koboSpan" id="kobo.702.2">We’ve already set up a function to rip the data out of the files without the field name. </span><span class="koboSpan" id="kobo.702.3">Ripping the names at the same time might add a lot of time since it is the same thing over and over; this is simply </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">more efficient:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.704.1">
columns = [
  'BirthYear', 'Gender', 'Parkinsons', 'Tremors', 'DiagnosisYear',
  'Sided', 'UPDRS', 'Impact', 'Levadopa', 'DA', 'MAOB', 'Other'
]</span></pre> <p><span class="koboSpan" id="kobo.705.1">Next, we make an empty DataFrame as a starting point using our </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">columns</span></strong><span class="koboSpan" id="kobo.707.1"> list. </span><span class="koboSpan" id="kobo.707.2">Think of this like making a new spreadsheet, and filling in the first row of your sheet with your </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">column names:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.709.1">
user_df = pd.DataFrame(columns=columns) # empty Data Frame for now</span></pre> <p><span class="koboSpan" id="kobo.710.1">Next, let’s loop through </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">user_set</span></strong><span class="koboSpan" id="kobo.712.1">, which we created in the previous cell. </span><span class="koboSpan" id="kobo.712.2">Remember, this is the list of user IDs that have data in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">Tappy Data</span></strong><span class="koboSpan" id="kobo.714.1"> folder. </span><span class="koboSpan" id="kobo.714.2">Recall that the structure of the filename for this file is the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.715.1">User</span></strong><span class="koboSpan" id="kobo.716.1"> followed by an underscore followed by the user ID and appended with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">.txt</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.718.1">file extension:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.719.1">
for user_id in user_set:
  temp_file_name = 'User_' + user_id + '.txt'</span></pre> <p><span class="koboSpan" id="kobo.720.1">Next, we make sure that the file is there. </span><span class="koboSpan" id="kobo.720.2">It should be since we did our </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">set</span></strong><span class="koboSpan" id="kobo.722.1"> operation earlier, but it is a good idea to check. </span><span class="koboSpan" id="kobo.722.2">If the file isn’t there, our analysis set will crash. </span><span class="koboSpan" id="kobo.722.3">This isn’t a big deal for a few hundred files, but it can be heartbreaking if you’re going through tens of thousands. </span><span class="koboSpan" id="kobo.722.4">Assuming the file is there, we read it into a variable called </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">temp_data</span></strong><span class="koboSpan" id="kobo.724.1"> using the function we created earlier. </span><span class="koboSpan" id="kobo.724.2">Remember, that function returns a list of data values that look just like the cells in a row of a spreadsheet. </span><span class="koboSpan" id="kobo.724.3">Then, we insert that data into the DataFrame using the user ID as the index for </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">the row:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.726.1">
  if temp_file_name in files:
    temp_data = read_user_file(temp_file_name)
    user_df.loc[user_id] = temp_data</span></pre> <p><span class="koboSpan" id="kobo.727.1">Naturally, we want to check, but</span><a id="_idIndexMarker1239"/><span class="koboSpan" id="kobo.728.1"> we don’t want every row – we just want the first few to make sure they are formatted as </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">we expect:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.730.1">
print(user_df.head())</span></pre> <p><span class="koboSpan" id="kobo.731.1">When I run this cell, I get the </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">following output:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer448">
<span class="koboSpan" id="kobo.733.1"><img alt="Figure 14.11: My run of our latest cell shows we have a populated pandas DataFrame" src="image/B19644_14_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.734.1">Figure 14.11: My run of our latest cell shows we have a populated pandas DataFrame</span></p>
<p><span class="koboSpan" id="kobo.735.1">Remember, you can view the DataFrame in </span><strong class="bold"><span class="koboSpan" id="kobo.736.1">SciView</span></strong><span class="koboSpan" id="kobo.737.1"> by clicking the </span><strong class="bold"><span class="koboSpan" id="kobo.738.1">View as DataFrame</span></strong><span class="koboSpan" id="kobo.739.1"> button indicated by the arrow in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.740.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.741.1">.11</span></em><span class="koboSpan" id="kobo.742.1">. </span><span class="koboSpan" id="kobo.742.2">Mine is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.743.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.744.1">.12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer449">
<span class="koboSpan" id="kobo.746.1"><img alt="Figure 14.12: Viewing the DataFrame I created in the previous step is easy and colorful in PyCharm" src="image/B19644_14_12.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.747.1">Figure 14.12: Viewing the DataFrame I created in the previous step is easy and colorful in PyCharm</span></p>
<p><span class="koboSpan" id="kobo.748.1">I can see from this that I still have</span><a id="_idIndexMarker1240"/><span class="koboSpan" id="kobo.749.1"> work to do. </span><span class="koboSpan" id="kobo.749.2">The diagnosis year is messy, as are a few of the other fields. </span><span class="koboSpan" id="kobo.749.3">Let’s keep chipping away </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">at it.</span></span></p>
<h2 id="_idParaDest-350"><a id="_idTextAnchor359"/><span class="koboSpan" id="kobo.751.1">Data cleansing</span></h2>
<p><span class="koboSpan" id="kobo.752.1">Now that we can see our data in a tabular format, there are some ways we can improve the format of this data with the</span><a id="_idIndexMarker1241"/><span class="koboSpan" id="kobo.753.1"> express purpose of performing numerical analysis across any dimensions we </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">might choose.</span></span></p>
<h3><span class="koboSpan" id="kobo.755.1">Changing numeric data into actual numbers</span></h3>
<p><span class="koboSpan" id="kobo.756.1">Our next cell contains a few lines </span><a id="_idIndexMarker1242"/><span class="koboSpan" id="kobo.757.1">of code designed to convert numeric values into numeric types. </span><span class="koboSpan" id="kobo.757.2">Remember, everything is coming in as text and is treated like a string until you tell pandas otherwise. </span><span class="koboSpan" id="kobo.757.3">Here’s the code for </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">the cell:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.759.1">
#%% Change numeric data into appropriate format
# force some columns to have numeric data type
user_df['BirthYear'] = pd.to_numeric(user_df['BirthYear'], errors='coerce')
user_df['DiagnosisYear'] = pd.to_numeric(user_df['DiagnosisYear'], errors='coerce')</span></pre> <p><span class="koboSpan" id="kobo.760.1">An application programmer would be tempted to process the data line by line and handle type conversions field by field. </span><span class="koboSpan" id="kobo.760.2">The neat thing about pandas is that once you have your data in a DataFrame, you can operate on entire rows </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">and columns.</span></span></p>
<p><span class="koboSpan" id="kobo.762.1">In this code, we’re doing just that. </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">BirthYear</span></strong><span class="koboSpan" id="kobo.764.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">DiagnosisYear</span></strong><span class="koboSpan" id="kobo.766.1"> are being converted into numbers using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">pd.to_numeric</span></strong><span class="koboSpan" id="kobo.768.1"> method. </span><span class="koboSpan" id="kobo.768.2">The second argument, </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">errors='coerce'</span></strong><span class="koboSpan" id="kobo.770.1">, will attempt to force a data conversion to a numeric type. </span><span class="koboSpan" id="kobo.770.2">If this is impossible, such as with a value of “</span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">-------</span></strong><span class="koboSpan" id="kobo.772.1">” (a bunch of dashes), which we saw in the </span><strong class="bold"><span class="koboSpan" id="kobo.773.1">SciView</span></strong><span class="koboSpan" id="kobo.774.1"> panel from the previous step, the dashes are replaced in the DataFrame with a bottom condition value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">NaN</span></strong><span class="koboSpan" id="kobo.776.1">, or “not a number.” </span><span class="koboSpan" id="kobo.776.2">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">NaN</span></strong><span class="koboSpan" id="kobo.778.1"> isn’t computationally valuable, it does at least standardize all non-numeric values to just this one, which will make these rows easier to ignore should </span><span class="No-Break"><span class="koboSpan" id="kobo.779.1">we choose.</span></span></p>
<p><span class="koboSpan" id="kobo.780.1">The mention of </span><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">NaN</span></strong><span class="koboSpan" id="kobo.782.1"> also indicates it’s time to bake some delicious bread in your mom’s tandoori oven. </span><span class="koboSpan" id="kobo.782.2">Some authors do Patreon, and I do bread, but it has to be your mom’s recipe. </span><span class="koboSpan" id="kobo.782.3">That means you have to call her and tell her you love her. </span><span class="koboSpan" id="kobo.782.4">Do it now, even if she doesn’t have a tandoori oven and can’t bake bread! </span><span class="No-Break"><span class="koboSpan" id="kobo.783.1">I’ll wait.</span></span></p>
<p><span class="koboSpan" id="kobo.784.1">While you were on the phone, I ran</span><a id="_idIndexMarker1243"/><span class="koboSpan" id="kobo.785.1"> the cell; my result is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.786.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.787.1">.13</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.788.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer450">
<span class="koboSpan" id="kobo.789.1"><img alt="Figure 14.13: The year fields are not actual numbers. Wherever there was invalid data, we now see a standardized value of nan" src="image/B19644_14_13.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.790.1">Figure 14.13: The year fields are not actual numbers. </span><span class="koboSpan" id="kobo.790.2">Wherever there was invalid data, we now see a standardized value of nan</span></p>
<h3><span class="koboSpan" id="kobo.791.1">Binarizing data</span></h3>
<p><span class="koboSpan" id="kobo.792.1">Any place where we can convert data that is essentially binary, we should. </span><span class="koboSpan" id="kobo.792.2">Within our data, gender is reported with two </span><a id="_idIndexMarker1244"/><span class="koboSpan" id="kobo.793.1">possible values, male and female, representing a possibility of representing it in a binary format. </span><span class="koboSpan" id="kobo.793.2">Likewise, many of the fields are presented as binaries, as </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.795.1">
Parkinsons: True
Tremors: True
Levodopa: True
DA: True
MAOB: False
Other: False</span></pre> <p><span class="koboSpan" id="kobo.796.1">In these cases, we just need to standardize the values as actual binaries, which may result in renaming or expanding our list of field names. </span><span class="koboSpan" id="kobo.796.2">Let’s look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.797.1">cell code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.798.1">
#%% "Binarize" true-false data
user_df = user_df.rename(index=str, columns={'Gender': 'Female'})
user_df['Female'] = user_df['Female'] == 'Female'
user_df['Female'] = user_df['Female'].astype(int)</span></pre> <p><span class="koboSpan" id="kobo.799.1">In the preceding code, we</span><a id="_idIndexMarker1245"/><span class="koboSpan" id="kobo.800.1"> renamed the column in our DataFrame from </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">Gender</span></strong><span class="koboSpan" id="kobo.802.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">Female</span></strong><span class="koboSpan" id="kobo.804.1">. </span><span class="koboSpan" id="kobo.804.2">The second line changes the value in each row for the newly renamed column to the result of an expression comparing the current value versus the word </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">Female</span></strong><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">It either is or isn’t </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">Female</span></strong><span class="koboSpan" id="kobo.808.1">, so we get back a </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">True</span></strong><span class="koboSpan" id="kobo.810.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">False</span></strong><span class="koboSpan" id="kobo.812.1"> value. </span><span class="koboSpan" id="kobo.812.2">The third line converts the Boolean type into an integer, making it more amenable </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">to analysis.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">Next, we’ll turn our attention to the previously listed columns and do the same conversion. </span><span class="koboSpan" id="kobo.814.2">This time, we’re checking for the word “True” in our expression. </span><span class="koboSpan" id="kobo.814.3">The value is either </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">True</span></strong><span class="koboSpan" id="kobo.816.1"> or it isn’t, which results in a </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">Boolean value:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.818.1">
str_to_binary_columns = ['Parkinsons', 'Tremors', 'Levadopa', 'DA', 'MAOB', 'Other'] # columns to be converted to binary data
for column in str_to_binary_columns:
  user_df[column] = user_df[column] == 'True'
  user_df[column] = user_df[column].astype(int)</span></pre> <p><span class="koboSpan" id="kobo.819.1">Running this code yields changes to our DataFrame, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.820.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.821.1">.14</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer451">
<span class="koboSpan" id="kobo.823.1"><img alt="Figure 14.14: We’ve successfully binarized our fields" src="image/B19644_14_14.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.824.1">Figure 14.14: We’ve successfully binarized our fields</span></p>
<p><span class="koboSpan" id="kobo.825.1">We can see that our fields are now binary numbers! </span><span class="koboSpan" id="kobo.825.2">This is going to make things </span><span class="No-Break"><span class="koboSpan" id="kobo.826.1">easier later!</span></span></p>
<p><span class="koboSpan" id="kobo.827.1">Let’s jump into the next cell since the</span><a id="_idIndexMarker1246"/><span class="koboSpan" id="kobo.828.1"> first part of the code is doing some more cleanup, similar to what we have done so far. </span><span class="koboSpan" id="kobo.828.2">In the first part of the cell, we are cleaning up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">Impact</span></strong><span class="koboSpan" id="kobo.830.1"> field. </span><span class="koboSpan" id="kobo.830.2">We’re standardizing any value that isn’t </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">Mild</span></strong><span class="koboSpan" id="kobo.832.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">Medium</span></strong><span class="koboSpan" id="kobo.834.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">Severe</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.836.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">None</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.839.1">
# prior processing for `Impact` column
user_df.loc[
  (user_df['Impact'] != 'Medium') &amp;
  (user_df['Impact'] != 'Mild') &amp;
  (user_df['Impact'] != 'Severe'), 'Impact'] = 'None'</span></pre> <p><span class="koboSpan" id="kobo.840.1">Next, while staying in the same cell, we’re going to explore a powerful and popular technique that is used by an </span><a id="_idIndexMarker1247"/><span class="koboSpan" id="kobo.841.1">ML algorithm when preparing data </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">for analysis.</span></span></p>
<h3><span class="koboSpan" id="kobo.843.1">One-hot encoding</span></h3>
<p><span class="koboSpan" id="kobo.844.1">For some reason, when</span><a id="_idIndexMarker1248"/><span class="koboSpan" id="kobo.845.1"> I first heard the term </span><strong class="bold"><span class="koboSpan" id="kobo.846.1">one-hot encoding</span></strong><span class="koboSpan" id="kobo.847.1">, I immediately thought of hot dogs and how I would love to </span><a id="_idIndexMarker1249"/><span class="koboSpan" id="kobo.848.1">encode one with mustard and sweet relish on a nice steamed bun, or maybe the NaN y’all are doing to send me. </span><span class="koboSpan" id="kobo.848.2">For the record, I know that’s not how the bread is spelled, and I don’t care. </span><span class="koboSpan" id="kobo.848.3">The joke only works if I spell it incorrectly. </span><span class="koboSpan" id="kobo.848.4">I don’t know why I’m telling you that, but here </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">we are.</span></span></p>
<p><span class="koboSpan" id="kobo.850.1">One-hot coding is a technique that allows you to take data that isn’t inherently Boolean, and make it so. </span><span class="koboSpan" id="kobo.850.2">When I was in the market for a new Jeep Wrangler, there were only a few colors </span><span class="No-Break"><span class="koboSpan" id="kobo.851.1">I considered:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.852.1">Firecracker Red</span></span></li>
<li><span class="koboSpan" id="kobo.853.1">Ocean </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">Blue Metallic</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.855.1">Mojito!</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.856.1">Hellayella</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.857.1">There are more colors than that, but they are all boring variants of black, white, or gray. </span><span class="koboSpan" id="kobo.857.2">I can’t get an orange Jeep because people will think I went to Oklahoma State University, and we can’t have that. </span><span class="koboSpan" id="kobo.857.3">I can ignore those colors, leaving me with a list that will fit on the page. </span><span class="koboSpan" id="kobo.857.4">Now, let’s one-hot encode </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">that list:</span></span></p>
<table class="No-Table-Style" id="table001-5">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.859.1">Color_Firecracker_Red</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.860.1">Color_Ocean_Blue_Metallic</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.861.1">Color_Mojito</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.862.1">Color_Hellayella</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.863.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.864.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.865.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.866.1">0</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.867.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.868.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.869.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.870.1">0</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.871.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.872.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.873.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.874.1">0</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.875.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.876.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.877.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.878.1">0</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.879.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.880.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.881.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.882.1">1</span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.883.1">You can easily see how one-hot encoding works – it pivots the fields and then makes them binary. </span><span class="koboSpan" id="kobo.883.2">If you’re a relational database guru, you have probably just lost your lunch. </span><span class="koboSpan" id="kobo.883.3">Data scientists do things a little differently. </span><span class="koboSpan" id="kobo.883.4">In the one-hot encoded representation, each observation gets a “1” in the column corresponding to its category and a “0” in all other columns. </span><span class="koboSpan" id="kobo.883.5">This encoding ensures that the</span><a id="_idIndexMarker1250"/><span class="koboSpan" id="kobo.884.1"> categorical information is preserved in a way that ML algorithms can understand and use effectively. </span><span class="koboSpan" id="kobo.884.2">For the record, I went with </span><em class="italic"><span class="koboSpan" id="kobo.885.1">Hellayella</span></em><span class="koboSpan" id="kobo.886.1"> based on the idea that if I got my Jeep stuck somewhere inaccessible, such as the deserts of Big Bend National Park, or deep in the Piney Woods region of east Texas, the rescue helicopters would easily find </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">my corpse.</span></span></p>
<p><span class="koboSpan" id="kobo.888.1">One-hot encoding is commonly used for features such as categorical variables, which can’t be directly used as numerical inputs in many ML algorithms. </span><span class="koboSpan" id="kobo.888.2">It’s an important step in data preprocessing to convert such variables into a suitable format for </span><span class="No-Break"><span class="koboSpan" id="kobo.889.1">training models.</span></span></p>
<p><span class="koboSpan" id="kobo.890.1">Let’s go back to our code for the current cell. </span><span class="koboSpan" id="kobo.890.2">We’ve explained the first few lines, so let’s move on to setting up for one-hot encoding on </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">several fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.892.1">
to_dummy_column_indices = ['Sided', 'UPDRS', 'Impact'] # columns to be one-hot encoded</span></pre> <p><span class="koboSpan" id="kobo.893.1">We’re going to encode these three columns. </span><span class="koboSpan" id="kobo.893.2">One of the columns under consideration is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">Impact</span></strong><span class="koboSpan" id="kobo.895.1"> column, which we just standardized as a lead-in for this step. </span><span class="koboSpan" id="kobo.895.2">We’ll perform the one-hot encoding for all three </span><span class="No-Break"><span class="koboSpan" id="kobo.896.1">columns here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.897.1">
for column in to_dummy_column_indices:
  user_df = pd.concat([
    user_df.iloc[:, : user_df.columns.get_loc(column)],
    pd.get_dummies(user_df[column], prefix=str(column)),
    user_df.iloc[:, user_df.columns.get_loc(column) + 1 :]
  ], axis=1)
print(user_df.head())</span></pre> <p><span class="koboSpan" id="kobo.898.1">Within the loop, the code performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">following steps:</span></span></p>
<ol>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.900.1">user_df.iloc[:, : user_df.columns.get_loc(column)]</span></strong><span class="koboSpan" id="kobo.901.1">: Selects the columns to the left of the current column being processed. </span><span class="koboSpan" id="kobo.901.2">This preserves the columns before the </span><a id="_idIndexMarker1251"/><span class="koboSpan" id="kobo.902.1">one being </span><span class="No-Break"><span class="koboSpan" id="kobo.903.1">one-hot encoded.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.904.1">pd.get_dummies(user_df[column], prefix=str(column))</span></strong><span class="koboSpan" id="kobo.905.1">: Applies one-hot encoding to the current column using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.906.1">pd.get_dummies()</span></strong><span class="koboSpan" id="kobo.907.1"> method. </span><span class="koboSpan" id="kobo.907.2">It creates a DataFrame with binary columns representing the different categories in the column. </span><span class="koboSpan" id="kobo.907.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.908.1">prefix</span></strong><span class="koboSpan" id="kobo.909.1"> parameter adds a prefix to the column names to indicate which original column they were </span><span class="No-Break"><span class="koboSpan" id="kobo.910.1">derived from.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.911.1">user_df.iloc[:, user_df.columns.get_loc(column) + 1 :]</span></strong><span class="koboSpan" id="kobo.912.1">: Selects the columns to the right of the current column being processed. </span><span class="koboSpan" id="kobo.912.2">This preserves the columns after the one being </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">one-hot encoded.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.914.1">When fed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">pd.concat</span></strong><span class="koboSpan" id="kobo.916.1"> method, these steps effectively replace each of the three categorical columns with one-hot encoded binary columns while keeping the rest of the DataFrame intact. </span><span class="koboSpan" id="kobo.916.2">When you run the cell, you should see results like mine, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.917.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.918.1">.15</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer452">
<span class="koboSpan" id="kobo.920.1"><img alt="Figure 14.15: I’ve scrolled to the right so that you can see the newly added one-hot encoded columns that were added" src="image/B19644_14_15.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.921.1">Figure 14.15: I’ve scrolled to the right so that you can see the newly added one-hot encoded columns that were added</span></p>
<p><span class="koboSpan" id="kobo.922.1">One-hot encoding will have</span><a id="_idIndexMarker1252"/><span class="koboSpan" id="kobo.923.1"> added many new columns to the DataFrame, so you might need to scroll to the right to see </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">them all.</span></span></p>
<h2 id="_idParaDest-351"><a id="_idTextAnchor360"/><span class="koboSpan" id="kobo.925.1">Exploring the second dataset</span></h2>
<p><span class="koboSpan" id="kobo.926.1">With our user data fairly well-cleaned</span><a id="_idIndexMarker1253"/><span class="koboSpan" id="kobo.927.1"> up and sitting in a pandas DataFrame, we are now ready to tackle the Tappy data. </span><span class="koboSpan" id="kobo.927.2">To keep things relatable, I’m going to arbitrarily pick one file from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">Tappy Data</span></strong><span class="koboSpan" id="kobo.929.1"> set. </span><span class="koboSpan" id="kobo.929.2">Let’s look at the code in our </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">next cell:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.931.1">
#%% Explore the second dataset
file_name = '0EA27ICBLF_1607.txt'</span></pre> <p><span class="koboSpan" id="kobo.932.1">As I said, I picked one arbitrary file to examine. </span><span class="koboSpan" id="kobo.932.2">We opened one of these files earlier and noted they were all in tab-separated format. </span><span class="koboSpan" id="kobo.932.3">pandas has a method that will easily read this file directly into a DataFrame. </span><span class="koboSpan" id="kobo.932.4">Despite the method being called </span><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">read_csv</span></strong><span class="koboSpan" id="kobo.934.1">, you get to specify a delimiter, which doesn’t have to be a comma. </span><span class="koboSpan" id="kobo.934.2">The method will read any kind of </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">delimited file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.936.1">
df = pd.read_csv(
  'data/Tappy Data/' + file_name,
  delimiter = '\t',
  index_col = False,
  names = ['UserKey', 'Date', 'Timestamp', 'Hand', 'Hold time', 'Direction', 'Latency time', 'Flight time']
)</span></pre> <p><span class="koboSpan" id="kobo.937.1">For our purposes, we don’t </span><a id="_idIndexMarker1254"/><span class="koboSpan" id="kobo.938.1">need the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">UserKey</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.940.1"> field:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.941.1">
df = df.drop('UserKey', axis=1)
print(df.head())</span></pre> <p><span class="koboSpan" id="kobo.942.1">When we run this cell, we create a new DataFrame called </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">df</span></strong><span class="koboSpan" id="kobo.944.1">. </span><span class="koboSpan" id="kobo.944.2">Be sure to pick it from the console variables panel shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.945.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.946.1">.16</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer453">
<span class="koboSpan" id="kobo.948.1"><img alt="Figure 14.16: Our new DataFrame can be viewed by clicking the View as DataFrame button" src="image/B19644_14_16.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.949.1">Figure 14.16: Our new DataFrame can be viewed by clicking the View as DataFrame button</span></p>
<h3><span class="koboSpan" id="kobo.950.1">Formatting datetime data</span></h3>
<p><span class="koboSpan" id="kobo.951.1">The next cell fixes our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">datetime</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1"> data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.954.1">
#%% Format datetime data</span></pre> <p><span class="koboSpan" id="kobo.955.1">This first line tries to force the </span><a id="_idIndexMarker1255"/><span class="koboSpan" id="kobo.956.1">values in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">Date</span></strong><span class="koboSpan" id="kobo.958.1"> column to be dates. </span><span class="koboSpan" id="kobo.958.2">If the coercion doesn’t work, we’ll see </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">NaT</span></strong><span class="koboSpan" id="kobo.960.1"> (not a time), which is disappointing since there’s no food joke to be made. </span><span class="koboSpan" id="kobo.960.2">Next, we’ll do some more coercion on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">Hold time</span></strong><span class="koboSpan" id="kobo.962.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">Latency time</span></strong><span class="koboSpan" id="kobo.964.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">Flight </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.966.1">time</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.967.1"> fields:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.968.1">
df['Date'] = pd.to_datetime(df['Date'], errors='coerce', format='%y%M%d').dt.date
# converting time data to numeric
for column in ['Hold time', 'Latency time', 'Flight time']:
  df[column] = pd.to_numeric(df[column], errors='coerce')</span></pre> <p><span class="koboSpan" id="kobo.969.1">Any observations lacking time data should </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">be dropped:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.971.1">
df = df.dropna(axis=0)</span></pre> <p><span class="koboSpan" id="kobo.972.1">Let’s print the result </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">for inspection:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.974.1">
print(df.head())</span></pre> <p><span class="koboSpan" id="kobo.975.1">Let’s run it! </span><span class="koboSpan" id="kobo.975.2">My cell run results are shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.976.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.977.1">.17</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer454">
<span class="koboSpan" id="kobo.979.1"><img alt="Figure 14.17: Our datetime data is now numeric and any observation with missing time data, being useless, has been dropped" src="image/B19644_14_17.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.980.1">Figure 14.17: Our datetime data is now numeric and any observation with missing time data, being useless, has been dropped</span></p>
<h3><span class="koboSpan" id="kobo.981.1">Washing hands and fixing direction</span></h3>
<p><span class="koboSpan" id="kobo.982.1">The next cell cleans up the</span><a id="_idIndexMarker1256"/><span class="koboSpan" id="kobo.983.1"> hand and </span><span class="No-Break"><span class="koboSpan" id="kobo.984.1">direction columns:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.985.1">
# cleaning data in Hand
df = df[
  (df['Hand'] == 'L') |
  (df['Hand'] == 'R') |
  (df['Hand'] == 'S')
]</span></pre> <p><span class="koboSpan" id="kobo.986.1">This code uses a logical </span><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">OR</span></strong><span class="koboSpan" id="kobo.988.1"> to filter out anything that doesn’t have a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.989.1">L</span></strong><span class="koboSpan" id="kobo.990.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">R</span></strong><span class="koboSpan" id="kobo.992.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">S</span></strong><span class="koboSpan" id="kobo.994.1">. </span><span class="koboSpan" id="kobo.994.2">Since it is presented as an </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">OR</span></strong><span class="koboSpan" id="kobo.996.1">, anything outside the three desirable possibilities will return as </span><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">false</span></strong><span class="koboSpan" id="kobo.998.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">be excluded.</span></span></p>
<p><span class="koboSpan" id="kobo.1000.1">Let’s do the same thing with direction, which has </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">more possibilities:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1002.1">
# cleaning data in Direction
df = df[
  (df['Direction'] == 'LL') |
  (df['Direction'] == 'LR') |
  (df['Direction'] == 'LS') |
  (df['Direction'] == 'RL') |
  (df['Direction'] == 'RR') |
  (df['Direction'] == 'RS') |
  (df['Direction'] == 'SL') |
  (df['Direction'] == 'SR') |
  (df['Direction'] == 'SS')
]</span></pre> <p><span class="koboSpan" id="kobo.1003.1">Of course, we’ll print </span><span class="No-Break"><span class="koboSpan" id="kobo.1004.1">the result:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1005.1">
print(df.head())</span></pre> <p><span class="koboSpan" id="kobo.1006.1">Go ahead and run the cell. </span><span class="koboSpan" id="kobo.1006.2">All rows </span><a id="_idIndexMarker1257"/><span class="koboSpan" id="kobo.1007.1">containing invalid data have been removed. </span><span class="koboSpan" id="kobo.1007.2">This result isn’t as visual as most have been, so I don’t think we need a screenshot for </span><span class="No-Break"><span class="koboSpan" id="kobo.1008.1">this one.</span></span></p>
<h3><span class="koboSpan" id="kobo.1009.1">Summarizing data</span></h3>
<p><span class="koboSpan" id="kobo.1010.1">Our next cell provides an example of how to </span><a id="_idIndexMarker1258"/><span class="koboSpan" id="kobo.1011.1">summarize our data, which we have been working so hard to set up for analysis. </span><span class="koboSpan" id="kobo.1011.2">We’re ready! </span><span class="koboSpan" id="kobo.1011.3">Let’s try something simple. </span><span class="koboSpan" id="kobo.1011.4">As usual, the first line of code in the cell just marks the beginning of </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">the cell:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1013.1">
#%% Group by direction (hand transition)</span></pre> <p><span class="koboSpan" id="kobo.1014.1">Recall that the data we have been working with so far is typing speed data for a specific subject at a given time. </span><span class="koboSpan" id="kobo.1014.2">A subject (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">User</span></strong><span class="koboSpan" id="kobo.1016.1">) is simply a single data point within our first dataset, and we would like to combine the two datasets somehow, so we need a way to aggregate our current data into a single </span><span class="No-Break"><span class="koboSpan" id="kobo.1017.1">data point.</span></span></p>
<p><span class="koboSpan" id="kobo.1018.1">Since we are working with numerical data (typing time), we can take the average (mean) of the time data across different columns as a way to summarize the data of a given user. </span><span class="koboSpan" id="kobo.1018.2">We can achieve this</span><a id="_idIndexMarker1259"/><span class="koboSpan" id="kobo.1019.1"> with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">groupby()</span></strong><span class="koboSpan" id="kobo.1021.1"> function </span><span class="No-Break"><span class="koboSpan" id="kobo.1022.1">from pandas:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1023.1">
 direction_grouped_df = df.groupby('Direction')[numeric_columns].mean()</span></pre> <p><span class="koboSpan" id="kobo.1024.1">Of course, we should </span><span class="No-Break"><span class="koboSpan" id="kobo.1025.1">print it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1026.1">
print(direction_grouped_df)</span></pre> <p><span class="koboSpan" id="kobo.1027.1">The result of the run is shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1028.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1029.1">.18</span></em><span class="koboSpan" id="kobo.1030.1">. </span><span class="koboSpan" id="kobo.1030.2">The code puts the results in a new DataFrame called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">direction_group_df</span></strong><span class="koboSpan" id="kobo.1032.1">, so be sure you select it as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">the figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer455">
<span class="koboSpan" id="kobo.1034.1"><img alt="Figure 14.18: Hooray! We have our first calculated insight!" src="image/B19644_14_18.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1035.1">Figure 14.18: Hooray! </span><span class="koboSpan" id="kobo.1035.2">We have our first calculated insight!</span></p>
<p><span class="koboSpan" id="kobo.1036.1">This is exciting! </span><span class="koboSpan" id="kobo.1036.2">We have the</span><a id="_idIndexMarker1260"/><span class="koboSpan" id="kobo.1037.1"> mechanics working, but now, we need to concentrate on making this work with many data files instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">just one.</span></span></p>
<h2 id="_idParaDest-352"><a id="_idTextAnchor361"/><span class="koboSpan" id="kobo.1039.1">Refactoring for scale</span></h2>
<p><span class="koboSpan" id="kobo.1040.1">Our exploration of the Tappy data has focused on one file to establish in an easily verifiable way that our code is working. </span><span class="koboSpan" id="kobo.1040.2">We’ve</span><a id="_idIndexMarker1261"/><span class="koboSpan" id="kobo.1041.1"> determined that it is, so now, we should refactor our code so that we can process thousands of files. </span><span class="koboSpan" id="kobo.1041.2">To do this, we should consolidate some of our cells into a function. </span><span class="koboSpan" id="kobo.1041.3">The code in the next cell is long but familiar since it is just all the code we’ve written so far combined into one function. </span><span class="koboSpan" id="kobo.1041.4">If you’re an application developer, and you</span><a id="_idIndexMarker1262"/><span class="koboSpan" id="kobo.1042.1"> understand the design principle known as the </span><strong class="bold"><span class="koboSpan" id="kobo.1043.1">single responsibility principle</span></strong><span class="koboSpan" id="kobo.1044.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1045.1">SRP</span></strong><span class="koboSpan" id="kobo.1046.1">), you know this is an antipattern. </span><span class="koboSpan" id="kobo.1046.2">Remember, though, this isn’t application code. </span><span class="koboSpan" id="kobo.1046.3">Nobody will run this beyond performing the analysis, so the rigors of SOLID principles that normally apply to software development are not observed</span><a id="_idIndexMarker1263"/><span class="koboSpan" id="kobo.1047.1"> in data </span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">science work.</span></span></p>
<h3><span class="koboSpan" id="kobo.1049.1">Processing the Tappy data with one function</span></h3>
<p><span class="koboSpan" id="kobo.1050.1">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">the </span></span><span class="No-Break"><a id="_idIndexMarker1264"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1053.1">
#%% Combine into one function
def read_tappy(file_name):</span></pre> <p><span class="koboSpan" id="kobo.1054.1">Here, we’re reading in the CSV filename passed as an argument to our function. </span><span class="koboSpan" id="kobo.1054.2">We enrich the data with hardcoded </span><span class="No-Break"><span class="koboSpan" id="kobo.1055.1">field names:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1056.1">
  df = pd.read_csv(
    'data/Tappy Data/' + file_name,
    delimiter='\t',
    index_col=False,
    names=['UserKey', 'Date', 'Timestamp', 'Hand', 'Hold time',
        'Direction', 'Latency time', 'Flight time']
  )</span></pre> <p><span class="koboSpan" id="kobo.1057.1">We drop the </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">unneeded column:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1059.1">
  df = df.drop('UserKey', axis=1)</span></pre> <p><span class="koboSpan" id="kobo.1060.1">We fix </span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1">the dates:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1062.1">
  df['Date'] = pd.to_datetime(df['Date'], errors='coerce', format='%y%M%d').dt.date
  # Convert time data to numeric
  for column in ['Hold time', 'Latency time', 'Flight time']:
    df[column] = pd.to_numeric(df[column], errors='coerce')
  df = df.dropna(axis=0)</span></pre> <p><span class="koboSpan" id="kobo.1063.1">Always wash your hands by getting rid </span><a id="_idIndexMarker1265"/><span class="koboSpan" id="kobo.1064.1">of </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">invalid values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1066.1">
  # Clean data in `Hand`
  df = df[
    (df['Hand'] == 'L') |
    (df['Hand'] == 'R') |
    (df['Hand'] == 'S')
    ]</span></pre> <p><span class="koboSpan" id="kobo.1067.1">Do the same with direction </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">data values:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1069.1">
  # Clean data in `Direction`
  df = df[
    (df['Direction'] == 'LL') |
    (df['Direction'] == 'LR') |
    (df['Direction'] == 'LS') |
    (df['Direction'] == 'RL') |
    (df['Direction'] == 'RR') |
    (df['Direction'] == 'RS') |
    (df['Direction'] == 'SL') |
    (df['Direction'] == 'SR') |
    (df['Direction'] == 'SS')
    ]</span></pre> <p><span class="koboSpan" id="kobo.1070.1">We’re doing our math! </span><span class="koboSpan" id="kobo.1070.2">This is where the manual GC process comes in. </span><span class="koboSpan" id="kobo.1070.3">It’s a good thing we washed our hands, right? </span><span class="koboSpan" id="kobo.1070.4">In the following code, we’re doing our calculations. </span><span class="koboSpan" id="kobo.1070.5">The results are being returned as a new DataFrame, so to save memory, we’re deleting the old DataFrames as we go. </span><span class="koboSpan" id="kobo.1070.6">This frees up memory </span><a id="_idIndexMarker1266"/><span class="koboSpan" id="kobo.1071.1">since this kind of work is </span><span class="No-Break"><span class="koboSpan" id="kobo.1072.1">memory intensive:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1073.1">
     direction_group_df = df.groupby('Direction')[numeric_columns][numeric_columns][numeric_columns] direction_group_df = df.groupby('Direction')[numeric_columns].mean()
  del df
  gc.collect()</span></pre> <p><span class="koboSpan" id="kobo.1074.1">With our new result, we re-index and </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">then sort:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1076.1">
  direction_group_df = direction_group_df.reindex(
    ['LL', 'LR', 'LS', 'RL', 'RR', 'RS', 'SL', 'SR', 'SS'])
  direction_group_df = direction_group_df.sort_index() # to ensure correct order of data</span></pre> <p><span class="koboSpan" id="kobo.1077.1">This line returns the flattened NumPy array, which contains the mean values of the grouped data. </span><span class="koboSpan" id="kobo.1077.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">.values.flatten()</span></strong><span class="koboSpan" id="kobo.1079.1"> method</span><a id="_idIndexMarker1267"/><span class="koboSpan" id="kobo.1080.1"> converts the DataFrame into a two-dimensional NumPy array and then flattens it into a one-dimensional array for ease </span><span class="No-Break"><span class="koboSpan" id="kobo.1081.1">of use:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1082.1">
  return direction_group_df.values.flatten()</span></pre> <h3><span class="koboSpan" id="kobo.1083.1">Processing the users with a function</span></h3>
<p><span class="koboSpan" id="kobo.1084.1">Within the same cell is a</span><a id="_idIndexMarker1268"/> <span class="No-Break"><span class="koboSpan" id="kobo.1085.1">second function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1086.1">
def process_user(user_id, filenames):
  running_user_data = np.array([])</span></pre> <p><span class="koboSpan" id="kobo.1087.1">This line initializes an empty NumPy array named </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">running_user_data</span></strong><span class="koboSpan" id="kobo.1089.1">. </span><span class="koboSpan" id="kobo.1089.2">This array will be used to accumulate data as the function iterates through filenames, which is what the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">block does:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1091.1">
  for filename in filenames:
    if user_id in filename:
      running_user_data = np.append(running_user_data, read_tappy(filename))</span></pre> <p><span class="koboSpan" id="kobo.1092.1">This loop iterates through the list of filenames. </span><span class="koboSpan" id="kobo.1092.2">If the provided user ID is found in the filename, it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">read_tappy()</span></strong><span class="koboSpan" id="kobo.1094.1"> function (which returns a flattened NumPy array of mean values) and appends its contents to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">running_user_data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1"> array.</span></span></p>
<p><span class="koboSpan" id="kobo.1097.1">After iterating through the filenames and appending the data, the following line reshapes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">running_user_data</span></strong><span class="koboSpan" id="kobo.1099.1"> array into a two-dimensional array, with each row containing 27 columns. </span><span class="koboSpan" id="kobo.1099.2">This flattening of time data allows for </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">further analysis:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1101.1">
  running_user_data = np.reshape(running_user_data, (-1, 27))</span></pre> <p><span class="koboSpan" id="kobo.1102.1">The last line calculates the mean values along the rows (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">axis=0</span></strong><span class="koboSpan" id="kobo.1104.1">) of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">running_user_data</span></strong><span class="koboSpan" id="kobo.1106.1"> array using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">np.nanmean()</span></strong><span class="koboSpan" id="kobo.1108.1">. </span><span class="koboSpan" id="kobo.1108.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">np.nanmean()</span></strong><span class="koboSpan" id="kobo.1110.1"> function ignores </span><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">NaN</span></strong><span class="koboSpan" id="kobo.1112.1"> values while</span><a id="_idIndexMarker1269"/><span class="koboSpan" id="kobo.1113.1"> calculating </span><span class="No-Break"><span class="koboSpan" id="kobo.1114.1">the mean:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1115.1">
  return np.nanmean(running_user_data, axis=0)</span></pre> <p><span class="koboSpan" id="kobo.1116.1">To summarize, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">process_user</span></strong><span class="koboSpan" id="kobo.1118.1"> function processes data for a specific user by iterating through relevant filenames, aggregating the data using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1119.1">read_tappy</span></strong><span class="koboSpan" id="kobo.1120.1"> function, reshaping the data, and calculating the mean values while ignoring </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">NaN</span></strong><span class="koboSpan" id="kobo.1122.1"> values. </span><span class="koboSpan" id="kobo.1122.2">The final result is an array of mean values for each column of </span><span class="No-Break"><span class="koboSpan" id="kobo.1123.1">the data.</span></span></p>
<h3><span class="koboSpan" id="kobo.1124.1">Processing all the data</span></h3>
<p><span class="koboSpan" id="kobo.1125.1">This one’s for all the marbles! </span><span class="koboSpan" id="kobo.1125.2">The</span><a id="_idIndexMarker1270"/><span class="koboSpan" id="kobo.1126.1"> following cell processes the data for all available users by aggregating and calculating mean values based on the Tappy data. </span><span class="koboSpan" id="kobo.1126.2">First, there’s a little housekeeping. </span><span class="koboSpan" id="kobo.1126.3">We’re going to ignore </span><span class="No-Break"><span class="koboSpan" id="kobo.1127.1">any warnings:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1128.1">
#%% Run through all available data
import warnings
warnings.filterwarnings("ignore")</span></pre> <p><span class="koboSpan" id="kobo.1129.1">We’ll make one more trip through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">Tappy </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">Data</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1132.1"> folder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1133.1">
filenames = os.listdir('data/Tappy Data/')</span></pre> <p><span class="koboSpan" id="kobo.1134.1">Next, we’ll make some column names for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1135.1">final DataFrame:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1136.1">
column_names = [first_hand + second_hand + '_' + time
        for first_hand in ['L', 'R', 'S']
        for second_hand in ['L', 'R', 'S']
        for time in ['Hold time', 'Latency time', 'Flight time']]
user_tappy_df = pd.DataFrame(columns=column_names)</span></pre> <p><span class="koboSpan" id="kobo.1137.1">Next, let’s loop through the user indexes and use our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">process_user</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1140.1">
for user_id in user_df.index:
  user_tappy_data = process_user(str(user_id), filenames)
  user_tappy_df.loc[user_id] = user_tappy_data</span></pre> <p><span class="koboSpan" id="kobo.1141.1">These next few lines do a little </span><a id="_idIndexMarker1271"/><span class="koboSpan" id="kobo.1142.1">interim cleaning by ensuring any NaN values are substituted with zeros, and any negative numeric data is also normalized </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">to zero:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1144.1">
user_tappy_df = user_tappy_df.fillna(0)
user_tappy_df[user_tappy_df &lt; 0] = 0</span></pre> <p><span class="koboSpan" id="kobo.1145.1">And then, we print like we’ve never printed before! </span><span class="koboSpan" id="kobo.1145.2">OK, that’s not true – we’ve done this </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">a lot:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1147.1">
print(user_tappy_df.head())</span></pre> <h3><span class="koboSpan" id="kobo.1148.1">Saving the processed data</span></h3>
<p><span class="koboSpan" id="kobo.1149.1">The last code cell likely</span><a id="_idIndexMarker1272"/><span class="koboSpan" id="kobo.1150.1"> doesn’t need </span><span class="No-Break"><span class="koboSpan" id="kobo.1151.1">much explanation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1152.1">
#%% Save processed data</span></pre> <p><span class="koboSpan" id="kobo.1153.1">First, we concatenate the two </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">DataFrames together:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1155.1">
combined_user_df = pd.concat([user_df, user_tappy_df], axis=1)
print(combined_user_df.head())</span></pre> <p><span class="koboSpan" id="kobo.1156.1">Finally, we save it to a </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">CSV file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1158.1">
combined_user_df.to_csv('data/combined_user.csv')</span></pre> <p><span class="koboSpan" id="kobo.1159.1">This is generally a good practice in a given data pipeline. </span><span class="koboSpan" id="kobo.1159.2">Saving the processed, cleaned version of a dataset can save data engineers a lot of effort if something goes wrong along the way. </span><span class="koboSpan" id="kobo.1159.3">It also offers flexibility, if and when we want to change or extend our </span><span class="No-Break"><span class="koboSpan" id="kobo.1160.1">pipeline further.</span></span></p>
<p><span class="koboSpan" id="kobo.1161.1">I’ll open the CSV file in</span><a id="_idIndexMarker1273"/><span class="koboSpan" id="kobo.1162.1"> PyCharm for one last look before we start doing the real analysis work. </span><span class="koboSpan" id="kobo.1162.2">You can see mine in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1163.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1164.1">.19</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer456">
<span class="koboSpan" id="kobo.1166.1"><img alt="Figure 14.19: Our hard work has paid off! Our data is ready for analysis" src="image/B19644_14_19.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1167.1">Figure 14.19: Our hard work has paid off! </span><span class="koboSpan" id="kobo.1167.2">Our data is ready for analysis</span></p>
<p><span class="koboSpan" id="kobo.1168.1">With that, we are ready to start exploring our dataset and searc</span><a id="_idTextAnchor362"/><span class="koboSpan" id="kobo.1169.1">hing </span><span class="No-Break"><span class="koboSpan" id="kobo.1170.1">for insights.</span></span></p>
<h1 id="_idParaDest-353"><a id="_idTextAnchor363"/><span class="koboSpan" id="kobo.1171.1">Data analysis and insights</span></h1>
<p><span class="koboSpan" id="kobo.1172.1">Remember what we </span><a id="_idIndexMarker1274"/><span class="koboSpan" id="kobo.1173.1">said about the importance of having a question in mind when starting to work on a data science project? </span><span class="koboSpan" id="kobo.1173.2">This is especially true during this phase, where we explore our dataset and extract insights, which should revolve around our initial question – the connection between typing speed and whether a patient has PD </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.1175.1">Throughout this section, we will be working with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">EDA.ipynb</span></strong><span class="koboSpan" id="kobo.1177.1"> file, located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">notebooks</span></strong><span class="koboSpan" id="kobo.1179.1"> folder of our current project. </span><span class="koboSpan" id="kobo.1179.2">In the following subsections, we will be looking at the code included in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">notebooks</span></strong><span class="koboSpan" id="kobo.1181.1"> folder. </span><span class="koboSpan" id="kobo.1181.2">Go ahead and open this Jupyter notebook in your PyCharm</span><a id="_idIndexMarker1275"/><span class="koboSpan" id="kobo.1182.1"> editor, or, if you are following our discussions and entering your own code, create a new </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">Jupyter notebook.</span></span></p>
<h2 id="_idParaDest-354"><a id="_idTextAnchor364"/><span class="koboSpan" id="kobo.1184.1">Starting the notebook and reading in our processed data</span></h2>
<p><span class="koboSpan" id="kobo.1185.1">Remember that when you </span><a id="_idIndexMarker1276"/><span class="koboSpan" id="kobo.1186.1">open a Jupyter notebook in Python, you can see the code, but Jupyter won’t run unless you click the </span><strong class="bold"><span class="koboSpan" id="kobo.1187.1">Run</span></strong><span class="koboSpan" id="kobo.1188.1"> button. </span><span class="koboSpan" id="kobo.1188.2">You can see PyCharm ready for this in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1189.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1190.1">.20</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer457">
<span class="koboSpan" id="kobo.1192.1"><img alt="Figure 14.20: The notebook is open, I’ve clicked in the first cell (In 1), and I’ll now click the Run button indicated by the arrow" src="image/B19644_14_20.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1193.1">Figure 14.20: The notebook is open, I’ve clicked in the first cell (In 1), and I’ll now click the Run button indicated by the arrow</span></p>
<p><span class="koboSpan" id="kobo.1194.1">Once you click the </span><strong class="bold"><span class="koboSpan" id="kobo.1195.1">Run</span></strong><span class="koboSpan" id="kobo.1196.1"> button, a Jupyter server will start and run the first cell in the notebook, which handles our imports and reads in our </span><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">cleaned dataset:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1198.1">
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
combined_user_df = pd.read_csv('../data/combined_user.csv', index_col=0)
combined_user_df.head()</span></pre> <p><span class="koboSpan" id="kobo.1199.1">Since the last line has us printing</span><a id="_idIndexMarker1277"/><span class="koboSpan" id="kobo.1200.1"> the first five lines of our output, you’ll see them appear below the code and next to a marker that says </span><strong class="bold"><span class="koboSpan" id="kobo.1201.1">Out 2</span></strong><span class="koboSpan" id="kobo.1202.1">, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1203.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1204.1">.21</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1205.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer458">
<span class="koboSpan" id="kobo.1206.1"><img alt="Figure 14.21: The output from the head statement in In 2 is shown in Out 2 and is horizontally scrollable" src="image/B19644_14_21.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1207.1">Figure 14.21: The output from the head statement in In 2 is shown in Out 2 and is horizontally scrollable</span></p>
<p><span class="koboSpan" id="kobo.1208.1">Now that our cleaned data has been loaded up, we can move on to </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">analysis techniques.</span></span></p>
<h1 id="_idParaDest-355"><a id="_idTextAnchor365"/><span class="koboSpan" id="kobo.1210.1">Using charts and graphs</span></h1>
<p><span class="koboSpan" id="kobo.1211.1">Visualization is normally the end goal for most of my work, so for me, this is a natural next step. </span><span class="koboSpan" id="kobo.1211.2">I’m going to start by </span><a id="_idIndexMarker1278"/><span class="koboSpan" id="kobo.1212.1">creating a bar graph that will show me the distribution of the counts of unique values within the data. </span><span class="koboSpan" id="kobo.1212.2">I think this might give us some insight into which factor would affect the </span><a id="_idIndexMarker1279"/><span class="koboSpan" id="kobo.1213.1">dependent variable in this study, which is whether a subject has early-onset PD. </span><span class="koboSpan" id="kobo.1213.2">However, there’s still a problem. </span><span class="koboSpan" id="kobo.1213.3">As shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1214.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1215.1">.21</span></em><span class="koboSpan" id="kobo.1216.1">, there are still some holes in the data I will need to account for before I begin analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">in earnest.</span></span></p>
<p><span class="koboSpan" id="kobo.1218.1">What I’m going to do first is create a bar chart to visualize our missing data. </span><span class="koboSpan" id="kobo.1218.2">The following code cell </span><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">handles this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1220.1">
#%%
missing_data = combined_user_df.isnull().sum()
g = sns.barplot(x=missing_data.index, y=missing_data)
g.set_xticklabels(labels=missing_data.index, rotation=90)
plt.show()</span></pre> <p><span class="koboSpan" id="kobo.1221.1">Running this code produces the visualization shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1222.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1223.1">.22</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer459">
<span class="koboSpan" id="kobo.1225.1"><img alt="Figure 14.22: The missing data is visualized in the bar chart" src="image/B19644_14_22.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1226.1">Figure 14.22: The missing data is visualized in the bar chart</span></p>
<p><span class="koboSpan" id="kobo.1227.1">Thankfully, our chart is very sparse. </span><span class="koboSpan" id="kobo.1227.2">There</span><a id="_idIndexMarker1280"/><span class="koboSpan" id="kobo.1228.1"> is only a small amount of data that is missing, or incomplete. </span><span class="koboSpan" id="kobo.1228.2">There are some missing values for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1229.1">BirthYear</span></strong><span class="koboSpan" id="kobo.1230.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">DiagnosisYear</span></strong><span class="koboSpan" id="kobo.1232.1">. </span><span class="koboSpan" id="kobo.1232.2">You can even see one in the preview shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1233.1">Figure 14</span></em></span><em class="italic"><span class="koboSpan" id="kobo.1234.1">.21</span></em><span class="koboSpan" id="kobo.1235.1">. </span><span class="koboSpan" id="kobo.1235.2">Analyzing missing values is important, and we</span><a id="_idIndexMarker1281"/><span class="koboSpan" id="kobo.1236.1"> will come back to the process of filling in these values later on. </span><span class="koboSpan" id="kobo.1236.2">But for now, let’s continue with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1237.1">visualization process.</span></span></p>
<p><span class="koboSpan" id="kobo.1238.1">A great feature in Matplotlib is subplots, which allow us to generate multiple visualizations side by side. </span><span class="koboSpan" id="kobo.1238.2">In the following code cell, we are creating multiple visualizations with this feature to highlight potential differences between patients with and </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">without Parkinson’s:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1240.1">
#%%
f, ax = plt.subplots(2, 2, figsize=(20, 10))
sns.distplot(
combined_user_df.loc[combined_user_df['Parkinsons'] == 0,
'BirthYear'].dropna(axis=0),
kde_kws = {'label': "Without Parkinson's"},
ax = ax[0][0]
)
sns.distplot(
combined_user_df.loc[combined_user_df['Parkinsons'] == 1,
'BirthYear'].dropna(axis=0),
kde_kws = {'label': "With Parkinson's"},
ax = ax[0][1]
)
sns.countplot(x='Female', hue='Parkinsons', data=combined_user_df, ax=ax[1][0])
sns.countplot(x='Tremors', hue='Parkinsons', data=combined_user_df, ax=ax[1][1])
plt.show()</span></pre> <p><span class="koboSpan" id="kobo.1241.1">After</span><a id="_idIndexMarker1282"/><span class="koboSpan" id="kobo.1242.1"> running this code cell, a visualization</span><a id="_idIndexMarker1283"/><span class="koboSpan" id="kobo.1243.1"> will be generated, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1244.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1245.1">.23</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer460">
<span class="koboSpan" id="kobo.1247.1"><img alt="Figure 14.23: Four plots drawn together from the previous cell" src="image/B19644_14_23.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1248.1">Figure 14.23: Four plots drawn together from the previous cell</span></p>
<p><span class="koboSpan" id="kobo.1249.1">The top two visualizations represent the </span><a id="_idIndexMarker1284"/><span class="koboSpan" id="kobo.1250.1">distribution in the year of birth of people with (top right) and without (top left) Parkinson’s. </span><span class="koboSpan" id="kobo.1250.2">We can see that these distributions roughly follow the normal </span><a id="_idIndexMarker1285"/><span class="koboSpan" id="kobo.1251.1">bell curve. </span><span class="koboSpan" id="kobo.1251.2">If you were to encounter a distribution that is skewed or in a strange shape, it might be worth digging into that data further. </span><span class="koboSpan" id="kobo.1251.3">Note that we can also apply the same visualization for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1252.1">DiagnosisYear</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1253.1"> column.</span></span></p>
<p><span class="koboSpan" id="kobo.1254.1">In the bottom-left visualization, we have a bar chart representing the count of male patients (two bars on the left) and female patients (two bars on the right). </span><span class="koboSpan" id="kobo.1254.2">Patients with Parkinson’s are counted with the orange bars, and patients without are counted with the blue bars. </span><span class="koboSpan" id="kobo.1254.3">In this visualization, we can see that while there are more patients with the disease than the ones without, the breakdown across the two genders is roughly </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">the same.</span></span></p>
<p><span class="koboSpan" id="kobo.1256.1">The bottom-right visualization, on the other hand, illustrates the breakdown between patients with tremors (two bars on the right) and those without tremors (two bars on the left). </span><span class="koboSpan" id="kobo.1256.2">From this visualization, we can see that tremors are significantly more common in patients with Parkinson’s, which is quite intuitive and can serve as a sanity check for our analyses </span><span class="No-Break"><span class="koboSpan" id="kobo.1257.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.1258.1">Next, we will move on to box plots. </span><span class="koboSpan" id="kobo.1258.2">Specifically, we will use box plots to visualize the distributions of different time data (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">Hold time</span></strong><span class="koboSpan" id="kobo.1260.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">Latency time</span></strong><span class="koboSpan" id="kobo.1262.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1263.1">Flight time</span></strong><span class="koboSpan" id="kobo.1264.1">) among patients with</span><a id="_idIndexMarker1286"/><span class="koboSpan" id="kobo.1265.1"> and without Parkinson’s. </span><span class="koboSpan" id="kobo.1265.2">Once again, we will use the subplots feature to </span><a id="_idIndexMarker1287"/><span class="koboSpan" id="kobo.1266.1">generate multiple visualizations at the </span><span class="No-Break"><span class="koboSpan" id="kobo.1267.1">same time:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1268.1">
#%%
column_names = [first_hand + second_hand + '_' + time
for first_hand in ['L', 'R', 'S']
for second_hand in ['L', 'R', 'S']
for time in ['Hold time', 'Latency time', 'Flight time']]
f, ax = plt.subplots(3, 3, figsize=(10, 5))
plt.subplots_adjust(
right = 3,
top = 3
)
for i in range(9):
temp_columns = column_names[3 * i : 3 * i + 3]
stacked_df = combined_user_df[temp_columns].stack().reset_index()
stacked_df = stacked_df.rename(
columns={'level_0': 'index', 'level_1': 'Type', 0: 'Time'})
stacked_df = stacked_df.set_index('index')
for index in stacked_df.index:
stacked_df.loc[index, 'Parkinsons'] = combined_user_df.loc[index,
'Parkinsons']
sns.boxplot(x='Type', y='Time',
hue='Parkinsons',
data=stacked_df,
ax=ax[i // 3][i % 3]
).set_title(column_names[i * 3][: 2], fontsize=20)
plt.show()</span></pre> <p><span class="koboSpan" id="kobo.1269.1">In this code cell, each subplot will</span><a id="_idIndexMarker1288"/><span class="koboSpan" id="kobo.1270.1"> visualize data of a specific direction type (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">LL</span></strong><span class="koboSpan" id="kobo.1272.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">LR</span></strong><span class="koboSpan" id="kobo.1274.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">LS</span></strong><span class="koboSpan" id="kobo.1276.1">, and so on) and will </span><a id="_idIndexMarker1289"/><span class="koboSpan" id="kobo.1277.1">contain different splits denoting patients with and without the disease. </span><span class="koboSpan" id="kobo.1277.2">You should obtain the visualization shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1278.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1279.1">.24</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1280.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer461">
<span class="koboSpan" id="kobo.1281.1"><img alt="Figure 14.24: The plots from the previous run cell" src="image/B19644_14_24.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1282.1">Figure 14.24: The plots from the previous run cell</span></p>
<p><span class="koboSpan" id="kobo.1283.1">What we can gather from this </span><a id="_idIndexMarker1290"/><span class="koboSpan" id="kobo.1284.1">visualization is that, surprisingly, the distribution of typing speed among patients without Parkinson’s can span across higher values and have more variance than that </span><a id="_idIndexMarker1291"/><span class="koboSpan" id="kobo.1285.1">among patients with Parkinson’s, which might contradict the intuition some might have that patients with Parkinson’s take more time to </span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">press keystrokes.</span></span></p>
<p><span class="koboSpan" id="kobo.1287.1">Overall, bar charts, distribution plots, and box plots are some of the most common visualization techniques in data science tasks, mostly because they are both simple to understand and powerful enough to highlight important patterns in our datasets. </span><span class="koboSpan" id="kobo.1287.2">In the next and final subsection on the topic of data analysis, we will consider more advanced techniques – namely, the correlation matrix between attributes and leveraging </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">ML models.</span></span></p>
<h1 id="_idParaDest-356"><a id="_idTextAnchor366"/><span class="koboSpan" id="kobo.1289.1">Machine learning-based insights</span></h1>
<p><span class="koboSpan" id="kobo.1290.1">Unlike the previous analysis methods, the methods discussed in this subsection and other similar ones are based on more complex mathematical models and ML algorithms. </span><span class="koboSpan" id="kobo.1290.2">Given the scope of this book, we will not be </span><a id="_idIndexMarker1292"/><span class="koboSpan" id="kobo.1291.1">going into the specific theoretical details for these models, but it’s still worth seeing some of them in action by applying them to </span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">our dataset.</span></span></p>
<p><span class="koboSpan" id="kobo.1293.1">First, let’s consider the feature correlation matrix for our dataset. </span><span class="koboSpan" id="kobo.1293.2">As the name suggests, this model is a matrix (a 2D table) that contains the correlation between each pair of numerical attributes (or features) within our dataset. </span><span class="koboSpan" id="kobo.1293.3">A correlation between two features is a real number between -1 and 1, indicating the magnitude and direction of the correlation. </span><span class="koboSpan" id="kobo.1293.4">The higher the value, the more correlated the two </span><span class="No-Break"><span class="koboSpan" id="kobo.1294.1">features are.</span></span></p>
<p><span class="koboSpan" id="kobo.1295.1">To obtain the feature correlation matrix from a pandas DataFrame, we must call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">corr()</span></strong><span class="koboSpan" id="kobo.1297.1"> method, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1298.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1299.1">
corr_matrix = combined_user_df.corr()</span></pre> <p><span class="koboSpan" id="kobo.1300.1">We usually visualize a correlation matrix using a heat map, as implemented in the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1301.1">code cell:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1302.1">
f, ax = plt.subplots(1, 1, figsize=(15, 10))
sns.heatmap(corr_matrix)
plt.show()</span></pre> <p><span class="koboSpan" id="kobo.1303.1">This code will produce the visualization shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1304.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1305.1">.25</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer462">
<span class="koboSpan" id="kobo.1307.1"><img alt="Figure 14.25: A heatmap is ideal for visualizing correlation matrices" src="image/B19644_14_25.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1308.1">Figure 14.25: A heatmap is ideal for visualizing correlation matrices</span></p>
<p><span class="koboSpan" id="kobo.1309.1">Next, we will try applying an ML model to our dataset. </span><span class="koboSpan" id="kobo.1309.2">Contrary to popular belief, in many data science projects, we don’t take advantage of ML models for predictive tasks, where we train our models to be able to </span><a id="_idIndexMarker1293"/><span class="koboSpan" id="kobo.1310.1">predict future data. </span><span class="koboSpan" id="kobo.1310.2">Instead, we feed our dataset to a specific model so that we can extract more insights from that </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">current dataset.</span></span></p>
<p><span class="koboSpan" id="kobo.1312.1">Here, we are using the linear </span><strong class="bold"><span class="koboSpan" id="kobo.1313.1">support vector classifier</span></strong><span class="koboSpan" id="kobo.1314.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1315.1">SVC</span></strong><span class="koboSpan" id="kobo.1316.1">) model from scikit-learn to analyze the </span><a id="_idIndexMarker1294"/><span class="koboSpan" id="kobo.1317.1">data we have and return the feature </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">importance list:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1319.1">
#%%
from sklearn.svm import LinearSVC
combined_user_df['BirthYear'].fillna(combined_user_df['BirthYear'].mode(dropna=True)[0], inplace=True)
combined_user_df['DiagnosisYear'].fillna(combined_user_df['DiagnosisYear'].mode(dropna=True)[0], inplace=True)
X_train = combined_user_df.drop(['Parkinsons'], axis=1)
y_train = combined_user_df['Parkinsons']
clf = LinearSVC()
clf.fit(X_train, y_train)
nfeatures = 10
coef = clf.coef_.ravel()
top_positive_coefs = np.argsort(coef)[-nfeatures :]
top_negative_coefs = np.argsort(coef)[: nfeatures]
top_coefs = np.hstack([top_negative_coefs, top_positive_coefs])</span></pre> <p><span class="koboSpan" id="kobo.1320.1">Note that before we feed the data we </span><a id="_idIndexMarker1295"/><span class="koboSpan" id="kobo.1321.1">have to the ML model, we need to fill in the missing values we have in the two columns we identified earlier – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">BirthYear</span></strong><span class="koboSpan" id="kobo.1323.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">DiagnosisYear</span></strong><span class="koboSpan" id="kobo.1325.1">. </span><span class="koboSpan" id="kobo.1325.2">Most ML models cannot handle missing values very well, and it is up to the data engineers to choose how these values should </span><span class="No-Break"><span class="koboSpan" id="kobo.1326.1">be filled.</span></span></p>
<p><span class="koboSpan" id="kobo.1327.1">Here, we are using the </span><strong class="bold"><span class="koboSpan" id="kobo.1328.1">mode</span></strong><span class="koboSpan" id="kobo.1329.1">, or the most commonly occurring data point, of these two columns to fill in the missing values. </span><span class="koboSpan" id="kobo.1329.2">This is because the mode is one of the statistics that tends to represent the range of different kinds of data well, especially for discrete or nominal attributes, which is what we have here. </span><span class="koboSpan" id="kobo.1329.3">If you are working with numerical and continuous data such as length or area, it is also common practice to use the mean of a given attribute. </span><span class="koboSpan" id="kobo.1329.4">Finally, getting back to our current process, this code trains the model on our dataset and obtains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1330.1">coef_</span></strong><span class="koboSpan" id="kobo.1331.1"> attribute of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1332.1">model afterward.</span></span></p>
<p><span class="koboSpan" id="kobo.1333.1">This attribute contains the feature importance list, which is visualized by the last section of </span><span class="No-Break"><span class="koboSpan" id="kobo.1334.1">the code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1335.1">
plt.figure(figsize=(15, 5))
colors = ['red' if c &lt; 0 else 'blue' for c in coef[top_coefs]]
plt.bar(np.arange(2 * nfeatures), coef[top_coefs], color=colors)
feature_names = np.array(X_train.columns)
# Make sure the number of tick locations matches the number of tick labels.
</span><span class="koboSpan" id="kobo.1335.2">plt.xticks(np.arange(0, 2 * nfeatures), feature_names[top_coefs], rotation=60, ha='right')
plt.show()</span></pre> <p><span class="koboSpan" id="kobo.1336.1">Running this code produces the</span><a id="_idIndexMarker1296"/><span class="koboSpan" id="kobo.1337.1"> visualization shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1338.1">Figure 14</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1339.1">.26</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1340.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer463">
<span class="koboSpan" id="kobo.1341.1"><img alt="Figure 14.26: A graph of the feature important list identifies features used extensively while training an ML model" src="image/B19644_14_26.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1342.1">Figure 14.26: A graph of the feature important list identifies features used extensively while training an ML model</span></p>
<p><span class="koboSpan" id="kobo.1343.1">From the feature importance list, we can identify any features that were used extensively by the ML model while training. </span><span class="koboSpan" id="kobo.1343.2">A</span><a id="_idIndexMarker1297"/><span class="koboSpan" id="kobo.1344.1"> feature with a very high importance value could be correlated with the target attribute (whether someone has Parkinson’s or not) in some interesting way. </span><span class="koboSpan" id="kobo.1344.2">For example, we can see that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1345.1">Tremors</span></strong><span class="koboSpan" id="kobo.1346.1"> (which we know is quite correlated to our target attribute) is the third most important feature of our current </span><span class="No-Break"><span class="koboSpan" id="kobo.1347.1">ML model.</span></span></p>
<p><span class="koboSpan" id="kobo.1348.1">That’s our last discussion point regarding analyzing our dataset. </span><span class="koboSpan" id="kobo.1348.2">In the last section of this chapter, we will have a brief discussion on deciding how to write a script</span><a id="_idTextAnchor367"/><span class="koboSpan" id="kobo.1349.1"> for a Python data </span><span class="No-Break"><span class="koboSpan" id="kobo.1350.1">science project.</span></span></p>
<h1 id="_idParaDest-357"><a id="_idTextAnchor368"/><span class="koboSpan" id="kobo.1351.1">Scripts versus notebooks in data science</span></h1>
<p><span class="koboSpan" id="kobo.1352.1">In the preceding data science pipeline, there are two main sections: data cleaning, where we remove inconsistent </span><a id="_idIndexMarker1298"/><span class="koboSpan" id="kobo.1353.1">data, fill in missing data, and appropriately </span><a id="_idIndexMarker1299"/><span class="koboSpan" id="kobo.1354.1">encode the attributes, and data analysis, where we </span><a id="_idIndexMarker1300"/><span class="koboSpan" id="kobo.1355.1">generate visualizations and insights from our </span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1">cleaned dataset.</span></span></p>
<p><span class="koboSpan" id="kobo.1357.1">The data cleaning process was implemented by a Python script while the data analysis process was done with a Jupyter notebook. </span><span class="koboSpan" id="kobo.1357.2">In general, deciding whether a Python program should be done in a script or a notebook is quite an important, yet often overlooked, aspect while working on a data </span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">science project.</span></span></p>
<p><span class="koboSpan" id="kobo.1359.1">As we discussed in the</span><a id="_idIndexMarker1301"/><span class="koboSpan" id="kobo.1360.1"> previous chapter, Jupyter notebooks are perfect for iterative </span><a id="_idIndexMarker1302"/><span class="koboSpan" id="kobo.1361.1">development processes, where we can transform and manipulate our data as we go. </span><span class="koboSpan" id="kobo.1361.2">A Python script, on the other hand, offers no such dynamism. </span><span class="koboSpan" id="kobo.1361.3">We need to enter all of the code necessary in the script and run it as a </span><span class="No-Break"><span class="koboSpan" id="kobo.1362.1">complete program.</span></span></p>
<p><span class="koboSpan" id="kobo.1363.1">However, as illustrated in the </span><em class="italic"><span class="koboSpan" id="kobo.1364.1">Data cleansing and preprocessing</span></em><span class="koboSpan" id="kobo.1365.1"> section, PyCharm allows us to divide a traditional Python script into separate code cells and inspect the data we have as we go using the </span><strong class="bold"><span class="koboSpan" id="kobo.1366.1">SciView</span></strong><span class="koboSpan" id="kobo.1367.1"> panel. </span><span class="koboSpan" id="kobo.1367.2">The dynamism offered by Jupyter notebooks can also be found </span><span class="No-Break"><span class="koboSpan" id="kobo.1368.1">within PyCharm.</span></span></p>
<p><span class="koboSpan" id="kobo.1369.1">Now, another core difference between regular Python scripts and Jupyter notebooks is the fact that printed output and visualizations are included inside a notebook, together with the code cells that generated them. </span><span class="koboSpan" id="kobo.1369.2">While looking at this from the perspective of data scientists, we can see that this feature is considerably useful when making reports </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">and presentations.</span></span></p>
<p><span class="koboSpan" id="kobo.1371.1">Say you are tasked with finding actionable insights from a dataset in a company project, and you need to present your final findings, as well as how you came across them with your team. </span><span class="koboSpan" id="kobo.1371.2">A Jupyter notebook can effectively serve as the main platform for your presentation. </span><span class="koboSpan" id="kobo.1371.3">Not only will people be able to see which specific commands were used to process and manipulate the original data but you will also be able to include Markdown texts to further explain any subtle </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">discussion points.</span></span></p>
<p><span class="koboSpan" id="kobo.1373.1">Regular Python scripts can simply be used for low-level tasks where the general workflow has already been agreed upon, and you will not need to present it to anyone else. </span><span class="koboSpan" id="kobo.1373.2">In our current example, I chose to clean the dataset using a Python script as most of the cleaning and formatting changes we applied to the dataset don’t generate any actionable insights that can address our initial question. </span><span class="koboSpan" id="kobo.1373.3">I only used a notebook for data analysis tasks, where there were</span><a id="_idIndexMarker1303"/><span class="koboSpan" id="kobo.1374.1"> many visualizations and insights worthy of </span><span class="No-Break"><span class="koboSpan" id="kobo.1375.1">further discussion.</span></span></p>
<p><span class="koboSpan" id="kobo.1376.1">Overall, the decision to use either a traditional Python script or a Jupyter notebook solely depends on your tasks and purposes. </span><span class="koboSpan" id="kobo.1376.2">We simply need to remember that, for whichever tool we would like to use, PyCharm offers incredible</span><a id="_idTextAnchor369"/> <a id="_idTextAnchor370"/><span class="koboSpan" id="kobo.1377.1">support that can streamline </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">our workflow.</span></span></p>
<h1 id="_idParaDest-358"><a id="_idTextAnchor371"/><span class="koboSpan" id="kobo.1379.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1380.1">In this chapter, we walked through the hands-on process of working on a data science pipeline. </span><span class="koboSpan" id="kobo.1380.2">First, we discussed the importance of having version control for not just our code and project-related files but also our datasets; we then learned how to use Git LFS to apply version control to large files </span><span class="No-Break"><span class="koboSpan" id="kobo.1381.1">and datasets.</span></span></p>
<p><span class="koboSpan" id="kobo.1382.1">Next, we looked at various data cleaning and preprocessing techniques that are specific to the example dataset. </span><span class="koboSpan" id="kobo.1382.2">Using the </span><strong class="bold"><span class="koboSpan" id="kobo.1383.1">SciView</span></strong><span class="koboSpan" id="kobo.1384.1"> panel in PyCharm, we can dynamically inspect the current state of our data and variables and see how they change after </span><span class="No-Break"><span class="koboSpan" id="kobo.1385.1">each command.</span></span></p>
<p><span class="koboSpan" id="kobo.1386.1">Finally, we considered several techniques to generate visualizations and extract insights from our dataset. </span><span class="koboSpan" id="kobo.1386.2">Using the Jupyter editor in PyCharm, we were able to avoid working with a Jupyter server and work on our notebook entirely within PyCharm. </span><span class="koboSpan" id="kobo.1386.3">Having walked through this process, you are now ready to tackle real-life data science problems and projects using the same tools and functionalities that we have discussed </span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1">so far.</span></span></p>
<p><span class="koboSpan" id="kobo.1388.1">So, we have finished our discussion on using PyCharm in the context of scientific computing and data science. </span><span class="koboSpan" id="kobo.1388.2">In the next chapter, we will finally consider a topic that we have mentioned multiple times throug</span><a id="_idTextAnchor372"/><span class="koboSpan" id="kobo.1389.1">h</span><a id="_idTextAnchor373"/><span class="koboSpan" id="kobo.1390.1"> our previous chapters – </span><span class="No-Break"><span class="koboSpan" id="kobo.1391.1">PyCharm plugins.</span></span></p>
<h1 id="_idParaDest-359"><a id="_idTextAnchor374"/><span class="koboSpan" id="kobo.1392.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.1393.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.1394.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1395.1">What are some of the main ways of collecting datasets for a data </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">science project?</span></span></li>
<li><span class="koboSpan" id="kobo.1397.1">Can Git LFS be used with Git? </span><span class="koboSpan" id="kobo.1397.2">If so, what is the </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">overall process?</span></span></li>
<li><span class="koboSpan" id="kobo.1399.1">Which type of attribute can have its missing values filled out with the mean? </span><span class="koboSpan" id="kobo.1399.2">What about </span><span class="No-Break"><span class="koboSpan" id="kobo.1400.1">the mode?</span></span></li>
<li><span class="koboSpan" id="kobo.1401.1">What problem does one-hot encoding address? </span><span class="koboSpan" id="kobo.1401.2">What problem can arise from using </span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1">one-hot encoding?</span></span></li>
<li><span class="koboSpan" id="kobo.1403.1">Which type of attribute can benefit from bar charts? </span><span class="koboSpan" id="kobo.1403.2">What about </span><span class="No-Break"><span class="koboSpan" id="kobo.1404.1">distribution plots?</span></span></li>
<li><span class="koboSpan" id="kobo.1405.1">Why is it important to consider the feature correlation matrix for </span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">a dataset?</span></span></li>
<li><span class="koboSpan" id="kobo.1407.1">Aside from predictive tasks, what can we use ML</span><a id="_idTextAnchor375"/> <a id="_idTextAnchor376"/><span class="koboSpan" id="kobo.1408.1">models for (like we did in </span><span class="No-Break"><span class="koboSpan" id="kobo.1409.1">this chapter)?</span></span></li>
</ol>
<h1 id="_idParaDest-360"><a id="_idTextAnchor377"/><span class="koboSpan" id="kobo.1410.1">Further reading</span></h1>
<p><span class="koboSpan" id="kobo.1411.1">Be sure to check out the companion website for this book </span><span class="No-Break"><span class="koboSpan" id="kobo.1412.1">at </span></span><a href="https://www.pycharm-book.com"><span class="No-Break"><span class="koboSpan" id="kobo.1413.1">https://www.pycharm-book.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1414.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1415.1">More information can be found in the following articles and </span><span class="No-Break"><span class="koboSpan" id="kobo.1416.1">reading materials:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1417.1">Adams, W. </span><span class="koboSpan" id="kobo.1417.2">R. </span><span class="koboSpan" id="kobo.1417.3">(2017). </span><em class="italic"><span class="koboSpan" id="kobo.1418.1">High-accuracy detection of early Parkinson’s Disease using multiple characteristics of finger movement while typing</span></em><span class="koboSpan" id="kobo.1419.1">. </span><span class="koboSpan" id="kobo.1419.2">PloS one, </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1420.1">12</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1421.1">(11), e0188226.</span></span></li>
<li><span class="koboSpan" id="kobo.1422.1">The </span><em class="italic"><span class="koboSpan" id="kobo.1423.1">Tappy Keystroke Data with Parkinson’s Patients</span></em><span class="koboSpan" id="kobo.1424.1"> data, uploaded by Patrick </span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1">DeKelly: </span></span><a href="https://www.kaggle.com/valkling/tappy-keystroke-data-with-parkinsons-patients"><span class="No-Break"><span class="koboSpan" id="kobo.1426.1">https://www.kaggle.com/valkling/tappy-keystroke-data-with-parkinsons-patients</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1428.1">Building a Data Pipeline from Scratch</span></em><span class="koboSpan" id="kobo.1429.1">, by Alan </span><span class="No-Break"><span class="koboSpan" id="kobo.1430.1">Marazzi: </span></span><a href="https://medium.com/the-data-experience/building-a-data-pipeline-from-scratch-32b712cfb1db"><span class="No-Break"><span class="koboSpan" id="kobo.1431.1">https://medium.com/the-data-experience/building-a-data-pipeline-from-scratch-32b712cfb1db</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1432.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1433.1">A Business Perspective to Designing an Enterprise-Level Data Science Pipeline</span></em><span class="koboSpan" id="kobo.1434.1">, by Vikram </span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">Reddy: </span></span><a href="https://www.datascience.com/blog/designing-an-enterprise-level-data-science-pipeline"><span class="No-Break"><span class="koboSpan" id="kobo.1436.1">https://www.datascience.com/blog/designing-an-enterprise-level-data-science-pipeline</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1437.1">.</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.1438.1">Data Science for Startups: Data Pipelines</span></em><span class="koboSpan" id="kobo.1439.1">, by Ben </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">Weber: </span></span><a href="https://towardsdatascience.com/data-science-for-startups-data-pipelines-786f6746a59a"><span class="No-Break"><span class="koboSpan" id="kobo.1441.1">https://towardsdatascience.com/data-science-for-startups-data-pipelines-786f6746a59a</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1443.1">Documentation for the pandas </span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1">library: </span></span><a href="https://pandas.pydata.org/pandas-docs/stable/"><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">https://pandas.pydata.org/pandas-docs/stable/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">.</span></span></li>
</ul>
</div>


<div class="Content" id="_idContainer465">
<h1 id="_idParaDest-361" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor378"/><span class="koboSpan" id="kobo.1.1">Part 5: Plugins and Conclusion</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part will introduce readers to the concept of PyCharm plugins and walk through the process of downloading plugins and adding them to their PyCharm environment. </span><span class="koboSpan" id="kobo.2.2">It will also go into details regarding the most popular plugins and how they can optimize a programmer’s productivity even further. </span><span class="koboSpan" id="kobo.2.3">We’ll also gloss over important topics discussed in previous chapters of the book and offers a comprehensive view on PyCharm’s most </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">popular features.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B19644_15.xhtml#_idTextAnchor379"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 15</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">More Possibilities with PyCharm Plugins</span></em></li>
<li><a href="B19644_16.xhtml#_idTextAnchor401"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 16</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Future Developments</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer466">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer467">
</div>
</div>
</body></html>