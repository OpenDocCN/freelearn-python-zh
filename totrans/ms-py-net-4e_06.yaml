- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Security with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In my opinion, network security is a tricky topic to write about. The reason
    is not a technical one but rather has to do with setting up the correct scope.
    The boundaries of network security are so wide that they touch all seven layers
    of the OSI model. From layer 1 of wiretapping to layer 4 of the transport protocol
    vulnerability, to layer 7 of man-in-the-middle spoofing, network security is everywhere.
    The issue is exacerbated by all the newly discovered vulnerabilities, which sometimes
    seem to be a daily occurrence. This does not even include the human social engineering
    aspect of network security.
  prefs: []
  type: TYPE_NORMAL
- en: As such, in this chapter, I would like to set the scope for what we will discuss.
    As we have been doing up to this point, we will primarily focus on using Python
    for network device security at OSI layers 3 and 4\. We will look at Python tools
    that we can use to manage individual network devices for security purposes, as
    well as using Python as a glue to connect different components. Hopefully, we
    can treat network security holistically using Python in different OSI layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The lab setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Scapy for security testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forensic analysis with Syslog and **Uncomplicated Firewall** (**UFW**) using
    Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools, such as a MAC address filter list, private VLAN, and Python IP
    table binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin by looking at our lab setup for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Lab Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The devices being used in this chapter are a bit different from the previous
    chapters. In the previous chapters, we isolated a particular set of devices. For
    this chapter, we will use a few more Linux hosts in our lab to illustrate the
    function of the tools we will use. The connectivity and operating system information
    are important as they have ramifications regarding the security tools we will
    show later in this chapter. For example, if we want to apply an access list to
    protect the server, we need to know what the topology looks like and in which
    direction the client is making their connections. The Ubuntu host connections
    are a bit different than what we have seen so far, so please refer to this lab
    section when you see the example later if needed.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same Cisco CML tool with the NYC nodes with two additional Ubuntu
    hosts. The lab topology is provided with the course files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to add a Linux host in CML is the same as adding network nodes, simply
    click on **add nodes** and pick Ubuntu as the selection. We will name the outside
    host connecting to `nyc-cor-r1` as the client, and the host behind `nyc-cor-edg-r1`
    as the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Adding Ubuntu Hosts'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good point to review and learn about Ubuntu Linux networking. We
    will spend some time listing out the Ubuntu Linux networking options of the setup.
    Here is an overview of the lab topology:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18403_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Lab Topology'
  prefs: []
  type: TYPE_NORMAL
- en: The IP addresses listed will probably be different in your lab. They are listed
    here to easily reference in the remainder of the chapter code examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add two dual-home links to the hosts, one for the default gateway going
    to the unmanaged switch for management and internet. The other link is used to
    route the internet traffic. As illustrated, we will rename the host on the top
    as the client, and the bottom host as the server using the `hostname <name>` command.
    This is analogous to an internet client trying to access a corporate server within
    our network. The version of Ubuntu Linux in the CML software is 18.04 LTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To list and turn up the links, we can use the `ip link` and `ifconfig` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the hosts, when we first turn it up, it will have an initial network configuration
    under `/etc/netplan/50-cloud-init.yaml`. We will back it up and create our own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the two network links, we will use the following configuration to configure
    the default gateway for `ens3` (management and internet) as well as the internal
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow the network change to take effect, we can use the `netplan apply`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a quick output for the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will put the connected network into the existing OSPF network. Here is the
    configuration of `nyc-cor-r1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration of `nyc-cor-edg-r1` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here comes the part that might be a bit tricky for engineers who might be new
    to host-based networking. By default, the host has a routing preference as well.
    The default gateway we added for `ens3` will allow us to use the lab gateway for
    the “destination of last resort.” We can see the routing table on the host via
    the `route` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following command to route traffic from the client to the server
    via the `route` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will do the same on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the client-to-server path, let’s ping and trace the route to make
    sure that traffic between our hosts is going through the network devices instead
    of the default route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The final task is to prepare the host for the remainder of the chapter with
    updated repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Great! We have our lab; we are now ready to look at some security tools and
    measures using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python Scapy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scapy ([https://scapy.net](https://scapy.net)) is a powerful Python-based interactive
    packet crafting program. Outside of some expensive commercial programs, very few
    tools can do what Scapy can do, to my knowledge. It is one of my favorite tools
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main advantage of Scapy is that it allows us to craft our packet from a
    very basic level. In the words of Scapy’s creator:'
  prefs: []
  type: TYPE_NORMAL
- en: ”Scapy is a powerful interactive packet manipulation program. It is able to
    forge or decode packets of a wide number of protocols, send them on the wire,
    capture them, match requests and replies, and much more…… with most other tools,
    you won’t build something the author did not imagine. These tools have been built
    for a specific goal and can’t deviate much from it.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s now take a look at the tool.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Scapy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scapy has had an interesting path when it comes to Python 3 support. Back in
    2015, there was an independent fork of Scapy from version 2.2.0 that aimed to
    support Python 3, named `Scapy3k`. In this book, we are using the main code base
    from the original Scapy project. If you have read the previous edition of the
    book and used a Scapy version that was only compatible with Python 2, please take
    a look at the Python 3 support per Scapy release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated with medium confidence](img/B18403_06_03.1.png)![A
    picture containing chart  Description automatically generated](img/B18403_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Python version support (source: https://scapy.net/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install the official release from the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Following installation, we can launch the Scapy interactive shell by typing
    in **scapy** in the Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a quick test to make sure we can access the `Scapy` library from Python
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Scapy is now installed and can be executed from our Python interpreter.
    Let’s take a look at its usage via the interactive shell in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our first example, we will craft an **Internet Control Message Protocol**
    (**ICMP**) packet on the client and send it to the server. On the server side,
    we will use `tcpdump` with a host filter to see the packet coming in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very simple to craft a packet from Scapy. Scapy allows
    you to build the packet layer by layer using the slash (`/`) as the separator.
    The `send` function operates at the layer 3 level, which takes care of routing
    and layer 2 for you. There is also a `sendp()` alternative that operates at layer
    2, which means you will need to specify the interface and link layer protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at capturing the returned packet by using the `send-request` (`sr`)
    function. We are using a special variation of `sr`, called `sr1`, which only returns
    one packet that answers from the packet sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note is that the `sr()` function returns a tuple containing answered
    and unanswered lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s take a look at what is contained inside the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to only take a look at the answered packet list, we could see that
    it is a `NamedTuple` containing the packet that we have sent as well as the returned
    packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Scapy also provides a layer 7 construct, such as a DNS query. In the following
    example, we are querying an open DNS server for the resolution of [www.google.com](http://www.google.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at some other Scapy features. We’ll begin by using Scapy for
    packet captures.
  prefs: []
  type: TYPE_NORMAL
- en: Packet captures with Scapy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As network engineers, we constantly have to capture packets on the wire during
    troubleshooting. We typically use Wireshark or similar tools, but Scapy can also
    be used to easily capture packets on the wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can look at the packets in some more detail, including the raw format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have seen the basic workings of Scapy. Let’s now move on and see how we can
    use Scapy for certain aspects of common security testing.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP port scan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step for any potential hackers is almost always trying to learn which
    service is open on the network to focus their efforts on the attack. Of course,
    we need to open certain ports to service our customers; that is part of the risk
    we must accept. However, we should close any other open port that needlessly exposes
    a larger attack surface. We can use Scapy to do a simple TCP open port scan to
    scan our own host.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can send a `SYN` packet and see whether the server will return with `SYN-ACK`
    for various ports. Let’s start with Telnet, TCP port `23`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, in the output here, the server is responding with a `RESET+ACK`
    for TCP port `23`. However, TCP port `22` (SSH) is open; therefore, a `SYN-ACK`
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also scan a range of destination ports from `20` to `22`; note that
    we are using `sr()` for send-receive instead of the `sr1()` send-receive-one-packet
    variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify a destination network instead of a single host. As you
    can see from the `10.0.0.8/29` block, hosts `10.0.0.9`, `10.0.0.10`, and `10.0.0.14`
    returned with `SA`, which corresponds to the two network devices and the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on what we have learned so far, we can make a simple script for reusability,
    `scapy_tcp_scan_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the script, we start with the suggested importing of `scapy` and the `sys`
    module for taking in arguments. The `tcp_scan()` function is similar to what we
    have seen up to this point, the only difference being that we functionalized it
    so that we can acquire inputs from arguments and then call the `tcp_scan()` function
    in the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that access to the low-level network requires root access; therefore,
    our script needs to be executed as `sudo`. Let’s try the script on port `22` (SSH)
    and port `80` (HTTP):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This was a relatively lengthy example of the TCP scan script, which demonstrated
    the power of crafting your packet with Scapy. We tested the steps in the interactive
    shell and finalized the usage with a simple script. Now, let’s look at some more
    examples of Scapy’s usage for security testing.
  prefs: []
  type: TYPE_NORMAL
- en: The ping collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say our network contains a mix of Windows, Unix, and Linux machines,
    with network users adding their machines from the **Bring Your Own Device** (**BYOD**)
    policy; they may or may not support an ICMP ping. We can now construct a file
    with three types of common pings for our network – the ICMP, TCP, and UDP pings
    – in `scapy_ping_collection.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then execute all three types of pings on the network in one script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: At this point, hopefully, you will agree with me that by having the ability
    to construct your custom packet, you can be in charge of the type of operations
    and tests that you would like to run. Along the same thought of constructing our
    custom packets using Scapy, we can construct our packets to perform security tests
    on our network.
  prefs: []
  type: TYPE_NORMAL
- en: Common attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, let’s look at how we can construct our packet to conduct some
    classic attacks, such as *Ping of Death* ([https://en.wikipedia.org/wiki/Ping_of_death](https://en.wikipedia.org/wiki/Ping_of_death))
    and *Land Attack* ([https://en.wikipedia.org/wiki/Denial-of-service_attack](https://en.wikipedia.org/wiki/Denial-of-service_attack)).
    These are network penetration tests that you previously had to pay for with similar
    commercial software. With Scapy, you can conduct the test while maintaining full
    control and adding more tests in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first attack sends the destination host with a bogus IP header, such as
    an IP header length of two and an IP version of three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ping_of_death_attack` consists of the regular ICMP packet with a payload
    bigger than 65,535 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `land_attack` wants to redirect the client response back to the client
    and exhausts the host’s resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: These are pretty old vulnerabilities or classic attacks that a modern operating
    system is no longer susceptible to. For our Ubuntu 20.04 host, none of the preceding
    attacks will bring it down. However, as more security issues are being discovered,
    Scapy is a great tool for initiating tests against our network and host without
    waiting for the impacted vendor to give you a validation tool. This is especially
    true for the zero-day (published without prior notification) attacks that seem
    more and more common on the internet. Scapy is a tool that can do a lot more than
    what we can cover in this chapter, but luckily, there are lots of open source
    resources on Scapy that we can reference.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have spent much effort working with Scapy in this chapter. This is partially
    due to the high regard in which I hold the tool. I hope you agree that Scapy is
    a great tool to keep in our toolset as network engineers. The best part about
    Scapy is that it is constantly being developed with an engaged community of users.
  prefs: []
  type: TYPE_NORMAL
- en: I would highly recommend at least going through the Scapy tutorial at [http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial](http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial),
    as well as any of the documentation that is of interest to you.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, network security is more than just crafting packets and testing vulnerabilities.
    In the next section, we’ll take a look at automating the access list that is commonly
    used to protect sensitive internal resources.
  prefs: []
  type: TYPE_NORMAL
- en: Access lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network access lists are usually the first line of defense against outside
    intrusions and attacks. Generally speaking, routers and switches process packets
    at a much faster rate than servers by utilizing high-speed memory hardware such
    as **ternary content-addressable memory** (**TCAM**). They do not need to see
    the application layer information. Instead, they just examine the layer 3 and
    layer 4 headers and decide whether the packets can be forwarded. Therefore, we
    generally utilize network device access lists as a first step in safeguarding
    our network resources.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, we want to place access lists as close to the source (client)
    as possible. Inherently, we also trust the inside host and distrust clients beyond
    our network boundary. The access list is, therefore, usually placed in the inbound
    direction on the external-facing network interface(s). In our lab scenario, this
    means we will place an inbound access list at Ethernet2/2 on `nyc-cor-r1`, which
    is directly connected to the client host.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unsure of the direction and placement of the access list, a few
    points might help here:'
  prefs: []
  type: TYPE_NORMAL
- en: Think of the access list from the perspective of the network device.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify the packets in terms of just source and destination IPs and use one
    host as an example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our lab, traffic from our server to the client will have a source IP of `10.0.0.9`,
    with a destination IP of `10.0.0.5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The traffic from the client to the server will have a source IP of `10.0.0.5`,
    and a destination IP of `10.0.0.9`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Obviously, every network is different, and how the access list should be constructed
    depends on the services provided by your server. But, as an inbound border access
    list, you should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Deny RFC 3030 special-use address sources, such as `127.0.0.0/8`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny RFC 1918 space, such as `10.0.0.0/8`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny our own space as the source IP; in this case, `10.0.0.4/30`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permit inbound TCP ports `22` (SSH) and `80` (HTTP) to host `10.0.0.9`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny everything else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a good list of bogon networks to block: [https://ipinfo.io/bogon](https://ipinfo.io/bogon).'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what to add is only half of the step. In the next section, let’s take
    a look at how to implement the intended access list with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing access lists with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to implement this access list would be to use Ansible. We have
    already looked at Ansible in previous chapters, but it is worth repeating the
    advantages of using Ansible in this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier management**: For a long access list, we can utilize the `include`
    statement to break the access list into more manageable pieces. The smaller pieces
    can then be managed by other teams or service owners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Idempotency**: We can schedule the playbook at regular intervals and only
    the necessary changes will be made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Each task is explicit**: We can separate the construct of the entries as
    well as apply the access list to the proper interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: In the future, if we add additional external-facing interfaces,
    we just need to add the device to the list of devices for the access list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensible**: You will notice that we can use the same playbook for constructing
    the access list and apply it to the right interface. We can start small and expand
    to separate playbooks in the future as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `host` file is pretty standard. We will also follow our standards of putting
    the variables in the `host_vars` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will declare the variables in the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To save space, we will only illustrate denying the RFC 1918 space. Implementing
    the denial of RFC 3030 and our own space will be identical to the steps used for
    the RFC 1918 space. Note that we did not deny `10.0.0.0/8` in our playbook because
    our configuration currently uses the `10.0.0.0` network for addressing. Of course,
    we could perform the single host permit first and deny `10.0.0.0/8` in a later
    entry, but in this example, we just chose to omit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are allowing the established connection sourcing from the server
    inside to be allowed back in. We use the final explicit `deny` `ip` `any` statement
    as a high-sequence number (`1000`) so that we can insert any new entries later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then apply the access list to the correct interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This may seem like a lot of work for a single access list. For an experienced
    engineer, using Ansible to do this task will take longer than just logging in
    to the device and configuring the access list. However, remember that this playbook
    can be reused many times in the future, so it will save you time in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: It is my experience that often, for a long access list, a few entries will be
    for one service, a few entries will be for another, and so on. The access lists
    tend to grow organically over time, and it becomes very hard to keep track of
    the origin and purpose of each entry. The fact that we can break them apart makes
    the management of a long access list much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s execute the playbook and `verify` on `nx-osv-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We should log in to `nyc-cor-r1` to verify the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We have seen the implementation of IP access lists that check layer 3 information
    on the network. In the next section, let’s look at how to restrict device access
    in a layer 2 environment.
  prefs: []
  type: TYPE_NORMAL
- en: MAC access lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case where you have a layer 2 environment, or where you are using non-IP
    protocols on Ethernet interfaces, you can still use a MAC address access list
    to allow or deny hosts based on MAC addresses. The steps are similar to the IP
    access list, but the match will be based on MAC addresses. Recall that for MAC
    addresses, or physical addresses, the first six hexadecimal symbols belong to
    an **organizationally unique identifier** (**OUI**). So, we can use the same access
    list matching pattern to deny a certain group of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: We are testing this on IOSv with the `ios_config` module. For older Ansible
    versions, the change will be pushed out every single time the playbook is executed.
    For newer Ansible versions, the control node will check for changes first and
    only make changes when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `host` file and the top portion of the playbook are similar to the IP access
    list; the `tasks` portion is where the different modules and arguments are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute the playbook and verify its application on `iosv-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have done before, let’s log in to the device to verify our change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As more virtual networks become popular, layer 3 information sometimes becomes
    transparent to the underlying virtual links. In these scenarios, the MAC access
    list becomes a good option if you need to restrict access to those links. In this
    section, we have used Ansible to automate the implementation of both layer 2 and
    layer 3 access lists. Now, let’s change gears a bit but stay within the security
    context and look at how to pick up necessary security information from `syslogs`
    using Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Syslog search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are plenty of documented network security breaches that took place over
    an extended period. In these slow breaches, we quite often saw signs and traces
    in logs indicating that there were suspicious activities. These can be found in
    both server and network device logs. The activities were not detected, not because
    there was a lack of information, but rather because there was **too much** information.
    The critical information we were looking for is usually buried deep in a mountain
    of information that is hard to sort out.
  prefs: []
  type: TYPE_NORMAL
- en: Besides Syslog, UFW is another great source of log information for servers.
    It is a frontend to IP tables, which is a server firewall. UFW makes managing
    firewall rules very simple and logs a good amount of information. Refer to the
    *Other Tools* section for more information on UFW.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will try to use Python to search through the Syslog text
    in order to detect the activities that we were looking for. Of course, the exact
    terms that we will search for depend on the device we are using. For example,
    Cisco provides a list of messages to look for in Syslog for any access-list violation
    logging. It is available at [http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html](http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html).
  prefs: []
  type: TYPE_NORMAL
- en: For more understanding of access control list logging, go to [http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html](http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our exercise, we will use a Nexus switch anonymized Syslog file containing
    about 65,000 lines of log messages. This file is included for you in the book’s
    GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We have inserted some Syslog messages from the Cisco documentation ([http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html](https://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html))
    as the log message that we should be looking for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We will be using simple examples with regular expressions. If you are already
    familiar with the regular expression module in Python, feel free to skip the rest
    of the section.
  prefs: []
  type: TYPE_NORMAL
- en: Searching with the regular expression module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our first search, we will simply use the regular expression module to search
    for the terms we are looking for. We will use a simple loop to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It took about four-hundredths of a second to search through the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It is recommended to compile the search term for a more efficient search. It
    will not impact us much since the script is already pretty fast. Python’s interpretative
    nature might make it slower. However, it will make a difference when we search
    through a larger text body, so let’s make the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The timing result is actually slower:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s expand the example a bit. Assuming we have several files and multiple
    terms to search through, we will copy the original file to a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also include searching for the `PAM: Authentication failure` term.
    We will add another loop to search both files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now see the difference in performance by expanding our search terms
    and the number of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Of course, when it comes to performance tuning, it is a never-ending, impossible
    race to zero, and the performance sometimes depends on the hardware you are using.
    But the important point is to regularly perform audits of your log files using
    Python so that you can catch the early signals of any potential breach.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at some of the key ways in which we can enhance our network security
    in Python, but there are several other powerful tools that can make this process
    easier and more effective. In the final section of this chapter, we will explore
    some of these tools.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other network security tools that we can use and automate with Python.
    Let’s take a look at two of the most commonly used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Private VLANs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Virtual local area networks** (**VLANs**) have been around for a long time.
    They are essentially broadcast domains where all hosts can be connected to a single
    switch but are partitioned out to different domains, so we can separate the hosts
    according to which hosts can see others via broadcasts. Let’s consider a map based
    on IP subnets. For example, in an enterprise building, I would likely see one
    IP subnet per physical floor: `192.168.1.0/24` for the first floor, `192.168.2.0/24`
    for the second floor, and so on. In this pattern, we use a `/24` block for each
    floor. This gives a clear delineation of my physical network as well as my logical
    network. A host wanting to communicate beyond its subnet will need to traverse
    through its layer 3 gateway, where I can use an access list to enforce security.'
  prefs: []
  type: TYPE_NORMAL
- en: What happens when different departments reside on the same floor? Perhaps the
    finance and sales teams are on the second floor, and I would not want the sales
    team’s hosts in the same broadcast domain as the finance team. I can break the
    subnet down further, but that might become tedious and break the standard subnet
    scheme previously set up. This is where a private VLAN can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The private VLAN essentially breaks up the existing VLAN into sub-VLANs. There
    are three categories within a private VLAN:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Promiscuous (P) port**: This port is allowed to send and receive layer
    2 frames from any other port on the VLAN; this usually belongs to the port connecting
    to the layer 3 routers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Isolated (I) port**: This port is only allowed to communicate with P
    ports, and it is typically connected to hosts when you do not want it to communicate
    with other hosts in the same VLAN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Community (C) port**: This port is allowed to communicate with other
    C ports in the same community and with P ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can again use Ansible or any other Python scripts introduced so far to accomplish
    this task. By now, we should have enough practice and confidence to implement
    this feature via automation, so I will not repeat the steps here. Being aware
    of the private VLAN feature will come in handy when you need to isolate ports
    even further in a layer 2 VLAN.
  prefs: []
  type: TYPE_NORMAL
- en: UFW with Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We briefly mentioned UFW as the front end for IP tables on Ubuntu hosts. Here
    is a quick overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the advantage of UFW is that it provides a simple interface
    to construct otherwise complicated IP table rules. There are several Python-related
    tools we can use with UFW to make things even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Ansible UFW module to streamline our operations. More information
    is available at [https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html](https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are Python wrapper modules around UFW as an API (visit [https://gitlab.com/dhj/easyufw](https://gitlab.com/dhj/easyufw)).
    This can make integration easier if you need to dynamically modify UFW rules based
    on certain events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UFW itself is written in Python. Therefore, you can use existing Python knowledge
    if we need to extend the current command sets. More information is available at
    [https://launchpad.net/ufw](https://launchpad.net/ufw).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UFW proves to be a good tool to safeguard your network server.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a very common language used in many security-related fields. A few
    of the books I would recommend are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Violent Python**: A cookbook for hackers, forensic analysts, penetration
    testers, and security engineers, by T.J. O’Connor (ISBN-10: 1597499579)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Black Hat Python**: Python programming for hackers and pen-testers, by Justin
    Seitz (ISBN-10: 1593275900)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have personally used Python extensively in my research work on **Distributed
    Denial of Service** (**DDoS**) at A10 Networks. If you are interested in learning
    more, the guide can be downloaded for free at [https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/](https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at network security with Python. We used the Cisco
    CML tool to set up our lab with hosts and network devices, consisting of NX-OSv
    and IOSv types. We took a tour around Scapy, which allows us to construct packets
    from the ground up.
  prefs: []
  type: TYPE_NORMAL
- en: Scapy can be used in interactive mode for quick testing. Once testing is completed
    in interactive mode, we can put the steps into a file for more scalable testing.
    It can be used to perform various network penetration testing for known vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how we can use both an IP access list and a MAC access list
    to protect our network. They are usually the first line of defense in our network
    protection. Using Ansible, we can deploy access lists consistently and quickly
    to multiple devices.
  prefs: []
  type: TYPE_NORMAL
- en: Syslog and other log files contain useful information that we should regularly
    comb through to detect any early signs of a breach. Using Python regular expressions,
    we can systematically search for known log entries that can point us to security
    events that require our attention. Besides the tools we have discussed, private
    VLAN and UFW are among some other useful tools that we can use for more security
    protection.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 7*, *Network Monitoring with Python – Part 1*, we will look at how
    to use Python for network monitoring. Monitoring allows us to know what is happening
    in our network, as well as the state of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Join our book community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code2903617220506617062.png)'
  prefs: []
  type: TYPE_IMG
