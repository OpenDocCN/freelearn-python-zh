- en: Securing Your App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的应用程序安全
- en: We have a mostly functioning blog app, but it is missing some crucial features,
    such as a user login, registration function, and the ability to add and edit posts
    from the browser. The user authentication functionality can be achieved in many
    different ways, so each of the following sections in this chapter will demonstrate
    a mutually exclusive method to create a login functionality. Each authentication
    method can have different levels of security, or may be adequate for different
    kinds of applications, ranging from web exposed to enterprise back office.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个基本功能齐全的博客应用程序，但它缺少一些关键功能，例如用户登录、注册功能以及从浏览器添加和编辑帖子的能力。用户身份验证功能可以通过多种方式实现，因此本章的每个后续部分都将演示一种互斥的方法来创建登录功能。每种身份验证方法可能具有不同的安全级别，或者可能适用于不同类型的应用程序，从公开的Web到企业后台办公室。
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: 'A brief overview of various authentication methods: basic authentication, remote
    user, LDAP, database authentication, and OpenID and Oauth'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种身份验证方法的简要概述：基本身份验证、远程用户、LDAP、数据库身份验证和OpenID和Oauth
- en: How to leverage Flask login (database/cookie authentication)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何利用Flask登录（数据库/cookie身份验证）
- en: How to implement **role-based access control** (**RBAC**) to distinguish functionality
    and implement granular access to normal blog users
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现**基于角色的访问控制**（**RBAC**）以区分功能并实现对普通博客用户的细粒度访问
- en: 'If you haven''t already, download the provided code and use the `init.sh` script
    to create a `virtualenv`, database schema, and test data. The test data will create
    three users, all with their passwords set to `password.` The users will each have
    the following permissions respectively:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请下载提供的代码，并使用`init.sh`脚本来创建`virtualenv`、数据库模式和测试数据。测试数据将创建三个用户，所有用户的密码都设置为`password`。每个用户将分别拥有以下权限：
- en: '`user_default` with minimal permissions'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_default`具有最小权限'
- en: '`user_poster` with author permissions'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_poster`具有作者权限'
- en: '`admin` with admin permissions'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin`具有管理员权限'
- en: Let's first explore some very simple authentication methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先探讨一些非常简单的身份验证方法。
- en: Authentication methods
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证方法
- en: An authentication method is a process of confirming an identity. In the case
    of an application, a user is given a username and a secret security token (password)
    and uses them to verify their identity on the application itself. There are several
    authentication methods and types, used for different types of applications (such
    as API, web exposed, intranet, and government). We will be covering the most used
    type of authentication—single factor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证方法是一个确认身份的过程。在应用程序的情况下，用户被分配一个用户名和一个秘密安全令牌（密码），并使用它们在应用程序本身上验证其身份。有几种身份验证方法和类型，用于不同类型的应用程序（如API、公开的Web、内网和政府）。我们将介绍最常用的身份验证类型——单因素。
- en: Basic authentication
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本身份验证
- en: As the name suggests, basic authentication is a very simple authentication method
    implemented by the HTTP protocol itself. It is part of the RFC7617\. To use it,
    we can configure our web servers (IIS, Apache, and NGINX) to implement it, or
    we can implement it ourselves.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，基本身份验证是HTTP协议本身实现的一种非常简单的身份验证方法。它是RFC7617的一部分。要使用它，我们可以配置我们的Web服务器（IIS、Apache和NGINX）来实现它，或者我们可以自己实现它。
- en: For details on how to configure NGINX for basic authentication, go to [https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/](https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何配置NGINX进行基本身份验证的详细信息，请访问 [https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/](https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/)。
- en: 'The basic authentication protocol goes through the following general steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 基本身份验证协议经过以下一般步骤：
- en: The user requests a protected resource from the server.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户从服务器请求受保护的资源。
- en: 'The server responds with `401` (unauthorized) and the HTTP header `WWW-Authenticate:
    Basic realm="Login required"`*.*'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '服务器响应`401`（未授权）和HTTP头`WWW-Authenticate: Basic realm="Login required"`*.*'
- en: The browser will display a basic authentication login window for the user to
    send a username/password back to the server.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器将为用户显示基本身份验证登录窗口，以便用户将用户名/密码发送回服务器。
- en: 'The username and password provided by the user will be sent to the server on
    the HTTP header with the form `Authorization: Basic <Username>:<Password>`*.*
    The `username:password` will be base64-encoded.'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '用户提供的用户名和密码将以 `Authorization: Basic <Username>:<Password>` 的形式在 HTTP 标头中发送到服务器。`username:password`
    将被 base64 编码。'
- en: 'Flask will make it easy for us to implement this protocol, since it will automatically
    decode the base64 authorization from the HTTP header and place the username and
    password has properties of the `Request.authorization` object, as shown in the
    following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 将使我们能够轻松实现此协议，因为它将自动从 HTTP 标头中解码 base64 授权，并将用户名和密码作为 `Request.authorization`
    对象的属性放置，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This type of authentication is very simple, but not very secure. The username
    and password will be sent to the server on every request, so make sure that you
    always use HTTPS to properly encrypt their transmission over the wire. Additionally,
    as you may have already noticed in the code flow of the preceding example, the
    authentication method will be invoked on every request, so it is not very efficient.
    Yet this can be a good option for the internal use of a very simple back-office
    application, or for rapidly protecting a proof-of-concept application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种认证类型非常简单，但不太安全。用户名和密码将在每次请求时发送到服务器，因此请确保您始终使用 HTTPS 正确加密它们的传输。此外，如您可能已经在前面示例的代码流程中注意到的，认证方法将在每次请求时被调用，因此它不太高效。然而，这对于非常简单的后台应用程序的内部使用或快速保护概念验证应用程序来说可能是一个不错的选择。
- en: Remote-user authentication
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程用户认证
- en: We can, with some intranet setups, use single sign-on authentication methods,
    where the web servers do all the heavy lifting related with security. This can
    be done using **IIS integrated windows authentication** or **Apache mod_auth_sspi**,
    **Apache Samba**, or others. The setup is beyond the scope of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些内部网络设置中，我们可以使用单点登录认证方法，其中 Web 服务器执行与安全相关的所有繁重工作。这可以使用 **IIS 集成 Windows 认证**
    或 **Apache mod_auth_sspi**、**Apache Samba** 或其他方法完成。设置超出了本书的范围。
- en: You can check out some examples of how to set up this kind of authentication
    with Apache Samba at [https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory](https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory](https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory)
    上查看如何使用 Apache Samba 设置此类认证的一些示例。
- en: 'With this kind of authentication method, the web server will pass the already
    authenticated username as an environment key to the **WSGI** (**web server gateway
    interface**), so we just have to fetch it using the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种认证方法，Web 服务器将已认证的用户名作为环境密钥传递给 **WSGI**（**Web 服务器网关接口**），因此我们只需使用以下方法获取它：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For our blog application, we could just check whether the user exists on the
    database, so no password database field is needed. This authentication method
    can be considered secure if it is properly set up on the server, and can be very
    convenient on intranet setups since the user, if already authenticated on the
    domain (for example, Active Directory) will no longer need to fill his/her login/password
    again (using Kerberos GSSAPI, or Windows SSPI, for example).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的博客应用程序，我们只需检查用户是否在数据库中存在即可，因此不需要密码数据库字段。如果服务器上设置得当，这种认证方法可以被认为是安全的，并且在内部网络设置中可以非常方便，因为如果用户已经在域（例如，Active
    Directory）上进行了认证，将不再需要再次填写其登录名/密码（例如使用 Kerberos GSSAPI 或 Windows SSPI）。
- en: LDAP authentication
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDAP 认证
- en: '**LDAP** (**lightweight directory access protocol**) is an open standard described
    currently by RFC4511\. Its purpose is to implement a distributed information directory
    over the IP. This directory can contain different types of information normally
    related to users, groups, and devices. It has a fixed schema describing each object''s
    attributes, but this schema can be changed using LDIF.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**LDAP**（**轻量级目录访问协议**）是一个由当前 RFC4511 描述的开放标准。其目的是在 IP 上实现分布式信息目录。此目录可以包含与用户、组和设备通常相关的不同类型的信息。它有一个固定模式描述每个对象的属性，但可以使用
    LDIF 更改此模式。'
- en: Active Directory is Microsoft's implementation of LDAP. You can take a look
    at the base-implemented user attributes that are available at [http://www.kouti.com/tables/userattributes.htm](http://www.kouti.com/tables/userattributes.htm).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Active Directory 是微软对 LDAP 的实现。您可以查看在 [http://www.kouti.com/tables/userattributes.htm](http://www.kouti.com/tables/userattributes.htm)
    上提供的基实现用户属性。
- en: 'An entry (for example, the user) on the directory is identified by a **distinguished
    name** (**DN**). For example, take a look at the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中的条目（例如，用户）通过一个**唯一名称**（**DN**）来识别。例如，看看下面的代码：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `DC`phrase is the domain component, and it identifies the domain where the
    user is (an LDAP directory can have trees of domains and subdomains). In our example,
    the domain is `example.com`. The phrase` OU` refers to the organizational unit
    where the user is, and `CN`is its common name.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`DC`短语是域组件，它标识了用户所在的域（LDAP目录可以有域和子域的树状结构）。在我们的例子中，域是`example.com`。短语`OU`指的是用户所在的组织单元，而`CN`是其通用名称。'
- en: The LDAP implements various operations, such as adding users, searching, deleting
    and so on. For authentication purposes only, we are interested on the `Bind` and
    `Search` operations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: LDAP实现了各种操作，如添加用户、搜索、删除等。仅就认证目的而言，我们只对`Bind`和`Search`操作感兴趣。
- en: 'To use the LDAP, we will need to install `python-ldap`, so let''s do that first
    using the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用LDAP，我们需要安装`python-ldap`，让我们首先使用以下代码进行安装：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The two most commonly used LDAP services nowadays are **OpenLDAP** (open and
    free) and **Microsoft Active Directory** (commercial). Their implementation differs
    a bit, mainly regarding their user attributes. The following code is an example
    of Active Directory. First, we need to define some configuration keys to connect
    to and authenticate with the service:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常用的两个LDAP服务是**OpenLDAP**（开放和免费）和**Microsoft Active Directory**（商业）。它们的实现略有不同，主要是在用户属性方面。以下代码是Active
    Directory的一个示例。首先，我们需要定义一些配置键来连接和认证服务：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that we are using nonencrypted communication between our application server
    and the LDAP server; we can turn encryption on by using digital certificates and
    using LDAPS on our `LDAP_SERVER` configuration key.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在应用程序服务器和LDAP服务器之间使用的是非加密通信；我们可以通过使用数字证书并在`LDAP_SERVER`配置键上使用LDAPS来启用加密。
- en: If we were to integrate LDAP authentication with our blog application, these
    values would be good candidates for our configuration on `config.py`***.***
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将LDAP认证集成到我们的博客应用程序中，这些值将是我们在`config.py`配置中的良好候选者***。
- en: 'Next, we will connect to and authenticate with the service as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将按照以下方式连接到并认证服务：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `OPT_REFERRALS` is a specific workaround for MSFT AD. Take a look at the
    FAQ for `python-ldap` for more detailed information at [https://www.python-ldap.org/en/latest/faq.html](https://www.python-ldap.org/en/latest/faq.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPT_REFERRALS`是针对MSFT AD的特定解决方案。请参阅`python-ldap`的常见问题解答以获取更多详细信息，请访问[https://www.python-ldap.org/en/latest/faq.html](https://www.python-ldap.org/en/latest/faq.html)。'
- en: 'Now that we have an authenticated connection, we will search for our user to
    fetch its username, as shown in the following code. In Active Directory, we could
    bind directly using the user''s username and password, yet that method would fail
    in OpenLDAP. This way, we are following the standard method that will work on
    both systems:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了认证连接，我们将搜索我们的用户以获取其用户名，如下面的代码所示。在Active Directory中，我们可以直接使用用户的用户名和密码进行绑定，但在OpenLDAP中这种方法会失败。这样，我们遵循的是在两个系统上都适用的标准方法：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A complete authentication function for LDAP could be as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的LDAP认证函数可能如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, with the LDAP username we make a final bind to authenticate our user
    (the highlighted code).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用LDAP用户名进行最后的绑定以认证我们的用户（高亮显示的代码）。
- en: Database user model authentication
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库用户模型认证
- en: Database authentication is widely used for internet-faced applications. If properly
    implemented, it can be considered a secure method. It has the advantages of being
    simple to add new users, and having no dependency on any external services. Security
    roles, groups, fine-grained access permissions, and extra user attributes are
    also all kept on the database. These can be easily changed without any external
    dependencies, and maintained within the scope change of the application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库认证在面向互联网的应用程序中得到了广泛的应用。如果实施得当，它可以被认为是一种安全的方法。它具有易于添加新用户和没有对外部服务的依赖的优点。安全角色、组、细粒度访问权限和额外的用户属性也都保存在数据库中。这些可以很容易地更改，而无需任何外部依赖，并且可以在应用程序的范围内维护。
- en: This authentication method consists of checking the username and password submitted
    by a user against the stored attributes in our database's user model. But until
    now, our users had their passwords stored as plain text in the database. This
    is a major security flaw. If any malicious user were to gain access to the data
    in the database, they could log in to any account. The fallout of such a breach
    not be limited to our site. Large numbers of people on the internet use a common
    password for many sites. If an attacker had access to an email and password combination,
    it is very likely that this information could be used to log in to a Facebook
    account, or even a bank account.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种认证方法包括检查用户提交的用户名和密码与数据库中用户模型存储的属性是否匹配。但是，直到现在，我们的用户密码都存储在数据库中的纯文本形式。这是一个重大的安全漏洞。如果任何恶意用户能够访问数据库中的数据，他们可以登录到任何账户。这种安全漏洞的后果不仅限于我们的网站。互联网上有大量的人使用许多网站的通用密码。如果一个攻击者能够访问到一个电子邮件和密码组合，那么这个信息很可能被用来登录到Facebook账户，甚至银行账户。
- en: To protect our user passwords, they will be encrypted with a one-way encryption
    method called a **hashing algorithm**. A one-way encryption means that after the
    information is encrypted, the original information cannot be regained from the
    result. However, given the same data, the hashing algorithm will always produce
    the same result. The data given to the hashing algorithm can be anything from
    a text file to a movie file. In this case, the data is just a string of characters.
    With this functionality, our passwords can be stored as **hashes** (data that
    has been hashed). Then, when a user enters their password in the login or registration
    page, the text entered for the password will be sent through the same hashing
    algorithm, and the stored hash and the entered hash will be verified.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护我们的用户密码，我们将使用一种称为**哈希算法**的单向加密方法进行加密。单向加密意味着信息加密后，原始信息无法从结果中恢复。然而，给定相同的数据，哈希算法将始终产生相同的结果。提供给哈希算法的数据可以是任何东西，从文本文件到电影文件。在这种情况下，数据只是一串字符。有了这个功能，我们的密码可以存储为**哈希值**（经过哈希处理的数据）。然后，当用户在登录或注册页面上输入密码时，输入的密码文本将通过相同的哈希算法进行处理，并将存储的哈希值与输入的哈希值进行验证。
- en: This is one of the authentication methods we will use; further implementation
    details are described later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要使用的一种认证方法；进一步的实现细节将在本章后面描述。
- en: OpenID and OAuth
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenID和OAuth
- en: Integrating alternative login and registration options into your site becomes
    more important as time goes on. Every month, there is another announcement that
    passwords have been stolen from a popular website. Implementing the following
    login options means that our site's database never stores a password for that
    user. Verification is handled by a large brand-named company that the user already
    places their trust in. By using social logins, the amount of trust a user has
    to place in the website they are using is much higher. Your login process also
    becomes much shorter for the user, decreasing the barrier to entry to your app.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，将替代登录和注册选项集成到您的网站中变得越来越重要。每个月，都会有关于某个热门网站密码被盗的公告。实施以下登录选项意味着我们的网站数据库永远不会存储该用户的密码。验证由用户已经信任的大型品牌公司处理。通过使用社交登录，用户对所使用的网站的信任程度大大提高。用户的登录过程也变得更短，降低了进入应用程序的门槛。
- en: Socially authenticated users act as normal users, and unlike the password-based
    login methods, they can all be used in tandem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 社交认证用户的行为与普通用户相同，并且与基于密码的登录方法不同，它们都可以协同使用。
- en: '**OpenID** is an open-standard authentication protocol that allows users on
    one site to be authenticated by any third-party site that implements the protocol,
    which are called **identity providers**. An OpenID login is represented as a URL
    from one of the identity providers, typically the profile page of the website.
    The users that wish to use this authentication method need to be already registered
    on at least one of the OpenID providers.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenID**是一种开放标准的认证协议，允许一个网站上的用户通过任何实现该协议的第三方网站进行认证，这些网站被称为**身份提供者**。OpenID登录通常表示为来自某个身份提供者的URL，通常是网站的简介页面。希望使用这种认证方法的用户需要在至少一个OpenID提供者处已经注册。'
- en: To see a full list of sites that use OpenID, and to learn how to use each one,
    go to [https://openid.net/get-an-openid/](https://openid.net/get-an-openid/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看使用OpenID的网站完整列表，以及了解如何使用每个网站，请访问[https://openid.net/get-an-openid/](https://openid.net/get-an-openid/)。
- en: During the process of authentication, the user is redirected to the OpenID provider,
    where the user can authenticate—typically using a username/password, but it can
    be any other method—and is asked if they trust the party (our application). If
    the user trusts our application and authenticates successfully, then the user
    is redirected back with a document holding some requested user information (such
    as the username or email). A final request is made to check whether the data really
    came from the provider.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证过程中，用户将被重定向到OpenID提供者，在那里用户可以进行认证——通常使用用户名/密码，但可以是任何其他方法——并询问他们是否信任该方（我们的应用程序）。如果用户信任我们的应用程序并成功认证，那么用户将被重定向回，并带有一个包含一些请求的用户信息的文档（如用户名或电子邮件）。然后发出一个最终请求来检查数据是否确实来自提供者。
- en: '**OAuth** is not an authentication method—it is an access-delegation method.
    It was mainly designed to enable third-party applications to interact with the
    OAuth providers (Facebook, Twitter, and so on). With it, we can design an application
    to interact with a user''s Facebook account, performing actions such as posting
    on his behalf, sending notifications, retrieving their friends list, and so on.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**OAuth** 不是一个认证方法——它是一个访问委托方法。它主要是为了使第三方应用程序能够与OAuth提供者（Facebook、Twitter等）交互而设计的。通过它，我们可以设计一个应用程序来与用户的Facebook账户交互，执行诸如代表用户发布、发送通知、检索他们的朋友列表等操作。'
- en: To start using OAuth, we first need to register our application on the OAuth
    provider and use its consumer key and secret token.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用OAuth，我们首先需要在OAuth提供者上注册我们的应用程序，并使用其消费者密钥和秘密令牌。
- en: 'For Facebook, we need to register our application at [http://developers.facebook.com](http://developers.facebook.com).
    Once you create a new app, look for the panel that lists your app''s ID and secret
    key, as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Facebook，我们需要在 [http://developers.facebook.com](http://developers.facebook.com)
    上注册我们的应用程序。一旦创建了一个新的应用程序，请查找列出您的应用程序ID和秘密密钥的面板，如下面的截图所示：
- en: '![](img/b8f61c46-8451-47b2-ae17-0c5e849b5c87.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8f61c46-8451-47b2-ae17-0c5e849b5c87.png)'
- en: To create a Twitter app and receive your keys, go to [https://apps.twitter.com/](https://apps.twitter.com/). Please
    do so, since we are going to use these keys, tokens and configuration information
    to set up our blog application for OAuth pseudoauthentication.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Twitter应用程序并接收您的密钥，请访问 [https://apps.twitter.com/](https://apps.twitter.com/)。请这样做，因为我们将要使用这些密钥、令牌和配置信息来设置我们的博客应用程序进行OAuth伪认证。
- en: 'The OAuth process is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth流程如下：
- en: The application requests access to a user's resources from the OAuth provider.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序从OAuth提供者请求访问用户的资源。
- en: The user is redirected and authorizes the requested access.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户将被重定向并授权请求的访问。
- en: The application receives an authorization grant, and requests an access token
    by providing its own credentials (key and token) as well as the received grant.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序收到一个授权授予，并通过提供自己的凭据（密钥和令牌）以及收到的授权来请求访问令牌。
- en: The application receives the access token (this will serve as our authentication
    method) and can be further used to interact with the provider API on behalf of
    our user.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序收到访问令牌（这将成为我们的认证方法）并可以进一步用于代表我们的用户与提供者API交互。
- en: For a view of the complete OAuth process, go to [https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2](https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解完整的OAuth流程，请访问 [https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2](https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2)。
- en: Since we will be using both methods in our application, you will find the implementation
    details in the following chapters.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在我们的应用程序中使用这两种方法，您将在以下章节中找到实现细节。
- en: Flask-Login overview
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flask-Login概述
- en: Flask-Login is a popular Flask extension for handling the process of logging
    users in and out, properly handling cookie sessions, and even using basic authentication
    with HTTP headers. It will set up callbacks for user loading, header authentication,
    logging in, logging out, unauthorized events, and so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Login是一个流行的Flask扩展，用于处理用户登录和注销的过程，正确处理cookie会话，甚至可以使用HTTP头的基本认证。它将为用户加载、头部认证、登录、注销、未经授权的事件等设置回调。
- en: 'To start using Flask-Login, we first need to declare it as a dependency on
    our `requirements.txt`, as shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Flask-Login，我们首先需要在`requirements.txt`中将它声明为一个依赖项，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need to update our Python virtual environment as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要更新我们的Python虚拟环境如下：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you have executed the provided `init.sh` script, then there is no need to
    update the `virtualenv`. All the required dependencies for this chapter are already
    installed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经执行了提供的`init.sh`脚本，那么就没有必要更新`virtualenv`。本章所需的所有依赖项已经安装。
- en: 'To use the session and login flow implemented by Flask-Login, we will need
    to do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Flask-Login实现的会话和登录流程，我们需要做以下事情：
- en: 'Change the user model and implement the following functions:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改用户模型并实现以下函数：
- en: '`is_authenticated`: This checks whether the current user is authenticated'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_authenticated`：这检查当前用户是否已认证'
- en: '`is_active`: This checks whether a user is active'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_active`：这检查用户是否活跃'
- en: '`is_anonymous`: This supports anonymous accesses to our blog'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_anonymous`：这支持对博客的匿名访问'
- en: '`get_id`: This fetches the user ID'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_id`：这获取用户ID'
- en: 'Initialize and configure the login manager object, declaring the following:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化和配置登录管理器对象，声明以下内容：
- en: Where our login view is (URL)
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的登录视图所在的位置（URL）
- en: The type of session
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话类型
- en: The login message (flashed login message)
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录消息（闪现登录消息）
- en: The special user class for anonymous users
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名用户的特殊用户类
- en: Register and implement a function to load our authenticated user
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册并实现一个加载我们认证用户的函数
- en: A function that returns a user object by its ID
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通过其ID返回用户对象的函数
- en: Flask-Login is agnostic as to our authentication method, so the authentication
    system itself needs be implemented.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Login对我们的认证方法无关紧要，因此认证系统本身需要实现。
- en: Setting up
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'To implement the user authentication system, we will develop a new module in
    our application by following the rules that were previously proposed in [Chapter
    5](dee931d4-a3b0-4355-acbd-37e05e158356.xhtml), *Advanced Application Structure*.
    Our application structure will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现用户认证系统，我们将根据之前在[第五章](dee931d4-a3b0-4355-acbd-37e05e158356.xhtml)，*高级应用结构*中提出的规则，在我们的应用程序中开发一个新的模块。我们的应用程序结构将如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To keep the principle of separation of concerns in our approach to our module''s
    design, we will make a simple change to the way we register each module blueprint.
    This is a nice thing to have, and it''s necessity is more evident now because
    in this chapter, we will be using lots of new extensions to implement security,
    and we have to initialize them, register event methods, and configure them. All
    of these security bootstrapping procedures are best kept in the authentication
    module itself. To achieve this, we will create a new method in each `__init__.py` file
    for each module. Let''s take a look at how this is done in our blog and authentication
    modules:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持关注点分离的原则，我们将对注册每个模块蓝图的方式做简单修改。这是一件好事，而且现在这种必要性更加明显，因为在本章中，我们将使用许多新的扩展来实现安全性，并需要初始化它们、注册事件方法以及配置它们。所有这些安全引导程序最好都放在认证模块本身中。为了实现这一点，我们将在每个模块的`__init__.py`文件中为每个模块创建一个新的方法。让我们看看在博客和认证模块中是如何做到这一点的：
- en: 'First, let''s look at the code in the `blog/__**init__**.py `file:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`blog/__**init__**.py`文件中的代码：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the authentication module, we will handle the Flask-Login configuration and
    initialization as previously described. The main Flask-Login object is the `LoginManager` object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证模块中，我们将处理之前所述的Flask-Login配置和初始化。主要的Flask-Login对象是`LoginManager`对象。
- en: 'Let''s look at the code in the `auth/__**init__**.py `file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`auth/__**init__**.py`文件中的代码：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding configuration values define which view should be treated as the
    login page, and what the message should be to the user after a successful login.
    Setting the `session_protection` option to `strong` better protects against malicious
    users tampering with their cookies. When a tampered cookie is identified, the
    session object for that user is deleted and the user is forced to log back in.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置值定义了哪个视图应被视为登录页面，以及用户成功登录后应显示的消息。将`session_protection`选项设置为`strong`可以更好地保护免受恶意用户篡改其cookie。当识别出篡改的cookie时，该用户的会话对象将被删除，并强制用户重新登录。
- en: The `load_user` function takes an ID and returns the `User` object. When a cookie
    is validated, Flask-Login will use our function to fetch the user into the current
    session.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`load_user`函数接受一个ID并返回`User`对象。当cookie验证通过时，Flask-Login将使用我们的函数将用户拉入当前会话。'
- en: 'Finally, in the `create_app` method itself, we just have to call the `create_module` on
    each module, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`create_app`方法本身中，我们只需对每个模块调用`create_module`，如下所示：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To implement an authentication system, we need a lot of setup code. To run
    any type of authentication, our app will need the following elements:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个认证系统，我们需要大量的设置代码。为了运行任何类型的认证，我们的应用程序需要以下元素：
- en: The user models will need proper password hashing
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户模型需要适当的密码散列
- en: It will need to implement a system to keep a secure user session context
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要实现一个系统来保持安全的用户会话上下文
- en: A login form and a registration form will be needed to validate user input
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个登录表单和一个注册表单来验证用户输入
- en: A login view and a registration view (and templates for each) will be needed
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个登录视图和一个注册视图（以及每个视图的模板）
- en: Updating the models
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新模型
- en: 'There are many hashing algorithms, most of which are not secure because they
    are easy to **brute force**. With brute-force attacks, hackers continuously try
    sending data through a hashing algorithm until something matches. To best protect
    the user passwords, bcrypt will be our hashing algorithm of choice. Bcrypt is
    purposely designed to be inefficient and slow (milliseconds rather than microseconds)
    for the computer to process, thereby making it harder to brute force. To add bcrypt
    to our project, the package flask-bcrypt will need to be installed and added as
    a dependency on our `requirements.txt`, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多散列算法，其中大多数不安全，因为它们容易被**暴力破解**。在暴力破解攻击中，黑客会不断地通过散列算法发送数据，直到找到匹配项。为了最好地保护用户密码，bcrypt将成为我们选择的散列算法。bcrypt故意设计为对计算机处理效率低下且速度慢（毫秒级而不是微秒级），从而使得暴力破解更困难。要将bcrypt添加到我们的项目中，需要安装flask-bcrypt包并将其添加到`requirements.txt`的依赖项中，如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `flask-bcrypt` package will have to be initialized. This is done in the
    `auth` module, `auth/__**init__**.py`, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需要初始化`flask-bcrypt`包。这需要在`auth`模块的`auth/__**init__**.py`文件中完成，如下所示：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Bcrypt is now ready to use. To have our `User` object use bcrypt, we will add
    two methods that set the password and check whether a string matches the stored
    hash, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Bcrypt现在可以使用了。为了使我们的`User`对象使用bcrypt，我们将添加两个方法来设置密码和检查字符串是否与存储的散列匹配，如下所示：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, our `User` models can store passwords securely. We also need to implement
    the Flask-Login methods previously described for the session and authentication
    flow. For this, we first need to define our anonymous user object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`User`模型可以安全地存储密码。我们还需要实现之前描述的Flask-Login方法来处理会话和认证流程。为此，我们首先需要定义我们的匿名用户对象。
- en: 'On the `auth/__**init__**.py`, enter the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth/__**init__**.py`文件中，输入以下内容：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then add our `is_authenticated` property to the user model in `auth/models.py`,
    as shown in the following code. If the current user is not anonymous, then it
    is authenticated:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`auth/models.py`中的用户模型上添加我们的`is_authenticated`属性，如下所示。如果当前用户不是匿名用户，则表示已认证：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then we add the `is_active` property; we will not be using it, but it checks
    whether the user has gone through some sort of activation process, such as an
    email confirmation. Otherwise, it allows site administrators to ban a user without
    deleting their data. To implement this, we will create a new Boolean property
    on our user model schema definition, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加`is_active`属性；我们不会使用它，但它检查用户是否完成了一些激活过程，例如电子邮件确认。否则，它允许网站管理员在不删除用户数据的情况下禁止用户。为此，我们将在用户模型模式定义上创建一个新的布尔属性，如下所示：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we add the following `is_active` property and `get_id` method, which
    are pretty self explanatory:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加以下`is_active`属性和`get_id`方法，它们相当直观：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, our login process needs to use these methods to create new users and check
    passwords, and check whether a user is authenticated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的登录过程需要使用这些方法来创建新用户、检查密码以及检查用户是否已认证。
- en: Creating the forms
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表单
- en: 'Three forms are required: a login form, a registration form, and a form for
    our **post creation** page. The login form will have username and password fields.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 需要三个表单：一个登录表单、一个注册表单以及我们**帖子创建**页面的表单。登录表单将包含用户名和密码字段。
- en: 'The following is the code for the `auth/forms.py` file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是`auth/forms.py`文件的代码：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Along with the normal validations, our `LoginForm` method will also check whether
    the username that was passed exists, and will use the `check_password()` method
    to check the hashes. This is done by overriding the `validate()` method called
    on the form `POST` requests. Here, we will first check whether the user exists
    on the database, and if it exists, check whether the encrypted passwords match
    (which will result in a successful login).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常的验证之外，我们的`LoginForm`方法还将检查传递的用户名是否存在，并使用`check_password()`方法检查散列。这是通过覆盖在表单`POST`请求上调用的`validate()`方法来完成的。在这里，我们首先检查用户是否在数据库中存在，如果存在，检查加密的密码是否匹配（这将导致成功登录）。
- en: Protecting your form from spam
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的表单免受垃圾邮件
- en: The registration form will have a username field, a password field with a confirmation
    field, and a special field named a `reCAPTCHA` field. A `CAPTCHA` is a special
    field on a web form that checks whether the person who is entering data into the
    form is actually a person, or an automated program that is spamming your site.
    The `reCAPTCHA `field is simply one implementation of a `CAPTCHA` field. The `reCAPTCHA` method
    has been integrated into WTForms, as it is the most popular implementation on
    the web.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表单将包含一个用户名字段、一个带有确认字段的密码字段，以及一个名为`reCAPTCHA`的特殊字段。`CAPTCHA`是一种特殊的表单字段，用于检查填写表单的人是否真的是一个人，或者是一个正在垃圾邮件你的网站的自动化程序。`reCAPTCHA`字段是`CAPTCHA`字段的一种简单实现。`reCAPTCHA`方法已被集成到WTForms中，因为它是网络上最流行的实现。
- en: To use `reCAPTCHA`, you will need a `reCAPTCHA` login from [https://www.google.com/recaptcha/intro/index.html](https://www.google.com/recaptcha/intro/index.html).
    As `reCAPTCHA` is a Google product, you can log in with your Google account.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`reCAPTCHA`，您需要从[https://www.google.com/recaptcha/intro/index.html](https://www.google.com/recaptcha/intro/index.html)获取`reCAPTCHA`登录。因为`reCAPTCHA`是谷歌的产品，您可以使用您的谷歌账户登录。
- en: Once you log in, it will ask you to add a site. In this case, any name will
    do, but the domain field must have `localhost` as an entry. Once you deploy your
    site, your domain must also be added to this list.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您登录，它将要求您添加一个站点。在这种情况下，任何名称都可以，但域名字段必须以`localhost`作为条目。一旦您部署了您的网站，您的域名也必须添加到这个列表中。
- en: 'Now that you have added a site, dropdowns with instructions on server and client
    integration will appear. The given `script` tag will need to be added to the templates
    of our login and registration views when we create them. What WTForms needs from
    this page are the keys, as shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经添加了一个站点，将出现带有服务器和客户端集成说明的下拉菜单。在创建它们时，我们需要将给定的`script`标签添加到我们的登录和注册视图的模板中。WTForms需要从这个页面获取的键，如下面的截图所示：
- en: '![](img/45813611-4cec-4f1f-a3d9-31bcdcc87738.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45813611-4cec-4f1f-a3d9-31bcdcc87738.png)'
- en: Remember to never show these keys to the public. As these keys are only registered
    to `localhost`, they can be shown here without any problem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住永远不要向公众展示这些密钥。因为这些密钥仅注册到`localhost`，所以在这里展示没有任何问题。
- en: 'Add these keys to the `config` object in the `config.py` file so that WTForms
    can access them as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些键添加到`config.py`文件中的`config`对象中，以便WTForms可以如下访问它们：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code is our registration form in `auth/forms.py`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是我们在`auth/forms.py`中的注册表单：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note how we are preventing a user from registering itself twice by overriding
    the `validate` method. This is the right way to add extra form validation logic,
    as we previously explained.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何通过覆盖`validate`方法来防止用户两次注册自己的。这是我们之前解释的添加额外表单验证逻辑的正确方法。
- en: 'The post creation form will just contain a text input for the title and a text
    area input for the post content. So the `blog/forms.py` will contain the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后的表单将只包含标题的文本输入和帖子内容的文本区域输入。因此，`blog/forms.py`将包含以下内容：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating views
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视图
- en: The login and registration views will create our form objects and pass them
    to the templates. After the `LoginForm` validates the user's credentials, we will
    use Flask-Login to actually log the user in.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注册视图将创建我们的表单对象并将它们传递到模板中。在`LoginForm`验证了用户的凭据后，我们将使用Flask-Login来实际登录用户。
- en: 'In the `auth/controllers.py` controller, we will find the `login` view, as
    shown in the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth/controllers.py`控制器中，我们将找到`login`视图，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `logout` view is very simple, and will redirect the user to the main index
    page, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout`视图非常简单，将用户重定向到主索引页面，如下所示：'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `register` view is used to register database users only, and will redirect
    users to the login page so that they can immediately log in, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`视图仅用于注册数据库用户，并将用户重定向到登录页面，以便他们可以立即登录，如下所示：'
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Your login page should now resemble the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您的登录页面现在应该类似于以下截图：
- en: '![](img/ae9598f8-b18d-486b-b971-e1c04b640a52.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae9598f8-b18d-486b-b971-e1c04b640a52.png)'
- en: 'Your registration page should look like the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您的注册页面应该看起来像以下截图：
- en: '![](img/83ab564b-b8a8-4fc9-9b65-3c2840c60d89.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83ab564b-b8a8-4fc9-9b65-3c2840c60d89.png)'
- en: 'Now we need to create the post creation and editing page so that something
    can be secured. The two pages will need to transform the text area field into
    a **WYSIWYG** (short for **what you see is what you get**) editor to handle wrapping
    the post text in HTML. In the `blog/controllers.py` controller, you will find
    the following view to add new posts:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建帖子创建和编辑页面，以便进行安全保护。这两个页面需要将文本区域字段转换为**WYSIWYG**（即**所见即所得**）编辑器，以处理将帖子文本包裹在HTML中。在`blog/controllers.py`控制器中，您将找到以下视图以添加新帖子：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are protecting our view using the Flask-Login decorator `@login_required` to
    ensure that only authenticated users can submit new posts. Next, using the proxy
    method `current_user`, we fetch the currently logged user ID so that the post
    is associated with the user.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Flask-Login装饰器`@login_required`来保护我们的视图，以确保只有经过身份验证的用户可以提交新帖子。接下来，使用代理方法`current_user`，我们获取当前登录的用户ID，以便将帖子与用户关联。
- en: 'The `new.html` template will need a JavaScript file for the WYSIWYG editor; **CKEditor**
    is very simple to install and use. Now, our `new.html` file can be created as
    follows. Name it `templates/blog/new.html`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`new.html`模板需要JavaScript文件来支持WYSIWYG编辑器；**CKEditor**安装和使用都非常简单。现在，我们可以创建`new.html`文件，命名为`templates/blog/new.html`：'
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is all that is needed to have the user''s input stored as HTML in the
    database. Because we passed the `safe` filter in our post template, the HTML code
    appears correctly on our post pages. The `edit.html` template is similar to the
    `new.html` template. The only difference is the `form` opening tag, shown in the
    following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将用户输入存储为HTML在数据库中的所有所需内容。因为我们已经在我们的帖子模板中传递了`safe`过滤器，所以HTML代码在我们的帖子页面上显示正确。`edit.html`模板与`new.html`模板类似。唯一的区别是`form`标签的打开方式，如下所示：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `post.html` template will need a button for authors to link them to the
    edit page, as shown in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`post.html`模板需要为作者提供一个按钮，以便将他们链接到编辑页面，如下所示：'
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once again, we are using the `current_user` proxy to fetch the currently logged-in
    user, this time on a Jinja2 template, so that we only show the Edit button to
    the user that previously create the blog post.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`current_user`代理来获取当前登录的用户，这次是在Jinja2模板中，这样我们只向之前创建博客帖子的用户显示编辑按钮。
- en: 'Finally, we should add an entry to create new posts in the main navigation
    bar. We should also take a look at how the login, logout, and register options
    are enabled and disabled. In `templates/navbar.html`, enter the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该在主导航栏中添加一个创建新帖子的条目。我们还应该查看如何启用和禁用登录、注销和注册选项。在`templates/navbar.html`中输入以下内容：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: OpenID
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenID
- en: 'To integrate OpenID authentication with our application, we are going to use
    a new Flask extension named **Flask-OpenID, **implemented by the **Flask **creator
    itself. As always, the extension needs to be added to the `requirements.txt` file,
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将OpenID身份验证集成到我们的应用程序中，我们将使用一个名为**Flask-OpenID**的新Flask扩展，该扩展由**Flask**的创建者本身实现。像往常一样，需要将扩展添加到`requirements.txt`文件中，如下所示：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Our app will also need a couple of things to implement OpenID:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序还需要一些东西来实现OpenID：
- en: A new form object
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的表单对象
- en: The form validation in the login and registration pages
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和注册页面上的表单验证
- en: A callback after the form submission to log the user in or create a new user
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单提交后的回调以登录用户或创建新用户
- en: 'In the `auth/__init__.py` file, the `OpenID` object can be initialized as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth/__init__.py`文件中，`OpenID`对象可以按照以下方式初始化：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `create_module` function, the `oid` object is registered to the `app`
    object, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create_module`函数中，`oid`对象注册到`app`对象，如下所示：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The new `form` object will only need the URL of the `OpenID` provider. In `auth/forms.py`,
    enter the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`form`对象只需要`OpenID`提供者的URL。在`auth/forms.py`中输入以下内容：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the login and registration views, `OpenIDForm()` will be initialized, and
    if the data is valid, a login request will be sent. In `auth/views.py`, enter
    the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在登录和注册视图中，将初始化`OpenIDForm()`，如果数据有效，将发送登录请求。在`auth/views.py`中输入以下内容：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Both the views have the new decorator `@oid.loginhandler`, which tells Flask-OpenID
    to listen for authentication information coming back from the provider. With OpenID,
    logging in and registering are the same. It is possible to create a user from
    the login form and to log in from the registration form. The same field appears
    on both pages to avoid confusing the user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个视图都有新的装饰器`@oid.loginhandler`，它告诉Flask-OpenID监听来自提供者的认证信息。使用OpenID，登录和注册是相同的。可以从登录表单创建用户，也可以从注册表单登录。同一字段出现在两个页面上，以避免使用户困惑。
- en: 'To handle the user creation and login, a new function in the `auth/__init__.py` file
    is needed, as shown in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理用户创建和登录，需要在`auth/__init__.py`文件中添加一个新的函数，如下所示：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function is called after every successful response from the provider. If
    the login is successful and a user object does not exist for the identity, then
    this function creates a new `User` object. If one already exists, the upcoming
    authentication methods will log the user in. OpenID does not require all possible
    information to be returned, so it is possible that not a full name, but only an
    email address will be returned. This is why the username can be the nickname,
    full name, or email address. The `db` and `User` object are imported inside the
    function to avoid cyclical imports from the `models.py` file that is importing
    the `bcrypt` object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在从提供者成功响应后调用。如果登录成功且不存在用于该身份的用户对象，则此函数将创建一个新的`User`对象。如果已经存在，即将到来的认证方法将登录用户。OpenID不需要返回所有可能的信息，因此可能只返回电子邮件地址而不是全名。这就是为什么用户名可以是昵称、全名或电子邮件地址。在函数内部导入`db`和`User`对象是为了避免从导入`bcrypt`对象的`models.py`文件中产生循环导入。
- en: OAuth
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth
- en: 'To log in with Facebook and Twitter, the **OAuth** protocol is used as previously
    described. Our app will not use OAuth directly; instead, another Flask extension
    will be used, named **Flask Dance**. In the `requirements.txt`, enter the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Facebook和Twitter登录，将使用如前所述的**OAuth**协议。我们的应用程序不会直接使用OAuth；相反，将使用另一个名为**Flask
    Dance**的Flask扩展。在`requirements.txt`中输入以下内容：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As previously described, the OAuth protocol needs a previously created application
    in each provider''s developer page. After our application is created, we will
    have a key and secret token for each provider. For now, we are going to keep these
    credentials on the configuration file as is. Later, we will be using environment
    variables to handle them. So, in the configuration file `config.py`, add the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，OAuth协议需要在每个提供者的开发者页面上预先创建一个应用程序。在我们的应用程序创建后，我们将为每个提供者拥有一个密钥和秘密令牌。目前，我们将保持这些凭据在配置文件中不变。稍后，我们将使用环境变量来处理它们。因此，在`config.py`配置文件中，添加以下内容：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we are ready to initialize and configure our OAuth extension. **Flask-Dance **will
    help us create a new Flask blueprint for each provider we want to add. Once again,
    `auth/__init__.py` is the place where we configure all our authentication extensions,
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好初始化和配置我们的OAuth扩展。**Flask-Dance**将帮助我们为每个我们想要添加的提供者创建一个新的Flask蓝图。再次强调，`auth/__init__.py`是配置所有我们的认证扩展的地方，如下所示：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Flask-Dance will create the following routes for us:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-Dance将为我们创建以下路由：
- en: '`/auth/login/twitter/authorized`: Here, the user is redirected after authorization
    is successful on Twitter'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/twitter/authorized`: 在这里，用户在Twitter授权成功后将被重定向'
- en: '`/auth/login/twitter`: This is the initial login view for Twitter OAuth'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/twitter`: 这是Twitter OAuth的初始登录视图'
- en: '`/auth/login/facebook/authorized`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/facebook/authorized`'
- en: '`/auth/login/facebook`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/facebook`'
- en: 'After a successful login/authorization is accomplished, we need to log the
    user in on Flask-Login; if the user does not exist on the database, add them.
    To do this, we register for the authorized signal event. Enter the following in
    `auth/__init__.py`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功完成登录/授权后，我们需要在Flask-Login中登录用户；如果数据库中不存在用户，则添加他们。为此，我们注册了授权信号事件。在`auth/__init__.py`中输入以下内容：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `@oauth_authorized` is the decorator from Flask-Dance that we use to register
    our function to handle the after-authorized signal. This is a generic signal handler
    for all our providers, so we need to know what provider are we currently handling.
    We need to know this because we need to fetch our username, and each provider
    is going to expose different user information in a different way. On Twitter,
    we will use the `screen_name` key that has already been returned by the provider
    and has already been pushed to our Flask session object by Flask-Dance. But on
    Facebook, we need to make a further request to Facebook's API to fetch the username.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`@oauth_authorized`是Flask-Dance提供的装饰器，我们用它来注册我们的函数以处理授权后的信号。这是一个针对所有我们的提供者的通用信号处理器，因此我们需要知道我们目前正在处理哪个提供者。我们需要知道这一点，因为我们需要获取我们的用户名，而每个提供者将以不同的方式公开不同的用户信息。在Twitter上，我们将使用提供者已经返回的`screen_name`键，并且Flask-Dance已经将其推送到我们的Flask会话对象。但在Facebook上，我们需要进一步请求Facebook的API来获取用户名。'
- en: During development, you will probably not use HTTPS. This will trigger an error
    when using `OAuth2`. To get around this, you have to tell `oauthlib` to accept
    insecure connections. In the command line, enter  `$ export OAUTHLIB_INSECURE_TRANSPORT=1`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，你可能不会使用HTTPS。这将触发使用`OAuth2`时的错误。为了解决这个问题，你必须告诉`oauthlib`接受不安全的连接。在命令行中输入`$
    export OAUTHLIB_INSECURE_TRANSPORT=1`。
- en: 'Finally, in the register and login templates, we have the following links to
    start the login process:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在注册和登录模板中，我们提供了以下链接以启动登录过程：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Role-based access control (RBAC)
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）
- en: To implement a simple role-based access control system, we need to create a
    new database entity `Role` model that will need a many-to-many relationship for
    our `User` model so that a user can have multiple roles.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个简单的基于角色的访问控制系统，我们需要创建一个新的数据库实体`Role`模型，它将需要一个与我们的`User`模型的多对多关系，以便用户可以有多个角色。
- en: 'With our code from [Chapter 2](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml),
    *Creating Models with SQLAlchemy*, adding a many-to-many relationship to the `User`
    object is easy, as shown in the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们[第2章](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml)中的代码，*使用SQLAlchemy创建模型*，向`User`对象添加多对多关系非常简单，如下所示：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Also, when a user is created, a default role is always inserted into it. Note
    the `has_role` method that will help us easily check whether a user has a certain
    role; this will be useful for templates.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当创建用户时，总是将其插入一个默认角色。注意`has_role`方法将帮助我们轻松地检查用户是否具有某个角色；这对于模板将很有用。
- en: Our test data Python script has already populated the `Role` model with admin,
    poster, and default.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试数据Python脚本已经用管理员、发布者和默认角色填充了`Role`模型。
- en: 'Next, we will need a decorator function to enable RBAC in our views. Python''s
    decorator functions are very useful, and security is certainly a context where
    they can be welcome. Without them, we would have to write the same code over and
    over again (violating the DRY principal). We need a decorator function that receives
    an argument—on our case, the role name—and then checks whether the user has the
    required role. It returns `HTTP 403` if they do not. This is enabled using the
    following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个装饰器函数来在我们的视图中启用RBAC。Python的装饰器函数非常有用，安全是一个它们可以受欢迎的上下文。没有它们，我们就必须一遍又一遍地编写相同的代码（违反DRY原则）。我们需要一个装饰器函数，它接受一个参数——在我们的情况下，是角色名称——然后检查用户是否有所需的角色。如果没有，它返回`HTTP
    403`。这是通过以下代码启用的：
- en: '[PRE46]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `functools.update_wrapper` is needed so that the decorated function returns
    the function definition instead of the wrapper definition; without it, we would
    lose the routing definition from Flask.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`functools.update_wrapper`以确保装饰的函数返回函数定义而不是包装器定义；没有它，我们将失去Flask的路由定义。
- en: Now, we are ready to protect our **new post** view and **edit** view. Since
    only a user with the **poster** role can access them, this is now very simple using
    the `has_access` decorator.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好保护我们的**新帖子**视图和**编辑**视图。由于只有具有**发布者**角色的用户可以访问它们，因此现在使用`has_access`装饰器非常简单。
- en: 'Look at the `auth/__init__.py` file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下`auth/__init__.py`文件：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can also add a user check to the view, to ensure that only a user that has
    created a post can actually edit it. We have already disabled the edit option,
    but a user can always access the view by typing the URL directly in the browser.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在视图中添加用户检查，以确保只有创建了帖子的用户才能实际编辑它。我们已经禁用了编辑选项，但用户总是可以通过在浏览器中直接输入URL来访问视图。
- en: 'Go to the file named `blog/controllers.py`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前往名为`blog/controllers.py`的文件：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Also, in the navigation bar, we want to show the New Post option only to the
    users that have the poster role.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在导航栏中，我们只想向具有发布者角色的用户显示“新建文章”选项。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our users now have secure logins, multiple login and registration options, and
    explicit access permissions. Our app has everything that is needed to be a fully
    fledged blog app. In the next chapter, we will stop following this example application
    in order to introduce a technology named **NoSQL**.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户现在拥有安全的登录，多种登录和注册选项，以及明确的访问权限。我们的应用拥有成为一个完整的博客应用所需的一切。在下一章中，我们将停止跟随这个示例应用，以便介绍一种名为**NoSQL**的技术。
