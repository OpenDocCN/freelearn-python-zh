- en: Securing Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a mostly functioning blog app, but it is missing some crucial features,
    such as a user login, registration function, and the ability to add and edit posts
    from the browser. The user authentication functionality can be achieved in many
    different ways, so each of the following sections in this chapter will demonstrate
    a mutually exclusive method to create a login functionality. Each authentication
    method can have different levels of security, or may be adequate for different
    kinds of applications, ranging from web exposed to enterprise back office.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A brief overview of various authentication methods: basic authentication, remote
    user, LDAP, database authentication, and OpenID and Oauth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to leverage Flask login (database/cookie authentication)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement **role-based access control** (**RBAC**) to distinguish functionality
    and implement granular access to normal blog users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you haven''t already, download the provided code and use the `init.sh` script
    to create a `virtualenv`, database schema, and test data. The test data will create
    three users, all with their passwords set to `password.` The users will each have
    the following permissions respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user_default` with minimal permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user_poster` with author permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin` with admin permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first explore some very simple authentication methods.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An authentication method is a process of confirming an identity. In the case
    of an application, a user is given a username and a secret security token (password)
    and uses them to verify their identity on the application itself. There are several
    authentication methods and types, used for different types of applications (such
    as API, web exposed, intranet, and government). We will be covering the most used
    type of authentication—single factor.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, basic authentication is a very simple authentication method
    implemented by the HTTP protocol itself. It is part of the RFC7617\. To use it,
    we can configure our web servers (IIS, Apache, and NGINX) to implement it, or
    we can implement it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: For details on how to configure NGINX for basic authentication, go to [https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/](https://docs.nginx.com/nginx/admin-guide/security-controls/configuring-http-basic-authentication/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic authentication protocol goes through the following general steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The user requests a protected resource from the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server responds with `401` (unauthorized) and the HTTP header `WWW-Authenticate:
    Basic realm="Login required"`*.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The browser will display a basic authentication login window for the user to
    send a username/password back to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The username and password provided by the user will be sent to the server on
    the HTTP header with the form `Authorization: Basic <Username>:<Password>`*.*
    The `username:password` will be base64-encoded.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Flask will make it easy for us to implement this protocol, since it will automatically
    decode the base64 authorization from the HTTP header and place the username and
    password has properties of the `Request.authorization` object, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This type of authentication is very simple, but not very secure. The username
    and password will be sent to the server on every request, so make sure that you
    always use HTTPS to properly encrypt their transmission over the wire. Additionally,
    as you may have already noticed in the code flow of the preceding example, the
    authentication method will be invoked on every request, so it is not very efficient.
    Yet this can be a good option for the internal use of a very simple back-office
    application, or for rapidly protecting a proof-of-concept application.
  prefs: []
  type: TYPE_NORMAL
- en: Remote-user authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can, with some intranet setups, use single sign-on authentication methods,
    where the web servers do all the heavy lifting related with security. This can
    be done using **IIS integrated windows authentication** or **Apache mod_auth_sspi**,
    **Apache Samba**, or others. The setup is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out some examples of how to set up this kind of authentication
    with Apache Samba at [https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory](https://wiki.samba.org/index.php/Authenticating_Apache_against_Active_Directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this kind of authentication method, the web server will pass the already
    authenticated username as an environment key to the **WSGI** (**web server gateway
    interface**), so we just have to fetch it using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For our blog application, we could just check whether the user exists on the
    database, so no password database field is needed. This authentication method
    can be considered secure if it is properly set up on the server, and can be very
    convenient on intranet setups since the user, if already authenticated on the
    domain (for example, Active Directory) will no longer need to fill his/her login/password
    again (using Kerberos GSSAPI, or Windows SSPI, for example).
  prefs: []
  type: TYPE_NORMAL
- en: LDAP authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LDAP** (**lightweight directory access protocol**) is an open standard described
    currently by RFC4511\. Its purpose is to implement a distributed information directory
    over the IP. This directory can contain different types of information normally
    related to users, groups, and devices. It has a fixed schema describing each object''s
    attributes, but this schema can be changed using LDIF.'
  prefs: []
  type: TYPE_NORMAL
- en: Active Directory is Microsoft's implementation of LDAP. You can take a look
    at the base-implemented user attributes that are available at [http://www.kouti.com/tables/userattributes.htm](http://www.kouti.com/tables/userattributes.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'An entry (for example, the user) on the directory is identified by a **distinguished
    name** (**DN**). For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `DC`phrase is the domain component, and it identifies the domain where the
    user is (an LDAP directory can have trees of domains and subdomains). In our example,
    the domain is `example.com`. The phrase` OU` refers to the organizational unit
    where the user is, and `CN`is its common name.
  prefs: []
  type: TYPE_NORMAL
- en: The LDAP implements various operations, such as adding users, searching, deleting
    and so on. For authentication purposes only, we are interested on the `Bind` and
    `Search` operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the LDAP, we will need to install `python-ldap`, so let''s do that first
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The two most commonly used LDAP services nowadays are **OpenLDAP** (open and
    free) and **Microsoft Active Directory** (commercial). Their implementation differs
    a bit, mainly regarding their user attributes. The following code is an example
    of Active Directory. First, we need to define some configuration keys to connect
    to and authenticate with the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are using nonencrypted communication between our application server
    and the LDAP server; we can turn encryption on by using digital certificates and
    using LDAPS on our `LDAP_SERVER` configuration key.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to integrate LDAP authentication with our blog application, these
    values would be good candidates for our configuration on `config.py`***.***
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will connect to and authenticate with the service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `OPT_REFERRALS` is a specific workaround for MSFT AD. Take a look at the
    FAQ for `python-ldap` for more detailed information at [https://www.python-ldap.org/en/latest/faq.html](https://www.python-ldap.org/en/latest/faq.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an authenticated connection, we will search for our user to
    fetch its username, as shown in the following code. In Active Directory, we could
    bind directly using the user''s username and password, yet that method would fail
    in OpenLDAP. This way, we are following the standard method that will work on
    both systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A complete authentication function for LDAP could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finally, with the LDAP username we make a final bind to authenticate our user
    (the highlighted code).
  prefs: []
  type: TYPE_NORMAL
- en: Database user model authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database authentication is widely used for internet-faced applications. If properly
    implemented, it can be considered a secure method. It has the advantages of being
    simple to add new users, and having no dependency on any external services. Security
    roles, groups, fine-grained access permissions, and extra user attributes are
    also all kept on the database. These can be easily changed without any external
    dependencies, and maintained within the scope change of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This authentication method consists of checking the username and password submitted
    by a user against the stored attributes in our database's user model. But until
    now, our users had their passwords stored as plain text in the database. This
    is a major security flaw. If any malicious user were to gain access to the data
    in the database, they could log in to any account. The fallout of such a breach
    not be limited to our site. Large numbers of people on the internet use a common
    password for many sites. If an attacker had access to an email and password combination,
    it is very likely that this information could be used to log in to a Facebook
    account, or even a bank account.
  prefs: []
  type: TYPE_NORMAL
- en: To protect our user passwords, they will be encrypted with a one-way encryption
    method called a **hashing algorithm**. A one-way encryption means that after the
    information is encrypted, the original information cannot be regained from the
    result. However, given the same data, the hashing algorithm will always produce
    the same result. The data given to the hashing algorithm can be anything from
    a text file to a movie file. In this case, the data is just a string of characters.
    With this functionality, our passwords can be stored as **hashes** (data that
    has been hashed). Then, when a user enters their password in the login or registration
    page, the text entered for the password will be sent through the same hashing
    algorithm, and the stored hash and the entered hash will be verified.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the authentication methods we will use; further implementation
    details are described later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID and OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating alternative login and registration options into your site becomes
    more important as time goes on. Every month, there is another announcement that
    passwords have been stolen from a popular website. Implementing the following
    login options means that our site's database never stores a password for that
    user. Verification is handled by a large brand-named company that the user already
    places their trust in. By using social logins, the amount of trust a user has
    to place in the website they are using is much higher. Your login process also
    becomes much shorter for the user, decreasing the barrier to entry to your app.
  prefs: []
  type: TYPE_NORMAL
- en: Socially authenticated users act as normal users, and unlike the password-based
    login methods, they can all be used in tandem.
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenID** is an open-standard authentication protocol that allows users on
    one site to be authenticated by any third-party site that implements the protocol,
    which are called **identity providers**. An OpenID login is represented as a URL
    from one of the identity providers, typically the profile page of the website.
    The users that wish to use this authentication method need to be already registered
    on at least one of the OpenID providers.'
  prefs: []
  type: TYPE_NORMAL
- en: To see a full list of sites that use OpenID, and to learn how to use each one,
    go to [https://openid.net/get-an-openid/](https://openid.net/get-an-openid/).
  prefs: []
  type: TYPE_NORMAL
- en: During the process of authentication, the user is redirected to the OpenID provider,
    where the user can authenticate—typically using a username/password, but it can
    be any other method—and is asked if they trust the party (our application). If
    the user trusts our application and authenticates successfully, then the user
    is redirected back with a document holding some requested user information (such
    as the username or email). A final request is made to check whether the data really
    came from the provider.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth** is not an authentication method—it is an access-delegation method.
    It was mainly designed to enable third-party applications to interact with the
    OAuth providers (Facebook, Twitter, and so on). With it, we can design an application
    to interact with a user''s Facebook account, performing actions such as posting
    on his behalf, sending notifications, retrieving their friends list, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: To start using OAuth, we first need to register our application on the OAuth
    provider and use its consumer key and secret token.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Facebook, we need to register our application at [http://developers.facebook.com](http://developers.facebook.com).
    Once you create a new app, look for the panel that lists your app''s ID and secret
    key, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8f61c46-8451-47b2-ae17-0c5e849b5c87.png)'
  prefs: []
  type: TYPE_IMG
- en: To create a Twitter app and receive your keys, go to [https://apps.twitter.com/](https://apps.twitter.com/). Please
    do so, since we are going to use these keys, tokens and configuration information
    to set up our blog application for OAuth pseudoauthentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OAuth process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The application requests access to a user's resources from the OAuth provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected and authorizes the requested access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application receives an authorization grant, and requests an access token
    by providing its own credentials (key and token) as well as the received grant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application receives the access token (this will serve as our authentication
    method) and can be further used to interact with the provider API on behalf of
    our user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a view of the complete OAuth process, go to [https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2](https://flask-dance.readthedocs.io/en/latest/how-oauth-works.html#oauth-2).
  prefs: []
  type: TYPE_NORMAL
- en: Since we will be using both methods in our application, you will find the implementation
    details in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Flask-Login overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask-Login is a popular Flask extension for handling the process of logging
    users in and out, properly handling cookie sessions, and even using basic authentication
    with HTTP headers. It will set up callbacks for user loading, header authentication,
    logging in, logging out, unauthorized events, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Flask-Login, we first need to declare it as a dependency on
    our `requirements.txt`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to update our Python virtual environment as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you have executed the provided `init.sh` script, then there is no need to
    update the `virtualenv`. All the required dependencies for this chapter are already
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the session and login flow implemented by Flask-Login, we will need
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the user model and implement the following functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_authenticated`: This checks whether the current user is authenticated'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_active`: This checks whether a user is active'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_anonymous`: This supports anonymous accesses to our blog'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_id`: This fetches the user ID'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initialize and configure the login manager object, declaring the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where our login view is (URL)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of session
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The login message (flashed login message)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The special user class for anonymous users
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Register and implement a function to load our authenticated user
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that returns a user object by its ID
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flask-Login is agnostic as to our authentication method, so the authentication
    system itself needs be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the user authentication system, we will develop a new module in
    our application by following the rules that were previously proposed in [Chapter
    5](dee931d4-a3b0-4355-acbd-37e05e158356.xhtml), *Advanced Application Structure*.
    Our application structure will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep the principle of separation of concerns in our approach to our module''s
    design, we will make a simple change to the way we register each module blueprint.
    This is a nice thing to have, and it''s necessity is more evident now because
    in this chapter, we will be using lots of new extensions to implement security,
    and we have to initialize them, register event methods, and configure them. All
    of these security bootstrapping procedures are best kept in the authentication
    module itself. To achieve this, we will create a new method in each `__init__.py` file
    for each module. Let''s take a look at how this is done in our blog and authentication
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the code in the `blog/__**init__**.py `file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the authentication module, we will handle the Flask-Login configuration and
    initialization as previously described. The main Flask-Login object is the `LoginManager` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code in the `auth/__**init__**.py `file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration values define which view should be treated as the
    login page, and what the message should be to the user after a successful login.
    Setting the `session_protection` option to `strong` better protects against malicious
    users tampering with their cookies. When a tampered cookie is identified, the
    session object for that user is deleted and the user is forced to log back in.
  prefs: []
  type: TYPE_NORMAL
- en: The `load_user` function takes an ID and returns the `User` object. When a cookie
    is validated, Flask-Login will use our function to fetch the user into the current
    session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the `create_app` method itself, we just have to call the `create_module` on
    each module, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement an authentication system, we need a lot of setup code. To run
    any type of authentication, our app will need the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The user models will need proper password hashing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will need to implement a system to keep a secure user session context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A login form and a registration form will be needed to validate user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A login view and a registration view (and templates for each) will be needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many hashing algorithms, most of which are not secure because they
    are easy to **brute force**. With brute-force attacks, hackers continuously try
    sending data through a hashing algorithm until something matches. To best protect
    the user passwords, bcrypt will be our hashing algorithm of choice. Bcrypt is
    purposely designed to be inefficient and slow (milliseconds rather than microseconds)
    for the computer to process, thereby making it harder to brute force. To add bcrypt
    to our project, the package flask-bcrypt will need to be installed and added as
    a dependency on our `requirements.txt`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flask-bcrypt` package will have to be initialized. This is done in the
    `auth` module, `auth/__**init__**.py`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Bcrypt is now ready to use. To have our `User` object use bcrypt, we will add
    two methods that set the password and check whether a string matches the stored
    hash, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `User` models can store passwords securely. We also need to implement
    the Flask-Login methods previously described for the session and authentication
    flow. For this, we first need to define our anonymous user object.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the `auth/__**init__**.py`, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add our `is_authenticated` property to the user model in `auth/models.py`,
    as shown in the following code. If the current user is not anonymous, then it
    is authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the `is_active` property; we will not be using it, but it checks
    whether the user has gone through some sort of activation process, such as an
    email confirmation. Otherwise, it allows site administrators to ban a user without
    deleting their data. To implement this, we will create a new Boolean property
    on our user model schema definition, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we add the following `is_active` property and `get_id` method, which
    are pretty self explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Next, our login process needs to use these methods to create new users and check
    passwords, and check whether a user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Three forms are required: a login form, a registration form, and a form for
    our **post creation** page. The login form will have username and password fields.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `auth/forms.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Along with the normal validations, our `LoginForm` method will also check whether
    the username that was passed exists, and will use the `check_password()` method
    to check the hashes. This is done by overriding the `validate()` method called
    on the form `POST` requests. Here, we will first check whether the user exists
    on the database, and if it exists, check whether the encrypted passwords match
    (which will result in a successful login).
  prefs: []
  type: TYPE_NORMAL
- en: Protecting your form from spam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The registration form will have a username field, a password field with a confirmation
    field, and a special field named a `reCAPTCHA` field. A `CAPTCHA` is a special
    field on a web form that checks whether the person who is entering data into the
    form is actually a person, or an automated program that is spamming your site.
    The `reCAPTCHA `field is simply one implementation of a `CAPTCHA` field. The `reCAPTCHA` method
    has been integrated into WTForms, as it is the most popular implementation on
    the web.
  prefs: []
  type: TYPE_NORMAL
- en: To use `reCAPTCHA`, you will need a `reCAPTCHA` login from [https://www.google.com/recaptcha/intro/index.html](https://www.google.com/recaptcha/intro/index.html).
    As `reCAPTCHA` is a Google product, you can log in with your Google account.
  prefs: []
  type: TYPE_NORMAL
- en: Once you log in, it will ask you to add a site. In this case, any name will
    do, but the domain field must have `localhost` as an entry. Once you deploy your
    site, your domain must also be added to this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have added a site, dropdowns with instructions on server and client
    integration will appear. The given `script` tag will need to be added to the templates
    of our login and registration views when we create them. What WTForms needs from
    this page are the keys, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45813611-4cec-4f1f-a3d9-31bcdcc87738.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember to never show these keys to the public. As these keys are only registered
    to `localhost`, they can be shown here without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add these keys to the `config` object in the `config.py` file so that WTForms
    can access them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is our registration form in `auth/forms.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note how we are preventing a user from registering itself twice by overriding
    the `validate` method. This is the right way to add extra form validation logic,
    as we previously explained.
  prefs: []
  type: TYPE_NORMAL
- en: 'The post creation form will just contain a text input for the title and a text
    area input for the post content. So the `blog/forms.py` will contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The login and registration views will create our form objects and pass them
    to the templates. After the `LoginForm` validates the user's credentials, we will
    use Flask-Login to actually log the user in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `auth/controllers.py` controller, we will find the `login` view, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `logout` view is very simple, and will redirect the user to the main index
    page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `register` view is used to register database users only, and will redirect
    users to the login page so that they can immediately log in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Your login page should now resemble the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae9598f8-b18d-486b-b971-e1c04b640a52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your registration page should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83ab564b-b8a8-4fc9-9b65-3c2840c60d89.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to create the post creation and editing page so that something
    can be secured. The two pages will need to transform the text area field into
    a **WYSIWYG** (short for **what you see is what you get**) editor to handle wrapping
    the post text in HTML. In the `blog/controllers.py` controller, you will find
    the following view to add new posts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are protecting our view using the Flask-Login decorator `@login_required` to
    ensure that only authenticated users can submit new posts. Next, using the proxy
    method `current_user`, we fetch the currently logged user ID so that the post
    is associated with the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `new.html` template will need a JavaScript file for the WYSIWYG editor; **CKEditor**
    is very simple to install and use. Now, our `new.html` file can be created as
    follows. Name it `templates/blog/new.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all that is needed to have the user''s input stored as HTML in the
    database. Because we passed the `safe` filter in our post template, the HTML code
    appears correctly on our post pages. The `edit.html` template is similar to the
    `new.html` template. The only difference is the `form` opening tag, shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `post.html` template will need a button for authors to link them to the
    edit page, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we are using the `current_user` proxy to fetch the currently logged-in
    user, this time on a Jinja2 template, so that we only show the Edit button to
    the user that previously create the blog post.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should add an entry to create new posts in the main navigation
    bar. We should also take a look at how the login, logout, and register options
    are enabled and disabled. In `templates/navbar.html`, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: OpenID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To integrate OpenID authentication with our application, we are going to use
    a new Flask extension named **Flask-OpenID, **implemented by the **Flask **creator
    itself. As always, the extension needs to be added to the `requirements.txt` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app will also need a couple of things to implement OpenID:'
  prefs: []
  type: TYPE_NORMAL
- en: A new form object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form validation in the login and registration pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A callback after the form submission to log the user in or create a new user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `auth/__init__.py` file, the `OpenID` object can be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `create_module` function, the `oid` object is registered to the `app`
    object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `form` object will only need the URL of the `OpenID` provider. In `auth/forms.py`,
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the login and registration views, `OpenIDForm()` will be initialized, and
    if the data is valid, a login request will be sent. In `auth/views.py`, enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Both the views have the new decorator `@oid.loginhandler`, which tells Flask-OpenID
    to listen for authentication information coming back from the provider. With OpenID,
    logging in and registering are the same. It is possible to create a user from
    the login form and to log in from the registration form. The same field appears
    on both pages to avoid confusing the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the user creation and login, a new function in the `auth/__init__.py` file
    is needed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function is called after every successful response from the provider. If
    the login is successful and a user object does not exist for the identity, then
    this function creates a new `User` object. If one already exists, the upcoming
    authentication methods will log the user in. OpenID does not require all possible
    information to be returned, so it is possible that not a full name, but only an
    email address will be returned. This is why the username can be the nickname,
    full name, or email address. The `db` and `User` object are imported inside the
    function to avoid cyclical imports from the `models.py` file that is importing
    the `bcrypt` object.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To log in with Facebook and Twitter, the **OAuth** protocol is used as previously
    described. Our app will not use OAuth directly; instead, another Flask extension
    will be used, named **Flask Dance**. In the `requirements.txt`, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As previously described, the OAuth protocol needs a previously created application
    in each provider''s developer page. After our application is created, we will
    have a key and secret token for each provider. For now, we are going to keep these
    credentials on the configuration file as is. Later, we will be using environment
    variables to handle them. So, in the configuration file `config.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to initialize and configure our OAuth extension. **Flask-Dance **will
    help us create a new Flask blueprint for each provider we want to add. Once again,
    `auth/__init__.py` is the place where we configure all our authentication extensions,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Flask-Dance will create the following routes for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/auth/login/twitter/authorized`: Here, the user is redirected after authorization
    is successful on Twitter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/login/twitter`: This is the initial login view for Twitter OAuth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/login/facebook/authorized`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/login/facebook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After a successful login/authorization is accomplished, we need to log the
    user in on Flask-Login; if the user does not exist on the database, add them.
    To do this, we register for the authorized signal event. Enter the following in
    `auth/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `@oauth_authorized` is the decorator from Flask-Dance that we use to register
    our function to handle the after-authorized signal. This is a generic signal handler
    for all our providers, so we need to know what provider are we currently handling.
    We need to know this because we need to fetch our username, and each provider
    is going to expose different user information in a different way. On Twitter,
    we will use the `screen_name` key that has already been returned by the provider
    and has already been pushed to our Flask session object by Flask-Dance. But on
    Facebook, we need to make a further request to Facebook's API to fetch the username.
  prefs: []
  type: TYPE_NORMAL
- en: During development, you will probably not use HTTPS. This will trigger an error
    when using `OAuth2`. To get around this, you have to tell `oauthlib` to accept
    insecure connections. In the command line, enter  `$ export OAUTHLIB_INSECURE_TRANSPORT=1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the register and login templates, we have the following links to
    start the login process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Role-based access control (RBAC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement a simple role-based access control system, we need to create a
    new database entity `Role` model that will need a many-to-many relationship for
    our `User` model so that a user can have multiple roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our code from [Chapter 2](42af8825-fb77-4eb9-a010-7d7fc9644f7c.xhtml),
    *Creating Models with SQLAlchemy*, adding a many-to-many relationship to the `User`
    object is easy, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Also, when a user is created, a default role is always inserted into it. Note
    the `has_role` method that will help us easily check whether a user has a certain
    role; this will be useful for templates.
  prefs: []
  type: TYPE_NORMAL
- en: Our test data Python script has already populated the `Role` model with admin,
    poster, and default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need a decorator function to enable RBAC in our views. Python''s
    decorator functions are very useful, and security is certainly a context where
    they can be welcome. Without them, we would have to write the same code over and
    over again (violating the DRY principal). We need a decorator function that receives
    an argument—on our case, the role name—and then checks whether the user has the
    required role. It returns `HTTP 403` if they do not. This is enabled using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `functools.update_wrapper` is needed so that the decorated function returns
    the function definition instead of the wrapper definition; without it, we would
    lose the routing definition from Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to protect our **new post** view and **edit** view. Since
    only a user with the **poster** role can access them, this is now very simple using
    the `has_access` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `auth/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We can also add a user check to the view, to ensure that only a user that has
    created a post can actually edit it. We have already disabled the edit option,
    but a user can always access the view by typing the URL directly in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the file named `blog/controllers.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Also, in the navigation bar, we want to show the New Post option only to the
    users that have the poster role.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our users now have secure logins, multiple login and registration options, and
    explicit access permissions. Our app has everything that is needed to be a fully
    fledged blog app. In the next chapter, we will stop following this example application
    in order to introduce a technology named **NoSQL**.
  prefs: []
  type: TYPE_NORMAL
