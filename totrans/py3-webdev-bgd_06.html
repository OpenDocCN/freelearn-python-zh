<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 6. Building a Wiki"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building a Wiki</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>Nowadays, a wiki is a well-known tool to enable people to maintain a body of knowledge in a cooperative way. Wikipedia (http://wikipedia.org) might be the most famous example of a wiki today, but countless numbers of forums use some sort of wiki and many tools and libraries exist to implement a wiki application.<a id="id275" class="indexterm"/>
</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>In this chapter, we will develop a wiki of our own, and in doing so, we will focus on two important concepts in building web applications. The first one is the design of the data layer. We will build upon the simple framework created in the previous chapter and we will try to establish where the limitations in our current implementation lie. The wiki application we will be building is a good test case as it is considerably more complex than the book database developed earlier.<a id="id276" class="indexterm"/>
</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>The second one is input validation. A wiki is normally a very public application that might not even employ a basic authentication scheme to identify users. This makes contributing to a wiki very simple, yet also makes a wiki vulnerable in the sense that anyone can put anything on a wiki page. It's therefore a good idea to verify the content of any submitted change. You may, for example, strip out any HTML markup or disallow external links.<a id="id277" class="indexterm"/>
</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>Enhancing user interactions in a meaningful way is often closely related with input validation. As we saw in the previous chapter, client-side input validation helps prevent the user from entering unwanted input and is therefore a valuable addition to any application but is not a substitute for server-side input validation as we cannot trust the outside world not to try and access our server in unintended ways.</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>We will address both input validation and user interaction explicitly when we develop our wiki application in this chapter.</p></blockquote></div><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Implement a data layer for a wiki application</li><li class="listitem" style="list-style-type: disc">Implement a delivery layer</li><li class="listitem" style="list-style-type: disc">Take a good look at input validation</li><li class="listitem" style="list-style-type: disc">Encounter jQuery UI's dialog widget</li></ul></div><p>So let's get on with it...</p><div class="section" title="The data layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec01"/>The data layer</h1></div></div></div><p>A wiki consists of quite a number of distinct entities we can indentify. We will implement these entities and the relations that exist between them by reusing the Entity/Relation framework developed earlier.<a id="id278" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action designing the wiki data model"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec02"/>Time for action designing the wiki data model</h1></div></div></div><p>As with any application, when we start developing our wiki application we must first take a few steps to create a data model that can act as a starting point for the development:<a id="id279" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Identify each entity that plays a role in the application. This might depend on the requirements. For example, because we want the user to be able to change the title of a topic and we want to archive revisions of the content, we define separate Topic and Page entities.</li><li class="listitem">Identify direct relations between entities. Our decision to define separate Topic and Page entities implies a relation between them, but there are more relations that can be identified, for example, between Topic and Tag. Do not specify indirect relations: All topics marked with the same tag are in a sense related, but in general, it is not necessary to record these indirect relations as they can easily be inferred from the recorded relation between topics and tags.</li></ol></div><p>The image shows the different entities and relations we can identify in our wiki application. Note that like in the books application, a User is a separate entity that is distinct from any user in, for example, a password database.</p><p>In the diagram, we have illustrated the fact that a<code class="literal"> Topic</code> may have more than one<code class="literal"> Page</code> while a<code class="literal"> Page</code> refers to a single User in a rather informal way by representing Page as a stack of rectangles and<code class="literal"> User</code> as a single rectangle. In this manner, we can grasp the most relevant aspects of the relations at a glance. When we want to show more relations or relations with different characteristics, it might be a good idea to use more formal methods and tools. A good starting point is the Wikipedia entry on UML:<a class="ulink" href="http://en.wikipedia.org/wiki/Unified_Modelling_Language"> http://en.wikipedia.org/wiki/Unified_Modelling_Language</a>.</p><div class="mediaobject"><img src="images/3746OS_06_01.jpg" height="100" alt="Time for action designing the wiki data model"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec01"/>What just happened?</h2></div></div></div><p>With the entities and relations in our data model identified, we can have a look at their specific qualities.</p><p>The basic entity in a wiki is a<code class="literal"> Topic</code>. A topic, in this context, is basically a title that describes what this topic is about. A topic has any number of associated Pages. Each instance of a<code class="literal"> Page</code> represents a revision; the most recent revision is the<span class="emphasis"><em> current</em></span> version of a topic. Each time a topic is edited, a new revision is stored in the database. This way, we can simply revert to an earlier version if we made a mistake or compare the contents of two revisions. To simplify identifying revisions, each revision has a modification date. We also maintain a relation between the<code class="literal"> Page</code> and the<code class="literal"> User</code> that modified that<code class="literal"> Page</code>.<a id="id280" class="indexterm"/>
</p><p>In the wiki application that we will develop, it is also possible to associate any number of tags with a topic. A<code class="literal"> Tag</code> entity consists simply of a<code class="literal"> tag</code> attribute. The important part is the relation that exists between the<code class="literal"> Topic</code> entity and the<code class="literal"> Tag</code> entity.</p><p>Like a<code class="literal"> Tag</code>, a<code class="literal"> Word</code> entity consists of a single attribute. Again, the important bit is the relation, this time, between a<code class="literal"> Topic</code> and any number of<code class="literal"> Words</code>. We will maintain this relation to reflect the words used in the current versions (that is, the last revision of a<code class="literal"> Page)</code> of a<code class="literal"> Topic</code>. This will allow for fairly responsive full text search facilities.</p><p>The final entity we encounter is the<code class="literal"> Image</code> entity. We will use this to store images alongside the pages with text. We do not define any relation between topics and images. Images might be referred to in the text of the topic, but besides this textual reference, we do not maintain a formal relation. If we would like to maintain such a relation, we would be forced to scan for image references each time a new revision of a page was stored, and probably we would need to signal something if a reference attempt was made to a non-existing image. In this case, we choose to ignore this: references to images that do not exist in the database will simply show nothing:<a id="id281" class="indexterm"/>
</p><p>
<span class="strong"><strong/></span>
</p><div class="informalexample"><pre class="programlisting">
from entity import Entity
from relation import Relation
class User(Entity): pass
class Topic(Entity): pass
class Page(Entity): pass
class Tag(Entity): pass
class Word(Entity): pass
class Image(Entity): pass
class UserPage(Relation): pass
class TopicPage(Relation): pass
class TopicTag(Relation): pass
class ImagePage(Relation): pass
class TopicWord(Relation): pass
def threadinit(db):
	User.threadinit(db)
	Topic.threadinit(db)
	Page.threadinit(db)
	Tag.threadinit(db)
	Word.threadinit(db)
	Image.threadinit(db)
	UserPage.threadinit(db)
	TopicPage.threadinit(db)
	TopicTag.threadinit(db)
	ImagePage.threadinit(db)
	TopicWord.threadinit(db)<span class="strong"><strong>
def inittable():</strong></span>
	User.inittable(userid="unique not null")
	Topic.inittable(title="unique not null")<span class="strong"><strong>
	Page.inittable(content="",</strong></span>
						modified="not null default CURRENT_TIMESTAMP")
	Tag.inittable(tag="unique not null")
	Word.inittable(word="unique not null")
	Image.inittable(type="",data="blob",title="",
						modified="not null default CURRENT_TIMESTAMP",
						description="")
	UserPage.inittable(User,Page)
	TopicPage.inittable(Topic,Page)
	TopicTag.inittable(Topic,Tag)
	TopicWord.inittable(Topic,Word)
</pre></div><p>Because we can reuse the entity and relation modules we developed earlier, the actual implementation of the database layer is straightforward (full code is available as<code class="literal"> wikidb.py)</code>. After importing both modules, we first define a subclass of<code class="literal"> Entity</code> for each entity we identified in our data model. All these classes are used as is, so they have only a<code class="literal"> pass</code> statement as their body.<a id="id282" class="indexterm"/>
</p><p>Likewise, we define a subclass of<code class="literal"> Relation</code> for each relation we need to implement in our wiki application.</p><p>All these<code class="literal"> Entity</code> and<code class="literal"> Relation</code> subclasses still need the initialization code to be called once each time the application starts and that is where the convenience function<code class="literal"> initdb()</code> comes in. It bundles the initialization code for each entity and relation (highlighted).</p><p>Many entities we define here are simple but a few warrant a closer inspection. The<code class="literal"> Page</code> entity contains a<code class="literal"> modified</code> column that has a<code class="literal"> non null</code> constraint. It also has a default:<code class="literal"> CURRENT_TIMESTAMP</code> (highlighted). This default is SQLite specific (other database engines will have other ways of specifying such a default) and will initialize the modified column to the current date and time if we create a new<code class="literal"> Page</code> record without explicitly setting a value.</p><p>The<code class="literal"> Image</code> entity also has a definition that is a little bit different: its<code class="literal"> data</code> column is explicitly defined to have a<code class="literal"> blob</code> affinity. This will enable us to store binary data without any problem in this table, something we need to store and retrieve the binary data contained in an image. Of course, SQLite will happily store anything we pass it in this column, but if we pass it an array of bytes (not a string that is), that array is stored as is.<a id="id283" class="indexterm"/>
</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="The delivery layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec03"/>The delivery layer</h1></div></div></div><p>With the foundation, that is, the data layer in place, we build on it when we develop the delivery layer. Between the delivery layer and the database layer, there is an additional layer that encapsulates the domain-specific knowledge (that is, it knows how to verify that the title of a new<code class="literal"> Topic</code> entity conforms to the requirements we set for it before it stores it in the database):<a id="id284" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746OS_06_09.jpg" width="156" alt="The delivery layer"/></div><p>Each different layer in our application is implemented in its own file or files. It is easy to get confused, so before we delve further into these files, have a look at the following table. It lists the different files that together make up the wiki application and refers to the names of the layers introduced in<a class="link" href="ch01.html" title="Chapter 1. Choosing Your Tools"> Chapter 1</a>,<span class="emphasis"><em> Choosing Your Tools</em></span> (shown again in the previous image).</p><div class="informaltable"><table border="1"><colgroup><col width="1.175" style="text-align: left"/><col width="1.73854166666667" style="text-align: left"/><col width="2.33218967013889" style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>File</p>
</th><th style="text-align: left" valign="bottom">
<p>Layer</p>
</th><th style="text-align: left" valign="top"> </th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wikiweb.py</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Content Delivery Framework</p>
</td><td style="text-align: left" valign="top">
<p>Our main CherryPy application</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wiki.py</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Object Relational Mapper</p>
</td><td style="text-align: left" valign="top">
<p>The domain specific part; Imported by<code class="literal"> wikiweb.py</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wikidb.py</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Object Relational Mapper</p>
</td><td style="text-align: left" valign="top">
<p>The domain independent part; Imported by<code class="literal"> wikiweb.py</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">basepage.html</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Structural Representation</p>
</td><td style="text-align: left" valign="top">
<p>Used by<code class="literal"> wikiweb.py</code> to serve pages to the client</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wikiweb.js</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Graphical User Interface</p>
</td><td style="text-align: left" valign="top">
<p>Referred to in<code class="literal"> basepage.html</code>; Implements user interaction like mouse clicks.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wiki.css</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Graphical User Interface</p>
</td><td style="text-align: left" valign="top">
<p>Referred to in<code class="literal"> basepage.html</code>; Implements the layout of graphical components.</p>
</td></tr></tbody></table></div><p>We'll focus on the main CherryPy application first to get a feel for the behavior of the application.</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action implementing the opening screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec04"/>Time for action implementing the opening screen</h1></div></div></div><p>The opening screen of the wiki application shows a list of all defined topics on the right and several ways to locate topics on the left. Note that it still looks quite rough because, at this point, we haven't applied any style sheets:<a id="id285" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_06_002.jpg" height="142" alt="Time for action implementing the opening screen"/></div><p>Let us first take a few steps to identify the underlying structure. This structure is what we would like to represent in the HTML markup:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify related pieces of information that are grouped together. These form the backbone of a structured web page. In this case, the search features on the left form a group of elements distinct from the list of topics on the right.</li><li class="listitem" style="list-style-type: disc">Identify distinct pieces of functionality within these larger groups. For example, the elements (input field and search button) that together make up the word search are such a piece of functionality, as are the tag search and the tag cloud.</li><li class="listitem" style="list-style-type: disc">Try to identify any hidden functionality, that is, necessary pieces of information that will have to be part of the HTML markup, but are not directly visible on a page. In our case, we have links to the jQuery and JQuery UI JavaScript libraries and links to CSS style sheets.</li></ul></div><p>Identifying these distinct pieces will not only help to put together HTML markup that reflects the structure of a page, but also help to identify necessary functionality in the delivery layer because each of these functional pieces is concerned with specific information processed and produced by the server.<a id="id286" class="indexterm"/>
</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec02"/>What just happened?</h2></div></div></div><p>Let us look in somewhat more detail at the structure of the opening page that we identified.<a id="id287" class="indexterm"/>
</p><p>Most notable are three search input fields to locate topics based on words occurring in their bodies, based on their actual title or based on tags associated with a topic. These search fields feature auto complete functionality that allows for comma-separated lists. In the same column, there is also room for a tag cloud, an alphabetical list of tags with font sizes dependent on the number of topics marked with that tag.</p></div><div class="section" title="The structural components"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec03"/>The structural components</h2></div></div></div><p>The HTML markup for this opening page is shown next. It is available as the file<code class="literal"> basepage.html</code> and the contents of this file are served by several methods in the<code class="literal"> Wiki</code> class implementing the delivery layer, each with a suitable content segment. Also, some of the content will be filled in by AJAX calls, as we will see in a moment:<a id="id288" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter6/basepage.html</strong></span>
</p><div class="informalexample"><pre class="programlisting">
&lt;html&gt;
	&lt;head&gt;
			&lt;title&gt;Wiki&lt;/title&gt;
			&lt;script
					src=
"http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"
					type="text/javascript"&gt;
			&lt;/script&gt;
			&lt;script
					src=
"http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.3/jquery-ui.min.js"
					type="text/javascript"&gt;
			&lt;/script&gt;
			&lt;link rel="stylesheet"
					href="http://ajax.googleapis.com/ajax/libs/
jqueryui/1.8.3/themes/smoothness/jquery-ui.css"
					type="text/css" media="all" /&gt;
			&lt;link rel="stylesheet" href="http:///wiki.css"
					type="text/css" media="all" /&gt;
	&lt;/head&gt;
	&lt;body&gt;<span class="strong"><strong>
			&lt;div id="navigation"&gt;</strong></span>
					&lt;div class="navitem"&gt;
						&lt;a href="http://./&gt;Wiki Home&lt;/a&gt;
					&lt;/div&gt;
					&lt;div class="navitem"&gt;
						&lt;span class="label"&gt;Search topic&lt;/span&gt;
						&lt;form id="topicsearch"&gt;
								&lt;input type="text" &gt;
								&lt;button type="submit" &gt;Search&lt;/button&gt;
						&lt;/form&gt;
					&lt;/div&gt;
					&lt;div class="navitem"&gt;
						&lt;span class="label"&gt;Search word&lt;/span&gt;
						&lt;form id="wordsearch"&gt;
								&lt;input type="text" &gt;
								&lt;button type="submit" &gt;Search&lt;/button&gt;
						&lt;/form&gt;
					&lt;/div&gt;
					&lt;div class="navitem"&gt;
						&lt;span class="label"&gt;Search tag&lt;/span&gt;
						&lt;form id="tagsearch"&gt;
								&lt;input type="text" &gt;
								&lt;button type="submit" &gt;Search&lt;/button&gt;
						&lt;/form&gt;
					&lt;/div&gt;
					&lt;div class="navitem"&gt;
						&lt;p id="tagcloud"&gt;Tag cloud&lt;/p&gt;
					&lt;/div&gt;
			&lt;/div&gt;<span class="strong"><strong>
			&lt;div id="content"&gt;%s&lt;/div&gt;</strong></span>
			&lt;script src="/wikiweb.js" type="text/javascript"&gt;&lt;/script&gt;
	&lt;/body&gt;
&lt;/html&gt;
</pre></div><p>The<code class="literal">&lt;head&gt;</code> element contains both links to CSS style sheets and<code class="literal">&lt;script&gt;</code> elements that refer to the jQuery libraries. This time, we choose again to retrieve these libraries from a public content delivery network.<a id="id289" class="indexterm"/>
</p><p>The highlighted lines show the top-level<code class="literal">&lt;div&gt;</code> elements that define the structure of the page. In this case, we have identified a navigation part and a content part and this is reflected in the HTML markup.</p><p>Enclosed in the navigation part are the search functions, each in their own<code class="literal">&lt;div&gt;</code> element. The content part contains just an interpolation placeholder<code class="literal"> %s</code> for now, that will be filled in by the method that serves this markup. Just before the end of the body of the markup is a final<code class="literal">&lt;script&gt;</code> element that refers to a JavaScript file that will perform actions specific to our application and we will examine those later.</p></div><div class="section" title="The application methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec04"/>The application methods</h2></div></div></div><p>The markup from the previous section is served by methods of the<code class="literal"> Wiki</code> class, an instance of which class can be mounted as a CherryPy application. The<code class="literal"> index()</code> method, for example, is where we produce the markup for the opening screen (the complete file is available as<code class="literal"> wikiweb.py</code> and contains several other methods that we will examine in the following sections):</p><p>
<span class="strong"><strong>Chapter6/wikiweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def index(self):<span class="strong"><strong>
		item = '&lt;li&gt;&lt;a href="http://show?topic=%s"&gt;%s&lt;/a&gt;&lt;/li&gt;'</strong></span>
		topiclist = "\n".join(
				[item%(t,t)for t in wiki.gettopiclist()])
		content = '&lt;div id="wikihome"&gt;&lt;ul&gt;%s&lt;/ul&gt;&lt;/div&gt;'%(
				topiclist,)
		return basepage % content
</pre></div><p>First, we define the markup for every topic we will display in the main area of the opening page (highlighted). The markup consists of a list item that contains an anchor element that refers to a URL relative to the page showing the opening screen. Using relative URLs allows us to mount the class that implements this part of the application anywhere in the tree that serves the CherryPy application. The<code class="literal"> show()</code> method that will serve this URL takes a topic parameter whose value is interpolated in the next line for each topic that is present in the database.</p><p>The result is joined to a single string that is interpolated into yet another string that encapsulates all the list items we just generated in an unordered list (a<code class="literal">&lt;ul&gt;</code> element in the markup) and this is finally returned as the interpolated content of the<code class="literal"> basepage</code> variable.</p><p>In the definition of the<code class="literal"> index()</code> method, we see a pattern that will be repeated often in the wiki application: methods in the delivery layer, like<code class="literal"> index()</code>, concern themselves with constructing and serving markup to the client and delegate the actual retrieval of information to a module that knows all about the wiki itself. Here the list of topics is produced by the<code class="literal"> wiki.gettopiclist()</code> function, while<code class="literal"> index()</code> converts this information to markup. Separation of these activities helps to keep the code readable and therefore maintainable.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action implementing a wiki topic screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec05"/>Time for action implementing a wiki topic screen</h1></div></div></div><p>When we request a URL of the form<code class="literal"> show?topic=value</code>, this will result in calling the<code class="literal"> show()</code> method. If<code class="literal"> value</code> equals an existing topic, the following (as yet unstyled) screen is the result:<a id="id290" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_06_003.jpg" height="123" alt="Time for action implementing a wiki topic screen"/></div><p>Just as for the opening screen, we take steps to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the main areas on screen</li><li class="listitem" style="list-style-type: disc">Identify specific functionality</li><li class="listitem" style="list-style-type: disc">Identify any hidden functionality</li></ul></div><p>The page structure is very similar to the opening screen, with the same navigational items, but instead of a list of topics, we see the content of the requested topic together with some additional information like the tags associated with this subject and a button that may be clicked to edit the contents of this topic. After all, collaboratively editing content is what a Wiki is all about.<a id="id291" class="indexterm"/>
</p><p>We deliberately made the choice not to refresh the contents of just a part of the opening screen with an AJAX call, but opted instead for a simple link that replaces the whole page. This way, there will be an unambiguous URL in the address bar of the browser that will point at the topic. This allows for easy bookmarking. An AJAX call would have left the URL of the opening screen that is visible in the address bar of the browser unaltered and although there are ways to alleviate this problem, we settle for this simple solution here.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec05"/>What just happened?</h2></div></div></div><p>As the main structure we identified is almost identical to the one for the opening page, the<code class="literal"> show()</code> method will reuse the markup in<code class="literal"> basepage.html</code>.</p><p>
<span class="strong"><strong>Chapter6/wikiweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def show(self,topic):
		topic = topic.capitalize()<span class="strong"><strong>
		currentcontent,tags = wiki.gettopic(topic)</strong></span>
		currentcontent = "".join(wiki.render(currentcontent))
		tags = ['&lt;li&gt;&lt;a href="http://searchtags?tags=%s"&gt;%s&lt;/a&gt;&lt;/li&gt;'%(
										t,t) for t in tags]
		content = '''
		&lt;div&gt;
				&lt;h1&gt;%s&lt;/h1&gt;&lt;a href="edit?topic=%s"&gt;Edit&lt;/a&gt;
		&lt;/div&gt;
		&lt;div id="wikitopic"&gt;%s&lt;/div&gt;
		&lt;div id="wikitags"&gt;&lt;ul&gt;%s&lt;/ul&gt;&lt;/div&gt;
		&lt;div id="revisions"&gt;revisions&lt;/div&gt;
		''' % ( topic, topic, currentcontent,"\n".join(tags))
		return basepage % content
</pre></div><p>The<code class="literal"> show()</code> method delegates most of the work to the<code class="literal"> wiki.gettopic()</code> method (highlighted) that we will examine in the next section and concentrates on creating the markup it will deliver to the client.<code class="literal"> wiki.gettopic()</code> will return a tuple that consists of both the current content of the topic and a list of tags.<a id="id292" class="indexterm"/>
</p><p>Those tags are converted to<code class="literal">&lt;li&gt;</code> elements with anchors that point to the<code class="literal"> searchtags</code> URL. This list of tags provides a simple way for the reader to find related topics with a single click. The<code class="literal"> searchtags</code> URL takes a<code class="literal"> tags</code> argument so a single<code class="literal">&lt;li&gt;</code> element constructed this way may look like this:<code class="literal">&lt;li&gt;&lt;a href="http://searchtags?tags=Python"&gt;Python&lt;/a&gt;&lt;/li&gt;</code>.</p><p>The content and the clickable list of tags are embedded in the markup of the<code class="literal"> basepage</code> together with an anchor that points to the<code class="literal"> edit</code> URL. Later, we will style this anchor to look like a button and when the user clicks it, it will present a page where the content may be edited.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action editing wiki topics"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec06"/>Time for action editing wiki topics</h1></div></div></div><p>In the previous section, we showed how to present the user with the contents of a topic but a wiki is not just about finding topics, but must present the user with a way to edit the content as well. This edit screen is presented in the following screenshot:<a id="id293" class="indexterm"/>
</p><div class="mediaobject"><img src="images/3746_06_004.jpg" height="191" alt="Time for action editing wiki topics"/></div><p>Besides the navigation column on the left, within the edit area, we can point out the following functionality:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Elements to alter the title of the subject.</li><li class="listitem" style="list-style-type: disc">Modify the tags (if any) associated with the topic.</li><li class="listitem" style="list-style-type: disc">A large text area to edit the contents of the topic. On the top of the text area, we see a number of buttons that can be used to insert references to other topics, external links, and images.</li><li class="listitem" style="list-style-type: disc">A<span class="strong"><strong> Save</strong></span> button that will submit the changes to the server.</li></ul></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec06"/>What just happened?</h2></div></div></div><p>The<code class="literal"> edit()</code> method in<code class="literal"> wikiweb.py</code> is responsible for showing the edit screen as well as processing the information entered by the user, once the save button is clicked:<a id="id294" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter6/wikiweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def edit(self,topic,
					content=None,tags=None,originaltopic=None):
	user = self.logon.checkauth(
			logonurl=self.logon.path, returntopage=True)<span class="strong"><strong>
	if content is None :</strong></span>
			currentcontent,tags = wiki.gettopic(topic)
			html = '''
			&lt;div id="editarea"&gt;
					&lt;form id="edittopic" action="edit"
							method="GET"&gt;
							&lt;label for="topic"&gt;&lt;/label&gt;
							&lt;input name="originaltopic"
									type="hidden" value="%s"&gt;
							&lt;input name="topic" type="text"
									value="%s"&gt;
							&lt;div id="buttonbar"&gt;
									&lt;button type="button" 
											id="insertlink"&gt;
											External link
									&lt;/button&gt;
									&lt;button type="button" 
											id="inserttopic"&gt;
											Wiki page
									&lt;/button&gt;
									&lt;button type="button" 
											id="insertimage"&gt;
											Image
									&lt;/button&gt;
							&lt;/div&gt;
							&lt;label for="content"&gt;&lt;/label&gt;
							&lt;textarea name="content"
									cols="72" rows="24" &gt;
									%s
							&lt;/textarea&gt;
							&lt;label for="tags"&gt;&lt;/label&gt;
							&lt;input name="tags" type="text" 
									value="%s"&gt;
							&lt;button type="submit"&gt;Save&lt;/button&gt;
							&lt;button type="button"&gt;Cancel&lt;/button&gt;
							&lt;button type="button"&gt;Preview&lt;/button&gt;
					&lt;/form&gt;
			&lt;/div&gt;
			&lt;div id="previewarea"&gt;preview&lt;/div&gt;
			&lt;div id="imagedialog"&gt;%s&lt;/div&gt;
			&lt;script&gt;
					$("#imagedialog").dialog(
								{autoOpen:false,
								width:600,
								height:600});
			&lt;/script&gt;
			'''%(topic, topic, currentcontent,
								", ".join(tags),
								"".join(self.images()))
			return basepage % html
		else :
			wiki.updatetopic(originaltopic,topic,content,tags)
			raise cherrypy.HTTPRedirect('show?topic='+topic)
</pre></div><p>The first priority of the<code class="literal"> edit()</code> method is to verify that the user is logged in as we want only known users to edit the topics. By setting the<code class="literal"> returntopage</code> parameter to true, the<code class="literal"> checkauth()</code> method will return to this page once the user is authenticated.<a id="id296" class="indexterm"/>
</p><p>The<code class="literal"> edit()</code> method is designed to present the edit screen for a topic as well as to process the result of this editing when the user clicks the<span class="strong"><strong> Save</strong></span> button and therefore takes quite a number of parameters.</p><p>The distinction is made based on the<code class="literal"> content</code> parameter. If this parameter is not present (highlighted), the method will produce the markup to show the various elements in the edit screen. If the content parameter is not equal to<code class="literal"> None</code>, the<code class="literal"> edit()</code> method was called as a result of submitting the content of the form presented in the edit screen, in which case, we delegate the actual update of the content to the<code class="literal"> wiki.updatetopic()</code> method. Finally, we redirect the client to a URL that will show the edited content again in its final form without the editing tools.</p><p>At this point, you may wonder what all this business is about with both a<code class="literal"> topic</code> and an<code class="literal"> originaltopic</code> parameter. In order to allow the user to change the title of the topic while that title is also used to find the topic entity that we are editing, we pass the title of the topic as a hidden variable in the edit form, and use this value to retrieve the original topic entity, a ploy necessary because, at this point, we may have a new title and yet have to find the associated topic that still resides in the database with the old title.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note24"/>Note</h3><p>
<span class="strong"><strong>Cross Site Request Forgery</strong></span>
</p><p>When we process the data sent to the<code class="literal"> edit()</code> function we make sure that only authenticated users submit anything. Unfortunately, this might not be enough if the user is tricked into sending an authenticated request on behalf of someone else. This is called<span class="strong"><strong> Cross Site Request Forgery</strong></span> (CSRF) and although there are ways to prevent this, these methods are out of scope for this example. Security conscious people should read up on these exploits, however, and a good place to start is<a class="ulink" href="http://www.owasp.org/index.php/Main_Page"> http://www.owasp.org/index.php/Main_Page</a> and for Python-specific discussions<a class="ulink" href="http://www.pythonsecurity.org/"> http://www.pythonsecurity.org/</a>.</p></div></div><div class="section" title="Pop quiz"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec07"/>Pop quiz</h2></div></div></div><p>What other attribute of the<code class="literal"> Topic</code> entity could we have passed to retrieve a reference to the topic we are editing?</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Additional functionality"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec07"/>Additional functionality</h1></div></div></div><p>In the opening screen as well as in the pages showing the content of topics and in the editing page, there is a lot of hidden functionality. We already encountered several functions of the<code class="literal"> wiki</code> module and we will examine them in detail in this section together with some JavaScript functionality to enhance the user interface.<a id="id297" class="indexterm"/>
</p></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action selecting an image"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec08"/>Time for action selecting an image</h1></div></div></div><p>On the page that allows us to edit a topic, we have half hidden an important element: the dialog to insert an image. If the insert image button is clicked, a dialog is present, as shown in the following image:</p><div class="mediaobject"><img src="images/3746_06_005.jpg" width="226" alt="Time for action selecting an image"/></div><p>Because a dialog is, in a way, a page of its own, we take the same steps to identify the functional components:<a id="id298" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the main structure</li><li class="listitem" style="list-style-type: disc">Identify specific functional components</li><li class="listitem" style="list-style-type: disc">Identify hidden functionality</li></ul></div><p>The dialog consists of two forms. The top one consists of an input field that can be used to look for images with a given title. It will be augmented with jQuery UI's auto complete functionality.</p><p>The second form gives the user the possibility to upload a new file while the rest of the dialog is filled with any number of images. Clicking on one of the images will close the dialog and insert a reference to that image in the text area of the edit page. It is also possible to close the dialog again without selecting an image by either clicking the small close button on the top-right or by pressing the<span class="emphasis"><em> Escape</em></span> key.</p><div class="section" title="What just happened ?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec08"/>What just happened ?</h2></div></div></div><p>The whole dialog consists of markup that is served by the<code class="literal"> images()</code> method.</p><p>
<span class="strong"><strong>Chapter6/wikiweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def images(self,title=None,description=None,file=None):
		if not file is None:
				data = file.file.read()
				wikidb.Image(title=title,description=description,
						data=data,type=str(file.content_type))
		yield '''
		&lt;div&gt;<span class="strong"><strong>
				&lt;form&gt;</strong></span>
						&lt;label for="title"&gt;select a title&lt;/label&gt;
						&lt;input name="title" type="text"&gt;
						&lt;button type="submit"&gt;Search&lt;/button&gt;
				&lt;/form&gt;
				&lt;form method="post" action="./images"
						enctype="multipart/form-data"&gt;
						&lt;label for="file"&gt;New image&lt;/label&gt;<span class="strong"><strong>
						&lt;input type="file" name="file"&gt;</strong></span>
						&lt;label for="title"&gt;Title&lt;/label&gt;
						&lt;input type="text" name="title"&gt;
						&lt;label for="description"&gt;Description&lt;/label&gt;
						&lt;textarea name="description"
								cols="48" rows="3"&gt;&lt;/textarea&gt;
						&lt;button type="submit"&gt;Upload&lt;/button&gt;
				&lt;/form&gt;
		&lt;/div&gt;
		'''
		yield '&lt;div id="imagelist"&gt;\n'
		for img in self.getimages():
				yield img
			yield '&lt;/div&gt;'
</pre></div><p>There is some trickiness here to understand well: from the<code class="literal"> edit()</code> method, we call this<code class="literal"> images()</code> method to provide the markup that we insert in the page that is delivered to the client requesting the<code class="literal"> edit</code> URL, but because we have decorated the<code class="literal"> images()</code> method with a<code class="literal"> @cherrypy.expose</code> decorator, the<code class="literal"> images()</code> method is visible from the outside and may be requested with the<code class="literal"> images</code> URL. If accessed that way, CherryPy will take care of adding the correct response headers.<a id="id299" class="indexterm"/>
</p><p>Being able to call this method this way is useful in two ways: because the dialog is quite a complex page with many elements, we may check how it looks without being bothered by it being part of a dialog, and we can use it as the target of the form that is part of the images dialog and that allows us to upload new images. As with the<code class="literal"> edit()</code> method, the distinction is again made based on a whether a certain parameter is present. The parameter that serves this purpose is<code class="literal"> file</code> and will contain a<code class="literal"> file</code> object if this method is called in response to an image being submitted (highlighted).</p><p>The<code class="literal"> file</code> object is a<code class="literal"> cherrypy.file</code> object, not a Python built in<code class="literal"> file</code> object, and has several attributes, including an attribute called<code class="literal"> file</code> that is a regular Python stream object. This Python stream object serves as an interface to a temporary file that CherryPy has created to store the uploaded file. We can use the streams<code class="literal"> read()</code> method to get at its content.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note25"/>Note</h3><p>Sorry about all the references to<code class="literal"> file</code>, I agree it is possibly a bit confusing. Read it twice if needed and relax. This summary may be convenient:</p><p>
<span class="strong"><strong>This item has a which is a</strong></span>
</p><p>The<code class="literal"> images()</code> method<code class="literal"> file</code> parameter<code class="literal"> herrypy.file</code> object</p><p>A<code class="literal"> cherrypy.file</code> object<code class="literal"> file</code> attribute Python<code class="literal"> stream</code> object</p><p>A Python<code class="literal"> stream</code> object<code class="literal"> name</code> attribute name of a file on disk</p><p>The Python stream can belong to a number of classes where all implement the same API. Refer to<a class="ulink" href="http://docs.python.org/py3k/library/functions.html#open"> http://docs.python.org/py3k/library/functions.html#open</a> for details on Python streams.</p></div><p>The<code class="literal"> cherrypy.file</code> also has a<code class="literal"> content_type</code> attribute whose string representation we use together with the title and the binary data to create a new<code class="literal"> Image</code> instance.</p><p>The next step is to present the HTML markup that will produce the dialog, possibly including the uploaded image. This markup contains two forms.</p><p>The first one (highlighted in the previous code snippet) consists of an input field and a submit button. The input field will be augmented with auto complete functionality as we will see when we examine<code class="literal"> wikiweb.js</code>. The submit button will replace the selection of images when clicked. This is also implemented in<code class="literal"> wikiweb.js</code> by adding a click handler that will perform an AJAX call to the<code class="literal"> getimages</code> URL.</p><p>The next form is the file upload form. What makes it a file upload form is the<code class="literal">&lt;input&gt;</code> element of the type<code class="literal"> file</code> (highlighted). Behind the scenes, CherryPy will store the contents of a file type<code class="literal">&lt;input&gt;</code> element in a temporary file and pass it to the method servicing the requested URL by submitting the form.<a id="id300" class="indexterm"/>
</p><p>There is a final bit of magic to pay attention to: we insert the markup for the dialog as part of the markup that is served by the<code class="literal"> edit()</code> method, yet the dialog only shows if the user clicks the insert image button. This magic is performed by jQuery UI's dialog widget and we convert the<code class="literal">&lt;div&gt;</code> element containing the dialog's markup by calling its<code class="literal"> dialog</code> method, as shown in this snippet of markup served by the<code class="literal"> edit()</code> method():</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;$("#imagedialog").dialog({autoOpen:false});&lt;/script&gt;
</pre></div><p>By setting the<code class="literal"> autoOpen</code> option to false, we ensure that the dialog remains hidden when the page is loaded, after all, the dialog should only be opened if the user clicks the insert image button.</p><p>Opening the dialog is accomplished by several pieces of JavaScript (full code available as<code class="literal"> wikiweb.js)</code>. The first piece associates a click handler with the insert image button that will pass the<code class="literal"> open</code> option to the dialog, causing it to display itself:</p><p>
<span class="strong"><strong>Chapter6/wikiweb.js</strong></span>
</p><div class="informalexample"><pre class="programlisting">
$("#insertimage").click(function(){
	$("#imagedialog").dialog("open");
});
</pre></div><p>Note that the default action of a dialog is to close itself when the<span class="emphasis"><em> Escape</em></span> key is pressed, so we don't have to do anything about that.</p><p>Within the dialog, we have to configure the images displayed there to insert a reference in the text area when clicked and then close the dialog. We do this by configuring a<code class="literal"> live</code> handler for the<code class="literal"> click</code> event. A<code class="literal"> live</code> handler will apply to elements that match the selector (in this case, images with the<code class="literal"> selectable-image</code> class) even if they are not present yet. This is crucial, as we may upload new images that are not yet present in the list of images shown when the dialog is first loaded:</p><p>
<span class="strong"><strong>Chapter6/wikiweb.js</strong></span>
</p><div class="informalexample"><pre class="programlisting">
$(".selectable-image").live('click',function(){
	$("#imagedialog").dialog("close");
	var insert = "&lt;" + $(this).attr("id").substring(3) + "," + 
$(this).attr("alt") + "&gt;";<span class="strong"><strong>
	var Area = $("#edittopic textarea");</strong></span>
	var area = Area[0];
	var oldposition = Area.getCursorPosition();
var pre = area.value.substring(0, oldposition);
	var post = area.value.substring(oldposition);
	area.value = pre + insert + post;
	Area.focus().setCursorPosition(oldposition + insert.length);
});
</pre></div><p>The first activity of this handler is to close the dialog. The next step is to determine what text we would like to insert into the text area (highlighted). In this case, we have decided to represent a reference to an image within the database as a number followed by a description within angled brackets. For example, image number 42 in the database might be represented as<code class="literal">&lt;42,"Picture of a shovel"&gt;</code>. When we examine the<code class="literal"> render()</code> method in<code class="literal"> wikiweb.py</code>, we will see how we will convert this angled bracket notation to HTML markup.<a id="id301" class="indexterm"/>
</p><p>The remaining part of the function is concerned with inserting this reference into the<code class="literal">&lt;textarea&gt;</code> element. We therefore retrieve the jQuery object that matches our text area first (highlighted) and because such a selection is always an array and we need access to the underlying JavaScript functionality of the<code class="literal">&lt;textarea&gt;</code> element, we fetch the first element.</p><p>The<code class="literal"> value</code> attribute of a<code class="literal">&lt;textarea&gt;</code> element holds the text that is being edited and we split this text into a part before the cursor position and a part after it and then combine it again with our image reference inserted. We then make sure the text area has the focus again (which might have shifted when the user was using the dialog) and position the cursor at a position that is just after the newly inserted text.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action implementing a tag cloud"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec09"/>Time for action implementing a tag cloud</h1></div></div></div><p>One of the distinct pieces of functionality we identified earlier was a so called tag cloud.</p><div class="mediaobject"><img src="images/3746_06_006.jpg" width="189" alt="Time for action implementing a tag cloud"/></div><p>The tag cloud that is present in the navigation section of all pages shows an alphabetically sorted list of tags. The styling of the individual tags represents the relative number of topics that are marked with this tag. Clicking on the tags will show the list of associated topics. In this implementation, we vary just the font size but we could have opted for additional impact by varying the color as well.<a id="id302" class="indexterm"/>
</p><p>Before we implement a tag cloud, we should take a step back and take a good look at what we need to implement:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need to retrieve a list of tags</li><li class="listitem" style="list-style-type: disc">We need to sort them</li><li class="listitem" style="list-style-type: disc">We need to present markup. This markup should contain links that will refer to a suitable URL that will represent a list of topics that are marked with this tag. Also, this markup must in some way indicate what the relative number of topics is that have this tag so it can be styled appropriately.</li></ul></div><p>The last requirement is again a matter of separating structure from representation. It is easier to adapt a specific style by changing a style sheet than to alter structural markup.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec09"/>What just happened?</h2></div></div></div><p>If we look at the HTML that represents an example tag cloud, we notice that the tags are represented by<code class="literal">&lt;span&gt;</code> elements with a<code class="literal"> class</code> attribute that indicates its weight. In this case, we divide the range of weights in five parts, giving us classes from<code class="literal"> weight0</code> for the least important tag to<code class="literal"> weight4</code> for the most important one:<a id="id303" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">
&lt;span class="weight1"&gt;&lt;a href="http://searchtags?tags=Intro"&gt;Intro&lt;/a&gt;&lt;/span&gt;
&lt;span class="weight1"&gt;&lt;a href="http://searchtags?tags=Main"&gt;Main&lt;/a&gt;&lt;/span&gt;
&lt;span class="weight4"&gt;&lt;a href="http://searchtags?tags=Python"&gt;Python&lt;/a&gt;&lt;/
span&gt;
&lt;span class="weight2"&gt;&lt;a href="http://searchtags?tags=Tutorial"&gt;Tutorial&lt;/a&gt;&lt;/
span&gt;
</pre></div><p>The actual font size we use to represent these weights is determined by the styles in<code class="literal"> wiki.css:</code>
</p><div class="informalexample"><pre class="programlisting">
.weight0 { font-size:60%; }
.weight1 { font-size:70%; }
.weight2 { font-size:80%; }
.weight3 { font-size:90%; }
.weight4 { font-size:100%; }
</pre></div><p>The tag cloud itself is delivered by the<code class="literal"> tagcloud()</code> method in<code class="literal"> wikiweb.py</code>.</p><p>
<span class="strong"><strong>Chapter6/wikiweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def tagcloud(self,_=None):
		for tag,weight in wiki.tagcloud():
				yield '''
				&lt;span class="weight%s"&gt;
						&lt;a href="http://searchtags?tags=%s"&gt;%s&lt;/a&gt;
				&lt;/span&gt;'''%(weight,tag,tag)
</pre></div><p>This method iterates over all tuples retrieved from<code class="literal"> wiki.tagcloud()</code> (highlighted). These tuples consist of a weight and a tag name and these are transformed to links and encapsulated in a<code class="literal">&lt;span&gt;</code> element with a fitting<code class="literal"> class</code> attribute:</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def tagcloud():
	tags = sorted([wikidb.Tag(id=t) for t in wikidb.Tag.list()],
							key=attrgetter('tag'))
	totaltopics=0
	tagrank = []
	for t in tags:
		topics = wikidb.TopicTag.list(t)
		if len(topics):
				totaltopics += len(topics)
				tagrank.append((t.tag,len(topics)))
	maxtopics = max(topics for tag,topics in tagrank)
	for tag,topics in tagrank:
		yield tag, int(5.0*topics/(maxtopics+1)) # map to 0 - 4
</pre></div><p>The<code class="literal"> tagcloud()</code> function in<code class="literal"> wiki.py</code> starts off by retrieving a list of all<code class="literal"> Tag</code> objects and sorts them based on their<code class="literal"> tag</code> attribute. Next, it iterates over all these tags and retrieves their associated topics (highlighted). It then checks if there really are topics by checking the length of the list of topics. Some tags may not have any associated topics and are not counted in this ranking operation.<a id="id304" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip07"/>Tip</h3><p>When a tag is removed from a topic, we do not actually delete the tag itself if it no longer has any associated topics. This might lead to a buildup of unused tags and, if necessary, you might want to implement some clean-up scheme.</p></div><p>If a tag does have associated topics, the number of topics is added to the total and a tuple consisting of the tag name and the number of topics is appended to the<code class="literal"> tagrank</code> list. Because our list of<code class="literal"> Tag</code> objects was sorted,<code class="literal"> tagrank</code> will be sorted as well when we have finished counting the topics.</p><p>In order to determine the relative weight of the tags, we iterate again, this time over the<code class="literal"> tagrank</code> list to find the maximum number of topics associated with any tag. Then, in a final iteration, we yield a tuple consisting of the tag name and it relative weight, where the relative weight is computed by dividing the number of topics by the maximum number we encountered (plus one, to prevent divide by zero errors). This weight will then be between zero and one (exclusive) and by multiplying this by 5 and rounding down to an integer, a whole number between 0 and 4 (inclusive) is obtained.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action searching for words"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec10"/>Time for action searching for words</h1></div></div></div><p>To be able to find a list of all topics which contain one or more specific words, we present the user with a search form in the navigation area. These are some of the considerations when designing such a form:<a id="id305" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user must be able to enter more than one word to find topics with all those words in their content</li><li class="listitem" style="list-style-type: disc">Searching should be case insensitive</li><li class="listitem" style="list-style-type: disc">Locating those topics should be fast even if we have a large number of topics with lots of text</li><li class="listitem" style="list-style-type: disc">Auto completion would be helpful to aid the user in specifying words that are actually part of the content of some topic</li></ul></div><p>All these considerations will determine how we will implement the functionality in the delivery layer and on the presentation side.</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec10"/>What just happened?</h2></div></div></div><p>The search options in the navigation area and the tag entry field in the edit screen all feature autocomplete functionality. We encountered autocomplete functionality before in the previous chapter where it was employed to show a list of titles and authors.<a id="id306" class="indexterm"/>
</p><p>With the word and tag search fields in the wiki application, we would like to go one step further. Here we would like to have auto completion on the list of items separated by commas. The illustrations show what happens if we type a single word and what happens when a second word is typed in:</p><div class="mediaobject"><img src="images/3746_06_007.jpg" height="103" alt="What just happened?"/></div><p>We cannot simply send the list of items complete with commas to the server because in that case we could not impose a minimum character limit. It would work for the first word of course, but once the first word is present in the input field, each subsequent character entry would result in a request to the server whereas we would like this to happen when the minimum character count for the second word is reached.</p><p>Fortunately, the jQuery UI website already shows an example of how to use the autocomplete widget in exactly this situation (check the example at<a class="ulink" href="http://jqueryui.com/demos/autocomplete/#multiple-remote)"> http://jqueryui.com/demos/autocomplete/#multiple-remote)</a>. As this online example is fairly well explained in its comments, we will not list it here, but note that the trick lies in the fact that instead of supplying the autocomplete widget with just a source URL, it is also given a callback function that will be invoked instead of retrieving information directly. This callback has access to the string of comma-separated items in the input field and can call the remote source with just the last item in the list.</p><p>On the delivery side, the word search functionality is represented by two methods. The first one is the<code class="literal"> getwords()</code> method in<code class="literal"> wikiweb.py:</code>
</p><p>
<span class="strong"><strong>Chapter6/wikiweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def getwords(self,term,_=None):<span class="strong"><strong>
		term = term.lower()</strong></span>
		return json.dumps(
				[t for t in wikidb.Word.getcolumnvalues('word')
						if t.startswith(term)])
</pre></div><p>
<code class="literal">getwords()</code> will return a list of words that starts with the characters in the<code class="literal"> term</code> argument and returns those as a JSON serialized string for use by the auto completion function that we will add to the input field of the word search form. Words are stored all lowercase in the database. Therefore, the<code class="literal"> term</code> argument is lowercased as well before matching any words (highlighted). Note that the argument to<code class="literal"> json.dumps()</code> is in square brackets to convert the generator returned by the list comprehension to a list. This is necessary because<code class="literal"> json.dumps</code> does not accept generators.<a id="id307" class="indexterm"/>
</p><p>The second method is called<code class="literal"> searchwords()</code>, which will return a list of clickable items consisting of those topics that contain all words passed to it as a string of comma-separated words. The list will be alphabetically sorted on the name of the topic:</p><p>
<span class="strong"><strong>Chapter6/wikiweb.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
@cherrypy.expose
def searchwords(self,words):
		yield '&lt;ul&gt;\n'
		for topic in sorted(wiki.searchwords(words)):
				yield '&lt;li&gt;&lt;a href="http://show?topic=%s"&gt;%s&lt;/a&gt;&lt;/li&gt;'%(
						topic,topic)
		yield '&lt;/ul&gt;\n'
</pre></div><p>Note that the markup returned by<code class="literal"> searchwords()</code> is not a complete HTML page, as it will be called asynchronously when the user clicks the search button and the result will replace the content part.</p><p>Again, the hard work of actually finding the topics that contain the words is not done in the delivery layer, but delegated to the function<code class="literal"> wiki.searchwords():</code>
</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def searchwords(words):
	topics = None
	for word in words.split(','):<span class="strong"><strong>
			word = word.strip('.,:;!? ').lower() # a list with a final 
comma will yield an empty last term</strong></span>
			if word.isalnum():
					w = list(wikidb.Word.list(word=word))
					if len(w):
							ww = wikidb.Word(id=w[0])<span class="strong"><strong>
							wtopic = set( w.a_id for w in wikidb.
TopicWord.list(ww) )</strong></span>
							if topics is None :
									topics = wtopic
							else:
									topics &amp;= wtopic
							if len(topics) == 0 :
									break
if not topics is None:
		for t in topics:
				yield wikidb.Topic(id=t).title
</pre></div><p>This<code class="literal"> searchwords()</code> function starts by splitting the comma-separated items in its<code class="literal"> word</code> argument and sanitizing each item by stripping, leading, and trailing punctuation and whitespace and converting it to lowercase (highlighted).<a id="id308" class="indexterm"/>
</p><p>The next step is to consider only items that consist solely of alphanumeric characters because these are the only ones stored as word entities to prevent pollution by meaningless abbreviations or markup.</p><p>We then check whether the item is present in the database by calling the<code class="literal"> list()</code> method of the<code class="literal"> Word</code> class. This will return either an empty list or a list containing just a single ID. In the latter case, this ID is used to construct a<code class="literal"> Word</code> instance and we use that to retrieve a list of<code class="literal"> Topic</code> IDs associated with this word by calling the<code class="literal"> list()</code> method of the<code class="literal"> TopicWord</code> class (highlighted) and convert it to a set for easy manipulation.</p><p>If this is the first word we are checking, the<code class="literal"> topics</code> variable will contain<code class="literal"> None</code> and we simply assign the set to it. If the<code class="literal"> topic</code> variable already contains a set, we replace the set by the intersection of the stored set and the set of topic IDs associated with the word we are now examining. The intersection of two sets is calculated by the<code class="literal">&amp;</code> operator (in this case, replacing the left-hand side directly, hence the<code class="literal">&amp;=</code> variant). The result of the intersection will be that we have a set of topic IDs of topics that contain all words examined so far.</p><p>If the resulting set contains any IDs at all, these are converted to<code class="literal"> Topic</code> instances to yield their<code class="literal"> title</code> attribute.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="The importance of input validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec11"/>The importance of input validation</h1></div></div></div><p>Anything that is passed as an argument to the methods that service the wiki application, can potentially damage the application. This may sound a bit pessimistic, but remember that when designing an application, you cannot rely on the goodwill of the public, especially when the application is accessible over the Internet and your public may consist of dimwitted search bots or worse.<a id="id309" class="indexterm"/>
</p><p>We may limit the risks by granting the right to edit a page only to people we know by implementing some sort of authentication scheme, but we don't want even these people to mess up the appearance of a topic by inserting all sorts of HTML markup, references to images that do not exist or even malicious snippets of JavaScript. We therefore want to get rid of any unwanted HTML elements present in the content before we store it in the database, a process generally known as<span class="emphasis"><em> scrubbing</em></span>.</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note26"/>Note</h3><p>Preventing Cross-Site Scripting (XSS) (as the inclusion of unwanted code in web pages is called) is covered in depth on this webpage:<a class="ulink" href="http://www.pythonsecurity.org/wiki/cross-sitescripting/"> http://www.pythonsecurity.org/wiki/cross-sitescripting/</a>.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action scrubbing your content"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec12"/>Time for action scrubbing your content</h1></div></div></div><p>Many wikis do not allow any HTML markup at all, but use simpler markup methods to indicate bulleted lists, headers, and so on.<a id="id310" class="indexterm"/>
</p><p>Consider the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Will the user understand some HTML markup or opt for no HTML markup at all?</li><li class="listitem" style="list-style-type: disc">What will the wiki contain? Just text or also external references or references to binary objects (like images) stored in the wiki?</li></ul></div><p>For this wiki, we will implement a mixed approach. We will allow some HTML markup like<code class="literal">&lt;b&gt;</code> and<code class="literal">&lt;ul&gt;</code> but not any links. References to topics in the wiki might be entered as<code class="literal"> [Topic]</code>, whereas links to external pages might be denoted as<code class="literal"> {www.example.org}</code>. Images stored in the wiki may be referred to as<code class="literal">&lt;143&gt;</code>. Each type of reference will take an optional description as well. Example markup, as entered by the user, is shown next:</p><div class="informalexample"><pre class="programlisting">
This topic is tried with a mix of legal and illegal markup.
A &lt;b&gt;list&lt;/b&gt; is fine:
&lt;ul&gt;
&lt;li&gt;One&lt;/li&gt;
&lt;li&gt;Two&lt;/li&gt;
&lt;li&gt;Three&lt;/li&gt;
&lt;/ul&gt;
A link using an html tag referring to a &lt;a href="http://www.example.
com" target="blank"&gt;nasty popup&lt;/a&gt;.
A legal link uses braces {http://www.example.com, "A link"}
</pre></div><p>When viewed, it will look like the following image:</p><div class="mediaobject"><img src="images/3746_06_008.jpg" width="212" alt="Time for action scrubbing your content"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec11"/>What just happened?</h2></div></div></div><p>When we encountered the<code class="literal"> edit()</code> method in<code class="literal"> wikiweb.py</code>, we saw that the actual update of the content of a topic was delegated to the<code class="literal"> updatetopic()</code> function in<code class="literal"> wiki.py</code>, so let's have a look at how this function is organized:<a id="id311" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def updatetopic(originaltopic,topic,content,tags):
	t=list(wikidb.Topic.list(title=originaltopic))
	if len(t) == 0 :
			t=wikidb.Topic(title=topic)
	else:
			t=wikidb.Topic(id=t[0])
			t.update(title=topic)
	content=scrub(content)
	p=wikidb.Page(content=content)
	wikidb.TopicPage(t.id,p.id)
	# update word index
	newwords = set(splitwords(content))
	wordlist = wikidb.TopicWord.list(t)
	topicwords = { wikidb.Word(id=w.b_id).word:w
								for w in wordlist }
	updateitemrelation(t,topicwords,newwords,
			wikidb.Word,'word',wikidb.TopicWord)
	# update tags
	newtags = set(t.capitalize()
								for t in [t.strip()
										for t in tags.split(',')] if 
t.isalnum())
	taglist = wikidb.TopicTag.list(t)
	topictags = { wikidb.Tag(id=t.b_id).tag:t
								for t in taglist }
	updateitemrelation(t,topictags,newtags,
			wikidb.Tag,'tag',wikidb.TopicTag)
</pre></div><p>First it checks whether the topic already exists by retrieving a list of<code class="literal"> Topic</code> objects that have a<code class="literal"> title</code> attribute that matches the<code class="literal"> originaltopic</code> parameter. If this list is empty, it creates a new topic (highlighted), otherwise we update the<code class="literal"> title</code> attribute of the first matching topic found. (See the explanation of the<code class="literal"> edit()</code> method for the rationale behind this).<a id="id312" class="indexterm"/>
</p><p>Then it calls the<code class="literal"> scrub()</code> function to sanitize the content and then creates a new<code class="literal"> Page</code> instance to store this content and associates it with the<code class="literal"> Topic</code> instance<code class="literal"> t</code>. So every time we update the content, we create a new revision and old revisions are still available for comparison.</p><p>The next step is to update the list of words used in the topic. We therefore create a set of unique words by passing the content to the<code class="literal"> splitwords()</code> function (not shown here, available in<code class="literal"> wiki.py)</code> and converting the list of words to a set. Converting a list to a set will remove any duplicate items.</p><p>We convert the set of words to a dictionary with<code class="literal"> Word</code> objects as keys and the words themselves as values and call the<code class="literal"> updateitemrelation()</code> function to perform the update.</p><p>The same scenario is used with any tags associated with the topic. The<code class="literal"> updateitemrelation()</code> function may look intimidating, but that is mainly due to the fact that it is made general enough to deal with any<code class="literal"> Relation</code>, not just one between<code class="literal"> Topic</code> and<code class="literal"> Word</code> or<code class="literal"> Topic</code> and<code class="literal"> Tag</code>. By designing a general function, we have less code to maintain which is good although, in this case, readability may have suffered too much.<a id="id313" class="indexterm"/>
</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def updateitemrelation(p,itemmap,newitems,Entity,attr,Relation):
	olditems = set()
	for item in itemmap:
			if not item in newitems:
					itemmap[item].delete()
			else:
					olditems.add(item)<span class="strong"><strong>
	for item in newitems - olditems:</strong></span>
			if not item in itemmap:
					ilist = list(Entity.list(**{attr:item}))
					if (len(ilist)):
							i = Entity(id=ilist[0])
					else:
							i = Entity(**{attr:item})
					Relation.add(p,i)
</pre></div><p>First we determine if any items currently associated with the primary entity<code class="literal"> p</code> are not in the new list of items. If so, they are deleted, that is, the recorded relation between the primary entity and the item is removed from the database, otherwise we store them in the<code class="literal"> olditems</code> set.</p><p>The next step determines the difference between the<code class="literal"> newitems</code> and<code class="literal"> olditmes</code> (highlighted). The result represents those items that have to be associated with the primary entity, but may not yet be stored in the database. This is determined by using the<code class="literal"> list()</code> method to find any, and if no entity is found, to create one. Finally, we add a new relation between the primary entity and the item</p><p>The<code class="literal"> scrub()</code> method is used to remove any HTML tags from the content that are not explicitly listed as being allowed:</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def scrub(content):<span class="strong"><strong>
	parser = Scrubber(('ul','ol','li','b','i','u','em','code','pre','h1',
'h2','h3','h4'))</strong></span>
	parser.feed(content)
	return "".join(parser.result)
</pre></div><p>For this purpose, it instantiates a<code class="literal"> Scrubber</code> object with a very limited list of allowable tags (highlighted) and feeds the content to its<code class="literal"> feed()</code> method. The result is then found in the result attribute of the<code class="literal"> Scrubber</code> instance:</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
class Scrubber(HTMLParser):
	def __init__(self,allowed_tags=[]):
			super().__init__()
			self.result = []
			self.allowed_tags = set(allowed_tags)
	def handle_starttag(self, tag, attrs):
			if tag in self.allowed_tags:
					self.result.append('&lt;%s %s&gt;'%(tag,
								" ".join('%s="%s"'%a for a in attrs)))
	def handle_endtag(self, tag):
			if tag in self.allowed_tags:
					self.result.append('&lt;/'+tag+'&gt;')
	def handle_data(self,data):
			self.result.append(data)
</pre></div><p>The<code class="literal"> Scrubber</code> class is a subclass of the<code class="literal"> HTMLParser</code> class provided in Python's<code class="literal"> html.parser</code> module. We override suitable methods here to deal with start and end tags and data and ignore the rest (like processing instructions and the like). Both beginning and end tags are only appended to the result if they are present in the list of allowable tags. Regular data (text, that is) is simply appended to the result.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Time for action rendering content"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec13"/>Time for action rendering content</h1></div></div></div><p>We added specific JavaScript functionality to the text area editor to insert references to external websites, other wiki topics, and wiki images in a format that we devised ourselves and that cannot be interpreted as HTML. Now we have to provide code that will convert this notation to something that will be understood by the client.<a id="id314" class="indexterm"/>
</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec12"/>What just happened?</h2></div></div></div><p>Recognizing those items that we have to convert to HTML is mostly done by using regular expressions. We therefore define three regular expressions first, each representing a distinct pattern. Note that we use raw strings here to prevent interpretation of backslashes. Backslashes are meaningful in regular expression, and if we didn't use raw strings, we would have to escape each and every backslash with a backslash, resulting in an unreadable sea of backslashes:</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
topicref = re.compile(r'\[\s*([^,\]]+?)(\s*,\s*([^\]]+))?\s*\]')
linkref = re.compile(r'\{\s*([^,\}]+?)(\s*,\s*([^\}]+))?\s*\}')
imgref = re.compile(r'\&lt;\s*(\d+?)(\s*,\s*([^\&gt;]*))?\s*\&gt;')
</pre></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note27"/>Note</h3><p>For more on Python regular expressions have a look at<a class="ulink" href="http://docs.python.org/py3k/library/re.html"> http://docs.python.org/py3k/library/re.html</a> or check the reading list in the appendix.</p></div><p>Next we define three utility functions, one for each pattern. Each function takes a<code class="literal"> match</code> object that represents a matching pattern and returns a string that can be used in HTML to show or link to that reference:</p><p>
<span class="strong"><strong>Chapter6/wiki.py</strong></span>
</p><div class="informalexample"><pre class="programlisting">
def topicrefreplace(matchobj):
	ref=matchobj.group(1)
	txt=matchobj.group(3) if (not matchobj.group(3)
								is None) else matchobj.group(1)
	nonexist = ""
	if(len(list(wikidb.Topic.list(title=ref)))==0):
			nonexist = " nonexisting"
	return '&lt;a href="http://show?topic=%s" class="topicref%s"&gt;%s&lt;/a&gt;'%(
							ref,nonexist,txt)
def linkrefreplace(matchobj):
	ref=matchobj.group(1)
	txt=matchobj.group(3) if (not matchobj.group(3)
							is None) else matchobj.group(1)
	ref=urlunparse(urlparse(ref,'http'))
	return '&lt;a href="http://%s class="externalref"&gt;%s&lt;/a&gt;'%(ref,txt)
def imgrefreplace(matchobj):
	ref=matchobj.group(1)
	txt=matchobj.group(3) if (not matchobj.group(3)
							is None) else matchobj.group(1)
	return '''&lt;img src="showimage?id=%s" alt="%s"
						class="wikiimage"&gt;'''%(ref,txt)
def render(content):
	yield '&lt;p&gt;\n'
	for line in content.splitlines(True):
			line = re.sub(imgref ,imgrefreplace ,line)
			line = re.sub(topicref,topicrefreplace,line)
			line = re.sub(linkref ,linkrefreplace ,line)<span class="strong"><strong>
			if len(line.strip())==0 : line = '&lt;/p&gt;\n&lt;p&gt;'</strong></span>
			yield line
	yield '&lt;/p&gt;\n'
</pre></div><p>The<code class="literal"> render()</code> function is passed a string with content to convert to HTML. For each line in the content, it tries to find the predefined patterns and converts them by passing the appropriate function to the<code class="literal"> re.sub()</code> method. If a line consists of whitespace only, suitable HTML is produced to end a paragraph (highlighted).</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec14"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about implementing a web application that consists of more than a few entities and their relations.</p><p>Specifically, we covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create a data model that describes entities and relations accurately</li><li class="listitem" style="list-style-type: disc">How to create a delivery layer that is security conscious and treats incoming data with care</li><li class="listitem" style="list-style-type: disc">How to use jQuery UI's dialog widget and extend the functionality of the autocomplete widget</li></ul></div><p>We also encountered some limitations, especially in our entity/relation framework. It is, for example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Quite a lot of work to initialize the database as each entity and relation needs its own initialization code</li><li class="listitem" style="list-style-type: disc">Unwieldy to specify things like sort order when retrieving entities</li><li class="listitem" style="list-style-type: disc">Difficult to check input values or display formats in a uniform way</li><li class="listitem" style="list-style-type: disc">Difficult to differentiate between different types of relations, like one-to-many or many-to-many</li></ul></div><p>This hardly poses a problem for our moderately complex wiki application, but more complex applications can only be built with a more flexible framework which is the topic of the next chapter.</p></div></div>
</body></html>