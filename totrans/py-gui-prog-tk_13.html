<html><head></head><body>
  <div id="_idContainer230">
    <h1 class="chapterNumber">13</h1>
    <h1 id="_idParaDest-348" class="chapterTitle">Connecting to the Cloud</h1>
    <p class="normal">It seems that nearly every application needs to talk to the outside world sooner or later, and your ABQ Data Entry application is no exception. You've received some new feature requests that will require some interactions with remote servers and services.</p>
    <p class="normal">First, the quality assurance division is doing a study of how local weather conditions are impacting the environmental data in each lab; they've requested a way to download and store local weather data in the database on demand. The second request is from your manager, who is still required to upload daily CSV files to the central corporate servers. She would like this process streamlined and available at a mouse click.</p>
    <p class="normal">In this chapter, you will learn to interface with the cloud in the following topics:</p>
    <ul>
      <li class="bullet">In <em class="italic">HTTP using urllib</em>, you'll connect to web services and download data using <code class="Code-In-Text--PACKT-">urllib</code>.</li>
      <li class="bullet">In <em class="italic">RESTful HTTP using requests</em>, you'll learn to interact with REST services using the <code class="Code-In-Text--PACKT-">requests</code> library.</li>
      <li class="bullet">In <em class="italic">SFTP using paramiko</em>, you'll upload files over SSH using <code class="Code-In-Text--PACKT-">paramiko</code>.</li>
    </ul>
    <h1 id="_idParaDest-349" class="title">HTTP using urllib</h1>
    <p class="normal">Every time you open a website in your browser, you're using the Hypertext Transfer Protocol, or HTTP. HTTP was created over 30 years<a id="_idIndexMarker1248"/> ago as a way for web browsers to download HTML documents, but has evolved into one of the most<a id="_idIndexMarker1249"/> popular client-server communication<a id="_idIndexMarker1250"/> protocols for any number of purposes. </p>
    <p class="normal">Not only do we use it in the browser to view everything from plain text to streaming video across the internet, but applications can also use it to transfer data, initiate remote procedures, or distribute computing tasks.</p>
    <h2 id="_idParaDest-350" class="title">HTTP transaction fundamentals</h2>
    <p class="normal">A basic HTTP transaction<a id="_idIndexMarker1251"/> between a client and server goes like this:</p>
    <ol>
      <li class="numbered">First, the client creates a <strong class="keyword">request</strong>, which it will send to the server. The request contains the following:<ul>
          <li class="bullet-l2">A <strong class="keyword">URL</strong>, which specifies the<a id="_idIndexMarker1252"/> host, port, and path to which the request is being<a id="_idIndexMarker1253"/> made.</li>
          <li class="bullet-l2">A <strong class="keyword">method</strong>, also known as a verb, which tells the server what operation the client<a id="_idIndexMarker1254"/> is requesting. The most common<a id="_idIndexMarker1255"/> methods<a id="_idIndexMarker1256"/> are <code class="Code-In-Text--PACKT-">GET</code>, for retrieving data, and <code class="Code-In-Text--PACKT-">POST</code>, for submitting data.</li>
          <li class="bullet-l2">A <strong class="keyword">header</strong>, which includes metadata in key-value<a id="_idIndexMarker1257"/> pairs; for example, the type<a id="_idIndexMarker1258"/> of content being submitted, how the content is encoded, or authorization tokens.</li>
          <li class="bullet-l2">Finally, the request may have a <strong class="keyword">payload</strong>, which would contain the data being submitted<a id="_idIndexMarker1259"/> to a server; for example, a file being uploaded, or a set<a id="_idIndexMarker1260"/> of key-value pairs from a form.</li>
        </ul>
      </li>
      <li class="numbered">When the server receives the request, it returns a <strong class="keyword">response</strong>. The response contains the following:<ul>
          <li class="bullet-l2">A <strong class="keyword">header</strong> containing metadata such as the size<a id="_idIndexMarker1261"/> or content type of the response.</li>
          <li class="bullet-l2">A <strong class="keyword">payload </strong>containing the actual content<a id="_idIndexMarker1262"/> of the response, such as HTML, XML, JSON, or binary data.</li>
        </ul>
      </li>
    </ol>
    <p class="normal">In a web browser, these interactions take place in the background, but our application code will deal directly with request and response objects in order to talk to remote HTTP servers.</p>
    <h3 id="_idParaDest-351" class="title">HTTP status codes</h3>
    <p class="normal">Every HTTP request<a id="_idIndexMarker1263"/> includes a <strong class="keyword">status code</strong> in its header, which is a 3-digit number indicating the disposition<a id="_idIndexMarker1264"/> of the request. The codes, defined in the HTTP standard, are organized as follows:</p>
    <ul>
      <li class="bullet">1XX status codes are informational messages sent during the processing of the request.</li>
      <li class="bullet">2XX status codes indicate a successful request; for example, 200 is the most common response, indicating the request was successful.</li>
      <li class="bullet">3XX status codes indicate a redirection. For example, a 301 is used to redirect the client to a new URL, and 304 indicates that the content hasn't been modified since it was last downloaded (redirecting the client to its cache).</li>
      <li class="bullet">4XX status codes indicate<a id="_idIndexMarker1265"/> an error in the client's request. For example, a 403 error indicates a forbidden request (such as a request to secure documents without authentication), while the well-known 404 error indicates that a non-existent document was requested.</li>
      <li class="bullet">5XX status codes<a id="_idIndexMarker1266"/> indicate an error on the server's side, such as the generic 500 error issued when the server encounters a bug in the web service.</li>
    </ul>
    <p class="normal">While web browser users typically only encounter the 4XX and 5XX errors, you will encounter a few different status codes as you work directly with HTTP through <code class="Code-In-Text--PACKT-">urllib</code>.</p>
    <h2 id="_idParaDest-352" class="title">Basic downloading with urllib.request</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">urllib.request</code> module is a Python module for implementing HTTP interactions. It contains a number of functions<a id="_idIndexMarker1267"/> and classes for generating requests, the most basic of which is the <code class="Code-In-Text--PACKT-">urlopen()</code> function. This function can create a <code class="Code-In-Text--PACKT-">GET</code> or <code class="Code-In-Text--PACKT-">POST</code> request, send it to a remote server, and return an object containing the server's response.</p>
    <p class="normal">Let's explore how <code class="Code-In-Text--PACKT-">urllib</code> works; open a Python shell and execute the following commands:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> urllib.request <span class="hljs-con-keyword">import</span> urlopen
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response = urlopen(<span class="hljs-con-string">'http://python.org'</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">urlopen()</code> function takes, at a minimum, a URL string. By default, it makes a <code class="Code-In-Text--PACKT-">GET</code> request to the URL and returns an object that wraps the response received from the server.</p>
    <p class="normal">This response object exposes metadata or content received from the server, which we can use in our application. Much of the response's metadata is found in the header, which we can extract using its <code class="Code-In-Text--PACKT-">getheader()</code> method, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> response.getheader(<span class="hljs-con-string">'Content-Type'</span>)
'text/html; charset=utf-8'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response.getheader(<span class="hljs-con-string">'Server'</span>)
'nginx'
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">getheader()</code> method requires a key name, and returns the value of that key if it is found in the header. If the key isn't found, it returns <code class="Code-In-Text--PACKT-">None</code>.</p>
    <p class="normal">We can also extract the status<a id="_idIndexMarker1268"/> code and a text explanation of the code using the <code class="Code-In-Text--PACKT-">status</code> and <code class="Code-In-Text--PACKT-">reason</code> attributes, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> response.status
200
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response.reason
'OK'
</code></pre>
    <p class="normal">Remember that a <code class="Code-In-Text--PACKT-">200</code> status means a successful request. The <code class="Code-In-Text--PACKT-">OK</code> string is just a more human-readable form of the status code.</p>
    <p class="normal">The payload of the response object can be retrieved using an interface similar to a file handle; for example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> html = response.read()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> html[:<span class="hljs-con-number">15</span>]
b'&lt;!doctype html&gt;'
</code></pre>
    <p class="normal">Just like a file handle, the response can only be read once, using the <code class="Code-In-Text--PACKT-">read()</code> method; unlike a file handle, it can't be "rewound" using <code class="Code-In-Text--PACKT-">seek()</code>, so it's important to save the response data in another variable if it needs to be accessed more than once. Note that the output of <code class="Code-In-Text--PACKT-">response.read()</code> is a bytes object, which should be cast or decoded into an appropriate object depending on the content downloaded.</p>
    <p class="normal">In this case, we know from the <code class="Code-In-Text--PACKT-">Content-Type</code> header that the content is a UTF-8 string, so we should convert it to <code class="Code-In-Text--PACKT-">str</code> using <code class="Code-In-Text--PACKT-">decode()</code>, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> html.decode(<span class="hljs-con-string">'utf-8'</span>)[:<span class="hljs-con-number">15</span>]
'&lt;!doctype html&gt;'
</code></pre>
    <h3 id="_idParaDest-353" class="title">Generating POST requests</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">urlopen()</code> function<a id="_idIndexMarker1269"/> can also generate <code class="Code-In-Text--PACKT-">POST</code> requests. To do this, we just<a id="_idIndexMarker1270"/> need to include a <code class="Code-In-Text--PACKT-">data</code> argument, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> response = urlopen(<span class="hljs-con-string">'http://duckduckgo.com'</span>, data=<span class="hljs-con-string">b'q=tkinter'</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">data</code> value needs to be a URL-encoded <code class="Code-In-Text--PACKT-">bytes</code> object. A URL-encoded data string consists of key-value pairs separated by ampersand (<code class="Code-In-Text--PACKT-">&amp;</code>) symbols, with certain reserved characters encoded to URL-safe alternatives (for example, the space character is <code class="Code-In-Text--PACKT-">%20</code>, or sometimes just <code class="Code-In-Text--PACKT-">+</code>).</p>
    <p class="normal">A string like this can be created<a id="_idIndexMarker1271"/> by hand, but it's easier to use the <code class="Code-In-Text--PACKT-">urlencode()</code> function<a id="_idIndexMarker1272"/> provided by the <code class="Code-In-Text--PACKT-">urllib.parse</code> module, as demonstrated here:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> urllib.parse <span class="hljs-con-keyword">import</span> urlencode
<span class="hljs-con-meta">&gt;&gt;&gt;</span> url = <span class="hljs-con-string">'http://duckduckgo.com'</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> data = {<span class="hljs-con-string">'q'</span>: <span class="hljs-con-string">'tkinter, python'</span>, <span class="hljs-con-string">'ko'</span>: <span class="hljs-con-string">'-2'</span>, <span class="hljs-con-string">'kz'</span>: <span class="hljs-con-string">'-1'</span>}
<span class="hljs-con-meta">&gt;&gt;&gt;</span> u_data = urlencode(data)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> u_data
'q=tkinter%2C+python&amp;ko=-2&amp;kz=-1'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response = urlopen(url, data=u_data.encode())
</code></pre>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">data</code> argument must be <code class="Code-In-Text--PACKT-">bytes</code>, not a string, so <code class="Code-In-Text--PACKT-">encode()</code> must be called on the URL-encoded string before <code class="Code-In-Text--PACKT-">urlopen()</code> will accept it.</p>
    <h2 id="_idParaDest-354" class="title">Downloading weather data to ABQ Data Entry</h2>
    <p class="normal">Let's try downloading the weather<a id="_idIndexMarker1273"/> data needed for our application. The site we'll be using is <a href="http://weather.gov"><span class="url">http://weather.gov</span></a>, which provides weather data<a id="_idIndexMarker1274"/> within the United States. The actual URL we'll be downloading is <a href="http://w1.weather.gov/xml/current_obs/STATION.xml"><span class="url">https://w1.weather.gov/xml/current_obs/STATION.xml</span></a>, where <code class="Code-In-Text--PACKT-">STATION</code> is replaced by the call-sign of the local weather station. In the case of ABQ, we'll be using <code class="Code-In-Text--PACKT-">KBMG</code>, located in Bloomington, Indiana.</p>
    <p class="normal">The QA team wants you to record the temperature (in degrees Celsius), relative humidity, air pressure (in millibars), and sky conditions (a string, like "overcast" or "fair"). They also need the date and time at which the weather was observed by the station.</p>
    <h3 id="_idParaDest-355" class="title">Creating a weather data model</h3>
    <p class="normal">While it would be simple<a id="_idIndexMarker1275"/> enough to put <code class="Code-In-Text--PACKT-">urlopen()</code> calls in an <code class="Code-In-Text--PACKT-">Application</code> class callback, it's more consistent with our MVC design to wrap our interactions with the weather data service in a model class. Our model class will be responsible for acquiring the weather data from the web service and translating it into a format our other components can use easily.</p>
    <p class="normal">Open the <code class="Code-In-Text--PACKT-">models.py</code> file and let's begin by importing <code class="Code-In-Text--PACKT-">urlopen()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py</span>
<span class="hljs-keyword">from</span> urllib.request <span class="hljs-keyword">import</span> urlopen
</code></pre>
    <p class="normal">Now, at the end of the file, let's start a new model class to wrap our data download:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">WeatherDataModel</span><span class="hljs-class">:</span>
  base_url = <span class="hljs-string">'http://w1.weather.gov/xml/current_obs/{}.xml'</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, station</span><span class="hljs-function">):</span>
    self.url = self.base_url.<span class="hljs-built_in">format</span>(station)
</code></pre>
    <p class="normal">Our initializer will take a <code class="Code-In-Text--PACKT-">station</code> string as an argument and use it with the base URL value to build the download<a id="_idIndexMarker1276"/> URL for the weather data. By making the <code class="Code-In-Text--PACKT-">station</code> value a variable, we can set the station in the user's configuration file, allowing users at other ABQ facilities to use the feature as well.</p>
    <p class="normal">Now, let's begin writing a public method for this class to retrieve the weather data:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside WeatherDataModel</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_weather_data</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    response = urlopen(self.url)
</code></pre>
    <p class="normal">We start the method by sending a GET request to the model's URL and retrieve a response. Note that this may raise an exception (for example, if the site can't be reached for some reason), which code calling this method will need to handle.</p>
    <p class="normal">Assuming things went okay, we just need to parse out the data in this response and put it into a form that the <code class="Code-In-Text--PACKT-">Application</code> class can pass to the SQL model. To determine how we'll handle the response, let's go back to the Python shell and examine the data there:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> url = <span class="hljs-con-string">'http://w1.weather.gov/xml/current_obs/KBMG.xml'</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response = urlopen(url)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(response.read().decode())
  &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
  &lt;?xml-stylesheet href="latest_ob.xsl" type="text/xsl"?&gt;
  &lt;current_observation version="1.0"
  xmlns:xsd=http://www.w3.org/2001/XMLSchema
  xmlns:xsi=http://www.w3.org/2001/XMLSchema-instance
  xsi:noNamespaceSchemaLocation=
    "http://www.weather.gov/view/current_observation.xsd"&gt;
  &lt;credit&gt;NOAA's National Weather Service&lt;/credit&gt;
  &lt;credit_URL&gt;http://weather.gov/&lt;/credit_URL&gt;
....
</code></pre>
    <p class="normal">As the URL indicated, the payload<a id="_idIndexMarker1277"/> of the response is an XML document, most of which we won't need. After some searching, though, you should be able to locate the fields we need, shown here:</p>
    <pre class="programlisting con"><code class="hljs-con">&lt;observation_time_rfc822&gt;
  Tue, 29 Jun 2021 15:53:00 -0400
&lt;/observation_time_rfc822&gt;
&lt;weather&gt;Mostly Cloudy&lt;/weather&gt;
&lt;temp_c&gt;32.8&lt;/temp_c&gt;
&lt;relative_humidity&gt;54&lt;/relative_humidity&gt;
&lt;pressure_mb&gt;1020.0&lt;/pressure_mb&gt;
</code></pre>
    <p class="normal">Good, the data we need is there, so we just need to extract it from the XML string into a format our application can use. Let's take a moment to learn about parsing XML data.</p>
    <h3 id="_idParaDest-356" class="title">Parsing the XML weather data</h3>
    <p class="normal">The Python standard library<a id="_idIndexMarker1278"/> contains an <code class="Code-In-Text--PACKT-">xml</code> package, which consists of several sub-modules for parsing or creating XML data. Of these, the <code class="Code-In-Text--PACKT-">xml.etree.ElementTree</code> sub-module is a simple, lightweight parser that should meet our needs.</p>
    <p class="normal">Let's import <code class="Code-In-Text--PACKT-">ElementTree</code> into our <code class="Code-In-Text--PACKT-">models.py</code> file as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py</span>
<span class="hljs-keyword">from</span> xml.etree <span class="hljs-keyword">import</span> ElementTree
</code></pre>
    <p class="normal">Now, back at the end of our <code class="Code-In-Text--PACKT-">get_weather_data()</code> method, we'll parse the XML data in our response object as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside WeatherDataModel.get_weather_data()</span>
  xmlroot = ElementTree.fromstring(response.read())
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">fromstring()</code> method takes an XML string and returns an <code class="Code-In-Text--PACKT-">Element</code> object. To get at the data we need, we'll first need to understand what an <code class="Code-In-Text--PACKT-">Element</code> object represents, and how to work with it.</p>
    <p class="normal">XML is a hierarchical<a id="_idIndexMarker1279"/> representation of data; an element represents a node in this<a id="_idIndexMarker1280"/> hierarchy. An element begins with a tag, which is a text string inside angle brackets. Each tag has a matching closing tag, which is just the tag with a forward-slash<a id="_idIndexMarker1281"/> prefixed to the tag name.</p>
    <p class="normal">Between the opening<a id="_idIndexMarker1282"/> and closing tags, an element may have other child elements or it may have text. An element can also have attributes, which are key-value pairs placed inside the angle brackets<a id="_idIndexMarker1283"/> of the opening tag, just after the tag name.</p>
    <p class="normal">Take a look at the following example of XML:</p>
    <pre class="programlisting gen"><code class="hljs">&lt;star_system starname="Sol"&gt;
  &lt;planet&gt;Mercury&lt;/planet&gt;
  &lt;planet&gt;Venus&lt;/planet&gt;
  &lt;planet&gt;Earth
    &lt;moon&gt;Luna&lt;/moon&gt;
  &lt;/planet&gt;
  &lt;planet&gt;Mars
    &lt;moon&gt;Phobos&lt;/moon&gt;
    &lt;moon&gt;Deimos&lt;/moon&gt;
  &lt;/planet&gt;
  &lt;dwarf_planet&gt;Ceres&lt;/dwarf_planet&gt;
&lt;/star_system&gt;
</code></pre>
    <p class="normal">This example is an (incomplete) XML description of the solar system. The root element has a tag of <code class="Code-In-Text--PACKT-">&lt;star_system&gt;</code> with an attribute of <code class="Code-In-Text--PACKT-">starname</code>. Under this root element, we have four <code class="Code-In-Text--PACKT-">&lt;planet&gt;</code> elements and a <code class="Code-In-Text--PACKT-">&lt;dwarf_planet&gt;</code> element, each of which contains a text node with the planet's name. Some of the planet nodes also have child <code class="Code-In-Text--PACKT-">&lt;moon&gt;</code> nodes, each containing a text node with the moon's name.</p>
    <p class="normal">Arguably, this data could have been structured differently; for example, planet names could have been in a child <code class="Code-In-Text--PACKT-">&lt;name&gt;</code> node inside the planet elements, or listed as an attribute of the <code class="Code-In-Text--PACKT-">&lt;planet&gt;</code> tag. While XML <em class="italic">syntax</em> is well-defined, the actual <em class="italic">structure</em> of an XML document is up to its creator, so fully parsing XML data requires a knowledge of the way the data is laid out in the document.</p>
    <p class="normal">If you look at the XML weather data that we downloaded in the shell earlier, you'll notice it's a fairly shallow hierarchy. Under the <code class="Code-In-Text--PACKT-">&lt;current_observations&gt;</code> node, there are a number of child elements whose tags represent specific data fields like temperature, humidity, wind chill, and so on.</p>
    <p class="normal">To access and extract these child elements, the <code class="Code-In-Text--PACKT-">Element</code> object offers us the following variety of methods:</p>
    <table id="table001-9" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Returns</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">iter()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">An iterator of all child nodes (recursively)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">find(tag)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">The first element matching the given tag</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">findall(tag)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A list of elements matching the given tag</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">getchildren()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A list of the immediate child nodes</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">iterfind(tag)</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">An iterator of all child nodes matching the given tag (recursive)</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">When we downloaded the XML data<a id="_idIndexMarker1284"/> earlier, we identified five tags containing the data we want to extract from this document: <code class="Code-In-Text--PACKT-">&lt;observation_time_rfc822&gt;</code>, <code class="Code-In-Text--PACKT-">&lt;weather&gt;</code>, <code class="Code-In-Text--PACKT-">&lt;temp_c&gt;</code>, <code class="Code-In-Text--PACKT-">&lt;relative_humidity&gt;</code>, and <code class="Code-In-Text--PACKT-">&lt;pressure_mb&gt;</code>. We'll want our function to return a Python dictionary containing each of these tags as keys.</p>
    <p class="normal">So, inside <code class="Code-In-Text--PACKT-">get_weather_data()</code>, let's create a dictionary containing the tags we want, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  weatherdata = {
    <span class="hljs-string">'observation_time_rfc822'</span>: <span class="hljs-literal">None</span>,
    <span class="hljs-string">'temp_c'</span>: <span class="hljs-literal">None</span>,
    <span class="hljs-string">'relative_humidity'</span>: <span class="hljs-literal">None</span>,
    <span class="hljs-string">'pressure_mb'</span>: <span class="hljs-literal">None</span>,
    <span class="hljs-string">'weather'</span>: <span class="hljs-literal">None</span>
  }
</code></pre>
    <p class="normal">Now, let's get the values from the <code class="Code-In-Text--PACKT-">Element</code> object and add them to the dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">for</span> tag <span class="hljs-keyword">in</span> weatherdata:
    element = xmlroot.find(tag)
    <span class="hljs-keyword">if</span> element <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
      weatherdata[tag] = element.text
  <span class="hljs-keyword">return</span> weatherdata
</code></pre>
    <p class="normal">For each of our tag names, we're going to use the <code class="Code-In-Text--PACKT-">find()</code> method to try to locate the element with a matching tag in <code class="Code-In-Text--PACKT-">xmlroot</code>. This particular XML document does not use duplicate tags (since it would make no sense for a single observation to have multiple times, temperature values, humidity values, and so on), so the first instance of any tag should be the only one. If the tag is matched, we'll get back an <code class="Code-In-Text--PACKT-">Element</code> object of the matched node; if not, we get back <code class="Code-In-Text--PACKT-">None</code>, so we need to make sure <code class="Code-In-Text--PACKT-">element</code> is not <code class="Code-In-Text--PACKT-">None</code> before trying to access its <code class="Code-In-Text--PACKT-">text</code> attribute.</p>
    <p class="normal">Once we've done that for all the tags, we can finish the function by returning the dictionary.</p>
    <p class="normal">You can test this function in the Python shell; from a command line, navigate to the <code class="Code-In-Text--PACKT-">ABQ_Data_Entry</code> directory and start a Python shell. Then enter these commands:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> abq_data_entry.models <span class="hljs-con-keyword">import</span> WeatherDataModel
<span class="hljs-con-meta">&gt;&gt;&gt;</span> wdm = WeatherDataModel(<span class="hljs-con-string">'KBMG'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> wdm.get_weather_data()
{'observation_time_rfc822': 'Mon, 09 Aug 2021 15:53:00 -0400',
'temp_c': '26.1', 'relative_humidity': '74',
'pressure_mb': '1013.7', 'weather': 'Fair'}
</code></pre>
    <p class="normal">You should get back a dictionary<a id="_idIndexMarker1285"/> with the current weather conditions in Bloomington, Indiana.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">You can find the station codes for other cities inside the U.S. at <a href="http://w1.weather.gov/xml/current_obs/"><span class="url">http://w1.weather.gov/xml/current_obs/</span></a>.</p>
    </div>
    <p class="normal">Now that we have our weather data model, we just need to build the table for storing the data and the interface for triggering the operation.</p>
    <h3 id="_idParaDest-357" class="title">Implementing weather data storage</h3>
    <p class="normal">To store our weather data, we'll start by creating a table in the ABQ database to hold the individual observation<a id="_idIndexMarker1286"/> data, then build a <code class="Code-In-Text--PACKT-">SQLModel</code> method to store the retrieved data in it. We don't need to worry about writing code to retrieve data back from the database, since our laboratory's QA team has their own reporting tools that they'll use to access it.</p>
    <h4 class="title">Creating the SQL table</h4>
    <p class="normal">Under the application's <code class="Code-In-Text--PACKT-">sql</code> folder, open<a id="_idIndexMarker1287"/> the <code class="Code-In-Text--PACKT-">create_db.sql</code> file, and add<a id="_idIndexMarker1288"/> a new <code class="Code-In-Text--PACKT-">CREATE TABLE</code> statement as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="code-highlight"><strong class="hljs-comment-slc"># create_db.sql</strong></span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> local_weather (
  datetime <span class="hljs-type">TIMESTAMP</span>(<span class="hljs-number">0</span>) <span class="hljs-keyword">WITH</span> <span class="hljs-type">TIME</span> ZONE <span class="hljs-keyword">PRIMARY</span> KEY,
  temperature <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>),
  rel_hum <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>),
  pressure <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>),
  conditions <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>)
);
</code></pre>
    <p class="normal">In this table, we're using the <code class="Code-In-Text--PACKT-">TIMESTAMP</code> data type on the record as a primary key; there's no point in saving the same timestamped observation twice, so this makes an adequate primary key. The <code class="Code-In-Text--PACKT-">(0)</code> size after the <code class="Code-In-Text--PACKT-">TIMESTAMP</code> data type indicates how many decimal places we need<a id="_idIndexMarker1289"/> for the seconds measurement. Since these measurements<a id="_idIndexMarker1290"/> are taken approximately hourly, and we only need one every four hours or so (when the lab checks are done), we don't need fractions of seconds in our timestamp.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Notice that we're saving the time zone; always store time zone data with timestamps when it's available! It may not seem necessary, especially when your application will be run in a workplace that will never change time zones, but there are many edge cases such as daylight savings time changes, where the lack of a time zone can create major problems.</p>
    </div>
    <p class="normal">Run this <code class="Code-In-Text--PACKT-">CREATE</code> query in your database to build the table, and let's move on to creating our <code class="Code-In-Text--PACKT-">SQLModel</code> method.</p>
    <h4 class="title">Implementing the SQLModel.add_weather_data() method</h4>
    <p class="normal">Over in <code class="Code-In-Text--PACKT-">models.py</code>, let's add<a id="_idIndexMarker1291"/> a new method to the <code class="Code-In-Text--PACKT-">SQLModel</code> class called <code class="Code-In-Text--PACKT-">add_weather_data()</code>, which takes a dictionary<a id="_idIndexMarker1292"/> as its only argument. Start this method by creating an <code class="Code-In-Text--PACKT-">INSERT</code> query as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside SQLModel</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add_weather_data</span><span class="hljs-function">(</span><span class="hljs-params">self, data</span><span class="hljs-function">):</span>
    query = (
      <span class="hljs-string">'INSERT INTO local_weather VALUES '</span>
      <span class="hljs-string">'(%(observation_time_rfc822)s, %(temp_c)s, '</span>
      <span class="hljs-string">'%(relative_humidity)s, %(pressure_mb)s, '</span>
      <span class="hljs-string">'%(weather)s)'</span>
    )
</code></pre>
    <p class="normal">This is a straightforward parameterized <code class="Code-In-Text--PACKT-">INSERT</code> query using variable names that match the dictionary keys which the <code class="Code-In-Text--PACKT-">get_local_weather()</code> function extracts from the XML data. We should only need to pass this query and the <code class="Code-In-Text--PACKT-">data</code> dictionary into our <code class="Code-In-Text--PACKT-">query()</code> method.</p>
    <p class="normal">There is one problem, however; if we get a duplicate timestamp, our query will fail due to a duplicate primary key. We could do another query to check first, but that would be slightly redundant, since PostgreSQL itself checks for duplicate keys before inserting a new row.</p>
    <p class="normal">When it detects such an error, <code class="Code-In-Text--PACKT-">psycopg2</code> raises an <code class="Code-In-Text--PACKT-">IntegrityError</code> exception, so we can just catch this exception and, if it gets raised, do nothing.</p>
    <p class="normal">To do this, we'll wrap our <code class="Code-In-Text--PACKT-">query()</code> call in the <code class="Code-In-Text--PACKT-">try</code>/<code class="Code-In-Text--PACKT-">except</code> block, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">try</span>:
      self.query(query, data)
    <span class="hljs-keyword">except</span> pg.IntegrityError:
      <span class="hljs-comment"># already have weather for this datetime</span>
      <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">Now, our data entry<a id="_idIndexMarker1293"/> staff can call this method as often<a id="_idIndexMarker1294"/> as they wish, but it will only save a record when there is a fresh observation to save.</p>
    <h4 class="title">Updating the SettingsModel class</h4>
    <p class="normal">Before leaving <code class="Code-In-Text--PACKT-">models.py</code>, we will need to add a new<a id="_idIndexMarker1295"/> application setting to store the preferred weather station. Add the following<a id="_idIndexMarker1296"/> new entry in the <code class="Code-In-Text--PACKT-">SettingsModel.fields</code> dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside SettingsModel</span>
  fields = {
    <span class="hljs-comment"># ...</span>
    <span class="code-highlight"><strong class="hljs-string-slc">'weather_station'</strong><strong class="hljs-slc">: {</strong><strong class="hljs-string-slc">'type'</strong><strong class="hljs-slc">: </strong><strong class="hljs-string-slc">'str'</strong><strong class="hljs-slc">, </strong><strong class="hljs-string-slc">'value'</strong><strong class="hljs-slc">: </strong><strong class="hljs-string-slc">'KBMG'</strong><strong class="hljs-slc">}</strong></span>,
  }
</code></pre>
    <p class="normal">We won't add a GUI to change this setting, since users won't need to update it. It'll be up to us, or the system admin at other lab sites, to make sure this is properly set on each workstation by editing the <code class="Code-In-Text--PACKT-">abq_settings.json</code> file.</p>
    <h2 id="_idParaDest-358" class="title">Adding the GUI elements for weather download</h2>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Application</code> object<a id="_idIndexMarker1297"/> now needs to connect the weather download<a id="_idIndexMarker1298"/> method from <code class="Code-In-Text--PACKT-">WeatherDataModel</code> to the database method in <code class="Code-In-Text--PACKT-">SQLModel</code> with an appropriate callback method that the main menu classes can call.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">application.py</code> and start a new method in the <code class="Code-In-Text--PACKT-">Application</code> class called <code class="Code-In-Text--PACKT-">_update_weather_data()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_update_weather_data</span><span class="hljs-function">(</span><span class="hljs-params">self, *_</span><span class="hljs-function">):</span>
    weather_data_model = m.WeatherDataModel(
      self.settings[<span class="hljs-string">'weather_station'</span>].get()
    )
    <span class="hljs-keyword">try</span>:
      weather_data = weather_data_model.get_weather_data()
</code></pre>
    <p class="normal">This method begins by creating a <code class="Code-In-Text--PACKT-">WeatherDataModel</code> instance using the <code class="Code-In-Text--PACKT-">weather_station</code> value pulled from the <code class="Code-In-Text--PACKT-">settings</code> dictionary. Then, it attempts to call <code class="Code-In-Text--PACKT-">get_weather_data()</code> inside a <code class="Code-In-Text--PACKT-">try</code> block.</p>
    <p class="normal">Recall that in an error scenario, <code class="Code-In-Text--PACKT-">urlopen()</code> can raise any number of exceptions, depending on what<a id="_idIndexMarker1299"/> went wrong with the HTTP transaction. There isn't really<a id="_idIndexMarker1300"/> anything the application can do to handle such exceptions other than informing the user and exiting the method. Therefore, we'll catch the generic <code class="Code-In-Text--PACKT-">Exception</code> and display the text in a <code class="Code-In-Text--PACKT-">messagebox</code> dialogbox, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showerror(
        title=<span class="hljs-string">'Error'</span>,
        message=<span class="hljs-string">'Problem retrieving weather data'</span>,
        detail=<span class="hljs-built_in">str</span>(e)
      )
      self.status.<span class="hljs-built_in">set</span>(<span class="hljs-string">'Problem retrieving weather data'</span>)
</code></pre>
    <p class="normal">In the event that <code class="Code-In-Text--PACKT-">get_local_weather()</code> succeeds, we simply need to pass the data on to our model method. We can add this in an <code class="Code-In-Text--PACKT-">else</code> clause:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">else</span>:
      self.data_model.add_weather_data(weather_data)
      time = weather_data[<span class="hljs-string">'observation_time_rfc822'</span>]
      self.status.<span class="hljs-built_in">set</span>(<span class="hljs-string">f"Weather data recorded for </span><span class="hljs-subst">{time}</span><span class="hljs-string">"</span>)
</code></pre>
    <p class="normal">In addition to saving the data, we've notified the user in the status bar that the weather was updated and displayed the timestamp of the update.</p>
    <p class="normal">With the callback method done, let's add it to our callbacks dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, in Application.__init__()</span>
    event_callbacks = {
      <span class="hljs-comment">#...</span>
      <span class="code-highlight"><strong class="hljs-string-slc">'&lt;&lt;UpdateWeatherData&gt;&gt;'</strong><strong class="hljs-slc">: self._update_weather_data</strong></span>
    }
</code></pre>
    <p class="normal">Now we can add a <code class="Code-In-Text--PACKT-">command</code> item for the callback in the main menu. In keeping with the main menu guidelines we learned in <em class="chapterRef">Chapter 10</em>, <em class="italic">Maintaining Cross-Platform Compatibility</em>, we should consider an appropriate sub-menu for the command. On Windows, functionality like this goes in the <code class="Code-In-Text--PACKT-">Tools</code> menu, and since neither the Gnome nor macOS guidelines seem<a id="_idIndexMarker1301"/> to indicate a more appropriate location, we'll implement a <code class="Code-In-Text--PACKT-">Tools</code> menu in the <code class="Code-In-Text--PACKT-">LinuxMainMenu</code> and <code class="Code-In-Text--PACKT-">MacOsMainMenu</code> classes<a id="_idIndexMarker1302"/> to hold this command, just to be consistent.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">mainmenu.py</code>, and starting in the generic menu class, let's add a private method that will add the <code class="Code-In-Text--PACKT-">command</code> item:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside GenericMainMenu</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_add_weather_download</span><span class="hljs-function">(</span><span class="hljs-params">self, menu</span><span class="hljs-function">):</span>
    menu.add_command(
      label=<span class="hljs-string">"Update Weather Data"</span>,
      command=self._event(<span class="hljs-string">'&lt;&lt;UpdateWeatherData&gt;&gt;'</span>)
    )
</code></pre>
    <p class="normal">Now, in each menu class's initializer, we'll create a <code class="Code-In-Text--PACKT-">Tools</code> menu and add the command to it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside GenericMainMenu.__init__()</span>
    <span class="hljs-comment"># Put between the File and Options menus</span>
    self._menus[<span class="hljs-string">'Tools'</span>] = tk.Menu(self, tearoff=<span class="hljs-literal">False</span>)
    self._add_weather_download(self._menus[<span class="hljs-string">'Tools'</span>])
</code></pre>
    <p class="normal">Add this same code to the macOS and Linux menu classes' initializers. In the <code class="Code-In-Text--PACKT-">WindowsMainMenu</code> class's initializer, you only need to add the second line, since the <code class="Code-In-Text--PACKT-">Tools</code> menu already exists. After updating the menus, you can run the application and try the new command from the <code class="Code-In-Text--PACKT-">Tools</code> menu. If all went well, you should see an indication in the status bar as shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="../Images/B17578_13_01.png" alt="Figure 13.1: Success downloading the weather data."/></figure>
    <p class="packt_figref">Figure 13.1: Success downloading the weather data</p>
    <p class="normal">You should also connect<a id="_idIndexMarker1303"/> to the database with your PostgreSQL client<a id="_idIndexMarker1304"/> and check that the table contains some weather data now by executing the following SQL command:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> local_weather;
</code></pre>
    <p class="normal">That SQL statement should return output similar to the following:</p>
    <table id="table002-9" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">datetime</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">temperature</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">rel_hum</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">pressure</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">conditions</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">2021-08-12 18:53:00-05</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">26.10</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">74.00</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">1013.70</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Fair</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">As you've seen, <code class="Code-In-Text--PACKT-">urllib</code> is fairly simple to work with for downloading files from the web; most of the work involves parsing the downloaded file and utilizing it in the application. However, not all web transactions are as simple as a single <code class="Code-In-Text--PACKT-">GET</code> or <code class="Code-In-Text--PACKT-">POST</code> request. In the next section, we'll look at a more powerful tool for HTTP interactions, <code class="Code-In-Text--PACKT-">requests</code>.</p>
    <h1 id="_idParaDest-359" class="title">RESTful HTTP using requests</h1>
    <p class="normal">You've been asked by your<a id="_idIndexMarker1305"/> manager to create a function in your program that will allow<a id="_idIndexMarker1306"/> her to upload a CSV extract of the daily data to ABQ's corporate web services, which uses an authenticated REST API. <strong class="keyword">REST</strong> stands for <strong class="keyword">REpresentational State Transfer</strong> and refers to an approach to web services that is built around advanced HTTP semantics to provide a more code-friendly interface. Services designed around the REST concept are described as <strong class="keyword">RESTful</strong>. Let's take a deeper look at how REST interactions work.</p>
    <h2 id="_idParaDest-360" class="title">Understanding RESTful web services</h2>
    <p class="normal">A RESTful service<a id="_idIndexMarker1307"/> is built around the idea of accessing <strong class="keyword">resources</strong>. A resource is typically a data record or file, though<a id="_idIndexMarker1308"/> it could also be something like a remote<a id="_idIndexMarker1309"/> procedure or hardware interface. We access resources via <strong class="keyword">endpoints</strong>, which are URLs that represent a particular resource.</p>
    <p class="normal">We have seen that web servers typically allow you to fetch data using <code class="Code-In-Text--PACKT-">GET</code> and submit data using <code class="Code-In-Text--PACKT-">POST</code>. REST APIs, however, employ additional HTTP methods like <code class="Code-In-Text--PACKT-">DELETE</code>, <code class="Code-In-Text--PACKT-">PUT</code>, and <code class="Code-In-Text--PACKT-">PATCH</code> to indicate different operations. Depending on which method we use when requesting an endpoint, we can perform different actions on the resource.</p>
    <p class="normal">While implementations of REST services vary, the following table shows the generally-agreed-upon functions of HTTP methods by a typical API:</p>
    <table id="table003-8" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Function</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">GET</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Retrieve a resource</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">HEAD</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Retrieve only metadata (headers) about a resource</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">POST</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Create or update a resource based on the submitted data</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">PUT</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Upload a resource as-is (typically for files)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">PATCH</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Update an existing resource with partial data (rarely implemented)</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">DELETE</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Delete a resource</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">In addition to a more robust set of methods, REST services also exchange data in a way that is more code-friendly. While browser-oriented services accept data in URL-encoded strings and return HTML documents, RESTful services may accept requests and return responses in formats like JSON or XML. In some cases, clients can even request the data format to be returned.</p>
    <p class="normal">It's critical to understand that, while some standards for RESTful services exist, the organization and behavior of REST sites (including their precise responses to different methods) vary widely. In order to interact with a REST API, you will need to consult its specific documentation.</p>
    <h2 id="_idParaDest-361" class="title">The Python requests library</h2>
    <p class="normal">As we saw in the<a id="_idIndexMarker1310"/> first section of this chapter, <code class="Code-In-Text--PACKT-">urllib</code> is fairly simple to use for basic <code class="Code-In-Text--PACKT-">GET</code> and <code class="Code-In-Text--PACKT-">POST</code> requests, and being in the standard library makes it a good choice when that's all we require. However, more complex HTTP interactions involving authentication, file uploads, or additional HTTP methods can be frustrating and complicated using <code class="Code-In-Text--PACKT-">urllib</code> alone. To get this done, we'll turn to the third-party <code class="Code-In-Text--PACKT-">requests</code> library. This library is highly recommended by the Python community for any serious work involving HTTP. As you'll see, <code class="Code-In-Text--PACKT-">requests</code> removes many of the rough edges and outdated<a id="_idIndexMarker1311"/> assumptions left in <code class="Code-In-Text--PACKT-">urllib</code>, providing convenient classes and wrapper functions for more modern HTTP transactions like REST. Complete<a id="_idIndexMarker1312"/> documentation on <code class="Code-In-Text--PACKT-">requests</code> can be found at <a href="https://docs.python-requests.org"><span class="url">https://docs.python-requests.org</span></a>, but the next section will cover most of what you need to know to use it effectively.</p>
    <h3 id="_idParaDest-362" class="title">Installing and using requests</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">requests</code> package<a id="_idIndexMarker1313"/> is written in pure Python, so installing it with <code class="Code-In-Text--PACKT-">pip</code> requires<a id="_idIndexMarker1314"/> no compiling or binary<a id="_idIndexMarker1315"/> downloads. Simply type <code class="Code-In-Text--PACKT-">pip install --user requests</code> in the terminal and it will be added to your system.</p>
    <p class="normal">Let's check out how <code class="Code-In-Text--PACKT-">requests</code> works in the Python shell; open a shell and enter the following:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> requests
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response = requests.request(<span class="hljs-con-string">'GET'</span>, <span class="hljs-con-string">'http://www.alandmoore.com'</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">requests.request()</code> function requires, at a minimum, an HTTP method and a URL. Just like <code class="Code-In-Text--PACKT-">urlopen()</code>, it constructs the appropriate request packet, sends it to the URL, and returns an object representing the server's response. Here, we're making a <code class="Code-In-Text--PACKT-">GET</code> request to this author's website.</p>
    <p class="normal">In addition to the <code class="Code-In-Text--PACKT-">request()</code> function, <code class="Code-In-Text--PACKT-">requests</code> has shortcut functions that correspond to the most common HTTP methods. Thus, the same request can be made as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> response = requests.get(<span class="hljs-con-string">'http://www.alandmoore.com'</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">get()</code> method requires only the URL and performs a <code class="Code-In-Text--PACKT-">GET</code> request. Likewise, the <code class="Code-In-Text--PACKT-">post()</code>, <code class="Code-In-Text--PACKT-">put()</code>, <code class="Code-In-Text--PACKT-">patch()</code>, <code class="Code-In-Text--PACKT-">delete()</code>, and <code class="Code-In-Text--PACKT-">head()</code> functions send requests using the corresponding HTTP method. All of these request functions take additional optional arguments.</p>
    <p class="normal">For example, we can send data with a <code class="Code-In-Text--PACKT-">POST</code> request as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> data = {<span class="hljs-con-string">'q'</span>: <span class="hljs-con-string">'tkinter'</span>, <span class="hljs-con-string">'ko'</span>: <span class="hljs-con-string">'-2'</span>, <span class="hljs-con-string">'kz'</span>: <span class="hljs-con-string">'-1'</span>}
<span class="hljs-con-meta">&gt;&gt;&gt;</span> url = <span class="hljs-con-string">'https://duckduckgo.com'</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response = requests.post(url, data)
</code></pre>
    <p class="normal">Notice that, unlike <code class="Code-In-Text--PACKT-">urlopen()</code>, we can use a Python dictionary directly as a <code class="Code-In-Text--PACKT-">data</code> argument; <code class="Code-In-Text--PACKT-">requests</code> does the job of converting it to the proper URL-encoded <code class="Code-In-Text--PACKT-">bytes</code> object for us.</p>
    <p class="normal">Some of the more common arguments used with request functions are as follows:</p>
    <table id="table004-6" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Argument</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Purpose</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">params</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Like <code class="Code-In-Text--PACKT-">data</code>, but added to the query string rather than the payload</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">json</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">JSON data to include in the payload</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">headers</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A dictionary of header data to use for the request</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">files</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A dictionary of <code class="Code-In-Text--PACKT-">{fieldnames: file_objects}</code> to send as a multipart form data request</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">auth</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Username and password tuple to use for basic HTTP digest authentication</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">auth</code> argument here only works to authenticate against HTTP digest authentication; this is an<a id="_idIndexMarker1316"/> older method of authentication that is implemented<a id="_idIndexMarker1317"/> at the web server level rather<a id="_idIndexMarker1318"/> than in the actual web application, and it's rarely used on modern websites. To work with modern authentication systems, we need to understand the use of sessions.</p>
    <h3 id="_idParaDest-363" class="title">Interacting with authenticated sites using Session</h3>
    <p class="normal">HTTP is a <strong class="keyword">stateless</strong> protocol, meaning that each HTTP request<a id="_idIndexMarker1319"/> stands on its own and is not connected to any<a id="_idIndexMarker1320"/> other requests, even between the same client and server. Although it may seem like<a id="_idIndexMarker1321"/> you are "connected" to your social media or banking<a id="_idIndexMarker1322"/> website when you log in, in reality there is no underlying ongoing connection between you and the server, only a series of unrelated requests and responses.</p>
    <p class="normal">How, then, do such sites manage to keep your interactions secure?</p>
    <p class="normal">On modern sites, this<a id="_idIndexMarker1323"/> is typically done using either a <strong class="keyword">session cookie</strong> or <strong class="keyword">authentication token</strong>. In both of these approaches, when the client authenticates to<a id="_idIndexMarker1324"/> the server, the server returns a piece of data that the client can include with future requests to identify itself as the same entity that successfully authenticated. In this way, both client and server can simulate a stateful connection by associating the requests and responses between them into a session.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The differences between session cookies and authentication tokens are immaterial for us on the client side; just know that both require us to store something from the server after authentication and provide it with each future request.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">requests</code> module makes<a id="_idIndexMarker1325"/> this kind of interaction simple by providing the <code class="Code-In-Text--PACKT-">Session</code> class. A <code class="Code-In-Text--PACKT-">Session</code> object persists settings, cookies, and tokens across multiple requests, allowing you to interact<a id="_idIndexMarker1326"/> with services that<a id="_idIndexMarker1327"/> require authentication or special client settings. To create a <code class="Code-In-Text--PACKT-">Session</code> object, use the <code class="Code-In-Text--PACKT-">requests.session()</code> factory function as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> s = requests.session()
</code></pre>
    <p class="normal">Now, we can call request methods like <code class="Code-In-Text--PACKT-">get()</code>, <code class="Code-In-Text--PACKT-">post()</code>, and others on our <code class="Code-In-Text--PACKT-">Session</code> object, for example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Assume this is a valid authentication service that returns an auth token</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> s.post(<span class="hljs-con-string">'http://example.com/login'</span>, data={<span class="hljs-con-string">'u'</span>: <span class="hljs-con-string">'test'</span>, <span class="hljs-con-string">'p'</span>: <span class="hljs-con-string">'test'</span>})
<span class="hljs-con-comment"># Now we would have an auth token stored in s</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> response = s.get(<span class="hljs-con-string">'http://example.com/protected_content'</span>)
<span class="hljs-con-comment"># Our token cookie would be listed here</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(s.cookies.items())
</code></pre>
    <p class="normal">Token and cookie handling like this happens in the background, without any explicit action from us. Cookies are stored in a <code class="Code-In-Text--PACKT-">CookieJar</code> object in the <code class="Code-In-Text--PACKT-">Session</code> object's <code class="Code-In-Text--PACKT-">cookies</code> property.</p>
    <p class="normal">We can also set configuration options on our <code class="Code-In-Text--PACKT-">Session</code> object that will persist across requests; for example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> s.headers[<span class="hljs-con-string">'User-Agent'</span>] = <span class="hljs-con-string">'Mozilla'</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> s.params[<span class="hljs-con-string">'uid'</span>] = <span class="hljs-con-number">12345</span>
<span class="hljs-con-comment"># will be sent with a user-agent string of "Mozilla"</span>
<span class="hljs-con-comment"># and a parameter of "uid=12345"</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> s.get(<span class="hljs-con-string">'http://example.com'</span>)
</code></pre>
    <p class="normal">In this example, we've set the user-agent string to <code class="Code-In-Text--PACKT-">Mozilla</code>, which will then be used for all requests made from this <code class="Code-In-Text--PACKT-">Session</code> object. We also set a default URL parameter using the <code class="Code-In-Text--PACKT-">params</code> attribute; thus, the actual URL that was requested was <code class="Code-In-Text--PACKT-">http://example.com?uid=12345</code>.</p>
    <h3 id="_idParaDest-364" class="title">The requests.Response object</h3>
    <p class="normal">All the request functions and methods in <code class="Code-In-Text--PACKT-">requests</code> return a <code class="Code-In-Text--PACKT-">Response</code> object. These <code class="Code-In-Text--PACKT-">Response</code> objects<a id="_idIndexMarker1328"/> are not the same as those returned by <code class="Code-In-Text--PACKT-">urlopen()</code>; they contain<a id="_idIndexMarker1329"/> all the same data, but in a slightly different (and generally more convenient) form. In addition, they have some helpful methods that make quick work of translating their contents.</p>
    <p class="normal">For example, the response headers are already translated into a Python dictionary for us, as demonstrated here:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> r = requests.get(<span class="hljs-con-string">'http://python.org'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> r.headers
{'Connection': 'keep-alive', 'Content-Length': '49812',
'Server': 'nginx', 'Content-Type': 'text/html; charset=utf-8',
 <span class="hljs-con-comment"># ... etc</span>
</code></pre>
    <p class="normal">Another difference from <code class="Code-In-Text--PACKT-">urllib</code> is that <code class="Code-In-Text--PACKT-">requests</code> does not automatically raise an exception on HTTP errors. However, the <code class="Code-In-Text--PACKT-">.raise_for_status()</code> response method can be called to do so.</p>
    <p class="normal">For example, let's make a request to a URL that will give an HTTP <code class="Code-In-Text--PACKT-">404</code> error:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> r = requests.get(<span class="hljs-con-string">'http://www.example.com/does-not-exist'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> r.status_code
404
<span class="hljs-con-meta">&gt;&gt;&gt;</span> r.raise_for_status()
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
File "/usr/lib/python3.9/site-packages/requests/models.py", line 935, in
raise_for_status
raise HTTPError(http_error_msg, response=self)
requests.exceptions.HTTPError: 404 Client Error: Not Found for url:
http://www.example.com/does-not-exist
</code></pre>
    <p class="normal">This gives us the option of dealing with HTTP errors using exception handling or more traditional flow control logic if we prefer, or to defer our exception handling to a more convenient moment.</p>
    <h2 id="_idParaDest-365" class="title">Implementing a REST backend</h2>
    <p class="normal">To start implementing<a id="_idIndexMarker1330"/> our interactions with the ABQ corporate REST server, we need to figure out what kind of requests we're going to send. We've been provided with some documentation from the corporate office that describes how to interact with the REST API.</p>
    <p class="normal">The API documentation<a id="_idIndexMarker1331"/> tells us the following things:</p>
    <ul>
      <li class="bullet">Before accessing any other endpoints, we'll need to obtain an authentication token. We do this by submitting a <code class="Code-In-Text--PACKT-">POST</code> request to the <code class="Code-In-Text--PACKT-">/auth</code> endpoint. The payload of the <code class="Code-In-Text--PACKT-">POST</code> request should include <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code> as URL-encoded data. If our credentials fail, we'll get an HTTP 401 error. If we don't have a token, any other requests will fail with an HTTP 403 error.</li>
      <li class="bullet">Once we have a token, we can work with files using the <code class="Code-In-Text--PACKT-">/files</code> endpoint:<ul>
          <li class="bullet-l2">We can upload files using a <code class="Code-In-Text--PACKT-">PUT</code> request. The file is uploaded as multipart form data specified in a parameter called <code class="Code-In-Text--PACKT-">file</code>.</li>
          <li class="bullet-l2">We can retrieve a file by sending a <code class="Code-In-Text--PACKT-">GET</code> request in the form of <code class="Code-In-Text--PACKT-">/files/FILENAME</code>, where <code class="Code-In-Text--PACKT-">FILENAME</code> is the name of the file.</li>
          <li class="bullet-l2">Alternatively, we can retrieve only metadata about a file by sending a <code class="Code-In-Text--PACKT-">HEAD</code> request to <code class="Code-In-Text--PACKT-">/files/FILENAME</code>.</li>
        </ul>
      </li>
      <li class="bullet">All HTTP errors are accompanied by a JSON payload that includes the status code and a message indicating what caused the error.</li>
    </ul>
    <div class="note">
      <p class="Information-Box--PACKT-">An example script, <code class="Code-In-Text--PACKT-">sample_rest_service.py</code>, is included with the example code for this book that replicates the functionality of the ABQ Corporate REST services. To use it, you'll need to install the <code class="Code-In-Text--PACKT-">flask</code> library using the command <code class="Code-In-Text--PACKT-">pip install -u flask</code>, then run the command <code class="Code-In-Text--PACKT-">python sample_rest_service.py</code> at a terminal prompt.</p>
    </div>
    <p class="normal">Once again, in keeping with our MVC design, we're going to implement a model that encapsulates all these interactions. We'll begin in <code class="Code-In-Text--PACKT-">models.py</code> by importing the <code class="Code-In-Text--PACKT-">requests</code> library like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py</span>
<span class="hljs-keyword">import</span> requests
</code></pre>
    <p class="normal">Now, at the end of the file, let's start a new model class, <code class="Code-In-Text--PACKT-">CorporateRestModel</code>, for the REST site:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">CorporateRestModel</span><span class="hljs-class">:</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, base_url</span><span class="hljs-function">):</span>
    self.auth_url = <span class="hljs-string">f'</span><span class="hljs-subst">{base_url}</span><span class="hljs-string">/auth'</span>
    self.files_url = <span class="hljs-string">f'</span><span class="hljs-subst">{base_url}</span><span class="hljs-string">/files'</span>
    self.session = requests.session()
</code></pre>
    <p class="normal">The class initializer takes a <code class="Code-In-Text--PACKT-">base_url</code> argument defining the base URL of the REST service we want to contact. It then uses this URL to construct the endpoint URLs for upload, authentication, and file retrieval. Finally, since we're going to need to store authentication tokens, we create a session object for each method to use.</p>
    <p class="normal">We could have just<a id="_idIndexMarker1332"/> specified the <code class="Code-In-Text--PACKT-">base_url</code> as a class attribute like we did with the <code class="Code-In-Text--PACKT-">WeatherDataModel</code>; however, to enable us to test this class against the test service, or to accommodate the possibility of a change to the corporate servers, we'll store this value in the user's settings so it can be easily swapped out.</p>
    <p class="normal">Before we go on, let's add a setting to our <code class="Code-In-Text--PACKT-">SettingsModel</code> for the REST base URL:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside SettingsModel</span>
  fields = {
    <span class="hljs-comment">#...</span>
    <span class="hljs-string">'abq_rest_url'</span>: {
      <span class="hljs-string">'type'</span>: <span class="hljs-string">'str'</span>,
      <span class="hljs-string">'value'</span>: <span class="hljs-string">'http://localhost:8000'</span>
    }
  }
</code></pre>
    <p class="normal">The default value of <code class="Code-In-Text--PACKT-">http://localhost:8000</code> is the base URL of the example server provided for testing; in production, this setting can be altered by technical support for each user by editing their <code class="Code-In-Text--PACKT-">abq_settings.json</code> file.</p>
    <p class="normal">Now, back in our <code class="Code-In-Text--PACKT-">CorporateRestModel</code> class, we need to implement four methods:</p>
    <ul>
      <li class="bullet">An <code class="Code-In-Text--PACKT-">authenticate()</code> method to send credentials via a <code class="Code-In-Text--PACKT-">POST</code> request to the <code class="Code-In-Text--PACKT-">/auth</code> endpoint.</li>
      <li class="bullet">An <code class="Code-In-Text--PACKT-">upload_file()</code> method to send a file via a <code class="Code-In-Text--PACKT-">PUT</code> request to the <code class="Code-In-Text--PACKT-">/files</code> endpoint.</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">check_file()</code> method to retrieve only metadata from the <code class="Code-In-Text--PACKT-">/files</code> endpoint.</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">get_file()</code> method to download a file from the <code class="Code-In-Text--PACKT-">/files</code> endpoint.</li>
    </ul>
    <p class="normal">Let's get started!</p>
    <h3 id="_idParaDest-366" class="title">The authenticate() method</h3>
    <p class="normal">Since we can't do anything else without<a id="_idIndexMarker1333"/> an authentication token, let's start<a id="_idIndexMarker1334"/> with the <code class="Code-In-Text--PACKT-">authenticate()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside CorporateRestModel</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">authenticate</span><span class="hljs-function">(</span><span class="hljs-params">self, username, password</span><span class="hljs-function">):</span>
    response = self.session.post(
      self.auth_url,
      data={<span class="hljs-string">'username'</span>: username, <span class="hljs-string">'password'</span>: password}
    )
</code></pre>
    <p class="normal">This method will take a username and password and post them to the <code class="Code-In-Text--PACKT-">auth_url</code> using our model's <code class="Code-In-Text--PACKT-">Session</code> object. The session will automatically store the token we receive if we're successful. Recall that the server will return an HTTP 401 error if we provide invalid credentials; we could simply check the status code of the response and return <code class="Code-In-Text--PACKT-">True</code> or <code class="Code-In-Text--PACKT-">False</code> from this method. However, since there are a variety of other ways that a call to a remote HTTP server can fail (for example, a problem on the server might result in a 500 error), it would be better if we could report back to the calling code some more detailed information about the failure. We could do this by calling the <code class="Code-In-Text--PACKT-">Response</code> object's <code class="Code-In-Text--PACKT-">raise_for_status()</code> method to send an <code class="Code-In-Text--PACKT-">HTTPError</code> exception back to the calling code. That might give us an error dialog like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_13_02.png" alt="Figure 13.2: An ugly 401 error"/></figure>
    <p class="packt_figref">Figure 13.2: An ugly 401 error</p>
    <p class="normal">Of course, we can, and should, do a bit better. Most users won't know what an HTTP 401 error means. </p>
    <p class="normal">Remember from the API specification that the server also returns a JSON object with the error<a id="_idIndexMarker1335"/> that contains a more meaningful message about<a id="_idIndexMarker1336"/> the failure. We can write a static method for our model that will handle an <code class="Code-In-Text--PACKT-">HTTPError</code> and convert it to an exception with a more human-friendly message. Add this method to the model:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">  @staticmethod</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_raise_for_status</span><span class="hljs-function">(</span><span class="hljs-params">response</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">try</span>:
      response.raise_for_status()
    <span class="hljs-keyword">except</span> requests.HTTPError:
      <span class="hljs-keyword">raise</span> Exception(response.json().get(<span class="hljs-string">'message'</span>))
</code></pre>
    <p class="normal">This method accepts a <code class="Code-In-Text--PACKT-">Response</code> object, then calls its <code class="Code-In-Text--PACKT-">raise_for_status()</code> method. If the status was a success (200), then nothing will happen and the method returns. If it raises an <code class="Code-In-Text--PACKT-">HTTPError</code>, however, we'll extract the <code class="Code-In-Text--PACKT-">message</code> value from the <code class="Code-In-Text--PACKT-">Response</code> object's JSON payload and raise a new <code class="Code-In-Text--PACKT-">Exception</code> error using that message.</p>
    <p class="normal">Back in <code class="Code-In-Text--PACKT-">authenticate()</code>, let's end the method by passing the response to this static method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside CorporateRestModel.authenticate()</span>
    self._raise_for_status(response)
</code></pre>
    <p class="normal">Now a failed login looks more like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_13_03.png" alt="Figure 13.3: A much nicer failure message"/></figure>
    <p class="packt_figref">Figure 13.3: A much nicer failure message</p>
    <p class="normal">If no exception is raised, we don't need to do anything else. The session has the token and we can proceed to other operations.</p>
    <h3 id="_idParaDest-367" class="title">The upload_file() method</h3>
    <p class="normal">Our next method will implement<a id="_idIndexMarker1337"/> actually uploading a file. Remember from the<a id="_idIndexMarker1338"/> API documentation that this requires a <code class="Code-In-Text--PACKT-">PUT</code> request to the <code class="Code-In-Text--PACKT-">/files</code> endpoint. The method looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">upload_file</span><span class="hljs-function">(</span><span class="hljs-params">self, filepath</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filepath, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> fh:
      files = {<span class="hljs-string">'file'</span>: fh}
      response = self.session.put(
        self.files_url, files=files
      )
    self._raise_for_status(response)
</code></pre>
    <p class="normal">To send a file using <code class="Code-In-Text--PACKT-">requests</code>, we have to actually open it and retrieve a file handle, then place the file handle in a dictionary, which we pass to the request method's <code class="Code-In-Text--PACKT-">files</code> argument. Multiple files can be sent if each one receives a different key in the dictionary; our API only allows one file at a time, however, and it must have a key of <code class="Code-In-Text--PACKT-">file</code>. Once again, we finish the method by checking the response for an error code with our <code class="Code-In-Text--PACKT-">_raise_for_status()</code> method.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Notice we open the file in binary-read mode (<code class="Code-In-Text--PACKT-">rb</code>). The <code class="Code-In-Text--PACKT-">requests</code> documentation recommends this, as it ensures the correct <code class="Code-In-Text--PACKT-">Content-length</code> value will be calculated for the request header.</p>
    </div>
    <h3 id="_idParaDest-368" class="title">The check_file() method</h3>
    <p class="normal">The next method we need is the <code class="Code-In-Text--PACKT-">check_file()</code> method, which will retrieve header information about<a id="_idIndexMarker1339"/> a file on the server without actually downloading<a id="_idIndexMarker1340"/> it. The API documentation tells us that we can get metadata about the file by sending a <code class="Code-In-Text--PACKT-">HEAD</code> request to the <code class="Code-In-Text--PACKT-">files/FILENAME</code> endpoint, where <code class="Code-In-Text--PACKT-">FILENAME</code> is the name of the file we want information about. <code class="Code-In-Text--PACKT-">HEAD</code> requests are useful when dealing with slow connections or large files, as they allow us to find out information about the file (for example, its size or whether it exists or not) without actually downloading the entire file.</p>
    <p class="normal">Let's implement this method like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">check_file</span><span class="hljs-function">(</span><span class="hljs-params">self, filename</span><span class="hljs-function">):</span>
    url = <span class="hljs-string">f"</span><span class="hljs-subst">{self.files_url}</span><span class="hljs-string">/</span><span class="hljs-subst">{filename}</span><span class="hljs-string">"</span>
    response = self.session.head(url)
    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">200</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
    <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">404</span>:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    self._raise_for_status(response)
</code></pre>
    <p class="normal">For our purposes, we are mostly interested in whether files on the server exist or not, so we're going to return a Boolean<a id="_idIndexMarker1341"/> value from this method depending on whether we get a status 200 (success) or 404 (file not found). Of course, other things can go wrong with the request too, so we'll also pass<a id="_idIndexMarker1342"/> the response to our <code class="Code-In-Text--PACKT-">_raise_for_status()</code> method if it has a different status code.</p>
    <h3 id="_idParaDest-369" class="title">The get_file() method</h3>
    <p class="normal">The last method we'll implement<a id="_idIndexMarker1343"/> is the <code class="Code-In-Text--PACKT-">get_file()</code> method, for downloading file data. Add the following<a id="_idIndexMarker1344"/> method to <code class="Code-In-Text--PACKT-">CorporateRestModel</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_file</span><span class="hljs-function">(</span><span class="hljs-params">self, filename</span><span class="hljs-function">):</span>
    <span class="hljs-string">"""Download a file from the server"""</span>
    url = <span class="hljs-string">f"</span><span class="hljs-subst">{self.files_url}</span><span class="hljs-string">/</span><span class="hljs-subst">{filename}</span><span class="hljs-string">"</span>
    response = self.session.get(url)
    self._raise_for_status(response)
    <span class="hljs-keyword">return</span> response.text
</code></pre>
    <p class="normal">Unlike other endpoints in this API, a <code class="Code-In-Text--PACKT-">GET</code> request to the <code class="Code-In-Text--PACKT-">/files</code> endpoint does <em class="italic">not</em> return JSON, but rather the contents of the file. We can retrieve these contents from the <code class="Code-In-Text--PACKT-">Response</code> object's <code class="Code-In-Text--PACKT-">text</code> attribute, which we're returning from the method. It will be up to the code that calls this method to do something suitable with the content returned from the method. We'll do this in our <code class="Code-In-Text--PACKT-">Application</code> class, where we'll save the downloaded content to a file.</p>
    <p class="normal">As our model is now complete, let's head over to the <code class="Code-In-Text--PACKT-">Application</code> class to begin working on the front end.</p>
    <h2 id="_idParaDest-370" class="title">Integrating REST upload into the application</h2>
    <p class="normal">After discussions with your manager, who is responsible for performing the REST upload, you determine that<a id="_idIndexMarker1345"/> the workflow for the REST upload operation<a id="_idIndexMarker1346"/> needs to go something like this:</p>
    <ul>
      <li class="bullet">When a REST upload is run from the GUI, it should first check if there is any data in the database for that day, and abort if there is not. It looks bad on your manager if they upload empty files!</li>
      <li class="bullet">If there is data, it should create a CSV extract of the day's data using the original naming format that was used before the facility went to SQL storage, since this is the filename format expected by ABQ Corporate.</li>
      <li class="bullet">Next, it should prompt<a id="_idIndexMarker1347"/> for authentication credentials for the REST API.</li>
      <li class="bullet">After that, the program should check if a file has already been uploaded for that day's data. If not, go ahead and upload the file.</li>
      <li class="bullet">If there is a file (sometimes she forgets and uploads twice), the program should prompt whether the file should be overwritten or not.</li>
      <li class="bullet">In the event we're not overwriting the file, there should be an option to download the file from the server so it can be manually compared with the data in SQL.</li>
    </ul>
    <p class="normal">Let's begin implementing this code!</p>
    <h3 id="_idParaDest-371" class="title">Creating a CSV extract</h3>
    <p class="normal">Before we can upload anything, we need<a id="_idIndexMarker1348"/> to implement a way to create a CSV extract<a id="_idIndexMarker1349"/> of the daily data. This will be used by more than one function, so we'll implement it as a separate method.</p>
    <p class="normal">Start a new private method in <code class="Code-In-Text--PACKT-">Application</code> called <code class="Code-In-Text--PACKT-">_create_csv_extract()</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_create_csv_extract</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    csvmodel = m.CSVModel()
    records = self.model.get_all_records()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> records:
      <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'No records were found to build a CSV file.'</span>)
    <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> records:
      csvmodel.save_record(record)
    <span class="hljs-keyword">return</span> csvmodel.file
</code></pre>
    <p class="normal">The method begins by creating a new instance of our <code class="Code-In-Text--PACKT-">CSVModel</code> class; even though we're no longer storing our data in the CSV files, we can still use the model to export a CSV file. We are not passing in any arguments, just using the default file path of the file. Next, we call the <code class="Code-In-Text--PACKT-">get_all_records()</code> method of the application's <code class="Code-In-Text--PACKT-">SQLModel</code> instance. Remember that our <code class="Code-In-Text--PACKT-">SQLModel.get_all_records()</code> method returns a list of all records for the current day by default. Since your boss doesn't want to upload empty files, we'll raise an exception if there<a id="_idIndexMarker1350"/> are no records to build a CSV with. Our calling code<a id="_idIndexMarker1351"/> can catch that and display the appropriate warning. If there are records to save, the method iterates through them, saving each one to the CSV, then returns the <code class="Code-In-Text--PACKT-">CSVModel</code> object's <code class="Code-In-Text--PACKT-">file</code> attribute (that is, a <code class="Code-In-Text--PACKT-">Path</code> object pointing to the saved file).</p>
    <h3 id="_idParaDest-372" class="title">Creating the upload callback</h3>
    <p class="normal">Now that we have a way<a id="_idIndexMarker1352"/> to create a CSV extract file, we can write the actual<a id="_idIndexMarker1353"/> callback method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_upload_to_corporate_rest</span><span class="hljs-function">(</span><span class="hljs-params">self, *_</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">try</span>:
      csvfile = self._create_csv_extract()
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showwarning(
        title=<span class="hljs-string">'Error'</span>, message=<span class="hljs-built_in">str</span>(e)
      )
      <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">To begin, we attempt to create a CSV extract file; if we get any exceptions (for example, the "No records" exception we created, or perhaps a database issue) we'll display an error message and exit the method.</p>
    <p class="normal">If we've created a CSV file successfully, our next step is to authenticate to the REST API. To do that, we need to get a username and password from the user. Fortunately, we have the perfect class for this:</p>
    <pre class="programlisting code"><code class="hljs-code">    d = v.LoginDialog(
      self, <span class="hljs-string">'Login to ABQ Corporate REST API'</span>
    )
    <span class="hljs-keyword">if</span> d.result <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:
      username, password = d.result
    <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">LoginDialog</code> class serves us well here. Unlike with our database login, we're not going to run this in an endless loop; if the password is wrong, we will just return from the function and the user can rerun the command if need be. Recall that dialog's <code class="Code-In-Text--PACKT-">result</code> attribute will be <code class="Code-In-Text--PACKT-">None</code> if the user clicks <code class="Code-In-Text--PACKT-">Cancel</code>, so we'll just exit the callback method in that case.</p>
    <p class="normal">Now that we have credentials and a filename, we can try to authenticate to the server:</p>
    <pre class="programlisting code"><code class="hljs-code">    rest_model = m.CorporateRestModel(
      self.settings[<span class="hljs-string">'abq_rest_url'</span>].get()
    )
    <span class="hljs-keyword">try</span>:
      rest_model.authenticate(username, password)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showerror(<span class="hljs-string">'Error authenticating'</span>, <span class="hljs-built_in">str</span>(e))
      <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">We begin by creating a <code class="Code-In-Text--PACKT-">CorporateRestModel</code> instance based on the user's <code class="Code-In-Text--PACKT-">abq_rest_url</code> setting, then passing<a id="_idIndexMarker1354"/> our credentials to its <code class="Code-In-Text--PACKT-">authenticate()</code> method. Recall<a id="_idIndexMarker1355"/> that in the event of an HTTP problem (including invalid credentials), our model will raise an <code class="Code-In-Text--PACKT-">Exception</code> with a human-friendly message, so we can simply display that in a message box and exit the callback.</p>
    <p class="normal">Our next step is to check if a file for today's date already exists on the server. We'll do that using our model's <code class="Code-In-Text--PACKT-">check_file()</code> method, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">try</span>:
      exists = rest_model.check_file(csvfile.name)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showerror(<span class="hljs-string">'Error checking for file'</span>, <span class="hljs-built_in">str</span>(e))
      <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">Remember that <code class="Code-In-Text--PACKT-">check_file()</code> will return a Boolean value indicating if the file exists on the server or not, or it might raise an exception if some other HTTP issue arises. As before, in the event of an error we'll just show a dialog and exit the function.</p>
    <p class="normal">If the file already exists, we need to determine what the user wants to do about it; first, whether they want to just overwrite it, and if not, whether they want to download it. We can do that using some message boxes, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> exists:
      overwrite = messagebox.askyesno(
        <span class="hljs-string">'File exists'</span>,
        <span class="hljs-string">f'The file </span><span class="hljs-subst">{csvfile.name}</span><span class="hljs-string"> already exists on the server, '</span>
        <span class="hljs-string">'do you want to overwrite it?'</span>
      )
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> overwrite:
        download = messagebox.askyesno(
          <span class="hljs-string">'Download file'</span>,
          <span class="hljs-string">'Do you want to download the file to inspect it?'</span>
        )
</code></pre>
    <p class="normal">Remember from <em class="chapterRef">Chapter 7</em>, <em class="italic">Creating Menus with Menu and Tkinter Dialogs</em>, that <code class="Code-In-Text--PACKT-">askyesno()</code> returns a Boolean<a id="_idIndexMarker1356"/> value depending on whether<a id="_idIndexMarker1357"/> the user clicks <strong class="screenText">Yes</strong> or <strong class="screenText">No</strong>. </p>
    <p class="normal">If the user wants to download the file, we can do that using our model, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">        <span class="hljs-keyword">if</span> download:
          filename = filedialog.asksaveasfilename()
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> filename:
            <span class="hljs-keyword">return</span>
          <span class="hljs-keyword">try</span>:
            data = rest_model.get_file(csvfile.name)
          <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            messagebox.showerror(<span class="hljs-string">'Error downloading'</span>, <span class="hljs-built_in">str</span>(e))
            <span class="hljs-keyword">return</span>
          <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">'w'</span>, encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> fh:
            fh.write(data)
          messagebox.showinfo(
            <span class="hljs-string">'Download Complete'</span>, <span class="hljs-string">'Download Complete.'</span>
            )
        <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">Here, we first retrieve the filename the user wants to save the downloaded file to using a <code class="Code-In-Text--PACKT-">filedialog</code> function. If they cancel the dialog, we'll just exit the function doing nothing. Otherwise, we attempt to download the file using our model's <code class="Code-In-Text--PACKT-">get_file()</code> method. As before, if it fails we display the error and exit. If it succeeds, we'll open a new UTF-8 file and save the data to it. Finally, we display a success dialog once the file is written. The final <code class="Code-In-Text--PACKT-">return</code> statement exits the method whether or not the user decides to download the file; since at this point, they've opted not to overwrite the file in either case.</p>
    <p class="normal">If they have opted to overwrite the file, our method continues outside that <code class="Code-In-Text--PACKT-">if</code> block as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">try</span>:
      rest_model.upload_file(csvfile)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showerror(<span class="hljs-string">'Error uploading'</span>, <span class="hljs-built_in">str</span>(e))
    <span class="hljs-keyword">else</span>:
      messagebox.showinfo(
        <span class="hljs-string">'Success'</span>,
        <span class="hljs-string">f'</span><span class="hljs-subst">{csvfile}</span><span class="hljs-string"> successfully uploaded to REST API.'</span>
      )
</code></pre>
    <p class="normal">At this point, if the method has not yet returned due to an error or user selection, we can go ahead and upload<a id="_idIndexMarker1358"/> the file. This is done using our model's <code class="Code-In-Text--PACKT-">upload_file()</code> method. We'll either get a success dialog or an error dialog depending on<a id="_idIndexMarker1359"/> whether the operation succeeds or fails. In either case, our method is finished at this point.</p>
    <h3 id="_idParaDest-373" class="title">Finishing up</h3>
    <p class="normal">The last thing we need to do is add a menu option<a id="_idIndexMarker1360"/> for running the REST upload. First, add the method to the <code class="Code-In-Text--PACKT-">Application</code> class's event callbacks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application.__init__()</span>
    event_callbacks = {
      <span class="hljs-comment">#...</span>
      <span class="hljs-string">'&lt;&lt;UploadToCorporateREST&gt;&gt;'</span>: self._upload_to_corporate_rest,
    }
</code></pre>
    <p class="normal">Finally, let's add the command item to our main menu. We'll start by adding a method to create the REST upload entry in the menu, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside GenericMainMenu</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_add_rest_upload</span><span class="hljs-function">(</span><span class="hljs-params">self, menu</span><span class="hljs-function">):</span>
    menu.add_command(
      label=<span class="hljs-string">"Upload CSV to corporate REST"</span>,
      command=self._event(<span class="hljs-string">'&lt;&lt;UploadToCorporateREST&gt;&gt;'</span>)
    )
</code></pre>
    <p class="normal">Next, we'll need to add a call to this method in the <code class="Code-In-Text--PACKT-">GenericMainMenu</code> class initializer and each of the platform-specific menus; in each case, it should look like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, in each menu class initializer</span>
    <span class="hljs-comment"># after creation of Tools menu</span>
    self._add_rest_upload(self._menus[<span class="hljs-string">'Tools'</span>])
</code></pre>
    <p class="normal">Now, run the application<a id="_idIndexMarker1361"/> and let's try it out. To make it work, you'll need to have at least one record saved in the database, and you'll need to start up the <code class="Code-In-Text--PACKT-">sample_rest_service.py</code> script from the example code.</p>
    <p class="normal">If all goes well, you should get a dialog like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_13_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 13.4: A successful upload to the REST server</p>
    <p class="normal">Your server should also have printed some output to the terminal similar to this:</p>
    <pre class="programlisting con"><code class="hljs-con">127.0.0.1 - - [07/Sep/2021 17:10:27] "POST /auth HTTP/1.1" 200 –
127.0.0.1 - - [07/Sep/2021 17:10:27]
  "HEAD /files/abq_data_record_2021-09-07.csv HTTP/1.1" 200 –
Uploaded abq_data_record_2021-09-07.csv
127.0.0.1 - - [07/Sep/2021 17:10:34] "PUT /files HTTP/1.1" 200 -
</code></pre>
    <p class="normal">Notice the <code class="Code-In-Text--PACKT-">POST</code>, <code class="Code-In-Text--PACKT-">HEAD</code>, and <code class="Code-In-Text--PACKT-">PUT</code> requests, as well as the filename of the CSV file in the payload of <code class="Code-In-Text--PACKT-">PUT</code>.</p>
    <p class="normal">You can also run the upload<a id="_idIndexMarker1362"/> a second time, in which case you should get the dialogs asking if you want to overwrite the file, and then if you want to download it, like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_13_05.png" alt="Figure 13.5: Download dialog"/></figure>
    <p class="packt_figref">Figure 13.5: Download dialog</p>
    <p class="normal">That completes the functionality we needed for this application. Good job!</p>
    <h1 id="_idParaDest-374" class="title">SFTP using paramiko</h1>
    <p class="normal">While custom-written RESTful web APIs may be common with large companies and third-party services, our<a id="_idIndexMarker1363"/> programs are often called upon to<a id="_idIndexMarker1364"/> exchange files or data with servers using standard communication protocols. In the Linux and Unix world, the secure shell or SSH protocol has long been the de-facto standard for communication<a id="_idIndexMarker1365"/> between systems. Most implementations of SSH include SFTP (<strong class="keyword">Secure File Transfer Protocol</strong>), an encrypted replacement for the archaic FTP service.</p>
    <p class="normal">In addition to uploading the CSV extract to the corporate REST service, your manager has to upload a second copy to a remote server using SFTP. The user workflow needs to be the same, though there is a requirement to upload the file into a particular directory on the server. You need to implement this upload in your application just as you did for the REST service.</p>
    <h2 id="_idParaDest-375" class="title">Setting up SSH services for testing</h2>
    <p class="normal">In order to test the SFTP features<a id="_idIndexMarker1366"/> we're going to code in our application, we need to have an SSH server available to us. If you don't have access to a device that runs SSH, you can easily install it on your own workstation, depending on your operating system:</p>
    <ul>
      <li class="bullet">On macOS, SSH is preinstalled but needs to be enabled. You can enable it from the <strong class="screenText">Sharing</strong> page in <strong class="screenText">System Preferences</strong>.</li>
      <li class="bullet">On most Linux distributions, you can find SSH in your package manager as <code class="Code-In-Text--PACKT-">ssh</code>, <code class="Code-In-Text--PACKT-">ssh-server</code>, or <code class="Code-In-Text--PACKT-">openssh</code> if it's not already installed. Most distributions will enable the server by default after installation.</li>
      <li class="bullet">On Windows 10 and above, you can install OpenSSH server using the <strong class="screenText">Optional Features</strong> tool under <strong class="keyword">Settings</strong> | <strong class="keyword">Apps</strong> | <strong class="keyword">Apps &amp; features</strong>. Once installed, start the service by opening the <strong class="screenText">Services</strong> app, selecting <strong class="screenText">OpenSSH</strong> <strong class="screenText">server</strong>, and clicking <strong class="screenText">Start the service</strong>.</li>
    </ul>
    <p class="normal">Once the service<a id="_idIndexMarker1367"/> is installed and running, you can connect to your computer using an SSH client like OpenSSH Client, and log in using a local username and password. You can use your normal user account, but since our application will be creating directories and copying files under the home directory of whatever user you use to connect to SSH, you may also wish to create a test user account for login so that the application does not accidentally overwrite any of your files.</p>
    <h2 id="_idParaDest-376" class="title">Installing and using paramiko</h2>
    <p class="normal">Although the standard library<a id="_idIndexMarker1368"/> offers nothing in the way of SSH<a id="_idIndexMarker1369"/> or SFTP support, the third-party <code class="Code-In-Text--PACKT-">paramiko</code> library provides a full suite of tools for working with both. Install <code class="Code-In-Text--PACKT-">paramiko</code> from PyPI using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip install --user paramiko
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">paramiko</code> is pure Python, so it should not require compilation or additional programs to be installed. You can learn<a id="_idIndexMarker1370"/> more about <code class="Code-In-Text--PACKT-">paramiko</code> on its website, <a href="https://www.paramiko.org"><span class="url">https://www.paramiko.org</span></a>.</p>
    <h3 id="_idParaDest-377" class="title">Using paramiko</h3>
    <p class="normal">The main class we'll work with in <code class="Code-In-Text--PACKT-">paramiko</code> is the <code class="Code-In-Text--PACKT-">SSHClient</code> class, through which we'll connect and interact with remote servers. Open a Python shell and let's create one like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> paramiko
<span class="hljs-con-meta">&gt;&gt;&gt;</span> ssh_client = paramiko.SSHClient()
</code></pre>
    <p class="normal">Before we can connect to any servers with the object, we need to configure its key management policy. As part<a id="_idIndexMarker1371"/> of the secure design of SSH, SSH clients exchange encryption keys with the server the first time they connect; thus, when connecting to a new server for the first time with an SSH client, you'll likely see a message like this:</p>
    <pre class="programlisting con"><code class="hljs-con">The authenticity of host 'myserver (::1)' can't be established.
ED25519 key fingerprint is
  SHA256:fwefogdhFa2Bh6wnbXSGY8WG6nl7SzOw3fxmI8Ii2oVs.
This key is not known by any other names
Are you sure you want to continue connecting (yes/no/[fingerprint])?
</code></pre>
    <p class="normal">If you choose to continue, the server's key (or <strong class="keyword">fingerprint</strong>) will be stored with the hostname<a id="_idIndexMarker1372"/> in a file usually called <code class="Code-In-Text--PACKT-">known_hosts</code>. When connecting to the server again, SSH consults the known hosts list to verify that we're connecting to the same server. If the keys differ, the connection will fail.</p>
    <p class="normal">So, the first thing we need to do is load any available key store that we have; if your SSH keys are stored in a standard location, calling the <code class="Code-In-Text--PACKT-">load_system_host_keys()</code> method will suffice:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ssh_client.load_system_host_keys()
</code></pre>
    <p class="normal">You can also specify a known hosts file explicitly using the <code class="Code-In-Text--PACKT-">load_host_keys()</code> method, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ssh.load_host_keys(<span class="hljs-con-string">'/home/alanm/.ssh/known_hosts2'</span>)
</code></pre>
    <p class="normal">A prompt for adding an unknown host to the known hosts list may be OK for an interactive client, but within a programming library it is obviously not so practical. Instead, we need to set a policy of what the <code class="Code-In-Text--PACKT-">SSHClient</code> object will do when we try to connect to an unknown host. By default, it will simply fail, but we can force it to automatically trust new hosts using the <code class="Code-In-Text--PACKT-">set_missing_host_key_policy()</code>, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
</code></pre>
    <p class="normal">Here we've set the policy to an instance of <code class="Code-In-Text--PACKT-">AutoAddPolicy</code>, which means any new host keys will automatically be trusted. <code class="Code-In-Text--PACKT-">paramiko</code> also provides a <code class="Code-In-Text--PACKT-">RejectPolicy</code> class (which is the default) that automatically rejects all new keys, and for advanced use cases we can define our own policy class for more nuanced behaviors. We're using <code class="Code-In-Text--PACKT-">AutoAddPolicy</code> for convenience in this case; in a real-world, secure environment you should leave the default <code class="Code-In-Text--PACKT-">RejectPolicy</code> setting and manage the <code class="Code-In-Text--PACKT-">known_hosts</code> list outside the script.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">You can add servers to your <code class="Code-In-Text--PACKT-">known_hosts</code> file simply by logging into them using <strong class="keyword">OpenSSH</strong> Client and choosing <code class="Code-In-Text--PACKT-">yes</code> when prompted to add the key, or by retrieving the key using the <code class="Code-In-Text--PACKT-">ssh-keyscan</code> command included with OpenSSH Client and adding them to the file manually.</p>
    </div>
    <p class="normal">Once we've settled the issue of key management, we can connect to a host. This is done using the <code class="Code-In-Text--PACKT-">connect()</code> method, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> ssh_client.connect(<span class="hljs-con-string">'localhost'</span>, username=<span class="hljs-con-string">'test'</span>, password=<span class="hljs-con-string">'test'</span>)
</code></pre>
    <p class="normal">In addition to taking<a id="_idIndexMarker1373"/> a hostname or IP address as a positional argument, <code class="Code-In-Text--PACKT-">connect()</code> accepts a number of keyword arguments, including:</p>
    <table id="table005-4" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Argument</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Default</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">username</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Local username</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Username to use for authentication.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">password</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">None</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Password for authentication. If blank, <code class="Code-In-Text--PACKT-">SSHClient</code> will attempt key-based authentication.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">port</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">22</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">TCP port to connect to.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">pkey</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">None</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A private key string to use for authentication.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">key_file</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">None</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A file containing private keys or certificates for authentication.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">compress</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">False</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Enable or disable compression of transmitted data.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">timeout</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">None</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">A timeout in seconds before giving up on the connection.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h3 id="_idParaDest-378" class="title">Inspecting our connection</h3>
    <p class="normal">Once connected to a server, our code might need to get some information about the connection. This can be done<a id="_idIndexMarker1374"/> by accessing the <code class="Code-In-Text--PACKT-">Transport</code> object associated with the client. This object represents the connection and contains a number of methods and attributes to set or retrieve information about it.</p>
    <p class="normal">We can retrieve the <code class="Code-In-Text--PACKT-">Transport</code> object using the <code class="Code-In-Text--PACKT-">get_transport()</code> method of the <code class="Code-In-Text--PACKT-">SSHClient</code>, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> transport = ssh_client.get_transport()
</code></pre>
    <p class="normal">Now we can inspect our connection in various ways, for example:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># See if the connection is still active</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span>  transport.is_active()
True
<span class="hljs-con-comment"># See our remote username</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> transport.get_username()
'alanm'
<span class="hljs-con-comment"># See if we're authenticated</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> transport.is_authenticated()
True
<span class="hljs-con-comment"># Get the name or IP of the connected server</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> transport.getpeername()
('::1', 22, 0, 0)
<span class="hljs-con-comment"># Get the compression used by the server</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> transport.remote_compression
'none'
</code></pre>
    <p class="normal">These properties can be particularly useful in situations where the user is connecting using default values detected from the environment.</p>
    <h3 id="_idParaDest-379" class="title">Using SFTP</h3>
    <p class="normal">Now that we've established<a id="_idIndexMarker1375"/> an SSH connection to a server, we can begin using SFTP. To do this, we'll create an instance of <code class="Code-In-Text--PACKT-">SFTPClient</code> using the <code class="Code-In-Text--PACKT-">open_sftp()</code> method, like so:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> sftp_client = ssh_client.open_sftp()
</code></pre>
    <p class="normal">We can use the methods of the <code class="Code-In-Text--PACKT-">SFTPClient</code> object to execute various file management commands on the remote server over SFTP. Some of the more useful of these are shown in the following table:</p>
    <table id="table006-3" class="No-Table-Style">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Method</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Arguments</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Description</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">chdir()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">path</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Set the current working directory.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">getcwd()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">None</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Return the path of the current working directory. Note that it returns <code class="Code-In-Text--PACKT-">None</code> if the directory was not set with <code class="Code-In-Text--PACKT-">chdir()</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">listdir()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">path</code> (optional)</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Return a list of the files and directories in <code class="Code-In-Text--PACKT-">path</code>, or in the current working directory if not specified.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">mkdir()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">path</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Create a directory on the server at <code class="Code-In-Text--PACKT-">path</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">rmdir()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">path</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Remove the directory from the server described by <code class="Code-In-Text--PACKT-">path</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">get()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">remotepath</code>, <code class="Code-In-Text--PACKT-">localpath</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Download the file on the server at <code class="Code-In-Text--PACKT-">remotepath</code> and save it to the client at <code class="Code-In-Text--PACKT-">localpath</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">put()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">localpath</code>, <code class="Code-In-Text--PACKT-">remotepath</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Upload the file on the client at <code class="Code-In-Text--PACKT-">localpath</code> and save it on the server at <code class="Code-In-Text--PACKT-">remotepath</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">stat()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">path</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Return an object containing information about the file or directory at <code class="Code-In-Text--PACKT-">path</code>.</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">remove()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">path</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Remove the file from the server described by <code class="Code-In-Text--PACKT-">path</code>. Does not work if <code class="Code-In-Text--PACKT-">path</code> is a directory (use <code class="Code-In-Text--PACKT-">rmdir()</code> instead).</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">close()</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">None</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Close the SFTP connection.</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">For example, suppose we need to create a folder called <code class="Code-In-Text--PACKT-">Bananas</code> in the <code class="Code-In-Text--PACKT-">Fruit</code> directory on our server, and<a id="_idIndexMarker1376"/> upload a file called <code class="Code-In-Text--PACKT-">cavendish.ban</code> from <code class="Code-In-Text--PACKT-">/home/alanm/bananas/</code> to the new directory on the server. That exchange would look like this:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> sftp_client.chdir(<span class="hljs-con-string">'Fruit'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sftp_client.mkdir(<span class="hljs-con-string">'Bananas'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> sftp_client.put(<span class="hljs-con-string">'/home/alanm/bananas/cavendish.ban'</span>, <span class="hljs-con-string">'Bananas/cavendish.ban'</span>)
</code></pre>
    <p class="normal">Notice that, in the destination path of the <code class="Code-In-Text--PACKT-">put()</code> call, we did not include the <code class="Code-In-Text--PACKT-">Fruit</code> directory. That's because it's our current working directory, so our remote paths are understood to be relative to it.</p>
    <p class="normal">Let's see if we can use our understanding of <code class="Code-In-Text--PACKT-">paramiko</code> and SFTP to implement an SFTP upload in ABQ Data Entry.</p>
    <h2 id="_idParaDest-380" class="title">Implementing an SFTP model</h2>
    <p class="normal">As we did with our REST upload, we'll begin<a id="_idIndexMarker1377"/> by encapsulating our interactions with the SFTP server in a model class.</p>
    <p class="normal">Open <code class="Code-In-Text--PACKT-">models.py</code> and we'll begin by importing <code class="Code-In-Text--PACKT-">paramiko</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py</span>
<span class="hljs-keyword">import</span> paramiko
</code></pre>
    <p class="normal">Now, let's begin our model class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">SFTPModel</span><span class="hljs-class">:</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, host, port=</span><span class="hljs-number">22</span><span class="hljs-function">):</span>
    self.host = host
    self.port = port
</code></pre>
    <p class="normal">Our class initializer will take a hostname for the server and optionally a port number. SSH typically runs<a id="_idIndexMarker1378"/> on port <code class="Code-In-Text--PACKT-">22</code>, though it's not uncommon for system administrators to run it on another port for security reasons, so it's good to provide this as an option.</p>
    <p class="normal">Next, we'll continue our initializer by configuring our <code class="Code-In-Text--PACKT-">SSHClient</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code">    self._client = paramiko.SSHClient()
    self._client.set_missing_host_key_policy(
      paramiko.AutoAddPolicy()
    )
    self._client.load_system_host_keys()
</code></pre>
    <p class="normal">After creating our client instance and saving it to an instance property, we're configuring it to automatically add new host keys. Finally, we load in the known hosts from the default system location.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">In a secure production environment, you may want to leave this policy at the default <code class="Code-In-Text--PACKT-">RestrictPolicy</code> setting and manage the known hosts list outside of your application. Note, however, that the <code class="Code-In-Text--PACKT-">AutoAddPolicy</code> only impacts connections to <em class="italic">new hosts</em>; if <code class="Code-In-Text--PACKT-">SSHClient</code> receives an invalid fingerprint when connecting to a known host, it will still raise an exception.</p>
    </div>
    <p class="normal">That takes care of our initializer, so let's create an <code class="Code-In-Text--PACKT-">authenticate()</code> method to establish a connection to the server:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside SFTPModel</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">authenticate</span><span class="hljs-function">(</span><span class="hljs-params">self, username, password</span><span class="hljs-function">):</span>
    <span class="hljs-keyword">try</span>:
      self._client.connect(
        self.host, username=username,
        password=password, port=self.port
      )
    <span class="hljs-keyword">except</span> paramiko.AuthenticationException:
      <span class="hljs-keyword">raise</span> Exception(
        <span class="hljs-string">'The username and password were not accepted by the server.'</span>
      )
</code></pre>
    <p class="normal">This method will take a <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code> and use them to establish a connection using the <code class="Code-In-Text--PACKT-">connect()</code> method. If authentication fails, <code class="Code-In-Text--PACKT-">paramiko</code> will raise an <code class="Code-In-Text--PACKT-">AuthenticationException</code>. We could simply allow this to pass back to the calling code, but as we did with our REST model, we're cleaning it up a little so that our <code class="Code-In-Text--PACKT-">Application</code> object can display a more user-friendly message.</p>
    <p class="normal">As with our <code class="Code-In-Text--PACKT-">RESTModel</code>, we're going to create three more methods: one to upload a file, one to download<a id="_idIndexMarker1379"/> a file, and one to check if a file exists on the server. Because all of these require that we're connected and authenticated, though, it would be handy to have another method that raises an exception if we're not.</p>
    <p class="normal">We'll create a private method for this called <code class="Code-In-Text--PACKT-">_check_auth()</code>, like so:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_check_auth</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
    transport = self._client.get_transport()
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> transport.is_active() <span class="hljs-keyword">and</span> transport.is_authenticated():
      <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">'Not connected to a server.'</span>)
</code></pre>
    <p class="normal">As you saw in the previous section, our connection's active and authenticated statuses can be retrieved from its <code class="Code-In-Text--PACKT-">Transport</code> object; so, this method retrieves the transport, then raises an exception if it's not both active and authenticated.</p>
    <p class="normal">To see how we'll use this, let's create our <code class="Code-In-Text--PACKT-">get_file()</code> method first:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">get_file</span><span class="hljs-function">(</span><span class="hljs-params">self, remote_path, local_path</span><span class="hljs-function">):</span>
    self._check_auth()
    sftp = self._client.open_sftp()
    sftp.get(remote_path, local_path)
</code></pre>
    <p class="normal">This method will take a remote path and a local path and copy the file down from the remote path to the local one. Note that we start with a call to <code class="Code-In-Text--PACKT-">_check_auth()</code> to ensure that we're properly connected to the server. Then we create our SFTP client and run the <code class="Code-In-Text--PACKT-">get()</code> method. That's all there is to it!</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">When creating a command or function that copies or moves data, it's a long-standing convention to put your arguments in the order <code class="Code-In-Text--PACKT-">(SOURCE, DESTINATION)</code>. Mixing this up may rightly earn you the extreme displeasure of your users or fellow developers.</p>
    </div>
    <h3 id="_idParaDest-381" class="title">Uploading files</h3>
    <p class="normal">Creating an upload method will be slightly more complex. Unlike the REST client, which was working with a single endpoint, the SFTP server has a filesystem structure and we have the possibility<a id="_idIndexMarker1380"/> of uploading to a subdirectory on the server. If we try to upload a file to a directory that doesn't exist, <code class="Code-In-Text--PACKT-">paramiko</code> will raise an exception.</p>
    <p class="normal">So, before we upload a file, we'll need to connect to the server and make sure all the directories in the destination path are there first. If any of them are not, we'll need to create that directory.</p>
    <p class="normal">We'll begin our method as before by checking the connection and creating an SFTPClient instance:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">upload_file</span><span class="hljs-function">(</span><span class="hljs-params">self, local_path, remote_path</span><span class="hljs-function">):</span>
    self._check_auth()
    sftp = self._client.open_sftp()
</code></pre>
    <p class="normal">Now, we'll check the directories:</p>
    <pre class="programlisting code"><code class="hljs-code">    remote_path = Path(remote_path)
    <span class="hljs-keyword">for</span> directory <span class="hljs-keyword">in</span> remote_path.parent.parts:
      <span class="hljs-keyword">if</span> directory <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> sftp.listdir():
        sftp.mkdir(directory)
      sftp.chdir(directory)
</code></pre>
    <p class="normal">Our <code class="Code-In-Text--PACKT-">remote_path</code> will likely be a string, so the first thing we do is convert it to a <code class="Code-In-Text--PACKT-">pathlib.Path</code> object for easier manipulation. <code class="Code-In-Text--PACKT-">remote_path.parent.parts</code> gives us a list of all the directories that contain the file, in order from the topmost to the bottom-most. For example, if the <code class="Code-In-Text--PACKT-">remote_path</code> value was <code class="Code-In-Text--PACKT-">Food/Fruit/Bananas/cavendish.ban</code>, this attribute would give us the list <code class="Code-In-Text--PACKT-">['Food', 'Fruit', 'Bananas']</code>.</p>
    <p class="normal">Once we have that list, we iterate through it, checking to see if the directory is in the contents of the current working directory. If not, we create it. Once we know that the directory exists, we change the current working directory to it and repeat with the next directory in the list.</p>
    <p class="normal">Once the directory structure is established, we can upload the actual file:</p>
    <pre class="programlisting code"><code class="hljs-code">    sftp.put(local_path, remote_path.name)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">put()</code> method takes our local path to the file and the remote path where we want to copy it. Note, however, that we're only using the <code class="Code-In-Text--PACKT-">name</code> portion of the remote path; that's because the <code class="Code-In-Text--PACKT-">for</code> loop that iterated over our directories has left our current working directory<a id="_idIndexMarker1381"/> at the proper parent directory where the file needs to be put. Thus, we should just pass the file's name as a destination.</p>
    <h3 id="_idParaDest-382" class="title">Checking a file's existence</h3>
    <p class="normal">The last method we need is one that checks for a file's existence on the server. For this, we'll rely on the <code class="Code-In-Text--PACKT-">stat()</code> method. The <code class="Code-In-Text--PACKT-">stat()</code> method of <code class="Code-In-Text--PACKT-">SFTPClient</code> can be used to fetch metadata<a id="_idIndexMarker1382"/> about a file on the server, such as size and modification time. We don't need that information, but one useful side effect of <code class="Code-In-Text--PACKT-">stat()</code> is that it raises a <code class="Code-In-Text--PACKT-">FileNotFoundError</code> if passed a path that doesn't exist.</p>
    <p class="normal">We can use that in our method, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">check_file</span><span class="hljs-function">(</span><span class="hljs-params">self, remote_path</span><span class="hljs-function">):</span>
    self._check_auth()
    sftp = self._client.open_sftp()
    <span class="hljs-keyword">try</span>:
      sftp.stat(remote_path)
    <span class="hljs-keyword">except</span> FileNotFoundError:
      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
    <p class="normal">As with the other methods, this one begins by checking for authentication, then creating our <code class="Code-In-Text--PACKT-">SFTPClient</code> object. Then, it attempts to <code class="Code-In-Text--PACKT-">stat()</code> the file at <code class="Code-In-Text--PACKT-">remote_path</code>. If a <code class="Code-In-Text--PACKT-">FileNotFoundError</code> is raised, we return <code class="Code-In-Text--PACKT-">False</code>. Otherwise, we return <code class="Code-In-Text--PACKT-">True</code>.</p>
    <p class="normal">This completes our <code class="Code-In-Text--PACKT-">SFTPModel</code>, at least for the operation our application needs to perform; but before we leave <code class="Code-In-Text--PACKT-">models.py</code>, jump up to the <code class="Code-In-Text--PACKT-">SettingsModel</code> class and let's add a few SFTP-related settings:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># models.py, inside SettingsModel</span>
  fields = {
    <span class="hljs-comment"># ...</span>
    <span class="hljs-string">'abq_sftp_host'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'str'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-string">'localhost'</span>},
    <span class="hljs-string">'abq_sftp_port'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'int'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-number">22</span>},
    <span class="hljs-string">'abq_sftp_path'</span>: {<span class="hljs-string">'type'</span>: <span class="hljs-string">'str'</span>, <span class="hljs-string">'value'</span>: <span class="hljs-string">'ABQ/BLTN_IN'</span>}
  }
</code></pre>
    <p class="normal">These settings define the host and port of the server, as well as the subdirectory path on the server where our files will need to be uploaded. With these added, we're ready to work on the GUI side.</p>
    <h2 id="_idParaDest-383" class="title">Using SFTPModel in our application</h2>
    <p class="normal">The SFTP upload process we need<a id="_idIndexMarker1383"/> to implement is identical to the REST upload process: we need to authenticate to the server, then check to see if the file already exists. If it does, we ask the user if they<a id="_idIndexMarker1384"/> want to overwrite it. If not, we offer to download the file for their inspection.</p>
    <p class="normal">Let's begin this method in <code class="Code-In-Text--PACKT-">Application</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span>:
      csvfile = self._create_csv_extract()
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showwarning(
        title=<span class="hljs-string">'Error'</span>, message=<span class="hljs-built_in">str</span>(e)
      )
      <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">Just as before, we begin by attempting to create a CSV file from the day's data; if we get an exception, we'll display it and exit.</p>
    <p class="normal">Now, we'll authenticate:</p>
    <pre class="programlisting code"><code class="hljs-code">    d = v.LoginDialog(self, <span class="hljs-string">'Login to ABQ Corporate SFTP'</span>)
    <span class="hljs-keyword">if</span> d.result <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
      <span class="hljs-keyword">return</span>
    username, password = d.result
    host = self.settings[<span class="hljs-string">'abq_sftp_host'</span>].get()
    port = self.settings[<span class="hljs-string">'abq_sftp_port'</span>].get()
    sftp_model = m.SFTPModel(host, port)
    <span class="hljs-keyword">try</span>:
      sftp_model.authenticate(username, password)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showerror(<span class="hljs-string">'Error Authenticating'</span>, <span class="hljs-built_in">str</span>(e))
      <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">Again, just like before, we request a username and password from the user using our <code class="Code-In-Text--PACKT-">LoginDialog</code>, simply adjusting the label text for SFTP. Then we create our <code class="Code-In-Text--PACKT-">SFTPModel</code> instance using the host and port values from the <code class="Code-In-Text--PACKT-">settings</code> object and attempt to authenticate. Any authentication errors will be displayed in a message box.</p>
    <p class="normal">Next, we need to check the destination path to see if it exists:</p>
    <pre class="programlisting code"><code class="hljs-code">    destination_dir = self.settings[<span class="hljs-string">'abq_sftp_path'</span>].get()
    destination_path = <span class="hljs-string">f'</span><span class="hljs-subst">{destination_dir}</span><span class="hljs-string">/</span><span class="hljs-subst">{csvfile.name}</span><span class="hljs-string">'</span>
    <span class="hljs-keyword">try</span>:
      exists = sftp_model.check_file(destination_path)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showerror(
        <span class="hljs-string">f'Error checking file </span><span class="hljs-subst">{destination_path}</span><span class="hljs-string">'</span>,
        <span class="hljs-built_in">str</span>(e)
      )
      <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">This time, we need to construct<a id="_idIndexMarker1385"/> a complete destination path by combining the <code class="Code-In-Text--PACKT-">abq_sftp_path</code> value from <code class="Code-In-Text--PACKT-">settings</code> with the generated CSV filename. Notice that we're building the path using string formatting rather than with a <code class="Code-In-Text--PACKT-">Path</code> object. That's because <code class="Code-In-Text--PACKT-">Path</code> will join path components using the path separator character (forward-slash or backslash) used on our <em class="italic">local</em> system. The path we're creating needs to be compatible with the <em class="italic">remote</em> filesystem. Fortunately, <code class="Code-In-Text--PACKT-">paramiko</code> will use forward-slashes (Unix-style path separators) regardless<a id="_idIndexMarker1386"/> of whether the remote server uses Windows or a Unix-like system. For that reason, we're explicitly formatting our paths using forward-slashes.</p>
    <p class="normal">If the file exists, we need to ask the user what to do next:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">if</span> exists:
      overwrite = messagebox.askyesno(
        <span class="hljs-string">'File exists'</span>,
        <span class="hljs-string">f'The file </span><span class="hljs-subst">{destination_path}</span><span class="hljs-string"> already exists on the server,'</span>
        <span class="hljs-string">' do you want to overwrite it?'</span>
      )
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> overwrite:
        download = messagebox.askyesno(
          <span class="hljs-string">'Download file'</span>,
          <span class="hljs-string">'Do you want to download the file to inspect it?'</span>
        )
        <span class="hljs-keyword">if</span> download:
          filename = filedialog.asksaveasfilename()
          <span class="hljs-keyword">try</span>:
            sftp_model.get_file(destination_path, filename)
          <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
            messagebox.showerror(<span class="hljs-string">'Error downloading'</span>, <span class="hljs-built_in">str</span>(e))
            <span class="hljs-keyword">return</span>
          messagebox.showinfo(
            <span class="hljs-string">'Download Complete'</span>, <span class="hljs-string">'Download Complete.'</span>
            )
        <span class="hljs-keyword">return</span>
</code></pre>
    <p class="normal">Once again, this is identical to our REST-based code, except that we need to remember we're dealing with paths, not just filenames. Thus, we've used <code class="Code-In-Text--PACKT-">destination_path</code> where we previously used <code class="Code-In-Text--PACKT-">csvfile.name</code>.</p>
    <p class="normal">If the method has not yet<a id="_idIndexMarker1387"/> returned at this point, we can go ahead and attempt<a id="_idIndexMarker1388"/> to upload our file:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">try</span>:
      sftp_model.upload_file(csvfile, destination_path)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
      messagebox.showerror(<span class="hljs-string">'Error uploading'</span>, <span class="hljs-built_in">str</span>(e))
    <span class="hljs-keyword">else</span>:
      messagebox.showinfo(
        <span class="hljs-string">'Success'</span>,
        <span class="hljs-string">f'</span><span class="hljs-subst">{csvfile}</span><span class="hljs-string"> successfully uploaded to SFTP server.'</span>
      )
</code></pre>
    <p class="normal">That finishes up our SFTP upload callback.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Some readers might wonder why our model checks its authenticated status for each call, when our callback method only runs its operations after it has successfully authenticated. First, this is a defensive programming move. We don't know how our model class may be used in the future, and the model can't always count on well-behaved views and controllers ensuring authentication<a id="_idIndexMarker1389"/> before other operations. Secondly, it's because, unlike HTTP, SSH is a <strong class="keyword">stateful</strong> protocol. That means there is an active session created when we connect which must be maintained for any operations to be done. If this session is interrupted (say, by a temporary network outage, or a laptop user switching networks) between authentication and subsequent operations, those operations would fail and we'd need to start over again. Thus, when working with stateful protocols, it's a good idea to check connection and authentication status before individual operations.</p>
    </div>
    <h3 id="_idParaDest-384" class="title">Finishing up</h3>
    <p class="normal">All that remains to do now is to add<a id="_idIndexMarker1390"/> the new feature to our menu. Back in <code class="Code-In-Text--PACKT-">Application.__init__()</code>, add the callback to our <code class="Code-In-Text--PACKT-">event_callbacks</code> dictionary:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># application.py, inside Application.__init__()</span>
    event_callbacks = {
      <span class="hljs-comment">#...</span>
      <span class="hljs-string">'&lt;&lt;UploadToCorporateSFTP&gt;&gt;'</span>: self._upload_to_corporate_sftp,
     }
</code></pre>
    <p class="normal">Now, head over to <code class="Code-In-Text--PACKT-">mainmenu.py</code> and add a new private method to <code class="Code-In-Text--PACKT-">GenericMainMenu</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside GenericMainMenu</span>
  <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">_add_sftp_upload</span><span class="hljs-function">(</span><span class="hljs-params">self, menu</span><span class="hljs-function">):</span>
    menu.add_command(
      label=<span class="hljs-string">"Upload CSV to corporate SFTP"</span>,
      command=self._event(<span class="hljs-string">'&lt;&lt;UploadToCorporateSFTP&gt;&gt;'</span>),
    )
</code></pre>
    <p class="normal">Then, in each menu subclass, add the entry to the <code class="Code-In-Text--PACKT-">Tools</code> menu, like so:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># mainmenu.py, inside each class's _build_menu() method</span>
    self._add_sftp_upload(self._menus[<span class="hljs-string">'Tools'</span>])
</code></pre>
    <p class="normal">Our new upload feature is now complete! Make sure SSH is running on your system, launch ABQ Data Entry, make sure there's at least one record saved for the day, and run the upload from the <strong class="screenText">Tools</strong> menu. You should see a success dialog like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_13_06.png" alt="Figure 13.6: Success dialog for SFTP upload"/></figure>
    <p class="packt_figref">Figure 13.6: Success dialog for SFTP upload</p>
    <p class="normal">Run the feature<a id="_idIndexMarker1391"/> a second time, and you should get your warning dialog, like this:</p>
    <figure class="mediaobject"><img src="../Images/B17578_13_07.png" alt="Figure 13.7: Overwrite dialog for SFTP upload"/></figure>
    <p class="packt_figref">Figure 13.7: Overwrite dialog for SFTP upload</p>
    <p class="normal">Follow through and make sure you can download the file. Excellent work!</p>
    <h1 id="_idParaDest-385" class="title">Summary</h1>
    <p class="normal">In this chapter, we reached out to the cloud using the network protocols HTTP and SSH. You learned how to download data over HTTP using <code class="Code-In-Text--PACKT-">urllib</code>, and how to parse XML data structures using the <code class="Code-In-Text--PACKT-">ElementTree</code> module. You also discovered an alternative way to interact with HTTP using the <code class="Code-In-Text--PACKT-">requests</code> library and learned the basics of interacting with a REST API. You learned to work with HTTP interactions that required authentications and session cookies, and uploaded a file. Finally, you learned how to transfer and manage remote files over SSH with SFTP services using the <code class="Code-In-Text--PACKT-">paramiko</code> library.</p>
    <p class="normal">In the next chapter, we'll stop long-running processes from freezing up our application and improve our application's performance by learning about asynchronous programming. We'll learn to manipulate the Tkinter event loop for better responsiveness as well as advanced asynchronous programming using Python's <code class="Code-In-Text--PACKT-">threading</code> library.</p>
  </div>
</body></html>