["```py\nclass OldPaymentSystem:\n    def __init__(self, currency):\n        self.currency = currency\n    def make_payment(self, amount):\n        print(\n            f\"[OLD] Pay {amount} {self.currency}\"\n        )\n```", "```py\nclass NewPaymentGateway:\n    def __init__(self, currency):\n        self.currency = currency\n    def execute_payment(self, amount):\n        print(\n            f\"Execute payment of {amount} {self.currency}\"\n        )\n```", "```py\nclass PaymentAdapter:\n    def __init__(self, system):\n        self.system = system\n    def make_payment(self, amount):\n        self.system.execute_payment(amount)\n```", "```py\ndef main():\n    old_system = OldPaymentSystem(\"euro\")\n    print(old_system)\n    new_system = NewPaymentGateway(\"euro\")\n    print(new_system)\n    adapter = PaymentAdapter(new_system)\n    adapter.make_payment(100)\n```", "```py\n<__main__.OldPaymentSystem object at 0x10ee58fd0>\n<__main__.NewPaymentGateway object at 0x10ee58f70>\nExecute payment of 100 euro\n```", "```py\nclass Club:\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return f\"the club {self.name}\"\n    def organize_event(self):\n        return \"hires an artist to perform\"\n```", "```py\nclass Musician:\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return f\"the musician {self.name}\"\n    def play(self):\n        return \"plays music\"\nclass Dancer:\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return f\"the dancer {self.name}\"\n    def dance(self):\n        return \"does a dance performance\"\n```", "```py\nclass Adapter:\n    def __init__(self, obj, adapted_methods):\n        self.obj = obj\n        self.__dict__.update(adapted_methods)\n    def __str__(self):\n        return str(self.obj)\n```", "```py\ndef main():\n    objects = [\n        Club(\"Jazz Cafe\"),\n        Musician(\"Roy Ayers\"),\n        Dancer(\"Shane Sparks\"),\n    ]\n    for obj in objects:\n        if hasattr(obj, \"play\") or hasattr(\n            obj, \"dance\"\n        ):\n            if hasattr(obj, \"play\"):\n                adapted_methods = dict(\n                    organize_event=obj.play\n                )\n            elif hasattr(obj, \"dance\"):\n                adapted_methods = dict(\n                    organize_event=obj.dance\n                )\n            obj = Adapter(obj, adapted_methods)\n        print(f\"{obj} {obj.organize_event()}\")\n```", "```py\nthe club Jazz Cafe hires an artist to perform\nthe musician Roy Ayers plays music\nthe dancer Shane Sparks does a dance performance\n```", "```py\ndef number_sum(n):\n    if n == 0:\n        return 0\n    else:\n        return n + number_sum(n - 1)\nif __name__ == \"__main__\":\n    from timeit import Timer\n    t = Timer(\n        \"number_sum(50)\",\n        \"from __main__ import number_sum\",\n    )\n    print(\"Time: \", t.timeit())\n```", "```py\ndict for caching the already computed sums. We also change the parameter passed to the number_sum() function. We want to calculate the sum of the first 300 numbers instead of only the first 50.\n\t\t\tHere is the new version of the code (in the `ch04``/decorator/number_sum.py` file), using memoization:\n\n```", "```py\n\n\t\t\tExecuting the memoization-based code shows that performance improves dramatically, and is acceptable even for computing large values.\n\t\t\tA sample execution, using `python ch04/decorator/number_sum.py`, is as follows:\n\n```", "```py\n\n\t\t\tBut there are a few problems with this approach. First, while the performance is not an issue any longer, the code is not as clean as it is when not using memoization. And what happens if we decide to extend the code with more math functions and turn it into a module? We can think of several functions that would be useful for our module, for problems such as Pascal’s triangle or the Fibonacci numbers suite algorithm.\n\t\t\tSo, if we wanted a function in the same module as `number_sum()` for the Fibonacci numbers suite, using the same memoization technique, we would add code as follows (see the version in the `ch04/decorator/number_sum_and_fibonacci.py` file):\n\n```", "```py\n\n\t\t\tDo you notice the problem? We ended up with a new dictionary called `fib_cache` that acts as our cache for the `fibonacci()` function, and a function that is more complex than it would be without using memoization. Our module is becoming unnecessarily complex.\n\t\t\tIs it possible to write these functions while keeping them as simple as the naive versions, but achieving a performance similar to the performance of the functions that use memoization?\n\t\t\tFortunately, it is, and the solution is to use the decorator pattern.\n\t\t\tFirst, we create a `memoize()` decorator as shown in the following example. Our decorator accepts the `func` function, which needs to be memoized, as an input. It uses `dict` named `cache` as the cached data container. The `functools.wraps()` function is used for convenience when creating decorators. It is not mandatory but it’s a good practice to use it, since it makes sure that the documentation and the signature of the function that is decorated are preserved. The `*args` argument list is required in this case because the functions that we want to decorate accept input arguments (such as the `n` argument for our two functions):\n\n```", "```py\n\n\t\t\tNow we can use our `memoize()` decorator with the naive version of our functions. This has the benefit of readable code without performance impact. We apply a decorator using what is known as `@name` syntax, where `name` is the name of the decorator that we want to use. It is nothing more than syntactic sugar for simplifying the usage of decorators. We can even bypass this syntax and execute our decorator manually, but that is left as an exercise for you.\n\t\t\tSo, the `memoize()` decorator can be used with our recursive functions as follows:\n\n```", "```py\n\n\t\t\tIn the last part of the code, via the `main()` function, we show how to use the decorated functions and measure their performance. The `to_execute` variable is used to hold a list of tuples containing the reference to each function and the corresponding `timeit.Timer()` call (to execute it while measuring the time spent), thus avoiding code repetition. Note how the `__name__` and `__doc__` method attributes show the proper function names and documentation values, respectively. Try removing the `@functools.wraps(func)` decoration from `memoize()` and see whether this is still the case.\n\t\t\tHere is the last part of the code:\n\n```", "```py\n\n\t\t\tLet’s recapitulate how we write the complete code of our math module (the `ch04/decorator/decorate_math.py` file):\n\n\t\t\t\t1.  After the import of Python’s `functools` module that we will be using, we define the `memoize()` decorator function.\n\t\t\t\t2.  Then, we define the `number_sum()` function, decorated using `memoize()`.\n\t\t\t\t3.  Next, we define the `fibonacci()` function, decorated the same way.\n\t\t\t\t4.  Finally, we add the `main()` function, as shown earlier, and the usual trick to call it.\n\n\t\t\tHere is a sample output when executing the `python` `ch04/decorator/decorate_math.py` command:\n\n```", "```py\n\n\t\t\tNote\n\t\t\tThe execution times might differ in your case. Also, regardless of the time spent, we can see that the decorator-based implementation is a win because the code is more maintainable.\n\t\t\tNice! We ended up with readable code and acceptable performance. Now, you might argue that this is not the decorator pattern, since we don’t apply it at runtime. The truth is that a decorated function cannot be undecorated, but you can still decide at runtime whether the decorator will be executed or not. That’s an interesting exercise left for you. *Hint for the exercise:* use a decorator that acts as a wrapper, which decides whether or not the real decorator is executed based on some condition.\n\t\t\tThe bridge pattern\n\t\t\tA third structural pattern to look at is the **bridge** pattern. We can actually compare the bridge and the adapter patterns, looking at the way both work. While the adapter pattern is used *later* to make unrelated classes work together, as we saw in the implementation example we discussed earlier in the section on *The adapter pattern*, the bridge pattern is designed *up-front* to decouple an implementation from its abstraction, as we are going to see.\n\t\t\tReal-world examples\n\t\t\tIn our modern, everyday lives, an example of the bridge pattern I can think of is from the *digital economy*: information products. Nowadays, the information product or *infoproduct* is part of the resources one can find online for training, self-improvement, or one’s ideas and business development. The purpose of an information product that you find on certain marketplaces, or the website of the provider, is to deliver information on a given topic in such a way that it is easy to access and consume. The provided material can be a PDF document or ebook, an ebook series, a video, a video series, an online course, a subscription-based newsletter, or a combination of all those formats.\n\t\t\tIn the software realm, we can find two examples:\n\n\t\t\t\t*   **Device drivers**: Developers of an OS define the interface for device (such as printers) vendors to implement it\n\t\t\t\t*   **Payment gateways**: Different payment gateways can have different implementations, but the checkout process remains consistent\n\n\t\t\tUse cases for the bridge pattern\n\t\t\tUsing the bridge pattern is a good idea when you want to share an implementation among multiple objects. Basically, instead of implementing several specialized classes, and defining all that is required within each class, you can define the following special components:\n\n\t\t\t\t*   An abstraction that applies to all the classes\n\t\t\t\t*   A separate interface for the different objects involved\n\n\t\t\tAn implementation example we are about to see will illustrate this approach.\n\t\t\tImplementing the bridge pattern\n\t\t\tLet’s assume we are building an application where the user is going to manage and deliver content after fetching it from diverse sources, which could be the following:\n\n\t\t\t\t*   A web page (based on its URL)\n\t\t\t\t*   A resource accessed on an FTP server\n\t\t\t\t*   A file on the local filesystem\n\t\t\t\t*   A database server\n\n\t\t\tSo, here is the idea: instead of implementing several content classes, each holding the methods responsible for getting the content pieces, assembling them, and showing them inside the application, we can define an abstraction for the *Resource Content* and a separate interface for the objects that are responsible for fetching the content. Let’s try it!\n\t\t\tWe begin with the interface for the implementation classes that help fetch content – that is, the `ResourceContentFetcher` class. This concept is called the `protocols` feature, as follows:\n\n```", "```py\n\n\t\t\tThen, we define the class for our Resource Content abstraction, called `ResourceContent`. The first trick we use here is that, via an attribute (`_imp`) on the `ResourceContent` class, we maintain a reference to the object that represents the Implementor (fulfilling the `ResourceContentFetcher` interface). The code is as follows:\n\n```", "```py\n\n\t\t\tNow we can add an `implementation` class to fetch content from a web page or resource:\n\n```", "```py\n\n\t\t\tWe can also add an `implementation` class to fetch content from a file on the local filesystem:\n\n```", "```py\n\n\t\t\tBased on that, a `main` function with some testing code to show content using both *content fetchers* could look like the following:\n\n```", "```py\n\n\t\t\tLet’s see a summary of the complete code of our example (the `ch04/bridge/bridge.py` file):\n\n\t\t\t\t1.  We import the modules we need for the program (`os`, `urllib.request`, and `typing.Protocol`).\n\t\t\t\t2.  We define the `ResourceContentFetcher` interface, using *protocols*, for the *Implementor*.\n\t\t\t\t3.  We define the `ResourceContent` class for the interface of the abstraction.\n\t\t\t\t4.  We define two implementation classes:\n    *   `URLFetcher` for fetching content from a URL\n    *   `LocalFileFetcher` for fetching content from the local filesystem\n\t\t\t\t5.  Finally, we add the `main()` function, as shown earlier, and the usual trick to call it.\n\n\t\t\tHere is a sample output when executing the `python` `ch04/bridge/bridge.py` command:\n\n```", "```py\n\n\t\t\tThis is a basic illustration of how using the bridge pattern in your design, you can extract content from different sources and integrate the results in the same data manipulation system or user interface.\n\t\t\tThe facade pattern\n\t\t\tAs systems evolve, they can get very complex. It is not unusual to end up with a very large (and sometimes confusing) collection of classes and interactions. In many cases, we don’t want to expose this complexity to the client. This is where our next structural pattern comes to the rescue: **facade**.\n\t\t\tThe facade design pattern helps us hide the internal complexity of our systems and expose only what is necessary to the client through a simplified interface. In essence, facade is an abstraction layer implemented over an existing complex system.\n\t\t\tLet’s take the example of the computer to illustrate things. A computer is a complex machine that depends on several parts to be fully functional. To keep things simple, the word “computer,” in this case, refers to an IBM derivative that uses a von Neumann architecture. Booting a computer is a particularly complex procedure. The CPU, main memory, and hard disk need to be up and running, the boot loader must be loaded from the hard disk to the main memory, the CPU must boot the operating system kernel, and so forth. Instead of exposing all this complexity to the client, we create a facade that encapsulates the whole procedure, making sure that all steps are executed in the right order.\n\t\t\tIn terms of object design and programming, we should have several classes, but only the `Computer` class needs to be exposed to the client code. The client will only have to execute the `start()` method of the `Computer` class, for example, and all the other complex parts are taken care of by the facade `Computer` class.\n\t\t\tReal-world examples\n\t\t\tThe facade pattern is quite common in life. When you call a bank or a company, you are usually first connected to the customer service department. The customer service employee acts as a facade between you and the actual department (billing, technical support, general assistance, and so on), where an employee will help you with your specific problem.\n\t\t\tAs another example, a key used to turn on a car or motorcycle can also be considered a facade. It is a simple way of activating a system that is very complex internally. And, of course, the same is true for other complex electronic devices that we can activate with a single button, such as computers.\n\t\t\tIn software, the `django-oscar-datacash` module is a Django third-party module that integrates with the **DataCash** payment gateway. The module has a gateway class that provides fine-grained access to the various DataCash APIs. On top of that, it also offers a facade class that provides a less granular API (for those who don’t want to mess with the details), and the ability to save transactions for auditing purposes.\n\t\t\tThe `Requests` library is another great example of the facade pattern. It simplifies sending HTTP requests and handling responses, abstracting the complexities of the HTTP protocol. Developers can easily make HTTP requests without dealing with the intricacies of sockets or the underlying HTTP methods.\n\t\t\tUse cases for the facade pattern\n\t\t\tThe most usual reason to use the facade pattern is to provide a single, simple entry point to a complex system. By introducing facade, the client code can use a system by simply calling a single method/function. At the same time, the internal system does not lose any functionality, it just encapsulates it.\n\t\t\tNot exposing the internal functionality of a system to the client code gives us an extra benefit: we can introduce changes to the system, but the client code remains unaware of and unaffected by the changes. No modifications are required to the client code.\n\t\t\tFacade is also useful if you have more than one layer in your system. You can introduce one facade entry point per layer and let all layers communicate with each other through their facades. That promotes **loose coupling** and keeps the layers as independent as possible.\n\t\t\tImplementing the facade pattern\n\t\t\tAssume that we want to create an operating system using a multi-server approach, similar to how it is done in MINIX 3 or GNU Hurd. A multi-server operating system has a minimal kernel, called the **microkernel**, which runs in privileged mode. All the other services of the system are following a server architecture (driver server, process server, file server, and so forth). Each server belongs to a different memory address space and runs on top of the microkernel in user mode. The pros of this approach are that the operating system can become more fault-tolerant, reliable, and secure. For example, since all drivers are running in user mode on a driver server, a bug in a driver cannot crash the whole system, nor can it affect the other servers. The cons of this approach are the performance overhead and the complexity of system programming, because the communication between a server and the microkernel, as well as between the independent servers, happens using message passing. Message passing is more complex than the shared memory model used in monolithic kernels such as Linux.\n\t\t\tWe begin with a `Server` interface. Also, an `Enum` parameter describes the different possible states of a server. We use the `ABC` technique to forbid direct instantiation of the `Server` interface and make the fundamental `boot()` and `kill()` methods mandatory, assuming that different actions are needed to be taken for booting, killing, and restarting each server. Here is the code for these elements, the first important bits to support our implementation:\n\n```", "```py\n\n\t\t\tA modular operating system can have a great number of interesting servers: a file server, a process server, an authentication server, a network server, a graphical/window server, and so forth. The following example includes two stub servers: `FileServer` and `ProcessServer`. Apart from the `boot()` and `kill()` methods all servers have, `FileServer` has a `create_file()` method for creating files, and `ProcessServer` has a `create_process()` method for creating processes.\n\t\t\tThe `FileServer` class is as follows:\n\n```", "```py\n\n\t\t\tThe `ProcessServer` class is as follows:\n\n```", "```py\n\n\t\t\tThe `OperatingSystem` class is a facade. In its `__init__()`, all the necessary server instances are created. The `start()` method, used by the client code, is the entry point to the system. More wrapper methods can be added, if necessary, as access points to the services of the servers, such as the wrappers, `create_file()` and `create_process()`. From the client’s point of view, all those services are provided by the `OperatingSystem` class. The client should not be confused by unnecessary details such as the existence of servers and the responsibility of each server.\n\t\t\tThe code for the `OperatingSystem` class is as follows:\n\n```", "```py\n\n\t\t\tAs you are going to see in a minute, when we present a summary of the example, there are many dummy classes and servers. They are there to give you an idea about the required abstractions (`User`, `Process`, `File`, and so forth) and servers (`WindowServer`, `NetworkServer`, and so forth) for making the system functional.\n\t\t\tFinally, we add our main code for testing the design, as follows:\n\n```", "```py\n\n\t\t\tWe are going to recapitulate the details of our implementation example; the full code is in the `ch04/facade.py` file:\n\n\t\t\t\t1.  We start with the imports we need.\n\t\t\t\t2.  We define the `State` constant using `Enum`, as shown earlier.\n\t\t\t\t3.  We then add the `User`, `Process`, and `File` classes, which do nothing in this minimal but functional example.\n\t\t\t\t4.  We define the abstract `Server` class, as shown earlier.\n\t\t\t\t5.  We then define the `FileServer` class and the `ProcessServer` class, which are both subclasses of `Server`.\n\t\t\t\t6.  We add two other dummy classes, `WindowServer` and `NetworkServer`.\n\t\t\t\t7.  Then we define our facade class, `OperatingSystem`, as shown earlier.\n\t\t\t\t8.  Finally, we add the main part of the code, where we use the facade we have defined.\n\n\t\t\tAs you can see, executing the `python ch04/facade.py` command shows the messages produced by our two stub servers:\n\n```", "```py\nCarType = Enum(\n    \"CarType\", \"SUBCOMPACT COMPACT SUV\"\n)\n```", "```py\nclass Car:\n    pool = dict()\n    def __new__(cls, car_type):\n        obj = cls.pool.get(car_type, None)\n        if not obj:\n            obj = object.__new__(cls)\n            cls.pool[car_type] = obj\n            obj.car_type = car_type\n        return obj\n```", "```py\n    def render(self, color, x, y):\n        type = self.car_type\n        msg = f\"render a {color} {type.name} car at ({x}, {y})\"\n        print(msg)\n```", "```py\ndef main():\n    rnd = random.Random()\n    colors = [\n        \"white\",\n        \"black\",\n        \"silver\",\n        \"gray\",\n        \"red\",\n        \"blue\",\n        \"brown\",\n        \"beige\",\n        \"yellow\",\n        \"green\",\n    ]\n    min_point, max_point = 0, 100\n    car_counter = 0\n    for _ in range(10):\n        c1 = Car(CarType.SUBCOMPACT)\n        c1.render(\n            random.choice(colors),\n            rnd.randint(min_point, max_point),\n            rnd.randint(min_point, max_point),\n        )\n        car_counter += 1\n    for _ in range(3):\n        c2 = Car(CarType.COMPACT)\n        c2.render(\n            random.choice(colors),\n            rnd.randint(min_point, max_point),\n            rnd.randint(min_point, max_point),\n        )\n        car_counter += 1\n    for _ in range(5):\n        c3 = Car(CarType.SUV)\n        c3.render(\n            random.choice(colors),\n            rnd.randint(min_point, max_point),\n            rnd.randint(min_point, max_point),\n        )\n        car_counter += 1\n    print(f\"cars rendered: {car_counter}\")\n    print(\n        f\"cars actually created: {len(Car.pool)}\"\n    )\n    c4 = Car(CarType.SUBCOMPACT)\n    c5 = Car(CarType.SUBCOMPACT)\n    c6 = Car(CarType.SUV)\n    print(\n        f\"{id(c4)} == {id(c5)}? {id(c4) == id(c5)}\"\n    )\n    print(\n        f\"{id(c5)} == {id(c6)}? {id(c5) == id(c6)}\"\n    )\n```", "```py\nrender a gray SUBCOMPACT car at (25, 79)\nrender a black SUBCOMPACT car at (31, 99)\nrender a brown SUBCOMPACT car at (16, 74)\nrender a green SUBCOMPACT car at (10, 1)\nrender a gray SUBCOMPACT car at (55, 38)\nrender a red SUBCOMPACT car at (30, 45)\nrender a brown SUBCOMPACT car at (17, 78)\nrender a gray SUBCOMPACT car at (14, 21)\nrender a gray SUBCOMPACT car at (7, 28)\nrender a gray SUBCOMPACT car at (22, 50)\nrender a brown COMPACT car at (75, 26)\nrender a red COMPACT car at (22, 61)\nrender a white COMPACT car at (67, 87)\nrender a beige SUV car at (23, 93)\nrender a white SUV car at (37, 100)\nrender a red SUV car at (33, 98)\nrender a black SUV car at (77, 22)\nrender a green SUV car at (16, 51)\ncars rendered: 18\ncars actually created: 3\n4493672400 == 4493672400? True\n4493672400 == 4493457488? False\n```", "```py\nclass LazyProperty:\n    def __init__(self, method):\n        self.method = method\n        self.method_name = method.__name__\n        # print(f\"function overriden: {self.method}\")\n        # print(f\"function's name: {self.method_name}\")\n```", "```py\n    def __get__(self, obj, cls):\n        if not obj:\n            return None\n        value = self.method(obj)\n        # print(f'value {value}')\n        setattr(obj, self.method_name, value)\n        return value\n```", "```py\nclass Test:\n    def __init__(self):\n        self.x = \"foo\"\n        self.y = \"bar\"\n        self._resource = None\n```", "```py\n    @LazyProperty\n    def resource(self):\n        print(\"initializing self._resource...\")\n        print(f\"... which is: {self._resource}\")\n        self._resource = tuple(range(5))\n        return self._resource\n```", "```py\ndef main():\n    t = Test()\n    print(t.x)\n    print(t.y)\n    # do more work...\n    print(t.resource)\n    print(t.resource)\n```", "```py\nfoo\nbar\ninitializing self._resource...\n... which is: None\n(0, 1, 2, 3, 4)\n(0, 1, 2, 3, 4)\n```", "```py\nclass SensitiveInfo:\n    def __init__(self):\n        self.users = [\"nick\", \"tom\", \"ben\", \"mike\"]\n    def read(self):\n        nb = len(self.users)\n        print(f\"There are {nb} users: {' '.join(self.users)}\")\n    def add(self, user):\n        self.users.append(user)\n        print(f\"Added user {user}\")\n```", "```py\nclass Info:\n    def __init__(self):\n        self.protected = SensitiveInfo()\n        self.secret = \"0xdeadbeef\"\n    def read(self):\n        self.protected.read()\n    def add(self, user):\n        sec = input(\"what is the secret? \")\n        if sec == self.secret:\n            self.protected.add(user)\n        else:\n            print(\"That's wrong!\")\n```", "```py\ndef main():\n    info = Info()\n    while True:\n        print(\"1\\. read list |==| 2\\. add user |==| 3\\. quit\")\n        key = input(\"choose option: \")\n        if key == \"1\":\n            info.read()\n        elif key == \"2\":\n            name = input(\"choose username: \")\n            info.add(name)\n        elif key == \"3\":\n            exit()\n        else:\n            print(f\"unknown option: {key}\")\n```", "```py\n1\\. read list |==| 2\\. add user |==| 3\\. quit\nchoose option: 1\nThere are 4 users: nick tom ben mike\n1\\. read list |==| 2\\. add user |==| 3\\. quit\nchoose option: 2\nchoose username: tom\nwhat is the secret? 0xdeadbeef\nAdded user tom\n1\\. read list |==| 2\\. add user |==| 3\\. quit\nchoose option: 3\n```", "```py\nfrom abc import ABC, abstractmethod\nclass RemoteServiceInterface(ABC):\n    @abstractmethod\n    def read_file(self, file_name):\n        pass\n    @abstractmethod\n    def write_file(self, file_name, contents):\n        pass\n    @abstractmethod\n    def delete_file(self, file_name):\n        pass\n```", "```py\nclass RemoteService(RemoteServiceInterface):\n    def read_file(self, file_name):\n        # Implementation for reading a file from the server\n        return \"Reading file from remote server\"\n    def write_file(self, file_name, contents):\n        # Implementation for writing to a file on the server\n        return \"Writing to file on remote server\"\n    def delete_file(self, file_name):\n        # Implementation for deleting a file from the server\n        return \"Deleting file from remote server\"\n```", "```py\nclass ProxyService(RemoteServiceInterface):\n    def __init__(self):\n        self.remote_service = RemoteService()\n    def read_file(self, file_name):\n        print(\"Proxy: Forwarding read request to RemoteService\")\n        return self.remote_service.read_file(file_name)\n    def write_file(self, file_name, contents):\n        print(\"Proxy: Forwarding write request to RemoteService\")\n        return self.remote_service.write_file(file_name, contents)\n    def delete_file(self, file_name):\n        print(\"Proxy: Forwarding delete request to RemoteService\")\n        return self.remote_service.delete_file(file_name)\n```", "```py\nif __name__ == \"__main__\":\n    proxy = ProxyService()\n    print(proxy.read_file(\"example.txt\"))\n```", "```py\nProxy: Forwarding read request to RemoteService\nReading file from remote server\n```", "```py\nfrom typing import Protocol\nclass DBConnectionInterface(Protocol):\n    def exec_query(self, query):\n        ...\n```", "```py\nclass DBConnection:\n    def __init__(self):\n        print(\"DB connection created\")\n    def exec_query(self, query):\n        return f\"Executing query: {query}\"\n    def close(self):\n        print(\"DB connection closed\")\n```", "```py\nclass SmartProxy:\n    def __init__(self):\n        self.cnx = None\n        self.ref_count = 0\n    def access_resource(self):\n        if self.cnx is None:\n            self.cnx = DBConnection()\n        self.ref_count += 1\n        print(f\"DB connection now has {self.ref_count} references.\")\n    def exec_query(self, query):\n        if self.cnx is None:\n            # Ensure the connection is created\n            # if not already\n            self.access_resource()\n        result = self.cnx.exec_query(query)\n        print(result)\n        # Decrement reference count after\n        # executing query\n        self.release_resource()\n        return result\n    def release_resource(self):\n        if self.ref_count > 0:\n            self.ref_count -= 1\n            print(\"Reference released...\")\n            print(f\"{self.ref_count} remaining refs.\")\n        if self.ref_count == 0 and self.cnx is not None:\n            self.cnx.close()\n            self.cnx = None\n```", "```py\nif __name__ == \"__main__\":\n    proxy = SmartProxy()\n    proxy.exec_query(\"SELECT * FROM users\")\n    proxy.exec_query(\"UPDATE users SET name = 'John Doe' WHERE id = 1\")\n```", "```py\nDB connection created\nDB connection now has 1 references.\nExecuting query: SELECT * FROM users\nReference released...\n0 remaining refs.\nDB connection closed\nDB connection created\nDB connection now has 1 references.\nExecuting query: UPDATE users SET name = 'John Doe' WHERE id = 1\nReference released...\n0 remaining refs.\nDB connection closed\n```", "```py\n\n```"]