<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer047" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-118" class="chapter-number" lang="en-GB"><a id="_idTextAnchor121"/>7</h1>&#13;
			<h1 id="_idParaDest-119" lang="en-GB"><a id="_idTextAnchor122"/>Extending the TC1</h1>&#13;
			<p lang="en-GB">In this chapter, you will learn how to expand the functionality of the TC1 simulator that we designed in <a href="B19624_06.xhtml#_idTextAnchor091"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. We also look at some of the elements of the design of a simulator, including input/output techniques and data validation, and describe how the simulator can display the state of a processor as it <span class="No-Break">executes instructions.</span></p>&#13;
			<p lang="en-GB">TC1 is a compromise. Initially, it was designed to support teaching the basics of computer architecture. It is an aid to understanding instruction encoding, instruction format trade-offs, the execution of an instruction, addressing modes, and the ability to design and implement an <span class="No-Break">instruction set.</span></p>&#13;
			<p lang="en-GB">Here, we look at ways of expanding TC1 by, for example, discussing how new instructions can be added. Finally, we deal with a topic that we have omitted so far: how to create a computer architecture with variable-length instructions. That is, individual instructions can be an integer multiple of the basic <span class="No-Break">word length.</span></p>&#13;
			<p lang="en-GB">The TC1 CPU simulator executes instructions one by one and prints the contents of the registers, program counter, and status flags after each instruction is executed. You can use this information to debug assembly-level programs. Often, when you look at the data, you find that the results are not what was expected; for example, you might want to execute a loop 9 times but execute it 10 times because you made an error in testing for the end of <span class="No-Break">the loop.</span></p>&#13;
			<p lang="en-GB">We have three issues to deal with. The first is displaying the data. How do we display the data and how do we format it? Should the contents of a register be displayed as a decimal value, a binary string of 1s and 0s, or as <span class="No-Break">hexadecimal characters?</span></p>&#13;
			<p lang="en-GB">Another design issue is whether to store historic data. That is, do we store the registers and flags after each instruction has been executed in an array so that we can look at values in <span class="No-Break">previous operations?</span></p>&#13;
			<p lang="en-GB">Finally, how do we proceed? The TC1 simulator executes an instruction every time the <em class="italic">Enter</em> key is pressed. This provides a great way of stepping through a program but becomes infeasible when a loop requires 1,000 instructions to be executed before you get to the part of the program of interest. We will demonstrate how you can leave the single-step mode, execute a batch of instructions, and return to the <span class="No-Break">single-step mode.</span></p>&#13;
			<h1 id="_idParaDest-120" lang="en-GB"><a id="_idTextAnchor123"/>Technical requirements</h1>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">You can find the programs used in this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-121" lang="en-GB"><a id="_idTextAnchor124"/>Another look at python’s input and output</h1>&#13;
			<p lang="en-GB">Here, we go into a little more detail about data input and output mechanisms, as these topics are so important in the design of a simulator because formatting data is all-important to the interpretation of <span class="No-Break">the data.</span></p>&#13;
			<p lang="en-GB">Let’s have another look at input in Python. Inputting data from the keyboard is very easy. To input text, you write <strong class="source-inline">x = input()</strong> and that’s it. When this statement is encountered, Python waits for your input. You enter the text and terminate it with a return (<em class="italic">Enter</em> key). If you just enter a return without text, the value of <strong class="source-inline">x</strong> will be a null string – that is, ' '. The data you input is stored in <span class="No-Break">text form.</span></p>&#13;
			<p lang="en-GB">Python lets you display a prompt before receiving the input; for example, you can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = input('Please enter your age')</span></pre>&#13;
			<p lang="en-GB">Because the input is in character form, you must convert numeric values into integer form before using them. It’s easy to perform conversions into decimal, binary, or hexadecimal, as the following examples show. You just add the number base as a second parameter to the <span class="No-Break"><strong class="source-inline">int()</strong></span><span class="No-Break"> function:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = input('Enter the constant ')</span>&#13;
<span>y = int(x)                        <span class="sc-comment"># For a decimal constant</span></span>&#13;
<span>y = int(x,2)                      <span class="sc-comment"># For a binary constant</span></span>&#13;
<span>y = int(x,16)                     <span class="sc-comment"># For a hexadecimal constant</span></span></pre>&#13;
			<p lang="en-GB">Let’s consider a more sophisticated example. We’ll input an instruction such as <strong class="source-inline">ADD R3,R7</strong>,<strong class="source-inline">$12FA</strong> and extract the three integers <strong class="source-inline">3</strong>, <strong class="source-inline">7</strong>, and <strong class="source-inline">0x12FA</strong>. In this example, a $ prefix indicates a hexadecimal value (a convention used <span class="No-Break">by Motorola).</span></p>&#13;
			<p lang="en-GB">The following code performs this operation. The input uses a <strong class="source-inline">replace</strong> function to convert all commas into spaces. We combine the replace operation with the input operation to create compact code. The input is followed by a <strong class="source-inline">split</strong> function to convert the string <span class="No-Break">into tokens:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>inst        = input('Enter operation: &gt;&gt;')<span class="sc-source-bold-bg">.replace(',',' ')</span></span>&#13;
<span>p           = inst.split(' ')</span>&#13;
<span>t1,t2,t3,<strong class="bold">t4</strong> = p[0],int(p[1][1:]),int(p[2][1:]),<strong class="bold">int(p[3][1:],16)</strong></span></pre>&#13;
			<p lang="en-GB">Finally, we examine each of the four tokens in turn and extract the parameter as an integer (<strong class="source-inline">t1</strong>, <strong class="source-inline">t2</strong>, <strong class="source-inline">t3</strong>, and <strong class="source-inline">t4</strong>). Consider <strong class="source-inline">t4</strong>. The <strong class="source-inline">p[3]</strong> expression extracts the <strong class="source-inline">"$12FA"</strong> string. The second index, <strong class="source-inline">[1:]</strong>, extracts all characters after the first one to give <strong class="source-inline">"12FA"</strong>. This is still a character string. The final operation, <span class="pcode-bold-bg">int</span><strong class="source-inline">(p[3]</strong>[1:]<strong class="source-inline">,</strong><span class="pcode-bg">16</span><strong class="source-inline">)</strong>, converts the parameter string in hexadecimal form into the integer <strong class="source-inline">4858</strong>. The output produced by a second example, <strong class="source-inline">ADD r3,r7,$1102</strong>, was <strong class="source-inline">ADD 3 </strong><span class="No-Break"><strong class="source-inline">7 4354</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">As we’ve already seen, Python lets you put several equates on a line – for example, <strong class="source-inline">a,b,c = p,q,r</strong>. This results in <span class="No-Break">the following:</span></p>&#13;
			<p class="source-code" lang="en-GB">a = p</p>&#13;
			<p class="source-code" lang="en-GB">b = q</p>&#13;
			<p class="source-code">c = r</p>&#13;
			<p lang="en-GB">This shorthand is useful when dealing with simple equates (usually during an initialization process). Some programmers prefer not to use this technique as it can reduce program readability. Let’s test the preceding fragment of code. We’ve added some <strong class="source-inline">print</strong> statements between the operations so that we can follow what’s going on as the code <span class="No-Break">is executed:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>inst = input('Enter operation: &gt;&gt;').replace(',',' ')</span>&#13;
<span>print('inst',inst)</span>&#13;
<span>p = inst.split(' ')</span>&#13;
<span>print ('p',p)</span>&#13;
<span>t1,t2,t3,t4 = p[0],int(p[1][1:]),int(p[2][1:]),int(p[3][1:],16)</span>&#13;
<span>print(‚t1,t2,t3,t4',t1,t2,t3,t4)</span></pre>&#13;
			<p lang="en-GB">The output is next. Note that when we print <strong class="source-inline">t1</strong> to <strong class="source-inline">t4</strong>, the numeric value of the hexadecimal operand is given in its <span class="No-Break">decimal form:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Enter operation: &gt;&gt;<strong class="bold">add r1,r2,$FACE</strong></span>&#13;
<span><strong class="bold">inst add r1 r2 $FACE</strong></span>&#13;
<span>p ['add', 'r1', 'r2', '$FACE']</span>&#13;
<span>t1,t2,t3,t4 add 1 2 64206</span></pre>&#13;
			<p lang="en-GB">The next section looks at how we format data such as numbers so that they can be made much easier for the reader to understand; for example, sometimes you might wish to represent the decimal 42 as <strong class="source-inline">101010</strong> and sometimes as <strong class="source-inline">00101010</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">002A</strong></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-122" lang="en-GB"><a id="_idTextAnchor125"/>Displaying data</h2>&#13;
			<p lang="en-GB">We now look more deeply at the ways in which data can be displayed in Python. When you are observing the execution of a program, you want to see what has changed after each instruction has been executed. A computer’s state is determined by the contents of its registers and memory, the program counter, and its status bits, plus <span class="No-Break">its memory.</span></p>&#13;
			<p lang="en-GB">How do we display data? Since data can represent anything you want it to, the data in a register has no intrinsic meaning. By convention, CPU simulators represent data in hexadecimal form. This is partially because each 16-bit register holds 4 hexadecimal characters and that provides a rather convenient way for humans to handle data (try remembering 16-bit strings of 1s and 0s). Some simulators permit binary, hex, or decimal displays, and others allow data to be displayed as characters (i.e., the data is assumed to <span class="No-Break">be ASCII-encoded).</span></p>&#13;
			<p lang="en-GB">As well as choosing the base in which we display numbers, we must choose the formatting in order to make it easy to read (e.g., aligning groups of characters). Like all high-level computer languages, Python provides ways of formatting printed data. And like formatting in most other languages, I am tempted to describe Python’s formatting as a <span class="No-Break">bit inelegant.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We do not have the space to do justice to Python’s formatting here. We simply provide some examples and enough information for you to <span class="No-Break">modify them.</span></p>&#13;
			<p lang="en-GB">One thing we need to print in a simulator is the instruction. That could not be simpler because it’s a string. So, we can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>print(listing[<strong class="bold">pcOld</strong>])          <span class="sc-comment"># Listing contains a list of string instructions</span></span></pre>&#13;
			<p lang="en-GB">This looks up the string item (instruction) at the <strong class="source-inline">pcOld</strong> address and prints it. Since <strong class="source-inline">pc</strong> is modified during an instruction cycle, we print the old value at the start of the <span class="No-Break">current cycle.</span></p>&#13;
			<p lang="en-GB">But each instruction is going to be of a different length (depending on the number of operands), and that means the next item printed on the same line will not be vertically aligned. We often need to print the instruction within a predefined frame. We can do this with <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>print("<strong class="bold">{:&lt;23}</strong>"<strong class="bold">.format</strong>(listing[pcOld]))</span></pre>&#13;
			<p lang="en-GB">We are using the<strong class="source-inline">.format()</strong>method. The <strong class="source-inline">"{:&lt;23}"</strong> expression controls the format. The integer <strong class="source-inline">23</strong> is the width of the text in characters. The &lt; symbol indicates that the string is left-justified. If we’d wanted it right-justified, we would have used &gt;. The value following <strong class="source-inline">format()</strong> is the string to <span class="No-Break">be printed.</span></p>&#13;
			<p lang="en-GB">Suppose we want to display the eight registers on the same line, each as a six-character hexadecimal value. First, consider the following <span class="No-Break">Python code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>z = 0x4ace          <span class="sc-comment"># The hex data to print</span></span>&#13;
<span>print("%06x" %z)    <span class="sc-comment"># Printing it in 6 chars with leading zeros</span></span></pre>&#13;
			<p lang="en-GB">When executed, this code prints <span class="No-Break">the following:</span></p>&#13;
			<p class="source-code" lang="en-GB">004ace</p>&#13;
			<p lang="en-GB">We set up a variable, <strong class="source-inline">z</strong>, for the <strong class="source-inline">0x4ace</strong> hexadecimal value and use <strong class="source-inline">print("%06x" %z)</strong> to display it as hex characters. The printed value is <strong class="source-inline">004ace</strong> because two leading zeros have been inserted. The formatting mechanism is <strong class="source-inline">"%06x" %z</strong>. The first component, <strong class="source-inline">"</strong>%<strong class="source-inline">06x"</strong>, specifies the format of the six-digit hex value that follows. It’s the first % that indicates the formatting. %<strong class="source-inline">z</strong> indicates the value to <span class="No-Break">be printed.</span></p>&#13;
			<h3 lang="en-GB">The escape character</h3>&#13;
			<p lang="en-GB">Python’s <strong class="source-inline">print</strong> mechanism is easy to use; for example, <strong class="source-inline">print('Answer =',a)</strong> displays anything in quotes as a literal, and the value of any variables that appear in the <strong class="source-inline">print</strong> statement. You can have as many quoted items and variables as <span class="No-Break">you want.</span></p>&#13;
			<p lang="en-GB">The <strong class="source-inline">print</strong> statement also allows formatting by using an <em class="italic">escape character</em> that gives the following character a special meaning. In Python, the escape character is <strong class="source-inline">'</strong> <strong class="source-inline">\'</strong>. If the escape is followed by <strong class="source-inline">'n'</strong>, it is equivalent to a new line; if the escape is followed by <strong class="source-inline">'t'</strong>, it is equivalent to a tab. Consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>a = 42</span>&#13;
<span>b = 'Test'</span></pre>&#13;
			<pre class="source-code">print('a is the integer\t',a,'\nb is the string','\t',b)</pre>&#13;
			<p lang="en-GB">The output from this code is <span class="No-Break">as follows:</span></p>&#13;
			<p class="source-code" lang="en-GB">a is the integer              42</p>&#13;
			<p class="source-code" lang="en-GB">b is the string               Test</p>&#13;
			<p lang="en-GB">Note how this has been printed on two lines due to <strong class="source-inline">'\n'</strong> and the two values tabbed by <strong class="source-inline">'\t'</strong>. You can control the size of the tab, as the following example shows. The <strong class="source-inline">expandtabs()</strong> method sets the tab width (number of spaces) to the parameter provided. In this case, we have embedded the tab into a string and set the tab width <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>print('This is a\ttab\ttest'<strong class="bold">.expandtabs(6)</strong>)</span>&#13;
<span>This is a   tab   test</span></pre>&#13;
			<p lang="en-GB">Some of the other escape sequences are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="source-inline">\’</strong><span class="CharOverride-1">     </span><span class="No-Break">Single quote</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">\\</strong><span class="CharOverride-1">     </span><span class="No-Break">Backslash</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">\r</strong><span class="CharOverride-1">     </span><span class="No-Break">Enter (return)</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">\b</strong><span class="CharOverride-1">     </span><span class="No-Break">Backspace</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">\f</strong><span class="CharOverride-1">     </span>Form feed (move to the same spot on the <span class="No-Break">line below)</span></li>&#13;
				<li lang="en-GB"><strong class="source-inline">\xhh</strong><span class="CharOverride-1">   </span>Hexadecimal character value (e.g., <strong class="source-inline">\x41</strong> would print <strong class="source-inline">A</strong> because <strong class="source-inline">0x41</strong> is the ASCII value <span class="No-Break">for A)</span></li>&#13;
			</ul>&#13;
			<h3 lang="en-GB">Escaping the escape</h3>&#13;
			<p lang="en-GB">There are occasions when you wish to escape the escape character and use the backslash as a printable character. In that case, you precede the string to be printed with either <strong class="source-inline">r</strong> or <strong class="source-inline">R</strong>. Note the <strong class="source-inline">r</strong> letter goes outside the string quotation marks, as in <span class="No-Break">this example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>print(R'test\n one', 'test\n two')</span></pre>&#13;
			<p lang="en-GB">This results in <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>test\n one test</span>&#13;
<span> two</span></pre>&#13;
			<p lang="en-GB">In this example, we use <strong class="source-inline">R</strong> to suppress <strong class="source-inline">\n</strong> as a newline command and print the actual <strong class="source-inline">\n</strong>. The second <strong class="source-inline">\n</strong> is not preceded by <strong class="source-inline">R</strong> and therefore acts as the <span class="No-Break">newline command.</span></p>&#13;
			<h3 lang="en-GB">To and from ASCII</h3>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">I was lucky enough to be around at the birth of the microprocessor and I built a Motorola 6000 microprocessor system from the individual chips (including the display). At that time, I did not have any commercial software and I had to convert between ASCII characters and their numeric values myself. Life is easier today. Python provides two functions that allow you to convert between numeric and ASCII values. These are <strong class="source-inline">ord()</strong> and <strong class="source-inline">chr()</strong>. If you write <strong class="source-inline">x = ord('B')</strong>, the value of <strong class="source-inline">x</strong> would be its ASCII equivalent, <strong class="source-inline">0x42</strong> or <strong class="source-inline">01000010</strong> in binary. Similarly, if you write <strong class="source-inline">y = chr(0x41)</strong>, the value of <strong class="source-inline">y</strong> would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">'A'</strong></span><span class="No-Break">.</span></p>&#13;
			<h4 lang="en-GB">Binary and hexadecimal strings</h4>&#13;
			<p lang="en-GB">Before we look at formatted strings in detail, consider the following simple example of console input using the Python interpreter. The text in bold is <span class="No-Break">the output:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; x = 12345</span>&#13;
<span>&gt;&gt;&gt; y = hex(x)</span>&#13;
<span>&gt;&gt;&gt; print(y)</span>&#13;
<span><strong class="bold">0x3039</strong></span>&#13;
<span>&gt;&gt;&gt; z = y + 1</span>&#13;
<span><strong class="bold">TypeError: can only concatenate str (not "int") to str</strong></span>&#13;
<span>&gt;&gt;&gt; z = int(y,16) + 1</span>&#13;
<span>&gt;&gt;&gt; print (z)</span>&#13;
<span><strong class="bold">12346</strong></span>&#13;
<span>&gt;&gt;&gt; print(hex(z))</span>&#13;
<span><strong class="bold">0x303a</strong></span></pre>&#13;
			<p lang="en-GB">We create an <strong class="source-inline">x</strong> variable equal to <strong class="source-inline">12345</strong> and create a new <strong class="source-inline">y</strong> value that is the hex version of <strong class="source-inline">x</strong>. Then, we print it and get the expected result of <strong class="source-inline">0x3039</strong>. Next, we create a new variable, <strong class="source-inline">z</strong>, where <strong class="source-inline">z = y + 1</strong>. This generates an error message because <strong class="source-inline">y</strong> is a text string and we cannot add the integer <strong class="source-inline">1</strong> to it. In the next line, we perform the addition again, but this time, we convert the hex string into integer form with <strong class="source-inline">int(y,16)</strong>. Now, we can print <strong class="source-inline">z</strong> as a decimal integer or as a hexadecimal string using <strong class="source-inline">print(hex(z))</strong>. In short, Python makes it easy to handle decimal, hexadecimal, and binary values, but you must be very careful to remember to ensure that you convert between string and integer forms <span class="No-Break">where necessary.</span></p>&#13;
			<p lang="en-GB">Because we are dealing with binary numbers, it makes sense to display the output of TC1 in binary or hexadecimal formats. Suppose we wish to convert a decimal integer value into a <em class="italic">binary</em> string. Consider the following where we convert an integer, <strong class="source-inline">p</strong>, into a binary string and then <span class="No-Break">print it:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>p = 1022</span>&#13;
<span>q = "{0:b}".format(p)</span>&#13;
<span>print('p in decimal is',p, "and in binary, it's",q)</span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">"{0:b}"</strong> expression is the key to the formatting. It is a string enclosed in curly brackets. <strong class="source-inline">0</strong> tells it to print from the first character of the string and <strong class="source-inline">b</strong> signifies binary. This produces the <span class="No-Break">following output:</span></p>&#13;
			<p class="source-code" lang="en-GB">p in decimal is 1022 and in binary, it's 1111111110</p>&#13;
			<p lang="en-GB">So far, so good. But what if we want the output to be justified with a fixed number of characters – for example, 16? The following demonstrates such formatting when we convert 26 and <strong class="source-inline">2033</strong> into <span class="No-Break">binary format:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>p1, p2 = 26, 2033</span>&#13;
<span>q1 = "{0:<strong class="bold">16</strong>b}".<strong class="bold">format(p1)</strong></span>&#13;
<span>q2 = "{0:<strong class="bold">16</strong>b}".<strong class="bold">format(p2)</strong></span></pre>&#13;
			<pre class="source-code">print('p1 is',q1, '\nand p2 is',q2)</pre>&#13;
			<p lang="en-GB">The only change to the format string is from <strong class="source-inline">"{0:b}"</strong> to <strong class="source-inline">"{0:16b}"</strong>. That is, we have inserted the field-width of 16 characters before b. The effect of <strong class="source-inline">16</strong> is to define a 16-bit width for the string. The string is padded with spaces on the left. The output of this code is <span class="No-Break">as follows:</span></p>&#13;
			<p class="source-code" lang="en-GB">p1 is            11010</p>&#13;
			<p class="source-code" lang="en-GB">p2 is      11111110001</p>&#13;
			<p lang="en-GB">In a lot of computer texts, it is normal to pad binary and decimal values with leading zeros on the left, rather than spaces. We can do this with a small change in the format. We insert <strong class="source-inline">0</strong> before the field width – that is, <strong class="source-inline">"{0:0</strong>16<strong class="source-inline">b}"</strong>. Now consider <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>p1, p2 = 26, 2033</span>&#13;
<span>q1 = "{0:<strong class="bold">016</strong>b}".format(p1)</span>&#13;
<span>q2 = "{0:<strong class="bold">016</strong>b}".format(p2)</span>&#13;
<span>print('p1 is',q1, '\nand p2 is',q2)</span></pre>&#13;
			<p lang="en-GB">This gives an output where the numbers are displayed in 16 bits and padded with leading zeros, <span class="No-Break">as follows:</span></p>&#13;
			<p class="source-code" lang="en-GB">p1 is 0000000000011010</p>&#13;
			<p class="source-code" lang="en-GB">p2 is 0000011111110001</p>&#13;
			<p lang="en-GB">Hexadecimal values are treated in the same way by substituting <strong class="source-inline">x</strong> for <strong class="source-inline">b</strong> in the <span class="No-Break"><strong class="source-inline">format</strong></span><span class="No-Break"> statement:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>p1, p2 = 30, 64123</span>&#13;
<span>q1 = "{0:8x}".format(p1)</span>&#13;
<span>q2 = "{0:8x}".format(p2)</span>&#13;
<span>q3 = "{0:08x}".format(p1)</span>&#13;
<span>q4 = "{0:08x}".format(p2)</span>&#13;
<span>print('\n', q1, '\n', q3, '\n', q2, '\n', q4)</span></pre>&#13;
			<p lang="en-GB">This gives the following output. As you can see, it’s analogous to the <span class="No-Break">binary version:</span></p>&#13;
			<p class="source-code" lang="en-GB">       1e</p>&#13;
			<p class="source-code" lang="en-GB"> 0000001e</p>&#13;
			<p class="source-code" lang="en-GB">     fa7b</p>&#13;
			<p class="source-code" lang="en-GB"> 0000fa7b</p>&#13;
			<p lang="en-GB">Of course, we can combine both print formats (i.e., binary and hexadecimal), as in <span class="No-Break">this example:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x, y = 1037, 325</span>&#13;
<span>xBin = "{0:016b}".format(x)</span>&#13;
<span>yHex = "{0:04x}".format(y)</span>&#13;
<span>print("x is",xBin,"y is",yHex)</span></pre>&#13;
			<pre class="source-code">print("x is","0b" + xBin,"y is","0x" + yHex)</pre>&#13;
			<p lang="en-GB">We print two numbers, one in a binary format and one in a hexadecimal format. In the first case, the number is padded to 16 bits with leading zeros, and in the second case, it’s padded to 4 characters with <span class="No-Break">leading zeros.</span></p>&#13;
			<p lang="en-GB">We print the result twice. In the second case, prefixes are added to the values to indicate the base. If the first number, <strong class="source-inline">xBin</strong>, is binary, we can concatenate “<strong class="source-inline">0b</strong>” simply by using a “+” symbol to add <strong class="source-inline">0b</strong> immediately before the binary string. The output from this code is <span class="No-Break">as follows:</span></p>&#13;
			<p class="source-code" lang="en-GB">x is 0000010000001101 y is 0145</p>&#13;
			<p class="source-code" lang="en-GB">x is 0b0000010000001101 y is 0x0145</p>&#13;
			<p lang="en-GB">We can generalize the string method format as <strong class="source-inline">"someString".format(&lt;parameter list&gt;</strong>. This string method takes the string and inserts parameters into it that appear in the parameter list. You have to insert <em class="italic">placeholders</em> in the form of <strong class="source-inline">{a:b}</strong> into the string, which will receive the parameters when the string <span class="No-Break">is printed.</span></p>&#13;
			<p lang="en-GB">Suppose you were printing a table of the powers of integers in the form x, x<span class="superscript">2</span>, x<span class="superscript">3</span>, x<span class="superscript">4</span>. We could write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for x in range (1,7):</span>&#13;
<span>    print("Table of powers {<strong class="bold CharOverride-2">0</strong>:<strong class="bold CharOverride-2">2d</strong>}{<strong class="bold CharOverride-2">1</strong>:<strong class="bold CharOverride-2">3d</strong>}{<strong class="bold CharOverride-2">2</strong>:<strong class="bold CharOverride-2">4d</strong>}{<strong class="bold CharOverride-2">3</strong>:<strong class="bold CharOverride-2">6d</strong>}"<strong class="bold CharOverride-2">.format(x,x**2,x**3,x**4)</strong>)</span></pre>&#13;
			<p lang="en-GB">Each parameter placeholder is of the form<strong class="source-inline">{</strong>a<strong class="source-inline">:b}</strong>where the first element, a, is the position of the parameter in the list of parameters in the format. The second element, <strong class="source-inline">b</strong>, determines how the parameter is printed. In this case, it is a number and the letter <strong class="source-inline">d</strong>. The number defines the parameter’s width, and <strong class="source-inline">d</strong> indicates that it’s decimal; for example, the last parameter is specified as <strong class="source-inline">{</strong>3<strong class="source-inline">:6d}</strong>, which indicates the fourth parameter is a decimal integer taking six places. The following demonstrates the output from this fragment <span class="No-Break">of code:</span></p>&#13;
			<p class="source-code" lang="en-GB">Table of powers  1   1    1      1</p>&#13;
			<p class="source-code" lang="en-GB">Table of powers  2   4    8     16</p>&#13;
			<p class="source-code" lang="en-GB">Table of powers  3   9   27     81</p>&#13;
			<p class="source-code" lang="en-GB">Table of powers  4  16   64    256</p>&#13;
			<p class="source-code" lang="en-GB">Table of powers  5  25  125    625</p>&#13;
			<p class="source-code" lang="en-GB">Table of powers  6  36  216   1296</p>&#13;
			<p lang="en-GB">In order to demonstrate the versatility of this approach, the next example prints the same table of powers but using a different format. As well as decimal, we also use binary and hexadecimal. Note that you only have to change b in <strong class="source-inline">{</strong>a<strong class="source-inline">:b}</strong> to change the base; for example, <strong class="source-inline">{</strong>6<strong class="source-inline">:x}</strong> tells the <strong class="source-inline">print</strong> statement to print the seventh parameter in <span class="No-Break">hexadecimal format:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for x in range (1,10):</span>&#13;
<span>    print('Table of powers {0:2d} binary {1:10b} {2:4d} \</span>&#13;
<span>    hex {3:6x}'.format(x, x*x, x*x*x, x*x*x*x))</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Note you can write x*x*x, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">x**3</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The following output demonstrates the results of this <span class="No-Break">formatting technique:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Table of powers  1 binary          1    1 hex      1</span>&#13;
<span>Table of powers  2 binary        100    8 hex     10</span>&#13;
<span>Table of powers  3 binary       1001   27 hex     51</span>&#13;
<span>Table of powers  4 binary      10000   64 hex    100</span>&#13;
<span>Table of powers  5 binary      11001  125 hex    271</span>&#13;
<span>Table of powers  6 binary     100100  216 hex    510</span>&#13;
<span>Table of powers  7 binary     110001  343 hex    961</span>&#13;
<span>Table of powers  8 binary    1000000  512 hex   1000</span>&#13;
<span>Table of powers  9 binary    1010001  729 hex   19a1</span></pre>&#13;
			<p lang="en-GB">We have repeated the example with a few modifications. It is not necessary to give the order of the parameters if they are to be printed sequentially; for example, the first parameter specification can be written as <strong class="source-inline">{:2d}</strong> instead of <strong class="source-inline">{0:2d}</strong>. We’ve also changed the spacing to demonstrate how the width <span class="No-Break">parameters operate:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for x in range (1,10):</span>&#13;
<span>    print('Powers {:2d} binary {:8b}{:4d} hex{:6x}'.format(x,x**2, x**3, x**4))</span>&#13;
<span>Powers  1 binary        1    1 hex      1</span>&#13;
<span>Powers  2 binary      100    8 hex     10</span>&#13;
<span>Powers  3 binary     1001   27 hex     51</span>&#13;
<span>Powers  4 binary    10000   64 hex    100</span>&#13;
<span>Powers  5 binary    11001  125 hex    271</span>&#13;
<span>Powers  6 binary   100100  216 hex    510</span>&#13;
<span>Powers  7 binary   110001  343 hex    961</span>&#13;
<span>Powers  8 binary  1000000  512 hex   1000</span>&#13;
<span>Powers  9 binary  1010001  729 hex   19a1</span></pre>&#13;
			<p lang="en-GB">Consider the following examples of the <strong class="source-inline">format</strong> mechanism. Here, we use the symbols “<strong class="source-inline">&lt;</strong>, <strong class="source-inline">&gt;</strong>, <strong class="source-inline">^</strong>” to control formatting. In order, these symbols force left justification, right justification, and centering within the <span class="No-Break">stated width.</span></p>&#13;
			<p lang="en-GB">The following code prints the decimal integer <strong class="source-inline">123</strong> first in decimal form, using the three modifiers, and then in binary form using the same three modifiers. In each case, we have specified a width of <span class="No-Break">10 characters:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = 123</span>&#13;
<span>print(<strong class="bold">'{:&lt;10d}'</strong>.format(x))</span>&#13;
<span>print(<strong class="bold">'{:&gt;10d}'</strong>.format(x))</span>&#13;
<span>print(<strong class="bold">'{:^10d}'</strong>.format(x))</span>&#13;
<span>print(<strong class="bold">'{:&lt;10b}'</strong>.format(x))</span>&#13;
<span>print(<strong class="bold">'{:&gt;10b}'</strong>.format(x))</span></pre>&#13;
			<pre class="source-code">print(<strong class="bold">'{:^10b}'</strong>.format(x))</pre>&#13;
			<p lang="en-GB">The output generated by this code is <span class="No-Break">as follows:</span></p>&#13;
			<p class="source-code" lang="en-GB">123                                   <span class="sc-comment">Left-justified</span></p>&#13;
			<p class="source-code" lang="en-GB">       123                            <span class="sc-comment">Right-justified</span></p>&#13;
			<p class="source-code" lang="en-GB">   123                                <span class="sc-comment">Centered</span></p>&#13;
			<p class="source-code" lang="en-GB">1111011                               <span class="sc-comment">Left-justified</span></p>&#13;
			<p class="source-code" lang="en-GB">   1111011                            <span class="sc-comment">Right-justified</span></p>&#13;
			<p class="source-code" lang="en-GB"> 1111011                              <span class="sc-comment">Centered</span></p>&#13;
			<p lang="en-GB">We are now going to provide three examples of how strings representing numbers can be printed. The first demonstrates the formatting of individual numbers in integer, hexadecimal, binary, and real forms. The second example shows how we can take a list of registers, join them as a single string, and print their values. This is very useful in displaying data when stepping through instructions during a simulation. The third example demonstrates the successive steps in processing a hexadecimal value into the <span class="No-Break">desired format.</span></p>&#13;
			<h3 lang="en-GB">Example 1 – Formatting numbers</h3>&#13;
			<p lang="en-GB">The following demonstrates this formatting mechanism, where we print several variables and a string. This uses a format specifier such as <strong class="source-inline">%05d</strong>, which means five decimal digits with leading zeros, and a placeholder such as <strong class="source-inline">%x</strong>, which means print the value of <strong class="source-inline">x</strong> in the format specified <span class="No-Break">by %05d:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>x = 123</span>&#13;
<span>y = 0xABCD</span>&#13;
<span>p = 13.141592</span>&#13;
<span>q ='This is a test'</span>&#13;
<span>print("Hex example: %03x" %y, "%05d" %x, 'Alan', "%12.3f" %p, '%-20.14s' %q)</span></pre>&#13;
			<p lang="en-GB">This <strong class="source-inline">print</strong> statement displays the following (note hexadecimal appears <span class="No-Break">in lowercase):</span></p>&#13;
			<p class="source-code" lang="en-GB">Hex example: abcd 00123 Alan       13.142 This is a test</p>&#13;
			<h3 lang="en-GB">Example 2 – Printing a list of register values in hexadecimal form</h3>&#13;
			<p lang="en-GB">Consider the following expression with an 8-register array filled with data in <span class="No-Break">various formats:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>R = [0xabcd,2,3,0x123,5,0x11010,7,124]</span>&#13;
<span>print('Registers =',<strong class="bold">" ".join</strong>(<strong class="bold">"%04x" % b for b in R</strong>))</span></pre>&#13;
			<p lang="en-GB">This expression prints the string ‘<strong class="source-inline">Registers =</strong>’<strong class="source-inline">,</strong> followed by a second string that contains eight four-character hexadecimal values. To create the second string, we use the string <strong class="source-inline">join()</strong> method. The string comprehension iterates over the registers applying the formatting structure to each element. That is, it reads <strong class="source-inline">r[0]</strong>, converts it into a string format, and then joins it to its left-hand neighbor (which is initially an empty string). This is repeated eight times and then that string is printed <span class="No-Break">as follows:</span></p>&#13;
			<p class="source-code">Registers = abcd 0002 0003 0123 0005 11010 0007 007c</p>&#13;
			<h3 lang="en-GB">Example 3 – Successively processing a decimal value into the desired hex format</h3>&#13;
			<p lang="en-GB">Consider the following sequence where we successively process the decimal value 44,350 until it is displayed in hexadecimal format in uppercase without the <strong class="source-inline">0x</strong> <span class="No-Break">indicator prefix:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>&gt;&gt;&gt; x = 44350                              <span class="sc-comment">Here's a decimal number</span></span>&#13;
<span>&gt;&gt;&gt; print(<strong class="bold">hex(x)</strong>)                          <span class="sc-comment">Can I see that in hex?</span></span>&#13;
<span>0xad3e                                     <span class="sc-comment">Thanks. But I like uppercase hex</span></span>&#13;
<span>&gt;&gt;&gt; print(hex(x)<strong class="bold">.upper())</strong>                  <span class="sc-comment">OK. We just use the .upper() method on the string.</span></span>&#13;
<span>0XAD3E                                     <span class="sc-comment">Nice one. But I don't like 0X at the front.</span></span>&#13;
<span>&gt;&gt;&gt; print(hex(x).upper()<strong class="bold">[2:]</strong>)              <span class="sc-comment">OK, OK, just use slice notation [2:] to strip 0X.</span></span>&#13;
<span>AD3E                                       <span class="sc-comment">Great. Can I have that with fries?</span></span></pre>&#13;
			<p lang="en-GB">We have described, briefly, how numbers can be formatted. Formatting is necessary if the printed output is to be read by humans, especially if you are simulating a computer where patterns of 1s and 0s are important. There are several ways of formatting data, and this section provided only an introduction to <span class="No-Break">this topic.</span></p>&#13;
			<h1 id="_idParaDest-123" lang="en-GB"><a id="_idTextAnchor126"/>Input validation</h1>&#13;
			<p lang="en-GB">In this section, I will introduce the notion of data validation. Historically, some of the major errors involving computers have been caused by a failure to check input data. TC1 doesn’t perform source data checking; you can write <strong class="source-inline">ADDL R1,R2,10</strong> or <strong class="source-inline">ADDL z1,z2,10</strong> with the same result. Why? Because when the assembler sees <strong class="source-inline">ADDL</strong>, it looks for three parameters. It takes the first parameter, let’s call this <strong class="source-inline">p1</strong>, and reads the register number by <strong class="source-inline">regnum = int(</strong>p1[1:]<strong class="source-inline">)</strong>. Only the second and successive characters of <strong class="source-inline">p1</strong> are recorded, and the “R” is ignored. You can write <strong class="source-inline">R1</strong> or even <strong class="source-inline">?1</strong>. This makes programming in assembly language easier; you can use any letter you want to represent a register. On the other hand, it encourages poor programming techniques and increases the dangers associated with <span class="No-Break">mistyped input.</span></p>&#13;
			<h2 id="_idParaDest-124" lang="en-GB"><a id="_idTextAnchor127"/>Validating data</h2>&#13;
			<p lang="en-GB">Since the TC1 assembler doesn’t perform error-checking on the input, if you make an error, it’s likely that the program will crash, leaving you to do your own debugging. Good software performs error-checking, which ranges from the simple detection of invalid instructions to the exact pinpointing of <span class="No-Break">all errors.</span></p>&#13;
			<p lang="en-GB">Here, we demonstrate how you can read a line of code and check for several types of common errors – for example, invalid opcodes, invalid instruction formats (too many or two few operands), typos (typing <strong class="source-inline">T6</strong> instead of <strong class="source-inline">R6</strong>), and registers out of range (<span class="No-Break">entering </span><span class="No-Break"><strong class="source-inline">R9</strong></span><span class="No-Break">).</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The purpose of this section is to show how you can add your own modifications to TC1. A formal way of dealing with the problem would be to construct a grammar for the assembly language and then build a parser to determine whether the input conforms to that grammar. We are going to take a simpler and more ad <span class="No-Break">hoc approach.</span></p>&#13;
			<p lang="en-GB">If the current instruction is <strong class="source-inline">x = </strong>'<strong class="source-inline">ADD r1 r2 r3</strong>', the <strong class="source-inline">y = x.split(</strong>' '<strong class="source-inline">)</strong> operation converts it into a list of tokens: <strong class="source-inline">y = [</strong>'<strong class="source-inline">ADD</strong>'<strong class="source-inline">, </strong>'<strong class="source-inline">R1</strong>'<strong class="source-inline">, </strong>'<strong class="source-inline">R2</strong>'<strong class="source-inline">, </strong>'<strong class="source-inline">R3</strong>'<strong class="source-inline">]</strong>. We can extract the first token with <strong class="source-inline">jj = y[0]</strong>, which should be a valid mnemonic (in this example, we are forgetting about <span class="No-Break">any labels).</span></p>&#13;
			<p lang="en-GB">The first test to perform is on the validity of the instruction. Assume that all mnemonics have been defined in a list or directory called <strong class="source-inline">codes</strong>. All we have to do is to look it up in the <strong class="source-inline">codes</strong> directory using <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">if</strong> jj <strong class="bold">not in</strong> codes: error = 1</span></pre>&#13;
			<p lang="en-GB">Python keywords are shaded. This expression sets the <strong class="source-inline">error</strong> variable to <strong class="source-inline">1</strong> if this instruction is not in the dictionary. Then, we can test <strong class="source-inline">error</strong> and take whatever action <span class="No-Break">is necessary.</span></p>&#13;
			<p lang="en-GB">The next step is to use the name of the instruction to look up its details, and then check whether that instruction requires parameters. Remember that our dictionary entries have a two-component tuple, with the first component being the instruction’s format (i.e., the number of operands required) and the second being the actual <span class="No-Break">operation code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>form = codes.<strong class="bold">get</strong>(y[0])   <span class="sc-comment"># Read the 4-bit format code</span></span></pre>&#13;
			<p lang="en-GB">It looks up the instruction (i.e., <strong class="source-inline">y[0]</strong>) in the dictionary and returns its value, which is a tuple, such as <strong class="source-inline">(8:12)</strong>. The first element of the tuple, <strong class="source-inline">form[0]</strong>, describes the instruction’s operands and the second is the opcode (which is not of interest here). The parameters required by the instruction are determined by <strong class="source-inline">form[0]</strong>. Consider the <span class="No-Break">following code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>opType = form[0]                                           <span class="sc-comment"># Get operand info</span></span>&#13;
<span>if   opType == 0:                  totalOperands = 1       <span class="sc-comment"># Just a mnemonic</span></span>&#13;
<span>elif opType == 8  or opType == 1:  totalOperands = 2       <span class="sc-comment"># Mnemonic + 1 operand</span></span>&#13;
<span>elif opType == 12 or opType == 9:  totalOperands = 3       <span class="sc-comment"># Mnemonic + 2 operands</span></span>&#13;
<span>elif opType == 14 or opType == 13: totalOperands = 4       <span class="sc-comment"># Mnemonic + 3</span></span>&#13;
<span>elif opType == 15:                 totalOperands = 5       <span class="sc-comment"># Mnemonic + 4 (not used)</span></span></pre>&#13;
			<p lang="en-GB">The four bits of the format code represent <strong class="source-inline">rD</strong>, <strong class="source-inline">rS1</strong>, <strong class="source-inline">rs2</strong>, and a literal. TC1 instructions have several valid formats; for example, if <strong class="source-inline">opType = 0b</strong><span class="pcode-bold">1</span><strong class="source-inline">00</strong><span class="pcode-bold-bg">1</span><strong class="source-inline"> = 9</strong>, then the format defines an instruction with a destination register and a literal such as <strong class="source-inline">LDRL</strong> <span class="pcode-bold">R3</span> <span class="pcode-bold-bg">25</span>. We’ve used bold and shading to demonstrate the relationship between the bits of the format code and the <span class="No-Break">actual instruction.</span></p>&#13;
			<p lang="en-GB">The preceding code uses an <strong class="source-inline">if…else</strong> to get the length (the number of tokens including the opcode) of each instruction. All we then have to do is to count the number of tokens in the current instruction and see whether it’s the same as the expected value (i.e., the total length). The following code performs <span class="No-Break">this check:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    totalTokens = len(<strong class="bold">y</strong>)                     <span class="sc-comment"># Get the number of tokens in this instruction y</span></span>&#13;
<span>    if totalTokens &lt; totalOperands:          <span class="sc-comment"># Are there enough tokens?</span></span>&#13;
<span>        error = 2                            <span class="sc-comment"># Error 2: Too few operands</span></span>&#13;
<span>        continue</span>&#13;
<span>    if totalTokens &gt; totalOperands:          <span class="sc-comment"># Are there too many tokens?</span></span>&#13;
<span>        error = 3                            <span class="sc-comment"># Error 3: Too many operands </span></span></pre>&#13;
			<pre class="source-code">        continue</pre>&#13;
			<p lang="en-GB">We set the error number to <strong class="source-inline">2</strong> or <strong class="source-inline">3</strong> if the number of tokens doesn’t match the expected value. After both tests, there is a <strong class="source-inline">continue</strong> statement. The effect of <strong class="source-inline">continue</strong> is to drop to the end of the current block and abandon further error-testing (because we know this current instruction is <span class="No-Break">in error).</span></p>&#13;
			<p lang="en-GB">Once we have established a valid instruction and the correct number of operands, the next step is to check each operand. An operand must be of the form <strong class="source-inline">R0</strong> to <strong class="source-inline">R7</strong> (or <span class="No-Break">a literal).</span></p>&#13;
			<p lang="en-GB">We use the format information to test for each operand in turn. Here, we just deal with the first operand, <strong class="source-inline">rD</strong> (the <span class="No-Break">destination register):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if opType &amp; 0b<strong class="bold">1</strong>000 == 0b<strong class="bold">1</strong>000:             <span class="sc-comment"># If the destination register bit is set</span></span>&#13;
<span>        rDname = y[1]                         <span class="sc-comment"># Get the register name (second item in string)</span></span>&#13;
<span>        error,q = syntaxTest(rDname)          <span class="sc-comment"># Call syntax test to look for errors</span></span></pre>&#13;
			<p lang="en-GB">The first line of this code tests whether the leftmost bit of <strong class="source-inline">format</strong> is 1 or 0 by ANDing the format code with <strong class="source-inline">0b1000</strong> and testing for <strong class="source-inline">0b1000</strong>. If the result is <strong class="source-inline">true</strong>, then we need to check for the first register operand, which is the second token – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">y[1]</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Because we are going to test for three operands, we have created a <strong class="source-inline">syntaxText</strong> function that takes the token as a parameter and returns two parameters: <strong class="source-inline">error</strong> and <strong class="source-inline">q</strong>. The value of <strong class="source-inline">error</strong> is the error code returned (<strong class="source-inline">0</strong> for no error, and <strong class="source-inline">q</strong> is the number of the register). The Python code for the <strong class="source-inline">syntaxTest</strong> function is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def syntaxTest(token):                         <span class="sc-comment"># Test register for validity (R0 to R7)</span></span>&#13;
<span>    if token[0] != 'R': return(4,0)            <span class="sc-comment"># Fail on missing initial R. Return error 4</span></span>&#13;
<span>    if not token[1:].isnumeric(): return(5,0)  <span class="sc-comment"># Fail on missing register number. Return 5</span></span>&#13;
<span>    if int(token[1:]) &gt; 7: return(6,0)         <span class="sc-comment"># Fail on register number not in 0-7. Return 6</span></span>&#13;
<span>    return(0,int(token[1:]))                   <span class="sc-comment"># OK so return with error 0 and reg number</span></span></pre>&#13;
			<p lang="en-GB">Three tests are performed, one for each type of error that we are looking for. The first test is to check whether the first character of the token is <strong class="source-inline">'R'</strong> . If it is not <strong class="source-inline">'R'</strong> , a return is made with the error code <strong class="source-inline">4</strong>, and the dummy or default register number is set to <strong class="source-inline">0</strong>. The second test looks for a numeric value for the register (the characters following the <strong class="source-inline">'R'</strong>, which is <strong class="source-inline">token[1:]</strong>). The third test checks whether the number is greater than <strong class="source-inline">7</strong> and returns an error code if it is. Finally, when the last line is reached, a return is made with the error code <strong class="source-inline">0</strong> and the appropriate register number. Note that we don’t need to use an <strong class="source-inline">elif</strong> because if an <strong class="source-inline">if</strong> yields <strong class="source-inline">True</strong>, the code is exited <span class="No-Break">via </span><span class="No-Break"><strong class="source-inline">return()</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">This routine is called up to three times in the event of an instruction having a format code of <strong class="source-inline">0b1110</strong> corresponding to a register-to-register operation such as <strong class="source-inline">ADD R1 R2 R3</strong>. In this exercise, we do not check the literal. If you wish to add that check, it would be necessary to check for an integer in the range 0 to 65,535 or -32,766 to 32,755 (plus a number beginning with <strong class="source-inline">%</strong> if it’s binary or <strong class="source-inline">0x</strong> if <span class="No-Break">it’s hexadecimal).</span></p>&#13;
			<h3 lang="en-GB">Using the <strong class="source-inline">continue</strong> statement</h3>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">When testing for errors, do you test for each error in a statement or do you stop once you have found <span class="No-Break">an error?</span></p>&#13;
			<p lang="en-GB">The code uses a <strong class="source-inline">continue</strong> statement whenever an error is found to bypass further testing. An unfortunate side effect is that <strong class="source-inline">continue</strong> takes you past the end of the loop and begins the next iteration; that is, you can’t print the nature of the error. The solution is to print any errors found in the previous iteration at the start of the loop. Of course, this causes a problem on the first iteration because there is no previous error value. That is easily fixed by setting <strong class="source-inline">error</strong> to zero before beginning the loop. The following code demonstrates <span class="No-Break">this approach:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>run = 1</span>&#13;
<span>error = 0</span>&#13;
<span>while run == 1:</span>&#13;
<span>    if error != 0: printError(error)</span>&#13;
<span>       .</span>&#13;
<span>       .</span>&#13;
<span>       &lt;test for error 1&gt;</span>&#13;
<span>    if error != 0: continue</span>&#13;
<span>        &lt;test for error 2&gt;</span>&#13;
<span>    if error != 0: continue</span>&#13;
<span>       .</span>&#13;
<span>       &lt;test for error n&gt;</span>&#13;
<span>    if error != 0: continue</span></pre>&#13;
			<p lang="en-GB">In this fragment of code, <strong class="source-inline">error</strong> is tested to determine whether an error occurred in the previous cycle. If <strong class="source-inline">error</strong> is not <strong class="source-inline">0</strong>, the <strong class="source-inline">printError</strong> function is called to print the error number and type. Using a function code to do the printing enhances the readability of <span class="No-Break">the program.</span></p>&#13;
			<p lang="en-GB">The code for an error-testing routine is given next. This is not intended to be a complete program, but a demonstration of the way in which you can extend a program to include error-testing on the <span class="No-Break">input data:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span># Testing Python parsing # 22 Aug 2020 Version of 29 July 2021</span>&#13;
<span>import sys                                    <span class="sc-comment"># System library used to exit program</span></span>&#13;
<span>codes = {'NOP':(0,0), 'STOP': (0,1),'BEQ':(1,4), 'INC':(8,2), \</span>&#13;
<span>         'MOVE':(12,23), 'LDRL':(9,13), 'ADD':(14,12),'ADDL':(13,12)}</span>&#13;
<span>def syntaxTest(token):               <span class="sc-comment"># Test the format of a register operand for validity (R0 to R7)</span></span>&#13;
<span>    if token[0] != 'R': return(4,0)           <span class="sc-comment"># Fail on missing initial R. Return error 2</span></span>&#13;
<span>    if not token[1:].isnumeric(): return(5,0) <span class="sc-comment"># Fail on missing register number. Return error 3</span></span>&#13;
<span>    if int(token[1:]) &gt; 7: return(6,0)  <span class="sc-comment"># Fail on register number not in range 0-7. Return error 4</span></span>&#13;
<span>    return(0,int(token[1:]))            <span class="sc-comment"># Success return with error code 0 and register number</span></span>&#13;
<span>def printError(error):</span>&#13;
<span>    if error != 0:</span>&#13;
<span>        if error == 1: print("Error 1: Non-valid operation")</span>&#13;
<span>        if error == 2: print("Error 2: Too few operands")</span>&#13;
<span>        if error == 3: print("Error 3: Too many operands")</span>&#13;
<span>        if error == 4: print("Error 4: Register operand error- no 'R'")</span>&#13;
<span>        if error == 5: print("Error 5: Register operand error - no valid num")</span>&#13;
<span>        if error == 6: print("Error 6: Register operand error - not in range")</span>&#13;
<span>run = 1</span>&#13;
<span>error = 0</span>&#13;
<span>while run == 1:</span>&#13;
<span>    if error != 0: printError(error)    <span class="sc-comment"># if error not zero, print message</span></span>&#13;
<span>    x = input("\nEnter instruction &gt;&gt; ")<span class="sc-comment"># Type an instruction (for testing)</span></span>&#13;
<span>    x =  x.upper()                      <span class="sc-comment"># Convert lowercase into uppercase</span></span>&#13;
<span>    x = x.replace(',',' ')              <span class="sc-comment"># Replace comma with space to allow add r1,r2 or add r1 r2</span></span>&#13;
<span>    y = x.split(' ')                    <span class="sc-comment"># Split into tokens. y is the tokenized instruction</span></span>&#13;
<span>    if len(y) &gt; 0:                      <span class="sc-comment"># z is the predicate (or null if no operands)</span></span>&#13;
<span>        z = y[1:]</span>&#13;
<span>    else: z  = ''</span>&#13;
<span>    print("Inst =",y, 'First token',y[0])</span>&#13;
<span>    if y[0] not in codes:               <span class="sc-comment"># Check for valid opcode</span></span>&#13;
<span>        error = 1                       <span class="sc-comment"># Error 1: instruction not valid</span></span>&#13;
<span>        print("Illegal instruction", y[0])</span>&#13;
<span>        continue</span>&#13;
<span>    form = codes.get(y[0])              <span class="sc-comment"># Get the code's format information</span></span>&#13;
<span>    print('Format', form)</span>&#13;
<span>    if form[1] == 1:                    <span class="sc-comment"># Detect STOP, opcode value 1,and terminate</span></span>&#13;
<span>        print("\nProgram terminated on STOP")  # Say "Goodbye"</span>&#13;
<span>        sys.exit()                      <span class="sc-comment"># Call OS function to leave</span></span>&#13;
<span>    opType = form[0]</span>&#13;
<span>    if   opType == 0:                                  totalOperands = 1</span>&#13;
<span>    elif opType == 8  or opType == 4  or opType == 1:  totalOperands = 2</span>&#13;
<span>    elif opType == 12 or opType == 9:                  totalOperands = 3</span>&#13;
<span>    elif opType == 14 or opType == 13:                 totalOperands = 4</span>&#13;
<span>    totalTokens = len(y)                <span class="sc-comment"># Compare tokens we have with those we need</span></span>&#13;
<span>    if totalTokens &lt; totalOperands:</span>&#13;
<span>        error = 2                       <span class="sc-comment"># Error 2: Too few operands</span></span>&#13;
<span>        <span class="sc-comment">continue</span></span>&#13;
<span>    if totalTokens &gt; totalOperands:</span>&#13;
<span>        error = 3                       <span class="sc-comment"># Error 3: Too many operands</span></span>&#13;
<span>        <span class="sc-comment">continue</span></span>&#13;
<span>    if opType &amp; 0b1000 == 0b1000:</span>&#13;
<span>        rDname = y[1]</span>&#13;
<span>        error,q = syntaxTest(rDname)</span>&#13;
<span>        if error != 0: continue</span>&#13;
<span>    if opType &amp; 0b0100 == 0b0100:</span>&#13;
<span>        rS1name = y[2]</span>&#13;
<span>        error,q = syntaxTest(rS1name)</span>&#13;
<span>        if error != 0: continue</span>&#13;
<span>    if opType &amp; 0b0010 == 0b0010:</span>&#13;
<span>        rS2name = y[3]</span>&#13;
<span>        error,q = syntaxTest(rS2name)</span>&#13;
<span>        if error != 0: continue</span>&#13;
<span>    if opType &amp; 0b0001 == 0b0001:</span>&#13;
<span>        if not y[-1].isnumeric():</span>&#13;
<span>            error == 7</span>&#13;
<span>            print("Error 7: Literal error")</span>&#13;
<span>    if error == 0:</span>&#13;
<span>       print("Instruction", x, "Total operands", totalOperands,"Predicate", z)</span></pre>&#13;
			<h3 lang="en-GB">Checking parameters – using dictionaries</h3>&#13;
			<p lang="en-GB">The next example provides another look at parameter checking. It examines the mnemonic and predicate of each instruction and checks whether it represents a valid operation. It stops after finding an error. In other words, it will detect only one error in <strong class="source-inline">INC R9,R2</strong> even though there are two errors (i.e., too many operands and the first operand is out <span class="No-Break">of range).</span></p>&#13;
			<p lang="en-GB">We also expand the use of the Python dictionary. Previously, we tested for a valid register operand by checking that the initial character was ‘R’ and that this was followed by a number in the range of 0 to 7. Since there are only eight register names (R0 to R7), it’s easy to employ a dictionary in <span class="No-Break">error checking:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>regSet = {'R0':0, 'R1':1, 'R2':2, 'R3':3, 'R4':4, 'R5':5, 'R6':6, 'R7':7}</span></pre>&#13;
			<p lang="en-GB">The dictionary, <strong class="source-inline">regSet</strong>, contains the register names (the keys) and the corresponding value. Because we do so much register checking, it’s convenient to create a function, <strong class="source-inline">regTest</strong>, to perform the check. This function takes two parameters. The first is a string, <strong class="source-inline">tokNam</strong>, that gives the register a name, and the second parameter is the token being tested – for example, <strong class="source-inline">regTest('rD',predicate[0])</strong>. The reason for passing a name to the function is so that the function can print the name of the operand <span class="No-Break">in error.</span></p>&#13;
			<p lang="en-GB">The function returns two values: an error code and the number of the register. If an error is detected, the register value of <strong class="source-inline">0</strong> is returned as a default. The function is <span class="No-Break">given here:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def regTest(tokNam,token):           <span class="sc-comment"># Test format of a register operand for validity (R0 to R7)</span></span>&#13;
<span>    if token in regSet:              <span class="sc-comment"># Is it in the register set?</span></span>&#13;
<span>        return (0,regSet.get(token)) <span class="sc-comment"># If it's there, return 0 and token value</span></span>&#13;
<span>    else:                            <span class="sc-comment"># If not there, return error code 4 and the token's name</span></span>&#13;
<span>        print("Error in register ",tokNam)</span>&#13;
<span>        return (4,0)</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Testing for validity is easy. The <strong class="source-inline">if token in regSet:</strong> condition checks whether this parameter is in the register set. If it is, we read the value of the register from the dictionary and return its value. If the token is not in the register set, an error message is printed (using <strong class="source-inline">tokNam</strong> to display the faulty value), and an error message number <strong class="source-inline">4</strong> is <span class="No-Break">reported back.</span></p>&#13;
			<p lang="en-GB">Using <strong class="source-inline">regSet.get(token)</strong> is a little heavy-handed. We do not actually need to read the register value. If it is in the set of valid registers, we can use <strong class="source-inline">int(token[1])</strong> to extract the register number from the name. The advantage of using the dictionary mechanism is that we can amend the code to add new registers such as <strong class="source-inline">SP</strong>, <strong class="source-inline">PC</strong>, and so on if we want. We can rename registers or even use aliases; for example, if we use the <strong class="source-inline">R7</strong> register as a temporary register, we could enter <strong class="source-inline">, {. . . 'R6':6, 'R7':7, </strong><span class="pcode-bold">'T':7</span><strong class="source-inline">}</strong> and then write either <strong class="source-inline">INC R7</strong> or <span class="No-Break"><strong class="source-inline">INC T</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We have also experimented with a new instruction dictionary. Some of the information in the dictionary is redundant because it can be derived from other information (e.g., the length can be derived from the format). However, we adopted the following system because we may change the program at a <span class="No-Break">later date.</span></p>&#13;
			<p lang="en-GB">In the previous version of the assembler, we used a dictionary in which each entry had a key that was a mnemonic and a two-element tuple – for example, <strong class="source-inline">'INC':(8,12)</strong>. The first element of the tuple was a format code that expressed the operands required by the mnemonic, and the second element was the <span class="No-Break">instruction’s opcode.</span></p>&#13;
			<p lang="en-GB">In this example, we are using a four-element tuple to provide the <span class="No-Break">following information:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB"><strong class="bold">Format</strong>: The format is a decimal number in the range 0 to 15, representing a 4-bit binary value. The 1s in the binary format indicate the operands required by the instruction in the order: <strong class="source-inline">rD, rS1, rS2, literal</strong> (<span class="No-Break">as before).</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Style</strong>: The style describes the class of instruction – for example, mnemonic only, mnemonic plus literal, mnemonic plus register plus literal, and so on. There is a direct relationship between format <span class="No-Break">and style.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Length</strong>: The length gives the number of tokens in the instruction – that is, the mnemonic plus its operands. This is equivalent to the number of 1s in the format <span class="No-Break">plus 1.</span></li>&#13;
				<li lang="en-GB">The <span class="No-Break">instruction’s opcode.</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The initial processing of an instruction is given by the following code. In section 1 (light shading), the mnemonic is read from the input token string (i.e., the first element). That may or may not be followed by <span class="No-Break">additional parameters.</span></p>&#13;
			<p lang="en-GB">The mnemonic is used to access the <strong class="source-inline">codes</strong> dictionary to check whether it’s valid. The error code is set to <strong class="source-inline">1</strong> (invalid operation) and a <strong class="source-inline">continue</strong> statement forces a drop to the end of the loop (further input testing is not necessary as the instruction is <span class="No-Break">not valid).</span></p>&#13;
			<p lang="en-GB">The code with the light gray background reads the tuple with the four data elements associated with the mnemonic and extracts the <span class="No-Break">individual parameters.</span></p>&#13;
			<p lang="en-GB">The three lines beginning with “<strong class="source-inline">if opCode == 1:</strong>” read the operation to determine whether the instruction was “<strong class="source-inline">STOP</strong>”. If it was <strong class="source-inline">STOP</strong>, the <strong class="source-inline">sys.exit()</strong> operation terminates the program. Note that we have to use <strong class="source-inline">import sys</strong> at the start of the program to import the library of <span class="No-Break">system functions:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    mnemonic = y[0]                    <span class="sc-comment"># Get the mnemonic</span></span>&#13;
<span>    if mnemonic not in codes:          <span class="sc-comment"># Check for a valid opcode</span></span>&#13;
<span>        error = 1                      <span class="sc-comment"># If none found, set error code</span></span>&#13;
<span>        continue                       <span class="sc-comment"># and jump to the end of the loop</span></span>&#13;
<span class="sc-grey" lang="en-GB">    opData  = codes.get(mnemonic)      <span class="sc-comment"># Read codes to get the data for this instruction</span></span>&#13;
<span class="sc-grey" lang="en-GB">    opForm  =  opData[0]               <span class="sc-comment"># Get each of this instruction's parameters</span></span>&#13;
<span class="sc-grey" lang="en-GB">    opStyle =  opData[1]</span>&#13;
<span class="sc-grey" lang="en-GB">    opCode  =  opData[2]</span>&#13;
<span class="sc-grey" lang="en-GB">    opLen   =  opData[3]</span>&#13;
<span class="sc-bottom" lang="en-GB">    if opCode == 1:                    <span class="sc-comment"># If the op_Code is 1, then it's "STOP", so exit the program</span></span>&#13;
<span class="sc-bottom" lang="en-GB">        print("\nProgram terminated on STOP")</span>&#13;
<span class="sc-bottom" lang="en-GB">        sys.exit()</span>&#13;
<span class="sc-grey" lang="en-GB">    totalTokens = len(y)               <span class="sc-comment"># How many tokens do we have?</span></span>&#13;
<span class="sc-grey" lang="en-GB">    if totalTokens &lt; opLen:            <span class="sc-comment"># Compare with the expected number</span></span>&#13;
<span class="sc-grey" lang="en-GB">        error = 2                      <span class="sc-comment"># Error 2: Too few operands</span></span>&#13;
<span class="sc-grey" lang="en-GB">        continue</span>&#13;
<span class="sc-grey" lang="en-GB">    if totalTokens &gt; opLen:</span>&#13;
<span class="sc-grey" lang="en-GB">        error = 3                      <span class="sc-comment"># Error 3: Too many operands</span></span>&#13;
<span class="sc-grey" lang="en-GB">        continue</span></pre>&#13;
			<p lang="en-GB">The final two blocks in the preceding code fragment with a dark gray background perform error-detecting operations. They both get the number of tokens from the instruction and then compare that number to the value for this instruction. In the first case, an error of <strong class="source-inline">2</strong> indicates too few tokens, and in the second case, an error of <strong class="source-inline">3</strong> indicates too <span class="No-Break">many tokens.</span></p>&#13;
			<p lang="en-GB">At this stage, we have determined that the instruction is valid and has the correct number of operands. The next stage is to check the operands. The check is performed according to the style of the instruction. There are seven styles. Style 1 has no further checking because there is no operand (e.g., for <strong class="source-inline">NOP</strong>). We will just look at the checking for style 6, which corresponds to instructions with a mnemonic, <strong class="source-inline">rD1</strong>, <strong class="source-inline">rS1</strong>, and a literal such as <span class="No-Break"><strong class="source-inline">ADD R1,R2,25</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">We call the <strong class="source-inline">regTest</strong> function first with the ‘<strong class="source-inline">rD</strong>’ parameter to tell it we are testing for the destination register and the <strong class="source-inline">predicate[0]</strong> token, which is the first parameter. This returns an error flag and the value of <span class="No-Break">the register.</span></p>&#13;
			<p lang="en-GB">Because we perform two tests (register <strong class="source-inline">rD</strong> and <strong class="source-inline">rS1</strong>), we must use two error names: <strong class="source-inline">e1</strong> for the first and <strong class="source-inline">e2</strong> for the second test. If we used <strong class="source-inline">error</strong> as the variable in both cases, a non-error second result would clear the first error. The line <strong class="source-inline">if (e1 != 0) or (e2 != 0): error = 4</strong> returns <strong class="source-inline">error</strong> with the appropriate error status independent of which register was in error. <strong class="source-inline">continue</strong> at the end of this block skips further error checking for <span class="No-Break">this instruction:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span># Input error checking - using dictionaries Modified 30 July 2021</span>&#13;
<span># Instruction dictionary 'mnemonic':(format, style, op_code, length)</span>&#13;
<span># Style definition and example of the instruction format</span>&#13;
<span># 0 NOP            mnemonic only</span>&#13;
<span># 1 BEQ L          mnemonic + literal</span>&#13;
<span># 2 INC R1         mnemonic + rD</span>&#13;
<span># 3 MOVE R1,R2     mnemonic + rD1 + rS1</span>&#13;
<span># 4 LDRL R1,L      mnemonic + rD1 + literal</span>&#13;
<span># 5 ADD R1 R2 R3   mnemonic + rD + rS1 + rS2</span>&#13;
<span># 6 ADDL R1 R2 L   mnemonic + rD + rS1 + literal</span>&#13;
<span># 7 LDRI R1 (R2 L) mnemonic + rD + rS1 + literal (same as 6)</span>&#13;
<span>import sys                                     <span class="sc-comment"># System library used to exit program</span></span>&#13;
<span>             # Dictionary of instructions (format, style, op_code, length)</span>&#13;
<span>codes = {'NOP': (0b0000,0,0,1),'STOP':(0b0000,0,1,1),'BEQ': (0b0001,1,2,2), \</span>&#13;
<span>         'INC': (0b1000,2,3,2),'MOVE':(0b1100,3,4,3),'LDRL':(0b1001,4,6,3), \</span>&#13;
<span>         'LDRI':(0b1101,7,7,4),'ADD': (0b1110,5,8,4),'ADDL':(0b1101,6,9,4)}</span>&#13;
<span>regSet = {'R0':0,'R1':1,'R2':2,'R3':3,'R4':4,'R5':5,'R6':6,'R7':7} <span class="sc-comment"># Registers</span></span>&#13;
<span>def regTest(token):                            <span class="sc-comment"># Test register operand for R0 to R7</span></span>&#13;
<span>    if token in regSet: return (0)             <span class="sc-comment"># Return with error 0 if legal name</span></span>&#13;
<span>    else:               return (4)             <span class="sc-comment"># Return with error 4 if illegal register name</span></span>&#13;
<span>def printError(error):                         <span class="sc-comment"># This function prints the error message</span></span>&#13;
<span>    if error != 0:</span>&#13;
<span>        if error == 1: print("Error 1: Non-valid operation")</span>&#13;
<span>        if error == 2: print("Error 2: Too few operands")</span>&#13;
<span>        if error == 3: print("Error 3: Too many operands")</span>&#13;
<span>        if error == 4: print("Error 4: Register name error")</span>&#13;
<span>        if error == 5: print("Error 5: Failure in pointer-based expression")</span>&#13;
<span>        if error == 6: print("Error 6: Invalid literal")</span>&#13;
<span>def litCheck(n):                          <span class="sc-comment"># Check for invalid literal format (this is just a demo)</span></span>&#13;
<span>    if n.isnumeric():    error = 0             <span class="sc-comment"># Decimal numeric OK</span></span>&#13;
<span>    elif n[0] == '-':    error = 0             <span class="sc-comment"># Negative number OK</span></span>&#13;
<span>    elif n[0] == '%':    error = 0             <span class="sc-comment"># Binary number OK</span></span>&#13;
<span>    elif n[0:2] == '0X': error = 0             <span class="sc-comment"># Hex number OK</span></span>&#13;
<span>    else:                error = 6             <span class="sc-comment"># Anything else is an error</span></span>&#13;
<span>    return(error)                              <span class="sc-comment"># Return with error number</span></span></pre>&#13;
			<p lang="en-GB">This is the main loop. An instruction is input and then checked for errors. As in earlier examples, the instruction is processed for validity first and the mnemonic is checked to see whether it is <span class="No-Break">in codes:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>error = 0</span>&#13;
<span>while True:             <span class="sc-comment"># Infinite loop</span></span>&#13;
<span>    if error != 0: printError(error)</span>&#13;
<span>    error = 0</span>&#13;
<span>    x = input("&gt;&gt; ").upper()             <span class="sc-comment"># Read instruction and provide limited processing</span></span>&#13;
<span>    if len(x) == 0: continue             <span class="sc-comment"># Ignore empty lines and continue</span></span>&#13;
<span>    x = x.replace(',',' ')               <span class="sc-comment"># remove commas</span></span>&#13;
<span>    x = x.replace('(','')                <span class="sc-comment"># remove (</span></span>&#13;
<span>    x = x.replace(')','')                <span class="sc-comment"># remove )</span></span>&#13;
<span>    y = x.split(' ')                     <span class="sc-comment"># Create list of tokens (mnemonic + predicate)</span></span>&#13;
<span>    mnemonic = y[0]                      <span class="sc-comment"># Get the mnemonic (first token)</span></span>&#13;
<span>    if mnemonic not in codes:            <span class="sc-comment"># Check for validity</span></span>&#13;
<span>        error = 1                        <span class="sc-comment"># If not valid, set error code and drop out</span></span>&#13;
<span>        continue</span>&#13;
<span>    opData = codes.get(mnemonic)         <span class="sc-comment"># Read the four parameters for this instruction</span></span>&#13;
<span>    opForm  =  opData[0]                 <span class="sc-comment"># opcode format (rDS,rS1,rS2,L)</span></span>&#13;
<span>    opStyle =  opData[1]                 <span class="sc-comment"># Instruction style (0 to 7)</span></span>&#13;
<span>    opCode  =  opData[2]                 <span class="sc-comment"># Numeric opcode</span></span>&#13;
<span>    opLen   =  opData[3]                 <span class="sc-comment"># Length (total mnemonic + operands in range 1 to 4)</span></span>&#13;
<span>    if opLen &gt; 1: predicate = y[1:]      <span class="sc-comment"># Get predicate if this is one</span></span>&#13;
<span>    else:         predicate = ''         <span class="sc-comment"># If single token, return null</span></span>&#13;
<span>    print("Mnemonic =",mnemonic, "Predicate", predicate, \</span>&#13;
<span>          "Format =", bin(opForm),"Style =",opStyle,"Code =",opCode, \</span>&#13;
<span>          "Length =",opLen)</span>&#13;
<span>    if opCode == 1:                      <span class="sc-comment"># Used to terminate this program</span></span>&#13;
<span>        print("\nProgram ends on STOP")</span>&#13;
<span>        sys.exit()</span>&#13;
<span>    totalTokens = len(y)</span>&#13;
<span>    if totalTokens &lt; opLen:</span>&#13;
<span>        error = 2                        <span class="sc-comment"># Error 2: Too few operands</span></span>&#13;
<span>        continue</span>&#13;
<span>    if totalTokens &gt; opLen:</span>&#13;
<span>        error = 3                        <span class="sc-comment"># Error 3: Too many operands</span></span>&#13;
<span><span class="No-Break">        continue</span></span>&#13;
<span>    if opStyle == 0:                     <span class="sc-comment"># e.g., NOP or STOP so nothing else to do</span></span>&#13;
<span>        continue</span>&#13;
<span>    elif opStyle == 1:                   <span class="sc-comment"># e.g., BEQ 5 just check for literal</span></span>&#13;
<span>        literal = predicate[0]</span>&#13;
<span>        error = litCheck(literal)</span>&#13;
<span>        continue</span>&#13;
<span>    elif opStyle == 2:                   <span class="sc-comment"># e.g., INC r6 check for single register</span></span>&#13;
<span>        error = regTest(predicate[0])</span>&#13;
<span>        continue</span>&#13;
<span>    elif opStyle == 3:                   <span class="sc-comment"># e.g., MOVE r1,r2 check for two registers</span></span>&#13;
<span>        e1 = regTest(predicate[0])</span>&#13;
<span>        e2 = regTest(predicate[1])</span>&#13;
<span>        if e1 != 0 or e2 != 0:</span>&#13;
<span>            error = 4</span>&#13;
<span>        continue</span>&#13;
<span>    elif opStyle == 4:                   <span class="sc-comment"># e.g., LDRL r1,12 Check register then literal</span></span>&#13;
<span>        error = regTest(predicate[0])</span>&#13;
<span>        if error != 0: continue</span>&#13;
<span>        literal = predicate[1]</span>&#13;
<span>        error = litCheck(literal)</span>&#13;
<span>        continue</span>&#13;
<span>    elif opStyle == 5:                   <span class="sc-comment"># e.g., ADD r1,r2,r3 Check for three register names</span></span>&#13;
<span>        e1 = regTest(predicate[0])</span>&#13;
<span>        e2 = regTest(predicate[1])</span>&#13;
<span>        e3 = regTest(predicate[2])</span>&#13;
<span>        if e1 != 0 or e2 != 0 or e3 !=0:</span>&#13;
<span>            error = 4</span>&#13;
<span>        continue</span>&#13;
<span>    elif opStyle == 6:                   <span class="sc-comment"># e.g., ADDL R1,R2,4 Check for two registers and literal</span></span>&#13;
<span>        e1 = regTest(predicate[0])</span>&#13;
<span>        e2 = regTest(predicate[1])</span>&#13;
<span>        literal = predicate[2]</span>&#13;
<span>        e3 = litCheck(literal)</span>&#13;
<span>        if e1 != 0 or e2 != 0:</span>&#13;
<span>            error = 4</span>&#13;
<span>        if e1==0 and e2==0 and e3 !=0:   <span class="sc-comment"># If registers are OK but not literal</span></span>&#13;
<span>            error = 6                    <span class="sc-comment"># report literal error</span></span>&#13;
<span>        continue</span>&#13;
<span>    elif opStyle == 7:                   <span class="sc-comment"># e.g., LDRI r4,r0,23 or LDRI r4,(r0,23)</span></span>&#13;
<span>        e1 = regTest(predicate[0])</span>&#13;
<span>        e2 = regTest(predicate[1])</span>&#13;
<span>        literal = predicate[2]</span>&#13;
<span>        e3 = litCheck(literal)</span>&#13;
<span>        if e1 != 0 or e2 != 0:</span>&#13;
<span>            error = 4</span>&#13;
<span>        if e1==0 and e2==0 and e3 !=0:   <span class="sc-comment"># If registers are OK but not literal</span></span>&#13;
<span>            error = 6                    <span class="sc-comment"># report literal error</span></span>&#13;
<span>        continue</span></pre>&#13;
			<p lang="en-GB">Having looked at input validation, we now look at how we can control the display of <em class="italic">useful</em> information during <span class="No-Break">a simulation.</span></p>&#13;
			<h4 lang="en-GB">Tracing and breakpoints</h4>&#13;
			<p lang="en-GB">When you simulate a computer, you have to show what is happening during the simulation. Consequently, you have to answer the following <span class="No-Break">three questions:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">When do you <span class="No-Break">display data?</span></li>&#13;
				<li lang="en-GB">How do you display <span class="No-Break">the data?</span></li>&#13;
				<li lang="en-GB">What do <span class="No-Break">you display?</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">When you have completed this section, you will be able to construct your own instruction <span class="No-Break">tracing facilities.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">CPU simulators execute one instruction at a time. At the end of an instruction, the state of the computer (i.e., its registers, status flags, and memory) can be displayed. This mode is called <em class="italic">single-stepping</em>. Every time you hit <em class="italic">Enter</em>, an instruction is executed and the machine’s status is displayed on <span class="No-Break">the screen.</span></p>&#13;
			<p lang="en-GB">Stepping through instructions sequentially, one by one, has limitations. What if there’s a 3-instruction loop that clears, say, 1,000 locations in an array? Do you expect someone to hit the <em class="italic">Enter</em> key 3,000 times to trace past this operation? We need a means of stepping past the boring bits of a program and jumping to the interesting bits – that is, a mechanism that lets us execute some instructions as a batch, without having to hit <em class="italic">return</em> after each instruction has been executed or printing the results of <span class="No-Break">that execution.</span></p>&#13;
			<p lang="en-GB">Suppose we create a variable, <strong class="source-inline">trace</strong>, and then, at the end of the <strong class="source-inline">execute</strong> loop, print the appropriate data if <strong class="source-inline">trace</strong> is <strong class="source-inline">1</strong> and jump to the next instruction without printing data if <strong class="source-inline">trace = </strong><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">trace = 1                                    </strong><span class="sc-comment"># Trace mode active when trace = 1</span></span>&#13;
<span>run = 1<strong class="bold">                                      </strong><span class="sc-comment"># run = 1 to execute program</span></span>&#13;
<span>pc = 0<strong class="bold">                                       </strong><span class="sc-comment"># Initialize program counter</span></span>&#13;
<span>while run == 1:<strong class="bold">                              </strong><span class="sc-comment"># Main program loop</span></span>&#13;
<span>    read instruction</span>&#13;
<span>    execute instruction</span>&#13;
<span>    <strong class="bold">if trace == 1: displayData()             </strong><span class="sc-comment"># When in trace mode, print results</span></span></pre>&#13;
			<p lang="en-GB">The CPU state is printed after each instruction only if <strong class="source-inline">trace = 1</strong>. How do we turn <strong class="source-inline">trace</strong> on and off? Turning <strong class="source-inline">trace</strong> off is easy; all you need do is read the keyboard input when single-stepping, and turn <strong class="source-inline">trace</strong> off if a particular character or string is entered. However, once <strong class="source-inline">trace</strong> is <strong class="source-inline">0</strong>, we’ve lost control, and instructions are executed until the program <span class="No-Break">is terminated.</span></p>&#13;
			<p lang="en-GB">One solution is to set up a trace count, with the number of instructions to be executed before <strong class="source-inline">trace</strong> is turned on again; for example, entering <strong class="source-inline">T 10</strong>, would turn off tracing, execute 10 instructions without displaying anything, and then turn tracing on again. Defining a fixed number of instructions to execute is not always helpful, as it requires the programmer to count the number of instructions to be executed before a point of interest is reached. The programmer may not always <span class="No-Break">know that.</span></p>&#13;
			<p lang="en-GB">A better solution is to turn tracing on when a specific point in the assembly language program, called a <em class="italic">breakpoint,</em> is reached. A breakpoint can be the value of the program counter, a label, or a specific instruction. Typically, the value of the program counter at which you wish to display machine status is stored in a table of breakpoints. Execution continues (without any display) until a breakpoint is encountered and the CPU state <span class="No-Break">is displayed.</span></p>&#13;
			<p lang="en-GB">The following fragment of Python demonstrates this approach. It is not a computer simulator and has only three instructions (<strong class="source-inline">nop</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">test1</strong>), which do nothing, plus <strong class="source-inline">stop</strong>. The program is intended to demonstrate a possible approach to the implementation of single-stepping and breakpoints. At the end of each instruction cycle, several choices <span class="No-Break">are possible:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Show the machine status after the execution of <span class="No-Break">this instruction</span></li>&#13;
				<li lang="en-GB">Wait for keyboard input before executing the <span class="No-Break">next cycle</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Print the machine status at a specific breakpoint (address <span class="No-Break">or instruction)</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">The following code uses different fonts and background shading to highlight the various functional parts of the code. The first two sections are the setting up and initialization of variables, and (shaded) the main program execution loop. This loop does nothing other than step through instructions that are <strong class="source-inline">nop</strong> (no operation); <strong class="source-inline"> test</strong> and <strong class="source-inline">test1</strong> are just used as markers. The <strong class="source-inline">stop</strong> instruction serves to <span class="No-Break">terminate execution.</span></p>&#13;
			<p lang="en-GB">Note that, when tracing, we require a second program counter, <strong class="source-inline">pcOld</strong>, because <strong class="source-inline">pc</strong> gets incremented during the <strong class="source-inline">fetch</strong> cycle and we need to display it before it <span class="No-Break">was modified:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def display():                                   <span class="sc-comment"># Display processor status</span></span>&#13;
<span>    if oldPC in breakTab: print('Breakpoint at %03x' %oldPC)   <span class="sc-comment"># if pc in the table</span></span>&#13;
<span>    print("PC = %03x" %oldPC,  ' Op-code = %s' %instruction)</span>&#13;
<span>    return()</span>&#13;
<span>opCodes = ['nop', 'test', 'test1', 'stop']       <span class="sc-comment"># Op-code set</span></span>&#13;
<span>traceCodes = []                                  <span class="sc-comment"># List of codes to be traced (initially empty)</span></span>&#13;
<span>mem = ['nop'] * 32                               <span class="sc-comment"># Initialize memory to NOPs</span></span>&#13;
<span>mem[10] = 'test'                                 <span class="sc-comment"># Dummy operation at 10</span></span>&#13;
<span>mem[20] = 'test'                                 <span class="sc-comment"># Dummy operation at 20</span></span>&#13;
<span>mem[25] = 'test1'                                <span class="sc-comment"># Dummy operation at 25</span></span>&#13;
<span>r = [0] * 4                                      <span class="sc-comment"># Set up 4 registers (not used)</span></span>&#13;
<span>pc = 0                                           <span class="sc-comment"># Initialize program counter</span></span>&#13;
<span>oldPC = 0                                        <span class="sc-comment"># Initialize previous program counter</span></span>&#13;
<span>run = 1                                          <span class="sc-comment"># Set run to 1 to go</span></span>&#13;
<span>trace = 1                                        <span class="sc-comment"># Set trace to 1 to single-step</span></span>&#13;
<span>count = 0                                     <span class="sc-comment"># Count is the number of cycles not displayed</span></span>&#13;
<span>breakTab = []                                    <span class="sc-comment"># Create table for breakpoints</span></span>&#13;
<span>while run == 1:                                  <span class="sc-comment"># PROGRAM LOOP</span></span>&#13;
<span>    instruction = mem[pc]                        <span class="sc-comment"># read instruction</span></span>&#13;
<span>    oldPC = pc                                   <span class="sc-comment"># Save current PC for display</span></span>&#13;
<span>    pc = pc + 1                                  <span class="sc-comment"># Increment PC</span></span>&#13;
<span>    # Do processing here                         <span class="sc-comment"># For experimentation (add stuff here)</span></span>&#13;
<span>    if pc == 32 or instruction == 'stop': run = 0 <span class="sc-comment"># End on stop instruction or max PC</span></span>&#13;
<span>    if trace == 0 and count != 0:                <span class="sc-comment"># Test for single-step mode</span></span>&#13;
<span>        count = count - 1                        <span class="sc-comment"># If not single-step, decrement counter</span></span>&#13;
<span>        if count == 0:                           <span class="sc-comment"># If count zero, return to single step mode</span></span>&#13;
<span>            trace = 1                            <span class="sc-comment"># Exit silent mode</span></span>&#13;
<span>            continue                             <span class="sc-comment"># Now drop to bottom of the loop</span></span>&#13;
<span>    if trace == 0 and pc in breakTab:            <span class="sc-comment"># If not single-step, check for breakpoint</span></span>&#13;
<span>        print('Breakpoint\n')                    <span class="sc-comment"># Print status at the breakpoint</span></span>&#13;
<span>        display()</span>&#13;
<span>    if trace == 0 and instruction in traceCodes: <span class="sc-comment"># If not single-step and opcode in table</span></span>&#13;
<span>        print('Trace Code')                      <span class="sc-comment"># Print status info</span></span>&#13;
<span>        display()</span>&#13;
<span>    <strong class="bold">if trace == 1:</strong><strong class="bold">                               </strong><span class="sc-comment"># If single-step with trace on</span></span>&#13;
<span>        display()                                <span class="sc-comment"># Display the status</span></span>&#13;
<span>        c = input('&gt;&gt; ')                         <span class="sc-comment"># Wait for keyboard input</span></span>&#13;
<span>        if c == '': continue                     <span class="sc-comment"># If it's just a return, continue</span></span>&#13;
<span>        elif c[0]== 't' and len(c) &gt; 2 and c[2:].isdigit():</span>&#13;
<span>                                                 <span class="sc-comment"># Test for 't' and number</span></span>&#13;
<span>            count = int(c[2:])                   <span class="sc-comment"># Set the count for silent mode</span></span>&#13;
<span>            trace = 0                            <span class="sc-comment"># Turn off single-step</span></span>&#13;
<span>        elif c[0] == 'b' and len(c) &gt; 2 and c[2:].isdigit():</span>&#13;
<span>                                                 <span class="sc-comment"># Test for b (set breakpoint)</span></span>&#13;
<span>            breakPoint = int(c[2:])              <span class="sc-comment"># Get breakpoint address and add to table</span></span>&#13;
<span>            breakTab.append(breakPoint)</span>&#13;
<span>        elif c == 'd':                           <span class="sc-comment"># Test for d to display breakpoint info</span></span>&#13;
<span>            print('Display status: breakpoints =', breakTab, \</span>&#13;
<span>                  'traced codes =',traceCodes)</span>&#13;
<span>        elif c in opCodes: traceCodes.append(c)  <span class="sc-comment"># Test for a valid opcode and add to list</span></span>&#13;
<span>print('\nProgram terminated')</span></pre>&#13;
			<p lang="en-GB">Initially, <strong class="source-inline">trace</strong> is set to <strong class="source-inline">1</strong>, indicating that we are in a <em class="italic">single-step</em> mode. After displaying the program counter and instruction, the program waits for keyboard input. The code that does this is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if trace == 1:                               <span class="sc-comment"># If single-step with trace on</span></span>&#13;
<span>        display()                                <span class="sc-comment"># Display the status</span></span>&#13;
<span>        c = input('&gt;&gt; ')                         <span class="sc-comment"># Wait for input from user</span></span>&#13;
<span>        if c == '': continue                     <span class="sc-comment"># If it's just a return, continue</span></span></pre>&#13;
			<p lang="en-GB">If the input is a return (i.e., <strong class="source-inline">enter</strong>), the loop is terminated by <strong class="source-inline">continue</strong> and the next instruction cycle is executed. If you enter <strong class="source-inline">t</strong> followed by an integer (e.g., <strong class="source-inline">t 13</strong>), the integer is transferred to the <strong class="source-inline">count</strong> variable and <strong class="source-inline">t</strong> is set to <strong class="source-inline">0</strong>. Setting <strong class="source-inline">t</strong> to <strong class="source-inline">0</strong> turns off the single-step mechanism, and instructions are executed without printing the machine status or waiting for a keyboard input at the end of each cycle. At the end of each cycle, the <strong class="source-inline">count</strong> variable is decremented. When <strong class="source-inline">count</strong> becomes <strong class="source-inline">0</strong>, <strong class="source-inline">trace</strong> is set to <strong class="source-inline">1</strong> and the single-step mode <span class="No-Break">is re-entered.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If you enter <strong class="source-inline">b</strong> followed by an integer (e.g., <strong class="source-inline">b 21</strong>), a breakpoint at address <strong class="source-inline">21</strong> is recorded in the breakpoint table (a dictionary). You can enter more than one breakpoint and it will be saved in the dictionary. Each breakpoint is an address in the program being executed. When the program counter reaches that address, the system status is displayed. For example, if you were to enter the sequence <strong class="source-inline">b 12</strong>, <strong class="source-inline">b 30</strong>, <strong class="source-inline">t 50</strong> (each on a separate line), the simulator would set breakpoints at addresses <strong class="source-inline">12</strong> and <strong class="source-inline">30</strong>, and then execute 50 cycles without displaying any data. However, if the program counter becomes either <strong class="source-inline">12</strong> or <strong class="source-inline">30</strong> during this period, the machine status will <span class="No-Break">be printed.</span></p>&#13;
			<p lang="en-GB">Similarly, you can enter an instruction that will be loaded into the <strong class="source-inline">traceCodes</strong> table. This behaves exactly like the PC breakpoint. When an instruction that’s in the <strong class="source-inline">traceCodes</strong> table is encountered, the machine status is displayed. Thus, the simulator provides <span class="No-Break">four modes:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">Execute instruction step <span class="No-Break">by step</span></li>&#13;
				<li lang="en-GB">Execute <em class="italic">n</em> instructions without displaying system status (the <span class="No-Break">silent mode)</span></li>&#13;
				<li lang="en-GB">Execute instructions in silent mode but stop and display if a breakpoint address <span class="No-Break">is encountered</span></li>&#13;
				<li lang="en-GB">Execute instructions in silent mode but stop and display if a specific opcode <span class="No-Break">is encountered</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">Of course, the program can be extended to more exotic forms of breakpoints that take account of register data, memory data, or any combination of events. For example, you could permit breakpoints of the <span class="No-Break">following form:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>If PC &gt; 200 or PC &lt; 300 and instruction = 'ADD'</span></pre>&#13;
			<p lang="en-GB">Some simulators let you set a breakpoint on a change of instruction flow – that is, after any jump, branch, or subroutine call. That’s very useful for tracing the execution of a <span class="No-Break">complex program.</span></p>&#13;
			<p lang="en-GB">The following is the output of a short session with this fragment program. Remember that it is intended to be a demonstration of the principles involved, rather than an actual <span class="No-Break">working system:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>PC = 000  Op-code = nop           <span class="sc-comment"># Hit enter key and trace first instruction</span></span>&#13;
<span>&gt;&gt;</span>&#13;
<span>PC = 001  Op-code = nop</span>&#13;
<span>&gt;&gt;</span>&#13;
<span>PC = <span class="sc-source-bold-bg">002</span>  Op-code = nop</span>&#13;
<span>&gt;&gt; t 4                            <span class="sc-comment"># Type t 4 to execute but skip printing 4 instructions</span></span>&#13;
<span>PC = <span class="sc-source-bold-bg">007</span>  Op-code = nop           <span class="sc-comment"># Note how PC jumps from 2 to 7</span></span>&#13;
<span>&gt;&gt;</span>&#13;
<span>PC = 008  Op-code = nop</span>&#13;
<span>&gt;&gt;</span>&#13;
<span>PC = 009  Op-code = nop</span>&#13;
<span>&gt;&gt; b 12                           <span class="sc-comment"># Type b 12 to insert breakpoint at PC = 12</span></span>&#13;
<span>PC = 00a  Op-code = nop</span>&#13;
<span>&gt;&gt; t 6                            <span class="sc-comment"># Type t 6 to execute 6 instructions without display</span></span>&#13;
<span>Breakpoint</span>&#13;
<span>Breakpoint at 00c                 <span class="sc-comment"># No display continues until PC = 12 (0xC)</span></span>&#13;
<span>PC = 00c  Op-code = nop           <span class="sc-comment"># Processor printed for PC = 12</span></span>&#13;
<span>PC = 011  Op-code = nop           <span class="sc-comment"># Execution continues until PC = 17 (0x11)</span></span>&#13;
<span>&gt;&gt; test1                          <span class="sc-comment"># Type 'test1' to make instruction test1 a breakpoint</span></span>&#13;
<span>PC = 012  Op-code = nop</span>&#13;
<span>&gt;&gt; t 15                           <span class="sc-comment"># Type t 15 to execute but skip printing 15 instructions</span></span>&#13;
<span><span class="sc-comment">Trace Code</span></span>&#13;
<span>PC = 019  Op-code = test1         <span class="sc-comment"># Execution continues until 'test1' encountered at PC = 25 (0x19)</span></span>&#13;
<span>Program terminated</span></pre>&#13;
			<p lang="en-GB">The next step is to demonstrate how the simulated computer can be extended by adding new instructions. We demonstrate what parts of the code have to be modified and how you can create new instructions of arbitrary complexity. For example, if you were developing a computer to be used primarily for playing chess, you could create an instruction, <strong class="source-inline">ROOK R1,R2</strong>, that takes the position of a rook in register <strong class="source-inline">R2</strong> and calculates the legal positions it could move to and put them <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">R1</strong></span><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-125" lang="en-GB"><a id="_idTextAnchor128"/>Adding new instructions</h1>&#13;
			<p lang="en-GB">So far, we have provided a modest set of instructions for TC1. In this section, we show how to add a new instruction to the TC1’s repertoire in order to see what’s involved in extending an instruction set. In fact, this is a remarkably <span class="No-Break">straightforward task.</span></p>&#13;
			<p lang="en-GB">The first step is to choose a mnemonic and unique opcode and insert them into the table of code. We’ve arranged the instruction set to leave some unallocated code (e.g., code beginning with <strong class="source-inline">11</strong>). The second step is to write the code to interpret the <span class="No-Break">new instruction.</span></p>&#13;
			<h2 id="_idParaDest-126" lang="en-GB"><a id="_idTextAnchor129"/>First example – putting two memory locations in ascending order</h2>&#13;
			<p lang="en-GB">Let’s create an instruction that takes the contents of two consecutive locations in memory and puts the largest number in the first location at the lower address (i.e., it orders them). This instruction takes a single parameter, a pointer register, and reads the numeric value pointed at by the register. We’ll assume that the register is <strong class="source-inline">r[i]</strong>. The instruction compares this number with the value stored at address <strong class="source-inline">r[i] + 1</strong>, and swaps them if the second number is higher than the one at the <strong class="source-inline">r[i]</strong> location. In pseudocode, this is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>temp ← mem[r[i]]                    <span class="sc-comment"># Save first number. Assume ri is the pointer register</span></span>&#13;
<span>if mem[r[i] + 1] &gt; temp             <span class="sc-comment"># If the second number is greater than the first</span></span>&#13;
<span>   mem[r[i]]   ← mem[r[i]+1]        <span class="sc-comment"># then put the second number in the first location</span></span>&#13;
<span>   mem[r[i]+1] ← temp               <span class="sc-comment"># and the first number in the second location</span></span></pre>&#13;
			<p lang="en-GB">We will call the instruction <strong class="source-inline">ORD</strong> (order numbers) and write it as <strong class="source-inline">ORD r0</strong>. The binary code is <strong class="source-inline">1110000 rrr 00…0</strong> (where <strong class="source-inline">rrr</strong> is the 3-bit register field) and is assigned to this instruction. <strong class="source-inline">'ORD':(8,112)</strong> is entered in the Python dictionary of instructions. The opcode is <strong class="source-inline">112</strong> and the parameter allocation code in binary is <strong class="source-inline">1000</strong> (i.e., 8), because the only parameter required <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Rd</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The new instruction is detected in the execution part of <span class="No-Break">the program:</span></p>&#13;
			<pre class="source-code"> elif opCode == 0b1110000:           <span class="sc-comment"># Test for 'ORD' ( 112 in decimal and in 1110000 binary)</span></pre>&#13;
			<p lang="en-GB">This is followed by the Python version of the preceding pseudocode. We can write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>temp = mem[r[dest]]                          <span class="sc-comment"># dest is the destination register</span></span>&#13;
<span>if mem[r[dest] + 1] &gt; temp:</span>&#13;
<span>    mem[r[dest]] = mem[r[dest]+1]</span>&#13;
<span>    mem[r[dest] + 1] = temp</span></pre>&#13;
			<p lang="en-GB">What could be simpler? The following code provides a testbed for the instruction. We fill memory with random numbers and then request a memory address. The data at that address is exchanged with the data at the next address to create an ordered pair. Note that this example does not use global variables: the registers and memory are passed to the function as parameters. To simplify testing, it is assumed that the memory address is in the <span class="No-Break"><strong class="source-inline">r[0]</strong></span><span class="No-Break"> register:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>import random                                <span class="sc-comment"># System library to generate random numbers</span></span>&#13;
<span>mem = [0] * 32                               <span class="sc-comment"># Set up memory</span></span>&#13;
<span>r   = [0] * 8                                <span class="sc-comment"># Set up registers</span></span>&#13;
<span>for i in range(32): mem[i] = random.randint(0,256) <span class="sc-comment"># Fill memory with random numbers</span></span>&#13;
<span>for i in range(32): print(i, mem[i])</span>&#13;
<span>def ord(reg,rD,memory):                      <span class="sc-comment"># Pass registers, memory, and register number</span></span>&#13;
<span>    temp = memory[reg[rD]]                   <span class="sc-comment"># rD is the destination register</span></span>&#13;
<span>    if memory[reg[rD] + 1] &gt; temp:</span>&#13;
<span>        memory[reg[rD]] = memory[reg[rD]+1]</span>&#13;
<span>        memory[reg[rD] + 1] = temp</span>&#13;
<span>    return()</span>&#13;
<span>go = True</span>&#13;
<span>r  = [0] * 8</span>&#13;
<span>rD = 0</span>&#13;
<span>while go:</span>&#13;
<span>    x = input('Type address of first: ')</span>&#13;
<span>    r[rD] = int(x)</span>&#13;
<span>    if r[rD] &gt; 30:                           <span class="sc-comment"># Exit on memory address 31 or higher</span></span>&#13;
<span>        print('End of run')</span>&#13;
<span>        break</span>&#13;
<span>    else:</span>&#13;
<span>        print('Before: mem[x] = ',mem[r[rD]], 'next = ',mem[r[rD] + 1])</span>&#13;
<span>        ord(r,0,mem)</span></pre>&#13;
			<pre class="source-code">        print('After:  mem[x] = ',mem[r[rD]], 'next = ',mem[r[rD] + 1])</pre>&#13;
			<h2 id="_idParaDest-127" lang="en-GB"><a id="_idTextAnchor130"/>Second example – adding a bit-reversal instruction</h2>&#13;
			<p lang="en-GB">Let’s add a more complicated instruction to the TC1 instruction set. Suppose you want to reverse the order of bits in a register so that the binary code <strong class="source-inline">1100111000101001</strong> in <strong class="source-inline">r0</strong> becomes <strong class="source-inline">1001010001110011</strong>. Assume that the new instruction is <strong class="source-inline">REV r0</strong>, which reverses the 16 bits in <strong class="source-inline">r0</strong> and returns the result <span class="No-Break">in r0.</span></p>&#13;
			<p lang="en-GB">How do we reverse bits? Consider the four bits 1101 and assume they are in T1 (<em class="italic">see Fig 7.1</em>). Suppose we shift the bits one place left so that the bit that leaves the left-hand end of T1 goes into the right-hand end of T2, and then we shift T2 one place to the right. We repeat that operation four times. <span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.1</em> shows what <span class="No-Break">we get:</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer043" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_7.1_B19624.jpg" alt="Figure 7.1 – Shifting one register’s output into a second register’s input to reverse a string" width="760" height="249"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Shifting one register’s output into a second register’s input to reverse a string</p>&#13;
			<p lang="en-GB">We have reversed the order of the bits. If the register to be shifted is <strong class="source-inline">op1</strong>, then we can write the Python code as follows. This code is in the form of a function that can be called from the <span class="No-Break">instruction interpreter:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>def reverseBits(op1):                      <span class="sc-comment"># Reverse the bits of register op1</span></span>&#13;
<span>    reversed = 0                           <span class="sc-comment"># The reversed value is initialized</span></span>&#13;
<span>    toShift  = r[op1]                      <span class="sc-comment"># Read the register contents</span></span>&#13;
<span>    for i in range(0,16):                  <span class="sc-comment"># Repeat for all 16 bits</span></span>&#13;
<span>        bitOut   = toShift &amp; 0x8000        <span class="sc-comment"># Get msb of word to reverse</span></span>&#13;
<span>        toShift  = toShift &lt;&lt; 1            <span class="sc-comment"># Shift source word one place left</span></span>&#13;
<span>        reversed = reversed &gt;&gt; 1           <span class="sc-comment"># Shift result one place right</span></span>&#13;
<span>        reversed = reversed | bitOut       <span class="sc-comment"># Use OR to insert bit in lsb of result</span></span>&#13;
<span>    return(reversed)</span></pre>&#13;
			<p lang="en-GB">We can now change the code of TC1 to incorporate this. There are <span class="No-Break">three steps:</span></p>&#13;
			<ol>&#13;
				<li lang="en-GB"><strong class="bold">Step 1</strong>: Insert the new instruction, <strong class="source-inline">'REV':(8,113)</strong>, into the <strong class="source-inline">codes</strong> dictionary. 8 indicates <strong class="source-inline">1000</strong> in binary and informs the computer that the reverse instruction requires the destination <strong class="source-inline">rD</strong> register to be specified by the instruction. 113 is the opcode, which is <strong class="source-inline">0b1110001</strong> <span class="No-Break">in binary.</span></li>&#13;
				<li lang="en-GB"><strong class="bold">Step 2</strong>: In the opcode interpretation list, insert the <span class="No-Break">new entry:</span><p class="source-code">elif 'code ' == 0b1110001: r[op0] = reverseBits(op0)</p></li>&#13;
			</ol>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This checks whether the current instruction is <strong class="source-inline">0b1110001</strong> (i.e., 161 decimal) and calls the r<strong class="source-inline">everseBits()</strong> function to perform the required operation.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="3"><strong class="bold">Step 3</strong>: Insert the <strong class="source-inline">reverseBits</strong> function into the Python code. This instruction replaces the data in the <strong class="source-inline">rD</strong> register with the <span class="No-Break">bits reversed.</span></li>&#13;
			</ol>&#13;
			<p lang="en-GB">Suppose that we wanted a non-destructive instruction that did not overwrite the register containing the bits to be reversed – that is <strong class="source-inline">REV r0,r1</strong>. What changes would we need?</p>&#13;
			<p lang="en-GB">First, we would need a new instruction format code. We have to specify two registers: the source and destination register. The code in the directory would now be <strong class="source-inline">'REV': (12,113)</strong> because the opcode parameter value would be <strong class="source-inline">1100</strong> in binary or <strong class="source-inline">12</strong> in decimal. The other change would be to the <span class="No-Break">instruction interpreter:</span></p>&#13;
			<p class="source-code" lang="en-GB">elif 'code' == 0b1110010: R[dest] = reverseBits(op1)</p>&#13;
			<p lang="en-GB">Note that we have changed the instruction format for minimal changes to the code (in this case, it’s just the change of source register from <strong class="source-inline">op0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">op1</strong></span><span class="No-Break">).</span></p>&#13;
			<h1 id="_idParaDest-128" lang="en-GB"><a id="_idTextAnchor131"/>A new comparison operation</h1>&#13;
			<p lang="en-GB">Suppose you are performing an operation on a string where you have to find the <em class="italic">middle</em> of the string. You can do this by stepping in from both ends until you get to the middle. But there are <em class="italic">two</em> types of middle. A string with an odd number of characters has a character in its middle. A string with an even number of characters has no middle character; it has two characters next to each other. Consider these <span class="No-Break">two examples:</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">String 1: 12</strong><span class="pcode-bold">34</span><strong class="source-inline">567</strong><strong class="source-inline CharOverride-2">        </strong><span class="sc-comment">Odd number </span><span class="No-Break"><span class="sc-comment">of characters</span></span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">String 2: 123</strong><span class="pcode-bold">45</span><strong class="source-inline">678</strong><strong class="source-inline CharOverride-2">       </strong><span class="sc-comment">Even number </span><span class="No-Break"><span class="sc-comment">of characters</span></span></p>&#13;
			<p lang="en-GB">String 1 has an odd number of characters and 4 is the center. String 2 has an even number of characters, and 4 and 5 are on either side of <span class="No-Break">the middle.</span></p>&#13;
			<p lang="en-GB">Suppose we are stepping through a string using two pointers, one at each end. As we step in from both sides, one pointer goes up and the other goes down. When we get to the middle, either the pointers are the same (odd length) or the pointers differ by one (<span class="No-Break">even length).</span></p>&#13;
			<p lang="en-GB">It would be nice to have a compare operation that compares two values and returns equality if either they are the same or if the second one differs from the first by +1. The new instruction, <strong class="source-inline">CMPT</strong> (<em class="italic">compare together</em>), does this. For example, <strong class="source-inline">CMPT</strong> <strong class="source-inline">r4,r6</strong> sets the <strong class="source-inline">z</strong> bit to <strong class="source-inline">1</strong> if the contents of <strong class="source-inline">r4</strong> and <strong class="source-inline">r6</strong> are the same, or if the contents of <strong class="source-inline">r4</strong> are one less than the contents of <strong class="source-inline">r6</strong>. The code to do this is <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if mnemonic == "CMPT":</span>&#13;
<span>        z = 0</span>&#13;
<span>        if (r[rD] == r[rS1]) or (r[rD] == r[rS1] + 1): z = 1</span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">As you can see, this performs two tests on the pointers, one for equality and one for higher by 1, and combines the test results using a Boolean <strong class="source-inline">or</strong> operator; that is, if the pointers are <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>, then the test is true <strong class="source-inline">if x = y</strong> is true or if <strong class="source-inline">x + 1 = y</strong> <span class="No-Break">is true.</span></p>&#13;
			<p lang="en-GB">This instruction is not implemented in a real processor. Why not if it’s a great idea? Well, first, it would be used in only a small number of programs requiring this particular operation. It takes up silicon real estate on the chip that is hardly ever used. That’s a waste of precious resources. Second, machine code is mostly generated by compilers, and it’s not easy to design compilers that use special-purpose operations such as this effectively. Third, this instruction performs three operations: comparing <strong class="source-inline">p</strong> and <strong class="source-inline">q</strong>, adding 1 to <strong class="source-inline">q</strong>, comparing <strong class="source-inline">p</strong> and <strong class="source-inline">q+1</strong>. Consequently, it takes longer to execute than single-operation instructions. That reduces the efficiency of <span class="No-Break">the computer.</span></p>&#13;
			<p lang="en-GB">In the next section, you will be introduced to the notion of instructions with fields that have variable lengths. Real machines do not have this facility. The reason for including this section is to demonstrate instruction decoding and <span class="No-Break">bit processing.</span></p>&#13;
			<h1 id="_idParaDest-129" lang="en-GB"><a id="_idTextAnchor132"/>Variable-length instructions</h1>&#13;
			<p lang="en-GB">This short section provides ideas for experimentation with instructions and their formats and extends your understanding of instructions, their structure, and the trade-off involved in creating instruction sets. It is not designed to illustrate a <span class="No-Break">real computer.</span></p>&#13;
			<p lang="en-GB">Like many computers, TC1 has <em class="italic">fixed-length fields</em> in its opcode; that is, the number of bits dedicated to each field is fixed and does not vary from instruction to instruction. There are always 16 bits in the literal field, even if the current instruction does not require a literal. Wasteful indeed. Since the purpose of TC1 is experimentation, we demonstrate how you might make the number of registers variable (i.e., user-definable). Adding more registers speeds up computation by requiring fewer memory accesses. However, there is a price; where do you get the extra bits that would be needed to specify the registers? Do you take the extra register bits from the opcode field (reducing the number of different instructions), or do you take them from the literal field (reducing the maximum size of a literal that can be loaded in a single instruction)? Or do you implement multiple banks of registers and switch in a new set of registers (called <em class="italic">windowing</em>) as a <span class="No-Break">temporary measure?</span></p>&#13;
			<p lang="en-GB">Here, we provide some code that we used to experiment with variable register sizes. This is not a complete program. All it does is let you enter the size of register fields and then run a test by creating a <em class="italic">dummy</em> instruction. It’s a dummy instruction because the opcode is set to <strong class="source-inline">1111110</strong> and the literal field is all zeros. It just tests the ability to place the register fields at appropriate points in an instruction and automatically adjust the length of the <span class="No-Break">literal field.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.2</em> provides the output of a single run of this program. The inputs are in bold. You can see that the register fields have been selected as 3, 3, and 5 bits wide. The instruction is <strong class="source-inline">ADD R7,R2,R31</strong> (note that the only data extracted is <strong class="source-inline">7</strong>, <strong class="source-inline">2</strong>, and <strong class="source-inline">31</strong>, as we are not interested in the <span class="No-Break">actual instruction):</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer044" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_7.2_B19624.jpg" alt="Figure 7.2 – Demonstration of variable-length fields" width="1360" height="402"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Demonstration of variable-length fields</p>&#13;
			<p lang="en-GB">The final binary instruction is given with each of its fields in a different style for clarity. You can see that the register fields have been placed in the correct positions in the instruction and the remaining bits (the literal field) are padded <span class="No-Break">with zeros.</span></p>&#13;
			<p lang="en-GB">It may seem strange to have register fields of different widths. That means that some parameters in an instruction can access more registers than others. Such a facility can be useful; for example, you could use some of the registers as special-purpose registers (e.g., a stack pointer), or they could be used to hold frequently accessed constants (such as <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">):</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span># 31 Aug 2020 TESTING a variable format instruction set V1</span>&#13;
<span>x = input("Enter three width for: rD,rS1,rS2 (e.g., 2,2,3) &gt;&gt; ")</span>&#13;
<span>x = x.replace(' ',',')</span>&#13;
<span>x = x.split(",")                          <span class="sc-comment"># Get register sizes and convert list into tokens</span></span>&#13;
<span>x1 = int(x[0])                            <span class="sc-comment"># First register size rD</span></span>&#13;
<span>x2 = int(x[1])                            <span class="sc-comment"># Second register size rS1</span></span>&#13;
<span>x3 = int(x[2])                            <span class="sc-comment"># Third register size </span><span class="sc-comment">rS2</span></span>&#13;
<span>y = (x1,x2,x3)                            <span class="sc-comment"># Convert data size elements into a tuple</span></span>&#13;
<span>z = input("Enter three register operands for: rD,rS1,rS2 (e.g. R1,R3,R2)&gt;&gt; ")</span>&#13;
<span>opCode = 0b1111110                        <span class="sc-comment"># Dummy 7-bit binary opcode</span></span>&#13;
<span>z = z.replace(' ',',')</span>&#13;
<span>z = z.split(",")</span>&#13;
<span>t1,t2,t3 = 0,0,0                          <span class="sc-comment"># t1,t2,t3 are up to three tokens in the predicate</span></span>&#13;
<span>t1 = int(z[0][1:])                        <span class="sc-comment"># Extract three parameters</span></span>&#13;
<span>t2 = int(z[1][1:])</span>&#13;
<span>t3 = int(z[2][1:])</span>&#13;
<span>print ('Register widths: rD = ',t1, 'rS1 = ',t2,'rS2 = ',t3)   <span class="sc-comment"># Print the registers</span></span>&#13;
<span>opCode = opCode &lt;&lt; x1 | t1                <span class="sc-comment"># Insert the rD field</span></span>&#13;
<span>opCode = opCode &lt;&lt; x2 | t2                <span class="sc-comment"># Insert the rS1 field</span></span>&#13;
<span>opCode = opCode &lt;&lt; x3 | t3                <span class="sc-comment"># Insert the rS2 field</span></span>&#13;
<span>intLen = 32 - 7 - x1 - x2 - x3            <span class="sc-comment"># Calculate the length of the literal field</span></span>&#13;
<span>opCode = opCode &lt;&lt; intLen                 <span class="sc-comment"># Shift left by literal size to create 16-bit instruction</span></span></pre>&#13;
			<pre class="source-code">print("opCode",bin(opCode))               <span class="sc-comment"># Print the result</span></pre>&#13;
			<p lang="en-GB">Running this code with some sample values gives the following output (<span class="No-Break"><em class="italic">Figure 7</em></span><em class="italic">.3</em>). As you can see, the register files have been inserted into <span class="No-Break">the opcode:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Enter three width for: rD,rS1,rS2 (e.g., 2,2,3) &gt;&gt; <strong class="bold">3,4,5</strong></span>&#13;
<span>Enter register operands for: rD,rS1,rS2 (e.g.,R1,R3,R2)&gt;&gt; <strong class="bold">R4,R6,R30</strong></span>&#13;
<span>Register widths: rD =  4 rS1 =  6 rS2 =  30</span>&#13;
<span>opCode 0b1111110 <span class="sc-source-bold-bg">100</span><strong class="bold"> </strong><span class="sc-source-bold-bg">0110</span><strong class="bold"> </strong><span class="sc-source-bold-bg">11110</span><strong class="bold"> </strong>0000000000000</span></pre>&#13;
			<p class="IMG---Figure ParaOverride-1" lang="en-GB"><img class="_idGenObjectAttribute-2" src="Images/Figure_7.3_B19624.jpg" alt="Figure 7.3 – Demonstration of variable-length operand fields" width="1013" height="199"/></p>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Demonstration of variable-length operand fields</p>&#13;
			<h2 id="_idParaDest-130" lang="en-GB"><a id="_idTextAnchor133"/>A variable-length instruction machine</h2>&#13;
			<p lang="en-GB">Throughout <a id="_idIndexMarker491"/>this text, we have demonstrated machines with fixed-length instruction words. Computers based on this paradigm frequently fall into the RISC category. However, classic CISC machines (from the humble 8080 and 6800 to the less humble 8086 and 68000 microprocessors) had variable-length instructions, as we’ve already pointed out. Consider the following example of a stream of variable-length instructions, where <strong class="source-inline">1</strong> represents a 1-word instruction, <strong class="source-inline">2</strong> represents a 2-word instruction, and so on (<span class="No-Break"><em class="italic">Figure 7</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer046" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_7.4_B19624.jpg" alt="Figure 7.4 – Instruction stream with variable-length opcodes" width="914" height="62"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Instruction stream with variable-length opcodes</p>&#13;
			<p lang="en-GB">As instructions are executed, they must be decoded and the appropriate number of bytes appended to the current instruction. A problem with this approach is that it makes look-ahead <a id="_idIndexMarker492"/>processing difficult because you do not know where future instructions begin and end until you’ve decoded the <span class="No-Break">current instruction.</span></p>&#13;
			<p lang="en-GB">Here, we’re going to demonstrate a very simple variable-length machine that uses 8-bit words and an instruction can be 8, 16, 24, or 32 bits long. An operation like <strong class="source-inline">nop</strong> is 8 bits, <strong class="source-inline">branch</strong> is 16 bits, <strong class="source-inline">move</strong> is 24 bits, and <strong class="source-inline">add</strong> is 32 bits. The instruction itself is 8 bits (in the demonstration, we use only 5 bits for simplicity). An instruction is read and the two most-significant bits determine the total number of bytes required by <span class="No-Break">this instruction.</span></p>&#13;
			<p lang="en-GB">The number of registers used by this machine is … none! For the sake of simplicity, and fun, we decided to make all <span class="No-Break">instructions memory-based.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Consequently, we need two counters: one that counts the instructions and one that counts the bytes. For example, the instruction sequence in <em class="italic">Table 7.1</em> demonstrates the <em class="italic">instruction address</em> (sequential) and the <em class="italic">memory address</em> of the first byte of an instruction. Here, instructions vary from 1 byte (<strong class="source-inline">stop</strong>) to 4 <span class="No-Break">bytes (</span><span class="No-Break"><strong class="source-inline">add</strong></span><span class="No-Break">):</span></p>&#13;
			<table id="table001-5" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="bold">Code</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="bold">Instruction address</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="bold">Memory address</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">ld</strong><strong class="source-inline CharOverride-3">  </strong><span class="No-Break"><strong class="source-inline">28,7</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">0</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-4">0</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">ld</strong><strong class="source-inline CharOverride-3">  </strong><span class="No-Break"><strong class="source-inline">27,2</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">1</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-4">3</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">ld</strong><strong class="source-inline CharOverride-3">  </strong><span class="No-Break"><strong class="source-inline">26,1</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">2</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-4">6</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="source-inline">add 28,28,26</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">3</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="CharOverride-4">9</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="source-inline">dec 26</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">4</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break CharOverride-4">13</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="source-inline">bne 3</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">5</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break CharOverride-4">15</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="source-inline">stop</strong></span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">6</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break CharOverride-4">17</span></p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">Next <span class="No-Break">free space</span></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="source-inline">7</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><span class="No-Break"><strong class="source-inline">18</strong></span></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – Instruction and memory addresses for variable-length code</p>&#13;
			<p lang="en-GB">Here, we have used simple numeric addresses. Some addresses are literal bytes; for example, <strong class="source-inline">ld 28,7</strong> means load memory location <strong class="source-inline">28</strong> with the <span class="No-Break">number </span><span class="No-Break"><strong class="source-inline">7</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">The following code provides a program to implement such a computer. Note that the actual program is supplied as a list. This program does not have the textual flexibility of TC1; it’s a simple demonstration. An instruction is entered in lowercase text with commas separating the parameters. All values are in decimal. However, limited symbolic names are permitted; for example, <strong class="source-inline">abc: equ 12</strong> binds the number <strong class="source-inline">12</strong> to the symbolic name <strong class="source-inline">abc:</strong>. Note the need for a colon after <span class="No-Break">the name.</span></p>&#13;
			<p lang="en-GB">All data is <a id="_idIndexMarker493"/>either a number or a memory address; for example, <strong class="source-inline">add 12,13,20</strong> adds the contents of memory location <strong class="source-inline">13</strong> to the contents of memory location <strong class="source-inline">20</strong> and puts the sum in memory <span class="No-Break">location </span><span class="No-Break"><strong class="source-inline">12</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">A branch requires an actual address. Branching is absolute (direct) and not program counter-relative. To branch to the instruction beginning at address <strong class="source-inline">16</strong>, you write <strong class="source-inline">bra 16</strong>. However, symbolic names are supported and you can write <strong class="source-inline">bra abc:</strong>, provided that the target is labeled <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">abc:</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">In this simulator, the instruction counter is incremented by one every time a new instruction is read. However, the memory counter is incremented every time a new byte is added to this instruction. The added bytes may be 1, 2, 3, <span class="No-Break">or 4.</span></p>&#13;
			<p lang="en-GB">Since you have to give a byte branch address, you not only have to count the number of instructions branched but also the number of bytes branched. To do this, we create a mapping table that maps the instruction address to the byte address. This table is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">map[]</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>print ('Demonstrating multiple length instructions. Version 3 December 8 2022 \n')</span></pre>&#13;
			<pre class="source-code">mem     = [0] * 128</pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">lookUp{}</strong> dictionary describes each instruction with a binary key and a value consisting <a id="_idIndexMarker494"/>of a mnemonic. The <strong class="source-inline">allOps{}</strong> dictionary consists of a key (the mnemonic) and a tuple containing the instruction length <span class="No-Break">and opcode:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>lookUp  = {0b00001:'nop',0b00010:'stop',0b01000:'inc',0b01001:'dec',  \</span>&#13;
<span>           0b01010:'bra',0b01011:'beq',0b01100:'bne',0b10000:'mov',   \</span>&#13;
<span>           0b10001:'cmpl',0b10010:'cmp',0b10011:'ld',0b10100:'st',    \</span>&#13;
<span>           0b11000:'add',0b11001:'sub'}</span>&#13;
<span>allOps  = {'nop':(1,1),'stop':(1,2),'inc':(2,8),'dec':(2,9),'bra':(2,10),   \</span>&#13;
<span>           'beq':(2,11),'bne':(2,12),'mov':(3,16),'ld':(3,19),              \</span>&#13;
<span>           'cmpl':(3,17),'cmp':(3,18),'add':(4,24),'sub':(4,25),'test':(0,0)}</span>&#13;
<span><span class="sc-comment"># NOTE that progS is the actual program to be executed. It is embedded into the program</span></span>&#13;
<span>progS   = ['this: equ 26','ld this:,7','that: equ 28','ld 27,2', \</span>&#13;
<span>           'ld that:,1','loop: add 28,28,26', 'dec 26','bne loop:','stop']</span>&#13;
<span>symTab  = {}                                          <span class="sc-comment"># Label symbol table</span></span>&#13;
<span>prog    = []                                          <span class="sc-comment"># progS is prog without equates</span></span>&#13;
<span>for i in range (0,len(progS)):                        <span class="sc-comment"># Process source code for equates</span></span>&#13;
<span>    thisLine = progS[i].split()                       <span class="sc-comment"># Split source code on spaces</span></span>&#13;
<span>    if len(thisLine) &gt; 1 and thisLine[1] == 'equ':    <span class="sc-comment"># Is this line an equate?</span></span>&#13;
<span>         symTab.update({thisLine[0][0:]:thisLine[2]}) <span class="sc-comment"># Store label in symbol table. </span></span>&#13;
<span>    else: prog.append(progS[i])                  <span class="sc-comment"># Append line to prog unless it's an equate</span></span></pre>&#13;
			<p lang="en-GB">The next <a id="_idIndexMarker495"/>step after removing equates is to clean up the source code and deal <span class="No-Break">with labels:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>for i in range (0,len(prog)):             <span class="sc-comment"># Process source code (now without equates)</span></span>&#13;
<span>    prog[i] = prog[i].replace(',',' ')    <span class="sc-comment"># Remove commas</span></span>&#13;
<span>    prog[i] = prog[i].split(' ')          <span class="sc-comment"># Tokenize</span></span>&#13;
<span>    token1 = prog[i][0]                   <span class="sc-comment"># Get first token of instruction</span></span>&#13;
<span>    if token1[-1] == ':':                 <span class="sc-comment"># If it ends in :, it's a label</span></span>&#13;
<span>        j = str(i)                        <span class="sc-comment"># Note: we have to store i as a string not an integer</span></span>&#13;
<span>        symTab.update({token1:j})         <span class="sc-comment"># Add label and instruction number to symbol table</span></span>&#13;
<span>        prog[i].pop(0)                    <span class="sc-comment"># Remove label from this line. NOTE "pop"</span></span>&#13;
<span>print('Symbol table: ', symTab)</span>&#13;
<span>map = [0] * 64                            <span class="sc-comment"># Map instruction number to byte address</span></span></pre>&#13;
			<p lang="en-GB">We now go through the code, but not in execution mode. We create a memory counter, mc, that acts rather like a program counter but serves to keep track of the instructions <span class="No-Break">in memory:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>mC  = 0                                 <span class="sc-comment"># Memory counter (store code from 0)</span></span>&#13;
<span>for iC in range (0,len(prog)):          <span class="sc-comment"># Step through the program</span></span>&#13;
<span>    instruction = prog[iC]              <span class="sc-comment"># Read an instruction. iC = instruction counter</span></span>&#13;
<span>    mCold = mC                          <span class="sc-comment"># Remember old memory counter (address of first byte)</span></span>&#13;
<span>    map[iC] = mC                        <span class="sc-comment"># Map byte address to instruction address</span></span>&#13;
<span>    mnemonic = instruction[0]           <span class="sc-comment"># The first token is the mnemonic</span></span>&#13;
<span>    mem[mC] = allOps[mnemonic][1]       <span class="sc-comment"># Store opcode in memory</span></span></pre>&#13;
			<pre class="source-code">    mC = mC + 1                         <span class="sc-comment"># Point to next free memory location</span>&#13;
<span>    numOperands = allOps[mnemonic][0] - 1    <span class="sc-comment"># Get the number of operands from dictionary</span></span>&#13;
<span>    if numOperands &gt; 0:                 <span class="sc-comment"># If one or more operands</span></span>&#13;
<span>        if instruction[1] in symTab:    <span class="sc-comment"># See if operand is in symbol table</span></span>&#13;
<span>            instruction[1] = symTab[instruction[1]]   <span class="sc-comment"># If it is, convert into as string</span></span>&#13;
<span>        mem[mC] = int(instruction[1])   <span class="sc-comment"># Store address in memory as integer</span></span>&#13;
<span>        mC = mC + 1                     <span class="sc-comment"># Bump up byte counter</span></span>&#13;
<span>    if numOperands &gt; 1:                 <span class="sc-comment"># Do the same for two operands</span></span>&#13;
<span>        if instruction[2] in symTab:    <span class="sc-comment"># See if operand is in symbol table</span></span>&#13;
<span>            instruction[2] = symTab[instruction[2]]    <span class="sc-comment"># Convert to address as string</span></span>&#13;
<span>        mem[mC] = int(instruction[2])</span>&#13;
<span>        mC = mC + 1</span>&#13;
<span>    if numOperands &gt; 2:                 <span class="sc-comment"># Now deal with 3-operand instructions</span></span>&#13;
<span>        if instruction[3] in symTab:    <span class="sc-comment"># See if operand is in symbol table</span></span>&#13;
<span>            instruction[3] = symTab[instruction[3]]   <span class="sc-comment"># If it is, convert to string</span></span>&#13;
<span>        mem[mC] = int(instruction[3])</span>&#13;
<span>        mC = mC + 1</span>&#13;
<span>    instPrint =  ' {0:&lt;15}'.format( (' ').join(instruction)) <span class="sc-comment"># reformat instruction</span></span>&#13;
<span>    print('iC=', iC,'\t', 'Op =', mnemonic, '\tNumber of operands =',  \</span>&#13;
<span>           numOperands, '\t mC =', mCold, '\tInstruction =',           \</span>&#13;
<span>           instPrint, 'memory =', mem[mCold:mC])</span>&#13;
<span>print('Memory (in bytes) =', mem[0:40], '\n')</span>&#13;
<span>                                               <span class="sc-comment"># EXECUTE THE CODE</span></span>&#13;
<span>print('\nCode execution: press enter \n')</span>&#13;
<span>pc, iC, z = 0, 0, 0                            <span class="sc-comment"># Initialize program and instruction counters</span></span></pre>&#13;
			<p lang="en-GB">Now we <a id="_idIndexMarker496"/>can execute the code by stepping through the instructions in memory using a program counter. However, the program counter is incremented by the length of each instruction after the current instruction has <span class="No-Break">been read:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>run = True</span>&#13;
<span>while run:                                       <span class="sc-comment"># Instruction execution loop</span></span>&#13;
<span>    pcOld  = pc                                  <span class="sc-comment"># Remember pc at start of this cycle</span></span>&#13;
<span>    opCode = mem[pc]                             <span class="sc-comment"># Read opcode</span></span>&#13;
<span>    opLen  = (opCode &gt;&gt; 3) + 1                   <span class="sc-comment"># Get instruction length from opcode</span></span>&#13;
<span>    if opCode == 0b00010:                        <span class="sc-comment"># Test for stop</span></span>&#13;
<span>        run = False                              <span class="sc-comment"># Terminate on stop instruction</span></span>&#13;
<span>        print('Execution terminated on stop')    <span class="sc-comment"># Say 'Goodbye'</span></span>&#13;
<span>        break                                    <span class="sc-comment"># and exit the loop</span></span>&#13;
<span>    operand1, operand2, operand3 = '', '', ''    <span class="sc-comment"># Dummy operands (null strings)</span></span>&#13;
<span>    if opLen &gt; 1: operand1 = mem[pc + 1]</span>&#13;
<span>    if opLen &gt; 2: operand2 = mem[pc + 2]</span>&#13;
<span>    if opLen &gt; 3: operand3 = mem[pc + 3]</span>&#13;
<span>    pc = pc + opLen</span>&#13;
<span>    iC = iC + 1</span></pre>&#13;
			<pre class="source-code">    mnemonic = lookUp[opCode]</pre>&#13;
			<p lang="en-GB">After <a id="_idIndexMarker497"/>looking up the opcode, we use an <strong class="source-inline">if...elif</strong> construct to examine successive mnemonics to determine the current operation. Note the dummy no-operation is implemented by Python’s pass, which <span class="No-Break">does nothing:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    if   mnemonic == 'nop': pass</span>&#13;
<span>    elif mnemonic == 'inc': mem[operand1] = mem[operand1] + 1</span>&#13;
<span>    elif mnemonic == 'dec':</span>&#13;
<span>        z = 0</span>&#13;
<span>        mem[operand1] = mem[operand1] - 1</span>&#13;
<span>        if mem[operand1] == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'bra':  pc = map[operand1] <span class="sc-comment"># Map instruction address to byte address</span></span>&#13;
<span>    elif mnemonic == 'beq' and z == 1: pc = map[operand1]</span>&#13;
<span>                                                 <span class="sc-comment"># Map instruction address to byte address</span></span>&#13;
<span>    elif mnemonic == 'bne' and z == 0: pc = map[operand1]</span>&#13;
<span>                                                 <span class="sc-comment"># Map instruction address to byte address</span></span>&#13;
<span>    elif mnemonic == 'ld':  mem[operand1] = operand2</span>&#13;
<span>    elif mnemonic == 'mov': mem[operand1] = mem[operand2]</span></pre>&#13;
			<p lang="en-GB">The <strong class="source-inline">cmp</strong> compare <a id="_idIndexMarker498"/>operation subtracts two operands and sets the z-bit to <strong class="source-inline">1</strong> if the result is zero. Otherwise, <strong class="source-inline">z</strong> is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    elif mnemonic == 'cmp':</span>&#13;
<span>        diff = mem[operand1] - mem[operand2]</span>&#13;
<span>        z = 0</span>&#13;
<span>        if diff == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'cmpl':</span>&#13;
<span>        diff = mem[operand1] - operand2</span>&#13;
<span>        z = 0</span>&#13;
<span>        if diff == 0: z = 1</span>&#13;
<span>    elif mnemonic == 'add': mem[operand1] = mem[operand2] + mem[operand3]</span>&#13;
<span>    elif mnemonic == 'sub':</span>&#13;
<span>        mem[operand1] = mem[operand2] - mem[operand3]</span>&#13;
<span>        z = 0</span>&#13;
<span>        if mem[operand1] == 0: z = 1</span></pre>&#13;
			<p lang="en-GB">At the end <a id="_idIndexMarker499"/>of the <strong class="source-inline">execute</strong> loop, we get input from the keyboard. This simply introduces a wait until the <em class="italic">Enter</em>/<em class="italic">return</em> key is hit before the next instruction is executed. The remaining Python code formats <span class="No-Break">the output:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    x = input('... ')</span>&#13;
<span>    xxxx =  mnemonic + ' ' + str(operand1) + ' ' + str(operand2) \</span>&#13;
<span>    + ' ' + str(operand3)</span>&#13;
<span>    instPrint =  ' {0:&lt;15}'.format(xxxx)                   <span class="sc-comment"># re-format the instruction</span></span>&#13;
<span>    print ('iC=',iC-1,'\tpc=',pcOld,'\tOp=',mnemonic,'z=',z,      \</span></pre>&#13;
			<pre class="source-code">           '\tmem 24-35=',mem[24:36],'\tInstruction = ', instPrint)</pre>&#13;
			<p lang="en-GB">We have only briefly touched on the topic of variable-length instructions. In principle, it’s a very simple idea. An instruction is read, decoded, and executed. As each instruction is fetched into the computer, it has to be decoded and the program counter advanced by the number of words taken up by the current instruction. In practice, this creates problems because branch addresses are no longer just the number of instructions from the branch but also the number of memory locations taken up by <span class="No-Break">those instructions.</span></p>&#13;
			<h1 id="_idParaDest-131" lang="en-GB"><a id="_idTextAnchor134"/>Summary</h1>&#13;
			<p lang="en-GB">The previous chapter introduced TC1, a Python-based computer simulator that could be used to develop and test instruction set architectures. In this chapter, we explored aspects of simulator design in <span class="No-Break">more depth.</span></p>&#13;
			<p lang="en-GB">We looked at how you can create new instructions and add them to TC1’s instruction set. Advanced instructions that perform a lot of special-purpose computation were once the province of the classic CISC processor, such as the Motorola 68K family. Then, with the rise of the RISC architecture and its stress on simplicity and single-cycle instructions, the CISC processor seemed about to go out of fashion. However, many modern computers have incorporated complex instructions for special applications such as data encoding, image processing, and <span class="No-Break">AI applications.</span></p>&#13;
			<p lang="en-GB">We looked a little more deeply at how you can check the input of a simulator and ensure that errors in data and instructions can <span class="No-Break">be detected.</span></p>&#13;
			<p lang="en-GB">We also looked at various topics in Python programming, such as data formatting. In principle, printing data the way you want it to look is easy. In practice, it is a little more complicated (not least because there are several methods of <span class="No-Break">formatting data).</span></p>&#13;
			<p lang="en-GB">This chapter expanded on the notion of tracing a program while it is being executed and demonstrated some of the techniques involved in printing the data you want to see during a <span class="No-Break">simulator run.</span></p>&#13;
			<p lang="en-GB">As well as looking at new instructions, we explored the concept of variable-length instructions. We started with a demonstration of how you could change the number of bits in each register address field at runtime to change the number of addressable registers. This is not a realistic factor in instruction set design (at the moment), but there was a period when register windows became popular and you could, indeed, expand the number <span class="No-Break">of registers.</span></p>&#13;
			<p lang="en-GB">We introduced the notion of variable-length instructions when each instruction can be an integer number of multiples of the computer’s word length. This approach allows instructions with an unlimited level of complexity at the price of more complicated decoding mechanisms. We demonstrated the design of a primitive variable instruction length machine that could easily be expanded to a simulator with the full complexity <span class="No-Break">of TC1.</span></p>&#13;
			<p lang="en-GB">The next chapter returns to the simulator and looks at several simulators for different types <span class="No-Break">of architecture.</span></p>&#13;
		</div>&#13;
	</div></body></html>