<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-118" class="chapter-number" lang="en-GB"><a id="_idTextAnchor121"/>7</h1>&#13;
			<h1 id="_idParaDest-119" lang="en-GB"><a id="_idTextAnchor122"/>Extending the TC1</h1>&#13;
			<p lang="en-GB">In this chapter, you will learn how to expand the functionality of the TC1 simulator that we designed in <a href="B19624_06.xhtml#_idTextAnchor091"><em class="italic">Chapter 6</em></a>. We also look at some of the elements of the design of a simulator, including input/output techniques and data validation, and describe how the simulator can display the state of a processor as it executes instructions.</p>&#13;
			<p lang="en-GB">TC1 is a compromise. Initially, it was designed to support teaching the basics of computer architecture. It is an aid to understanding instruction encoding, instruction format trade-offs, the execution of an instruction, addressing modes, and the ability to design and implement an instruction set.</p>&#13;
			<p lang="en-GB">Here, we look at ways of expanding TC1 by, for example, discussing how new instructions can be added. Finally, we deal with a topic that we have omitted so far: how to create a computer architecture with variable-length instructions. That is, individual instructions can be an integer multiple of the basic word length.</p>&#13;
			<p lang="en-GB">The TC1 CPU simulator executes instructions one by one and prints the contents of the registers, program counter, and status flags after each instruction is executed. You can use this information to debug assembly-level programs. Often, when you look at the data, you find that the results are not what was expected; for example, you might want to execute a loop 9 times but execute it 10 times because you made an error in testing for the end of the loop.</p>&#13;
			<p lang="en-GB">We have three issues to deal with. The first is displaying the data. How do we display the data and how do we format it? Should the contents of a register be displayed as a decimal value, a binary string of 1s and 0s, or as hexadecimal characters?</p>&#13;
			<p lang="en-GB">Another design issue is whether to store historic data. That is, do we store the registers and flags after each instruction has been executed in an array so that we can look at values in previous operations?</p>&#13;
			<p lang="en-GB">Finally, how do we proceed? The TC1 simulator executes an instruction every time the <em class="italic">Enter</em> key is pressed. This provides a great way of stepping through a program but becomes infeasible when a loop requires 1,000 instructions to be executed before you get to the part of the program of interest. We will demonstrate how you can leave the single-step mode, execute a batch of instructions, and return to the single-step mode.</p>&#13;
			<h1 id="_idParaDest-120" lang="en-GB"><a id="_idTextAnchor123"/>Technical requirements</h1>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">You can find the programs used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07">https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter07</a>.</p>&#13;
			<h1 id="_idParaDest-121" lang="en-GB"><a id="_idTextAnchor124"/>Another look at python’s input and output</h1>&#13;
			<p lang="en-GB">Here, we go into a little more detail about data input and output mechanisms, as these topics are so important in the design of a simulator because formatting data is all-important to the interpretation of the data.</p>&#13;
			<p lang="en-GB">Let’s have another look at input in Python. Inputting data from the keyboard is very easy. To input text, you write <code>x = input()</code> and that’s it. When this statement is encountered, Python waits for your input. You enter the text and terminate it with a return (<em class="italic">Enter</em> key). If you just enter a return without text, the value of <code>x</code> will be a null string – that is, ' '. The data you input is stored in text form.</p>&#13;
			<p lang="en-GB">Python lets you display a prompt before receiving the input; for example, you can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = input('Please enter your age')</pre>&#13;
			<p lang="en-GB">Because the input is in character form, you must convert numeric values into integer form before using them. It’s easy to perform conversions into decimal, binary, or hexadecimal, as the following examples show. You just add the number base as a second parameter to the <code>int()</code> function:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = input('Enter the constant ')&#13;
y = int(x)                        # For a decimal constant&#13;
y = int(x,2)                      # For a binary constant&#13;
y = int(x,16)                     # For a hexadecimal constant</pre>&#13;
			<p lang="en-GB">Let’s consider a more sophisticated example. We’ll input an instruction such as <code>ADD R3,R7</code>,<code>$12FA</code> and extract the three integers <code>3</code>, <code>7</code>, and <code>0x12FA</code>. In this example, a $ prefix indicates a hexadecimal value (a convention used by Motorola).</p>&#13;
			<p lang="en-GB">The following code performs this operation. The input uses a <code>replace</code> function to convert all commas into spaces. We combine the replace operation with the input operation to create compact code. The input is followed by a <code>split</code> function to convert the string into tokens:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
inst        = input('Enter operation: &gt;&gt;').replace(',',' ')&#13;
p           = inst.split(' ')&#13;
t1,t2,t3,<strong class="bold">t4</strong> = p[0],int(p[1][1:]),int(p[2][1:]),<strong class="bold">int(p[3][1:],16)</strong></pre>&#13;
			<p lang="en-GB">Finally, we examine each of the four tokens in turn and extract the parameter as an integer (<code>t1</code>, <code>t2</code>, <code>t3</code>, and <code>t4</code>). Consider <code>t4</code>. The <code>p[3]</code> expression extracts the <code>"$12FA"</code> string. The second index, <code>[1:]</code>, extracts all characters after the first one to give <code>"12FA"</code>. This is still a character string. The final operation, int<code>(p[3]</code>[1:]<code>,</code>16<code>)</code>, converts the parameter string in hexadecimal form into the integer <code>4858</code>. The output produced by a second example, <code>ADD r3,r7,$1102</code>, was <code>ADD 3 </code><code>7 4354</code>.</p>&#13;
			<p lang="en-GB">As we’ve already seen, Python lets you put several equates on a line – for example, <code>a,b,c = p,q,r</code>. This results in the following:</p>&#13;
			<pre>a = p</pre>&#13;
			<pre>b = q</pre>&#13;
			<pre>c = r</pre>&#13;
			<p lang="en-GB">This shorthand is useful when dealing with simple equates (usually during an initialization process). Some programmers prefer not to use this technique as it can reduce program readability. Let’s test the preceding fragment of code. We’ve added some <code>print</code> statements between the operations so that we can follow what’s going on as the code is executed:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
inst = input('Enter operation: &gt;&gt;').replace(',',' ')&#13;
print('inst',inst)&#13;
p = inst.split(' ')&#13;
print ('p',p)&#13;
t1,t2,t3,t4 = p[0],int(p[1][1:]),int(p[2][1:]),int(p[3][1:],16)&#13;
print(‚t1,t2,t3,t4',t1,t2,t3,t4)</pre>&#13;
			<p lang="en-GB">The output is next. Note that when we print <code>t1</code> to <code>t4</code>, the numeric value of the hexadecimal operand is given in its decimal form:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Enter operation: &gt;&gt;<strong class="bold">add r1,r2,$FACE</strong>&#13;
<strong class="bold">inst add r1 r2 $FACE</strong>&#13;
p ['add', 'r1', 'r2', '$FACE']&#13;
t1,t2,t3,t4 add 1 2 64206</pre>&#13;
			<p lang="en-GB">The next section looks at how we format data such as numbers so that they can be made much easier for the reader to understand; for example, sometimes you might wish to represent the decimal 42 as <code>101010</code> and sometimes as <code>00101010</code> or <code>002A</code>.</p>&#13;
			<h2 id="_idParaDest-122" lang="en-GB"><a id="_idTextAnchor125"/>Displaying data</h2>&#13;
			<p lang="en-GB">We now look more deeply at the ways in which data can be displayed in Python. When you are observing the execution of a program, you want to see what has changed after each instruction has been executed. A computer’s state is determined by the contents of its registers and memory, the program counter, and its status bits, plus its memory.</p>&#13;
			<p lang="en-GB">How do we display data? Since data can represent anything you want it to, the data in a register has no intrinsic meaning. By convention, CPU simulators represent data in hexadecimal form. This is partially because each 16-bit register holds 4 hexadecimal characters and that provides a rather convenient way for humans to handle data (try remembering 16-bit strings of 1s and 0s). Some simulators permit binary, hex, or decimal displays, and others allow data to be displayed as characters (i.e., the data is assumed to be ASCII-encoded).</p>&#13;
			<p lang="en-GB">As well as choosing the base in which we display numbers, we must choose the formatting in order to make it easy to read (e.g., aligning groups of characters). Like all high-level computer languages, Python provides ways of formatting printed data. And like formatting in most other languages, I am tempted to describe Python’s formatting as a bit inelegant.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">We do not have the space to do justice to Python’s formatting here. We simply provide some examples and enough information for you to modify them.</p>&#13;
			<p lang="en-GB">One thing we need to print in a simulator is the instruction. That could not be simpler because it’s a string. So, we can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
print(listing[<strong class="bold">pcOld</strong>])          # Listing contains a list of string instructions</pre>&#13;
			<p lang="en-GB">This looks up the string item (instruction) at the <code>pcOld</code> address and prints it. Since <code>pc</code> is modified during an instruction cycle, we print the old value at the start of the current cycle.</p>&#13;
			<p lang="en-GB">But each instruction is going to be of a different length (depending on the number of operands), and that means the next item printed on the same line will not be vertically aligned. We often need to print the instruction within a predefined frame. We can do this with the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
print("<strong class="bold">{:&lt;23}</strong>"<strong class="bold">.format</strong>(listing[pcOld]))</pre>&#13;
			<p lang="en-GB">We are using the<code>.format()</code>method. The <code>"{:&lt;23}"</code> expression controls the format. The integer <code>23</code> is the width of the text in characters. The &lt; symbol indicates that the string is left-justified. If we’d wanted it right-justified, we would have used &gt;. The value following <code>format()</code> is the string to be printed.</p>&#13;
			<p lang="en-GB">Suppose we want to display the eight registers on the same line, each as a six-character hexadecimal value. First, consider the following Python code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
z = 0x4ace          # The hex data to print&#13;
print("%06x" %z)    # Printing it in 6 chars with leading zeros</pre>&#13;
			<p lang="en-GB">When executed, this code prints the following:</p>&#13;
			<pre>004ace</pre>&#13;
			<p lang="en-GB">We set up a variable, <code>z</code>, for the <code>0x4ace</code> hexadecimal value and use <code>print("%06x" %z)</code> to display it as hex characters. The printed value is <code>004ace</code> because two leading zeros have been inserted. The formatting mechanism is <code>"%06x" %z</code>. The first component, <code>"</code>%<code>06x"</code>, specifies the format of the six-digit hex value that follows. It’s the first % that indicates the formatting. %<code>z</code> indicates the value to be printed.</p>&#13;
			<h3 lang="en-GB">The escape character</h3>&#13;
			<p lang="en-GB">Python’s <code>print</code> mechanism is easy to use; for example, <code>print('Answer =',a)</code> displays anything in quotes as a literal, and the value of any variables that appear in the <code>print</code> statement. You can have as many quoted items and variables as you want.</p>&#13;
			<p lang="en-GB">The <code>print</code> statement also allows formatting by using an <em class="italic">escape character</em> that gives the following character a special meaning. In Python, the escape character is <code>'</code> <code>\'</code>. If the escape is followed by <code>'n'</code>, it is equivalent to a new line; if the escape is followed by <code>'t'</code>, it is equivalent to a tab. Consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
a = 42&#13;
b = 'Test'</pre>&#13;
			<pre class="source-code">print('a is the integer\t',a,'\nb is the string','\t',b)</pre>&#13;
			<p lang="en-GB">The output from this code is as follows:</p>&#13;
			<pre>a is the integer              42</pre>&#13;
			<pre>b is the string               Test</pre>&#13;
			<p lang="en-GB">Note how this has been printed on two lines due to <code>'\n'</code> and the two values tabbed by <code>'\t'</code>. You can control the size of the tab, as the following example shows. The <code>expandtabs()</code> method sets the tab width (number of spaces) to the parameter provided. In this case, we have embedded the tab into a string and set the tab width to <code>6</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
print('This is a\ttab\ttest'<strong class="bold">.expandtabs(6)</strong>)&#13;
This is a   tab   test</pre>&#13;
			<p lang="en-GB">Some of the other escape sequences are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>\’</code>     Single quote</li>&#13;
				<li lang="en-GB"><code>\\</code>     Backslash</li>&#13;
				<li lang="en-GB"><code>\r</code>     Enter (return)</li>&#13;
				<li lang="en-GB"><code>\b</code>     Backspace</li>&#13;
				<li lang="en-GB"><code>\f</code>     Form feed (move to the same spot on the line below)</li>&#13;
				<li lang="en-GB"><code>\xhh</code>   Hexadecimal character value (e.g., <code>\x41</code> would print <code>A</code> because <code>0x41</code> is the ASCII value for A)</li>&#13;
			</ul>&#13;
			<h3 lang="en-GB">Escaping the escape</h3>&#13;
			<p lang="en-GB">There are occasions when you wish to escape the escape character and use the backslash as a printable character. In that case, you precede the string to be printed with either <code>r</code> or <code>R</code>. Note the <code>r</code> letter goes outside the string quotation marks, as in this example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
print(R'test\n one', 'test\n two')</pre>&#13;
			<p lang="en-GB">This results in the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
test\n one test&#13;
 two</pre>&#13;
			<p lang="en-GB">In this example, we use <code>R</code> to suppress <code>\n</code> as a newline command and print the actual <code>\n</code>. The second <code>\n</code> is not preceded by <code>R</code> and therefore acts as the newline command.</p>&#13;
			<h3 lang="en-GB">To and from ASCII</h3>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">I was lucky enough to be around at the birth of the microprocessor and I built a Motorola 6000 microprocessor system from the individual chips (including the display). At that time, I did not have any commercial software and I had to convert between ASCII characters and their numeric values myself. Life is easier today. Python provides two functions that allow you to convert between numeric and ASCII values. These are <code>ord()</code> and <code>chr()</code>. If you write <code>x = ord('B')</code>, the value of <code>x</code> would be its ASCII equivalent, <code>0x42</code> or <code>01000010</code> in binary. Similarly, if you write <code>y = chr(0x41)</code>, the value of <code>y</code> would be <code>'A'</code>.</p>&#13;
			<h4 lang="en-GB">Binary and hexadecimal strings</h4>&#13;
			<p lang="en-GB">Before we look at formatted strings in detail, consider the following simple example of console input using the Python interpreter. The text in bold is the output:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; x = 12345&#13;
&gt;&gt;&gt; y = hex(x)&#13;
&gt;&gt;&gt; print(y)&#13;
<strong class="bold">0x3039</strong>&#13;
&gt;&gt;&gt; z = y + 1&#13;
<strong class="bold">TypeError: can only concatenate str (not "int") to str</strong>&#13;
&gt;&gt;&gt; z = int(y,16) + 1&#13;
&gt;&gt;&gt; print (z)&#13;
<strong class="bold">12346</strong>&#13;
&gt;&gt;&gt; print(hex(z))&#13;
<strong class="bold">0x303a</strong></pre>&#13;
			<p lang="en-GB">We create an <code>x</code> variable equal to <code>12345</code> and create a new <code>y</code> value that is the hex version of <code>x</code>. Then, we print it and get the expected result of <code>0x3039</code>. Next, we create a new variable, <code>z</code>, where <code>z = y + 1</code>. This generates an error message because <code>y</code> is a text string and we cannot add the integer <code>1</code> to it. In the next line, we perform the addition again, but this time, we convert the hex string into integer form with <code>int(y,16)</code>. Now, we can print <code>z</code> as a decimal integer or as a hexadecimal string using <code>print(hex(z))</code>. In short, Python makes it easy to handle decimal, hexadecimal, and binary values, but you must be very careful to remember to ensure that you convert between string and integer forms where necessary.</p>&#13;
			<p lang="en-GB">Because we are dealing with binary numbers, it makes sense to display the output of TC1 in binary or hexadecimal formats. Suppose we wish to convert a decimal integer value into a <em class="italic">binary</em> string. Consider the following where we convert an integer, <code>p</code>, into a binary string and then print it:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
p = 1022&#13;
q = "{0:b}".format(p)&#13;
print('p in decimal is',p, "and in binary, it's",q)</pre>&#13;
			<p lang="en-GB">The <code>"{0:b}"</code> expression is the key to the formatting. It is a string enclosed in curly brackets. <code>0</code> tells it to print from the first character of the string and <code>b</code> signifies binary. This produces the following output:</p>&#13;
			<pre>p in decimal is 1022 and in binary, it's 1111111110</pre>&#13;
			<p lang="en-GB">So far, so good. But what if we want the output to be justified with a fixed number of characters – for example, 16? The following demonstrates such formatting when we convert 26 and <code>2033</code> into binary format:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
p1, p2 = 26, 2033&#13;
q1 = "{0:<strong class="bold">16</strong>b}".<strong class="bold">format(p1)</strong>&#13;
q2 = "{0:<strong class="bold">16</strong>b}".<strong class="bold">format(p2)</strong></pre>&#13;
			<pre class="source-code">print('p1 is',q1, '\nand p2 is',q2)</pre>&#13;
			<p lang="en-GB">The only change to the format string is from <code>"{0:b}"</code> to <code>"{0:16b}"</code>. That is, we have inserted the field-width of 16 characters before b. The effect of <code>16</code> is to define a 16-bit width for the string. The string is padded with spaces on the left. The output of this code is as follows:</p>&#13;
			<pre>p1 is            11010</pre>&#13;
			<pre>p2 is      11111110001</pre>&#13;
			<p lang="en-GB">In a lot of computer texts, it is normal to pad binary and decimal values with leading zeros on the left, rather than spaces. We can do this with a small change in the format. We insert <code>0</code> before the field width – that is, <code>"{0:0</code>16<code>b}"</code>. Now consider the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
p1, p2 = 26, 2033&#13;
q1 = "{0:<strong class="bold">016</strong>b}".format(p1)&#13;
q2 = "{0:<strong class="bold">016</strong>b}".format(p2)&#13;
print('p1 is',q1, '\nand p2 is',q2)</pre>&#13;
			<p lang="en-GB">This gives an output where the numbers are displayed in 16 bits and padded with leading zeros, as follows:</p>&#13;
			<pre>p1 is 0000000000011010</pre>&#13;
			<pre>p2 is 0000011111110001</pre>&#13;
			<p lang="en-GB">Hexadecimal values are treated in the same way by substituting <code>x</code> for <code>b</code> in the <code>format</code> statement:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
p1, p2 = 30, 64123&#13;
q1 = "{0:8x}".format(p1)&#13;
q2 = "{0:8x}".format(p2)&#13;
q3 = "{0:08x}".format(p1)&#13;
q4 = "{0:08x}".format(p2)&#13;
print('\n', q1, '\n', q3, '\n', q2, '\n', q4)</pre>&#13;
			<p lang="en-GB">This gives the following output. As you can see, it’s analogous to the binary version:</p>&#13;
			<pre>       1e</pre>&#13;
			<pre> 0000001e</pre>&#13;
			<pre>     fa7b</pre>&#13;
			<pre> 0000fa7b</pre>&#13;
			<p lang="en-GB">Of course, we can combine both print formats (i.e., binary and hexadecimal), as in this example:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x, y = 1037, 325&#13;
xBin = "{0:016b}".format(x)&#13;
yHex = "{0:04x}".format(y)&#13;
print("x is",xBin,"y is",yHex)</pre>&#13;
			<pre class="source-code">print("x is","0b" + xBin,"y is","0x" + yHex)</pre>&#13;
			<p lang="en-GB">We print two numbers, one in a binary format and one in a hexadecimal format. In the first case, the number is padded to 16 bits with leading zeros, and in the second case, it’s padded to 4 characters with leading zeros.</p>&#13;
			<p lang="en-GB">We print the result twice. In the second case, prefixes are added to the values to indicate the base. If the first number, <code>xBin</code>, is binary, we can concatenate “<code>0b</code>” simply by using a “+” symbol to add <code>0b</code> immediately before the binary string. The output from this code is as follows:</p>&#13;
			<pre>x is 0000010000001101 y is 0145</pre>&#13;
			<pre>x is 0b0000010000001101 y is 0x0145</pre>&#13;
			<p lang="en-GB">We can generalize the string method format as <code>"someString".format(&lt;parameter list&gt;</code>. This string method takes the string and inserts parameters into it that appear in the parameter list. You have to insert <em class="italic">placeholders</em> in the form of <code>{a:b}</code> into the string, which will receive the parameters when the string is printed.</p>&#13;
			<p lang="en-GB">Suppose you were printing a table of the powers of integers in the form x, x2, x3, x4. We could write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for x in range (1,7):&#13;
    print("Table of powers {<strong class="bold CharOverride-2">0</strong>:<strong class="bold CharOverride-2">2d</strong>}{<strong class="bold CharOverride-2">1</strong>:<strong class="bold CharOverride-2">3d</strong>}{<strong class="bold CharOverride-2">2</strong>:<strong class="bold CharOverride-2">4d</strong>}{<strong class="bold CharOverride-2">3</strong>:<strong class="bold CharOverride-2">6d</strong>}"<strong class="bold CharOverride-2">.format(x,x**2,x**3,x**4)</strong>)</pre>&#13;
			<p lang="en-GB">Each parameter placeholder is of the form<code>{</code>a<code>:b}</code>where the first element, a, is the position of the parameter in the list of parameters in the format. The second element, <code>b</code>, determines how the parameter is printed. In this case, it is a number and the letter <code>d</code>. The number defines the parameter’s width, and <code>d</code> indicates that it’s decimal; for example, the last parameter is specified as <code>{</code>3<code>:6d}</code>, which indicates the fourth parameter is a decimal integer taking six places. The following demonstrates the output from this fragment of code:</p>&#13;
			<pre>Table of powers  1   1    1      1</pre>&#13;
			<pre>Table of powers  2   4    8     16</pre>&#13;
			<pre>Table of powers  3   9   27     81</pre>&#13;
			<pre>Table of powers  4  16   64    256</pre>&#13;
			<pre>Table of powers  5  25  125    625</pre>&#13;
			<pre>Table of powers  6  36  216   1296</pre>&#13;
			<p lang="en-GB">In order to demonstrate the versatility of this approach, the next example prints the same table of powers but using a different format. As well as decimal, we also use binary and hexadecimal. Note that you only have to change b in <code>{</code>a<code>:b}</code> to change the base; for example, <code>{</code>6<code>:x}</code> tells the <code>print</code> statement to print the seventh parameter in hexadecimal format:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for x in range (1,10):&#13;
    print('Table of powers {0:2d} binary {1:10b} {2:4d} \&#13;
    hex {3:6x}'.format(x, x*x, x*x*x, x*x*x*x))</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Note you can write x*x*x, or <code>x**3</code>.</p>&#13;
			<p lang="en-GB">The following output demonstrates the results of this formatting technique:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Table of powers  1 binary          1    1 hex      1&#13;
Table of powers  2 binary        100    8 hex     10&#13;
Table of powers  3 binary       1001   27 hex     51&#13;
Table of powers  4 binary      10000   64 hex    100&#13;
Table of powers  5 binary      11001  125 hex    271&#13;
Table of powers  6 binary     100100  216 hex    510&#13;
Table of powers  7 binary     110001  343 hex    961&#13;
Table of powers  8 binary    1000000  512 hex   1000&#13;
Table of powers  9 binary    1010001  729 hex   19a1</pre>&#13;
			<p lang="en-GB">We have repeated the example with a few modifications. It is not necessary to give the order of the parameters if they are to be printed sequentially; for example, the first parameter specification can be written as <code>{:2d}</code> instead of <code>{0:2d}</code>. We’ve also changed the spacing to demonstrate how the width parameters operate:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for x in range (1,10):&#13;
    print('Powers {:2d} binary {:8b}{:4d} hex{:6x}'.format(x,x**2, x**3, x**4))&#13;
Powers  1 binary        1    1 hex      1&#13;
Powers  2 binary      100    8 hex     10&#13;
Powers  3 binary     1001   27 hex     51&#13;
Powers  4 binary    10000   64 hex    100&#13;
Powers  5 binary    11001  125 hex    271&#13;
Powers  6 binary   100100  216 hex    510&#13;
Powers  7 binary   110001  343 hex    961&#13;
Powers  8 binary  1000000  512 hex   1000&#13;
Powers  9 binary  1010001  729 hex   19a1</pre>&#13;
			<p lang="en-GB">Consider the following examples of the <code>format</code> mechanism. Here, we use the symbols “<code>&lt;</code>, <code>&gt;</code>, <code>^</code>” to control formatting. In order, these symbols force left justification, right justification, and centering within the stated width.</p>&#13;
			<p lang="en-GB">The following code prints the decimal integer <code>123</code> first in decimal form, using the three modifiers, and then in binary form using the same three modifiers. In each case, we have specified a width of 10 characters:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = 123&#13;
print(<strong class="bold">'{:&lt;10d}'</strong>.format(x))&#13;
print(<strong class="bold">'{:&gt;10d}'</strong>.format(x))&#13;
print(<strong class="bold">'{:^10d}'</strong>.format(x))&#13;
print(<strong class="bold">'{:&lt;10b}'</strong>.format(x))&#13;
print(<strong class="bold">'{:&gt;10b}'</strong>.format(x))</pre>&#13;
			<pre class="source-code">print(<strong class="bold">'{:^10b}'</strong>.format(x))</pre>&#13;
			<p lang="en-GB">The output generated by this code is as follows:</p>&#13;
			<pre>123                                   Left-justified</pre>&#13;
			<pre>       123                            Right-justified</pre>&#13;
			<pre>   123                                Centered</pre>&#13;
			<pre>1111011                               Left-justified</pre>&#13;
			<pre>   1111011                            Right-justified</pre>&#13;
			<pre> 1111011                              Centered</pre>&#13;
			<p lang="en-GB">We are now going to provide three examples of how strings representing numbers can be printed. The first demonstrates the formatting of individual numbers in integer, hexadecimal, binary, and real forms. The second example shows how we can take a list of registers, join them as a single string, and print their values. This is very useful in displaying data when stepping through instructions during a simulation. The third example demonstrates the successive steps in processing a hexadecimal value into the desired format.</p>&#13;
			<h3 lang="en-GB">Example 1 – Formatting numbers</h3>&#13;
			<p lang="en-GB">The following demonstrates this formatting mechanism, where we print several variables and a string. This uses a format specifier such as <code>%05d</code>, which means five decimal digits with leading zeros, and a placeholder such as <code>%x</code>, which means print the value of <code>x</code> in the format specified by %05d:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
x = 123&#13;
y = 0xABCD&#13;
p = 13.141592&#13;
q ='This is a test'&#13;
print("Hex example: %03x" %y, "%05d" %x, 'Alan', "%12.3f" %p, '%-20.14s' %q)</pre>&#13;
			<p lang="en-GB">This <code>print</code> statement displays the following (note hexadecimal appears in lowercase):</p>&#13;
			<pre>Hex example: abcd 00123 Alan       13.142 This is a test</pre>&#13;
			<h3 lang="en-GB">Example 2 – Printing a list of register values in hexadecimal form</h3>&#13;
			<p lang="en-GB">Consider the following expression with an 8-register array filled with data in various formats:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
R = [0xabcd,2,3,0x123,5,0x11010,7,124]&#13;
print('Registers =',<strong class="bold">" ".join</strong>(<strong class="bold">"%04x" % b for b in R</strong>))</pre>&#13;
			<p lang="en-GB">This expression prints the string ‘<code>Registers =</code>’<code>,</code> followed by a second string that contains eight four-character hexadecimal values. To create the second string, we use the string <code>join()</code> method. The string comprehension iterates over the registers applying the formatting structure to each element. That is, it reads <code>r[0]</code>, converts it into a string format, and then joins it to its left-hand neighbor (which is initially an empty string). This is repeated eight times and then that string is printed as follows:</p>&#13;
			<pre>Registers = abcd 0002 0003 0123 0005 11010 0007 007c</pre>&#13;
			<h3 lang="en-GB">Example 3 – Successively processing a decimal value into the desired hex format</h3>&#13;
			<p lang="en-GB">Consider the following sequence where we successively process the decimal value 44,350 until it is displayed in hexadecimal format in uppercase without the <code>0x</code> indicator prefix:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
&gt;&gt;&gt; x = 44350                              Here's a decimal number&#13;
&gt;&gt;&gt; print(<strong class="bold">hex(x)</strong>)                          Can I see that in hex?&#13;
0xad3e                                     Thanks. But I like uppercase hex&#13;
&gt;&gt;&gt; print(hex(x)<strong class="bold">.upper())</strong>                  OK. We just use the .upper() method on the string.&#13;
0XAD3E                                     Nice one. But I don't like 0X at the front.&#13;
&gt;&gt;&gt; print(hex(x).upper()<strong class="bold">[2:]</strong>)              OK, OK, just use slice notation [2:] to strip 0X.&#13;
AD3E                                       Great. Can I have that with fries?</pre>&#13;
			<p lang="en-GB">We have described, briefly, how numbers can be formatted. Formatting is necessary if the printed output is to be read by humans, especially if you are simulating a computer where patterns of 1s and 0s are important. There are several ways of formatting data, and this section provided only an introduction to this topic.</p>&#13;
			<h1 id="_idParaDest-123" lang="en-GB"><a id="_idTextAnchor126"/>Input validation</h1>&#13;
			<p lang="en-GB">In this section, I will introduce the notion of data validation. Historically, some of the major errors involving computers have been caused by a failure to check input data. TC1 doesn’t perform source data checking; you can write <code>ADDL R1,R2,10</code> or <code>ADDL z1,z2,10</code> with the same result. Why? Because when the assembler sees <code>ADDL</code>, it looks for three parameters. It takes the first parameter, let’s call this <code>p1</code>, and reads the register number by <code>regnum = int(</code>p1[1:]<code>)</code>. Only the second and successive characters of <code>p1</code> are recorded, and the “R” is ignored. You can write <code>R1</code> or even <code>?1</code>. This makes programming in assembly language easier; you can use any letter you want to represent a register. On the other hand, it encourages poor programming techniques and increases the dangers associated with mistyped input.</p>&#13;
			<h2 id="_idParaDest-124" lang="en-GB"><a id="_idTextAnchor127"/>Validating data</h2>&#13;
			<p lang="en-GB">Since the TC1 assembler doesn’t perform error-checking on the input, if you make an error, it’s likely that the program will crash, leaving you to do your own debugging. Good software performs error-checking, which ranges from the simple detection of invalid instructions to the exact pinpointing of all errors.</p>&#13;
			<p lang="en-GB">Here, we demonstrate how you can read a line of code and check for several types of common errors – for example, invalid opcodes, invalid instruction formats (too many or two few operands), typos (typing <code>T6</code> instead of <code>R6</code>), and registers out of range (entering <code>R9</code>).</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">The purpose of this section is to show how you can add your own modifications to TC1. A formal way of dealing with the problem would be to construct a grammar for the assembly language and then build a parser to determine whether the input conforms to that grammar. We are going to take a simpler and more ad hoc approach.</p>&#13;
			<p lang="en-GB">If the current instruction is <code>x = </code>'<code>ADD r1 r2 r3</code>', the <code>y = x.split(</code>' '<code>)</code> operation converts it into a list of tokens: <code>y = [</code>'<code>ADD</code>'<code>, </code>'<code>R1</code>'<code>, </code>'<code>R2</code>'<code>, </code>'<code>R3</code>'<code>]</code>. We can extract the first token with <code>jj = y[0]</code>, which should be a valid mnemonic (in this example, we are forgetting about any labels).</p>&#13;
			<p lang="en-GB">The first test to perform is on the validity of the instruction. Assume that all mnemonics have been defined in a list or directory called <code>codes</code>. All we have to do is to look it up in the <code>codes</code> directory using the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">if</strong> jj <strong class="bold">not in</strong> codes: error = 1</pre>&#13;
			<p lang="en-GB">Python keywords are shaded. This expression sets the <code>error</code> variable to <code>1</code> if this instruction is not in the dictionary. Then, we can test <code>error</code> and take whatever action is necessary.</p>&#13;
			<p lang="en-GB">The next step is to use the name of the instruction to look up its details, and then check whether that instruction requires parameters. Remember that our dictionary entries have a two-component tuple, with the first component being the instruction’s format (i.e., the number of operands required) and the second being the actual operation code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
form = codes.<strong class="bold">get</strong>(y[0])   # Read the 4-bit format code</pre>&#13;
			<p lang="en-GB">It looks up the instruction (i.e., <code>y[0]</code>) in the dictionary and returns its value, which is a tuple, such as <code>(8:12)</code>. The first element of the tuple, <code>form[0]</code>, describes the instruction’s operands and the second is the opcode (which is not of interest here). The parameters required by the instruction are determined by <code>form[0]</code>. Consider the following code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
opType = form[0]                                           # Get operand info&#13;
if   opType == 0:                  totalOperands = 1       # Just a mnemonic&#13;
elif opType == 8  or opType == 1:  totalOperands = 2       # Mnemonic + 1 operand&#13;
elif opType == 12 or opType == 9:  totalOperands = 3       # Mnemonic + 2 operands&#13;
elif opType == 14 or opType == 13: totalOperands = 4       # Mnemonic + 3&#13;
elif opType == 15:                 totalOperands = 5       # Mnemonic + 4 (not used)</pre>&#13;
			<p lang="en-GB">The four bits of the format code represent <code>rD</code>, <code>rS1</code>, <code>rs2</code>, and a literal. TC1 instructions have several valid formats; for example, if <code>opType = 0b</code>1<code>00</code>1<code> = 9</code>, then the format defines an instruction with a destination register and a literal such as <code>LDRL</code> R3 25. We’ve used bold and shading to demonstrate the relationship between the bits of the format code and the actual instruction.</p>&#13;
			<p lang="en-GB">The preceding code uses an <code>if…else</code> to get the length (the number of tokens including the opcode) of each instruction. All we then have to do is to count the number of tokens in the current instruction and see whether it’s the same as the expected value (i.e., the total length). The following code performs this check:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    totalTokens = len(<strong class="bold">y</strong>)                     # Get the number of tokens in this instruction y&#13;
    if totalTokens &lt; totalOperands:          # Are there enough tokens?&#13;
        error = 2                            # Error 2: Too few operands&#13;
        continue&#13;
    if totalTokens &gt; totalOperands:          # Are there too many tokens?&#13;
        error = 3                            # Error 3: Too many operands </pre>&#13;
			<pre class="source-code">        continue</pre>&#13;
			<p lang="en-GB">We set the error number to <code>2</code> or <code>3</code> if the number of tokens doesn’t match the expected value. After both tests, there is a <code>continue</code> statement. The effect of <code>continue</code> is to drop to the end of the current block and abandon further error-testing (because we know this current instruction is in error).</p>&#13;
			<p lang="en-GB">Once we have established a valid instruction and the correct number of operands, the next step is to check each operand. An operand must be of the form <code>R0</code> to <code>R7</code> (or a literal).</p>&#13;
			<p lang="en-GB">We use the format information to test for each operand in turn. Here, we just deal with the first operand, <code>rD</code> (the destination register):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if opType &amp; 0b<strong class="bold">1</strong>000 == 0b<strong class="bold">1</strong>000:             # If the destination register bit is set&#13;
        rDname = y[1]                         # Get the register name (second item in string)&#13;
        error,q = syntaxTest(rDname)          # Call syntax test to look for errors</pre>&#13;
			<p lang="en-GB">The first line of this code tests whether the leftmost bit of <code>format</code> is 1 or 0 by ANDing the format code with <code>0b1000</code> and testing for <code>0b1000</code>. If the result is <code>true</code>, then we need to check for the first register operand, which is the second token – that is, <code>y[1]</code>.</p>&#13;
			<p lang="en-GB">Because we are going to test for three operands, we have created a <code>syntaxText</code> function that takes the token as a parameter and returns two parameters: <code>error</code> and <code>q</code>. The value of <code>error</code> is the error code returned (<code>0</code> for no error, and <code>q</code> is the number of the register). The Python code for the <code>syntaxTest</code> function is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def syntaxTest(token):                         # Test register for validity (R0 to R7)&#13;
    if token[0] != 'R': return(4,0)            # Fail on missing initial R. Return error 4&#13;
    if not token[1:].isnumeric(): return(5,0)  # Fail on missing register number. Return 5&#13;
    if int(token[1:]) &gt; 7: return(6,0)         # Fail on register number not in 0-7. Return 6&#13;
    return(0,int(token[1:]))                   # OK so return with error 0 and reg number</pre>&#13;
			<p lang="en-GB">Three tests are performed, one for each type of error that we are looking for. The first test is to check whether the first character of the token is <code>'R'</code> . If it is not <code>'R'</code> , a return is made with the error code <code>4</code>, and the dummy or default register number is set to <code>0</code>. The second test looks for a numeric value for the register (the characters following the <code>'R'</code>, which is <code>token[1:]</code>). The third test checks whether the number is greater than <code>7</code> and returns an error code if it is. Finally, when the last line is reached, a return is made with the error code <code>0</code> and the appropriate register number. Note that we don’t need to use an <code>elif</code> because if an <code>if</code> yields <code>True</code>, the code is exited via <code>return()</code>.</p>&#13;
			<p lang="en-GB">This routine is called up to three times in the event of an instruction having a format code of <code>0b1110</code> corresponding to a register-to-register operation such as <code>ADD R1 R2 R3</code>. In this exercise, we do not check the literal. If you wish to add that check, it would be necessary to check for an integer in the range 0 to 65,535 or -32,766 to 32,755 (plus a number beginning with <code>%</code> if it’s binary or <code>0x</code> if it’s hexadecimal).</p>&#13;
			<h3 lang="en-GB">Using the <code>continue</code> statement</h3>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">When testing for errors, do you test for each error in a statement or do you stop once you have found an error?</p>&#13;
			<p lang="en-GB">The code uses a <code>continue</code> statement whenever an error is found to bypass further testing. An unfortunate side effect is that <code>continue</code> takes you past the end of the loop and begins the next iteration; that is, you can’t print the nature of the error. The solution is to print any errors found in the previous iteration at the start of the loop. Of course, this causes a problem on the first iteration because there is no previous error value. That is easily fixed by setting <code>error</code> to zero before beginning the loop. The following code demonstrates this approach:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
run = 1&#13;
error = 0&#13;
while run == 1:&#13;
    if error != 0: printError(error)&#13;
       .&#13;
       .&#13;
       &lt;test for error 1&gt;&#13;
    if error != 0: continue&#13;
        &lt;test for error 2&gt;&#13;
    if error != 0: continue&#13;
       .&#13;
       &lt;test for error n&gt;&#13;
    if error != 0: continue</pre>&#13;
			<p lang="en-GB">In this fragment of code, <code>error</code> is tested to determine whether an error occurred in the previous cycle. If <code>error</code> is not <code>0</code>, the <code>printError</code> function is called to print the error number and type. Using a function code to do the printing enhances the readability of the program.</p>&#13;
			<p lang="en-GB">The code for an error-testing routine is given next. This is not intended to be a complete program, but a demonstration of the way in which you can extend a program to include error-testing on the input data:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Testing Python parsing # 22 Aug 2020 Version of 29 July 2021&#13;
import sys                                    # System library used to exit program&#13;
codes = {'NOP':(0,0), 'STOP': (0,1),'BEQ':(1,4), 'INC':(8,2), \&#13;
         'MOVE':(12,23), 'LDRL':(9,13), 'ADD':(14,12),'ADDL':(13,12)}&#13;
def syntaxTest(token):               # Test the format of a register operand for validity (R0 to R7)&#13;
    if token[0] != 'R': return(4,0)           # Fail on missing initial R. Return error 2&#13;
    if not token[1:].isnumeric(): return(5,0) # Fail on missing register number. Return error 3&#13;
    if int(token[1:]) &gt; 7: return(6,0)  # Fail on register number not in range 0-7. Return error 4&#13;
    return(0,int(token[1:]))            # Success return with error code 0 and register number&#13;
def printError(error):&#13;
    if error != 0:&#13;
        if error == 1: print("Error 1: Non-valid operation")&#13;
        if error == 2: print("Error 2: Too few operands")&#13;
        if error == 3: print("Error 3: Too many operands")&#13;
        if error == 4: print("Error 4: Register operand error- no 'R'")&#13;
        if error == 5: print("Error 5: Register operand error - no valid num")&#13;
        if error == 6: print("Error 6: Register operand error - not in range")&#13;
run = 1&#13;
error = 0&#13;
while run == 1:&#13;
    if error != 0: printError(error)    # if error not zero, print message&#13;
    x = input("\nEnter instruction &gt;&gt; ")# Type an instruction (for testing)&#13;
    x =  x.upper()                      # Convert lowercase into uppercase&#13;
    x = x.replace(',',' ')              # Replace comma with space to allow add r1,r2 or add r1 r2&#13;
    y = x.split(' ')                    # Split into tokens. y is the tokenized instruction&#13;
    if len(y) &gt; 0:                      # z is the predicate (or null if no operands)&#13;
        z = y[1:]&#13;
    else: z  = ''&#13;
    print("Inst =",y, 'First token',y[0])&#13;
    if y[0] not in codes:               # Check for valid opcode&#13;
        error = 1                       # Error 1: instruction not valid&#13;
        print("Illegal instruction", y[0])&#13;
        continue&#13;
    form = codes.get(y[0])              # Get the code's format information&#13;
    print('Format', form)&#13;
    if form[1] == 1:                    # Detect STOP, opcode value 1,and terminate&#13;
        print("\nProgram terminated on STOP")  # Say "Goodbye"&#13;
        sys.exit()                      # Call OS function to leave&#13;
    opType = form[0]&#13;
    if   opType == 0:                                  totalOperands = 1&#13;
    elif opType == 8  or opType == 4  or opType == 1:  totalOperands = 2&#13;
    elif opType == 12 or opType == 9:                  totalOperands = 3&#13;
    elif opType == 14 or opType == 13:                 totalOperands = 4&#13;
    totalTokens = len(y)                # Compare tokens we have with those we need&#13;
    if totalTokens &lt; totalOperands:&#13;
        error = 2                       # Error 2: Too few operands&#13;
        continue&#13;
    if totalTokens &gt; totalOperands:&#13;
        error = 3                       # Error 3: Too many operands&#13;
        continue&#13;
    if opType &amp; 0b1000 == 0b1000:&#13;
        rDname = y[1]&#13;
        error,q = syntaxTest(rDname)&#13;
        if error != 0: continue&#13;
    if opType &amp; 0b0100 == 0b0100:&#13;
        rS1name = y[2]&#13;
        error,q = syntaxTest(rS1name)&#13;
        if error != 0: continue&#13;
    if opType &amp; 0b0010 == 0b0010:&#13;
        rS2name = y[3]&#13;
        error,q = syntaxTest(rS2name)&#13;
        if error != 0: continue&#13;
    if opType &amp; 0b0001 == 0b0001:&#13;
        if not y[-1].isnumeric():&#13;
            error == 7&#13;
            print("Error 7: Literal error")&#13;
    if error == 0:&#13;
       print("Instruction", x, "Total operands", totalOperands,"Predicate", z)</pre>&#13;
			<h3 lang="en-GB">Checking parameters – using dictionaries</h3>&#13;
			<p lang="en-GB">The next example provides another look at parameter checking. It examines the mnemonic and predicate of each instruction and checks whether it represents a valid operation. It stops after finding an error. In other words, it will detect only one error in <code>INC R9,R2</code> even though there are two errors (i.e., too many operands and the first operand is out of range).</p>&#13;
			<p lang="en-GB">We also expand the use of the Python dictionary. Previously, we tested for a valid register operand by checking that the initial character was ‘R’ and that this was followed by a number in the range of 0 to 7. Since there are only eight register names (R0 to R7), it’s easy to employ a dictionary in error checking:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
regSet = {'R0':0, 'R1':1, 'R2':2, 'R3':3, 'R4':4, 'R5':5, 'R6':6, 'R7':7}</pre>&#13;
			<p lang="en-GB">The dictionary, <code>regSet</code>, contains the register names (the keys) and the corresponding value. Because we do so much register checking, it’s convenient to create a function, <code>regTest</code>, to perform the check. This function takes two parameters. The first is a string, <code>tokNam</code>, that gives the register a name, and the second parameter is the token being tested – for example, <code>regTest('rD',predicate[0])</code>. The reason for passing a name to the function is so that the function can print the name of the operand in error.</p>&#13;
			<p lang="en-GB">The function returns two values: an error code and the number of the register. If an error is detected, the register value of <code>0</code> is returned as a default. The function is given here:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def regTest(tokNam,token):           # Test format of a register operand for validity (R0 to R7)&#13;
    if token in regSet:              # Is it in the register set?&#13;
        return (0,regSet.get(token)) # If it's there, return 0 and token value&#13;
    else:                            # If not there, return error code 4 and the token's name&#13;
        print("Error in register ",tokNam)&#13;
        return (4,0)</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Testing for validity is easy. The <code>if token in regSet:</code> condition checks whether this parameter is in the register set. If it is, we read the value of the register from the dictionary and return its value. If the token is not in the register set, an error message is printed (using <code>tokNam</code> to display the faulty value), and an error message number <code>4</code> is reported back.</p>&#13;
			<p lang="en-GB">Using <code>regSet.get(token)</code> is a little heavy-handed. We do not actually need to read the register value. If it is in the set of valid registers, we can use <code>int(token[1])</code> to extract the register number from the name. The advantage of using the dictionary mechanism is that we can amend the code to add new registers such as <code>SP</code>, <code>PC</code>, and so on if we want. We can rename registers or even use aliases; for example, if we use the <code>R7</code> register as a temporary register, we could enter <code>, {. . . 'R6':6, 'R7':7, </code>'T':7<code>}</code> and then write either <code>INC R7</code> or <code>INC T</code>.</p>&#13;
			<p lang="en-GB">We have also experimented with a new instruction dictionary. Some of the information in the dictionary is redundant because it can be derived from other information (e.g., the length can be derived from the format). However, we adopted the following system because we may change the program at a later date.</p>&#13;
			<p lang="en-GB">In the previous version of the assembler, we used a dictionary in which each entry had a key that was a mnemonic and a two-element tuple – for example, <code>'INC':(8,12)</code>. The first element of the tuple was a format code that expressed the operands required by the mnemonic, and the second element was the instruction’s opcode.</p>&#13;
			<p lang="en-GB">In this example, we are using a four-element tuple to provide the following information:</p>&#13;
			<ul>&#13;
				<li lang="en-GB"><code>rD, rS1, rS2, literal</code> (as before).</li>&#13;
				<li lang="en-GB"><strong class="bold">Style</strong>: The style describes the class of instruction – for example, mnemonic only, mnemonic plus literal, mnemonic plus register plus literal, and so on. There is a direct relationship between format and style.</li>&#13;
				<li lang="en-GB"><strong class="bold">Length</strong>: The length gives the number of tokens in the instruction – that is, the mnemonic plus its operands. This is equivalent to the number of 1s in the format plus 1.</li>&#13;
				<li lang="en-GB">The instruction’s opcode.</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The initial processing of an instruction is given by the following code. In section 1 (light shading), the mnemonic is read from the input token string (i.e., the first element). That may or may not be followed by additional parameters.</p>&#13;
			<p lang="en-GB">The mnemonic is used to access the <code>codes</code> dictionary to check whether it’s valid. The error code is set to <code>1</code> (invalid operation) and a <code>continue</code> statement forces a drop to the end of the loop (further input testing is not necessary as the instruction is not valid).</p>&#13;
			<p lang="en-GB">The code with the light gray background reads the tuple with the four data elements associated with the mnemonic and extracts the individual parameters.</p>&#13;
			<p lang="en-GB">The three lines beginning with “<code>if opCode == 1:</code>” read the operation to determine whether the instruction was “<code>STOP</code>”. If it was <code>STOP</code>, the <code>sys.exit()</code> operation terminates the program. Note that we have to use <code>import sys</code> at the start of the program to import the library of system functions:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    mnemonic = y[0]                    # Get the mnemonic&#13;
    if mnemonic not in codes:          # Check for a valid opcode&#13;
        error = 1                      # If none found, set error code&#13;
        continue                       # and jump to the end of the loop&#13;
    opData  = codes.get(mnemonic)      # Read codes to get the data for this instruction&#13;
    opForm  =  opData[0]               # Get each of this instruction's parameters&#13;
    opStyle =  opData[1]&#13;
    opCode  =  opData[2]&#13;
    opLen   =  opData[3]&#13;
    if opCode == 1:                    # If the op_Code is 1, then it's "STOP", so exit the program&#13;
        print("\nProgram terminated on STOP")&#13;
        sys.exit()&#13;
    totalTokens = len(y)               # How many tokens do we have?&#13;
    if totalTokens &lt; opLen:            # Compare with the expected number&#13;
        error = 2                      # Error 2: Too few operands&#13;
        continue&#13;
    if totalTokens &gt; opLen:&#13;
        error = 3                      # Error 3: Too many operands&#13;
        continue</pre>&#13;
			<p lang="en-GB">The final two blocks in the preceding code fragment with a dark gray background perform error-detecting operations. They both get the number of tokens from the instruction and then compare that number to the value for this instruction. In the first case, an error of <code>2</code> indicates too few tokens, and in the second case, an error of <code>3</code> indicates too many tokens.</p>&#13;
			<p lang="en-GB">At this stage, we have determined that the instruction is valid and has the correct number of operands. The next stage is to check the operands. The check is performed according to the style of the instruction. There are seven styles. Style 1 has no further checking because there is no operand (e.g., for <code>NOP</code>). We will just look at the checking for style 6, which corresponds to instructions with a mnemonic, <code>rD1</code>, <code>rS1</code>, and a literal such as <code>ADD R1,R2,25</code>.</p>&#13;
			<p lang="en-GB">We call the <code>regTest</code> function first with the ‘<code>rD</code>’ parameter to tell it we are testing for the destination register and the <code>predicate[0]</code> token, which is the first parameter. This returns an error flag and the value of the register.</p>&#13;
			<p lang="en-GB">Because we perform two tests (register <code>rD</code> and <code>rS1</code>), we must use two error names: <code>e1</code> for the first and <code>e2</code> for the second test. If we used <code>error</code> as the variable in both cases, a non-error second result would clear the first error. The line <code>if (e1 != 0) or (e2 != 0): error = 4</code> returns <code>error</code> with the appropriate error status independent of which register was in error. <code>continue</code> at the end of this block skips further error checking for this instruction:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# Input error checking - using dictionaries Modified 30 July 2021&#13;
# Instruction dictionary 'mnemonic':(format, style, op_code, length)&#13;
# Style definition and example of the instruction format&#13;
# 0 NOP            mnemonic only&#13;
# 1 BEQ L          mnemonic + literal&#13;
# 2 INC R1         mnemonic + rD&#13;
# 3 MOVE R1,R2     mnemonic + rD1 + rS1&#13;
# 4 LDRL R1,L      mnemonic + rD1 + literal&#13;
# 5 ADD R1 R2 R3   mnemonic + rD + rS1 + rS2&#13;
# 6 ADDL R1 R2 L   mnemonic + rD + rS1 + literal&#13;
# 7 LDRI R1 (R2 L) mnemonic + rD + rS1 + literal (same as 6)&#13;
import sys                                     # System library used to exit program&#13;
             # Dictionary of instructions (format, style, op_code, length)&#13;
codes = {'NOP': (0b0000,0,0,1),'STOP':(0b0000,0,1,1),'BEQ': (0b0001,1,2,2), \&#13;
         'INC': (0b1000,2,3,2),'MOVE':(0b1100,3,4,3),'LDRL':(0b1001,4,6,3), \&#13;
         'LDRI':(0b1101,7,7,4),'ADD': (0b1110,5,8,4),'ADDL':(0b1101,6,9,4)}&#13;
regSet = {'R0':0,'R1':1,'R2':2,'R3':3,'R4':4,'R5':5,'R6':6,'R7':7} # Registers&#13;
def regTest(token):                            # Test register operand for R0 to R7&#13;
    if token in regSet: return (0)             # Return with error 0 if legal name&#13;
    else:               return (4)             # Return with error 4 if illegal register name&#13;
def printError(error):                         # This function prints the error message&#13;
    if error != 0:&#13;
        if error == 1: print("Error 1: Non-valid operation")&#13;
        if error == 2: print("Error 2: Too few operands")&#13;
        if error == 3: print("Error 3: Too many operands")&#13;
        if error == 4: print("Error 4: Register name error")&#13;
        if error == 5: print("Error 5: Failure in pointer-based expression")&#13;
        if error == 6: print("Error 6: Invalid literal")&#13;
def litCheck(n):                          # Check for invalid literal format (this is just a demo)&#13;
    if n.isnumeric():    error = 0             # Decimal numeric OK&#13;
    elif n[0] == '-':    error = 0             # Negative number OK&#13;
    elif n[0] == '%':    error = 0             # Binary number OK&#13;
    elif n[0:2] == '0X': error = 0             # Hex number OK&#13;
    else:                error = 6             # Anything else is an error&#13;
    return(error)                              # Return with error number</pre>&#13;
			<p lang="en-GB">This is the main loop. An instruction is input and then checked for errors. As in earlier examples, the instruction is processed for validity first and the mnemonic is checked to see whether it is in codes:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
error = 0&#13;
while True:             # Infinite loop&#13;
    if error != 0: printError(error)&#13;
    error = 0&#13;
    x = input("&gt;&gt; ").upper()             # Read instruction and provide limited processing&#13;
    if len(x) == 0: continue             # Ignore empty lines and continue&#13;
    x = x.replace(',',' ')               # remove commas&#13;
    x = x.replace('(','')                # remove (&#13;
    x = x.replace(')','')                # remove )&#13;
    y = x.split(' ')                     # Create list of tokens (mnemonic + predicate)&#13;
    mnemonic = y[0]                      # Get the mnemonic (first token)&#13;
    if mnemonic not in codes:            # Check for validity&#13;
        error = 1                        # If not valid, set error code and drop out&#13;
        continue&#13;
    opData = codes.get(mnemonic)         # Read the four parameters for this instruction&#13;
    opForm  =  opData[0]                 # opcode format (rDS,rS1,rS2,L)&#13;
    opStyle =  opData[1]                 # Instruction style (0 to 7)&#13;
    opCode  =  opData[2]                 # Numeric opcode&#13;
    opLen   =  opData[3]                 # Length (total mnemonic + operands in range 1 to 4)&#13;
    if opLen &gt; 1: predicate = y[1:]      # Get predicate if this is one&#13;
    else:         predicate = ''         # If single token, return null&#13;
    print("Mnemonic =",mnemonic, "Predicate", predicate, \&#13;
          "Format =", bin(opForm),"Style =",opStyle,"Code =",opCode, \&#13;
          "Length =",opLen)&#13;
    if opCode == 1:                      # Used to terminate this program&#13;
        print("\nProgram ends on STOP")&#13;
        sys.exit()&#13;
    totalTokens = len(y)&#13;
    if totalTokens &lt; opLen:&#13;
        error = 2                        # Error 2: Too few operands&#13;
        continue&#13;
    if totalTokens &gt; opLen:&#13;
        error = 3                        # Error 3: Too many operands&#13;
        continue&#13;
    if opStyle == 0:                     # e.g., NOP or STOP so nothing else to do&#13;
        continue&#13;
    elif opStyle == 1:                   # e.g., BEQ 5 just check for literal&#13;
        literal = predicate[0]&#13;
        error = litCheck(literal)&#13;
        continue&#13;
    elif opStyle == 2:                   # e.g., INC r6 check for single register&#13;
        error = regTest(predicate[0])&#13;
        continue&#13;
    elif opStyle == 3:                   # e.g., MOVE r1,r2 check for two registers&#13;
        e1 = regTest(predicate[0])&#13;
        e2 = regTest(predicate[1])&#13;
        if e1 != 0 or e2 != 0:&#13;
            error = 4&#13;
        continue&#13;
    elif opStyle == 4:                   # e.g., LDRL r1,12 Check register then literal&#13;
        error = regTest(predicate[0])&#13;
        if error != 0: continue&#13;
        literal = predicate[1]&#13;
        error = litCheck(literal)&#13;
        continue&#13;
    elif opStyle == 5:                   # e.g., ADD r1,r2,r3 Check for three register names&#13;
        e1 = regTest(predicate[0])&#13;
        e2 = regTest(predicate[1])&#13;
        e3 = regTest(predicate[2])&#13;
        if e1 != 0 or e2 != 0 or e3 !=0:&#13;
            error = 4&#13;
        continue&#13;
    elif opStyle == 6:                   # e.g., ADDL R1,R2,4 Check for two registers and literal&#13;
        e1 = regTest(predicate[0])&#13;
        e2 = regTest(predicate[1])&#13;
        literal = predicate[2]&#13;
        e3 = litCheck(literal)&#13;
        if e1 != 0 or e2 != 0:&#13;
            error = 4&#13;
        if e1==0 and e2==0 and e3 !=0:   # If registers are OK but not literal&#13;
            error = 6                    # report literal error&#13;
        continue&#13;
    elif opStyle == 7:                   # e.g., LDRI r4,r0,23 or LDRI r4,(r0,23)&#13;
        e1 = regTest(predicate[0])&#13;
        e2 = regTest(predicate[1])&#13;
        literal = predicate[2]&#13;
        e3 = litCheck(literal)&#13;
        if e1 != 0 or e2 != 0:&#13;
            error = 4&#13;
        if e1==0 and e2==0 and e3 !=0:   # If registers are OK but not literal&#13;
            error = 6                    # report literal error&#13;
        continue</pre>&#13;
			<p lang="en-GB">Having looked at input validation, we now look at how we can control the display of <em class="italic">useful</em> information during a simulation.</p>&#13;
			<h4 lang="en-GB">Tracing and breakpoints</h4>&#13;
			<p lang="en-GB">When you simulate a computer, you have to show what is happening during the simulation. Consequently, you have to answer the following three questions:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">When do you display data?</li>&#13;
				<li lang="en-GB">How do you display the data?</li>&#13;
				<li lang="en-GB">What do you display?</li>&#13;
			</ul>&#13;
			<p lang="en-GB">When you have completed this section, you will be able to construct your own instruction tracing facilities.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">CPU simulators execute one instruction at a time. At the end of an instruction, the state of the computer (i.e., its registers, status flags, and memory) can be displayed. This mode is called <em class="italic">single-stepping</em>. Every time you hit <em class="italic">Enter</em>, an instruction is executed and the machine’s status is displayed on the screen.</p>&#13;
			<p lang="en-GB">Stepping through instructions sequentially, one by one, has limitations. What if there’s a 3-instruction loop that clears, say, 1,000 locations in an array? Do you expect someone to hit the <em class="italic">Enter</em> key 3,000 times to trace past this operation? We need a means of stepping past the boring bits of a program and jumping to the interesting bits – that is, a mechanism that lets us execute some instructions as a batch, without having to hit <em class="italic">return</em> after each instruction has been executed or printing the results of that execution.</p>&#13;
			<p lang="en-GB">Suppose we create a variable, <code>trace</code>, and then, at the end of the <code>execute</code> loop, print the appropriate data if <code>trace</code> is <code>1</code> and jump to the next instruction without printing data if <code>trace = </code><code>0</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">trace = 1                                    </strong># Trace mode active when trace = 1&#13;
run = 1<strong class="bold">                                      </strong># run = 1 to execute program&#13;
pc = 0<strong class="bold">                                       </strong># Initialize program counter&#13;
while run == 1:<strong class="bold">                              </strong># Main program loop&#13;
    read instruction&#13;
    execute instruction&#13;
    <strong class="bold">if trace == 1: displayData()             </strong># When in trace mode, print results</pre>&#13;
			<p lang="en-GB">The CPU state is printed after each instruction only if <code>trace = 1</code>. How do we turn <code>trace</code> on and off? Turning <code>trace</code> off is easy; all you need do is read the keyboard input when single-stepping, and turn <code>trace</code> off if a particular character or string is entered. However, once <code>trace</code> is <code>0</code>, we’ve lost control, and instructions are executed until the program is terminated.</p>&#13;
			<p lang="en-GB">One solution is to set up a trace count, with the number of instructions to be executed before <code>trace</code> is turned on again; for example, entering <code>T 10</code>, would turn off tracing, execute 10 instructions without displaying anything, and then turn tracing on again. Defining a fixed number of instructions to execute is not always helpful, as it requires the programmer to count the number of instructions to be executed before a point of interest is reached. The programmer may not always know that.</p>&#13;
			<p lang="en-GB">A better solution is to turn tracing on when a specific point in the assembly language program, called a <em class="italic">breakpoint,</em> is reached. A breakpoint can be the value of the program counter, a label, or a specific instruction. Typically, the value of the program counter at which you wish to display machine status is stored in a table of breakpoints. Execution continues (without any display) until a breakpoint is encountered and the CPU state is displayed.</p>&#13;
			<p lang="en-GB">The following fragment of Python demonstrates this approach. It is not a computer simulator and has only three instructions (<code>nop</code>, <code>test</code>, and <code>test1</code>), which do nothing, plus <code>stop</code>. The program is intended to demonstrate a possible approach to the implementation of single-stepping and breakpoints. At the end of each instruction cycle, several choices are possible:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Show the machine status after the execution of this instruction</li>&#13;
				<li lang="en-GB">Wait for keyboard input before executing the next cycle</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">Print the machine status at a specific breakpoint (address or instruction)</li>&#13;
			</ul>&#13;
			<p lang="en-GB">The following code uses different fonts and background shading to highlight the various functional parts of the code. The first two sections are the setting up and initialization of variables, and (shaded) the main program execution loop. This loop does nothing other than step through instructions that are <code>nop</code> (no operation); <code> test</code> and <code>test1</code> are just used as markers. The <code>stop</code> instruction serves to terminate execution.</p>&#13;
			<p lang="en-GB">Note that, when tracing, we require a second program counter, <code>pcOld</code>, because <code>pc</code> gets incremented during the <code>fetch</code> cycle and we need to display it before it was modified:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def display():                                   # Display processor status&#13;
    if oldPC in breakTab: print('Breakpoint at %03x' %oldPC)   # if pc in the table&#13;
    print("PC = %03x" %oldPC,  ' Op-code = %s' %instruction)&#13;
    return()&#13;
opCodes = ['nop', 'test', 'test1', 'stop']       # Op-code set&#13;
traceCodes = []                                  # List of codes to be traced (initially empty)&#13;
mem = ['nop'] * 32                               # Initialize memory to NOPs&#13;
mem[10] = 'test'                                 # Dummy operation at 10&#13;
mem[20] = 'test'                                 # Dummy operation at 20&#13;
mem[25] = 'test1'                                # Dummy operation at 25&#13;
r = [0] * 4                                      # Set up 4 registers (not used)&#13;
pc = 0                                           # Initialize program counter&#13;
oldPC = 0                                        # Initialize previous program counter&#13;
run = 1                                          # Set run to 1 to go&#13;
trace = 1                                        # Set trace to 1 to single-step&#13;
count = 0                                     # Count is the number of cycles not displayed&#13;
breakTab = []                                    # Create table for breakpoints&#13;
while run == 1:                                  # PROGRAM LOOP&#13;
    instruction = mem[pc]                        # read instruction&#13;
    oldPC = pc                                   # Save current PC for display&#13;
    pc = pc + 1                                  # Increment PC&#13;
    # Do processing here                         # For experimentation (add stuff here)&#13;
    if pc == 32 or instruction == 'stop': run = 0 # End on stop instruction or max PC&#13;
    if trace == 0 and count != 0:                # Test for single-step mode&#13;
        count = count - 1                        # If not single-step, decrement counter&#13;
        if count == 0:                           # If count zero, return to single step mode&#13;
            trace = 1                            # Exit silent mode&#13;
            continue                             # Now drop to bottom of the loop&#13;
    if trace == 0 and pc in breakTab:            # If not single-step, check for breakpoint&#13;
        print('Breakpoint\n')                    # Print status at the breakpoint&#13;
        display()&#13;
    if trace == 0 and instruction in traceCodes: # If not single-step and opcode in table&#13;
        print('Trace Code')                      # Print status info&#13;
        display()&#13;
    <strong class="bold">if trace == 1:</strong><strong class="bold">                               </strong># If single-step with trace on&#13;
        display()                                # Display the status&#13;
        c = input('&gt;&gt; ')                         # Wait for keyboard input&#13;
        if c == '': continue                     # If it's just a return, continue&#13;
        elif c[0]== 't' and len(c) &gt; 2 and c[2:].isdigit():&#13;
                                                 # Test for 't' and number&#13;
            count = int(c[2:])                   # Set the count for silent mode&#13;
            trace = 0                            # Turn off single-step&#13;
        elif c[0] == 'b' and len(c) &gt; 2 and c[2:].isdigit():&#13;
                                                 # Test for b (set breakpoint)&#13;
            breakPoint = int(c[2:])              # Get breakpoint address and add to table&#13;
            breakTab.append(breakPoint)&#13;
        elif c == 'd':                           # Test for d to display breakpoint info&#13;
            print('Display status: breakpoints =', breakTab, \&#13;
                  'traced codes =',traceCodes)&#13;
        elif c in opCodes: traceCodes.append(c)  # Test for a valid opcode and add to list&#13;
print('\nProgram terminated')</pre>&#13;
			<p lang="en-GB">Initially, <code>trace</code> is set to <code>1</code>, indicating that we are in a <em class="italic">single-step</em> mode. After displaying the program counter and instruction, the program waits for keyboard input. The code that does this is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if trace == 1:                               # If single-step with trace on&#13;
        display()                                # Display the status&#13;
        c = input('&gt;&gt; ')                         # Wait for input from user&#13;
        if c == '': continue                     # If it's just a return, continue</pre>&#13;
			<p lang="en-GB">If the input is a return (i.e., <code>enter</code>), the loop is terminated by <code>continue</code> and the next instruction cycle is executed. If you enter <code>t</code> followed by an integer (e.g., <code>t 13</code>), the integer is transferred to the <code>count</code> variable and <code>t</code> is set to <code>0</code>. Setting <code>t</code> to <code>0</code> turns off the single-step mechanism, and instructions are executed without printing the machine status or waiting for a keyboard input at the end of each cycle. At the end of each cycle, the <code>count</code> variable is decremented. When <code>count</code> becomes <code>0</code>, <code>trace</code> is set to <code>1</code> and the single-step mode is re-entered.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">If you enter <code>b</code> followed by an integer (e.g., <code>b 21</code>), a breakpoint at address <code>21</code> is recorded in the breakpoint table (a dictionary). You can enter more than one breakpoint and it will be saved in the dictionary. Each breakpoint is an address in the program being executed. When the program counter reaches that address, the system status is displayed. For example, if you were to enter the sequence <code>b 12</code>, <code>b 30</code>, <code>t 50</code> (each on a separate line), the simulator would set breakpoints at addresses <code>12</code> and <code>30</code>, and then execute 50 cycles without displaying any data. However, if the program counter becomes either <code>12</code> or <code>30</code> during this period, the machine status will be printed.</p>&#13;
			<p lang="en-GB">Similarly, you can enter an instruction that will be loaded into the <code>traceCodes</code> table. This behaves exactly like the PC breakpoint. When an instruction that’s in the <code>traceCodes</code> table is encountered, the machine status is displayed. Thus, the simulator provides four modes:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">Execute instruction step by step</li>&#13;
				<li lang="en-GB">Execute <em class="italic">n</em> instructions without displaying system status (the silent mode)</li>&#13;
				<li lang="en-GB">Execute instructions in silent mode but stop and display if a breakpoint address is encountered</li>&#13;
				<li lang="en-GB">Execute instructions in silent mode but stop and display if a specific opcode is encountered</li>&#13;
			</ul>&#13;
			<p lang="en-GB">Of course, the program can be extended to more exotic forms of breakpoints that take account of register data, memory data, or any combination of events. For example, you could permit breakpoints of the following form:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
If PC &gt; 200 or PC &lt; 300 and instruction = 'ADD'</pre>&#13;
			<p lang="en-GB">Some simulators let you set a breakpoint on a change of instruction flow – that is, after any jump, branch, or subroutine call. That’s very useful for tracing the execution of a complex program.</p>&#13;
			<p lang="en-GB">The following is the output of a short session with this fragment program. Remember that it is intended to be a demonstration of the principles involved, rather than an actual working system:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
PC = 000  Op-code = nop           # Hit enter key and trace first instruction&#13;
&gt;&gt;&#13;
PC = 001  Op-code = nop&#13;
&gt;&gt;&#13;
PC = 002  Op-code = nop&#13;
&gt;&gt; t 4                            # Type t 4 to execute but skip printing 4 instructions&#13;
PC = 007  Op-code = nop           # Note how PC jumps from 2 to 7&#13;
&gt;&gt;&#13;
PC = 008  Op-code = nop&#13;
&gt;&gt;&#13;
PC = 009  Op-code = nop&#13;
&gt;&gt; b 12                           # Type b 12 to insert breakpoint at PC = 12&#13;
PC = 00a  Op-code = nop&#13;
&gt;&gt; t 6                            # Type t 6 to execute 6 instructions without display&#13;
Breakpoint&#13;
Breakpoint at 00c                 # No display continues until PC = 12 (0xC)&#13;
PC = 00c  Op-code = nop           # Processor printed for PC = 12&#13;
PC = 011  Op-code = nop           # Execution continues until PC = 17 (0x11)&#13;
&gt;&gt; test1                          # Type 'test1' to make instruction test1 a breakpoint&#13;
PC = 012  Op-code = nop&#13;
&gt;&gt; t 15                           # Type t 15 to execute but skip printing 15 instructions&#13;
Trace Code&#13;
PC = 019  Op-code = test1         # Execution continues until 'test1' encountered at PC = 25 (0x19)&#13;
Program terminated</pre>&#13;
			<p lang="en-GB">The next step is to demonstrate how the simulated computer can be extended by adding new instructions. We demonstrate what parts of the code have to be modified and how you can create new instructions of arbitrary complexity. For example, if you were developing a computer to be used primarily for playing chess, you could create an instruction, <code>ROOK R1,R2</code>, that takes the position of a rook in register <code>R2</code> and calculates the legal positions it could move to and put them in <code>R1</code>.</p>&#13;
			<h1 id="_idParaDest-125" lang="en-GB"><a id="_idTextAnchor128"/>Adding new instructions</h1>&#13;
			<p lang="en-GB">So far, we have provided a modest set of instructions for TC1. In this section, we show how to add a new instruction to the TC1’s repertoire in order to see what’s involved in extending an instruction set. In fact, this is a remarkably straightforward task.</p>&#13;
			<p lang="en-GB">The first step is to choose a mnemonic and unique opcode and insert them into the table of code. We’ve arranged the instruction set to leave some unallocated code (e.g., code beginning with <code>11</code>). The second step is to write the code to interpret the new instruction.</p>&#13;
			<h2 id="_idParaDest-126" lang="en-GB"><a id="_idTextAnchor129"/>First example – putting two memory locations in ascending order</h2>&#13;
			<p lang="en-GB">Let’s create an instruction that takes the contents of two consecutive locations in memory and puts the largest number in the first location at the lower address (i.e., it orders them). This instruction takes a single parameter, a pointer register, and reads the numeric value pointed at by the register. We’ll assume that the register is <code>r[i]</code>. The instruction compares this number with the value stored at address <code>r[i] + 1</code>, and swaps them if the second number is higher than the one at the <code>r[i]</code> location. In pseudocode, this is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
temp ← mem[r[i]]                    # Save first number. Assume ri is the pointer register&#13;
if mem[r[i] + 1] &gt; temp             # If the second number is greater than the first&#13;
   mem[r[i]]   ← mem[r[i]+1]        # then put the second number in the first location&#13;
   mem[r[i]+1] ← temp               # and the first number in the second location</pre>&#13;
			<p lang="en-GB">We will call the instruction <code>ORD</code> (order numbers) and write it as <code>ORD r0</code>. The binary code is <code>1110000 rrr 00…0</code> (where <code>rrr</code> is the 3-bit register field) and is assigned to this instruction. <code>'ORD':(8,112)</code> is entered in the Python dictionary of instructions. The opcode is <code>112</code> and the parameter allocation code in binary is <code>1000</code> (i.e., 8), because the only parameter required is <code>Rd</code>.</p>&#13;
			<p lang="en-GB">The new instruction is detected in the execution part of the program:</p>&#13;
			<pre class="source-code"> elif opCode == 0b1110000:           # Test for 'ORD' ( 112 in decimal and in 1110000 binary)</pre>&#13;
			<p lang="en-GB">This is followed by the Python version of the preceding pseudocode. We can write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
temp = mem[r[dest]]                          # dest is the destination register&#13;
if mem[r[dest] + 1] &gt; temp:&#13;
    mem[r[dest]] = mem[r[dest]+1]&#13;
    mem[r[dest] + 1] = temp</pre>&#13;
			<p lang="en-GB">What could be simpler? The following code provides a testbed for the instruction. We fill memory with random numbers and then request a memory address. The data at that address is exchanged with the data at the next address to create an ordered pair. Note that this example does not use global variables: the registers and memory are passed to the function as parameters. To simplify testing, it is assumed that the memory address is in the <code>r[0]</code> register:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
import random                                # System library to generate random numbers&#13;
mem = [0] * 32                               # Set up memory&#13;
r   = [0] * 8                                # Set up registers&#13;
for i in range(32): mem[i] = random.randint(0,256) # Fill memory with random numbers&#13;
for i in range(32): print(i, mem[i])&#13;
def ord(reg,rD,memory):                      # Pass registers, memory, and register number&#13;
    temp = memory[reg[rD]]                   # rD is the destination register&#13;
    if memory[reg[rD] + 1] &gt; temp:&#13;
        memory[reg[rD]] = memory[reg[rD]+1]&#13;
        memory[reg[rD] + 1] = temp&#13;
    return()&#13;
go = True&#13;
r  = [0] * 8&#13;
rD = 0&#13;
while go:&#13;
    x = input('Type address of first: ')&#13;
    r[rD] = int(x)&#13;
    if r[rD] &gt; 30:                           # Exit on memory address 31 or higher&#13;
        print('End of run')&#13;
        break&#13;
    else:&#13;
        print('Before: mem[x] = ',mem[r[rD]], 'next = ',mem[r[rD] + 1])&#13;
        ord(r,0,mem)</pre>&#13;
			<pre class="source-code">        print('After:  mem[x] = ',mem[r[rD]], 'next = ',mem[r[rD] + 1])</pre>&#13;
			<h2 id="_idParaDest-127" lang="en-GB"><a id="_idTextAnchor130"/>Second example – adding a bit-reversal instruction</h2>&#13;
			<p lang="en-GB">Let’s add a more complicated instruction to the TC1 instruction set. Suppose you want to reverse the order of bits in a register so that the binary code <code>1100111000101001</code> in <code>r0</code> becomes <code>1001010001110011</code>. Assume that the new instruction is <code>REV r0</code>, which reverses the 16 bits in <code>r0</code> and returns the result in r0.</p>&#13;
			<p lang="en-GB">How do we reverse bits? Consider the four bits 1101 and assume they are in T1 (<em class="italic">see Fig 7.1</em>). Suppose we shift the bits one place left so that the bit that leaves the left-hand end of T1 goes into the right-hand end of T2, and then we shift T2 one place to the right. We repeat that operation four times. <em class="italic">Figure 7</em><em class="italic">.1</em> shows what we get:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_7.1_B19624.jpg" alt="Figure 7.1 – Shifting one register’s output into a second register’s input to reverse a string" width="760" height="249"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Shifting one register’s output into a second register’s input to reverse a string</p>&#13;
			<p lang="en-GB">We have reversed the order of the bits. If the register to be shifted is <code>op1</code>, then we can write the Python code as follows. This code is in the form of a function that can be called from the instruction interpreter:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
def reverseBits(op1):                      # Reverse the bits of register op1&#13;
    reversed = 0                           # The reversed value is initialized&#13;
    toShift  = r[op1]                      # Read the register contents&#13;
    for i in range(0,16):                  # Repeat for all 16 bits&#13;
        bitOut   = toShift &amp; 0x8000        # Get msb of word to reverse&#13;
        toShift  = toShift &lt;&lt; 1            # Shift source word one place left&#13;
        reversed = reversed &gt;&gt; 1           # Shift result one place right&#13;
        reversed = reversed | bitOut       # Use OR to insert bit in lsb of result&#13;
    return(reversed)</pre>&#13;
			<p lang="en-GB">We can now change the code of TC1 to incorporate this. There are three steps:</p>&#13;
			<ol>&#13;
				<li lang="en-GB"><code>'REV':(8,113)</code>, into the <code>codes</code> dictionary. 8 indicates <code>1000</code> in binary and informs the computer that the reverse instruction requires the destination <code>rD</code> register to be specified by the instruction. 113 is the opcode, which is <code>0b1110001</code> in binary.</li>&#13;
				<li lang="en-GB"><strong class="bold">Step 2</strong>: In the opcode interpretation list, insert the new entry:<pre>elif 'code ' == 0b1110001: r[op0] = reverseBits(op0)</pre></li>&#13;
			</ol>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This checks whether the current instruction is <code>0b1110001</code> (i.e., 161 decimal) and calls the r<code>everseBits()</code> function to perform the required operation.</p>&#13;
			<ol>&#13;
				<li lang="en-GB" value="3"><code>reverseBits</code> function into the Python code. This instruction replaces the data in the <code>rD</code> register with the bits reversed.</li>&#13;
			</ol>&#13;
			<p lang="en-GB">Suppose that we wanted a non-destructive instruction that did not overwrite the register containing the bits to be reversed – that is <code>REV r0,r1</code>. What changes would we need?</p>&#13;
			<p lang="en-GB">First, we would need a new instruction format code. We have to specify two registers: the source and destination register. The code in the directory would now be <code>'REV': (12,113)</code> because the opcode parameter value would be <code>1100</code> in binary or <code>12</code> in decimal. The other change would be to the instruction interpreter:</p>&#13;
			<pre>elif 'code' == 0b1110010: R[dest] = reverseBits(op1)</pre>&#13;
			<p lang="en-GB">Note that we have changed the instruction format for minimal changes to the code (in this case, it’s just the change of source register from <code>op0</code> to <code>op1</code>).</p>&#13;
			<h1 id="_idParaDest-128" lang="en-GB"><a id="_idTextAnchor131"/>A new comparison operation</h1>&#13;
			<p lang="en-GB">Suppose you are performing an operation on a string where you have to find the <em class="italic">middle</em> of the string. You can do this by stepping in from both ends until you get to the middle. But there are <em class="italic">two</em> types of middle. A string with an odd number of characters has a character in its middle. A string with an even number of characters has no middle character; it has two characters next to each other. Consider these two examples:</p>&#13;
			<p lang="en-GB"><code>String 1: 12</code>34<code>567</code><code>        </code>Odd number of characters</p>&#13;
			<p lang="en-GB"><code>String 2: 123</code>45<code>678</code><code>       </code>Even number of characters</p>&#13;
			<p lang="en-GB">String 1 has an odd number of characters and 4 is the center. String 2 has an even number of characters, and 4 and 5 are on either side of the middle.</p>&#13;
			<p lang="en-GB">Suppose we are stepping through a string using two pointers, one at each end. As we step in from both sides, one pointer goes up and the other goes down. When we get to the middle, either the pointers are the same (odd length) or the pointers differ by one (even length).</p>&#13;
			<p lang="en-GB">It would be nice to have a compare operation that compares two values and returns equality if either they are the same or if the second one differs from the first by +1. The new instruction, <code>CMPT</code> (<em class="italic">compare together</em>), does this. For example, <code>CMPT</code> <code>r4,r6</code> sets the <code>z</code> bit to <code>1</code> if the contents of <code>r4</code> and <code>r6</code> are the same, or if the contents of <code>r4</code> are one less than the contents of <code>r6</code>. The code to do this is as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if mnemonic == "CMPT":&#13;
        z = 0&#13;
        if (r[rD] == r[rS1]) or (r[rD] == r[rS1] + 1): z = 1</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">As you can see, this performs two tests on the pointers, one for equality and one for higher by 1, and combines the test results using a Boolean <code>or</code> operator; that is, if the pointers are <code>x</code> and <code>y</code>, then the test is true <code>if x = y</code> is true or if <code>x + 1 = y</code> is true.</p>&#13;
			<p lang="en-GB">This instruction is not implemented in a real processor. Why not if it’s a great idea? Well, first, it would be used in only a small number of programs requiring this particular operation. It takes up silicon real estate on the chip that is hardly ever used. That’s a waste of precious resources. Second, machine code is mostly generated by compilers, and it’s not easy to design compilers that use special-purpose operations such as this effectively. Third, this instruction performs three operations: comparing <code>p</code> and <code>q</code>, adding 1 to <code>q</code>, comparing <code>p</code> and <code>q+1</code>. Consequently, it takes longer to execute than single-operation instructions. That reduces the efficiency of the computer.</p>&#13;
			<p lang="en-GB">In the next section, you will be introduced to the notion of instructions with fields that have variable lengths. Real machines do not have this facility. The reason for including this section is to demonstrate instruction decoding and bit processing.</p>&#13;
			<h1 id="_idParaDest-129" lang="en-GB"><a id="_idTextAnchor132"/>Variable-length instructions</h1>&#13;
			<p lang="en-GB">This short section provides ideas for experimentation with instructions and their formats and extends your understanding of instructions, their structure, and the trade-off involved in creating instruction sets. It is not designed to illustrate a real computer.</p>&#13;
			<p lang="en-GB">Like many computers, TC1 has <em class="italic">fixed-length fields</em> in its opcode; that is, the number of bits dedicated to each field is fixed and does not vary from instruction to instruction. There are always 16 bits in the literal field, even if the current instruction does not require a literal. Wasteful indeed. Since the purpose of TC1 is experimentation, we demonstrate how you might make the number of registers variable (i.e., user-definable). Adding more registers speeds up computation by requiring fewer memory accesses. However, there is a price; where do you get the extra bits that would be needed to specify the registers? Do you take the extra register bits from the opcode field (reducing the number of different instructions), or do you take them from the literal field (reducing the maximum size of a literal that can be loaded in a single instruction)? Or do you implement multiple banks of registers and switch in a new set of registers (called <em class="italic">windowing</em>) as a temporary measure?</p>&#13;
			<p lang="en-GB">Here, we provide some code that we used to experiment with variable register sizes. This is not a complete program. All it does is let you enter the size of register fields and then run a test by creating a <em class="italic">dummy</em> instruction. It’s a dummy instruction because the opcode is set to <code>1111110</code> and the literal field is all zeros. It just tests the ability to place the register fields at appropriate points in an instruction and automatically adjust the length of the literal field.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB"><em class="italic">Figure 7</em><em class="italic">.2</em> provides the output of a single run of this program. The inputs are in bold. You can see that the register fields have been selected as 3, 3, and 5 bits wide. The instruction is <code>ADD R7,R2,R31</code> (note that the only data extracted is <code>7</code>, <code>2</code>, and <code>31</code>, as we are not interested in the actual instruction):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_7.2_B19624.jpg" alt="Figure 7.2 – Demonstration of variable-length fields" width="1360" height="402"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Demonstration of variable-length fields</p>&#13;
			<p lang="en-GB">The final binary instruction is given with each of its fields in a different style for clarity. You can see that the register fields have been placed in the correct positions in the instruction and the remaining bits (the literal field) are padded with zeros.</p>&#13;
			<p lang="en-GB">It may seem strange to have register fields of different widths. That means that some parameters in an instruction can access more registers than others. Such a facility can be useful; for example, you could use some of the registers as special-purpose registers (e.g., a stack pointer), or they could be used to hold frequently accessed constants (such as <code>0</code>, <code>1</code>, or <code>2</code>):</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
# 31 Aug 2020 TESTING a variable format instruction set V1&#13;
x = input("Enter three width for: rD,rS1,rS2 (e.g., 2,2,3) &gt;&gt; ")&#13;
x = x.replace(' ',',')&#13;
x = x.split(",")                          # Get register sizes and convert list into tokens&#13;
x1 = int(x[0])                            # First register size rD&#13;
x2 = int(x[1])                            # Second register size rS1&#13;
x3 = int(x[2])                            # Third register size rS2&#13;
y = (x1,x2,x3)                            # Convert data size elements into a tuple&#13;
z = input("Enter three register operands for: rD,rS1,rS2 (e.g. R1,R3,R2)&gt;&gt; ")&#13;
opCode = 0b1111110                        # Dummy 7-bit binary opcode&#13;
z = z.replace(' ',',')&#13;
z = z.split(",")&#13;
t1,t2,t3 = 0,0,0                          # t1,t2,t3 are up to three tokens in the predicate&#13;
t1 = int(z[0][1:])                        # Extract three parameters&#13;
t2 = int(z[1][1:])&#13;
t3 = int(z[2][1:])&#13;
print ('Register widths: rD = ',t1, 'rS1 = ',t2,'rS2 = ',t3)   # Print the registers&#13;
opCode = opCode &lt;&lt; x1 | t1                # Insert the rD field&#13;
opCode = opCode &lt;&lt; x2 | t2                # Insert the rS1 field&#13;
opCode = opCode &lt;&lt; x3 | t3                # Insert the rS2 field&#13;
intLen = 32 - 7 - x1 - x2 - x3            # Calculate the length of the literal field&#13;
opCode = opCode &lt;&lt; intLen                 # Shift left by literal size to create 16-bit instruction</pre>&#13;
			<pre class="source-code">print("opCode",bin(opCode))               # Print the result</pre>&#13;
			<p lang="en-GB">Running this code with some sample values gives the following output (<em class="italic">Figure 7</em><em class="italic">.3</em>). As you can see, the register files have been inserted into the opcode:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Enter three width for: rD,rS1,rS2 (e.g., 2,2,3) &gt;&gt; <strong class="bold">3,4,5</strong>&#13;
Enter register operands for: rD,rS1,rS2 (e.g.,R1,R3,R2)&gt;&gt; <strong class="bold">R4,R6,R30</strong>&#13;
Register widths: rD =  4 rS1 =  6 rS2 =  30&#13;
opCode 0b1111110 100<strong class="bold"> </strong>0110<strong class="bold"> </strong>11110<strong class="bold"> </strong>0000000000000</pre>&#13;
			<p class="IMG---Figure ParaOverride-1" lang="en-GB"><img class="_idGenObjectAttribute-2" src="img/Figure_7.3_B19624.jpg" alt="Figure 7.3 – Demonstration of variable-length operand fields" width="1013" height="199"/></p>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Demonstration of variable-length operand fields</p>&#13;
			<h2 id="_idParaDest-130" lang="en-GB"><a id="_idTextAnchor133"/>A variable-length instruction machine</h2>&#13;
			<p lang="en-GB">Throughout <a id="_idIndexMarker491"/>this text, we have demonstrated machines with fixed-length instruction words. Computers based on this paradigm frequently fall into the RISC category. However, classic CISC machines (from the humble 8080 and 6800 to the less humble 8086 and 68000 microprocessors) had variable-length instructions, as we’ve already pointed out. Consider the following example of a stream of variable-length instructions, where <code>1</code> represents a 1-word instruction, <code>2</code> represents a 2-word instruction, and so on (<em class="italic">Figure 7</em><em class="italic">.4</em>):</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_7.4_B19624.jpg" alt="Figure 7.4 – Instruction stream with variable-length opcodes" width="914" height="62"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Instruction stream with variable-length opcodes</p>&#13;
			<p lang="en-GB">As instructions are executed, they must be decoded and the appropriate number of bytes appended to the current instruction. A problem with this approach is that it makes look-ahead <a id="_idIndexMarker492"/>processing difficult because you do not know where future instructions begin and end until you’ve decoded the current instruction.</p>&#13;
			<p lang="en-GB">Here, we’re going to demonstrate a very simple variable-length machine that uses 8-bit words and an instruction can be 8, 16, 24, or 32 bits long. An operation like <code>nop</code> is 8 bits, <code>branch</code> is 16 bits, <code>move</code> is 24 bits, and <code>add</code> is 32 bits. The instruction itself is 8 bits (in the demonstration, we use only 5 bits for simplicity). An instruction is read and the two most-significant bits determine the total number of bytes required by this instruction.</p>&#13;
			<p lang="en-GB">The number of registers used by this machine is … none! For the sake of simplicity, and fun, we decided to make all instructions memory-based.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Consequently, we need two counters: one that counts the instructions and one that counts the bytes. For example, the instruction sequence in <em class="italic">Table 7.1</em> demonstrates the <em class="italic">instruction address</em> (sequential) and the <em class="italic">memory address</em> of the first byte of an instruction. Here, instructions vary from 1 byte (<code>stop</code>) to 4 bytes (<code>add</code>):</p>&#13;
			<table id="table001-5" class="No-Table-Style">&#13;
				<colgroup>&#13;
					<col/>&#13;
					<col/>&#13;
					<col/>&#13;
				</colgroup>&#13;
				<thead>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="bold">Code</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="bold">Instruction address</strong></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><strong class="bold">Memory address</strong></p>&#13;
						</td>&#13;
					</tr>&#13;
				</thead>&#13;
				<tbody>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>ld</code><code>  </code><code>28,7</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>0</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">0</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>ld</code><code>  </code><code>27,2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>1</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">3</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>ld</code><code>  </code><code>26,1</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>2</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">6</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>add 28,28,26</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>3</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">9</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>dec 26</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>4</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">13</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>bne 3</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>5</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">15</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>stop</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>6</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">17</p>&#13;
						</td>&#13;
					</tr>&#13;
					<tr class="No-Table-Style">&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB">Next free space</p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>7</code></p>&#13;
						</td>&#13;
						<td class="No-Table-Style CellOverride-1">&#13;
							<p class="ParaOverride-1" lang="en-GB"><code>18</code></p>&#13;
						</td>&#13;
					</tr>&#13;
				</tbody>&#13;
			</table>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – Instruction and memory addresses for variable-length code</p>&#13;
			<p lang="en-GB">Here, we have used simple numeric addresses. Some addresses are literal bytes; for example, <code>ld 28,7</code> means load memory location <code>28</code> with the number <code>7</code>.</p>&#13;
			<p lang="en-GB">The following code provides a program to implement such a computer. Note that the actual program is supplied as a list. This program does not have the textual flexibility of TC1; it’s a simple demonstration. An instruction is entered in lowercase text with commas separating the parameters. All values are in decimal. However, limited symbolic names are permitted; for example, <code>abc: equ 12</code> binds the number <code>12</code> to the symbolic name <code>abc:</code>. Note the need for a colon after the name.</p>&#13;
			<p lang="en-GB">All data is <a id="_idIndexMarker493"/>either a number or a memory address; for example, <code>add 12,13,20</code> adds the contents of memory location <code>13</code> to the contents of memory location <code>20</code> and puts the sum in memory location <code>12</code>.</p>&#13;
			<p lang="en-GB">A branch requires an actual address. Branching is absolute (direct) and not program counter-relative. To branch to the instruction beginning at address <code>16</code>, you write <code>bra 16</code>. However, symbolic names are supported and you can write <code>bra abc:</code>, provided that the target is labeled with <code>abc:</code>.</p>&#13;
			<p lang="en-GB">In this simulator, the instruction counter is incremented by one every time a new instruction is read. However, the memory counter is incremented every time a new byte is added to this instruction. The added bytes may be 1, 2, 3, or 4.</p>&#13;
			<p lang="en-GB">Since you have to give a byte branch address, you not only have to count the number of instructions branched but also the number of bytes branched. To do this, we create a mapping table that maps the instruction address to the byte address. This table is called <code>map[]</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
print ('Demonstrating multiple length instructions. Version 3 December 8 2022 \n')</pre>&#13;
			<pre class="source-code">mem     = [0] * 128</pre>&#13;
			<p lang="en-GB">The <code>lookUp{}</code> dictionary describes each instruction with a binary key and a value consisting <a id="_idIndexMarker494"/>of a mnemonic. The <code>allOps{}</code> dictionary consists of a key (the mnemonic) and a tuple containing the instruction length and opcode:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
lookUp  = {0b00001:'nop',0b00010:'stop',0b01000:'inc',0b01001:'dec',  \&#13;
           0b01010:'bra',0b01011:'beq',0b01100:'bne',0b10000:'mov',   \&#13;
           0b10001:'cmpl',0b10010:'cmp',0b10011:'ld',0b10100:'st',    \&#13;
           0b11000:'add',0b11001:'sub'}&#13;
allOps  = {'nop':(1,1),'stop':(1,2),'inc':(2,8),'dec':(2,9),'bra':(2,10),   \&#13;
           'beq':(2,11),'bne':(2,12),'mov':(3,16),'ld':(3,19),              \&#13;
           'cmpl':(3,17),'cmp':(3,18),'add':(4,24),'sub':(4,25),'test':(0,0)}&#13;
# NOTE that progS is the actual program to be executed. It is embedded into the program&#13;
progS   = ['this: equ 26','ld this:,7','that: equ 28','ld 27,2', \&#13;
           'ld that:,1','loop: add 28,28,26', 'dec 26','bne loop:','stop']&#13;
symTab  = {}                                          # Label symbol table&#13;
prog    = []                                          # progS is prog without equates&#13;
for i in range (0,len(progS)):                        # Process source code for equates&#13;
    thisLine = progS[i].split()                       # Split source code on spaces&#13;
    if len(thisLine) &gt; 1 and thisLine[1] == 'equ':    # Is this line an equate?&#13;
         symTab.update({thisLine[0][0:]:thisLine[2]}) # Store label in symbol table. &#13;
    else: prog.append(progS[i])                  # Append line to prog unless it's an equate</pre>&#13;
			<p lang="en-GB">The next <a id="_idIndexMarker495"/>step after removing equates is to clean up the source code and deal with labels:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
for i in range (0,len(prog)):             # Process source code (now without equates)&#13;
    prog[i] = prog[i].replace(',',' ')    # Remove commas&#13;
    prog[i] = prog[i].split(' ')          # Tokenize&#13;
    token1 = prog[i][0]                   # Get first token of instruction&#13;
    if token1[-1] == ':':                 # If it ends in :, it's a label&#13;
        j = str(i)                        # Note: we have to store i as a string not an integer&#13;
        symTab.update({token1:j})         # Add label and instruction number to symbol table&#13;
        prog[i].pop(0)                    # Remove label from this line. NOTE "pop"&#13;
print('Symbol table: ', symTab)&#13;
map = [0] * 64                            # Map instruction number to byte address</pre>&#13;
			<p lang="en-GB">We now go through the code, but not in execution mode. We create a memory counter, mc, that acts rather like a program counter but serves to keep track of the instructions in memory:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
mC  = 0                                 # Memory counter (store code from 0)&#13;
for iC in range (0,len(prog)):          # Step through the program&#13;
    instruction = prog[iC]              # Read an instruction. iC = instruction counter&#13;
    mCold = mC                          # Remember old memory counter (address of first byte)&#13;
    map[iC] = mC                        # Map byte address to instruction address&#13;
    mnemonic = instruction[0]           # The first token is the mnemonic&#13;
    mem[mC] = allOps[mnemonic][1]       # Store opcode in memory</pre>&#13;
			<pre class="source-code">    mC = mC + 1                         # Point to next free memory location&#13;
    numOperands = allOps[mnemonic][0] - 1    # Get the number of operands from dictionary&#13;
    if numOperands &gt; 0:                 # If one or more operands&#13;
        if instruction[1] in symTab:    # See if operand is in symbol table&#13;
            instruction[1] = symTab[instruction[1]]   # If it is, convert into as string&#13;
        mem[mC] = int(instruction[1])   # Store address in memory as integer&#13;
        mC = mC + 1                     # Bump up byte counter&#13;
    if numOperands &gt; 1:                 # Do the same for two operands&#13;
        if instruction[2] in symTab:    # See if operand is in symbol table&#13;
            instruction[2] = symTab[instruction[2]]    # Convert to address as string&#13;
        mem[mC] = int(instruction[2])&#13;
        mC = mC + 1&#13;
    if numOperands &gt; 2:                 # Now deal with 3-operand instructions&#13;
        if instruction[3] in symTab:    # See if operand is in symbol table&#13;
            instruction[3] = symTab[instruction[3]]   # If it is, convert to string&#13;
        mem[mC] = int(instruction[3])&#13;
        mC = mC + 1&#13;
    instPrint =  ' {0:&lt;15}'.format( (' ').join(instruction)) # reformat instruction&#13;
    print('iC=', iC,'\t', 'Op =', mnemonic, '\tNumber of operands =',  \&#13;
           numOperands, '\t mC =', mCold, '\tInstruction =',           \&#13;
           instPrint, 'memory =', mem[mCold:mC])&#13;
print('Memory (in bytes) =', mem[0:40], '\n')&#13;
                                               # EXECUTE THE CODE&#13;
print('\nCode execution: press enter \n')&#13;
pc, iC, z = 0, 0, 0                            # Initialize program and instruction counters</pre>&#13;
			<p lang="en-GB">Now we <a id="_idIndexMarker496"/>can execute the code by stepping through the instructions in memory using a program counter. However, the program counter is incremented by the length of each instruction after the current instruction has been read:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
run = True&#13;
while run:                                       # Instruction execution loop&#13;
    pcOld  = pc                                  # Remember pc at start of this cycle&#13;
    opCode = mem[pc]                             # Read opcode&#13;
    opLen  = (opCode &gt;&gt; 3) + 1                   # Get instruction length from opcode&#13;
    if opCode == 0b00010:                        # Test for stop&#13;
        run = False                              # Terminate on stop instruction&#13;
        print('Execution terminated on stop')    # Say 'Goodbye'&#13;
        break                                    # and exit the loop&#13;
    operand1, operand2, operand3 = '', '', ''    # Dummy operands (null strings)&#13;
    if opLen &gt; 1: operand1 = mem[pc + 1]&#13;
    if opLen &gt; 2: operand2 = mem[pc + 2]&#13;
    if opLen &gt; 3: operand3 = mem[pc + 3]&#13;
    pc = pc + opLen&#13;
    iC = iC + 1</pre>&#13;
			<pre class="source-code">    mnemonic = lookUp[opCode]</pre>&#13;
			<p lang="en-GB">After <a id="_idIndexMarker497"/>looking up the opcode, we use an <code>if...elif</code> construct to examine successive mnemonics to determine the current operation. Note the dummy no-operation is implemented by Python’s pass, which does nothing:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    if   mnemonic == 'nop': pass&#13;
    elif mnemonic == 'inc': mem[operand1] = mem[operand1] + 1&#13;
    elif mnemonic == 'dec':&#13;
        z = 0&#13;
        mem[operand1] = mem[operand1] - 1&#13;
        if mem[operand1] == 0: z = 1&#13;
    elif mnemonic == 'bra':  pc = map[operand1] # Map instruction address to byte address&#13;
    elif mnemonic == 'beq' and z == 1: pc = map[operand1]&#13;
                                                 # Map instruction address to byte address&#13;
    elif mnemonic == 'bne' and z == 0: pc = map[operand1]&#13;
                                                 # Map instruction address to byte address&#13;
    elif mnemonic == 'ld':  mem[operand1] = operand2&#13;
    elif mnemonic == 'mov': mem[operand1] = mem[operand2]</pre>&#13;
			<p lang="en-GB">The <code>cmp</code> compare <a id="_idIndexMarker498"/>operation subtracts two operands and sets the z-bit to <code>1</code> if the result is zero. Otherwise, <code>z</code> is set to <code>0</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    elif mnemonic == 'cmp':&#13;
        diff = mem[operand1] - mem[operand2]&#13;
        z = 0&#13;
        if diff == 0: z = 1&#13;
    elif mnemonic == 'cmpl':&#13;
        diff = mem[operand1] - operand2&#13;
        z = 0&#13;
        if diff == 0: z = 1&#13;
    elif mnemonic == 'add': mem[operand1] = mem[operand2] + mem[operand3]&#13;
    elif mnemonic == 'sub':&#13;
        mem[operand1] = mem[operand2] - mem[operand3]&#13;
        z = 0&#13;
        if mem[operand1] == 0: z = 1</pre>&#13;
			<p lang="en-GB">At the end <a id="_idIndexMarker499"/>of the <code>execute</code> loop, we get input from the keyboard. This simply introduces a wait until the <em class="italic">Enter</em>/<em class="italic">return</em> key is hit before the next instruction is executed. The remaining Python code formats the output:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    x = input('... ')&#13;
    xxxx =  mnemonic + ' ' + str(operand1) + ' ' + str(operand2) \&#13;
    + ' ' + str(operand3)&#13;
    instPrint =  ' {0:&lt;15}'.format(xxxx)                   # re-format the instruction&#13;
    print ('iC=',iC-1,'\tpc=',pcOld,'\tOp=',mnemonic,'z=',z,      \</pre>&#13;
			<pre class="source-code">           '\tmem 24-35=',mem[24:36],'\tInstruction = ', instPrint)</pre>&#13;
			<p lang="en-GB">We have only briefly touched on the topic of variable-length instructions. In principle, it’s a very simple idea. An instruction is read, decoded, and executed. As each instruction is fetched into the computer, it has to be decoded and the program counter advanced by the number of words taken up by the current instruction. In practice, this creates problems because branch addresses are no longer just the number of instructions from the branch but also the number of memory locations taken up by those instructions.</p>&#13;
			<h1 id="_idParaDest-131" lang="en-GB"><a id="_idTextAnchor134"/>Summary</h1>&#13;
			<p lang="en-GB">The previous chapter introduced TC1, a Python-based computer simulator that could be used to develop and test instruction set architectures. In this chapter, we explored aspects of simulator design in more depth.</p>&#13;
			<p lang="en-GB">We looked at how you can create new instructions and add them to TC1’s instruction set. Advanced instructions that perform a lot of special-purpose computation were once the province of the classic CISC processor, such as the Motorola 68K family. Then, with the rise of the RISC architecture and its stress on simplicity and single-cycle instructions, the CISC processor seemed about to go out of fashion. However, many modern computers have incorporated complex instructions for special applications such as data encoding, image processing, and AI applications.</p>&#13;
			<p lang="en-GB">We looked a little more deeply at how you can check the input of a simulator and ensure that errors in data and instructions can be detected.</p>&#13;
			<p lang="en-GB">We also looked at various topics in Python programming, such as data formatting. In principle, printing data the way you want it to look is easy. In practice, it is a little more complicated (not least because there are several methods of formatting data).</p>&#13;
			<p lang="en-GB">This chapter expanded on the notion of tracing a program while it is being executed and demonstrated some of the techniques involved in printing the data you want to see during a simulator run.</p>&#13;
			<p lang="en-GB">As well as looking at new instructions, we explored the concept of variable-length instructions. We started with a demonstration of how you could change the number of bits in each register address field at runtime to change the number of addressable registers. This is not a realistic factor in instruction set design (at the moment), but there was a period when register windows became popular and you could, indeed, expand the number of registers.</p>&#13;
			<p lang="en-GB">We introduced the notion of variable-length instructions when each instruction can be an integer number of multiples of the computer’s word length. This approach allows instructions with an unlimited level of complexity at the price of more complicated decoding mechanisms. We demonstrated the design of a primitive variable instruction length machine that could easily be expanded to a simulator with the full complexity of TC1.</p>&#13;
			<p lang="en-GB">The next chapter returns to the simulator and looks at several simulators for different types of architecture.</p>&#13;
		</div>&#13;
	</div></body></html>