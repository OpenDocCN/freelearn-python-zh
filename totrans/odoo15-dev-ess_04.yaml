- en: '[*Chapter 6*](B16119_06_Final_PD_ePub.xhtml#_idTextAnchor164): Models – Structuring
    the Application Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn more about the model layer and how to use models
    to design the data structures that support applications. We will explore the available
    model types, when each should be used, and how to define constraints that enforce
    data validations.
  prefs: []
  type: TYPE_NORMAL
- en: Models are composed of data fields that support several data types, and some
    field types support defining relationships between models. More advanced usage
    of fields involves having values automatically computed using specific business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning project – improving the Library app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships between models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the Odoo base models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout these topics, you will learn how to create non-trivial data structures
    for your Odoo projects. By the end of this chapter, you should have a clear overview
    of all the relevant features needed to structure data models.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is based on the code we created in [*Chapter 3*](B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072),
    *Your First Odoo Application*. This code can be found in the `ch06/` directory
    of this book's GitHub repository at [https://github.com/PacktPublishing/Odoo-15-Development-Essentials](https://github.com/PacktPublishing/Odoo-15-Development-Essentials).
  prefs: []
  type: TYPE_NORMAL
- en: You should have it in your add-ons path. Make sure that you install the `library_app`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Learning project – improving the Library app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072), *Your First
    Odoo Application*, we created the `library_app` add-on module and implemented
    the simple `library.book` model to represent a book catalog. In this chapter,
    we will revisit that module to enrich the data that we can store for each book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add a category hierarchy to use for book categorization with the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: The category title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent**: The parent category that it belongs to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subcategories**: The categories that have this one as the parent'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Featured book or author**: A selected book or author that represents this
    category'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A few more fields will be added to showcase the different data types available
    for Odoo fields. We will also use model constraints to implement a few validations
    on the Books model:'
  prefs: []
  type: TYPE_NORMAL
- en: The title and publication date should be unique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ISBNs entered should be valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start by revisiting Odoo models, now in more depth, to learn about all
    the options that are available for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Models are at the heart of the Odoo framework. They describe the application
    data structures and are the bridge between the application server and the database
    storage. Business logic can be implemented around models to provide application
    features, and user interfaces are created on top of them to provide the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will learn about the model's generic attributes,
    which are used to influence their behavior, and the several types we have available
    – **regular models**, **transient models**, and **abstract models**.
  prefs: []
  type: TYPE_NORMAL
- en: Model attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Model classes can use additional attributes to control some behaviors. These
    are the most commonly used attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_name`: This is the internal identifier for the Odoo model we are creating.
    This is mandatory when creating a new model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_description`: This is a user-friendly title that can be used to refer to
    a single `Model` record, such as `Book`. This is optional but recommended. If
    this is not set, a server log warning will be displayed during the loading sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_order`: This sets the default order to use when the model''s records are
    browsed, or shown in a list view. It is a text string to be used as the SQL order
    by clause, so it can be anything you could use there, although it has smart behavior
    and supports translatable and many-to-one field names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `Book` model is already using the `_name` and `_description` attributes.
    The following code adds the `_order` attribute to have the default order by book
    title, and then by reverse order of publication date (from newest to oldest):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more advanced attributes available that can be helpful in advanced
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_rec_name`: This sets the field to use for the record''s display name. By
    default, it is the `name` field, which is why we usually choose this particular
    field name for the records title field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_table`: This is the name of the database table supporting the model. Usually,
    it is left to be automatically set by the ORM, which will use the model name after
    replacing the dots with underscores. However, we are free to choose a specific
    database table name to be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_log_access=False`: This can be used to prevent audit tracking fields from
    being automatically created; that is, `create_uid`, `create_date`, `write_uid`,
    and `write_date`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_auto=False`: This prevents the underlying database table from being automatically
    created. In this case, we should use the `init()` method to provide our specific
    logic for creating the supporting database object, a table, or a view. This is
    usually used for views that support read-only reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an example, the following code sets the default values on the `library.book`
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are also the `_inherit` and `_inherits` attributes, which are used for
    module extension. These were explained in detail in [*Chapter 4*](B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119),
    *Extending Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: When using `_auto = False`, we are overriding the process of creating the database
    object, so we should provide the logic for that. A frequent application of this
    is models to use for reports, based on a database view that gathers all the data
    needed for the report.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example taken from the `sale` core module, in the `sale/report/sale_report.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses a `tools` Python module, which needs to be imported
    using `odoo import tools`.
  prefs: []
  type: TYPE_NORMAL
- en: Models and Python classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Odoo models use Python classes. In the preceding code, we can see a Python class,
    `Book`, based on the `models.Model` class, being used to define an Odoo model
    named `library.book`.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo models are kept in a *central registry*, available through the *environment
    object*, which is usually accessed using `self.env`. The central registry keeps
    references to all the models available, and they can be accessed with a dictionary-like
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to get a reference to the library book model inside a method, we
    could use `self.env["library.book"]` or `self.env.get(["library.book"])`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, model names are important and are the key to accessing the model
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: Model names must be globally unique. Because of this, it is a good practice
    to use the first word of the application the module belongs to as the first word
    in the model's name. In the case of the `Library` app, all model names should
    have `library` as a prefix. Other examples from the core modules are `project`,
    `crm`, or `sale`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Model names should use the singular form, `library.book`, rather than `library.books`.
    The convention is to use a list of lowercase words joined with dots. The first
    word should identify the main app the model belongs to, such as `library.book`
    or `library.book.category`. Other examples that have been taken from official
    add-ons include `project.project`, `project.task`, and `project.task.type`.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, Python class identifiers are local to the Python file where
    they are declared and are not relevant to the Odoo framework. The identifier that's
    used for them is only significant for the code in that file and is rarely relevant.
    The Python convention for class identifiers is to use *CamelCase*, following the
    standards defined by the PEP8 coding conventions.
  prefs: []
  type: TYPE_NORMAL
- en: There are several types of models available. The most frequently used one is
    the `models.Model` class, for persistent database stored models. Next, we will
    learn about the other available model types.
  prefs: []
  type: TYPE_NORMAL
- en: Transient and abstract models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most Odoo models, the Python class is based on `models.Model`. This type
    of model has permanent database persistence, which means that database tables
    are created for them and their records are stored until they're explicitly deleted.
    And most of the time, this is what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in some cases, we don''t need permanent database persistence, and hence
    these two other model types can be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`models.TransientModel`, are used for wizard-style user interaction. Their
    data is still stored in the database, but it is expected to be temporary. A vacuum
    job periodically clears old data from these tables. For example, the **Settings**
    | **Translations** | **Import Translation** menu option opens a dialog window
    that uses a transient model to store the user selections and implement the wizard
    logic. An example of using a transient model will be discussed in [*Chapter 8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227),
    *Business Logic – Supporting Business Processes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models.AbstractModel` class and have no data storage attached to them. They
    can be used as reusable feature sets, to be mixed in with other models using Odoo''s
    inheritance capabilities. For example, `mail.thread` is an abstract model provided
    by the `mail.thread` example mentioned previously were discussed in [*Chapter
    4*](B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119), *Extending Modules*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting existing models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The models and fields that are created by Python classes can be inspected through
    the user interface. With **Developer Mode** enabled, via the **Settings** top
    menu, navigate to the **Technical** | **Database Structure** | **Models** menu
    item. Here, you will find a list of all the models available in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on a model in the list will open a form showing its details, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Inspecting the Book model from the Technical menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B16119.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Inspecting the Book model from the Technical menu
  prefs: []
  type: TYPE_NORMAL
- en: This is a good tool for inspecting a model since it shows the results of all
    the modifications made by different modules. At the top right of the form, in
    the `library.book` is affected by the `library_app` and `library_member` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As seen in [*Chapter 1*](B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Quick
    Start Using Developer Mode*, the **Models** form is editable! It is possible to
    create and modify models, fields, and views from here. You can use this to build
    prototypes that will be implemented as add-on modules later.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the lower area, we have some tabs with additional information available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fields** lists the model fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access Rights** lists the access control rules granted to security groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Record Rules** lists the record rules applying filters to records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notes** is the model definition docstring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Views** lists the views available for the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find the model's external identifier or XML ID, we can use the `model_`.
    As an example, the identifier that's generated for the `library.book` model, as
    created by the `library_app` module, is `library_app.model_library_book`. These
    XML IDs are usually needed for the CSV files defining the security ACLs.
  prefs: []
  type: TYPE_NORMAL
- en: We are now familiar with the options we have for defining the model. The next
    step is to understand the several field types, as well as the options available
    to configure them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having created a new model, the next step is to add fields to it. Odoo supports
    all the basic data types that are expected, such as text strings, integers, floating-point
    numbers, Booleans, dates and time, and image or binary data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore the several types of fields available in Odoo.
  prefs: []
  type: TYPE_NORMAL
- en: Basic field types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will go back to the book model to present the several available field types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `library_app/models/library_book.py` file, edit the `Book` class, replacing
    the current field definitions with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These are examples of the non-relational field types that are available in Odoo
    with the positional arguments expected by each one. Next, we will explain all
    these field types and options.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Python functions can have two types of arguments: positional and keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fn(x, y)` should be something such as `f(1, 2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`f(x=1, y=2)`, or even mix both styles, with something such as `f(1, y=2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, note that positional arguments must come before keyword arguments,
    so `f(x=1, 2)` is not allowed. More information on keyword arguments can be found
    in the Python official documentation at [https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments](https://docs.python.org/3/tutorial/controlflow.html#keyword-arguments).
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, the first positional argument is the field title, which corresponds
    to the `string` keyword argument. The exception to this rule is the **Selection**
    fields and all the relational fields.
  prefs: []
  type: TYPE_NORMAL
- en: The `string` attribute is used as the default text for the user interface labels.
    If the `string` attribute is not provided, it will be automatically generated
    from the field name, replacing underscores with spaces and capitalizing the first
    letter in each word. For example, the `date_published` default label is **Date
    Published**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, this is the list of all the non-relational field types that
    are available, along with the positional arguments expected by each:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Char(string)` is a simple text field. The only positional argument that''s
    expected is the field label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Text(string)` is a multiline text field. The only positional argument is also
    the field label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Selection(selection, string)` is a drop-down selection list. The selection
    positional arguments is a `[("value", "Description"),]` list of tuples. For each
    pair, the first element is the value stored in the database, and the second element
    is the description presented in the user interface. Extension modules can add
    options to this list using the `selection_add` keyword argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Html(string)` is stored as a text field but has specific handling for the
    user interface for HTML content presentation. For security reasons, it is sanitized
    by default, but this behavior can be overridden using the `sanitize=False` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Integer(string)` is for integer numbers and expects a string argument for
    the field label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float(string, digits)` stores floating-point numbers and has a second optional
    argument for the precision to use. This is an `(n, d)` tuple, where `n` is the
    total number of digits, and `d` is the number of those digits used for decimals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Monetary(string, currency_field)` is similar to a `float` field but has specific
    handling for currency values. The `currency_field` second argument is for the
    name of the currency field. By default, it is set to `currency_field="currency_id"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Date(string)` and `Datetime(string)` fields are for dates and date-time
    values. They only expect the label text as a positional argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean(string)` stores True or False values and has one positional argument
    for the label text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Binary(string)` stores binary data, including images, and expects the string
    label positional argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These field definitions provide the basic parameters that are usually used.
    Note that there are no required arguments, and Odoo will use reasonable defaults
    for the missing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: The `Date` and `Datetime` fields are now handled in the ORM as Python date objects.
    In previous versions, they were handled as text representations. Because of this,
    when manipulated, an explicit conversion into a Python date object was needed,
    which would have to be converted back into a text string after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Text-based fields, including `Char`, `Text`, and `Html`, have a few specific
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`size` (only for `Char` fields) sets the maximum allowed size. It is recommended
    to not use it unless there is a good reason for it; for example, a social security
    number with a maximum length allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translate=True` makes the field contents translatable, holding different values
    for different languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim` is set to `True` by default and automatically trims the surrounding
    white space, which is performed by the web client. This can be explicitly disabled
    by setting `trim=False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `trim` field attribute was introduced in Odoo 12\. In previous versions,
    text fields were saved along with the white space.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, we also have relational field types available. These will be explained
    later in this chapter, in the *Relationships between models* section.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to that, however, there is still more to know about the attributes
    of the basic field types, as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Common field attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have looked at the basic positional arguments available for several
    basic field types. However, there are more attributes available to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following keyword argument attributes are generally available to all field
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string` is the field''s default label, to be used in the user interface. Except
    for `Selection` and relational fields, it is available as the first positional
    argument, so most of the time, it is not used as a keyword argument. If it''s
    not provided, it is automatically generated from the field name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` sets a default value for the field. It can be a fixed value (such
    as `default=True` in the `active` field), or a callable reference, either the
    named function reference or a `lambda` anonymous function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`help` provides the text for tooltips that are displayed to users when hovering
    the mouse over the field in the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readonly=True` makes the field not editable in the user interface by default.
    This is not enforced at the API level: code in model methods will still be capable
    of writing to it, and a view definition can override this. It is only a user interface
    setting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`required=True` makes the field mandatory in the user interface by default.
    This is enforced at the database level by adding a `NOT NULL` constraint to the
    database column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index=True` adds a database index to the field, for faster search operations
    at the expense of disk space usage and slower write operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy=False` has the field ignored when duplicating a record via the `copy()`
    ORM method. Field values are copied by default, except for to-many relational
    fields, which are not copied by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deprecated=True` marks the field as deprecated. It will still work as usual,
    but any access to it will write a warning message to the server log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups` allows you to limit the field''s access and visibility to only some
    groups. It expects a comma-separated list of XML IDs for security groups; for
    example, `groups="base.group_user,base.group_system"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`states` expects dictionary mapping values for UI attributes, depending on
    the values of the `state` field. The attributes that can be used are `readonly`,
    `required`, and `invisible`; for example, `states={''done'':[(''readonly'',True)]}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the `states` field attribute is equivalent to the `attrs` attribute
    in views. Also, views support a `states` attribute that has a different use: it
    is a comma-separated list of states in which the view element should be visible.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is an example of the `name` field with all the available keyword arguments
    spelled out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Previous Odoo versions supported the `oldname="field"` attribute, which is used
    when a field is renamed in a newer version. It enabled the data in the old field
    to be automatically copied into the new field during the module upgrade process.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: The `oldname` field attribute was removed and is no longer available. The alternative
    is to use migration scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding field attributes are generic and apply to all field types. Next,
    we will learn how to set default values on fields.
  prefs: []
  type: TYPE_NORMAL
- en: Setting default values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, the `default` attribute can have a fixed value or
    a reference to a function to dynamically compute the default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For trivial computations, we can use a `lambda` function to avoid the overhead
    of creating a named method function. Here is a common example of computing a default
    value with the current date and time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `default` value can also be a function reference. This can be a name reference
    or a string with the function name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses a name reference to the `_default_last_borrow_date`
    function method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And this example does the same, but uses a string with the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With this latter method, the function name resolution is delayed at runtime,
    rather than Python file loading time. So, in the second example, we can reference
    a function declared later in the code, while in the first example, the function
    must be declared before the function declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Still, the general code convention here is to have the default value function
    defined before the field's definitions. Another argument for preferring the first
    approach, using the function name reference, is that code editors can detect typing
    errors if they support static code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic field names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some field names are special, either because they are reserved by the ORM for
    special purposes, or because some built-in features make use of some default field
    names.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field is reserved to be used as an automatic number, uniquely identifying
    each record, and is used as the database's primary key. It is automatically added
    to every model.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fields are automatically created on new models unless the `_log_access=False`
    model attribute is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_uid` is for the user who created the record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_date` is for the date and time when the record is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_uid` is for the last user to modify the record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write_date` is for the last date and time when the record was modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The information in these fields is available in the web client when in a form
    view if you go to the **Developer Mode** menu and then click the **View Metadata**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding field names have a special meaning for the Odoo framework. Other
    than these, there are a few more field names that are used as defaults for some
    Odoo features. The next section describes them.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved field names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some built-in API features expect specific field names by default. These are
    considered reserved field names, and we should avoid using them for purposes other
    than the expected ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the reserved fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` or `x_name` of the `Char` type: These are used by default as the display
    name for the record. But a different field can be used for the display name by
    setting the `_rec_name` model attribute. Non-character field types are also known
    to work for this, and a number to text conversion will be forced for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active` or `x_active` of the `Boolean` type: These allow you to deactivate
    records, making them invisible. Records with `active=False` are automatically
    excluded from queries unless the `{''active_test'': False}` key is added to the
    environmental context. It can be used as a record *archive* or *soft delete* feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state` of the `Selection` type: This represents basic states for the record
    life cycle. It enables the usage of the `states` field attribute to dynamically
    set the `readonly`, `required`, or `invisible` attributes; for example, `states={''draft'':
    [(''readonly'', False)]}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent_id` of the `Many2one` type: This is used to define tree-like hierarchical
    structures, and enables the usage of the `child_of` and `parent_of` operators
    in domain expressions. The field to use as `parent_id` can be set to a different
    one using the `_parent_name` model attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent_path` of the `Char` type: This can be used to optimize the usage of
    the `child_of` and `parent_of` operators in domain expressions. For proper operation,
    use `add index=True` to use a database index. We will discuss hierarchical relations
    later in this chapter, in the *Hierarchical relationships* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`company_id` of the `Many2one` type: This is used to identify the company that
    the record belongs to. An empty value means that the record is shared between
    companies. It is used by internal checks on company data consistency via the `_check_company`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in Odoo 14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`x_active` is now recognized as an equivalent to the `active` field and can
    be used for the same effect. This was introduced for better support for customizations
    using **Developer Mode** or the **Odoo Studio** app.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So far, we have discussed non-relational fields. But a good part of an application
    data structure is about describing the relationships between entities. Let's look
    at that now.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships between models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-trivial business applications need to use relationships between the different
    entities involved. To do this, we need to use relational fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `Library` app, the `Book` model has the following relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: Each book can have one publisher, and each publisher can have many books. From
    the book's point of view, this is a *many-to-one relationship*. It is implemented
    in the database as an integer field, holding the ID of the related publisher record,
    and a database foreign key in it, enforcing referential integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reverse of this, from the publisher's point of view, is a **one-to-many
    relation**, meaning that each publisher can have many books. While this is also
    a field type in Odoo, its database representation relies on the many-to-one relationship.
    We know the books related to a publisher running a query on books, filtered by
    the publisher ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each book can have many authors, and each author can have many books. This is
    a **many-to-many** relationship. The inverse relationship is also a many-to-many
    relationship. In relational databases, many-to-many relationships are represented
    through a helper database table. Odoo will automatically take care of this, although
    we can have some control over the technical details if we want.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will explore each of these relationships in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: A particular case is hierarchical relations, where records in a model are related
    to other records in the same model. We will introduce a book category model to
    explain this.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Odoo framework also supports flexible relationships, where the
    same field is capable of representing relationships with several different models.
    These are called `Reference` fields.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-one relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `publisher_id` field represents a reference to the book publisher – a record
    in the **Partner** model.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, this is the publisher field definition using positional arguments
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `Many2one` field definition uses positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first positional argument is the related model, corresponding to the `comodel`
    keyword argument, which is `res.partner` in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second positional argument is the field label, corresponding to the `string`
    keyword argument. This is not the case for the other relational fields, so the
    preferred option is to always use `string` as a keyword argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A many-to-one model field creates a column in the database table, with a foreign
    key to the related table, and holds the database ID of the related record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments can be used instead of, or to complement, the positional
    argument. These are the keyword arguments that are supported by many-to-one fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ondelete`: This defines what happens when the related record is deleted. The
    possible behaviors are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set null` (the default): An empty value is set when the related record is
    deleted.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`restricted`: This raises an error, preventing the deletion.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`cascade`: This will also delete this record when the related record is deleted.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`context`: This is a dictionary of data that''s meaningful for the web client
    views to carry information when navigating through the relationship, such as to
    set default values. This will be explained in more detail in [*Chapter 8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227),
    *Business Logic – Supporting Business Processes*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`domain`: This is a domain expression – a list of tuples used to filter the
    records made available for selection on the relationship field. See [*Chapter
    8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227), *Business Logic – Supporting
    Business Processes*, for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto_join=True`: This allows the ORM to use SQL joins when doing searches
    using this relationship. If used, the access security rules will be bypassed,
    and the user could have access to related records that the security rules would
    not allow, but the SQL queries will run faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delegate=True`: This creates a delegation inheritance with the related model.
    When used, the `required=True` and `ondelete="cascade"` attributes must also be
    set. See [*Chapter 4*](B16119_04_Final_PD_ePub.xhtml#_idTextAnchor119), *Extending
    Modules*, for more information on delegation inheritance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One-to-many inverse relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **one-to-many relationship** is the inverse of the many-to-one relationship.
    It lists the records that have a relationship with this record.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the library book model, the `publisher_id` field has a many-to-one
    relationship with the partner model. This means that the partner model can have
    a one-to-many inverse relationship with the book model, listing the books published
    by each partner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before a one-to-many relationship field can be created, the inverse many-to-one
    field should be added to the related model. For this, create the `library_app/models/res_partner.py`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a new code file for the module, it must also be added to the
    `library_app/models/__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `One2many` fields expect three positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The related model, which corresponds to the `comodel_name` keyword argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The related model field that's used to refer to this record, which corresponds
    to the `inverse_name` keyword argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The field label, which corresponds to the `string` keyword argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The additional keyword arguments that are available are the same as those for
    the many-to-one fields: `context`, `domain`, `auto_join`, and `ondelete` (here,
    these act on the **many** sides of the relationship).'
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **many-to-many relationship** is used when both entities have a to-many relationship
    between them. Using the library books example, there is a many-to-many relationship
    between books and authors: each book can have many authors, and each author can
    have many books.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the book''s side – that is, the `library.book` model – we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'On the author''s side, we can have the `res.partner` model inverse relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Many2many` minimal signature expects one positional argument for the related
    model – the `comodel_name` keyword argument – and it is recommended to also provide
    the `string` argument with the field label.
  prefs: []
  type: TYPE_NORMAL
- en: At the database level, many-to-many relationships don't add any columns to the
    existing tables. Instead, a special relationship table is automatically created
    to store the relationships between records. This special table has only two ID
    fields, with foreign keys for each of the two related tables.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the relationship table's name is the two table names joined with
    an underscore and `_rel` appended at the end. In the case of our books or authors
    relationship, it should be named `library_book_res_partner_rel`.
  prefs: []
  type: TYPE_NORMAL
- en: On some occasions, we may need to override these automatic defaults. One such
    case is when the related models have long names, and the name for the automatically
    generated relationship table is too long, exceeding the 63-character PostgreSQL
    limit. In these cases, we need to manually choose a name for the relationship
    table to conform to the table name size limit.
  prefs: []
  type: TYPE_NORMAL
- en: Another case is when we need a second many-to-many relationship between the
    same models. In these cases, a relationship table name must be manually provided
    so that it doesn't collide with the table name already being used for the first
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two alternatives to manually override these values: either use positional
    arguments or keyword arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using positional arguments for the field definition, the field definition
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Keyword arguments can be used instead, which may be preferred for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following arguments were used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`comodel_name` is the name of the related model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`relation` is the database table name supporting the relationship data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column1` is the column name referring to the model records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`column2` is the column name referring to the related model records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string` is the field label in the user interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to one-to-many relational fields, many-to-many fields can also use the
    `context`, `domain`, and `auto_join` keyword arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: On abstract models, don't use the many-to-many field `column1` and `column2`
    attributes. There is a limitation in the ORM design regarding abstract models,
    and when you force the names of the relationship columns, they cannot be cleanly
    inherited anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Parent-child relationships are a particular case that is worth looking into
    in more detail. We will do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parent-child tree relationships are represented using a many-to-one relationship
    with the same model, where each record holds a reference to its parent. The inverse
    one-to-many relationship represents the record's direct children.
  prefs: []
  type: TYPE_NORMAL
- en: Odoo provides improved support for these hierarchical data structures, making
    the `child_of` and `parent_of` operators available in domain expressions. These
    operators are available so long as the model has a `parent_id` field (or the model
    has a `_parent_name` valid definition, setting an alternative field name to use
    for this purpose).
  prefs: []
  type: TYPE_NORMAL
- en: Optimized hierarchy tree searching can be enabled by setting the `_parent_store=True`
    model attribute and adding the `parent_path` helper field. This helper field stores
    additional information about the hierarchy tree structure, which is used to run
    faster queries.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: The `parent_path` hierarchy helper field was introduced in Odoo 12\. Previous
    versions used the `parent_left` and `parent_right` integer fields for the same
    purpose, but these were deprecated as of Odoo 12.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of a hierarchical structure, we will add a category tree to the
    **Library** app to be used to categorize books.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `library_app/models/library_book_category.py` file, along with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a basic model with a `parent_id` field to reference the parent
    record.
  prefs: []
  type: TYPE_NORMAL
- en: To enable a faster tree search, we added the `_parent_store=True` model attribute.
    When doing so, the `parent_path` field must also be added, and it must be indexed.
    The field that's used to refer to the parent is expected to be named `parent_id`,
    but any other field name can be used, so long as we declare that in the `_parent_name`
    optional model attribute.
  prefs: []
  type: TYPE_NORMAL
- en: It is often convenient to add a field to list the direct children. This is the
    one-to-many inverse relationship shown in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the previous code to be used by our module, remember to add a reference
    to its file in `library_app/models/__init__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that these additional operations come with storage and execution time
    penalties, so they are best used when you expect to read more frequently than
    write, such as in the case of category trees. This is only necessary when optimizing
    deep hierarchies with many nodes; this can be misused for small or shallow hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible relationships using Reference fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regular relational fields can only reference one fixed co-model. The `Reference`
    field type does not have this limitation and supports flexible relationships,
    and the same field can reference records from different destination models.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will add a `Reference` field to the book category model,
    to indicate a highlighted book or author. This field can link to either a book
    or a partner record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The field definition is similar to a `Selection` field, but here, the selection
    list holds the models that can be used on the field. In the user interface, the
    user will pick a model from the available list, and then pick a specific record
    from that model.
  prefs: []
  type: TYPE_NORMAL
- en: Reference fields are stored in the database as a character field, containing
    a `<model>,<id>` string.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: Previous Odoo versions featured a referenceable model configuration that could
    be used to pick the models used in `Reference` fields from the `Reference` field,
    by adding the `odoo.addons.res.res_request.referenceable_models` function in place
    of the model selection list. This feature was removed in Odoo 12.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've seen the field types that are supported by Odoo. Not only can
    fields store user-provided data, but they are also capable of presenting computed
    values. The next section introduces this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Computed fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fields can have their values automatically calculated by a function, instead
    of simply reading a database stored value. A computed field is declared just like
    a regular field but has the additional `compute` argument to define the function
    that's used for the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Computed fields involve writing some business logic. So, to take full advantage
    of this feature, we should be comfortable with the topics that will be explained
    in [*Chapter 8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227), *Business Logic
    – Supporting Business Processes*. Computed fields will still be explained here,
    but we will keep the business logic as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will add a computed field to the `Books` model, displaying
    the publisher's country. This will allow the country to be displayed in the form
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that''s needed to find the value is simple: if `book` represents a
    book record, we can use object dot notation to get the publisher''s country using
    `book.publisher_id.country_id`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the book model in the `library_app/models/library_book.py` file by adding
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, this code adds the `publisher_country_id` field and sets the compute
    attribute with the name of the method function to use for its computation, `_compute_publisher_country`.
  prefs: []
  type: TYPE_NORMAL
- en: The function name was passed to the field as a string argument, but it may also
    be passed as a callable reference (the function identifier, without the surrounding
    quotes). In this case, we need to make sure the function is defined in the Python
    file before the field is.
  prefs: []
  type: TYPE_NORMAL
- en: The coding convention for computation method names is to append the `_compute_`
    prefix to the computed field name.
  prefs: []
  type: TYPE_NORMAL
- en: The `_compute_publisher_country` method receives a `self` record set to operate
    on and is expected to set the computed field values for all of those records.
    The code should iterate on the `self` recordset, to act on each record.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computed value is set using the usual assignment (write) operation. In
    our case, the computation is quite simple: we assign it to the current book''s
    `publisher_id.country_id` value.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The same computation method can be used to compute two or more fields. In this
    case, the method should be used on the `compute` attribute of the computed fields,
    and the computation method should assign values to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: The computation function must always assign a value to the field, or fields,
    to compute. If your computation method has `if` conditions, make sure that all
    the run paths assign values to the computed fields. Computation methods will error
    if it misses assigning a value to some computed field(s).
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 13
  prefs: []
  type: TYPE_NORMAL
- en: Odoo 13 introduced **computed writeable** fields, intended to replace the **onchange**
    mechanism in the future. Computed writeable fields have a computation logic, triggered
    by changes on the dependencies, and also allow for the value to be directly set
    by users. This mechanism will be discussed alongside **onchange** in [*Chapter
    8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227), *Business Logic – Supporting
    Business Processes*.
  prefs: []
  type: TYPE_NORMAL
- en: The `@api.depends` decorator is needed to specify the fields the computation
    depends on. It is used by the ORM to know when the computation needs to be triggered
    to update stored or cached values. One or more field names are accepted as arguments
    and dot-notation can be used to follow field relationships. In this example, the
    `publisher_country_id` field should be recomputed when `publisher_id.country_id`
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Forgetting to add the `@api.depends` decorator to a computation method, or adding
    it but failing to add all the dependency fields used for the computation, will
    prevent the computed field from being recalculated when it is supposed to. This
    can lead to hard-to-identify bugs.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the result of our work by adding the `publisher_country_id` field
    to the book form view, in the `library_app/views/library_book.xml` file. Make
    sure that the selected publishers have the country set on them when trying this
    with a web client.
  prefs: []
  type: TYPE_NORMAL
- en: Searching and writing on computed fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The computed field we created can be read, but it cannot be searched or written
    to. By default, computed field values are computed immediately when read, and
    their values are not stored in the database. That's why they can't be searched
    like regular stored fields can.
  prefs: []
  type: TYPE_NORMAL
- en: One way to work around this limitation is to have the computed values stored
    in the database by adding the `store = True` attribute. They will be recomputed
    when any of their dependencies change. Since the values are now stored, they can
    be searched just like regular fields, and a search function is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computed fields also support search and write operations without being stored
    in the database. This can be enabled by implementing specialized functions for
    these operations, alongside the `compute` function:'
  prefs: []
  type: TYPE_NORMAL
- en: A `search` function to implement the search logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `inverse` function to implement the write logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using these, our computed field declaration will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To write on a computed field, we must implement the *inverse* logic of the value
    computation. This is why the function in charge of handling the write operation
    is called `inverse`.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, setting a value on `publisher_country_id` is expected to change
    the publisher's country.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this will also change the value that's seen in all the books with
    this publisher. Regular access controls apply to these write operations, so this
    action will only be successful if the current user also has to write access to
    the partner model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This inverse function implementation uses the values set on the computed field
    to perform the actual write operations needed to make this change persistent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The original value computation copies the `book.publisher_id.country_id` value
    to the `book.publisher_country_id` field. The inverse implementation, shown previously,
    does the opposite. It reads the value set on `book.publisher_country_id` and writes
    it to the `book.publisher_id.country_id` field.
  prefs: []
  type: TYPE_NORMAL
- en: To enable search operations on a computed field, its `search` function must
    be implemented. The `search` function intercepts domain expressions operating
    on the computed field, and then replaces them with an alternative domain expression,
    using only regular stored fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `publisher_country_id` example, the actual search should be done on
    the `country_id` field of the linked `publisher_id` partner record. Here is the
    function implementation for this translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we perform a search on a model, a domain expression tuple is used as an
    argument, giving the details of the operator and the value that was used in the
    domain expression.
  prefs: []
  type: TYPE_NORMAL
- en: The `search` function is triggered whenever this computed field is found in
    conditions of a domain expression. It receives `operator` and `value` for the
    search and is expected to translate the original search element into an alternative
    domain search expression. The `country_id` field is stored in the related partner
    model, so our search implementation just alters the original search expression
    to use the `publisher_id.country_id` field instead.
  prefs: []
  type: TYPE_NORMAL
- en: For reference, domain expressions will be explained in more detail in [*Chapter
    8*](B16119_08_Final_PD_ePub.xhtml#_idTextAnchor227), *Business Logic – Supporting
    Business Processes*.
  prefs: []
  type: TYPE_NORMAL
- en: Related fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The computed field we implemented in the previous section simply copies a value
    from a related record to a field of the model. This is a common use case and is
    needed when we want to present a field in a form from a related record. The Odoo
    framework provides a shortcut for this: the **related field** feature.'
  prefs: []
  type: TYPE_NORMAL
- en: Related fields make fields that belong to a related model available in a model
    and are accessible using a *dot notation chain*. This makes them available in
    cases where dot notation can't be used, such as UI form views.
  prefs: []
  type: TYPE_NORMAL
- en: To create a related field, a field of the required type must be declared, and
    the `related` attribute must be used, with the dot notation field chain needed
    to reach the target-related field.
  prefs: []
  type: TYPE_NORMAL
- en: A `related` field can be used to get the same effect as in the previous `publisher_country_id`
    computed field example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the alternative implementation, now using a `related` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, related fields are just computed fields, and they also conveniently
    implement `search` and `inverse` methods. So, they can be searched and written
    on.
  prefs: []
  type: TYPE_NORMAL
- en: By default, related fields are read-only, so the inverse write operation won't
    be available. To enable it, set the `readonly=False` field attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous Odoo versions, related fields were writable by default, but it
    was proven to be a dangerous default since it could allow changes to setup or
    master data in cases where that was not expected to be allowed. Because of this,
    starting with Odoo 12, the `related` fields are now read-only by default: `readonly=True`.'
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth noting that `related` fields can also be stored in a database
    using `store=True`, just like any other computed field.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've learned about the features supported by Odoo fields, including
    computed fields. Another important element regarding data structures is constraints
    that enforce data quality and integrity. This is what the next section will discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Model constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, applications need to ensure data integrity and enforce validations to
    ensure that the data is complete and correct.
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL database manager supports many useful validations, such as avoiding
    duplicates or checking that values meet certain simple conditions. Odoo models
    can use the PostgreSQL constraints capabilities for this.
  prefs: []
  type: TYPE_NORMAL
- en: Some checks require more sophisticated logic and are better implemented as Python
    code. For these cases, we can use specific model methods that implement that Python
    constraint logic.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn more about these two possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: SQL model constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL constraints are added to the database table definition and are enforced
    directly by PostgreSQL. They are declared using the `_sql_constraints` class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a list of tuples, and each tuple has a format of `(name, sql, message)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` is the constraint identifier name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql` is the PostgreSQL syntax for the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message` is the error message to present to users when the constraint is not
    verified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most used SQL constraints are `UNIQUE` constraints, which are used to prevent
    data duplication, and `CHECK` constraints, which are used to test a SQL expression
    on the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will add two constraints to the `Book` model:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that there are repeated books with the same title and publication date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the publication date is not in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `library_app/models/library_book.py` file by adding the following
    code, which implements these two constraints. Usually, this goes after a section
    of the code with the field declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the PostgreSQL constraint syntax, see the official documentation
    at [https://www.postgresql.org/docs/current/ddl-constraints.html](https://www.postgresql.org/docs/current/ddl-constraints.html).
  prefs: []
  type: TYPE_NORMAL
- en: Python model constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python constraints can use arbitrary code to perform validations. The validation
    function should be decorated with `@api.constrains` and the list of fields involved
    in the check. The validation is triggered when any of those fields are modified
    and should raise an exception if the condition fails – usually, `ValidationError`.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the Library app, an obvious example is to prevent inserting incorrect
    ISBNs. We already have the logic to check that an ISBN is correct in the `_check_isbn()`
    method. We can use this in a model constraint to prevent saving incorrect data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `library_app/models/library_book.py` file by going to the top of the
    file and adding the following `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the same file, add the following code to the `Book` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Python SQL constraints are usually added before the code section containing
    the field declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of the Odoo base models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we had the chance to create new models, such as the
    **Book** model, but we also made use of the already existing models, such as the
    **Partner** model, provided by the Odoo base module. In this section, we will
    provide a short introduction to these built-in models.
  prefs: []
  type: TYPE_NORMAL
- en: The Odoo core framework includes the `base` add-on module. It provides the essential
    features needed for Odoo apps to work. It can be found in the Odoo repository,
    in the`./odoo/addons/base` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: The standard add-on modules, which provide the official apps and features made
    available with Odoo, depend on and build on top of the `base` module. The standard
    add-ons can be found in the Odoo repository, in the `./addons` subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `base` module provides two kinds of models:'
  prefs: []
  type: TYPE_NORMAL
- en: Information repository, `ir.*`, models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources, `res.*`, models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **information repository** models are used to store basic data needed for
    the Odoo framework, such as Menus, Views, Models, and Actions. The data we find
    in the **Technical** menu is usually stored in information repository models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some relevant examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ir.actions.act_window` for **Windows Actions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ir.config_parameter` for global configuration options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ir.ui.menu` for **Menu Items**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ir.ui.view` for **Views**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ir.model` for **Models**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ir.model.fields` for model **Fields**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ir.model.data` for **XML IDs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **resources** models store basic master data that can be used by any module.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most important resource models:'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.partner` for business partners, such as customers and suppliers, and addresses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.company` for company data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.country` for countries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.country.state` for states or regions inside countries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.currency` for currencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.groups` for application security groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`res.users` for application users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should provide useful context to help you understand the origin of these
    models.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the different model types, such as transient
    and abstract models, and why these are useful for user interface wizards and mixins,
    respectively. Other relevant model features include Python and SQL constraints,
    which can be used to prevent data entry errors.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the available field types, as well as all the attributes
    they support, to be able to represent the business data in the most accurate way
    possible. We also learned about relationships fields, and how to use them to create
    relationships between the different entities that are used by our applications.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we saw that models are usually based on the `models.Model` class,
    but that we can also use `models.Abstract` for reusable mixin models and `models.Transient`
    for wizards or advanced user interaction dialogs. We saw the general model attributes
    that are available, such as `_order` for default sort order and `_rec_name` for
    the default field to use for record representation.
  prefs: []
  type: TYPE_NORMAL
- en: The fields in a model define all the data they will store. We have also seen
    the non-relational field types that are available and the attributes they support.
    We also learned about the several types of relational fields – many-to-one, one-to-many,
    and many-to-many – and how they define relationships between models, including
    hierarchical parent/child relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Most fields store user input in databases, but fields can have values automatically
    computed by Python code. We saw how to implement computed fields and some advanced
    possibilities we have, such as making them writable and searchable.
  prefs: []
  type: TYPE_NORMAL
- en: Also part of model definitions is constraints, enforcing data consistency, and
    validation. These can be implemented either using PostgreSQL or Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the data model, we should populate it with some default
    and demonstration data. In the next chapter, we will learn how to use data files
    to export, import, and load data using our system.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation for models can be found at [https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html.](https://www.odoo.com/documentation/15.0/developer/reference/backend/orm.html)
  prefs: []
  type: TYPE_NORMAL
