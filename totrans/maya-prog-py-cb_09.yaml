- en: Chapter 9. Communicating with the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll be looking at the following ways to get your scripts
    talking to the outside world by sending and receiving web requests:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a web page from script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grabbing data from a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with XML data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending POST data to a web server from Maya
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to read and write data to disk, which
    can be a great way to build up toolchains and pipelines for your teams. However,
    you will almost always be working as part of a team (or working to support a team
    as a TD), which means that you'll generally want to read and write data to some
    central repository.
  prefs: []
  type: TYPE_NORMAL
- en: And in order to do it, you'll probably need to communicate with a web server
    of some kind. In this chapter, we'll be looking at how to do just that—how to
    pull data from and push data onto the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a web page from script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you find yourself writing a complex script, it can often be helpful to provide
    documentation for your script in the form of a web page. A great way to do that
    is to include an easy way to show that page to the user. In this example, we'll
    create a simple script that will open a given URL in the user's default web browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run the script, and you'll see the specified URL appear in your default browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All we''re really doing here is using the `showHelp` command. It''s a bit misleading,
    as the `showHelp` command is also used to show Maya''s documentation for a specific
    command. However, as long as you specify the absolute flag to true, you can pass
    in a full path to the URL you would like to open:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are a few deprecated commands that you might come across that
    no longer work. In older versions of Maya, there was a `webBrowser` command that
    would allow for the inclusion of web content in script-based UIs. Unfortunately,
    that command has been removed, necessitating the use of `showHelp` to open content
    in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's highly likely that if you have a script that is complex enough to warrant
    a page of documentation, it also includes (possibly complex) UI. Rather than just
    having a button to show help, it's easy enough to implement a proper "Help" menu,
    as is commonly seen in other programs.
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/B04657_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is easily done with the menu and `menuItem` commands. Here''s a full listing
    to produce the preceding result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a window, just as we've done in previous examples. Then,
    we add a new menu with the `menu` command. The label is the text that will appear
    as the top of the menu, and specifying `helpMenu=True` ensures that this particular
    menu will be treated as a help menu (displayed to the far right of all menu options).
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a menu, we can add menu items to it. This is a lot like adding
    a button, in that we specify a label and a command that will be executed when
    the item is selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the new `menuItem` will be added to the most recent menu. To add menu
    items in different menus (to have both a "File" and a "Help" category, for example),
    be sure to call `cmds.menu` to start a new menu before adding additional items.
  prefs: []
  type: TYPE_NORMAL
- en: Grabbing data from a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll look at the simplest possible way to grab data from a
    given URL, using Python's built-in `urllib2` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ll want to make sure that you have a URL to grab. You can use any website
    you like, but for the sake of testing, it can be helpful to have a minimal page
    served on your local machine. If you want to do that, start by creating a simple
    html file, something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve done that, you''ll want to have that served as a page on your
    own machine. Python offers a really simple way to do just that. Open a command
    line (terminal on a mac) and navigate to wherever you saved your html file. From
    there, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause Python to serve the contents of the current directory as a
    website on localhost. The -m flag tells python to include a given module (in this
    case, `SimpleHTTPServer`) when running the interpreter. It''s the equivalent of
    using the following at the beginning of a Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the contents of the current directory will be served on port 8000,
    meaning that you can access the contents by opening a browser and going to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that you''ve created an `index.htm` (or html) file somewhere and
    that you''ve run `python -m SimpleHTTPServer` from that same directory. If you''ve
    done that, running the preceding script should output something like the following
    followed by the entire contents of your `index.htm` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we have to make sure to import the `urllib2` library in addition
    to our standard `maya.cmds`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us access to the commands we''ll need to load data from a given
    URL. We start by setting up a variable to hold the URL we''re loading, and printing
    a message indicating that we''re about to attempt to load it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to actually attempt to load the data. When loading data from
    a URL, it's important that you never assume that the URL is accessible. There
    are any number of things that can go wrong either on the server side (the server
    could be down or not responding to requests) or on the client side (the indicated
    URL could be blocked by a firewall, the Ethernet cable could be unplugged, and
    so on) any one of which would prevent the URL from loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'As such, we''ll wrap our attempt to fetch the URL in a try/catch block. If
    anything goes wrong in the loading of the URL, we''ll print out the error and
    return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we manage to actually retrieve the URL in question, we''re left with a "file-like
    object". This means that we can use all the functions that we would use when opening
    a file, such as `read()` to get the contents. The specific file-like objects returned
    by `urllib2.urlopen` also implement a couple of additional functions, which we
    make use of here. First, we get the HTTP code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went as expected, that *should* print out "200", indicating a
    successful request. Next, we retrieve some information about the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the information in the headers (server type, time of last
    modification, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we'll get the actual data at the web address with the `read()` function.
    Calling `read()` without specifying a number of bytes to read will grab the entire
    contents of the file (or in this case, the website).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we loaded the entirety of a website. While you generally wouldn't
    want to do that for most websites, it makes a lot of sense when requesting data
    from a web API, where the result will typically be a small(ish) amount of formatted
    data (either XML or JSON).
  prefs: []
  type: TYPE_NORMAL
- en: If what you want is to just display a full website (rather than retrieving data
    via an API), see the previous example where we use the `showHelp` command to display
    a given website.
  prefs: []
  type: TYPE_NORMAL
- en: Working with XML data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When grabbing data from a web server, it's highly likely that you'll receive
    it in a structured format of one kind or another, with XML and JSON being the
    most common options. In this example, we'll look at how to make use of data served
    up as XML.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use this example, you''ll need to have an XML file available on a server
    somewhere. The easiest way to do this is to create a file locally on your machine,
    then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From the same directory as the file, provide access to it via localhost. Here''s
    the file that I''ll be using as the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The file is pretty simple, but will allow us to look at iterating over XML nodes
    and parsing both attributes and elements.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to point the URL at the proper location for your XML file, and run the
    script; you should see a cube and a sphere appear.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First off, we add another library `xml.etree.ElementTree` to our imports and
    give it a shorter name to make it easier to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a simple function to create either a sphere or a cube of a
    given size and move it to a given position. This is pretty straightforward and
    probably seems quite familiar at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we grab the data from the specified URL, as we have in the previous examples
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to move onto the meat of the example—the actual XML parsing.
    First off, we parse the data we received from the Web into an XML tree with the
    `xml.etree.ElementTree` parse command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The parse command can accept either a string or a file-like object. Because
    we receive a file-like object from the `urllib2.urlopen` command, we can pass
    the result straight in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve done that, we have a proper tree of XML nodes, and we''re ready
    to start traversing the tree and parsing our data. To get started parsing, we
    first need to grab the root node, which we do with the `getroot()` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The actual parsing will be a bit different, depending on the nature of your
    XML schema. In this case, we have some number of <object> nodes, each of which
    containing a "type" attribute and several child nodes for the *x*, *y*, and *z*
    positions as well as the size.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll want to start by iterating through all of the child nodes of the root
    to give us all of the object nodes. The `ElementTree` library makes that really
    easy—we can simply use a for loop to get all the child nodes. For each object
    we find, we''ll start by setting variables for object type, position, and size
    to default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, our local `item` variable represents a node that is a direct child
    of the root. Given the structure of our example XML document, that means we have
    an <object> node. First off, we'll want to examine the `type` attribute to see
    if we should be making a cube or a sphere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attributes of a given node are stored as a dictionary in the node''s `attrib`
    attribute. We can index into that to grab the value, and if we find that it''s
    equal to `sphere`, we set our `objectType` to `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to look at the children of our current node to get the *x*, *y*,
    *z* positions and the size. We''ll use the same trick as before, iterating over
    the children of a given node with a for loop. For each child we find, we want
    to know two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value contained within the tag, as a float.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name of a given node can be accessed via its tag property, and any text
    contained within it can be grabbed via the text property. For our purposes, we
    want to ensure floating point values, so we''ll be sure to cast the text to a
    float. Putting all that together gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left is to make use of the tag that we found and set the appropriate
    variable to our `tagValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Having done all of that, we pass our data into our `makeObjectAt` function to
    produce the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Working with JSON data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll look at the other format you're likely to want to use—JSON.
    JSON can model data just as well as XML, but is considerably more compact. As
    such, it has been growing in popularity in recent years and has all but replaced
    XML for many tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, you'll want to make sure that you have a file being served by a
    server that you have access to, but this time you'll want to make sure that it's
    JSON data. Once again, we'll create some number of cubes and spheres, but this
    time, we'll specify the data as an array of JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full listing for the example document is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The square brackets indicate an array, and the curly brackets indicate an object.
    Within an object, there can be any number of named values. Arrays and objects
    can also be nested, allowing us to have an array *of* objects, as we do here.
    For more information on how to structure JSON data, be sure to have a look at
    [http://www.json.org/](http://www.json.org/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new script and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have a JSON file formatted in the same way as the example
    and that it's accessible via a URL, localhost, or otherwise. Run the script, and
    you should have some number of cubes and spheres appear on your scene.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the script is the same as our previous example of parsing XML data.
    The first difference is that we change the import statements slightly, removing
    the `xml.etree.ElementTree` library and adding the JSON library instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we have the same function as was used in the XML example to create
    either a sphere or a cube of a given size and move it to a specified position.
    I'll omit the details because it's identical to the function from the previous
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the function responsible for actually loading the data, we start off grabbing
    the URL as we have in the previous examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The new functionality comes in the form of a call to the `loads()` or "load
    string" function, which will load data from a string into a proper JSON object.
    By passing the result of `webData.read()` into that function, we will be left
    with the full contents of our file into an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Once we've done that, we'll want to step through the entries in the data. The
    result of parsing JSON in Python will translate arrays into lists and objects
    into dictionaries. Because our JSON data was in the form of an array of objects,
    we are left with a list of dictionaries after loading.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start our parsing by stepping through the array and grabbing the data for
    each object. As in the XML example, we set up placeholder variables with default
    values for `objectType`, `objectSize`, and `position`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the loop, we''ll grab the values for each of our attributes by first
    checking to see if they''re present in the current dictionary and, if so, set
    the value of the corresponding variable. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that we cast `objectSize` to a float. That's necessary, since we divide
    it by 2 in our `makeObjectAt()` function. If we happen to have an integer input,
    dividing it by 2 would result in an integer result, possibly giving us a bad value
    (if we pass in 1, we would get 0 instead of 0.5, for example).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we pass in the retrieved values to our `makeObjectAt()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll probably note that JSON data is a bit easier to work with than XML—with
    JSON, we end up with standard Python lists and dictionaries, whereas XML requires
    that we walk up and down a series of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: That's true not only in Python, but in many other languages as well. If you
    happen to be working in JavaScript, there's often no actual parsing required,
    as JSON is a subset of JavaScript itself (JSON is short for JavaScript Object
    Notation).
  prefs: []
  type: TYPE_NORMAL
- en: There are still good reasons to use XML, but if all that's needed is a way to
    move structured data from one place to another, JSON tends to be easier to parse,
    and just as easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're new to JSON, it's a good idea to have a look at the official docs,
    available at [http://www.json.org/](http://www.json.org/). You'll find that for
    all its flexibility, it's actually a pretty simple format.
  prefs: []
  type: TYPE_NORMAL
- en: Sending POST data to a web server from Maya
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything we've looked at involves pulling data from the Web into Maya.
    In this example, we'll look at how to send data to a server from within Maya.
  prefs: []
  type: TYPE_NORMAL
- en: There are two main ways to send data to a server—GET and POST. Using GET involves
    adding arguments onto a URL directly. It has the benefit of being able to be bookmarked
    (since the arguments are in the URL), but has limitations on the amount of data
    that can be sent. POST requests are more flexible and will usually be what you
    want to use to build tool pipelines in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll implement two different examples of sending POST data.
    First, we'll look at sending summary data about a scene (the name of the file
    and the number of objects). Then, we'll look at using POST requests to send a
    selected model to a server as an OBJ file. This could form the backbone of an
    asset management pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the requests library for this example, so make sure to install
    it. For details on how to do that, visit [http://docs.python-requests.org/en/master/user/install/#install](http://docs.python-requests.org/en/master/user/install/#install).
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the most of this example, you'll need to have a server that
    can respond to GET and POST requests. Setting that up is beyond the scope of this
    book, and there are any number of ways to go about it (and any number of languages
    you can use to do so). Luckily, there's an easy way to test your requests in the
    form of [http://httpbin.org/](http://httpbin.org/). The httpbin site can be used
    to test a wide range of HTTP requests, and will return whatever data is passed
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since we're going to be sending actual model data, you'll need to have
    at least one polygonal mesh in your scene.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Select a polygonal mesh and run the script. Both of the examples will send
    data to httpbin and output the result that gets parroted back from the site. You
    should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start off the script with importing everything we need—`maya.cmds` as always,
    plus the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`- requests`: This provides nicer tools for working with requests and sending
    data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- os`: This is needed to work with paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`- json`: This is needed to parse the response that we''ll get from httpbin.org'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also set a global variable to hold the URL that we''ll be sending data to,
    in this case, `httpbin.org/post`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to implement our first example—sending some summary data about
    our scene. In this case, we'll send the name of the scene and the number of objects
    it contains. To get the name of the current scene, we use the file command in
    query mode, and setting the `sceneName` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give us the full path to the current scene, which we''ll pass into
    `os.path.basename` to retrieve just the filename itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll get the total number of objects in the scene by using the `ls`
    command and setting the geometry flag to true. The length of that list will give
    us the total number of (geometric) objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have all of the data that we want to send. In order to prep
    it for sending, we''ll need to create a new dictionary and create an entry for
    each value we want to send:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, sending the data is very straightforward, thanks to the requests
    library. All that we need to do is to call `requests.post` with our desired URL,
    and with our data variable passed in as the value for the JSON option. We''ll
    be sure to save the result to a variable so that we can examine the response from
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve sent the request, we''ll want to examine whether or not it was
    successful. To do that, we examine the `status_code` attribute of the result,
    checking it against 200\. If the request went through, we parse the actual response
    into a JSON object and print the data attribute. Otherwise, we display an error,
    as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `httpbin.org/post` will echo back any data sent to it, we should see
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the data was successfully sent to the server and returned
    to us as a response.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at a slightly more involved example. We'll create a function
    that will save a selected polygonal object as an OBJ, then send that file to a
    server as POST data. We'll build that up from a few smaller functions, starting
    with one to test whether or not the current selection is a polygon mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to what we've done in previous examples; we get the current
    selection and start by checking to see if at least one object is selected. If
    that succeeds, we use the `listRelatives` command to retrieve the shape node associated
    with the selected object and test its node type. If it's anything other than "mesh"
    (indicating a polygonal object), we return false. If we pass through both checks,
    we return true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement a function to save the currently selected object as an OBJ.
    Since exporting OBJs requires that the OBJ export plugin be loaded, we start our
    function with a call to `loadPlugin` to make sure that it is. See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We pass in `objExport` as the plugin to load, and we set the quiet flag to true,
    which will prevent Maya from displaying a message if the plugin was already loaded.
  prefs: []
  type: TYPE_NORMAL
- en: To export the model, we'll need to use the `file` command, but before doing
    that, we'll want to make sure that the file exists. That's needed in order to
    avoid a quirk of the file command, which can cause it to error out if saving to
    a file that doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by using the `file` command in the query mode to see if a file of
    the given name exists. If not, we create one by opening it in write mode, then
    immediately closing it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to actually write out the OBJ file, using the file command
    once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the full path to where we want to save the file. After
    that, we set `exportSelected` to true to indicate the main operation that should
    be performed, in this case, exporting only the currently selected object. Next,
    we specify that we want to save it as an OBJ, and we set force to true to avoid
    prompting the user for a file overwrite confirmation. Finally, we set the options
    for the OBJ export as a single string, with semicolons to separate out each of
    the parts. In this case, we'll turn everything off except `normals`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created both of our helper functions, we''re ready to move
    to the function to put them together and send the model to a server. We start
    by running the check for polygonal geometry and throwing an error if it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, we build up the path to save the file by first using
    the workspace command to retrieve the current workspace location and using `os.path.join`
    to append the desired filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With the full path, we can save out the model using our `saveSelectionAsOBJ()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to send the file. In order to send files via POST data, we'll
    need to send a "multipart" request in order to send the file data as its own part.
    Luckily for us, the requests library handles all of that for us. It ends up looking
    quite similar to our previous example of sending simple POST data, in that we
    start by setting up our data in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have only a single entry, named `file`, which we set equal
    to the output of the `file open` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve done that, all we need to do to actually send the file is to call
    `requests.post` with the desired URL, and pass in our `modelFile` dictionary as
    the value for the `files` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with the simple example, we''ll check the `result.status_code` and,
    if we find 200, parse the response as JSON and output some of it, though in this
    case, we output the `files` attribute instead of data. We have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we sent data and files in two separate requests for the sake of the examples,
    you can certainly send both at the same time. For example, if you wanted to build
    an asset management pipeline for an MMO, you might want to send the models to
    a central server, along with some metadata, such as which textures they use or
    what their in-game attributes are.
  prefs: []
  type: TYPE_NORMAL
