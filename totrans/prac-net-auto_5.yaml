- en: Ansible for Network Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see the use of a popular network automation tool called
    **Ansible**. This chapter will guide you through the basics of Ansible, including
    installation and basic configurations, and will give examples of how to perform
    tasks related to network automation from Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: This will cover various terminologies and concepts used in Ansible, examples,
    executions using Ansible, some use cases like using Ansible to create configurations
    for various devices based upon the templates, and how to fetch some information
    about the managed nodes from Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce readers to:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview and installation of Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding programming concepts of Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case scenarios for Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible overview and terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible is an automation tool or platform, which is available as open source,
    and used to configure devices such as routers, switches, and various types of
    servers. Ansible''s primary purpose is to configure three main type of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration management**:This is used to fetch and push configs on various
    devices that we call as inventory in Ansible. Based upon the type of inventory,
    Ansible is capable of pushing in bulk specific or full configs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application deployment**: In server scenarios, many a time we need to bulk
    deploy some specific applications or patches. Ansible takes care of that as well
    as bulk uploading patches or applications on the server, installing on them, and
    even configuring the applications of a particular task. Ansible can also take
    care of customizing settings based upon the devices in the inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task automation**:This is a feature of Ansible that performs a certain written
    task on a single device or a group of devices. The tasks can be written and Ansible
    can be configured to run those tasks once or on a periodic basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another powerful feature of Ansible is IT or infrastructure orchestration. To
    explain this in detail, let us say we need to code upgrade certain routers or
    network devices. Ansible can perform sequential steps to isolate the particular
    router, push code, update code, and then move on to next router based upon the
    return values of the previous result or task.
  prefs: []
  type: TYPE_NORMAL
- en: Basic requirements of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is very easy to install and set up. It works on a controller and managed
    nodes model. In this model, Ansible is installed on a controller, which is a Linux
    server, and has access to all the inventory or nodes that we want to manage. As
    we have seen, Ansible is supported on Linux (there is a beta version out there
    for the Windows controller but it's not yet fully supported), and it relies on
    the SSH protocol to communicate with nodes. So, apart from the configuration of
    the controller, we need to ensure the nodes that are going to be managed are SSH
    capable.
  prefs: []
  type: TYPE_NORMAL
- en: There is an additional requirement of Python being installed on the managed
    nodes, since multiple Ansible modules are written in Python and Ansible copies
    the module locally to the client and executes it from the node itself. In servers
    running Linux this is already met, however, in network devices such as Cisco IOS,
    this might not be a possibility as Python is not available on the Cisco node.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this limitation, there is something called a **raw module** that
    executes raw commands, like `show version` to fetch the output from the Cisco
    device. This might not help a lot, but there is another way in which Ansible can
    be made to run its modules on the server itself, rather than executing those modules
    on the client (or managed node). This ensures that modules use the resources of
    the Ansible server (including Python), and they can call the SSH or HTTP APIs
    of Cisco vendors to perform tasks that are configured locally on the server. Even
    SNMP can also be used for devices that don't have a good set of APIs (such as
    Cisco IOS), to perform our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen earlier, SNMP can be used in both read and write mode, so using
    Ansible and running the module locally, we can even configure old IOS devices
    with the assistance of the SNMP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Ansible controller (the main component that manages the nodes), is supported
    on multiple flavors of Linux, but it cannot be installed on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: For managed nodes, the core requirement is anything with Python 2.6 and above.
    Additionally, since Ansible uses SSH to communicate with managed nodes, the node
    must be able to be accessed from SSH. For any file transfers, the default is **SSH
    File Transfer Protocol** (**SFTP**), but there is always an option to use `scp`
    for the default file transfer protocol. This being said, as mentioned earlier,
    if Python installation is not possible, then we would be using the raw modules
    of Ansible running from the server itself.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to controller machine installation, Python 2 (2.6 or above) needs
    to be installed. In our case, we are using Ubuntu as our OS, hence our focus would
    be on working with Ansible using Ubuntu as the underlying OS. A way of installing
    Ansible is to use the **Advanced Packaging Tool** (**APT)**in Ubuntu. The following
    commands will configure the **Personal Package Archives** (**PPA**) and install
    Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the basic commands, in the same order they are needed for the installation
    of Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case Ansible is already installed. Here is a sample output that we get
    if we run the command `sudo apt-get install ansible` again. In this case if there
    is a new update available, Ansible will upgrade to the latest version, otherwise
    it would exit out of the command stating that we already have the newest version
    as shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb447213-d5c2-4b9b-aa1b-cb2b5d1f0cf6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way of installing Ansible is by using our well known Python library
    installation command `pip`. The command for this will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is done, here is the information about the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd2d10a2-4cc7-4e6f-b815-e4dc5a5da243.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `hosts` file is the inventory file where we add our managed nodes to be
    controlled by Ansible. `ansible.cfg` is the actual configuration file used to
    tweak Ansible parameters. Once the installation is done, we need to add some nodes
    in the `hosts` file. In our case as a fresh installation, we need to add our localhost
    (`127.0.0.1`). This node is accessible from SSH with the username `abhishek` and
    password `abhishek`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample output of our `/etc/hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16bde62c-2b2b-48eb-9992-18fa4d9ca766.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The line `127.0.0.1 ansible_connection=ssh ansible_user=abhishek ansible_ssh_pass=abhishek`
    is where we specify the parameters that are needed to access this system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use any text editor (in our case we are using nano or the vi editor)
    to add or modify the changes to these files. To modify the `hosts` file, we use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to verify the accessibility/reachability of the nodes that
    we added into the `hosts`file, which can be done using the `ansible all -m ping` command
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5482103c-42cc-4457-94fa-95b4de76817a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the previous screenshot, the command `ansible all -m ping`
    pings all the configured nodes in the `hosts` file and responds with a ping. Additionally,
    in the same output, if we use the command `ansible all -m ping --ask-pass`, this
    asks for a password to be accessed for that particular node. In our case, we give
    the password, and then we get the response back. Now, you might ask: *I am performing
    a simple ping, so what is the need for SSH now in this case?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add the global DNS server (`4.2.2.2`) in our `hosts` file and then test
    it as shown in the following screenshot. As mentioned earlier, we invoke the nano
    editor using `sudo nano /etc/ansible/hosts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac3d933a-f7c7-45d5-a3b3-5c594f8c81e9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, we try to perform the same ping test again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53c964ee-87e5-45c1-ba1e-2be7637bbb15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What do we see now? Even though I can easily `ping 4.2.2.2` from my machine,
    Ansible returns the value of `false`, since Ansible first tries to log in to the
    device using SSH and then tries to ping the IP. In this case, `4.2.2.2` SSH is
    not open, and we get a failure message for that specific IP address from Ansible.
    Additionally, we can group the managed objects under a specific name, such as
    `routers`, `switches`, `servers`, or whatever name we like in the `hosts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We group our current IPs (localhost and `4.2.2.2`) under a new group, `myrouters`.
    We go back and modify the file `/etc/ansible/hosts` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7c34eda-17f5-41cc-b2a9-f4f2c18e3b06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the addition of the `myrouters` group in the file. Once we save it,
    let''s now use the group to perform a ping task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ab16961-f8e7-44fe-b046-59b6b9581fd8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see now, instead of pinging all, we just ping the group `myrouters`, which
    in our case is the loopback IP and `4.2.2.2`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, results will be the same as earlier, but now we have the added flexibility
    of ensuring that we perform our tasks based upon either individual nodes or a
    group of nodes under a specific name.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to ad hoc commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ad hoc** commands in Ansible are used to perform tasks or operations that
    are needed on an ad hoc basis or only once based upon the requirement. In other
    words, these are tasks that a user wants to be performed on the fly but doesn’t
    want to be saved for later use. A quick example of an use case for Ansible ad
    hoc commands could be to quickly fetch the version information of the group of
    managed nodes for some other use as a one time task. As this is a quick information
    need and does not need to be repeated, we would use an ad hoc task to perform
    this request.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we proceed with the chapter, there will be some additional switches (extra
    options that we pass to Ansible commands), that would be introduced based upon
    the requirements. Invoking the `ansible` command only will produce all the values
    that can be passed as options or parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/454c0042-2085-4353-8e49-d7e5c25029d4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some examples of ad-hoc commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us say we need to ping the same set of devices, but now in parallel (the
    default is sequential but to make tasks faster, we would use parallelism in our
    approach):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want use a separate `username` instead of the default configured one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to enhance the session (or use `sudo` or `root`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For a separate username, we use the `--become-user switch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For executing a specific command, we use the `-a`option (Let us say we want
    to fetch the `show version` of the routers in `myrouters` list in a parallel method
    ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `5` is the default value for number of parallel threads, but to change this
    value again, we can modify it in the Ansible configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is to copy a file from source to destination. Let us say we
    need to copy a file from the current source to multiple servers that are under,
    let''s say, the `servers` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to start the `httpd` on the web servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In reverse, if we want to stop the `httpd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As another important example to look at, let us say we want to run a long running
    command like `show tech-support`, but do not want to wait for it in the foreground.
    We can specify a timeout (600 seconds in our case) for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This would return a `jobid` that can be referred later on for the update. Once
    we have the `jobid`, we can check the status of that particular `jobid` using
    the command given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an additional command that provides all the information about a particular
    node that Ansible can fetch and work upon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output to view the facts on the local machine (localhost) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80a11e09-4efb-4d5a-989f-98b6949e92b2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another ad hoc command that is commonly used is the `shell` command. This is
    used to control the overall OS, or shell, or root scenarios. Let us see an example
    to reboot the managed nodes in the `servers` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to shut down the same set of servers instead of reboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can ensure that using the ad hoc task we can quickly perform basic
    tasks on individual or groups of managed nodes to quickly get results.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playbooks are simply a set of instructions that we create for Ansible to configure,
    deploy, and manage the nodes. These act as guidelines, using Ansible to perform
    a certain set of tasks on individuals or groups. Think of Ansible as your drawing
    book, playbooks as your colors, and managed nodes as the picture. Taking that
    example, playbooks ensure what color needs to be added to which part of the picture,
    and the Ansible framework performs the task of executing the playbook for the
    managed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks are written in a basic text language referred to as **YAML Ain't Markup
    Langu****age** (**YAML**). Playbooks consist of configurations to perform certain
    tasks on managed nodes. Additionally, playbooks are used to defined a workflow
    in which, based upon conditions (like different type of devices or different type
    of OS), specific tasks can be executed, and validations can be performed based
    upon the results retrieved from task executions. It also combines multiple tasks
    (and configuration steps in each task) and can execute those tasks sequentially,
    or in parallel against selective or all managed nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good information about YAML can be referenced here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.getgrav.org/advanced/yaml](https://learn.getgrav.org/advanced/yaml)'
  prefs: []
  type: TYPE_NORMAL
- en: At a basic level a playbook consists of multiple **plays** in a list. Each play
    is written to perform certain Ansible tasks (or a collection of commands to be
    executed) on a certain group of managed nodes (for example `myrouters`, or `servers`).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Ansible website, here is a sample playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, there are certain sections that we need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hosts`: This lists the group or managed nodes (in this case `webservers`),
    or individual nodes separated by a space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`vars`: This is the declaration section where we can define variables, similar
    to how we define them in any other programming language. In this case `http_port:
    80` means the value of `80` is assigned to the `http_port` variable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tasks`: This is the actual declaration section on what task needs to be performed
    on the group (or managed nodes) that was defined under the `- hosts` section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`name`: This denotes the remark line used to identify a particular task.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using this example, let us create our playbook to ping our managed nodes in
    earlier examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the config, we type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the editor, we copy and paste the previous code, and save it. For execution
    , we can use the `--check` parameter. This ensures that on the remote systems,
    if there is a change intended to be performed in the playbook, it will be simulated
    locally and not actually executed on the remote systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for execution of the preceding given command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be0c2000-33c0-4fbc-944e-e33ffe1a8869.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see in the preceding output, a simulation of our playbook `checkme.yml`
    was performed and the results were displayed in the `PLAY RECAP` section.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is if we want to call specific tasks based upon our initial
    results. In Ansible, we use `handlers` to perform that task.  In a play, we create
    a task that can perform `notify` actions based upon any changes from that task.
    These actions are triggered after all the tasks are completed through a handler.
    In other words, after all the tasks in a play are completed, only then will the
    `handlers` condition be triggered (for example, rebooting a server if all the
    configuration tasks are completed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Handlers are simply another type of tasks, but referenced by a globally unique
    name and executed only when called by `notify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding example, the task is executed on `myrouters`,
    which calls `notify` to perform a handler task. The `-name` in `handlers` depicts
    the handler name that the task will be calling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible is case-sensitive (for example: two variables named `x` and `X` will
    be different).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the notified handler is called, the `shell: uptime` command will run the
    `uptime` command on the remote shell and fetch the output to be displayed. The
    `listen` command under a `handlers` section is also an alternate or a more generic
    way of calling the specific handler. In this case, the `notify` section can call
    the specific handler under `handlers` , which matches the `listen` declaration
    with the `notify` declaration  (for example, in our case `notify : "show device
    uptime"` will call the specific handler that is listening to the command `show
    device uptime`, which in this case is defined by `-name` as show variables) ,
    instead of calling the  `- name` declaration under `handlers` that we currently
    see in config.'
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible playbook (`showenv.yml` in this case) needs to be invoked with a
    `-v` switch to see the `verbose` output where verbose output is an output where
    we can see all the activities as they are happening by execution rather than just
    displaying only the final result).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output without the `-v` command(verbose output is not enabled) is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/d76689bc-28a2-4f10-9f0f-9a2950368ac8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The output with the `-v` command (verbose output is enabled) is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/7bfe0a44-f4f5-410c-85b8-51a1d4376e04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, notice the output of the `uptime` command in playbook
    execution (from the preceding screenshot, `changed: [127.0.0.1] => {"changed":
    true, "cmd": "uptime", "delta":"`) . The verbose output states the output and
    the command that was executed (in this case `uptime`), with the values fetched
    for the managed nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, if we have created multiple playbooks and want to run them in
    a master playbook, we can import the created playbooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we explicitly import certain tasks from a `.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the configuration inside `main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can call handlers from another `.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the configuration of `main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Additionally when we define variables in Ansible, there are some considerations
    that we need to keep in mind. Variables cannot have special characters (except
    underscores) or spaces in between two characters or words and should not start
    with a number or special character.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`check_me` and `check123` are good variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check-me`, `check me`, and `check.me` are invalid variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In YAML, we can create dictionaries using the colon approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To reference or retrieve any values from this dictionary created with the name
    `myname`, we would specify command like: `myname['name']` or  `myname.name`**.**
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ansible facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw earlier, we can gather facts about a managed node using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as we get the values back (called **facts**), we can refer to those system
    variables. Each system variable will hold a unique value based upon each of the
    managed node that was called under the `hosts` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The system variables can be called using the `{{variable name}}`, but in a playbook,
    they need to be referenced with double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example where we get the value of `hostname` in our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the playbook to fetch the hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/989916fc-e94d-4b15-bdd9-c0c06247db6e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, in the playbook (in the preceding code),  we referred to the
    `{{inventory_hostname}}` and `{{ansible_nodename}}` variables, which results in
    the output in the `msg` section: `System 127.0.0.1 has host hostname as ubuntutest`.
    Using the same playbook configuration , we can use all or any of the other facts
    that were retrieved by replacing the system variables in the configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to get additional information from inside the facts, we can refer
    to the specific values within square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ ansible_eth0.ipv4.address }}` or `{{ ansible_eth0["ipv4"]["address"] }}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass the variable using the command line to the playbook, as in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution command to execute the playbook with passing variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command with variables provided during command line execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c914523-202e-426d-8227-bf1ec8ef724d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see, the value of `myrouters`was passed to `hosts` and the value of `Abhishek`was
    passed to the `user` variable. As we see in output of the playbook execution,
    the `msg` variable output contains the value of the `user` variable and the IP
    address of the host(s) configured in the `myrouters` group (In this case, the
    single host is part of this group with the IP address `127.0.0.1`).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times when we want to execute certain tasks based upon the conditions.
    `when` statement is used to determine those conditions and execute the specified
    task if the condition evaluates to true. Let us take an example to execute the
    `uptime` command, if we pass the parameter clock to the variable clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Execution from command line**: With and incorrect value `clock123` being
    passed to `clock` variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the execution with incorrect values provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb9088bc-4481-41b0-821d-5a5323f1ee6a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we see in preceding output, the message `This is NOT a clock condition`
    is executed based upon the value that we passed. Similarly, if we pass the clock
    variable shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output with correct variable values passed from command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fce7b487-e622-46e8-85e2-58a5c28b945a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The message `This is clock condition` is now executed based upon the parameter
    passed. Looking at another example, in a similar way, we can ensure that based
    upon a certain fact, we can take some action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As we see, the condition is triggered on the `ansible_distribution` fact. If
    the response is Ubuntu, then the first condition is executed, otherwise, based
    upon `Red Hat`, the other condition is executed. Additionally, we are also validating
    if the clock value is `clock`, when the playbook is being called from command
    line with `clock` as the variable passed to the playbook. In the previous code,
    both the conditions need to be evaluated to true if we want to get that particular
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can loop for repetitive operations using `with_items`**. **Let us see an
    example where we parse the list and print the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the playbook execution using the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb971bc1-f997-4bce-8c72-1a99b659f49d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the preceding screenshot, the iteration prints the value of
    `Server` plus the item value in the list for each item in the list. Similarly,
    for an integer iteration we can perform a loop using the `with_sequence`command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, let us say we want to print values skipping 2 (even numbers from
    0 to 10), the same `with_sequence` command will be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we also need to pick any random value for performing specific task.
    The following sample code picks a random value from the 4 options available (in
    our case, `Choice Random 1` till `Choice Random 4`) and displays it using `msg`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This will pick any random value from the list from the given options under the
    `with_random_choice` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Python API with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible code can be called using Python, using the Ansible API. Ansible has
    released version 2.0 of its API for better integration with programming languages.
    One important aspect to note is that Ansible has extended its capability to support
    development using Python, but it also suggests on its website that, based upon
    its own discretion, it can also stop supporting the API (creating or even bug
    fixing its current API version) framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example of creating a play with the task of seeing the username
    from our earlier inventory of `myrouters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code for displaying the username from managed nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''#call libraries''`: These are used to initialize the available Ansible API
    libraries. Some of the important ones are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`from ansible.parsing.dataloader import DataLoader`: This is used for loading
    or parsing a YAML or JSON format file or value if called'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from ansible.vars import VariableManager`: This is used for inventory file
    location'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from ansible.inventory.manager import InventoryManager`: This is used for
    inventory initialization'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from ansible.playbook.play import Play`: This is used for configuring a play'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from ansible.executor.task_queue_manager import TaskQueueManager`: This is
    used for actual execution of the configured play'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`# initialize objects`: This section initializes the various components, such
    as the root user, `become_user` (if any) and other parameters required to run
    the play.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`# create inventory`: This is where we specify the actual inventory location
    and initialize it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`# create play with task`:  This is where we create the task in a similar way
    that we create the `.yml` file. In this case, it is to show the hostname for all
    nodes in the `myrouters` section of the inventory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`# execution`:This is the execution of the play that we created using the `run()`
    method of the task.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13f8d60b-01d5-417f-82c7-377d1eed0484.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, after invoking the Python file, we got the hostname of the localhost
    defined under the `myrouters` inventory section in the `hosts` file (`/etc/ansible/hosts`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating network configuration templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are now familiar with the basics of Ansible, let us look at an example
    in which we generate configs ready to be deployed for some routers. To start with,
    we need to understand roles in Ansible. **Roles** are used to create a file structure
    for Ansible playbooks. Based upon roles, we can group similar data. Sharing the
    roles with others would mean we share the entire defined file structure for a
    common set of content. A typical role file structure would contain the main folder
    and the content folder, and under the content folder, we would have `templates`,
    `vars`, and `tasks` folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the hierarchy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Main directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -Roles
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: -Routers
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: -Templates
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: -Vars
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: -Tasks
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under each of the templates, vars, or tasks folders, if we call that specific
    role, a file named `main.yml` is searched automatically and any configs in that
    file are taken into consideration for that particular role. Using the details
    of hierarchy as previously mentioned , in our test machine (running Ubuntu) here
    is how our file structure looks in the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbbcab9e-9683-484b-973b-b4df1e3f7dd4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we see, under the `rtrconfig` folder, we have defined the folders as per
    Ansible standards. Once we create the folder hierarchy, the next step is to configure/create
    the files under each of the sections, based upon our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, as we will be using a router template to generate the configs,
    we create a template and put it in the `roles/routers/templates` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Router config template is as follows (used as a generic router template to
    generate router configs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the template, `{{item.hostname}}` and `{{logging_server}}`
    are two values that we would replace while creating the actual config. As this
    is a Jinja template, we would save this template as `somename.j2` (in our case, `routers.j2`).
    The next step is to define the variable values.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we saw earlier, we need to ensure that the `logging_server` variable has
    already been defined a value. This will be in the `roles/routers/vars` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We save this file as `main.yml` in the `vars` folder, which will be picked by
    default while executing the playbook for the variable value declarations. Once
    we have the definitions and template in place, the next step is to define the
    actual task that needs to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: This will be done in the `roles/routers/tasks` folder and again saved as `main.yml` for
    auto discovery during the execution of that specific role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the config for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the config for the task, we call the template that we created (in this case,
    `routers.j2`), and provide a destination folder where the config files will be
    saved (in this case, `/home/abhishek/{{item.hostname}}.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: A specific point to note here is that `{{item.hostname}}` will resolve to each
    of the hostnames that we have provided using the `with_items` loop. As a result,
    the filename that will be generated will be each item defined in the `with_items`
    loop (in our case, `myrouter1.txt` and `myrouter2.txt`).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, the `with_items` will loop with each value, with the
    hostname variable value being changed with each iteration. Once we have the template,
    vars, and task created, we will call the role in our main playbook and get it
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main playbook config is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here we just call the hosts (which is localhost in our case since we want to
    get this executed locally), and call the role that needs to be executed in the
    playbook (in our case, `routers`). We save it as any name with a `.yml` extension
    (in our case, `makeconfig.yml`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final validation to ensure all `.yml` files are created in respective folders
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, here is the detailed file structure, as we now see the files under
    the `rtrconfig` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3591c748-27ae-46b1-844f-f96a3220fcc7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To generate the config for routers , we execute the `makeconfig.yml` playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21dc946b-6154-4f5c-b40f-35bc02cf3f21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once executed successfully, we should have two files (`myrouter1.txt` and `myrouter2.txt`)
    in the `/home/abhishek` folder with the generated config:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f7019e1f-025f-441f-acf8-5ca2fb2d8ad4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the content from one of the generated files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/187efb7c-51bc-49a7-af5a-4a275c9ad11e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, now we have a generated config, using the template, with the
    values replaced for the hostname and `logging _server` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The config is now generated and ready to be pushed on those particular routers
    (which were part of `main.yml` under `roles/routers/tasks`), and in a similar
    way, we can generate configs with various roles and multiple devices in each role,
    such as switches, routers, load balancers, and so on with each role containing
    specific information, such as variables, templates, and tasks relevant to that
    role.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what Ansible is, its installation, and basic usage
    of Ansible. This chapter also introduced concepts and terminology used in Ansible,
    with reference to how to create playbooks, tasks, and other basic functions in
    Ansible. We also got familar with ad-hoc commands and understand the concept of
    facts and their usage in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using Jinja templates we understood how to create a full configuration
    using templates with reference to device/role specific information using roles
    in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to call miscellaneous other aspects of
    automation, such as using Splunk for syslog collection and fetching information
    from Python, working with basic automation on BGP, UC integration examples, and
    other relevant examples that can be used for ready reference when creating automation
    scripts.
  prefs: []
  type: TYPE_NORMAL
