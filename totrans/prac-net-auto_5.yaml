- en: Ansible for Network Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible用于网络自动化
- en: In this chapter, we will see the use of a popular network automation tool called
    **Ansible**. This chapter will guide you through the basics of Ansible, including
    installation and basic configurations, and will give examples of how to perform
    tasks related to network automation from Ansible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到使用一个流行的网络自动化工具**Ansible**。本章将指导您了解Ansible的基础知识，包括安装和基本配置，并给出如何从Ansible执行与网络自动化相关的任务的示例。
- en: This will cover various terminologies and concepts used in Ansible, examples,
    executions using Ansible, some use cases like using Ansible to create configurations
    for various devices based upon the templates, and how to fetch some information
    about the managed nodes from Ansible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涵盖Ansible中使用的各种术语和概念，例如示例、使用Ansible的执行，以及如何使用Ansible模板为各种设备创建配置，以及如何从Ansible获取有关受管理节点的某些信息。
- en: 'This chapter will introduce readers to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向读者介绍：
- en: Overview and installation of Ansible
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible的概述和安装
- en: Understanding programming concepts of Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Ansible的编程概念
- en: Playbooks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbooks
- en: Use case scenarios for Ansible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible的使用场景
- en: Ansible overview and terminology
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible概述和术语
- en: 'Ansible is an automation tool or platform, which is available as open source,
    and used to configure devices such as routers, switches, and various types of
    servers. Ansible''s primary purpose is to configure three main type of tasks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个自动化工具或平台，它作为开源软件提供，用于配置诸如路由器、交换机和各种类型的服务器等设备。Ansible的主要目的是配置三种主要类型的任务：
- en: '**Configuration management**:This is used to fetch and push configs on various
    devices that we call as inventory in Ansible. Based upon the type of inventory,
    Ansible is capable of pushing in bulk specific or full configs.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置管理**：这用于从我们称为Ansible中的清单的各种设备中获取和推送配置。根据清单的类型，Ansible能够批量推送特定的或完整的配置。'
- en: '**Application deployment**: In server scenarios, many a time we need to bulk
    deploy some specific applications or patches. Ansible takes care of that as well
    as bulk uploading patches or applications on the server, installing on them, and
    even configuring the applications of a particular task. Ansible can also take
    care of customizing settings based upon the devices in the inventory.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用部署**：在服务器场景中，很多时候我们需要批量部署一些特定的应用程序或补丁。Ansible也负责在服务器上批量上传补丁或应用程序，安装它们，甚至配置特定任务的程序。Ansible还可以根据清单中的设备自定义设置。'
- en: '**Task automation**:This is a feature of Ansible that performs a certain written
    task on a single device or a group of devices. The tasks can be written and Ansible
    can be configured to run those tasks once or on a periodic basis.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务自动化**：这是Ansible的一个功能，它在单个设备或一组设备上执行某些书写的任务。这些任务可以编写，并且Ansible可以配置为一次性或定期运行这些任务。'
- en: Another powerful feature of Ansible is IT or infrastructure orchestration. To
    explain this in detail, let us say we need to code upgrade certain routers or
    network devices. Ansible can perform sequential steps to isolate the particular
    router, push code, update code, and then move on to next router based upon the
    return values of the previous result or task.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的另一个强大功能是IT或基础设施编排。为了详细解释这一点，让我们假设我们需要升级某些路由器或网络设备。Ansible可以执行一系列步骤来隔离特定的路由器，推送代码，更新代码，然后根据前一个结果或任务的返回值移动到下一个路由器。
- en: Basic requirements of Ansible
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的基本要求
- en: Ansible is very easy to install and set up. It works on a controller and managed
    nodes model. In this model, Ansible is installed on a controller, which is a Linux
    server, and has access to all the inventory or nodes that we want to manage. As
    we have seen, Ansible is supported on Linux (there is a beta version out there
    for the Windows controller but it's not yet fully supported), and it relies on
    the SSH protocol to communicate with nodes. So, apart from the configuration of
    the controller, we need to ensure the nodes that are going to be managed are SSH
    capable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible非常易于安装和设置。它基于控制器和受管理节点模型工作。在这个模型中，Ansible安装在控制器上，控制器是一个Linux服务器，可以访问我们想要管理的所有清单或节点。正如我们所看到的，Ansible支持Linux（目前有一个Windows控制器的beta版本，但尚未完全支持），它依赖于SSH协议与节点通信。因此，除了控制器的配置之外，我们还需要确保将要管理的节点具有SSH能力。
- en: There is an additional requirement of Python being installed on the managed
    nodes, since multiple Ansible modules are written in Python and Ansible copies
    the module locally to the client and executes it from the node itself. In servers
    running Linux this is already met, however, in network devices such as Cisco IOS,
    this might not be a possibility as Python is not available on the Cisco node.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在托管节点上安装 Python 是一个额外的要求，因为多个 Ansible 模块是用 Python 编写的，并且 Ansible 会将模块本地复制到客户端并在节点本身上执行它。在运行
    Linux 的服务器上，这已经满足，然而，在网络设备如 Cisco IOS 上，这可能不是一个可能性，因为 Cisco 节点上没有 Python。
- en: To overcome this limitation, there is something called a **raw module** that
    executes raw commands, like `show version` to fetch the output from the Cisco
    device. This might not help a lot, but there is another way in which Ansible can
    be made to run its modules on the server itself, rather than executing those modules
    on the client (or managed node). This ensures that modules use the resources of
    the Ansible server (including Python), and they can call the SSH or HTTP APIs
    of Cisco vendors to perform tasks that are configured locally on the server. Even
    SNMP can also be used for devices that don't have a good set of APIs (such as
    Cisco IOS), to perform our tasks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这种限制，有一种称为**原始模块**的东西可以执行原始命令，例如 `show version` 从 Cisco 设备获取输出。这可能帮助不大，但还有一种方法可以使
    Ansible 在服务器本身上运行其模块，而不是在客户端（或托管节点）上执行这些模块。这确保了模块使用 Ansible 服务器的资源（包括 Python），并且它们可以调用
    Cisco 供应商的 SSH 或 HTTP API 来执行在服务器上本地配置的任务。甚至对于没有良好 API 集的设备（如 Cisco IOS），也可以使用
    SNMP 来执行我们的任务。
- en: As we have seen earlier, SNMP can be used in both read and write mode, so using
    Ansible and running the module locally, we can even configure old IOS devices
    with the assistance of the SNMP protocol.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，SNMP 可以在读取和写入模式下使用，因此使用 Ansible 并在本地运行模块，我们甚至可以使用 SNMP 协议的帮助来配置旧的 IOS
    设备。
- en: Installation of Ansible
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Ansible
- en: An Ansible controller (the main component that manages the nodes), is supported
    on multiple flavors of Linux, but it cannot be installed on Windows.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 控制器（管理节点的主要组件）支持多种 Linux 版本，但不能安装在 Windows 上。
- en: For managed nodes, the core requirement is anything with Python 2.6 and above.
    Additionally, since Ansible uses SSH to communicate with managed nodes, the node
    must be able to be accessed from SSH. For any file transfers, the default is **SSH
    File Transfer Protocol** (**SFTP**), but there is always an option to use `scp`
    for the default file transfer protocol. This being said, as mentioned earlier,
    if Python installation is not possible, then we would be using the raw modules
    of Ansible running from the server itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于托管节点，核心要求是任何具有 Python 2.6 及以上版本的东西。此外，由于 Ansible 使用 SSH 与托管节点通信，节点必须能够通过 SSH
    访问。对于任何文件传输，默认是**SSH 文件传输协议**（**SFTP**），但始终有使用 `scp` 作为默认文件传输协议的选项。话虽如此，如前所述，如果无法安装
    Python，那么我们将使用从服务器本身运行的 Ansible 的原始模块。
- en: Going back to controller machine installation, Python 2 (2.6 or above) needs
    to be installed. In our case, we are using Ubuntu as our OS, hence our focus would
    be on working with Ansible using Ubuntu as the underlying OS. A way of installing
    Ansible is to use the **Advanced Packaging Tool** (**APT)**in Ubuntu. The following
    commands will configure the **Personal Package Archives** (**PPA**) and install
    Ansible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 回到控制器机器的安装，需要安装 Python 2（2.6 或更高版本）。在我们的案例中，我们使用 Ubuntu 作为我们的操作系统，因此我们的重点将放在使用
    Ubuntu 作为底层操作系统的情况下与 Ansible 一起工作。安装 Ansible 的方法之一是使用 Ubuntu 中的**高级打包工具**（**APT**）。以下命令将配置**个人软件包存档**（**PPA**）并安装
    Ansible。
- en: 'Here are the basic commands, in the same order they are needed for the installation
    of Ansible:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是基本命令，按照它们在安装 Ansible 时所需的顺序：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our case Ansible is already installed. Here is a sample output that we get
    if we run the command `sudo apt-get install ansible` again. In this case if there
    is a new update available, Ansible will upgrade to the latest version, otherwise
    it would exit out of the command stating that we already have the newest version
    as shown in the following screenshot):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，Ansible 已经安装。以下是我们再次运行命令 `sudo apt-get install ansible` 时得到的示例输出。在这种情况下，如果有一个新的更新可用，Ansible
    将升级到最新版本，否则它将退出命令，表示我们已经有最新版本，如下面的截图所示）：
- en: '![](img/fb447213-d5c2-4b9b-aa1b-cb2b5d1f0cf6.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fb447213-d5c2-4b9b-aa1b-cb2b5d1f0cf6.jpg)'
- en: 'Another way of installing Ansible is by using our well known Python library
    installation command `pip`. The command for this will be:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Ansible 的另一种方式是使用我们熟知的 Python 库安装命令 `pip`。这个命令将是：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the installation is done, here is the information about the folder:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，以下是文件夹的信息：
- en: '![](img/bd2d10a2-4cc7-4e6f-b815-e4dc5a5da243.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd2d10a2-4cc7-4e6f-b815-e4dc5a5da243.jpg)'
- en: The `hosts` file is the inventory file where we add our managed nodes to be
    controlled by Ansible. `ansible.cfg` is the actual configuration file used to
    tweak Ansible parameters. Once the installation is done, we need to add some nodes
    in the `hosts` file. In our case as a fresh installation, we need to add our localhost
    (`127.0.0.1`). This node is accessible from SSH with the username `abhishek` and
    password `abhishek`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`hosts` 文件是我们添加要由 Ansible 控制的受管理节点的清单文件。`ansible.cfg` 是实际用于调整 Ansible 参数的配置文件。一旦安装完成，我们需要在
    `hosts` 文件中添加一些节点。在我们的例子中，作为一个全新的安装，我们需要添加我们的本地主机（`127.0.0.1`）。此节点可以通过 SSH 使用用户名
    `abhishek` 和密码 `abhishek` 访问。'
- en: 'Here is a sample output of our `/etc/hosts` file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们 `/etc/hosts` 文件的示例输出：
- en: '![](img/16bde62c-2b2b-48eb-9992-18fa4d9ca766.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16bde62c-2b2b-48eb-9992-18fa4d9ca766.jpg)'
- en: The line `127.0.0.1 ansible_connection=ssh ansible_user=abhishek ansible_ssh_pass=abhishek`
    is where we specify the parameters that are needed to access this system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这行 `127.0.0.1 ansible_connection=ssh ansible_user=abhishek ansible_ssh_pass=abhishek`
    是我们指定访问此系统所需参数的地方。
- en: 'We can use any text editor (in our case we are using nano or the vi editor)
    to add or modify the changes to these files. To modify the `hosts` file, we use
    the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何文本编辑器（在我们的例子中我们使用 nano 或 vi 编辑器）来添加或修改这些文件的更改。要修改 `hosts` 文件，我们使用以下命令：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to verify the accessibility/reachability of the nodes that
    we added into the `hosts`file, which can be done using the `ansible all -m ping` command
    as shown in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是验证我们添加到 `hosts` 文件中的节点的可访问性/可达性，可以使用 `ansible all -m ping` 命令来完成，如下截图所示：
- en: '![](img/5482103c-42cc-4457-94fa-95b4de76817a.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5482103c-42cc-4457-94fa-95b4de76817a.jpg)'
- en: 'As we can see in the previous screenshot, the command `ansible all -m ping`
    pings all the configured nodes in the `hosts` file and responds with a ping. Additionally,
    in the same output, if we use the command `ansible all -m ping --ask-pass`, this
    asks for a password to be accessed for that particular node. In our case, we give
    the password, and then we get the response back. Now, you might ask: *I am performing
    a simple ping, so what is the need for SSH now in this case?*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个截图所示，命令 `ansible all -m ping` 对 `hosts` 文件中配置的所有节点进行 ping 操作，并响应 ping。此外，在相同的输出中，如果我们使用命令
    `ansible all -m ping --ask-pass`，这将要求输入密码以访问该特定节点。在我们的例子中，我们输入密码，然后得到响应。现在，你可能会问：*我正在执行一个简单的
    ping，那么在这种情况下为什么还需要 SSH 呢？*
- en: 'Let us add the global DNS server (`4.2.2.2`) in our `hosts` file and then test
    it as shown in the following screenshot. As mentioned earlier, we invoke the nano
    editor using `sudo nano /etc/ansible/hosts`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `hosts` 文件中添加全局 DNS 服务器（`4.2.2.2`），然后按照以下截图所示进行测试。如前所述，我们使用 `sudo nano
    /etc/ansible/hosts` 来调用 nano 编辑器：
- en: '![](img/ac3d933a-f7c7-45d5-a3b3-5c594f8c81e9.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac3d933a-f7c7-45d5-a3b3-5c594f8c81e9.jpg)'
- en: 'Once done, we try to perform the same ping test again:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们再次尝试执行相同的 ping 测试：
- en: '![](img/53c964ee-87e5-45c1-ba1e-2be7637bbb15.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53c964ee-87e5-45c1-ba1e-2be7637bbb15.jpg)'
- en: What do we see now? Even though I can easily `ping 4.2.2.2` from my machine,
    Ansible returns the value of `false`, since Ansible first tries to log in to the
    device using SSH and then tries to ping the IP. In this case, `4.2.2.2` SSH is
    not open, and we get a failure message for that specific IP address from Ansible.
    Additionally, we can group the managed objects under a specific name, such as
    `routers`, `switches`, `servers`, or whatever name we like in the `hosts` file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在看到了什么？尽管我可以轻松地从我的机器上 ping `4.2.2.2`，但 Ansible 返回 `false` 的值，因为 Ansible 首先尝试使用
    SSH 登录到设备，然后尝试 ping IP。在这种情况下，`4.2.2.2` 的 SSH 没有打开，我们从 Ansible 那里得到一个针对该特定 IP
    地址的失败消息。此外，我们可以在 `hosts` 文件中按特定名称分组受管理的对象，例如 `routers`、`switches`、`servers` 或我们喜欢的任何名称。
- en: 'Consider the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: 'We group our current IPs (localhost and `4.2.2.2`) under a new group, `myrouters`.
    We go back and modify the file `/etc/ansible/hosts` for this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将当前的 IP（本地主机和 `4.2.2.2`）分组到一个新的组中，`myrouters`。我们返回并修改 `/etc/ansible/hosts`
    文件：
- en: '![](img/e7c34eda-17f5-41cc-b2a9-f4f2c18e3b06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7c34eda-17f5-41cc-b2a9-f4f2c18e3b06.jpg)'
- en: 'Notice the addition of the `myrouters` group in the file. Once we save it,
    let''s now use the group to perform a ping task:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件中添加了 `myrouters` 组。一旦我们保存它，现在让我们使用这个组来执行ping任务：
- en: '![](img/2ab16961-f8e7-44fe-b046-59b6b9581fd8.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2ab16961-f8e7-44fe-b046-59b6b9581fd8.jpg)'
- en: As we see now, instead of pinging all, we just ping the group `myrouters`, which
    in our case is the loopback IP and `4.2.2.2`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们不再ping所有设备，而是ping `myrouters` 组，在我们的例子中是环回IP和 `4.2.2.2`。
- en: Of course, results will be the same as earlier, but now we have the added flexibility
    of ensuring that we perform our tasks based upon either individual nodes or a
    group of nodes under a specific name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，结果将与之前相同，但现在我们增加了灵活性，确保我们根据单个节点或特定名称下的节点组执行任务。
- en: Introduction to ad hoc commands
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时命令简介
- en: '**Ad hoc** commands in Ansible are used to perform tasks or operations that
    are needed on an ad hoc basis or only once based upon the requirement. In other
    words, these are tasks that a user wants to be performed on the fly but doesn’t
    want to be saved for later use. A quick example of an use case for Ansible ad
    hoc commands could be to quickly fetch the version information of the group of
    managed nodes for some other use as a one time task. As this is a quick information
    need and does not need to be repeated, we would use an ad hoc task to perform
    this request.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**临时**命令在Ansible中用于执行基于临时需求或仅一次需求的任务。换句话说，这些是用户希望即时执行但不想保存以供以后使用的任务。一个Ansible临时命令的快速用例可能是快速获取一组受管理节点的版本信息，作为一次性任务用于其他用途。由于这是一个快速的信息需求且不需要重复，我们会使用临时任务来执行此请求。'
- en: 'As we proceed with the chapter, there will be some additional switches (extra
    options that we pass to Ansible commands), that would be introduced based upon
    the requirements. Invoking the `ansible` command only will produce all the values
    that can be passed as options or parameters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的进行，将会有一些额外的开关（我们传递给Ansible命令的额外选项），这些开关将根据需求引入。仅调用 `ansible` 命令将产生所有可以作为选项或参数传递的值：
- en: '![](img/454c0042-2085-4353-8e49-d7e5c25029d4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/454c0042-2085-4353-8e49-d7e5c25029d4.jpg)'
- en: 'Some examples of ad-hoc commands are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一些临时命令的示例如下：
- en: 'Let us say we need to ping the same set of devices, but now in parallel (the
    default is sequential but to make tasks faster, we would use parallelism in our
    approach):'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们需要ping同一组设备，但现在是在并行方式下（默认是顺序执行，但为了使任务更快，我们会使用并行方法）：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want use a separate `username` instead of the default configured one:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要使用一个单独的 `username` 而不是默认配置的用户：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we want to enhance the session (or use `sudo` or `root`):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要增强会话（或使用 `sudo` 或 `root`）：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For a separate username, we use the `--become-user switch`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单独的用户名，我们使用 `--become-user` 开关。
- en: 'For executing a specific command, we use the `-a`option (Let us say we want
    to fetch the `show version` of the routers in `myrouters` list in a parallel method
    ):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于执行特定的命令，我们使用 `-a` 选项（假设我们想要以并行方式获取 `myrouters` 列表中路由器的 `show version` 信息）：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `5` is the default value for number of parallel threads, but to change this
    value again, we can modify it in the Ansible configuration file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`5` 是并行线程数的默认值，但为了再次更改此值，我们可以在Ansible配置文件中修改它。'
- en: 'Another example is to copy a file from source to destination. Let us say we
    need to copy a file from the current source to multiple servers that are under,
    let''s say, the `servers` group:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个例子是将文件从源复制到目标。假设我们需要将文件从当前源复制到多个服务器，这些服务器属于，比如说，`servers` 组：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We want to start the `httpd` on the web servers:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要在Web服务器上启动 `httpd`：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In reverse, if we want to stop the `httpd`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，如果我们想要停止 `httpd`：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As another important example to look at, let us say we want to run a long running
    command like `show tech-support`, but do not want to wait for it in the foreground.
    We can specify a timeout (600 seconds in our case) for this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为另一个重要的例子，让我们假设我们想要运行一个长时间运行的命令，例如 `show tech-support`，但我们不想在前台等待。我们可以为这个命令指定一个超时时间（在我们的例子中是600秒）：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This would return a `jobid` that can be referred later on for the update. Once
    we have the `jobid`, we can check the status of that particular `jobid` using
    the command given as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个 `jobid`，稍后可以用来更新。一旦我们有了 `jobid`，我们可以使用以下命令检查该特定 `jobid` 的状态：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There is an additional command that provides all the information about a particular
    node that Ansible can fetch and work upon:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个额外的命令可以提供Ansible可以获取并工作的特定节点的所有信息：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output to view the facts on the local machine (localhost) is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 查看本地机器（localhost）上事实的输出如下：
- en: '![](img/80a11e09-4efb-4d5a-989f-98b6949e92b2.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/80a11e09-4efb-4d5a-989f-98b6949e92b2.jpg)'
- en: 'Another ad hoc command that is commonly used is the `shell` command. This is
    used to control the overall OS, or shell, or root scenarios. Let us see an example
    to reboot the managed nodes in the `servers` group:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个常用的ad hoc命令是`shell`命令。它用于控制整体操作系统、shell或root场景。让我们看一个示例来重启`servers`组中的受管理节点：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we want to shut down the same set of servers instead of reboot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要关闭同一组服务器而不是重启：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This way, we can ensure that using the ad hoc task we can quickly perform basic
    tasks on individual or groups of managed nodes to quickly get results.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以确保使用ad hoc任务，我们可以快速对单个或多个受管理节点执行基本任务，以快速获得结果。
- en: Ansible playbooks
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible playbooks
- en: Playbooks are simply a set of instructions that we create for Ansible to configure,
    deploy, and manage the nodes. These act as guidelines, using Ansible to perform
    a certain set of tasks on individuals or groups. Think of Ansible as your drawing
    book, playbooks as your colors, and managed nodes as the picture. Taking that
    example, playbooks ensure what color needs to be added to which part of the picture,
    and the Ansible framework performs the task of executing the playbook for the
    managed nodes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks是我们为Ansible创建的一组指令，用于配置、部署和管理节点。这些作为指南，使用Ansible在个人或组上执行一组特定任务。将Ansible视为你的画册，playbooks视为你的颜色，受管理节点视为图片。以这个例子为例，playbooks确保需要将哪种颜色添加到图片的哪个部分，而Ansible框架执行为受管理节点执行playbook的任务。
- en: Playbooks are written in a basic text language referred to as **YAML Ain't Markup
    Langu****age** (**YAML**). Playbooks consist of configurations to perform certain
    tasks on managed nodes. Additionally, playbooks are used to defined a workflow
    in which, based upon conditions (like different type of devices or different type
    of OS), specific tasks can be executed, and validations can be performed based
    upon the results retrieved from task executions. It also combines multiple tasks
    (and configuration steps in each task) and can execute those tasks sequentially,
    or in parallel against selective or all managed nodes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Playbooks是用一种称为**YAML Ain't Markup Language**（**YAML**）的基本文本语言编写的。Playbooks包含执行在受管理节点上特定任务的配置。此外，playbooks还用于定义一个工作流程，其中根据条件（如不同类型的设备或不同类型的操作系统），可以执行特定任务，并根据从任务执行中检索到的结果进行验证。它还结合了多个任务（以及每个任务中的配置步骤），可以按顺序执行这些任务，或者针对选定的或所有受管理节点并行执行。
- en: 'Good information about YAML can be referenced here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 关于YAML的良好信息可以在此处参考：
- en: '[https://learn.getgrav.org/advanced/yaml](https://learn.getgrav.org/advanced/yaml)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://learn.getgrav.org/advanced/yaml](https://learn.getgrav.org/advanced/yaml)'
- en: At a basic level a playbook consists of multiple **plays** in a list. Each play
    is written to perform certain Ansible tasks (or a collection of commands to be
    executed) on a certain group of managed nodes (for example `myrouters`, or `servers`).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本层面上，playbook由列表中的多个**plays**组成。每个play都是为了在特定的受管理节点组上执行某些Ansible任务（或要执行的命令集合）而编写的（例如`myrouters`或`servers`）。
- en: 'From the Ansible website, here is a sample playbook:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ansible网站，以下是一个示例playbook：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, there are certain sections that we need to understand:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一些部分我们需要理解：
- en: '`hosts`: This lists the group or managed nodes (in this case `webservers`),
    or individual nodes separated by a space.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hosts`：此列表包含组或受管理节点（在本例中为`webservers`），或由空格分隔的单独节点。'
- en: '`vars`: This is the declaration section where we can define variables, similar
    to how we define them in any other programming language. In this case `http_port:
    80` means the value of `80` is assigned to the `http_port` variable.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vars`：这是声明部分，我们可以在此处定义变量，类似于我们在任何其他编程语言中定义它们的方式。在这种情况下`http_port: 80`表示将`80`的值分配给`http_port`变量。'
- en: '`tasks`: This is the actual declaration section on what task needs to be performed
    on the group (or managed nodes) that was defined under the `- hosts` section.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tasks`：这是实际声明部分，用于在`- hosts`部分定义的组（或受管理节点）上执行的任务。'
- en: '`name`: This denotes the remark line used to identify a particular task.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`name`：这表示用于识别特定任务的注释行。'
- en: 'Using this example, let us create our playbook to ping our managed nodes in
    earlier examples:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此示例，让我们创建我们的playbook来ping早期示例中的受管理节点：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To create the config, we type:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建配置，我们输入：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the editor, we copy and paste the previous code, and save it. For execution
    , we can use the `--check` parameter. This ensures that on the remote systems,
    if there is a change intended to be performed in the playbook, it will be simulated
    locally and not actually executed on the remote systems:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中，我们复制并粘贴之前的代码，并保存它。对于执行，我们可以使用 `--check` 参数。这确保在远程系统上，如果要在 playbook 中执行更改，它将在本地模拟而不是在远程系统上实际执行：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output for execution of the preceding given command is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述给定命令的输出如下：
- en: '![](img/be0c2000-33c0-4fbc-944e-e33ffe1a8869.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/be0c2000-33c0-4fbc-944e-e33ffe1a8869.jpg)'
- en: As we see in the preceding output, a simulation of our playbook `checkme.yml`
    was performed and the results were displayed in the `PLAY RECAP` section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个输出所示，我们的 playbook `checkme.yml` 的模拟执行完成，并在 `PLAY RECAP` 部分显示了结果。
- en: Another example is if we want to call specific tasks based upon our initial
    results. In Ansible, we use `handlers` to perform that task.  In a play, we create
    a task that can perform `notify` actions based upon any changes from that task.
    These actions are triggered after all the tasks are completed through a handler.
    In other words, after all the tasks in a play are completed, only then will the
    `handlers` condition be triggered (for example, rebooting a server if all the
    configuration tasks are completed).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是如果我们想根据我们的初始结果调用特定的任务。在 Ansible 中，我们使用 `handlers` 来执行该任务。在一个 play 中，我们创建一个可以基于任何从该任务中产生的变化执行
    `notify` 动作的任务。这些动作在所有任务通过处理程序完成后被触发。换句话说，只有在 play 中的所有任务都完成后，`handlers` 条件才会被触发（例如，如果所有配置任务都已完成，则重新启动服务器）。
- en: 'Handlers are simply another type of tasks, but referenced by a globally unique
    name and executed only when called by `notify`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序只是另一种类型的任务，但通过全局唯一名称引用，并且仅在由 `notify` 调用时执行：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see in the preceding example, the task is executed on `myrouters`,
    which calls `notify` to perform a handler task. The `-name` in `handlers` depicts
    the handler name that the task will be calling.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一个示例中所示，任务是在 `myrouters` 上执行的，它调用 `notify` 来执行处理程序任务。`handlers` 中的 `-name`
    描述了任务将要调用的处理程序名称。
- en: 'Ansible is case-sensitive (for example: two variables named `x` and `X` will
    be different).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是区分大小写的（例如：两个名为 `x` 和 `X` 的变量将是不同的）。
- en: 'Once the notified handler is called, the `shell: uptime` command will run the
    `uptime` command on the remote shell and fetch the output to be displayed. The
    `listen` command under a `handlers` section is also an alternate or a more generic
    way of calling the specific handler. In this case, the `notify` section can call
    the specific handler under `handlers` , which matches the `listen` declaration
    with the `notify` declaration  (for example, in our case `notify : "show device
    uptime"` will call the specific handler that is listening to the command `show
    device uptime`, which in this case is defined by `-name` as show variables) ,
    instead of calling the  `- name` declaration under `handlers` that we currently
    see in config.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦调用通知处理程序，`shell: uptime` 命令将在远程 shell 上运行 `uptime` 命令并获取要显示的输出。在 `handlers`
    部分下的 `listen` 命令也是一个调用特定处理程序的替代或更通用的方式。在这种情况下，`notify` 部分可以调用 `handlers` 下的特定处理程序，这与
    `listen` 声明与 `notify` 声明相匹配（例如，在我们的案例中 `notify : "show device uptime"` 将调用监听 `show
    device uptime` 命令的特定处理程序，在这种情况下是由 `-name` 作为显示变量定义的），而不是调用我们在配置中目前看到的 `handlers`
    下的 `-name` 声明。'
- en: The Ansible playbook (`showenv.yml` in this case) needs to be invoked with a
    `-v` switch to see the `verbose` output where verbose output is an output where
    we can see all the activities as they are happening by execution rather than just
    displaying only the final result).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook（在本例中为 `showenv.yml`）需要使用 `-v` 开关来调用以查看 `verbose` 输出，其中 verbose
    输出是一种输出，我们可以通过执行看到所有活动，而不仅仅是显示最终结果）。
- en: 'The output without the `-v` command(verbose output is not enabled) is as follows:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有使用 `-v` 命令（verbose 输出未启用）的输出如下：
- en: '![](img/d76689bc-28a2-4f10-9f0f-9a2950368ac8.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d76689bc-28a2-4f10-9f0f-9a2950368ac8.jpg)'
- en: 'The output with the `-v` command (verbose output is enabled) is as follows:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-v` 命令（verbose 输出已启用）的输出如下：
- en: '![](img/7bfe0a44-f4f5-410c-85b8-51a1d4376e04.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7bfe0a44-f4f5-410c-85b8-51a1d4376e04.jpg)'
- en: 'In the preceding screenshot, notice the output of the `uptime` command in playbook
    execution (from the preceding screenshot, `changed: [127.0.0.1] => {"changed":
    true, "cmd": "uptime", "delta":"`) . The verbose output states the output and
    the command that was executed (in this case `uptime`), with the values fetched
    for the managed nodes.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的屏幕截图中，注意 playbook 执行中 `uptime` 命令的输出（从前面的屏幕截图中，`changed: [127.0.0.1] =>
    {"changed": true, "cmd": "uptime", "delta":"`)。详细的输出显示了执行命令（在这种情况下为 `uptime`）以及从管理节点获取的值。'
- en: 'In many cases, if we have created multiple playbooks and want to run them in
    a master playbook, we can import the created playbooks:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，如果我们创建了多个 playbook 并想在主 playbook 中运行它们，我们可以导入创建的 playbook：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we explicitly import certain tasks from a `.yml` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们明确从 `.yml` 文件中导入某些任务：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Looking at the configuration inside `main.yml`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 查看内部 `main.yml` 的配置：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, we can call handlers from another `.yml` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以从另一个 `.yml` 文件中调用处理器：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the configuration of `main.yml`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.yml` 的配置中：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Additionally when we define variables in Ansible, there are some considerations
    that we need to keep in mind. Variables cannot have special characters (except
    underscores) or spaces in between two characters or words and should not start
    with a number or special character.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们定义 Ansible 变量时，有一些考虑因素我们需要记住。变量不能包含特殊字符（除了下划线）或两个字符或单词之间的空格，并且不应以数字或特殊字符开头。
- en: 'For example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`check_me` and `check123` are good variables'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_me` 和 `check123` 是有效的变量'
- en: '`check-me`, `check me`, and `check.me` are invalid variables'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check-me`、`check me` 和 `check.me` 是无效变量'
- en: 'In YAML, we can create dictionaries using the colon approach:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 YAML 中，我们可以使用冒号方法创建字典：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To reference or retrieve any values from this dictionary created with the name
    `myname`, we would specify command like: `myname['name']` or  `myname.name`**.**
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用或检索由名称 `myname` 创建的字典中的任何值，我们可以指定如下命令：`myname['name']` 或 `myname.name`**。**
- en: Working with Ansible facts
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 事实
- en: 'As we saw earlier, we can gather facts about a managed node using the following
    command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们可以使用以下命令收集关于管理节点的事实：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, as we get the values back (called **facts**), we can refer to those system
    variables. Each system variable will hold a unique value based upon each of the
    managed node that was called under the `hosts` section:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们获取回值（称为 **事实**）时，我们可以引用这些系统变量。每个系统变量将根据在 `hosts` 部分下调用的每个管理节点持有唯一值：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The system variables can be called using the `{{variable name}}`, but in a playbook,
    they need to be referenced with double quotes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `{{variable name}}` 调用系统变量，但在 playbook 中需要用双引号引用。
- en: 'Let us see an example where we get the value of `hostname` in our playbook:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个示例，其中我们在 playbook 中获取 `hostname` 的值：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the playbook to fetch the hostname:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 获取主机名的 playbook 输出：
- en: '![](img/989916fc-e94d-4b15-bdd9-c0c06247db6e.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/989916fc-e94d-4b15-bdd9-c0c06247db6e.jpg)'
- en: 'As we can see, in the playbook (in the preceding code),  we referred to the
    `{{inventory_hostname}}` and `{{ansible_nodename}}` variables, which results in
    the output in the `msg` section: `System 127.0.0.1 has host hostname as ubuntutest`.
    Using the same playbook configuration , we can use all or any of the other facts
    that were retrieved by replacing the system variables in the configuration.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在 playbook（在前面代码中），我们引用了 `{{inventory_hostname}}` 和 `{{ansible_nodename}}`
    变量，这导致在 `msg` 部分的输出：`System 127.0.0.1 has host hostname as ubuntutest`。使用相同的 playbook
    配置，我们可以使用所有或任何其他通过替换配置中的系统变量检索到的事实。
- en: 'If we want to get additional information from inside the facts, we can refer
    to the specific values within square brackets:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从事实中获取更多信息，我们可以引用方括号内的特定值：
- en: '`{{ ansible_eth0.ipv4.address }}` or `{{ ansible_eth0["ipv4"]["address"] }}`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{ ansible_eth0.ipv4.address }}` 或 `{{ ansible_eth0["ipv4"]["address"] }}`。'
- en: 'We can also pass the variable using the command line to the playbook, as in
    this example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过命令行将变量传递给 playbook，如下例所示：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The execution command to execute the playbook with passing variables:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 执行包含变量的 playbook 的命令：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the command with variables provided during command line execution:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行执行期间提供变量时命令的输出：
- en: '![](img/8c914523-202e-426d-8227-bf1ec8ef724d.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c914523-202e-426d-8227-bf1ec8ef724d.jpg)'
- en: As we see, the value of `myrouters`was passed to `hosts` and the value of `Abhishek`was
    passed to the `user` variable. As we see in output of the playbook execution,
    the `msg` variable output contains the value of the `user` variable and the IP
    address of the host(s) configured in the `myrouters` group (In this case, the
    single host is part of this group with the IP address `127.0.0.1`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`myrouters`的值被传递给`hosts`，`Abhishek`的值被传递给`user`变量。正如我们在 playbook 执行的输出中看到的，`msg`变量输出包含`user`变量的值和配置在`myrouters`组中的主机（在本例中，单个主机是这个组的一部分，IP
    地址为`127.0.0.1`）。
- en: Ansible conditions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 条件
- en: 'There are times when we want to execute certain tasks based upon the conditions.
    `when` statement is used to determine those conditions and execute the specified
    task if the condition evaluates to true. Let us take an example to execute the
    `uptime` command, if we pass the parameter clock to the variable clock:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们想要根据条件执行某些任务。`when`语句用于确定这些条件，如果条件评估为真，则执行指定的任务。让我们用一个例子来执行`uptime`命令，如果我们传递参数`clock`到变量`clock`：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Execution from command line**: With and incorrect value `clock123` being
    passed to `clock` variable):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**从命令行执行**：将错误的值`clock123`传递给`clock`变量：'
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the execution with incorrect values provided:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 提供错误值后的执行输出：
- en: '![](img/cb9088bc-4481-41b0-821d-5a5323f1ee6a.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cb9088bc-4481-41b0-821d-5a5323f1ee6a.jpg)'
- en: 'As we see in preceding output, the message `This is NOT a clock condition`
    is executed based upon the value that we passed. Similarly, if we pass the clock
    variable shown as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的输出中看到的，消息`This is NOT a clock condition`是根据我们传递的值执行的。同样，如果我们传递如下所示的时钟变量：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output with correct variable values passed from command line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行传递正确变量值后的输出：
- en: '![](img/fce7b487-e622-46e8-85e2-58a5c28b945a.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fce7b487-e622-46e8-85e2-58a5c28b945a.jpg)'
- en: 'The message `This is clock condition` is now executed based upon the parameter
    passed. Looking at another example, in a similar way, we can ensure that based
    upon a certain fact, we can take some action:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 消息`This is clock condition`现在是根据传递的参数执行的。看另一个例子，以类似的方式，我们可以确保根据某个事实采取某些行动：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we see, the condition is triggered on the `ansible_distribution` fact. If
    the response is Ubuntu, then the first condition is executed, otherwise, based
    upon `Red Hat`, the other condition is executed. Additionally, we are also validating
    if the clock value is `clock`, when the playbook is being called from command
    line with `clock` as the variable passed to the playbook. In the previous code,
    both the conditions need to be evaluated to true if we want to get that particular
    result.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，条件是在`ansible_distribution`事实上触发的。如果响应是 Ubuntu，则执行第一个条件，否则，根据`Red Hat`执行其他条件。此外，我们还在从命令行使用`clock`作为传递给
    playbook 的变量调用 playbook 时验证时钟值是否为`clock`。在前面的代码中，如果我们要得到那个特定的结果，两个条件都需要评估为真。
- en: Ansible loops
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 循环
- en: 'We can loop for repetitive operations using `with_items`**. **Let us see an
    example where we parse the list and print the values:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`with_items`循环进行重复操作。让我们看看一个解析列表并打印值的例子：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the playbook execution using the preceding code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面代码执行 playbook 的输出：
- en: '![](img/eb971bc1-f997-4bce-8c72-1a99b659f49d.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb971bc1-f997-4bce-8c72-1a99b659f49d.jpg)'
- en: 'As we can see in the preceding screenshot, the iteration prints the value of
    `Server` plus the item value in the list for each item in the list. Similarly,
    for an integer iteration we can perform a loop using the `with_sequence`command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的屏幕截图中所见，迭代打印了`Server`的值加上列表中每个项目的值。同样，对于整数迭代，我们可以使用`with_sequence`命令执行循环：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Additionally, let us say we want to print values skipping 2 (even numbers from
    0 to 10), the same `with_sequence` command will be written as:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设我们想要打印跳过 2（从 0 到 10 的偶数）的值，相同的`with_sequence`命令将写成：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Sometimes, we also need to pick any random value for performing specific task.
    The following sample code picks a random value from the 4 options available (in
    our case, `Choice Random 1` till `Choice Random 4`) and displays it using `msg`
    variable:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们也需要为执行特定任务随机选择任何值。以下示例代码从 4 个可用的选项中（在我们的案例中，从`Choice Random 1`到`Choice
    Random 4`）随机选择一个值，并使用`msg`变量显示它：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will pick any random value from the list from the given options under the
    `with_random_choice` declaration.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`with_random_choice`声明下的给定选项列表中随机选择任何值。
- en: Python API with Ansible
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python API 与 Ansible
- en: Ansible code can be called using Python, using the Ansible API. Ansible has
    released version 2.0 of its API for better integration with programming languages.
    One important aspect to note is that Ansible has extended its capability to support
    development using Python, but it also suggests on its website that, based upon
    its own discretion, it can also stop supporting the API (creating or even bug
    fixing its current API version) framework.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Python调用Ansible代码，使用Ansible API。Ansible已发布其API的2.0版本，以更好地与编程语言集成。需要注意的是，Ansible已扩展其功能以支持使用Python进行开发，但它在网站上也建议，根据其自己的判断，它也可以停止支持API（创建甚至修复其当前API版本的）框架。
- en: 'Let us see an example of creating a play with the task of seeing the username
    from our earlier inventory of `myrouters`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个创建play的例子，该play的任务是从我们之前`myrouters`的清单中查看用户名：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code for displaying the username from managed nodes:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示从受管理节点用户名的先前代码中：
- en: '`''#call libraries''`: These are used to initialize the available Ansible API
    libraries. Some of the important ones are:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`''#call libraries''`：这些用于初始化可用的Ansible API库。其中一些重要的库有：'
- en: '`from ansible.parsing.dataloader import DataLoader`: This is used for loading
    or parsing a YAML or JSON format file or value if called'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from ansible.parsing.dataloader import DataLoader`：此用于加载或解析YAML或JSON格式的文件或值，如果被调用'
- en: '`from ansible.vars import VariableManager`: This is used for inventory file
    location'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from ansible.vars import VariableManager`：此用于清单文件位置'
- en: '`from ansible.inventory.manager import InventoryManager`: This is used for
    inventory initialization'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from ansible.inventory.manager import InventoryManager`：此用于清单初始化'
- en: '`from ansible.playbook.play import Play`: This is used for configuring a play'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from ansible.playbook.play import Play`：此用于配置play'
- en: '`from ansible.executor.task_queue_manager import TaskQueueManager`: This is
    used for actual execution of the configured play'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from ansible.executor.task_queue_manager import TaskQueueManager`：此用于配置的play的实际执行'
- en: '`# initialize objects`: This section initializes the various components, such
    as the root user, `become_user` (if any) and other parameters required to run
    the play.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`# initialize objects`：此部分初始化各种组件，如root用户、`become_user`（如果有）和其他运行play所需的参数。'
- en: '`# create inventory`: This is where we specify the actual inventory location
    and initialize it.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`# create inventory`：这是指定实际清单位置并初始化它的地方。'
- en: '`# create play with task`:  This is where we create the task in a similar way
    that we create the `.yml` file. In this case, it is to show the hostname for all
    nodes in the `myrouters` section of the inventory.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`# create play with task`：这是我们在类似创建`.yml`文件的方式中创建任务的地方。在这种情况下，是为了显示清单中`myrouters`部分所有节点的主机名。'
- en: '`# execution`:This is the execution of the play that we created using the `run()`
    method of the task.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`# execution`：这是使用任务的`run()`方法创建的play的执行。'
- en: 'The output of the preceding code is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/13f8d60b-01d5-417f-82c7-377d1eed0484.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/13f8d60b-01d5-417f-82c7-377d1eed0484.jpg)'
- en: As we can see, after invoking the Python file, we got the hostname of the localhost
    defined under the `myrouters` inventory section in the `hosts` file (`/etc/ansible/hosts`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在调用Python文件后，我们得到了在`hosts`文件（`/etc/ansible/hosts`）中定义的`myrouters`清单部分下localhost的主机名。
- en: Creating network configuration templates
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网络配置模板
- en: As we are now familiar with the basics of Ansible, let us look at an example
    in which we generate configs ready to be deployed for some routers. To start with,
    we need to understand roles in Ansible. **Roles** are used to create a file structure
    for Ansible playbooks. Based upon roles, we can group similar data. Sharing the
    roles with others would mean we share the entire defined file structure for a
    common set of content. A typical role file structure would contain the main folder
    and the content folder, and under the content folder, we would have `templates`,
    `vars`, and `tasks` folders.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经熟悉了Ansible的基础知识，让我们看看一个例子，其中我们为一些路由器生成准备部署的配置。首先，我们需要了解Ansible中的角色。**角色**用于为Ansible
    playbooks创建文件结构。基于角色，我们可以分组相似的数据。与他人共享角色意味着我们共享整个定义的文件结构，以共享一组常见内容。一个典型的角色文件结构将包含主文件夹和内容文件夹，在内容文件夹下，我们将有`templates`、`vars`和`tasks`文件夹。
- en: 'In our case, the hierarchy is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，层次结构如下：
- en: Main directory
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主目录
- en: -Roles
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 角色'
- en: -Routers
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 路由器'
- en: -Templates
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 模板'
- en: -Vars
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 变量'
- en: -Tasks
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 任务'
- en: 'Under each of the templates, vars, or tasks folders, if we call that specific
    role, a file named `main.yml` is searched automatically and any configs in that
    file are taken into consideration for that particular role. Using the details
    of hierarchy as previously mentioned , in our test machine (running Ubuntu) here
    is how our file structure looks in the example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个模板、变量或任务文件夹下，如果我们调用该特定角色，将自动搜索名为`main.yml`的文件，并考虑该特定角色的该文件中的任何配置。使用之前提到的层次结构细节，在我们的测试机器（运行Ubuntu）上，以下是我们的文件结构示例：
- en: '![](img/bbbcab9e-9683-484b-973b-b4df1e3f7dd4.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bbbcab9e-9683-484b-973b-b4df1e3f7dd4.jpg)'
- en: As we see, under the `rtrconfig` folder, we have defined the folders as per
    Ansible standards. Once we create the folder hierarchy, the next step is to configure/create
    the files under each of the sections, based upon our requirements.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在`rtrconfig`文件夹下，我们根据Ansible标准定义了文件夹。一旦我们创建了文件夹层次结构，下一步就是在每个部分下根据我们的需求配置/创建文件。
- en: To start with, as we will be using a router template to generate the configs,
    we create a template and put it in the `roles/routers/templates` folder.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于我们将使用路由器模板来生成配置，我们创建一个模板并将其放入`roles/routers/templates`文件夹中。
- en: 'Router config template is as follows (used as a generic router template to
    generate router configs):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器配置模板如下（用作通用路由器模板以生成路由器配置）：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As we can see in the template, `{{item.hostname}}` and `{{logging_server}}`
    are two values that we would replace while creating the actual config. As this
    is a Jinja template, we would save this template as `somename.j2` (in our case, `routers.j2`).
    The next step is to define the variable values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在模板中所见，`{{item.hostname}}`和`{{logging_server}}`是我们创建实际配置时需要替换的两个值。由于这是一个Jinja模板，我们将把这个模板保存为`somename.j2`（在我们的例子中，`routers.j2`）。下一步是定义变量值。
- en: 'As we saw earlier, we need to ensure that the `logging_server` variable has
    already been defined a value. This will be in the `roles/routers/vars` folder:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们需要确保`logging_server`变量已经定义了一个值。这将在`roles/routers/vars`文件夹中：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We save this file as `main.yml` in the `vars` folder, which will be picked by
    default while executing the playbook for the variable value declarations. Once
    we have the definitions and template in place, the next step is to define the
    actual task that needs to be performed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此文件保存为`vars`文件夹中的`main.yml`，这将默认在执行playbook时用于变量值声明。一旦我们有了定义和模板，下一步就是定义实际需要执行的任务。
- en: This will be done in the `roles/routers/tasks` folder and again saved as `main.yml` for
    auto discovery during the execution of that specific role.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`roles/routers/tasks`文件夹中完成，并再次保存为`main.yml`，以便在执行该特定角色时进行自动发现。
- en: 'Let us see the config for this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个配置：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the config for the task, we call the template that we created (in this case,
    `routers.j2`), and provide a destination folder where the config files will be
    saved (in this case, `/home/abhishek/{{item.hostname}}.txt`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在任务的配置中，我们调用我们创建的模板（在这种情况下，`routers.j2`），并提供一个配置文件将保存到的目标文件夹（在这种情况下，`/home/abhishek/{{item.hostname}}.txt`）。
- en: A specific point to note here is that `{{item.hostname}}` will resolve to each
    of the hostnames that we have provided using the `with_items` loop. As a result,
    the filename that will be generated will be each item defined in the `with_items`
    loop (in our case, `myrouter1.txt` and `myrouter2.txt`).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要特别注意的一个点是`{{item.hostname}}`将解析为我们使用`with_items`循环提供的每个主机名。因此，将生成的文件名将是`with_items`循环中定义的每个项（在我们的例子中，`myrouter1.txt`和`myrouter2.txt`）。
- en: As mentioned previously, the `with_items` will loop with each value, with the
    hostname variable value being changed with each iteration. Once we have the template,
    vars, and task created, we will call the role in our main playbook and get it
    executed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`with_items`将循环每个值，其中主机变量值在每个迭代中都会改变。一旦我们有了模板、变量和任务，我们将在主playbook中调用该角色并执行它。
- en: 'The main playbook config is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 主playbook配置如下：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here we just call the hosts (which is localhost in our case since we want to
    get this executed locally), and call the role that needs to be executed in the
    playbook (in our case, `routers`). We save it as any name with a `.yml` extension
    (in our case, `makeconfig.yml`).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是调用主机（在我们的例子中是localhost，因为我们想在本地上执行），并调用在playbook中需要执行的角色（在我们的例子中，`routers`）。我们将其保存为任何带有`.yml`扩展名的名称（在我们的例子中，`makeconfig.yml`）。
- en: 'The final validation to ensure all `.yml` files are created in respective folders
    are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 确保所有`.yml`文件都创建在相应文件夹中的最终验证如下：
- en: 'To recap, here is the detailed file structure, as we now see the files under
    the `rtrconfig` folder:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回顾一下，以下是详细的文件结构，正如我们现在在`rtrconfig`文件夹下看到的文件：
- en: '![](img/3591c748-27ae-46b1-844f-f96a3220fcc7.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3591c748-27ae-46b1-844f-f96a3220fcc7.jpg)'
- en: 'To generate the config for routers , we execute the `makeconfig.yml` playbook:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为路由器生成配置，我们执行`makeconfig.yml`剧本：
- en: '![](img/21dc946b-6154-4f5c-b40f-35bc02cf3f21.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21dc946b-6154-4f5c-b40f-35bc02cf3f21.jpg)'
- en: 'Once executed successfully, we should have two files (`myrouter1.txt` and `myrouter2.txt`)
    in the `/home/abhishek` folder with the generated config:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦成功执行，我们应该在`/home/abhishek`文件夹中有两个文件（`myrouter1.txt`和`myrouter2.txt`），其中包含生成的配置：
- en: '![](img/f7019e1f-025f-441f-acf8-5ca2fb2d8ad4.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f7019e1f-025f-441f-acf8-5ca2fb2d8ad4.jpg)'
- en: 'Here is the content from one of the generated files:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是从生成的文件中提取的内容：
- en: '![](img/187efb7c-51bc-49a7-af5a-4a275c9ad11e.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/187efb7c-51bc-49a7-af5a-4a275c9ad11e.jpg)'
- en: As we can see, now we have a generated config, using the template, with the
    values replaced for the hostname and `logging _server` section.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所见，现在我们有了生成的配置，使用模板，并替换了主机名和`logging_server`部分的值。
- en: The config is now generated and ready to be pushed on those particular routers
    (which were part of `main.yml` under `roles/routers/tasks`), and in a similar
    way, we can generate configs with various roles and multiple devices in each role,
    such as switches, routers, load balancers, and so on with each role containing
    specific information, such as variables, templates, and tasks relevant to that
    role.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 配置现在已生成并准备好推送到那些特定的路由器（它们位于`roles/routers/tasks`下的`main.yml`中），以类似的方式，我们可以为具有各种角色和每个角色中多个设备的配置生成配置，例如交换机、路由器、负载均衡器等，每个角色都包含与该角色相关的特定信息，如变量、模板和任务。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what Ansible is, its installation, and basic usage
    of Ansible. This chapter also introduced concepts and terminology used in Ansible,
    with reference to how to create playbooks, tasks, and other basic functions in
    Ansible. We also got familar with ad-hoc commands and understand the concept of
    facts and their usage in Ansible.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Ansible是什么，它的安装以及Ansible的基本使用。本章还介绍了Ansible中使用的概念和术语，包括如何创建剧本、任务和其他基本功能。我们还熟悉了ad-hoc命令，并理解了事实的概念及其在Ansible中的使用。
- en: Finally, using Jinja templates we understood how to create a full configuration
    using templates with reference to device/role specific information using roles
    in Ansible.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过使用Jinja模板，我们了解了如何使用模板创建完整的配置，并参考设备/角色特定信息使用Ansible中的角色。
- en: In the next chapter, we will see how to call miscellaneous other aspects of
    automation, such as using Splunk for syslog collection and fetching information
    from Python, working with basic automation on BGP, UC integration examples, and
    other relevant examples that can be used for ready reference when creating automation
    scripts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何调用自动化的一些其他方面，例如使用Splunk进行syslog收集和从Python获取信息，在BGP上进行基本自动化，UC集成示例以及其他相关示例，这些示例在创建自动化脚本时可以作为参考资料。
