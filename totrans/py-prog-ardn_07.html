<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;The Midterm Project &#x2013; a Portable DIY Thermostat"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. The Midterm Project – a Portable DIY Thermostat</h1></div></div></div><p>After the first Python-Arduino project, you learned the process of prototyping various sensors, developing user interfaces, and plotting sensor data. The concepts that you learned in the previous chapters can be utilized to create a wide variety of Arduino-based hardware projects. The inception of a good application concept always begins with a real-world necessity and ends up as a practical project if it is executed properly. In this chapter, we will demonstrate this project-building process with an example of a portable sensor unit. As you can estimate from the chapter title, we will be building a simple and portable DIY thermostat that can be deployed without a desktop computer or a laptop.</p><p>To begin with, we will describe the proposed thermostat with specific goals and processes to achieve them. Once the strategy to achieve these goals has been laid down, you will be introduced to the two successive programming stages to develop the deployable and portable unit. In the first stage, we will utilize a traditional computer to successfully develop the program to interface Arduino with Python. In the second stage, we will replace this computer with a Raspberry Pi to make it portable and deployable.</p><div class="section" title="Thermostat – the project description"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Thermostat – the project description</h1></div></div></div><p>From the multiple projects that we can build using the things that you learned, a project that helps you to monitor your surrounding environment really stands out as an important <a id="id601" class="indexterm"/>real-world application. From the various environment-monitoring projects such as weather station, thermostat, and plant monitoring system, we will be developing the thermostat <a id="id602" class="indexterm"/>as it focuses on indoor environment and can be part of your daily routine.</p><p>The thermostat is <a id="id603" class="indexterm"/>one of the most important components of any remote home monitoring system and home automation system. A popular commercial example of a connected thermostat is the <a id="id604" class="indexterm"/>Nest Thermostat (<a class="ulink" href="https://www.nest.com">https://www.nest.com</a>), which provides intelligent remote monitoring and scheduling features for your existing home's heating and cooling system.  Before we think about a full-stack product such as Nest, we need first need to build a DIY thermostat with the basic set of features. Later, we can build upon this project by adding features to improve the DIY thermostat experience. Let's first outline the features that we are planning to implement in this version of the thermostat project.</p><div class="section" title="Project background"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec86"/>Project background</h2></div></div></div><p>Temperature, humidity, and ambient light are the three main physical characteristics that we want to monitor using the thermostat. In terms of user experience, we want to have an elegant user interface to display the measured sensor data. The user experience <a id="id605" class="indexterm"/>can be more resourceful if any of this sensor data is plotted as a line graph. In the case of a thermostat, the visual representation of the sensor data provides a more meaningful comprehension of the environment than just displaying plain numerical values.</p><p>One of the major objectives of the project is to make the thermostat portable and deployable so that it can be used in your day-to-day life. To satisfy this requirement, the thermostat display needs to be changed from a regular monitor to something small and more portable. To ensure its real-world and meaningful application, the thermostat should demonstrate real-time operation.</p><p>It is important to note that the thermostat will not be interfacing with any actuators such as home cooling and heating systems. As the interfacing of these systems with the thermostat project requires high-level understanding and experience of working with heating and cooling systems, it will deviate the flow of the chapter from its original goal of teaching you Arduino and Python programming.</p></div><div class="section" title="Project goals and stages"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec87"/>Project goals and stages</h2></div></div></div><p>In order to describe the features that we want to have in the thermostat, let's first identify the goals and <a id="id606" class="indexterm"/>milestones to achieve these objectives. The major goals for the project can be <a id="id607" class="indexterm"/>determined as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify the necessary sensors and hardware components for the project</li><li class="listitem" style="list-style-type: disc">Design and assemble the circuit for the thermostat using these sensors and the Arduino board</li><li class="listitem" style="list-style-type: disc">Design an effective user experience and develop software to accommodate the user experience</li><li class="listitem" style="list-style-type: disc">Develop and implement code to interface the designed hardware with the software components</li></ul></div><p>The code <a id="id608" class="indexterm"/>development process of the thermostat project is divided into two major stages. The objectives <a id="id609" class="indexterm"/>of the first stage include sensor interfacing, the development of the Arduino sketch, and the development of the Python code on your regular computer that you have been using all along. The coding milestone for the first stage can be further distributed as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Develop the Arduino sketch to interface sensors and buttons while providing output of the sensor data to the Python program via the serial port</li><li class="listitem" style="list-style-type: disc">Develop the Python code to obtain sensor data from the serial port using the <code class="literal">pySerial</code> library and display the data using GUI that is designed in <code class="literal">Tkinter</code></li><li class="listitem" style="list-style-type: disc">Create a plot to demonstrate the real-time humidity readings using the <code class="literal">matplotlib</code> library</li></ul></div><p>In the second stage, we will attach the Arduino hardware to a single-board computer and a miniature display to make it mobile and deployable. The milestone to achieve objective of the second stage are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Install and configure a single-board computer, Raspberry Pi, to run the Python code from the first stage</li><li class="listitem" style="list-style-type: disc">Interface and configure the miniature screen with the Raspberry Pi</li><li class="listitem" style="list-style-type: disc">Optimize the GUI and plot window to adjust to this small screen's resolution</li></ul></div><p>In the following subsection of this section, you will be notified about the list of required components for both the stages, followed by the hardware circuit design and the software flow design. The programming exercises for these stages are explained in the next two sections of the chapter.</p></div><div class="section" title="The list of required components"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec88"/>The list of required components</h2></div></div></div><p>Instead of going through the process of identifying the required components, we have already <a id="id610" class="indexterm"/>selected the components for this project based on their utilization in the previous exercises, ease of use, and availability. You can replace these components according to their availability at the time you are building this project or your familiarity with other sensors. Just make sure that you take care of modifications in the circuit connections and code, if these new components are not compatible with the ones that we are using.</p><p>In the first stage of prototyping, we will need components to develop the electronic circuit for the thermostat unit. As we mentioned earlier, we are going to measure temperature, humidity, and ambient light through our unit. We already learned about the temperature sensor TMP102 and the ambient light sensor BH1750 in <a class="link" href="ch04.html" title="Chapter 4. Diving into Python-Arduino Prototyping">Chapter 4</a>, <span class="emphasis"><em>Diving into Python-Arduino Prototyping</em></span>. We will be using these sensors for this project with the humidity sensor HIH-4030. The project will utilize the same Arduino Uno board that you have been using throughout the previous chapters with the <a id="id611" class="indexterm"/>necessary cables. We will also need two push buttons to provide manual inputs to the unit. The summary of the required components for the first stage is provided in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Component (first stage)</p>
</th><th style="text-align: left" valign="bottom">
<p>Quantity</p>
</th><th style="text-align: left" valign="bottom">
<p>Website</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Arduino Uno</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/11021">https://www.sparkfun.com/products/11021</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>USB cable for Arduino</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/512">https://www.sparkfun.com/products/512</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Breadboard</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/9567">https://www.sparkfun.com/products/9567</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TMP102 temperature sensor</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/11931">https://www.sparkfun.com/products/11931</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HIH-4030 humidity sensor</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/9569">https://www.sparkfun.com/products/9569</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>BH1750 ambient light sensor</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.robotshop.com/en/dfrobot-light-sensor-bh1750.html">http://www.robotshop.com/en/dfrobot-light-sensor-bh1750.html</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Push button switch</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/97">https://www.sparkfun.com/products/97</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>1 kilo-ohm resistor</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>10 kilo-ohm resistor</p>
</td><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top"> </td></tr><tr><td style="text-align: left" valign="top">
<p>Connection wires</p>
</td><td style="text-align: left" valign="top">
<p>As required</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>Although the table provides links for few specific website, you can obtain these components from your preferred providers. The two major components HIH-4030 humidity sensor and push button switch that we haven't used previously are described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>HIH-4030 humidity sensor</strong></span>: This measures and provides relative humidity results as an <a id="id612" class="indexterm"/>analog output. The output of the sensor can be directly connected to any analog pin of Arduino. The following image shows the breakout board with the HIH-4030 sensor that is sold by SparkFun Electronics. You can learn more about the HIH-4030 sensor from its datasheet, which can be obtained from <a class="ulink" href="https://www.sparkfun.com/datasheets/Sensors/Weather/SEN-09569-HIH-4030-datasheet.pdf">https://www.sparkfun.com/datasheets/Sensors/Weather/SEN-09569-HIH-4030-datasheet.pdf</a>:<div class="mediaobject"><img src="graphics/5938OS_07_06.jpg" alt="The list of required components"/></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Push button switch</strong></span>: Push button switches are small switches that can be used on a<a id="id613" class="indexterm"/> breadboard. When pressed, the switch output changes its status to <span class="strong"><strong>HIGH</strong></span>, which is <span class="strong"><strong>LOW</strong></span> otherwise.<div class="mediaobject"><img src="graphics/5938OS_07_07.jpg" alt="The list of required components"/></div></li></ul></div><p>In the <a id="id614" class="indexterm"/>second stage, we are going to make the sensor unit mobile by replacing your computer with a Raspberry Pi. For that, you will need the following components to get started:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Component (second stage)</p>
</th><th style="text-align: left" valign="bottom">
<p>Quantity</p>
</th><th style="text-align: left" valign="bottom">
<p>Image</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Raspberry Pi</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/11546">https://www.sparkfun.com/products/11546</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Micro USB cable with a power adapter</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0/">http://www.amazon.com/CanaKit-Raspberry-Supply-Adapter-Charger/dp/B00GF9T3I0/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>8 GB SD card</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://www.sparkfun.com/products/12998">https://www.sparkfun.com/products/12998</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TFT LCD screen</p>
</td><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.amazon.com/gp/product/B00GASHVDU/">http://www.amazon.com/gp/product/B00GASHVDU/</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>A USB hub</p>
</td><td style="text-align: left" valign="top">
<p>Optional</p>
</td><td style="text-align: left" valign="top"> </td></tr></tbody></table></div><p>Further explanations of these components are provided later in the chapter.</p></div><div class="section" title="Hardware design"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Hardware design</h2></div></div></div><p>The entire hardware architecture of the thermostat can be divided into two units, a physical <a id="id615" class="indexterm"/>world interfacing unit and a computation unit. The physical world interfacing unit, as its name indicates, monitors phenomenon of the physical world such as temperature, humidity, and ambient light using sensors connected to the Arduino board. The physical world interfacing unit is interchangeably mentioned as the thermostat sensor unit throughout the chapter. The computational unit is responsible for displaying the sensor information via the GUI and plots.</p><p>The following diagram shows the hardware components for the first stage where the thermostat sensor unit is connected to a computer using the USB port. In the thermostat sensor unit, various sensor components are connected to the Arduino board using I2C, analog, and digital pins:</p><div class="mediaobject"><img src="graphics/5938OS_07_08.jpg" alt="Hardware design"/></div><p>In the second programming stage where we are going make our thermostat into a mobile and deployable unit, you will be using a single-board computer, Raspberry Pi, as the computational device. In this stage, we will use a miniature <span class="strong"><strong>thin-film transistor liquid-crystal display</strong></span> (<span class="strong"><strong>TFT LCD</strong></span>)<a id="id616" class="indexterm"/> screen that is connected to a Raspberry Pi via <span class="strong"><strong>general-purpose input/output</strong></span> (<span class="strong"><strong>GPIO</strong></span>) pins and is used as a display unit to replace the<a id="id617" class="indexterm"/> traditional monitor or laptop screen. The following diagram shows this new thermostat computational unit, which truly reduces the overall size of the thermostat and makes it portable and mobile. Circuit connections for the Arduino board are unchanged for this stage and we will use the same hardware without any major modifications.</p><div class="mediaobject"><img src="graphics/5938OS_07_09.jpg" alt="Hardware design"/></div><p>As the common unit for both stages of the project, the Arduino-centric thermostat sensor unit requires slightly more complex circuit connections compared to other exercises that <a id="id618" class="indexterm"/>you have been through. In this section, we are going to interface the necessary sensors and push buttons to their respective pins on the Arduino board and you will need a breadboard to make these connections. If you are familiar with PCB prototyping, you can create your own PCB board by soldering these components and avoid the breadboard. PCB boards are more robust compared to breadboards and less prone to loose connections. Use the following instructions and the Fritzing diagram to complete the circuit connections:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As you can see in the following diagram, connect the SDA and SCL pins of TMP102 and BH1750 to analog pins 4 and 5 of the Arduino board and create an I2C bus. To make these connections, you can use multiple color-coded wires to simplify the debugging process.</li><li class="listitem">Use two 10 kilo-ohm pull-up resistors with the SDA and SCL lines.</li><li class="listitem">Contrary to these I2C sensors, the HIH-4030 humidity sensor is a simple analog sensor and can be directly connected to the analog pin. Connect the HIH-4030 to the analog pin A0.</li><li class="listitem">Connect VCC and the ground of TMP102, BH1750, and HIH-4030 to +5V and the ground of the Arduino board using power strips of the breadboard, as displayed in the diagram. We recommend that you use red and black wires to represent the +5V and ground lines respectively.</li><li class="listitem">The push button provides the output as <span class="strong"><strong>HIGH</strong></span> or <span class="strong"><strong>LOW</strong></span> state and interfaced using digital pins. As displayed in the circuit, connect these push buttons to digital pins 2 and 3 using two 1 kilo-ohm resistors.</li><li class="listitem">Complete the remaining connections as displayed in the following diagram. Make sure that you have firmly connected all the wires before powering up the Arduino board:<div class="mediaobject"><img src="graphics/5938OS_07_10.jpg" alt="Hardware design"/></div></li></ol></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Make sure that you always disconnect your Arduino board from the power source or a USB port before making any connections. This will prevent any damage to the board due to short circuiting.</p></div></div><p>Complete all the <a id="id619" class="indexterm"/>connections for the thermostat sensor unit before heading to the next section. As this unit is being used in both the programming stages, you won't be performing any further changes to the thermostat sensor unit.</p></div><div class="section" title="Software flow for user experience design"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Software flow for user experience design</h2></div></div></div><p>One of the critical components of any project is its usability or accessibility. When you are <a id="id620" class="indexterm"/>working on making your project prototype into a product, it is necessary to have an intuitive and resourceful user interface so that the user can easily interact with your product. Hence, it is necessary to define the user experience and software flow of a project before you start coding. The software flow includes the flow chart and the logical components of the program that are derived from the project requirements. According to the goals that we have defined for the thermostat project, the software flow can be demonstrated in the following diagram:</p><div class="mediaobject"><img src="graphics/5938OS_07_11.jpg" alt="Software flow for user experience design"/></div><p>In the implementation, the software flow of the project begins by measuring the temperature, humidity, and ambient light from Arduino and printing them on a serial port line by line. The Python program obtains the sensor data from Arduino via the<a id="id621" class="indexterm"/> serial port before presenting the data on the screen. Meanwhile, the Python program keeps looking for a new line of data.</p><p>A user can interact with the thermostat using a push button, which will let the user change the unit for the temperature data. Once the button is pressed, the flag gets changed to <span class="strong"><strong>HIGH</strong></span> and the temperature unit is changed to <span class="strong"><strong>Celsius</strong></span> from its default unit, <span class="strong"><strong>Fahrenheit</strong></span>. If the button is pressed again, the opposite process will happen and the unit will be changed back to its default value. Similarly, another user interaction point is the second push button that allows a user to open a plot for real-time humidity values. The second push button also utilizes a similar method of using flags to capture the input and opens a new plot window. If the same button is pushed sequentially, the program will close the plot window.</p></div></div></div>
<div class="section" title="Stage 1 &#x2013; prototyping the thermostat"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Stage 1 – prototyping the thermostat</h1></div></div></div><p>In this prototyping stage, we will develop the Arduino and Python code for our thermostat, which will be later used in the second stage with minor changes. Before you start the <a id="id622" class="indexterm"/>coding exercise, make sure that you have the thermostat sensor unit ready with the Arduino board and the connected sensors, as described in the previous section. For this stage, you will be using your regular computer which is equipped <a id="id623" class="indexterm"/>with the Arduino IDE and the Python programming environment. The prototyping stage requires two levels of programming, the Arduino sketch for the thermostat sensor unit and the Python code for the computational unit. Let's get started with coding for our thermostat.</p><div class="section" title="The Arduino sketch for the thermostat"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec91"/>The Arduino sketch for the thermostat</h2></div></div></div><p>The goal of this Arduino program is to interface sensors, get measurements from the sensors, and print them on the serial port. As we discussed earlier, rather than using the <a id="id624" class="indexterm"/>standard Firmata sketch that we used in the previous project, we are going to develop a custom Arduino sketch in this project. To get started, open the <code class="literal">Thermostat_Arduino.ino</code> sketch from this chapter's code folder, which is part of the source code that you received for the book.</p><p>Connect the USB port of the Arduino board, which is now part of the thermostat sensor unit, to your computer. Select the appropriate board and port names in the Arduino IDE and verify the code. Upload the code to your Arduino board and open the <span class="strong"><strong>Serial Monitor</strong></span> window once the code is successfully uploaded. You should be able to see text similar to that displayed in the following screenshot:</p><div class="mediaobject"><img src="graphics/5938OS_07_12.jpg" alt="The Arduino sketch for the thermostat"/></div><p>The Arduino code structure and basic declarations are already explained in various sections throughout the book. Instead of explaining the entire code line by line, we will focus here <a id="id625" class="indexterm"/>on the main components of the software flow that we described earlier.</p><div class="section" title="Interfacing the temperature sensor"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec52"/>Interfacing the temperature sensor</h3></div></div></div><p>In the Arduino sketch, the temperature data is obtained from the TMP102 sensor using<a id="id626" class="indexterm"/> the <code class="literal">getTemperature()</code> function. The function implements the <code class="literal">Wire</code> library on the I2C address of TMP102 to read the sensor data. This is then converted into proper temperature values:</p><div class="informalexample"><pre class="programlisting"> float getTemperature(){
  Wire.requestFrom(tmp102Address, 2);

  byte MSB = Wire.read();
  byte LSB = Wire.read();

  //it's a 12bit int, using two's compliment for negative
  int TemperatureSum = ((MSB &lt;&lt; 8) | LSB) &gt;&gt; 4;

  float celsius = TemperatureSum*0.0625;
  return celsius;
}</pre></div><p>The <code class="literal">getTemperature()</code> function returns the temperature values in Celsius, which is then sent to the serial port.</p></div><div class="section" title="Interfacing the humidity sensor"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec53"/>Interfacing the humidity sensor</h3></div></div></div><p>Although the humidity sensor provides the analog output, it is not straightforward to obtain <a id="id627" class="indexterm"/>relative humidity since it also depends upon the temperature. The <code class="literal">getHumidity()</code> function calculates the relative humidity from the analog output provided by the HIH-4030 sensor. The formulas to calculate the relative humidity are obtained from the datasheet and reference examples of the sensor. If you are using a different humidity sensor, please make sure that you change the formulas accordingly, as they may change the results significantly:</p><div class="informalexample"><pre class="programlisting">float getHumidity(float degreesCelsius){
//caculate relative humidity
float supplyVolt = 5.0;

// Get the sensor value:
int HIH4030_Value = analogRead(HIH4030_Pin);
// convert to voltage value
float voltage = HIH4030_Value/1023. * supplyVolt;

// convert the voltage to a relative humidity
float sensorRH = 161.0 * voltage / supplyVolt - 25.8;
float trueRH = sensorRH / (1.0546 - 0.0026 * degreesCelsius);

   return trueRH;
}</pre></div><p>As we are <a id="id628" class="indexterm"/>calculating relative humidity, the returned humidity values are sent to the serial port with percentage as the unit.</p></div><div class="section" title="Interfacing the light sensor"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec54"/>Interfacing the light sensor</h3></div></div></div><p>To interface the BH1750 light sensor, we will use the BH1750 Arduino library, which we used <a id="id629" class="indexterm"/>earlier. Using this library, the ambient light value can be directly obtained using the following line of code:</p><div class="informalexample"><pre class="programlisting">uint16_t lux = lightMeter.readLightLevel();</pre></div><p>This line provides the luminance values in the unit of <code class="literal">lux</code>. These values are also sent to the serial port so the Python program can utilize it further.</p></div><div class="section" title="Using Arduino interrupts"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec55"/>Using Arduino interrupts</h3></div></div></div><p>Until now you used the Arduino program to read the physical state of an I/O pin using the <code class="literal">DigitalRead()</code> or <code class="literal">AnalogRead()</code> functions. How would you automatically <a id="id630" class="indexterm"/>obtain the state change instead of periodically reading the pins and waiting for the state<a id="id631" class="indexterm"/> to change? Arduino interrupts provide a very convenient way of capturing <a id="id632" class="indexterm"/>signals for the Arduino board. Interrupts are a very powerful way of automatically controlling various things in Arduino. Arduino supports interrupts using the <code class="literal">attachInterrupt()</code> method. In terms of the physical pins, Arduino Uno provides two interrupts: interrupt 0 (on digital pin 2) and interrupt 1 (on digital pin 3). Various Arduino boards have different specifications for interrupt pins. If you are using any board other than Uno, please refer to Arduino's website to find out about the interrupt pin for your board.</p><p>The <code class="literal">attachInterrupt()</code> function takes three input arguments (<code class="literal">pin</code>, <code class="literal">ISR</code>, and <code class="literal">mode</code>). In these input arguments, <code class="literal">pin</code> refers to the number of the interrupt pin, <code class="literal">ISR</code> (which stands for Interrupt Service Routine) refers to the function that gets called when the interrupt occurs, and <code class="literal">mode</code> defines the condition when the interrupt should be triggered. We have utilized this function in our Arduino program, as described in the following code snippet:</p><div class="informalexample"><pre class="programlisting">  attachInterrupt(0, button1Press, RISING);
  attachInterrupt(1, button2Press, RISING);</pre></div><p>The supported <code class="literal">mode</code> for <code class="literal">attachInterrupt()</code> are <code class="literal">LOW</code>, <code class="literal">CHANGE</code>, <code class="literal">RISING</code>, and <code class="literal">FALLING</code>. In our case, the interrupts are triggered when the mode is <code class="literal">RISING</code>, that is, the pin goes from low to high. For interrupts declared at 0 and 1, we call the <code class="literal">button1Press</code> and <code class="literal">button2Press</code> functions that will change <code class="literal">flagTemperature</code> and <code class="literal">flagPlot</code> respectively. When <code class="literal">flagTemperature</code> is set to <code class="literal">HIGH</code>, Arduino sends the temperature<a id="id633" class="indexterm"/> in Celsius, otherwise it sends the temperature in Fahrenheit. When <code class="literal">flagPlot</code> is <code class="literal">HIGH</code>, Arduino <a id="id634" class="indexterm"/>will print the flag on the serial port, which will be used by the Python program later to open the plot window. You can learn more about Arduino interrupts <a id="id635" class="indexterm"/>from the tutorial at <a class="ulink" href="http://arduino.cc/en/Reference/attachInterrupt">http://arduino.cc/en/Reference/attachInterrupt</a>.</p></div></div><div class="section" title="Designing the GUI and plot in Python"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Designing the GUI and plot in Python</h2></div></div></div><p>Once your thermostat sensor unit starts sending sensor data to the serial port, it is time to execute the second part of this stage, the Python code for the GUI and the plot. From <a id="id636" class="indexterm"/>this chapter's <a id="id637" class="indexterm"/>code folder, open the Python file called <code class="literal">Thermostat_Stage1.py</code>. In the file, go to the line that contains the <code class="literal">Serial()</code> function where the serial port is <a id="id638" class="indexterm"/>declared. Change the serial port name from <code class="literal">COM5</code> to the appropriate one. You can find this information from the Arduino IDE. Save the change and exit the editor. From the same folder, run the following command on the terminal:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python Thermostat_Stage1.py</strong></span>
</pre></div><p>This will execute the Python code and you will be able to see the GUI window on the screen.</p><div class="section" title="Using pySerial to stream sensor data in your Python program"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec56"/>Using pySerial to stream sensor data in your Python program</h3></div></div></div><p>As described in the software flow, the program receives the sensor data from the Arduino <a id="id639" class="indexterm"/>using the <code class="literal">pySerial</code> library. The code that declares the serial port in the Python code is as follows:</p><div class="informalexample"><pre class="programlisting">Import serial
port = serial.Serial('COM5',9600, timeout=1)</pre></div><p>It is very important to specify the <code class="literal">timeout</code> parameter while using the <code class="literal">pySerial</code> library, as the code may have an error if <code class="literal">timeout</code> is not specified.</p></div><div class="section" title="Designing the GUI using Tkinter"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec57"/>Designing the GUI using Tkinter</h3></div></div></div><p>The GUI for this project is designed using the <code class="literal">Tkinter</code> library that we used earlier. As a GUI-building exercise, three columns of labels (labels to display the sensor type, the observation <a id="id640" class="indexterm"/>values, and observation units) are programmed as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting"># Labels for sensor name
Tkinter.Label(top, text = "Temperature").grid(column = 1, row = 1)
Tkinter.Label(top, text = "Humidity").grid(column = 1, row = 2)
Tkinter.Label(top, text = "Light").grid(column = 1, row = 3)

# Labels for observation values
TempLabel = Tkinter.Label(top, text = " ")
TempLabel.grid(column = 2, row = 1)
HumdLabel = Tkinter.Label(top, text = " ")
HumdLabel.grid(column = 2, row = 2)
LighLabel = Tkinter.Label(top, text = " ")
LighLabel.grid(column = 2, row = 3)

# Labels for observation unit
TempUnitLabel = Tkinter.Label(top, text = " ")
TempUnitLabel.grid(column = 3, row = 1)
HumdUnitLabel = Tkinter.Label(top, text = "%")
HumdUnitLabel.grid(column = 3, row = 2)
LighUnitLabel = Tkinter.Label(top, text = "lx")
LighUnitLabel.grid(column = 3, row = 3)</pre></div><p>Once you initialize the code and before you click on the <span class="strong"><strong>Start</strong></span> button, you will be able to see the following window. The observation labels are populated without any values at this stage:</p><div class="mediaobject"><img src="graphics/5938OS_07_13.jpg" alt="Designing the GUI using Tkinter"/></div><p>Once the <span class="strong"><strong>Start</strong></span> button is clicked, the program will engage the thermostat sensor unit and start reading the sensor values from the serial port. Using the lines that are obtained from the serial port, the program will populate the observation labels with the obtained values. The following code snippet updates the temperature values in the observation label and also updates the temperature unit:</p><div class="informalexample"><pre class="programlisting">TempLabel.config(text = cleanText(reading[1]))
TempUnitLabel.config(text = "C")
TempUnitLabel.update_idletasks()</pre></div><p>In the program, we are using similar methods for humidity and ambient light to update their labels respectively. As you can see in the following screenshot, the GUI now has the<a id="id641" class="indexterm"/> values for the temperature, humidity, and ambient light readings:</p><div class="mediaobject"><img src="graphics/5938OS_07_14.jpg" alt="Designing the GUI using Tkinter"/></div><p>The <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>Exit</strong></span> buttons are programmed to call the <code class="literal">onStartButtonPress()</code> and <code class="literal">onExitButtonPress()</code> functions when they are clicked by the user. The <code class="literal">onStartButtonPress()</code> function executes the code necessary to create the user interface, while the <code class="literal">onExitButtonPress()</code> function closes all the opened windows, disconnects the thermostat sensor unit, and exits the code:</p><div class="informalexample"><pre class="programlisting">StartButton = Tkinter.Button(top,
                             text="Start",
                             command=onStartButtonPress)
StartButton.grid(column=1, row=4)
ExitButton = Tkinter.Button(top,
                            text="Exit",
                            command=onExitButtonPress)
ExitButton.grid(column=2, row=4)</pre></div><p>You can play with the <span class="strong"><strong>Start</strong></span> and <span class="strong"><strong>Exit</strong></span> buttons to explore the Python code. To observe the changes in the sensor readings, try to blow air or place an obstacle over the thermostat sensor unit. If the program doesn't behave appropriately, check the terminal for error messages.</p></div><div class="section" title="Plotting percentage humidity using matplotlib"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec58"/>Plotting percentage humidity using matplotlib</h3></div></div></div><p>We will use the <code class="literal">matplotlib</code> library to plot the relative humidity values in real time. We will plot the relative humidity values in this project, as the range of the data is fixed <a id="id642" class="indexterm"/>between 0 and 100 percent. Using a similar method, you can also plot temperature and ambient light sensor values. While developing the code to plot temperature and ambient light sensor data, make sure that you are using appropriate ranges to cover the sensor data in the same plot. Now, as we have specified in the <code class="literal">onStartButtonPress()</code> function, a window similar to the following screenshot will pop up once you press the push button for the plot:</p><div class="mediaobject"><img src="graphics/5938OS_07_15.jpg" alt="Plotting percentage humidity using matplotlib"/></div><p>The following code snippet is responsible for plotting the line chart using the humidity sensor values. The values are limited between 0 and 100 on the <span class="emphasis"><em>y</em></span> axis, where the <span class="emphasis"><em>y</em></span> axis represents the relative humidity range. The plot is updated every time the program receives a new humidity value:</p><div class="informalexample"><pre class="programlisting">pyplot.figure()
pyplot.title('Humidity')
ax1 = pyplot.axes()
l1, = pyplot.plot(pData)
pyplot.ylim([0,100])</pre></div></div><div class="section" title="Using button interrupts to control the parameters"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec59"/>Using button interrupts to control the parameters</h3></div></div></div><p>The push button interrupts are a critical part of the user experience, as the user can control the <a id="id643" class="indexterm"/>temperature unit and the plot using these interrupts. The Python features implemented using the push button interrupts are as follows.</p><div class="section" title="Changing the temperature unit by pressing a button"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec05"/>Changing the temperature unit by pressing a button</h4></div></div></div><p>The Arduino sketch contains the logic to handle interrupts from push buttons and use them to change the temperature unit. When an interrupt occurs, instead of printing the<a id="id644" class="indexterm"/> temperature in Fahrenheit, it sends the temperature in Celsius to the serial port. As you can see in the following screenshot, the Python code just prints the obtained numeric value of the temperature observation and the associated unit of measurement with it:</p><div class="mediaobject"><img src="graphics/5938OS_07_16.jpg" alt="Changing the temperature unit by pressing a button"/></div><p>As you can see in the following code snippet, if the Python code receives the <code class="literal">Temperature(C)</code> string, it prints the temperature in <code class="literal">Celsius</code>, and if it receives the <code class="literal">Temperature(F)</code> string, it prints the temperature in <code class="literal">Fahrenheit</code>:</p><div class="informalexample"><pre class="programlisting">if (reading[0] == "Temperature(C)"):
    TempLabel.config(text=cleanText(reading[1]))
    TempUnitLabel.config(text="C")
    TempUnitLabel.update_idletasks()
if (reading[0] == "Temperature(F)"):
    TempLabel.config(text=cleanText(reading[1]))
    TempUnitLabel.config(text="F")
    TempUnitLabel.update_idletasks()</pre></div></div><div class="section" title="Swapping between the GUI and the plot by pressing a button"><div class="titlepage"><div><div><h4 class="title"><a id="ch07lvl4sec06"/>Swapping between the GUI and the plot by pressing a button</h4></div></div></div><p>If the Python code receives the value of the flag from the serial port as <code class="literal">1</code> (HIGH), it creates a new plot and draws the humidity values as a line chart. However, it closes any open <a id="id645" class="indexterm"/>plots if it receives <code class="literal">0</code> (LOW) as the value of the flag. As you can see in the following code snippet, the program will always try to update the plot with the latest values for humidity readings. If the program can't find an opened plot to draw this value from, it will create a new plot:</p><div class="informalexample"><pre class="programlisting">if (reading[0] == "Flag"):
    print reading[1]
    if (int(reading[1]) == 1):
        try:
            l1.set_xdata(np.arange(len(pData)))
            l1.set_ydata(pData)  # update the data
            pyplot.ylim([0, 100])
            pyplot.draw()  # update the plot
        except:
            pyplot.figure()
            pyplot.title('Humidity')
            ax1 = pyplot.axes()
            l1, = pyplot.plot(pData)
            pyplot.ylim([0, 100])
    if (int(reading[1]) == 0):
        try:
            pyplot.close('all')
            l1 = None
        except:</pre></div><p>By now, you should have a complete idea about the programs that are required by the thermostat sensor unit and the computation unit. Due to the complexity involved, you may face a few known problems during the execution of these programs. You can refer to the <span class="emphasis"><em>Troubleshooting</em></span> section in case you run into any trouble.</p></div></div></div><div class="section" title="Troubleshooting"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Troubleshooting</h2></div></div></div><p>Here are <a id="id646" class="indexterm"/>some of the errors that you may find, and their fixes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">I2C sensor returns the error string:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Check the connections to the SDA and SCL pins.</li><li class="listitem" style="list-style-type: disc">Confirm that you are providing enough delay between the reading cycles of the sensor. Check the datasheet for the delay and message sequence.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The plot <a id="id647" class="indexterm"/>window flickers instead of staying on when the button is pressed:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Don't try to press it multiple times. Hold and let go quickly. Make sure that your button is connected properly.</li><li class="listitem" style="list-style-type: disc">Adjust the delay in the Arduino sketch.</li></ul></div></li></ul></div></div></div>
<div class="section" title="Stage 2 &#x2013; using a Raspberry Pi for the deployable thermostat"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Stage 2 – using a Raspberry Pi for the deployable thermostat</h1></div></div></div><p>We have now created a thermostat that exists as an Arduino prototype while the Python program <a id="id648" class="indexterm"/>runs from your computer. This prototype is still nowhere near a deployable or mobile state due to the connected computer, and the display monitor if you are <a id="id649" class="indexterm"/>using a desktop computer. A real-world thermostat device should have a small footprint, portable size, and miniature display to show limited information. The popular and practical way to achieve this goal is to use a small single-board computer that is capable of hosting an operating system and hence providing the essential Python programming interface. For this stage of the project, we will be utilizing a single-board computer—a Raspberry Pi—with a small LCD display.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Note that this stage of the project is optional unless you want to extend the previous stage of the project to a device that can be used on a regular basis. If you are referring to the project to just learn Python programming, you can skip this entire section.</p></div></div><p>The following is an image of the Raspberry Pi Model B:</p><div class="mediaobject"><img src="graphics/5938OS_07_17.jpg" alt="Stage 2 – using a Raspberry Pi for the deployable thermostat"/></div><p>If you haven't worked with a single-board computer before, you may have a lot of unanswered <a id="id650" class="indexterm"/>questions, such as "What exactly does a Raspberry Pi consists of?", "What are the benefits of using a Raspberry Pi in our project?", and "Can't we just use Arduino for that?". These <a id="id651" class="indexterm"/>are legitimate questions and we will try to answer them in the following section.</p><div class="section" title="What is a Raspberry Pi?"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec94"/>What is a Raspberry Pi?</h2></div></div></div><p>The Raspberry Pi is a small (almost the size of a credit card) single-board computer that was <a id="id652" class="indexterm"/>developed with the initial aim of helping students learn the basics of computer science. Today, the Raspberry Pi movement, guided by the Raspberry Pi Foundation, has turned into a DIY phenomenon and captured the attention of enthusiasts and developers around the world. The capabilities and features shipped with a Raspberry Pi at a nominal cost ($35) have boosted the popularity of the device.</p><p>The term single-board computer is used for devices that have all the necessary components to run an operating system on one board, such as a processor, RAM, graphics processor, storage device, and basic adaptors for expansion. This makes a single-board computer an appropriate candidate for portable applications, as they can be part of the portable hardware device that we are trying to create. Although there were a number of single-board computers in the market before the introduction of the Raspberry Pi, the open source nature of the hardware and the economical price are the main reasons behind the popularity and rapid adoption of the Raspberry Pi. The following figure shows the Raspberry Pi Model B with its major components:</p><div class="mediaobject"><img src="graphics/5938OS_07_18.jpg" alt="What is a Raspberry Pi?"/></div><p>The computational capabilities of the Raspberry Pi are adequate for running a trimmed down version of Linux OS. Although people had tried to use many types of operating systems on a Raspberry Pi, we will be using the default and recommended operating system<a id="id653" class="indexterm"/> called <span class="strong"><strong>Raspbian</strong></span>. Raspbian is a Debian distribution-based open source Linux OS, which <a id="id654" class="indexterm"/>is optimized for the Raspberry Pi. The Raspberry Pi uses an SD card as the storage device, which will be used to store your OS and program files. In Raspbian, you can avoid running the unnecessary OS components that are shipped with traditional OSes. These include the Internet browser, communication application, and in some cases even the graphical interface.</p><p>After its introduction, the Raspberry Pi has gone through a few major upgrades. The earlier <a id="id655" class="indexterm"/>version, called <span class="strong"><strong>Model A</strong></span>, did not include the Ethernet port and only had a memory of 256 MB. In our project, we are using the Raspberry Pi's Model B that has a dedicated Ethernet port, 512 MB memory, and dual USB ports. The latest versions of Raspberry Pi, Model B+, can be also used as it is also equipped with an Ethernet port.</p></div><div class="section" title="Installing the operating system and configuring the Raspberry Pi"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Installing the operating system and configuring the Raspberry Pi</h2></div></div></div><p>Although the Raspberry Pi is a computer, it is different than traditional desktop computers <a id="id656" class="indexterm"/>when it <a id="id657" class="indexterm"/>comes to interfacing peripheral devices. Instead of supporting traditional VGA or DVI display ports, the Raspberry Pi provides a RCA video port for TVs and an HDMI port for the latest generation of monitors and TVs. In addition, the Raspberry Pi has only two USB ports that need to be utilized for connecting various peripheral devices such as the mouse, the keyboard, the USB wireless adapter, and the USB memory stick. Let's get started by collecting components and cables to start working with a Raspberry Pi.</p><div class="section" title="What do you need to begin using the Raspberry Pi?"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec60"/>What do you need to begin using the Raspberry Pi?</h3></div></div></div><p>The hardware components<a id="id658" class="indexterm"/> required to get started with a Raspberry Pi are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A Raspberry Pi</strong></span>: For this stage <a id="id659" class="indexterm"/>of the project, you will need a Raspberry Pi version<a id="id660" class="indexterm"/> Model B or latest. You can buy the Raspberry Pi from <a class="ulink" href="http://www.raspberrypi.org/buy">http://www.raspberrypi.org/buy</a>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A power cable</strong></span>: The Raspberry Pi runs on 5V DC and requires at least 750 mA current. The <a id="id661" class="indexterm"/>power is applied through the micro USB port that is located on the board. In this project, you will need a micro USB power supply. Optionally, you can use a micro USB-based phone charger to supply power to the Raspberry Pi.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A display cable</strong></span>: If you have an HDMI monitor or a TV, you can use an HDMI cable to <a id="id662" class="indexterm"/>connect it to your Raspberry Pi. If you want to use your VGA or DVI-based monitor, you will need a VGA to HDMI or DVI to HDMI adapter converter. You can buy these adapter converters from Amazon or Best Buy.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>An SD card</strong></span>: You<a id="id663" class="indexterm"/> are required to have at least an 8 GB SD card to get started. It is preferable to use an SD card that has a quality of class 4 or better. You can also buy an <a id="id664" class="indexterm"/>SD card with the preinstalled OS at <a class="ulink" href="http://swag.raspberrypi.org/collections/frontpage/products/noobs-8gb-sd-card">http://swag.raspberrypi.org/collections/frontpage/products/noobs-8gb-sd-card</a>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>The Raspberry Pi Model B+ requires a microSD card instead of a regular SD card.</p></div></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A mouse and keyboard</strong></span>: You will need a standard USB keyboard and a USB mouse to <a id="id665" class="indexterm"/>work <a id="id666" class="indexterm"/>with the Raspberry Pi.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>A USB hub (optional)</strong></span>: Since the Model B has just two USB ports, you will have to remove <a id="id667" class="indexterm"/>existing devices from the USB ports to make space for another device if you want to connect a Wi-Fi adapter or memory stick to it. A USB hub can be handy to attach multiple peripheral components to your Raspberry Pi. We recommend that you use a USB hub with external power supply, as the Raspberry Pi can drive a limited number of peripheral devices through the USB ports due to power limitations.</li></ul></div></div><div class="section" title="Preparing an SD card"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec61"/>Preparing an SD card</h3></div></div></div><p>To install and configure software components such as Python and the required libraries, first <a id="id668" class="indexterm"/>we need <a id="id669" class="indexterm"/>an operating system for the Raspberry Pi. A Raspberry Pi officially supports Linux-based open source operating systems that are preconfigured for custom Raspberry Pi hardware components. Various versions of these operating systems are available on <a id="id670" class="indexterm"/>Raspberry Pi's website (<a class="ulink" href="http://www.raspberrypi.org/downloads">http://www.raspberrypi.org/downloads</a>).</p><p>Raspberry Pi's website provides a variety of OSes for users who range from newbies to experts. It is difficult for a first-time user to identify the appropriate OS and its installation process. If this is your first attempt with a Raspberry Pi, we recommend that you use the <span class="strong"><strong>New Out Of Box Software</strong></span> (<span class="strong"><strong>NOOBS</strong></span>) package. Download the latest version of <a id="id671" class="indexterm"/>
<code class="literal">NOOBS</code> from the previous link. The <code class="literal">NOOBS</code> package includes few different operating systems such as Raspbian, Pidora, Archlinux, and RaspBMC. <code class="literal">NOOBS</code> streamlines the entire installation process and helps you to install and configure your preferred version of the OS easily. It is important to note that <code class="literal">NOOBS</code> is just an installation package and you will be left with only the Raspbian OS once you complete the given installation steps.</p><p>Raspberry Pi uses the SD card to host the operating system and you need to prepare the SD card from your computer before placing it into the SD card slot of the Raspberry Pi. Insert your SD card into your computer and make sure that you have a backup of any important information that is on the SD card. During the installation process, you will lose all the data stored on the SD card. Let's start by preparing <a id="id672" class="indexterm"/>your SD card.</p><p>Follow these steps to prepare an SD card from Windows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You will require <a id="id673" class="indexterm"/>a software tool to format and prepare the SD card for Windows. You can download <a id="id674" class="indexterm"/>the freely available formatting tool from <a class="ulink" href="https://www.sdcard.org/downloads/formatter_4/eula_windows/">https://www.sdcard.org/downloads/formatter_4/eula_windows/</a>.</li><li class="listitem">Download and<a id="id675" class="indexterm"/> install the formatting tool on your Windows computer.</li><li class="listitem">Insert your SD card and start the formatting tool.</li><li class="listitem">In the formatting tool, open the <span class="strong"><strong>Options</strong></span> menu and set <span class="strong"><strong>FORMAT SIZE ADJUSTMENT</strong></span> to <span class="strong"><strong>ON</strong></span>.</li><li class="listitem">Select the appropriate SD card and click on <span class="strong"><strong>Format</strong></span>.</li><li class="listitem">Then, wait for the formatting tool to finish formatting the SD card. Once this is done, extract the downloaded <code class="literal">NOOBS</code> ZIP file to the SD card. Make sure that you extract the content of the ZIP folder to the root location of the SD card.</li></ol></div><p>Follow these directions to prepare SD card from Mac OS X:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">You will <a id="id676" class="indexterm"/>require a<a id="id677" class="indexterm"/> software tool to format and prepare the SD card for Mac OS X. You can download the freely available formatting tool from <a class="ulink" href="https://www.sdcard.org/downloads/formatter_4/eula_mac/">https://www.sdcard.org/downloads/formatter_4/eula_mac/</a>.</li><li class="listitem">Download and install the formatting tool on your machine.</li><li class="listitem">Insert your SD card and run the formatting tool.</li><li class="listitem">In the formatting tool, select <span class="strong"><strong>Overwrite Format</strong></span>.</li><li class="listitem">Select the appropriate SD card and click on <span class="strong"><strong>Format</strong></span>.</li><li class="listitem">Then, wait for the formatting tool to finish formatting the SD card. Once this is done, extract the downloaded <code class="literal">NOOBS</code> ZIP file to the SD card. Make sure that you extract the content of the ZIP folder to the root location of the SD card.</li></ol></div><p>Follow these steps to<a id="id678" class="indexterm"/> prepare <a id="id679" class="indexterm"/>the SD card from Ubuntu Linux:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">To format the SD card on Ubuntu, you can use a formatting tool called <code class="literal">gparted</code>. Install <code class="literal">gparted</code> using the following command on the terminal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install gparted</strong></span>
</pre></div></li><li class="listitem">Insert your SD card and run <code class="literal">gparted</code>.</li><li class="listitem">In the <code class="literal">gparted</code> window, select the entire SD card and format it using <span class="strong"><strong>FAT32</strong></span>.</li><li class="listitem">Once <a id="id680" class="indexterm"/>the format <a id="id681" class="indexterm"/>process is complete, extract the downloaded <code class="literal">NOOBS</code> ZIP file to the SD card. Make <a id="id682" class="indexterm"/>sure that you extract the content of the ZIP folder to the root location of the SD card.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>If you have any trouble following these steps, you can refer to the official documentation for<a id="id683" class="indexterm"/> preparing the SD card for a Raspberry Pi at <a class="ulink" href="http://www.raspberrypi.org/documentation/installation/installing-images/">http://www.raspberrypi.org/documentation/installation/installing-images/</a>.</p></div></div></li></ol></div></div><div class="section" title="The Raspberry Pi setup process"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec62"/>The Raspberry Pi setup process</h3></div></div></div><p>Once you have prepared your SD card with <code class="literal">NOOBS</code>, insert it into the SD card slot of the Raspberry Pi. Connect your monitor, mouse, and keyboard before connecting the micro USB <a id="id684" class="indexterm"/>cable for the power adapter. Once you connect the power adapter, the Raspberry Pi will turn on automatically and you will be able to see the installation process on the monitor. If you are not able to see any progress on the monitor after connecting the power adapter, refer to the troubleshooting section that is available later in this chapter.</p><p>Once the Raspberry Pi boots up, it will repartition the SD card and show you the following installation screen so that you can get started:</p><div class="mediaobject"><img src="graphics/5938OS_07_19.jpg" alt="The Raspberry Pi setup process"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note45"/>Note</h3><p>The preceding screenshot is taken from <code class="literal">raspberry_pi_F01_02_5a.jpg</code> by Simon Monk and is licensed under Attribution Creative Commons license (<a class="ulink" href="https://learn.adafruit.com/assets/11384">https://learn.adafruit.com/assets/11384</a>).</p></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">As a first-time user, select <span class="strong"><strong>Raspbian [RECOMMENDED]</strong></span> as the recommended operating system and click on the <span class="strong"><strong>Install OS</strong></span> button. Raspbian is a Debian-based OS that is optimized for the Raspberry Pi and it supports useful Linux commands that we have already learned in the previous chapters. The process will take <a id="id685" class="indexterm"/>about 10 to 20 minutes to complete.</li><li class="listitem">On successful completion, you will be able to see a screen similar to the one displayed in the following screenshot. The screenshot displays the <code class="literal">raspi-config</code> tool that will let you set up the initial parameters. We will skip this process to complete the installation. Select <span class="strong"><strong>&lt;Finish&gt;</strong></span> and press <span class="emphasis"><em>Enter</em></span>:<div class="mediaobject"><img src="graphics/5938OS_07_20.jpg" alt="The Raspberry Pi setup process"/></div></li><li class="listitem">You can go back to this screen again, in case you want to change any parameter, by typing the following command in the terminal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo raspi-config</strong></span>
</pre></div></li><li class="listitem">Raspberry Pi will now reboot and you will be prompted to the default login screen. Log in using the default username <code class="literal">pi</code> and password <code class="literal">raspberry</code>.</li><li class="listitem">You can start the graphical desktop of the Raspberry Pi by typing the following command in the terminal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ startx</strong></span>
</pre></div></li><li class="listitem">To run the Python code that we developed in the first stage, you will need to set up required Python libraries on the Raspberry Pi. You will have to connect <a id="id686" class="indexterm"/>your Raspberry Pi to the Internet using the Ethernet cable to install the packages. Install the required Python packages on the Raspberry Pi terminal using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install python-setuptools, python-matplotlib, python-numpy</strong></span>
</pre></div></li><li class="listitem">Install <code class="literal">pySerial</code> using Setuptools:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo easy_install pyserial</strong></span>
</pre></div></li></ol></div><p>Now, your Raspberry Pi is ready with an operating system and the necessary components to support Python-Arduino programming.</p></div></div><div class="section" title="Using a portable TFT LCD display with the Raspberry Pi"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Using a portable TFT LCD display with the Raspberry Pi</h2></div></div></div><p>TFT LCD is a <a id="id687" class="indexterm"/>great way to expand the Raspberry Pi's functionalities and avoid the use of large display devices. These TFT LCD displays can be interfaced directly with GPIO pins. TFT LCD screens are available in various shapes and size, but for the Raspberry Pi <a id="id688" class="indexterm"/>we recommend that you use a screen with a size smaller than or equal to 3.2 inches due to interfacing convenience. Most of these small screens do not require additional power supply and can be directly powered using the GPIO pins. In a few cases, touch screen versions are also available to extend the functionality of the Raspberry Pi.</p><p>In this project, we are using a Tontec 2.4 inch TFT LCD screen that can be directly interfaced with the Raspberry Pi via GPIO. Although you can use any available TFT LCD screen, this book only cover the setup and configuration process for this particular screen. In most cases, manufacturers of these screens provide detailed configuration tutorials on their websites. Raspberry Pi forums and blogs are another good places to look for help if you are using a different type of the TFT LCD screen. The following image shows the back of the Tontec 2.4 inch TFT LCD screen with the location of the GPIO pins. Let's get started and use this screen with your Raspberry Pi:</p><div class="mediaobject"><img src="graphics/5938OS_07_21.jpg" alt="Using a portable TFT LCD display with the Raspberry Pi"/></div><div class="section" title="Connecting the TFT LCD using GPIO"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec63"/>Connecting the TFT LCD using GPIO</h3></div></div></div><p>Before we can use the screen, we will have to connect it to the Raspberry Pi. Let's disconnect the <a id="id689" class="indexterm"/>micro USB power adapter from the Raspberry Pi and locate the GPIO male<a id="id690" class="indexterm"/> pins near the RCA video port on the Raspberry Pi. Get your TFT screen and connect the GPIO pins as such you can see Raspberry Pi and the screen as displayed in the following image. In handful cases, the notations on the screen will be misleading, and therefore we suggest that you follow the guidelines from the manufacturer to make the connections:</p><div class="mediaobject"><img src="graphics/5938OS_07_22.jpg" alt="Connecting the TFT LCD using GPIO"/></div><p>Once your screen is connected to the Raspberry Pi, power it up using the micro USB cable. Do not disconnect your HDMI cable yet, as your screen is still not ready. Before <a id="id691" class="indexterm"/>we go ahead with any of the configuration steps, let's first connect the Raspberry Pi to the Internet. Connect the Ethernet port of the Raspberry Pi to your home or office <a id="id692" class="indexterm"/>network using an Ethernet cable. Now, let's configure the TFT LCD screen in the Raspbian OS to make it work properly.</p></div><div class="section" title="Configuring the TFT LCD with the Raspberry Pi OS"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec64"/>Configuring the TFT LCD with the Raspberry Pi OS</h3></div></div></div><p>Once your Raspberry Pi is powered up, log in using your username and password. Complete<a id="id693" class="indexterm"/> the following<a id="id694" class="indexterm"/> steps to configure the screen with your Raspberry Pi:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download the supporting files and manual using the following command on the terminal:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ wget https://s3.amazonaws.com/tontec/24usingmanual.zip</strong></span>
</pre></div></li><li class="listitem">Unzip the file. The following command will extract the files into the same directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ unzip 24usingmanual.zip</strong></span>
</pre></div></li><li class="listitem">Navigate to the <code class="literal">src</code> directory:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd cd mztx-ext-2.4/src/</strong></span>
</pre></div></li><li class="listitem">Enter following command to compile the source files:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ make</strong></span>
</pre></div></li><li class="listitem">Open the boot configuration files:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo pico /boot/config.txt</strong></span>
</pre></div></li><li class="listitem">In the <code class="literal">config.txt</code> file, locate and uncomment the following lines of code:<div class="informalexample"><pre class="programlisting">framebuffer_width=320
framebuffer_height=240</pre></div></li><li class="listitem">Save and exit the file.</li><li class="listitem">Now, every time the Raspberry Pi restarts we need to execute a command to start the TFT LCD screen. To do this, open the <code class="literal">rc.local</code> file using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo pico /etc/rc.local</strong></span>
</pre></div></li><li class="listitem">Add the following line of code to the file that starts the screen:<div class="informalexample"><pre class="programlisting">sudo /home/pi/mztx-ext-2.4/src/mztx06a &amp;</pre></div></li><li class="listitem">Save and exit the file. Then, reboot the Raspberry Pi using the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo reboot</strong></span>
</pre></div></li></ol></div><p>You can <a id="id695" class="indexterm"/>remove <a id="id696" class="indexterm"/>your HDMI monitor now and start working with your TFT LCD screen. One thing that you will have to keep in mind is that the screen resolution is very small and it is not optimized for coding. We prefer to use the HDMI monitor to perform the major code modifications that are required in the next section. The utilization of the TFT LCD screen in this project is to accommodate the mobility and portability requirements of the thermostat.</p></div></div><div class="section" title="Optimizing the GUI for the TFT LCD screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Optimizing the GUI for the TFT LCD screen</h2></div></div></div><p>The resolution of the TFT LCD screen that we configured in the previous section is only 320 x 240 pixels, but the windows that we created in first programming stage are quite large. Therefore, before we copy and run our Python code on the Raspberry Pi, we <a id="id697" class="indexterm"/>need to adjust a<a id="id698" class="indexterm"/> few parameters in the code.</p><p>In your regular computer where you have this chapter's folder from the book's source code, open the <code class="literal">Thermostat_Stage2.py</code> file. This file contains the details of the modification required to obtain the optimum size with minor cosmetic changes. You will be using this file, instead of the one that we used in the previous stage, on your Raspberry Pi. These adjustments in the code are explained in the following lines of code.</p><p>The first major alteration is in the port name. For the Raspberry Pi, you need to change the name of the Arduino port from that you were using in the first stage to <code class="literal">/dev/ttyACM0</code>, which is the address assigned to Arduino in the majority of the cases:</p><div class="informalexample"><pre class="programlisting">port = serial.Serial('/dev/ttyACM0',9600, timeout=1)</pre></div><p>In this program file, the size of the <code class="literal">Tkinter</code> main window and the <code class="literal">matplotlib</code> figure are also adjusted to fit the screen size. If you are using a different-sized screen, change the following lines of code appropriately:</p><div class="informalexample"><pre class="programlisting">top.minsize(320,160)
pyplot.figure(figsize=(4,3))</pre></div><p>Now, with the preceding changes, the GUI window should be able to fit within Raspberry Pi's screen. As the Raspberry Pi's screen will be used as the dedicated screen for the thermostat application, we need to adjust the text size on the screen to fit the window<a id="id699" class="indexterm"/> properly. Add the <code class="literal">font=("Helvetica", 20)</code> text in the declaration of the labels to increase <a id="id700" class="indexterm"/>the font size. The following line of code shows changes that are performed on the labels to contain the sensor names:</p><div class="informalexample"><pre class="programlisting">Tkinter.Label(top,
              text="Humidity",
              font=("Helvetica", 20)).grid(column=1, row=2)</pre></div><p>Similarly, the <code class="literal">font</code> option is added to the observation labels:</p><div class="informalexample"><pre class="programlisting">HumdUnitLabel = Tkinter.Label(top,
                              text="%",
                              font=("Helvetica", 20))</pre></div><p>The labels for the observation unit also carry similar modifications:</p><div class="informalexample"><pre class="programlisting">HumdLabel.config(text=cleanText(reading[1]),
                 font=("Helvetica", 20))</pre></div><p>The <code class="literal">Thermostat_ Stage2.py</code> file already includes the preceding modifications and is ready to run on your Raspberry Pi. Before you run the file, first we need to copy the file to the Raspberry Pi. At this stage, the USB hub will be very handy to copy the files. If you don't have a USB hub, you can utilize two available USB ports simultaneously to attach the USB pen drive, mouse, and keyboard. With the use of the USB hub, connect the USB pen drive containing the Python files and copy them to the home folder. Attach the USB port of the Arduino board to one of the ends of the USB hub. From the start menu of the Raspberry Pi, open the <span class="strong"><strong>LXTerminal</strong></span> program by navigating to <span class="strong"><strong>Accessories</strong></span> | <span class="strong"><strong>LXterminal</strong></span>. Run the Python code from the home folder and you will be able to see the optimized user interface window that opens on the Raspberry Pi's screen. If every step mentioned in the chapter is performed correctly, you will be able to see the sensor observation being printed when you click on the <span class="strong"><strong>Start</strong></span> button:</p><div class="mediaobject"><img src="graphics/5938OS_07_23.jpg" alt="Optimizing the GUI for the TFT LCD screen"/></div><p>At the end of the chapter, you must be wondering what a mobile unit with sensors, Arduino, Raspberry Pi, and TFT screen might look like. The following image shows a sample thermostat that was developed using the instructions given in this chapter. We used an<a id="id701" class="indexterm"/> acrylic <a id="id702" class="indexterm"/>sheet to hold the Raspberry Pi and the Arduino board together and created a compact form factor:</p><div class="mediaobject"><img src="graphics/5938OS_07_24.jpg" alt="Optimizing the GUI for the TFT LCD screen"/></div></div><div class="section" title="Troubleshooting"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Troubleshooting</h2></div></div></div><p>There are a few known problems that you may face in this stage of the project. The following <a id="id703" class="indexterm"/>section describes these problems and their quick fixes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Raspberry Pi is not booting up:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make sure that the SD card is formatted properly with the specified tools. The Raspberry Pi won't boot if the SD card is not prepared properly.</li><li class="listitem" style="list-style-type: disc">Check the HDMI cable and the monitor to see whether they are working fine.</li><li class="listitem" style="list-style-type: disc">Make sure that the power adapter is compatible with the Raspberry Pi.</li></ul></div></li><li class="listitem" style="list-style-type: disc">The TFT LCD screen doesn't turn on:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Make sure that the screen is properly connected to the GPIO pins of the Raspberry Pi.</li><li class="listitem" style="list-style-type: disc">If you are using any other TFT LCD screen, make sure from its datasheet that your screen doesn't require additional power.</li><li class="listitem" style="list-style-type: disc">Check whether the screen is properly configured using the steps described in the <span class="emphasis"><em>Optimizing the GUI for the TFT LCD screen</em></span> section.</li></ul></div></li><li class="listitem" style="list-style-type: disc">There is a<a id="id704" class="indexterm"/> slow refresh rate of the sensor data on the Raspberry Pi:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Try decreasing the delay between each serial message that is sent by Arduino.</li><li class="listitem" style="list-style-type: disc">Terminate any other application that is running in the background.</li></ul></div></li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Summary</h1></div></div></div><p>With this project, we successfully created a portable and deployable thermostat using Arduino, which monitors temperature, humidity, and ambient light. During this process, we assembled the thermostat sensor unit using the necessary components and developed custom Arduino program to support them. We also utilized Python programming methods including GUI development and plots using <code class="literal">Tkinter</code> and <code class="literal">matplotlib</code> libraries respectively. Later in the chapter, we utilized the Raspberry Pi to convert a mere project prototype into a practical application. Henceforth, you should be able to develop similar projects that require you to observe and visualize real-time sensor information.</p><p>Going forward, we will be expanding this project to accommodate upcoming topics such as Arduino networking, cloud communication, and remote monitoring. In the next level of the thermostat project, we will integrate these advanced features and make it a really resourceful DIY project that can be used in everyday life. In the next chapter, we are going to start the next stage of our journey from making simple Python-Arduino projects to Internet-connected and remotely accessible IoT projects.</p></div></body></html>