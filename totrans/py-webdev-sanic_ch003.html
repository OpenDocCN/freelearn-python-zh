<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xml:lang="en-US">
<head>
<meta charset="utf-8"/>
<meta name="generator" content="packt"/>
<title>2 Organizing a project</title>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet1.css"/>
<link rel="stylesheet" type="text/css" href="../styles/stylesheet2.css"/>

</head>
<body>
<section id="organizing-a-project" class="level1 pkt" data-number="3">
<h1 data-number="3">2 Organizing a project</h1>
<p>It is Day 0. You have a project in hand. You are fired up and ready to build a new web application. Ideas are swirling in your head, and your fingers are itching to start punching the keyboard. Time to sit down and start coding!</p>
<p>Or is it? It is tempting to start building an application as soon as the ideas about what we want to build begin to formulate in our heads. Before doing that, we should think about setting ourselves up for success. Having a solid foundation for the building will make the process much easier, reduce bugs, and result in a cleaner application.</p>
<p>The three foundations for beginning any Python web application project are:</p>
<ul>
<li>your IDE/coding editor</li>
<li>an environment for running your development application</li>
<li>a project application structure</li>
</ul>
<p>These three elements take into account a lot of personal tastes. There are so many good tools and approaches. There is no way a single book could cover them all. If you are a more seasoned developer and already have a set of preferences: great, run with that and skip ahead to the next chapter.</p>
<p>In this chapter, we will explore a couple of modern options to get you up and running. The focus will be upon foundation #2 (the environment) and foundation #3 (the application structure). We skip #1 and assume you are using a modern IDE of your own choosing. Popular choices in the Python world include VS Code, Pycharm, and Sublime Text. If you are not using one of these or something similar, go look them up and find one that works for you.</p>
<p>After we setup our environment, we will explore some patterns to be implemented in Sanic that will help define your application architecture. This is not a software architecture book. I highly recommend you learn about approaches like “Domain Driven Design” and “Clean Architecture”. This book is focused much more on the practical aspects and decisions of building a web application in Sanic, so feel free to adjust the patterns as you feel necessary.</p>
<p>In this chapter, we’ll go through the following topics:</p>
<ul>
<li>Setting up an environment and directory</li>
<li>Using blueprints effectively</li>
<li>Wiring it all up</li>
<li>Running our application</li>
</ul>
<section id="technical-requirements-1" class="level2" data-number="3.1">
<h2 data-number="3.1">Technical requirements</h2>
<p>Before we begin, we will assume you have the following already setup on your computer:</p>
<ul>
<li>Modern Python installation (Python 3.7 or newer)</li>
<li>Terminal (and basic knowledge of how to execute programs)</li>
<li>IDE (as discussed above)</li>
</ul>
</section>
<section id="setting-up-an-environment-and-directory" class="level2" data-number="3.2">
<h2 data-number="3.2">Setting up an environment and directory</h2>
<p>The first few steps that you take when starting any project have a monumental impact on the entirety of the project. Whether you are embarking on a multi-year project—or one that will be complete in a couple of hours—these early decisions will shape how you and others work on the project. But, even though these are important choices, do not fall into the trap of thinking that you need to find the <em>perfect</em> solution. There is no single “right way” to set up an environment or project directory. Remember our discussion from the previous chapter: we want to make the choices that fit the project at hand.</p>
<section id="environment" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1">Environment</h3>
<p>A good practice for Python development is to isolate its running environment from other projects. This is typically accomplished with virtual environments. In its most basic understanding, a virtual environment is a tool that allows you to install Python dependencies in isolation. This is important so that when we begin to develop our application, we have control of the requirements and dependencies in use. In its absence, we might mistakenly run our application and have requirements from other projects bleed into the application causing bugs and unintended behaviors.</p>
<p>Usage of a virtual environment is so foundational in the Python development world, that it has become the expected “norm” when creating a Python script or application. The first step you should always do when starting a new project is making a new virtual environment for it. The alternative to them is to run your application with your operating system’s installation of Python. Do not do this. It may be fine for a while, but eventually, you will come across conflicting requirements, naming collisions, or other difficulties that all stem from a lack of isolation. The first step to becoming a better Python developer is to use virtual environments if you are not already.</p>
<p>It is also extremely helpful to acquaint yourself with the different tools that IDEs provide in hooking up to your virtual environment. These tools will often include things like code completion, and guide you as you start using features of your dependencies.</p>
<p>We do eventually want to run our application using containers. Being able to run our application inside of a Docker container will greatly reduce the complexity in deploying our application down the road. This will be discussed further in <em>Chapter 9, Best practices to improve your web applications</em>. However, I also believe that our application should be runnable (and therefore testable) from multiple environments. Even if we intend to use Docker down the road, we first need our application running locally without it. Debugging becomes much easier when our application does not rely upon an overly complex set of requirements just to run. Therefore, let’s spend some time thinking about how to setup a virtual environment.</p>
<p>There are many great tutorials and resources about how to use virtual environments. There are also many tools out there that are created to help manage the process. While I personally am a fan of the simple, tried and true method of <code>virtualenv </code>plus <code>virtuanenvwrapper</code>, there are many people who are fans of <code>pipenv</code>, or <code>poetry</code>. These latter tools are meant to be a more “complete” encapsulation of your running environment. If they work for you, great. You are encouraged to spend some time to see what strikes a chord and resonates with your development pattern and needs.</p>
<p>We will leave virtual environments aside for now, and briefly explore the usage of a relatively new pattern in Python. In Python 3.8, Python adopted a new pattern in PEP 582 that formalizes the inclusion of requirements into an isolated environment in a special <code>__pypackages__</code> directory that lives inside the project. While the concept is similar to virtual environments, it works a little differently.</p>
<p>In order to implement <code>__pypackages__</code>, we are making it mandatory for our fictitious development team to use <code>pdm</code>. This is a relatively new tool that makes it super simple to adhere to some of the latest practices in modern Python development. If this approach interests you, take some time to go read PEP 582 (<a href="https://www.python.org/dev/peps/pep-0582/">https://www.python.org/dev/peps/pep-0582/</a>) and look at <code>pdm</code> (<a href="https://pdm.fming.dev/">https://pdm.fming.dev/</a>).</p>
<p>You can get started by installing it with <code>pip</code>:</p>
<pre><code>$ pip install --user pdm</code></pre>
<p>Refer to the installation instructions on their website for more details: <a href="https://pdm.fming.dev/#installation">https://pdm.fming.dev/#installation</a>. Pay particular attention to useful features like shell completion and IDE integrations.</p>
<p>Now let’s proceed with setting up:</p>
<ol>
<li><p>To get started, we create a new directory for our application, and from that directory run the following and follow the prompts to setup a basic structure.</p>
<pre><code>$ mkdir booktracker
$ cd booktracker
$ pdm init</code></pre></li>
<li><p>Now we will install Sanic.</p>
<pre><code>$ pdm add sanic</code></pre></li>
<li><p>We now have access to Sanic. Just to confirm in our heads that we are indeed in an isolated environment, let’s quickly jump into the Python REPL, and check the location of Sanic using: sanic.__file__.</p>
<pre><code>$ python
&gt;&gt;&gt; import sanic
&gt;&gt;&gt; sanic.__file__
&#39;/path/to/booktracker/__pypackages__/3.9/lib/sanic/__init__.py&#39;</code></pre></li>
</ol>
</section>
<section id="sanic-cli" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2">Sanic CLI</h3>
<p>As discussed in <em>Chapter 8, Running a Server</em>, there are many considerations that go into <em>how</em> to deploy and run Sanic. Unless we are specifically looking into one of these alternatives, you can assume in this book that we are running Sanic using the Sanic CLI. This will standup our application using the integrated Sanic web server.</p>
<p>First, we will check to see what version we are running:</p>
<pre><code>$ sanic -v
Sanic 21.3.4</code></pre>
<p>And check to see what options we can use with the CLI:</p>
<pre><code>$ sanic -h
usage: sanic [-h] [-H HOST] [-p PORT] [-u UNIX] [--cert CERT] [--key KEY] [-w WORKERS] [--debug] [--access-logs | --no-access-logs] [-v] module
                 Sanic
         Build Fast. Run Fast.
positional arguments:
  module                path to your Sanic app. Example: path.to.server:app
optional arguments:
  -h, --help            show this help message and exit
  -H HOST, --host HOST  host address [default 127.0.0.1]
  -p PORT, --port PORT  port to serve on [default 8000]
  -u UNIX, --unix UNIX  location of unix socket
  --cert CERT           location of certificate for SSL
  --key KEY             location of keyfile for SSL.
  -w WORKERS, --workers WORKERS
                        number of worker processes [default 1]
  --debug
  --access-logs         display access logs
  --no-access-logs      no display access logs
  -v, --version         show program&#39;s version number and exit</code></pre>
<p>Our standard form for running our applications right now will be:</p>
<pre><code>$ sanic src.server:app -p 7777 --debug --workers=2</code></pre>
<p>What thought went into the decision for using this command? Let’s take a look.</p>
<section id="why-src.serverapp" class="level4" data-number="3.2.2.1">
<h4 data-number="3.2.2.1">Why src.server:app?</h4>
<p>First, we are going to run this from the <code>./booktracker</code> directory. All of our code will be nested in a <code>src </code>directory.</p>
<p>Second, it is somewhat standard practice that our application creates a single <code>Sanic()</code> instance, and assigns it to a variable called <code>app</code>:</p>
<pre><code>app = Sanic(&quot;BookTracker&quot;)</code></pre>
<p>If we were to place that into a file called <code>app.py</code>, then our module and variable start to get confused.</p>
<pre><code>from app import app</code></pre>
<p>The above import statement is, well, ugly. As much as possible, it is beneficial to avoid naming conflicts between modules and the contents of that module.</p>
<p>A bad example of this exists in the standard library. Have you ever done this one by accident:</p>
<pre><code>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; datetime(2021, 1, 1)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: &#39;module&#39; object is not callable</code></pre>
<p>Oops, we should have used <code>from datetime import datetime</code>. We want to minimize the replication of module names and properties, and to make our imports easy to remember and intuitive to look at.</p>
<p>Therefore, we will place our global <code>app</code> variable into a file called <code>server.py</code>. Sanic will look for our app instance when you pass in the form: <code>&lt;module&gt;:&lt;variable&gt;</code>.</p>
</section>
<section id="why--p-7777" class="level4" data-number="3.2.2.2">
<h4 data-number="3.2.2.2">Why -p 7777?</h4>
<p>We, of course, could choose any arbitrary port here. Many web servers will use port <code>8000</code> and that is the Sanic default if we just left it out completely. However, precisely because it is standard, we want to choose something else. Often, it is beneficial to choose a port that is less likely to collide with other ports that might be running on your machine. The more we can preserve common ports, the less likely we will run into collisions.</p>
</section>
<section id="why---debug" class="level4" data-number="3.2.2.3">
<h4 data-number="3.2.2.3">Why --debug?</h4>
<p>While developing, having <code>DEBUG</code> mode enabled provides: a more verbose output from Sanic, and an auto-reloading server. It can be helpful to see more logs, but make sure you turn this off in production.</p>
<p>The auto-reloading feature is particularly beneficial because you can start writing your app in one window, and in a separate terminal session have it running. Then, every time that you make a change and save the application, Sanic will restart the server and immediately your new code is available for testing.</p>
<p>If you want the auto-reloading, but not all the extra verbosity, consider using <code>--auto-reload</code> instead.</p>
</section>
<section id="why---workers2" class="level4" data-number="3.2.2.4">
<h4 data-number="3.2.2.4">Why --workers=2?</h4>
<p>It is not an uncommon problem where someone begins to build an application and then realizes down the road that they have made a mistake by not preparing for horizontal scaling. Perhaps they added global state that cannot be accessed outside of a single process.</p>
<pre><code>sessions = set()
@app.route(&quot;/login&quot;)
async def login(request):
    new_session = await create_session(request)
    sessions.add(new_session)</code></pre>
<p>Oops, now that person needs to go back and re-engineer the solution if they want to scale up the application. This could be a costly endeavor. Luckily, we are smarter than that.</p>
<p>By forcing our development pattern to include multiple workers from the beginning, it will help remind us as we are solving problems that our application <em>must</em> account for scaling. Even if our ultimate deployment does not use multiple Sanic workers per instance (and instead, for example, uses multiple Kubernetes pods with single worker instances–see <em>Chapter 9, Best practices to improve your web applications</em>), this constant safeguard is a helpful way to keep the ultimate goal integral to the design process.</p>
</section>
</section>
<section id="directory-structure" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3">Directory Structure</h3>
<p>There are many different patterns you can follow for organizing a web application. Perhaps the simplest would be the single file <code>server.py</code> where all of your logic exists together. For obvious reasons, this is not a practical solution for larger, real world projects. So we will ignore that one.</p>
<p>What types of solutions are there? Perhaps we could use the “apps” structure that Django prefers where discrete portions of our application are grouped together into a single module. Or, perhaps you prefer to group by type, for example, by keeping all of your view controllers together. We make no judgments here about what is better for your needs, but we need to understand some consequences of our decisions.</p>
<p>When making a decision, you might want to learn some common practices. This might be a good opportunity to go look up some of the following patterns:</p>
<ul>
<li><strong>Model View Controller</strong> (<strong>MVC</strong>)</li>
<li><strong>Model View ViewModel</strong> (<strong>MVVM</strong>)</li>
<li><strong>Domain Driven Design</strong> (<strong>DDD</strong>)</li>
<li><strong>Clean Architecture</strong> (<strong>CA</strong>)</li>
</ul>
<p>Just to give you a flavor of the differences (or at least my interpretation of them), you might structure your project in one of the following ways:</p>
<p>You might use MVC:</p>
<pre><code>./booktracker
├── controllers
│   ├── book.py
│   └── author.py
├── models
│   ├── book.py
│   └── author.py
├── views
│   ├── static
│   └── templates
└── services</code></pre>
<p>Or you might use DDD:</p>
<pre><code>./booktracker
└── domains
    ├── author
    │   ├── view.py
    │   └── model.py
    ├── book
    │   ├── view.py
    │   └── model.py
    └── universal
        └── middleware.py</code></pre>
<p>In this book, we are going to adopt something that approximates a hybrid approach. There is a time and place for applying these theoretical constructs. I urge you to learn them. The information is useful. But we are here to learn <em>how</em> to practically go about building an application with Sanic.</p>
<p>Here’s the modified structure:</p>
<pre><code>./booktracker
├── blueprints
│   ├── author
│   │   ├── view.py
│   │   └── model.py
│   └── book
│       ├── view.py
│       └── model.py
├── middleware
│   └── thing.py
├── common
│   ├── utilities
│   └── base
└── server.py</code></pre>
<p>Let’s breakdown each of these to see what they might look like and understand the thought process behind this application design.</p>
<section id="blueprints" class="level4" data-number="3.2.3.1">
<h4 data-number="3.2.3.1">./blueprints</h4>
<p>This might strike you as odd since ultimately this directory looks like it contains more than just blueprints. And, you would be right. Looking at the tree, you see that “blueprints” includes both <code>view.py</code> and <code>model.py</code>. The goal of this directory is to separate your application into logical components, or domains. It functions much the same way as an <code>apps </code>directory might in a Django application. If you can isolate some construct or portion of your application as being a distinct entity, it should probably have a subfolder here.</p>
<p>A single module in this directory might contain models for validating incoming requests, utilities for fetching data from a database, and blueprints with attached route handlers. This keeps related code close together.</p>
<p>But why call it <code>blueprints</code>? Each subdirectory will contain much more than a single <code>Blueprint </code>object. The point is to reinforce the idea that everything in this directory resolves around one of these discrete components. The standard method for organization a so-called component in Sanic is the <code>Blueprint </code>(which we will more about in the next section). Therefore, each subdirectory will have one–and only one–<code>Blueprint </code>object.</p>
<p>Another important rule: <em>nothing</em> inside the <code>./bluprints</code> directory will reference our Sanic application. That means that both <code>Sanic.get_app()</code> and <code>from server import app</code> are forbidden inside this directory.</p>
<p>It is generally helpful to think of a blueprint as corresponding to a portion of your API design pattern.</p>
<ul>
<li><code>example.com/auth -&gt; ./blueprints/auth</code></li>
<li><code>example.com/cake -&gt; ./blueprints/cake</code></li>
<li><code>example.com/pie -&gt; ./blueprints/pie</code></li>
<li><code>example.com/user -&gt; ./blueprints/user</code></li>
</ul>
</section>
<section id="middleware" class="level4" data-number="3.2.3.2">
<h4 data-number="3.2.3.2">./middleware</h4>
<p>This directory should contain any middleware that is meant to be global in scope.</p>
<pre><code>@app.on_request
async def extract_user(request):
    user = await get_user_from_request(request)
    request.ctx.user = user</code></pre>
<p>As discussed later in this Chapter and in <em>Chapter 6, Outside the response cycle</em> and also at the Sanic User Guide (<a href="https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware">https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware</a>), middleware can be global or attach to blueprints. If you need to apply middleware to specific routes, perhaps blueprint based middleware makes sense. In this case, you should nest them in the appropriate <code>./blueprints</code> directory and not here.</p>
</section>
<section id="common" class="level4" data-number="3.2.3.3">
<h4 data-number="3.2.3.3">./common</h4>
<p>This module is meant to be a place to store class definitions and functions that will be used to build your application. It is for everything that will span your blueprints and be pervasive within your application.</p>
<blockquote>
<p><strong>TIP</strong></p>
<p>Try to expand upon the directory structure here to meet your needs. But, try not to add too many top level directories. If you start cluttering up your folders, think about how you might be able to nest directories inside one another. Usually you will find that this leads to a cleaner architecture. There is also such as thing as going too far with nesting. For example, if you need to navigate ten levels deep in your appication code, perhaps you should dial it back.</p>
</blockquote>
<p>It’s still Day 0. You still have a lot of great ideas in your head about what you want to build. And thanks to some thoughtful pre-planning, we now have an effective setup for building out application locally. At this point we should know how the application will run locally, and generally how the project will be organized. What we will learn next is the transition step from application structure to business logic.</p>
</section>
</section>
</section>
<section id="using-blueprints-effectively" class="level2" data-number="3.3">
<h2 data-number="3.3">Using Blueprints effectively</h2>
<p>If you already know what a blueprint is, imagine for a moment that you do not. As we are building out our application and trying to structure our code base in a logical and maintainable pattern, we realize that we need to constantly pass around our <code>app </code>object:</p>
<pre><code>from some.location import app
@app.route(&quot;/my/stuff&quot;)
async def stuff_handler(...):
    ...
@app.route(&quot;/my/profile&quot;)
async def profile_handler(...):
    ...</code></pre>
<p>This can become very tedious if we need to make changes to our endpoints. You can imagine a scenario where we would need to go update a bunch of separate files to duplicate the same change over and over again.</p>
<p>Perhaps more frustratingly, we might end up in a scenario where we have circular imports.</p>
<pre><code># server.py
from user import *
app = Sanic(...)
# user.py
from server import app
@app.route(&quot;/user&quot;)
...</code></pre>
<p>Blueprints solve both of these problems, and allow us to abstract away some content so that the component can stand on its own. Returning to the above example, we take the common part of the endpoints (<code>/my</code>) and add it to the <code>Blueprint </code>definition.</p>
<pre><code>from sanic import Blueprint
bp = Blueprint(&quot;MyInfo&quot;, url_prefix=&quot;/my&quot;)
@bp.route(&quot;/stuff&quot;)
async def stuff_handler(...):
    ...
@bp.route(&quot;/profile&quot;)
async def profile_handler(...):
    ...</code></pre>
<p>In this example, we were able to group these routes together into a single blueprint. Importantly, this allows us to pull common parts of the URL path (<code>/my</code>) to the <code>Blueprint</code>, which gives us flexibility to make changes in the future.</p>
<p>No matter how you decide to organize your file structure, you probably should always use blueprints. They make organization easier, and can even be nested. Personally, I will only ever use <code>@app.route</code> in the most trivial of web applications. For any <em>real</em> projects, I always attach routes to blueprints.</p>
<section id="blueprint-registration" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1">Blueprint registration</h3>
<p>Just creating our blueprints is not enough. Python would have no way to know they exist. We need to import our blueprints and attach them to our application. This is done through a simple registration method: <code>app.blueprint()</code>.</p>
<pre><code># server.py
from user import bp as user_bp
app = Sanic(...)
app.blueprint(user_bp)</code></pre>
<p>A common “gotcha” is misunderstanding what <code>blueprint</code> is doing. Something like this will not work as expected:</p>
<pre><code>from sanic import Sanic, Blueprint
app = Sanic(&quot;MyApp&quot;)
bp = Blueprint(&quot;MyBrokenBp&quot;)
app.blueprint(bp)
@bp.route(&quot;/oops&quot;)</code></pre>
<p>At the instant that we register a Blueprint, everything that was attached to it will reattach to the application. That means that anything added to the Blueprint <em>after</em> the call to <code>app.blueprint() </code>will not be applied. In the above example, <code>/oops</code> will not exist on the application. Therefore, you should try and register your blueprints as late as possible.</p>
<blockquote>
<p><strong>TIP</strong></p>
<p>I think it is super convenient to always name blueprint variables <code>bp</code>. When I open a file, I automatically know what <code>bp </code>means. Some people may find it helpful to name their variable more meaningful: <code>user_bp </code>or <code>auth_bp</code>. For me, I would rather keep them consistent in the files I am always looking at, and just rename them at import: <code>from user import bp as user_bp</code>.</p>
</blockquote>
</section>
<section id="blueprint-versioning" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2">Blueprint versioning</h3>
<p>A very powerful and common construct in API design is versioning. Let’s imagine that we are developing our book API that will be consumed by customers. They have already created their integrations, and perhaps they have been using the API for some time already.</p>
<p>You have some new business requirements, or new features you want to support. The only way to accomplish that is to change how a particular endpoint works. But, this will break backwards compatibility for the users. This is a dilemma.</p>
<p>API designers often solve this problem by versioning their routes. Sanic makes this easy by adding a keyword argument to a route definition, or (perhaps more usefully) a Blueprint.</p>
<p>You can learn more about versioning in the User Guide (<a href="https://sanicframework.org/en/guide/advanced/versioning.html">https://sanicframework.org/en/guide/advanced/versioning.html</a>) and we will discuss it in more depth in <em>Chapter 3, Routing and intaking HTTP requests</em>. For now, we will be content to know that our original API design needs a modification, and we will see how we can achieve that in the next section.</p>
</section>
<section id="grouping-blueprints" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3">Grouping blueprints</h3>
<p>As you begin to develop your applications, you might start to see similarities between blueprints. Just like we saw that we could pull common parts of routes out to the <code>Blueprint</code>, we can pull common parts of a <code>Blueprint </code>out into a <code>BlueprintGroup</code>. This provides the same purpose.</p>
<pre><code>from myinfo import bp as myinfo_bp
from somethingelse import bp as somethingelse_bp
from sanic import Blueprint
bp = Blueprint.group(myinfo_bp, somethingelse_bp, url_prefix=&quot;/api&quot;)</code></pre>
<p>We have now added <code>/api</code> to the beginning of every route path defined inside of <code>myinfo </code>and <code>somethingelse</code>.</p>
<p>By grouping blueprints, we are condensing our logic and becoming less repetitive. In the above example, by adding a prefix to the whole group, we no longer need to manage individual endpoints or even Blueprints. We really need to keep the nesting possibilities in mind as we design the layout of our endpoints and our project structure.</p>
<p>In the last section, we mentioned using versions to provide an easy path towards flexibly upgrading our API. Let’s go back to our book tracking application and see what this might look like. If you recall our application looked like this:</p>
<pre><code>./booktracker
└── blueprints
    ├── author
    │   └── view.py
    └── book
        └── view.py</code></pre>
<p>And the <code>view.py</code> files:</p>
<ul>
<li><code># ./blueprints/book/view.py</code></li>
<li><code>bp = Blueprint("book", url_prefix="/book")</code></li>
<li><code># ./blueprints/author/view.py</code></li>
<li><code>bp = Blueprint("author", url_prefix="/author")</code></li>
</ul>
<p>Let’s imagine the scenario where this API is already deployed and in use by customers when our new business requirements come in for a <code>/v2/books</code> route.</p>
<p>We add it to our existing architecture, and immediately it is starting to look ugly and messy:</p>
<pre><code>└── blueprints
    ├── author
    │   └── view.py
    ├── book
    │   └── view.py
    └── book_v2
        └── view.py</code></pre>
<p>Let’s re-factor this. We will not change <code>./blueprints/author </code>or <code>./blueprints/book</code>, just nest them a little deeper. That part of the application is already built and we do not want to touch it. But, now that we have learned from our mistake, we want to revise our strategy for <code>/v2</code> endpoints to look like this:</p>
<pre><code>└── blueprints
    ├── v1
    │   ├── author
    │   │   └── view.py
    │   ├── book
    │   │   └── view.py
    │   └── group.py
    └── v2
        ├── book
        │   └── view.py
        └── group.py</code></pre>
<p>We just created a new file, <code>group.py</code>:</p>
<pre><code># ./blurprints/v2/group.py
from .book.view import bp as book_bp
from sanic import Blueprint
group = Blueprint.group(book_bp, version=2)</code></pre>
<p>Grouping blueprints is a powerful concept when building complex APIs. It allows us to nest Blueprints as deep as we need to, while providing us with both routing and organizational control. In this example, notice how we were able to assign <code>version=2</code> to the group. This means now that every route attached to a Blueprint in this group will have a <code>/v2</code> path prefix.</p>
</section>
</section>
<section id="wiring-it-all-up" class="level2" data-number="3.4">
<h2 data-number="3.4">Wiring it all up</h2>
<p>As we have learned, creating a pragmatic directory structure leads to predictable and easy to navigate source code. Because it is predictable to us as developers, it is also predictable for computers to run. Perhaps we can use this to our advantage.</p>
<p>Earlier we discussed one of the problems we often encounter when trying to expand our application from the single file structure: circular imports. We can solve this well with our blueprints, but it still leaves us wondering about what to do with things that we might want to attach at the application level (such as middleware, listeners, and signals). Let’s take a look at those use cases now.</p>
<section id="controlled-imports" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1">Controlled imports</h3>
<p>It is generally preferred to break code up into modules using nested directories and files that helps us both logically think about our code, but also navigate to it. This does not come without a cost. What happens when there are two modules that are interdependent? This will cause a circular import exception, and our Python application will crash. We need to not only think about how to logically organize our code, but also how different parts of the code can be imported and used in other locations.</p>
<p>Consider the following example. First, create a file called <code>./server.py</code> like this:</p>
<pre><code>app = Sanic(__file__)</code></pre>
<p>Second, create a second file called <code>./services/db.py</code>.</p>
<pre><code>app = Sanic.get_app()
@app.before_server_start
async def setup_db_pool(app, _):
    ...</code></pre>
<p>This example illustrates the problem. When we run our application, we need <code>Sanic(__file__)</code> to run before <code>Sanic.get_app()</code>. But, we need to import <code>.services.db</code> so that it can attach to our application. Which file evaluates first? Since the Python interpreter will run instructions sequentially, we need to make sure that we instantiate the <code>Sanic()</code> object before importing the <code>db </code>module.</p>
<p>This will work:</p>
<pre><code>app = Sanic(__file__)
from .services.db import *</code></pre>
<p>But, it sort of looks ugly and non-Pythonic. Indeed, if you run tools like <code>flake8</code> you will start to notice that your environment does not really like this pattern so much either. It breaks the normal practice of placing imports at the top of the file. Learn more about this anti-pattern here: <a href="https://www.flake8rules.com/rules/E402.html">https://www.flake8rules.com/rules/E402.html</a>.</p>
<p>You may decide that you do not care, and that is perfectly okay. Remember, we are in this to find the solution that works for your application. Before we make the decision, however, let’s look at some other alternatives.</p>
<p>We could have a single “startup” file that will be a controlled set of import ordering:</p>
<pre><code># ./startup.py
from .server import app
from .services.db import *</code></pre>
<p>Now, instead of running <code>sanic server:app</code> we want to point our server to the new <code>startup.py</code>.</p>
<pre><code>sanic startup:app</code></pre>
<p>Let’s keep looking for an alternative.</p>
<blockquote>
<p><strong>TIP</strong></p>
<p>The <code>Sanic.get_app()</code> construct is a very useful pattern to get access to your app instance without having to pass it around by import. This is a very helpful step in the right direction, and you can learn more about it in the User Guide. https://sanicframework.org/en/guide/basics/app.html#app-registry</p>
</blockquote>
</section>
<section id="factory-pattern" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2">Factory pattern</h3>
<p>We are going to move our application creation into a factory pattern. You may be familiar with this if you come from Flask as many examples and tutorials use a similar construct. The main reason for doing this here is that we want to setup our application for good development practices in the future. It also will ultimately solve the circular import problem. Later on down the line in Chapter 9, we will talk about testing. In the absence of a nice factory, testing will become much more difficult.</p>
<p>We need to create a new file <code>./utilities/app_factory.py</code>, and redo our <code>./server.py</code>.</p>
<pre><code># ./utilities/app_factory.py
from typing import Optional, Sequence
from sanic import Sanic
from importlib import import_module
DEFAULT_BLUEPRINTS = [
    &quot;src.blueprints.v1.book.view&quot;,
    &quot;src.blueprints.v1.author.view&quot;,
    &quot;src.blueprints.v2.group&quot;,
]
def create_app(
    init_blueprints: Optional[Sequence[str]] = None,
) -&gt; Sanic:
    app = Sanic(&quot;BookTracker&quot;)
    if not init_blueprints:
        init_blueprints = DEFAULT_BLUEPRINTS
    for module_name in init_blueprints:
        module = import_module(module_name)
        app.blueprint(getattr(module, &quot;bp&quot;))
    return app
from .utilities.app_factory import create_app
app = create_app()</code></pre>
<p>As you can see, our new factory will create the <code>app </code>instance, and attach some blueprints to it. We specifically are allowing for the factory to override the blueprints that it will use. Perhaps this is unnecessary and we could instead hard-code them in all the time. But, I like the flexibility that this provides us, and find it helpful later on down the road when I want to start testing my application.</p>
<p>One problem that might jump out at you is that it requires our modules to have a global <code>bp</code> variable. While I mentioned that is standard practice for me, it might not work in all scenarios.</p>
</section>
<section id="autodiscovery" class="level3" data-number="3.4.3">
<h3 data-number="3.4.3">Autodiscovery</h3>
<p>The Sanic User Guide gives us another idea in the “How to…” section. See https://sanicframework.org/en/guide/how-to/autodiscovery.html. It suggests we create an <code>autodiscover</code> utility that will handle some of the importing for us, and also have the benefit of automatically attaching blueprints. Remember how I said I like predictable folder structures? We are about to take advantage of this pattern.</p>
<p>Let’s create <code>./utilities/autodiscovery.py</code>:</p>
<pre><code># ./utilities/autodiscovery.py
from importlib import import_module
from inspect import getmembers
from types import ModuleType
from typing import Union
from sanic.blueprints import Blueprint
def autodiscover(app, *module_names: Union[str, ModuleType]) -&gt; None:
    mod = app.__module__
    blueprints = set()
    def _find_bps(module: ModuleType) -&gt; None:
        nonlocal blueprints
        for _, member in getmembers(module):
            if isinstance(member, Blueprint):
                blueprints.add(member)
    for module in module_names:
        if isinstance(module, str):
            module = import_module(module, mod)
        _find_bps(module)
    for bp in blueprints:
        app.blueprint(bp)</code></pre>
<p>This file closely matches what the User Guide suggests (<a href="https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py">https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py</a>). Noticeably absent from the code presented there is the idea of recursion. If you look up the function in the User Guide, you will see that it includes the ability to recursively search through our source code looking for <code>Blueprint </code>instances. While convenient, in the application that we are building we want the express control provided by having to declare every blueprint’s location. Quoting Tim Peters, <em>The Zen of Python</em>, again:</p>
<p>Explicit is better than implicit.</p>
<p>What the autodiscover tool does is allow us to pass locations to modules, and hands the task of importing them over to the application. After loading the module, it will inspect it any Blueprints. The last thing it will handle is automatically registering the discovered Blueprints to our application instance.</p>
<p>Now, our <code>server.py</code> looks like this:</p>
<pre><code>from typing import Optional, Sequence
from sanic import Sanic
from .autodiscovery import autodiscover
DEFAULT_BLUEPRINTS = [
    &quot;src.blueprints.v1.book.view&quot;,
    &quot;src.blueprints.v1.author.view&quot;,
    &quot;src.blueprints.v2.group&quot;,
]
def create_app(
    init_blueprints: Optional[Sequence[str]] = None,
) -&gt; Sanic:
    app = Sanic(&quot;BookTracker&quot;)
    if not init_blueprints:
        init_blueprints = DEFAULT_BLUEPRINTS
    autodiscover(app, *init_blueprints)
    return app</code></pre>
<blockquote>
<p><strong>TIP</strong></p>
<p>In this example, we are using the import paths as strings. We just as easily could import the modules here, and pass those objects since the <code>autodiscover </code>utility works with both module objects and strings. We prefer strings though since it will keep the annoying circular import exceptions away.</p>
</blockquote>
<p>Another thing to keep in mind is that this autodiscover tool could be used for a module containing middleware or listeners. The given example is still fairly simplistic, and will not cover all use cases. How, for example, should we handle deeply nested Blueprint groups? This is a great opportunity for you to experiment, and I highly encourage you to spend some time playing with application structure and the autodiscover tool to figure out what works best for you.</p>
</section>
</section>
<section id="running-our-application" class="level2" data-number="3.5">
<h2 data-number="3.5">Running our application</h2>
<p>Now that we have laid our application foundations, we are almost ready to run our server. We are going to make one small change to <code>server.py</code> to include a small little utility to run at startup to show us what routes are registered.</p>
<pre><code>from .utilities.app_factory import create_app
from sanic.log import logger
app = create_app()
@app.main_process_start
def display_routes(app, _):
    logger.info(&quot;Registered routes:&quot;)
    for route in app.router.routes:
        logger.info(f&quot;&gt; /{route.path}&quot;)</code></pre>
<p>You can head over to the GitHub repository <a href="https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02">https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02</a> to see the full source code.</p>
<p>We can now start our application for the first time. Remember, this is going to be our pattern:</p>
<pre><code>$ sanic src.server:app -p 7777 --debug --workers=2</code></pre>
<p>We should see something like this:</p>
<pre><code>[2021-05-30 11:34:54 +0300] [36571] [INFO] Goin&#39; Fast @ http://127.0.0.1:7777
[2021-05-30 11:34:54 +0300] [36571] [INFO] Registered routes:
[2021-05-30 11:34:54 +0300] [36571] [INFO] &gt; /v2/book
[2021-05-30 11:34:54 +0300] [36571] [INFO] &gt; /book
[2021-05-30 11:34:54 +0300] [36571] [INFO] &gt; /author
[2021-05-30 11:34:54 +0300] [36572] [INFO] Starting worker [36572]
[2021-05-30 11:34:54 +0300] [36573] [INFO] Starting worker [36573]</code></pre>
<p>Hooray!</p>
<p>And now, for the tempting part. What does our code actually do? Head over to your favorite web browser and open: <a href="http://127.0.0.1:7777/book">http://127.0.0.1:7777/book</a>. It might not be much to look at yet, but you should see some JSON data. Next, try going to <code>/author </code>and <code>/v2/book</code>. You should now see the content that we created above. Feel free to play around with these routes adding to them. Every time you do, you should see your changes reflected in the web browser.</p>
<p>Our journey into web application development as officially begun.</p>
</section>
<section id="summary-1" class="level2" data-number="3.6">
<h2 data-number="3.6">Summary</h2>
<p>We have looked at the important impact of some of the early decisions we make about setting up our environment and project organization. We can—and should—constantly adapt our environment and application to meet changing needs. We used <code>pdm </code>to leverage some of the newest tools for running our server in a well-defined and isolated environment.</p>
<p>In our example, we then started to build our application. Perhaps we were too hasty when we added our <code>/book</code> route, because we quickly realized that we needed the endpoint to perform differently. Rather than breaking the application for existing users, we simply created a new group of blueprints that will be the beginning of a <code>/v2</code> of our API. By nesting and grouping blueprints, we are setting the application up for future flexibility and development maintainability. Going forward, let’s stick to this pattern as much as possible.</p>
<p>We also examined a few alternative approaches for organizing our application logic. These early decisions will impact the import ordering and shape the look of the application. We decided to adopt a factory method that will help us in the future when we start to test the application.</p>
<p>With the basic application structure decided, we will begin in the next chapter to explore the most important aspect of a web server and framework: handling the request/response cycle. We know that we will use blueprints, but it is time to dive in and look more closely at what we can do with Sanic routing and handlers. In this chapter, there was a taste of it with API versioning. In the next chapter we will also look at routing more generally, and try to understand some strategies for designing application logic within a web API.</p>
</section>
</section>
</body>
</html>
