["```py\ntozo\n└── backend\n    ├── src\n    │   └── backend\n    │       ├── migrations\n    │       └── models\n    └── tests\n        └── models\n```", "```py\nCREATE TABLE members (\n    id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n    created TIMESTAMP NOT NULL DEFAULT now(),\n    email TEXT NOT NULL,\n    email_verified TIMESTAMP,\n    password_hash TEXT NOT NULL\n);\n\nCREATE UNIQUE INDEX members_unique_email_idx on members (LOWER(email));\n```", "```py\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass Member:\n    id: int\n    email: str\n    password_hash: str\n    created: datetime\n    email_verified: datetime | None\n```", "```py\nfrom quart_db import Connection\n\nasync def select_member_by_email(\n    db: Connection, email: str\n) -> Member | None:\n    result = await db.fetch_one(\n        \"\"\"SELECT id, email, password_hash, created,                  email_verified\n             FROM members\n            WHERE LOWER(email) = LOWER(:email)\"\"\",\n        {\"email\": email},\n    )\n    return None if result is None else Member(**result)\n\nasync def select_member_by_id(\n    db: Connection, id: int\n) -> Member | None:\n    result = await db.fetch_one(\n        \"\"\"SELECT id, email, password_hash, created,                  email_verified\n             FROM members\n            WHERE id = :id\"\"\",\n        {\"id\": id},\n    )\n    return None if result is None else Member(**result)\n```", "```py\nasync def insert_member(\n    db: Connection, email: str, password_hash: str\n) -> Member:\n    result = await db.fetch_one(\n        \"\"\"INSERT INTO members (email, password_hash)\n                VALUES (:email, :password_hash)\n             RETURNING id, email, password_hash, created,\n                       email_verified\"\"\",\n        {\"email\": email, \"password_hash\": password_hash},\n    )\n    return Member(**result)\n\nasync def update_member_password(\n    db: Connection, id: int, password_hash: str\n) -> None:\n    await db.execute(\n        \"\"\"UPDATE members \n              SET password_hash = :password_hash \n            WHERE id = :id\"\"\",\n        {\"id\": id, \"password_hash\": password_hash},\n    )\n\nasync def update_member_email_verified(\n    db: Connection, id: int\n) -> None:\n    await db.execute(\n        \"UPDATE members SET email_verified = now() WHERE id = :id\",\n        {\"id\": id},\n    )\n```", "```py\nimport pytest\nfrom asyncpg.exceptions import UniqueViolationError  # type: ignore\nfrom quart_db import Connection\nfrom backend.models.member import insert_member\nasync def test_insert_member(connection: Connection) -> None:\n    await insert_member(connection, \"casing@tozo.dev\", \"\")\n    with pytest.raises(UniqueViolationError):\n        await insert_member(connection, \"Casing@tozo.dev\", \"\")\n```", "```py\nfrom backend.models.member import select_member_by_email\nasync def test_select_member_by_email (connection: Connection) -> None:\n    await insert_member(connection, \"casing@tozo.dev\", \"\")\n    member = await select_member_by_email(\n        connection, \"Casing@tozo.dev\"\n    )\n    assert member is not None\n```", "```py\nCREATE TABLE todos (\n    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n    complete BOOLEAN NOT NULL DEFAULT FALSE,\n    due TIMESTAMPTZ,\n    member_id INT NOT NULL REFERENCES members(id),\n    task TEXT NOT NULL\n);\n```", "```py\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pydantic import constr\n\n@dataclass\nclass Todo:\n    complete: bool\n    due: datetime | None\n    id: int\n    task: constr(strip_whitespace=True, min_length=1)  # type: ignore\n```", "```py\nfrom quart_db import Connection\nasync def select_todos(\n    connection: Connection, \n    member_id: int, \n    complete: bool | None = None,\n) -> list[Todo]:\n    if complete is None:\n        query = \"\"\"SELECT id, complete, due, task\n                     FROM todos\n                    WHERE member_id = :member_id\"\"\"\n        values = {\"member_id\": member_id}\n    else:\n        query = \"\"\"SELECT id, complete, due, task\n                     FROM todos\n                    WHERE member_id = :member_id \n                          AND complete = :complete\"\"\"\n        values = {\"member_id\": member_id, \"complete\": complete}\n    return [\n        Todo(**row) \n        async for row in connection.iterate(query, values)\n    ]\nasync def select_todo(\n    connection: Connection, id: int, member_id: int,\n) -> Todo | None:\n    result = await connection.fetch_one(\n        \"\"\"SELECT id, complete, due, task\n             FROM todos\n            WHERE id = :id AND member_id = :member_id\"\"\",\n        {\"id\": id, \"member_id\": member_id},\n    )\n    return None if result is None else Todo(**result)\n```", "```py\nasync def insert_todo(\n    connection: Connection, \n    member_id: int,\n    task: str,\n    complete: bool,\n    due: datetime | None, \n) -> Todo:\n    result = await connection.fetch_one(\n        \"\"\"INSERT INTO todos (complete, due, member_id, task)\n                VALUES (:complete, :due, :member_id, :task)\n             RETURNING id, complete, due, task\"\"\",\n        {\n            \"member_id\": member_id, \n            \"task\": task, \n            \"complete\": complete, \n            \"due\": due,\n        },\n    )\n    return Todo(**result)\nasync def update_todo(\n    connection: Connection, \n    id: int, \n    member_id: int,\n    task: str,\n    complete: bool,\n    due: datetime | None,\n) -> Todo | None:\n    result = await connection.fetch_one(\n        \"\"\"UPDATE todos\n              SET complete = :complete, due = :due, \n                  task = :task\n            WHERE id = :id AND member_id = :member_id\n        RETURNING id, complete, due, task\"\"\",\n        {\n            \"id\": id,\n            \"member_id\": member_id, \n            \"task\": task, \n            \"complete\": complete, \n            \"due\": due,\n        },\n    )\n    return None if result is None else Todo(**result)\n\nasync def delete_todo(\n    connection: Connection, id: int, member_id: int,\n) -> None:\n    await connection.execute(\n        \"DELETE FROM todos WHERE id = :id AND member_id = :member_id\",\n        {\"id\": id, \"member_id\": member_id},\n    )\n```", "```py\nimport pytest\nfrom quart_db import Connection\nfrom backend.models.todo import (\n    delete_todo, insert_todo, select_todo, update_todo\n)\n@pytest.mark.parametrize(\n    \"member_id, deleted\",\n    [(1, True), (2, False)],\n)\nasync def test_delete_todo(\n    connection: Connection, member_id: int, deleted: bool\n) -> None:\n    todo = await insert_todo(        connection, 1, \"Task\", False, None     )\n    await delete_todo(connection, todo.id, member_id)\n    new_todo = await select_todo(connection, todo.id, 1)\n    assert (new_todo is None) is deleted\n```", "```py\n@pytest.mark.parametrize(\n    \"member_id, complete\",\n    [(1, True), (2, False)],\n)\nasync def test_update_todo(\n    connection: Connection, member_id: int, complete: bool\n) -> None:\n    todo = await insert_todo(        connection, 1, \"Task\", False, None     )\n    await update_todo(\n        connection, todo.id, member_id, \"Task\", True, None\n    )\n    new_todo = await select_todo(connection, todo.id, 1)\n    assert new_todo is not None\n    assert new_todo.complete is complete\n```", "```py\nfrom quart_db import Connection\n\nasync def migrate(connection: Connection) -> None:\n    await connection.execute(\n        \"\"\"CREATE TABLE members (\n               id INT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n               created TIMESTAMP NOT NULL DEFAULT now(),\n               email TEXT NOT NULL,\n               email_verified TIMESTAMP,\n               password_hash TEXT NOT NULL\n           )\"\"\",\n    )\n    await connection.execute(\n        \"\"\"CREATE UNIQUE INDEX members_unique_email_idx \n                            ON members (LOWER(email)\n        )\"\"\"\n    )\n    await connection.execute(\n        \"\"\"CREATE TABLE todos (\n               id BIGINT PRIMARY KEY GENERATED ALWAYS AS                  IDENTITY,\n               complete BOOLEAN NOT NULL DEFAULT FALSE,\n               due TIMESTAMPTZ,\n               member_id INT NOT NULL REFERENCES members(id),\n               task TEXT NOT NULL\n           )\"\"\",\n    )\nasync def valid_migration(connection: Connection) -> bool:\n    return True\n```", "```py\nfrom quart_db import Connection \n\nasync def execute(connection: Connection) -> None:\n    await connection.execute(\n        \"\"\"INSERT INTO members (email, password_hash)\n                VALUES ('member@tozo.dev', '$2b$14$6yXjNza30kPCg3LhzZJfqeCWOLM.zyTiQFD4rdWlFHBTfYzzKJMJe'\n           )\"\"\"\n    )\n    await connection.execute(\n        \"\"\"INSERT INTO todos (member_id, task)\n                VALUES (1, 'Test Task')\"\"\"\n    )\n```", "```py\nTOZO_QUART_DB_DATA_PATH=\"migrations/data.py\"\n```", "```py\npdm run test\n```", "```py\nfrom quart import Blueprint\nblueprint = Blueprint(\"sessions\", __name__)\n```", "```py\nfrom backend.blueprints.sessions import blueprint as sessions_blueprint\napp.register_blueprint(sessions_blueprint)\n```", "```py\nfrom dataclasses import dataclass\nfrom datetime import timedelta\n\nimport bcrypt\nfrom pydantic import EmailStr\nfrom quart import g, ResponseReturnValue\nfrom quart_auth import AuthUser, login_user\nfrom quart_rate_limiter import rate_limit\nfrom quart_schema import validate_request\n\nfrom backend.lib.api_error import APIError\nfrom backend.models.member import select_member_by_email\n\n@dataclass\nclass LoginData:\n    email: EmailStr\n    password: str\n    remember: bool = False\n\n@blueprint.post(\"/sessions/\")\n@rate_limit(5, timedelta(minutes=1))\n@validate_request(LoginData)\nasync def login(data: LoginData) -> ResponseReturnValue:\n    \"\"\"Login to the app.\n\n    By providing credentials and then saving the     returned cookie.\n    \"\"\"\n    result = await select_member_by_email(        g.connection, data.email     )\n    if result is None:\n        raise APIError(401, \"INVALID_CREDENTIALS\")\n    passwords_match = bcrypt.checkpw(\n        data.password.encode(\"utf-8\"),\n        result.password_hash.encode(\"utf-8\"),\n    )\n    if passwords_match:\n        login_user(AuthUser(str(result.id)), data.remember)\n        return {}, 200\n    else:\n        raise APIError(401, \"INVALID_CREDENTIALS\")\n```", "```py\nfrom quart_auth import logout_user\nfrom quart_rate_limiter import rate_exempt\n\n@blueprint.delete(\"/sessions/\")\n@rate_exempt\nasync def logout() -> ResponseReturnValue:\n    \"\"\"Logout from the app.\n\n    Deletes the session cookie.\n    \"\"\"\n    logout_user()\n    return {}\n```", "```py\nfrom quart_auth import current_user, login_required\nfrom quart_schema import validate_response\n\n@dataclass\nclass Status:\n    member_id: int\n\n@blueprint.get(\"/sessions/\")\n@rate_limit(10, timedelta(minutes=1))\n@login_required\n@validate_response(Status)\nasync def status() -> ResponseReturnValue:\n    assert current_user.auth_id is not None  # nosec\n    return Status(member_id=int(current_user.auth_id))\n```", "```py\nfrom quart import Quart\n\nasync def test_session_flow(app: Quart) -> None:\n    test_client = app.test_client()\n    await test_client.post(\n        \"/sessions/\",\n        json={\n            \"email\": \"member@tozo.dev\", \"password\": \"password\"\n        },\n    )\n    response = await test_client.get(\"/sessions/\")\n    assert (await response.get_json())[\"memberId\"] == 1\n    await test_client.delete(\"/sessions/\")\n    response = await test_client.get(\"/sessions/\")\n    assert response.status_code == 401\n```", "```py\nasync def test_login_invalid_password(app: Quart) -> None:\n    test_client = app.test_client()\n    await test_client.post(\n        \"/sessions/\",\n        json={\n            \"email\": \"member@tozo.dev\", \"password\": \"incorrect\"\n        },\n    )\n    response = await test_client.get(\"/sessions/\")\n    assert response.status_code == 401\n```", "```py\nfrom quart import Blueprint\nblueprint = Blueprint(\"members\", __name__)\n```", "```py\nfrom backend.blueprints.members import blueprint as members_blueprint\napp.register_blueprint(members_blueprint)\n```", "```py\n{% extends \"email.xhtml\" %}\n{% block welcome %}\n  Hello and welcome to tozo!\n{% endblock %}\n{% block content %}\n  Please confirm you signed up by following this \n  <a href=\"{{ config['BASE_URL'] }}/confirm-email/{{ token }}/\">\n    link\n  </a>.\n{% endblock %}\n```", "```py\nfrom dataclasses import dataclass\nfrom datetime import timedelta\n\nimport asyncpg  # type: ignore\nimport bcrypt\nfrom itsdangerous import URLSafeTimedSerializer\nfrom quart import current_app, g, ResponseReturnValue\nfrom quart_schema import validate_request\nfrom quart_rate_limiter import rate_limit\nfrom zxcvbn import zxcvbn  # type: ignore\n\nfrom backend.lib.api_error import APIError\nfrom backend.lib.email import send_email\nfrom backend.models.member import insert_member\n\nMINIMUM_STRENGTH = 3\nEMAIL_VERIFICATION_SALT = \"email verify\"\n\n@dataclass\nclass MemberData:\n    email: str\n    password: str\n\n@blueprint.post(\"/members/\")\n@rate_limit(10, timedelta(seconds=10))\n@validate_request(MemberData)\nasync def register(data: MemberData) -> ResponseReturnValue:\n    \"\"\"Create a new Member.\n\n    This allows a Member to be created.\n    \"\"\"\n    strength = zxcvbn(data.password)\n    if strength[\"score\"] < MINIMUM_STRENGTH:\n        raise APIError(400, \"WEAK_PASSWORD\")\n\n    hashed_password = bcrypt.hashpw(\n        data.password.encode(\"utf-8\"), \n        bcrypt.gensalt(14),\n    )\n    try:\n        member = await insert_member(\n            g.connection, \n            data.email, \n            hashed_password.decode(),\n        )\n    except asyncpg.exceptions.UniqueViolationError:\n        pass\n    else:\n        serializer = URLSafeTimedSerializer(\n            current_app.secret_key,             salt=EMAIL_VERIFICATION_SALT,\n        )\n        token = serializer.dumps(member.id)\n        await send_email(\n            member.email, \n            \"Welcome\", \n            \"welcome.xhtml\", \n            {\"token\": token},\n        )\n    return {}, 201\n```", "```py\nfrom itsdangerous import BadSignature, SignatureExpired \nfrom backend.models.member import update_member_email_verified\nONE_MONTH = int(timedelta(days=30).total_seconds()) \n\n@dataclass\nclass TokenData:\n    token: str\n\n@blueprint.put(\"/members/email/\")\n@rate_limit(5, timedelta(minutes=1))\n@validate_request(TokenData)\nasync def verify_email(data: TokenData) -> ResponseReturnValue:\n    \"\"\"Call to verify an email.\n\n    This requires the user to supply a valid token.\n    \"\"\"\n    serializer = URLSafeTimedSerializer(\n        current_app.secret_key, salt=EMAIL_VERIFICATION_SALT\n    )\n    try:\n        member_id = serializer.loads(            data.token, max_age=ONE_MONTH         )\n    except SignatureExpired:\n        raise APIError(403, \"TOKEN_EXPIRED\")\n    except BadSignature:\n        raise APIError(400, \"TOKEN_INVALID\")\n    else:\n        await update_member_email_verified(g.connection,          member_id)\n    return {} \n```", "```py\n{% extends \"email.xhtml\" %}\n\n{% block content %}\n  Your Tozo password has been successfully changed.\n{% endblock %}\n```", "```py\nfrom typing import cast\nfrom quart_auth import current_user, login_required\nfrom backend.models.member import select_member_by_id, update_member_password\n\n@dataclass\nclass PasswordData:\n    current_password: str\n    new_password: str\n\n@blueprint.put(\"/members/password/\")\n@rate_limit(5, timedelta(minutes=1))\n@login_required\n@validate_request(PasswordData)\nasync def change_password(data: PasswordData) -> ResponseReturnValue:\n    \"\"\"Update the members password.\n\n    This allows the user to update their password.\n    \"\"\"\n    strength = zxcvbn(data.new_password)\n    if strength[\"score\"] < MINIMUM_STRENGTH:\n        raise APIError(400, \"WEAK_PASSWORD\")\n\n    member_id = int(cast(str, current_user.auth_id))\n    member = await select_member_by_id(\n        g.connection, member_id\n    )\n    assert member is not None  # nosec\n    passwords_match = bcrypt.checkpw(\n        data.current_password.encode(\"utf-8\"),\n        member.password_hash.encode(\"utf-8\"),\n    )\n    if not passwords_match:\n        raise APIError(401, \"INVALID_PASSWORD\")\n\n    hashed_password = bcrypt.hashpw(\n        data.new_password.encode(\"utf-8\"),\n        bcrypt.gensalt(14),\n    )\n    await update_member_password(\n        g.connection, member_id, hashed_password.decode()\n    )\n    await send_email(\n        member.email, \n        \"Password changed\", \n        \"password_changed.xhtml\", \n        {},\n    )\n    return {}\n```", "```py\n{% extends \"email.xhtml\" %}\n{% block content %}\n  You can use this \n  <a href=\"{{ config['BASE_URL'] }}/reset-password/{{ token     }}/\">\n    link\n  </a> \n  to reset your password.\n{% endblock %}\n```", "```py\nfrom pydantic import EmailStr\nfrom backend.models.member import select_member_by_email\n\nFORGOTTEN_PASSWORD_SALT = \"forgotten password\"  # nosec\n\n@dataclass\nclass ForgottenPasswordData:\n    email: EmailStr\n\n@blueprint.put(\"/members/forgotten-password/\")\n@rate_limit(5, timedelta(minutes=1))\n@validate_request(ForgottenPasswordData)\nasync def forgotten_password(data: ForgottenPasswordData) -> ResponseReturnValue:\n    \"\"\"Call to trigger a forgotten password email.\n\n    This requires a valid member email.\n    \"\"\"\n    member = await select_member_by_email(        g.connection, data.email     )\n    if member is not None:\n        serializer = URLSafeTimedSerializer(\n            current_app.secret_key,             salt=FORGOTTEN_PASSWORD_SALT,\n        )\n        token = serializer.dumps(member.id)\n        await send_email(\n            member.email, \n            \"Forgotten password\", \n            \"forgotten_password.xhtml\", \n            {\"token\": token},\n        )\n    return {}\n```", "```py\nONE_DAY = int(timedelta(hours=24).total_seconds())\n@dataclass\nclass ResetPasswordData:\n    password: str\n    token: str\n\n@blueprint.put(\"/members/reset-password/\")\n@rate_limit(5, timedelta(minutes=1))\n@validate_request(ResetPasswordData)\nasync def reset_password(data: ResetPasswordData) -> ResponseReturnValue:\n    \"\"\"Call to reset a password using a token.\n\n    This requires the user to supply a valid token and a\n    new password.\n    \"\"\"\n    serializer = URLSafeTimedSerializer(\n        current_app.secret_key, salt=FORGOTTEN_PASSWORD_SALT\n    )\n    try:\n        member_id = serializer.loads(data.token, max_age=ONE_          DAY)\n    except SignatureExpired:\n        raise APIError(403, \"TOKEN_EXPIRED\")\n    except BadSignature:\n        raise APIError(400, \"TOKEN_INVALID\")\n    else:\n        strength = zxcvbn(data.password)\n        if strength[\"score\"] < MINIMUM_STRENGTH:\n            raise APIError(400, \"WEAK_PASSWORD\")\n\n        hashed_password = bcrypt.hashpw(\n            data.password.encode(\"utf-8\"), \n            bcrypt.gensalt(14),\n        )\n        await update_member_password(\n            g.connection, member_id, hashed_password.decode()\n        )\n        member = await select_member_by_id(\n            g.connection, int(cast(str, current_user.auth_id))\n        )\n        assert member is not None  # nosec\n        await send_email(\n            member.email, \n            \"Password changed\", \n            \"password_changed.xhtml\", \n            {},\n        )\n    return {}\n```", "```py\nimport pytest\nfrom quart import Quart\n\nasync def test_register(\n    app: Quart, caplog: pytest.LogCaptureFixture \n) -> None:\n    test_client = app.test_client()\n    data = {\n        \"email\": \"new@tozo.dev\", \n        \"password\": \"testPassword2$\",\n    }\n    await test_client.post(\"/members/\", json=data)\n    response = await test_client.post(\"/sessions/\", json=data)\n    assert response.status_code == 200\n    assert \"Sending welcome.xhtml to new@tozo.dev\" in caplog.text\n```", "```py\nfrom itsdangerous import URLSafeTimedSerializer\nfrom freezegun import freeze_time\nfrom backend.blueprints.members import EMAIL_VERIFICATION_SALT\n@pytest.mark.parametrize(\n    \"time, expected\",\n    [(\"2022-01-01\", 403), (None, 200)],\n)\nasync def test_verify_email(\n    app: Quart, time: str | None, expected: int\n) -> None:\n    with freeze_time(time):\n        signer = URLSafeTimedSerializer(\n            app.secret_key, salt= EMAIL_VERIFICATION_SALT\n        )\n        token = signer.dumps(1)\n    test_client = app.test_client()\n    response = await test_client.put(\n        \"/members/email/\", json={\"token\": token}\n    )\n    assert response.status_code == expected\nasync def test_verify_email_invalid_token(app: Quart) -> None:\n    test_client = app.test_client()\n    response = await test_client.put( \n        \"/members/email/\", json={\"token\": \"invalid\"} \n    ) \n    assert response.status_code == 400\n```", "```py\nasync def test_change_password(\n    app: Quart, caplog: pytest.LogCaptureFixture \n) -> None:\n    test_client = app.test_client()\n    data = {\n        \"email\": \"new_password@tozo.dev\", \n        \"password\": \"testPassword2$\",\n    }\n    response = await test_client.post(\"/members/\", json=data)\n    async with test_client.authenticated(\"2\"):  # type: ignore\n        response = await test_client.put(\n            \"/members/password/\", \n            json={\n                \"currentPassword\": data[\"password\"], \n                \"newPassword\": \"testPassword3$\",\n            }\n        )\n        assert response.status_code == 200\n    assert \"Sending password_changed.xhtml to new@tozo.dev\" in caplog.text\n```", "```py\nasync def test_forgotten_password(\n    app: Quart, caplog: pytest.LogCaptureFixture \n) -> None:\n    test_client = app.test_client()\n    data = {\"email\": \"member@tozo.dev\"}\n    response = await test_client.put(\n        \"/members/forgotten-password/\", json=data\n    )\n    assert response.status_code == 200\n    assert \"Sending forgotten_password.xhtml to member@tozo.dev\" in caplog.text\n```", "```py\nfrom quart import Blueprint\nblueprint = Blueprint(\"todos\", __name__)\n```", "```py\nfrom backend.blueprints.todos import blueprint as todos_blueprint\napp.register_blueprint(todos_blueprint)\n```", "```py\nfrom dataclasses import dataclass \nfrom datetime import datetime, timedelta\nfrom typing import cast\n\nfrom quart import g\nfrom quart_auth import current_user, login_required\nfrom quart_schema import validate_request, validate_response\nfrom quart_rate_limiter import rate_limit\n\nfrom backend.models.todo import insert_todo, Todo\n@dataclass\nclass TodoData:\n    complete: bool\n    due: datetime | None\n    task: str\n\n@blueprint.post(\"/todos/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\n@validate_request(TodoData)\n@validate_response(Todo, 201)\nasync def post_todo(data: TodoData) -> tuple[Todo, int]:\n    \"\"\"Create a new Todo.\n\n    This allows todos to be created and stored.\n    \"\"\"\n    todo = await insert_todo(\n        g.connection, \n        int(cast(str, current_user.auth_id)),\n        data.task,\n        data.complete,\n        data.due,\n    )\n    return todo, 201\n```", "```py\nfrom backend.lib.api_error import APIError\nfrom backend.models.todo import select_todo\n\n@blueprint.get(\"/todos/<int:id>/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\n@validate_response(Todo)\nasync def get_todo(id: int) -> Todo:\n    \"\"\"Get a todo.\n\n    Fetch a Todo by its ID.\n    \"\"\"\n    todo = await select_todo(\n        g.connection, id, int(cast(str, current_user.auth_id))\n    )\n    if todo is None:\n        raise APIError(404, \"NOT_FOUND\")\n    else:\n        return todo\n```", "```py\nfrom quart_schema import validate_querystring\n\nfrom backend.models.todo import select_todos\n\n@dataclass\nclass Todos:\n    todos: list[Todo]\n\n@dataclass\nclass TodoFilter:\n    complete: bool | None = None\n\n@blueprint.get(\"/todos/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\n@validate_response(Todos)\n@validate_querystring(TodoFilter)\nasync def get_todos(query_args: TodoFilter) -> Todos:\n    \"\"\"Get the todos.\n\n    Fetch all the Todos optionally based on the     complete status.\n    \"\"\"\n    todos = await select_todos(\n        g.connection, \n        int(cast(str, current_user.auth_id)), \n        query_args.complete,\n    )\n    return Todos(todos=todos)\n```", "```py\nfrom backend.models.todo import update_todo\n\n@blueprint.put(\"/todos/<int:id>/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\n@validate_request(TodoData)\n@validate_response(Todo)\nasync def put_todo(id: int, data: TodoData) -> Todo:\n    \"\"\"Update the identified todo\n\n    This allows the todo to be replaced with the request data.\n    \"\"\"\n    todo = await update_todo(\n        g.connection, \n        id,  \n        int(cast(str, current_user.auth_id)),\n        data.task,\n        data.complete,\n        data.due,\n    )\n    if todo is None:\n        raise APIError(404, \"NOT_FOUND\")\n    else:\n        return todo\n```", "```py\nfrom quart import ResponseReturnValue\n\nfrom backend.models.todo import delete_todo\n\n@blueprint.delete(\"/todos/<int:id>/\")\n@rate_limit(10, timedelta(seconds=10))\n@login_required\nasync def todo_delete(id: int) -> ResponseReturnValue:\n    \"\"\"Delete the identified todo\n\n    This will delete the todo.\n    \"\"\"\n    await delete_todo(\n        g.connection, id, int(cast(str, current_user.auth_id))\n    )\n    return \"\", 202\n```", "```py\nfrom quart import Quart\n\nasync def test_post_todo(app: Quart) -> None:\n    test_client = app.test_client()\n    async with test_client.authenticated(\"1\"):  # type: ignore\n        response = await test_client.post(\n            \"/todos/\", \n            json={\n                \"complete\": False, \"due\": None, \"task\": \"Test                    task\"\n            },\n        )\n        assert response.status_code == 201\n        assert (await response.get_json())[\"id\"] > 0\n```", "```py\nasync def test_get_todo(app: Quart) -> None:\n    test_client = app.test_client()\n    async with test_client.authenticated(\"1\"):  # type: ignore\n        response = await test_client.get(\"/todos/1/\")\n        assert response.status_code == 200\n        assert (await response.get_json())[\"task\"] == \"Test           Task\"\n```", "```py\nasync def test_put_todo(app: Quart) -> None: \n    test_client = app.test_client() \n    async with test_client.authenticated(\"1\"):  # type: ignore    \n        response = await test_client.post( \n            \"/todos/\",  \n            json={ \n                \"complete\": False, \"due\": None, \"task\": \"Test                    task\"\n            }, \n        )\n        todo_id = (await response.get_json())[\"id\"]\n        response = await test_client.put(\n            f\"/todos/{todo_id}/\",\n            json={\n                \"complete\": False, \"due\": None, \"task\":                   \"Updated\"\n            },  \n        )\n        assert (await response.get_json())[\"task\"] == \"Updated\"\n        response = await test_client.get(f\"/todos/{todo_id}/\")\n        assert (await response.get_json())[\"task\"] == \"Updated\"\n```", "```py\nasync def test_delete_todo(app: Quart) -> None:  \n    test_client = app.test_client()  \n    async with test_client.authenticated(\"1\"):  # type: ignore     \n        response = await test_client.post(  \n            \"/todos/\",   \n            json={  \n                \"complete\": False, \"due\": None, \"task\": \"Test                   task\"\n            },  \n        ) \n        todo_id = (await response.get_json())[\"id\"]\n        await test_client.delete(f\"/todos/{todo_id}/\")\n        response = await test_client.get(f\"/todos/{todo_id}/\")\n        assert response.status_code == 404\n```"]