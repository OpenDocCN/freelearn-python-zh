- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up a React Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focuses on the React library and discusses the important topics
    and features that you should be aware of so that you can create a very simple
    React app, really just a frontend. In this chapter, you will learn about the main
    features and the most salient concepts of React.
  prefs: []
  type: TYPE_NORMAL
- en: You will begin with the prerequisites and tools, such as Node.js, some Visual
    Studio Code extensions, and more. You will also learn how to use the new standard
    and recommended build tool called **Vite**. Compared to **Create React App**,
    Vite is more efficient and allows for fast **hot module replacement** (**HMR**)
    and on-demand file serving, without the need for bundling. Bundling is the process
    of combining and joining multiple JavaScript files into a single file, reducing
    the number of HTTP requests needed to load the page. HMR, on the other hand, allows
    for the updating of single modules while the application is running, in real time.
  prefs: []
  type: TYPE_NORMAL
- en: You will design a simple application with a few components and see how decoupling
    helps you write modular and maintainable code. This chapter covers two of the
    most important React Hooks and how they solve some common web development problems.
    However, the main objective of this chapter is to discuss the tools needed to
    be able to explore React and its various functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a simple but fully functional React
    web app. The concepts in this chapter will prepare you to be a frontend developer
    who values relatively simple tools to be able to achieve complex functionalities,
    without being confined within a strict framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to React and how to use Vite to create React apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling techniques with Tailwind CSS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functional components and JSX, the language of React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `useState` and `useEffect` Hooks for state management and API
    communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features of React Router and other packages within the React ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a React-based application involves several steps, including setting
    up a build system and a transpiler, creating a directory structure, and more.
    You must install the following tools before you start developing your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vite**: Vite requires Node.js versions 18+ or 20+ in order to run, but you
    can always check the documentation at [https://vitejs.dev](https://vitejs.dev)
    for updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js**:You can download Node.js for your operating system from[https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    When installing, check all the boxes – you want **npm** (**Node.js’ package manager**)
    and optional additional command-line tools if you are on a Windows machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: Install a React extension called **ES7+ React/Redux/React-Native
    snippets** to help speed up the creation of components of a React app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React Developer Tools** : Install the React Developer Tools browser extension
    ([https://react.dev/learn/react-developer-tools](https://react.dev/learn/react-developer-tools)).
    This enables debugging your React apps quicker and spotting potential problems
    easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a React app using Vite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is a JavaScript library for building **user interfaces** (**UIs**), particularly
    for **single-page applications** (**SPAs**) but also for traditional server-side-rendered
    applications. It offers reusable UI components that are able to manage their own
    state, allowing for the creation of complex and dynamic web applications with
    simplicity and high scalability.
  prefs: []
  type: TYPE_NORMAL
- en: React is based on the virtual **document object model** (**DOM**). It minimizes
    manipulations of the actual DOM, improving performance. As stated in the introduction,
    React’s robust ecosystem includes libraries, tools, and frameworks such as **Next.js**,
    **Remix.js**, mobile-centric **React Native**, and numerous Hooks. These features
    enable developers to build versatile and high-performance applications.
  prefs: []
  type: TYPE_NORMAL
- en: Vite is a modern build tool designed to simplify and speed up the development
    of web applications with React, but also with Vue.js, Svelte, and other frameworks
    and libraries. It offers a fast development server that supports features such
    as hot module replacement, ensuring quick updates without losing the application’s
    current state. Unlike traditional setups, Vite separates app modules into dependencies
    and source code, employing `esbuild` for fast dependency bundling and serving
    source code using native **ECMAScript Modules** (**ESMs**). This approach results
    in faster server start and update times, enhancing productivity during development.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Vite supports the scaffolding of numerous types of projects, such as Svelte,
    Preact, Solid.js, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a simple app that you will be building upon in this
    introduction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pick a folder of your choice, for example, `chapter5`. Set it to the working
    directory with `cd`, and from your terminal of choice, run the following command
    to create a React template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unlike the Create React App tool, Vite requires manual installation of all
    the Node.js dependencies. Change the working directory into your `/``frontend`
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can install the dependencies by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once this process is complete, you will have a properly initiated React project
    ready to be developed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Although you can start your project with a simple command (`npm run dev`),
    this is the opportunity to install your CSS framework, **Tailwind CSS**, as it
    is easier to begin with the Tailwind CSS setup and not have to deal with the few
    bundled Vite-specific CSS styles. Run the following commands to install the CSS
    framework in order to install the Tailwind framework and initialize its configuration
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the first command installs Tailwind itself and a couple of needed packages
    as development dependencies, the second creates a `tailwind.config.js` file, the
    file that you will be using for fine-tuning and configuring your instance of Tailwind.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It is useful to set up a simple project to showcase basic React concepts. Configure
    your newly created `tailwind.config.js` file by replacing the contents of the
    file with the following code. The configuration of Tailwind for React is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, edit the `src/index.css` file that Vite created and populated with
    some default styles. Delete everything, and insert the `tailwind` directives instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you have a basic React application with a Tailwind setup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The latest documentation of this process is usually available on the excellent
    Tailwind CSS website ([https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite))
    along with similar documents for Next.js, Remix.js, and other frameworks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete the `App.css` file since you will not be using it, and then perform the
    following steps to populate the landing page of your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Replace the contents of `App.jsx` by pasting the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in the terminal, start your React project with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you open a browser tab on port `5173` (`http://localhost:5173/`), which is
    the default for Vite, you will be greeted by a purple screen and the title *Hello
    FARM stack!* in the middle of the page. However, behind this page, there is some
    code and many packages, and you can examine this generated code by looking inside
    the frontend folder that the Vite build tool built for you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In your project, there is a `node_modules` directory that contains all the project
    dependencies. You don’t need to touch this folder except for extreme debugging
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the `public` folder, there are a couple of generic files that you will not
    use in this project, such as the png logos and the `favicon.ico` file. This folder
    will contain static assets that Vite will not process, such as images, fonts and
    so on. You can leave it as is or use it later for files that will be served to
    users without any Vite modification.
  prefs: []
  type: TYPE_NORMAL
- en: In the `/src` directory there is an important HTML file called `index.html`.
    This bare-bones file contains a `div` element with the `id` parameter of the root.
    This `div` element is the place where React will load your entire application.
  prefs: []
  type: TYPE_NORMAL
- en: You will be creating most of the application in the `/src` directory. The `App.jsx`
    file that represents your entire application will be living inside this file,
    which, in turn, will be rendered in your single `div` element with the `id` parameter
    of the root in the `index.html` file. This complexity is necessary for the declarative
    approach that React will be able to provide us with while developing, in just
    a few more steps. At this point, different approaches are possible depending on
    your use case, so you might want to create additional folders for components or
    pages or group functionalities by features.
  prefs: []
  type: TYPE_NORMAL
- en: React enables you to style applications in a myriad of ways. You can use classic
    CSS style sheets or **syntactically awesome style sheets** (**SASS**), you can
    opt for JavaScript-style objects, or you can choose a modern but efficient solution
    such as **styled-components**. Additionally, all the major UI/CSS frameworks have
    a React version, for example, Material UI, Bootstrap, and Semantic UI.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, you will be using Tailwind CSS, which has an atypical
    approach that busy developers tend to like, as it doesn’t get in the way. It is
    excellent for defining basic, simple styles that make the page look simple and
    clean, but it is also good for achieving pixel-perfect designs from Figma or Adobe
    XD files if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tailwind CSS and installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tailwind CSS is a utility-first framework that translates CSS into classes that
    can be used directly in the markup and enables you to achieve complex designs.
    Just by adding classes to your HTML elements, you will be able to create completely
    styled documents. Check out the Tailwind documentation at [https://tailwindcss.com/](https://tailwindcss.com/),
    as you will be using it for all your React styling needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `App.jsx` file has a `div` element with the following list of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bg-purple-800`: To make the background purple'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-white`: To make the text white'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min-h-screen`: To make the height full-screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p-4`: To add padding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flex`: To display a flex container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flex-col`: To set the flex direction to a vertical one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`justify-center`: To justify the item’s center'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`items-center`: To center the items across the secondary axis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`className` is from **JavaScript Syntax Extension** (**JSX**), React’s language
    for creating HTML. Visual Studio Code does some autocompletion as soon as you
    type in the first quote.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a basic **React + Tailwind** setup. If you want to practice Tailwind
    CSS a bit, try creating a full-height page with some dashed borders and some titles.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will tackle the most fundamental parts of React by using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Components and building blocks of JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the latest Stack Overflow Developer Survey from 2023[1](B22406_05.xhtml#footnote-002),
    React is the developers’ top choice, and still the most popular frontend JavaScript
    library by a large margin. Like FastAPI, React boasts an incredibly well-written
    and structured documentation website ([https://react.dev/](https://react.dev/)),
    so starting from there and making your way up is one of the best things you can
    do when starting your React journey and even when you have become a seasoned developer.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](B22406_05.xhtml#footnote-002-backlink) [https://survey.stackoverflow.co/2023/#most-popular-technologies-webframe](https://survey.stackoverflow.co/2023/#most-popular-technologies-webframe)'
  prefs: []
  type: TYPE_NORMAL
- en: To put it simply, React enables you to craft UIs using a much simpler and more
    efficient way compared to plain JavaScript or first-generation JavaScript libraries
    such as jQuery, as it takes care of operations that would prove to be very tedious
    and error-prone if performed with plain JavaScript. React achieves this with the
    help of JSX, which is an enhanced JavaScript and HTML mix that React compiles
    into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: To be more precise, JSX is a JavaScript extension used in React to build interactive
    functionalities and UIs in a visually intuitive way. It allows you to write HTML-like
    code within JavaScript, making the code easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: React performs two essential functions, which are visible in the `main.jsx`
    file of your newly created Vite project. If you open and inspect the file, you
    will see two packages imported. React is responsible for using features such as
    JSX, while ReactDOM performs operations on the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword in every React description is **declarative,** so you, as a developer,
    can describe (declare) the UI and the associated data flow and actions. Then,
    React will figure out how to achieve the desired functionality through its mechanisms
    and optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSX is the glue that holds the whole React concept together. The smallest building
    blocks of a React page or app are **React elements**. A simple element might be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code looks like an `h1 HTML` element, but it also looks like JavaScript.
    Both observations are valid, because JSX enables you to create React elements
    that can be inserted into React’s virtual DOM tree, which is different from the
    actual HTML. React takes care of the tedious job of updating the DOM to match
    the virtual DOM through a process called **diffing**, and then compiles the JSX
    elements (through a tool called Babel) into actual HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: React elements are immutable, which means that once you create them, you cannot
    change them, and as the React website states, they are like single frames in a
    movie. However, they can be replaced with new elements or frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that every React component, including your `App.jsx`
    file, which is currently the only component that you have, must return only one
    element—a `div` element or a fragment (essentially, an empty tag, `<>`) and all
    the React elements enclosed in it. The following examples will show you how to
    craft some components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create some simple elements in your `App.jsx` file by pasting the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run your web app, you should see the following page rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22406_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: A simple page generated by using React'
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us review what you created in your React app:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you declared some data, a simple list of car brands in an array. For
    now, the data is hard-coded, but this data might be loaded from an external API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the `return` statement, you map over this array by using the JavaScript
    `map` function, iterating by referencing each element of the array as `el`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, you return these elements. In this case, they are strings, and you
    wrap them in `div` element. Since `className` keyword, and you can see how it
    was used quite a bit since Tailwind is very verbose. Finally, there’s a little
    addition to the `App.jsx` file, so React doesn’t complain in the console—a key
    property so React can handle our list even when it changes. You can read about
    the purpose and need for this key in the documentation here: [https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key).'
  prefs: []
  type: TYPE_NORMAL
- en: The key is a unique identifier that React needs anytime it creates arrays of
    DOM elements, so it knows which one to replace, keep, or remove. This is a rather
    simplistic example, but it shows the basics of the power of JSX. An important
    thing to remember is that you must return *exactly one element*, such as a `div`
    element, a title, or a React fragment. Functional components are, after all, functions
    (and you will only be working with functional components).
  prefs: []
  type: TYPE_NORMAL
- en: React does not have a dedicated templating language with a special syntax for
    looping over arrays of objects or `if-else` constructs. Instead, you can rely
    on the full power of JavaScript and use the standard language features such as
    `map` for iterating through arrays, `filter` for filtering data, ternary operators
    for `if-else` constructs, template literals for string interpolations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will discuss React components.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components are reusable pieces of the UI. They are the functions returning pieces
    or units of UI written in JSX. They are the building blocks of UI in React, allowing
    you to create modular, reusable pieces of code that can be composed to form the
    desired output of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.2* shows an application user interface that is visually broken
    into separate components. Each rectangle represents an independent component that
    is imported into the main app component. Some might be repeated several times,
    while others, such as the header and the footer, might be present with only one
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22406_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Breaking an app into components'
  prefs: []
  type: TYPE_NORMAL
- en: One of the first stages of planning the development of a React site is the identification
    of areas, or pieces, that could be abstracted into components and reused in some
    way or at least abstracted into separate units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a minimal component for displaying the header on a page.
    The component should have an easy task: to display the header, in your case, the
    title of the page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional components in React.js are defined as files with `.jsx` or `.js`
    extensions, and like your `App.jsx` file (the root component), they must return
    a single JSX element. The filenames should be capitalized. This is a great moment
    in which to use your previously installed React extension for Visual Studio Code
    as it provides useful snippets for creating standard components. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder and name it `components` in your `/src` folder along with a
    new file called `Header.jsx` in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the newly created file and type in `rafce`. The editor should suggest
    creating a component shell called `reactArrowFunctionExportComponent`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select this entry from the suggestion list and you will see your file filled
    with a typical ES6 arrow function component exported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This file defines a single JSX topmost element—called `Header`—and exports it
    at the bottom.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make some edits to this file, making use of our Tailwind CSS framework classes
    to make a `div` element. At this point, don’t worry about responsiveness or fancy
    coloring. Replace the `Header` element with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After these edits, which are purely Tailwind-related, import the first component
    to our `App.jsx` file. Imports are handled in terms of the relative path—remember
    that the dot denotes the current directory of the file (`/src`, in your case),
    while `/components` is the folder in which you are keeping your components. The
    `App.jsx` file should also include an instance of the `Header` component. Replace
    the contents of the `App.jsx` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Vite should automatically reload the app for you if you haven’t stopped the
    `npm run` `dev` process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see that your simple web page now has a simple header component. It
    is an `H1` element and has some basic formatting, as it is purple, centered, and
    has a yellow border. You imported the component as a self-closing tag. It is worth
    noting that components can be self-closing or (like an `H1` tag, for instance)
    enclose the data provided via children.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just made your first, very simple, React functional component. In this
    way, you can break down the functionality of your entire website. You can add
    a footer, some navigation, and more. The process of breaking an app down into
    components and deciding what should constitute a single component is so important
    that the React documentation has an excellent page dedicated to the process: [https://reactjs.org/docs/thinking-in-react.html](https://reactjs.org/docs/thinking-in-react.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating dynamic components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Crafting components like this is nice and quick, but it can become tedious if
    the output is fixed. Fortunately, React components are functions, and functions
    can take arguments then do something useful with those arguments. Suppose you
    want to create a component that will replace your plain list of car brands and
    display the information in a more pleasing and informative way. You can pass the
    data for each car in your data array (an object) and have it formatted in a specified
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To redo your procedure for displaying the list, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `components` folder, name it `Card.jsx`, and type
    `rafce` in order to get the correct component template. Replace the `Card` component
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This component, unlike the `Header` component that you made earlier, accepts
    props, or properties that define the component behavior. The `Card` component
    is a simple reusable abstraction that is repeated across the page wherever needed.
    You also made use of ES7 object *destructuring* to make the component a bit easier
    on the eyes and not have to repeat `props.name`, `props.model`, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `App.jsx` main file to make proper use of `Card`. Replace the contents
    of `App.jsx` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the goal is to use the newly created `Card` component and pass it all
    the needed data. Update `Card.jsx` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, instead of returning the `div` elements when mapping through your data,
    you are returning your `Card` component and passing it the key—that is, the ID
    of the `car` object. Note that the ID has to be unique or React will throw warnings
    in the console indicating that we haven’t specified it. Additionally, you’re passing
    something that you can refer to as `el` and set to the element—the `car` object
    from your data array.
  prefs: []
  type: TYPE_NORMAL
- en: Your `Card` component is now able to display data related to the cars—each card
    holds the data of a single car. You passed data through props (short for properties)
    to each card. You just have to accept it in the component.
  prefs: []
  type: TYPE_NORMAL
- en: It is easy to pass props to components, but since props provide one-way communication,
    in most apps, you will have to deal with the **state** as well, which is discussed
    in the next section
  prefs: []
  type: TYPE_NORMAL
- en: Events and state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React exposes and wraps all the standard DOM events—button and link clicks,
    form submissions, mouse hovers, keyups and keydowns, and more. Handling these
    events in React is relatively intuitive. A click event will be handled by a synthetic
    event called `onClick`; events are named by using the **camelCase naming convention**.
    In React, **event handlers** are functions that are triggered when an interaction
    occurs. These functions accept function handlers, which are other functions, as
    props. The simplest possible case would be clicking a button (although it could
    be any DOM element).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple component in a file called `Button.jsx` in the `/components`
    directory that contains a button that, when clicked, displays a message in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste the following code into your `Button.jsx` file after performing the `racfe`
    action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a simple example and it showcases the underlying mechanism; `onClick`
    is React’s way of knowing what event it should listen to and the `handleClick`
    function executes your (rather simple) business logic. If you import the button
    into the `App.jsx` file and click the button, you should see the messages in the
    console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The implementation is very simple; update the `App.jsx` component with the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: React Hooks with events and state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The components of React are essentially functions that convert a state to a
    user interface. A React component isa function that takes props as arguments.
    It can be thought of as an updatable data structure responsible for the component
    behavior. The output of the function, the component, is a JSX element. Essentially,
    React Hooks are functional constructs that enable you to tap into the life cycle
    of a component and change its state.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are many standard React Hooks and numerous external ones, you will
    work with only two, which are the most fundamental for React comprehension: `useState`
    and `useEffect`. These two Hooks will remain in the forthcoming React version
    19, while others, such as `useMemo`, `useCallback`, and some others, will be gradually
    deprecated. It is also true that while mastering React takes some time, much of
    standard UI functionality can be achieved through clever combinations of these
    two Hooks.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating stateful variables with useState
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `useState` Hook allows you to maintain a certain state throughout your component.
    For example, you might want to maintain some kind of state in your SPA, so the
    website doesn’t show you any cars that are too expensive based on your specified
    budget. You can make a simple textbox, set it to display just numeric values,
    and hook it up with a state variable that you can name `budget`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the contents of the `App.jsx` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, you first import the `useState` Hook from React.
    The `useState` Hook returns two values:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable, which can be anything you want—an array or an object, a simple number,
    or a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that sets the value for this state variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although you can use any legal JavaScript name, it is a good convention to
    use the name of the variable—in your case, `budget`—and the same name prepended
    with `set`: `setBudget`. With this simple line of code, you have told React to
    set up a state unit called `budget` and to set up a setter. The argument of the
    `useState()` call is the initial value. In the following case, you have set it
    to 20,000 dollars.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the updated web app with the updateable budget box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22406_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Listing cars'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you are free to use this state variable across the page. Here, you placed
    the `useState` call inside the `App` functional component—if you try to place
    it elsewhere, it will not work: Hooks tap into the lifecycle of components from
    the inside of the bodies of the functions defining the components themselves!'
  prefs: []
  type: TYPE_NORMAL
- en: Moving down to the bottom of the component, you added a simple textbox. You
    can set it to display only numeric values with HTML and a step of `1000` and add
    an `onChange` handler.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good moment to emphasize yet again that React uses the so-called **synthetic
    event**, a wrapper around the browser’s native events that enables React to achieve
    cross-browser compatibility. Once you have remembered a couple of differences
    (that the events are using camelCase rather than lowercase, and you must pass
    them a function in JSX), you will be writing event handlers in no time.
  prefs: []
  type: TYPE_NORMAL
- en: In your app, you added an `onChange` event to the textbox and set it to handle
    the state, then you set the new value of the budget. Every time you change the
    value, the `setBudget` function fires, and, as a consequence, the budget updates
    and different `Card` instances are displayed that match your budget constraints.
  prefs: []
  type: TYPE_NORMAL
- en: This `onChange` event takes the current value of the textbox (`target.value`,
    just like the original DOM events, as it’s just a wrapper) and sets your budget
    state to this value using our `useState` call defined just above the function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ve added a `div` element component that uses this budget value
    and displays it. You have added a state variable to your app’s root component.
    You can set it, get it, and display it on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you have accomplished another task typical for developing React apps. You
    have allowed the user to enter their budget and you are displaying it on the page.
    If you want to differentiate between cars that fit said budget and those that
    do not, you will make use of some simple JavaScript and component state. To get
    this to work, set your small data sample that is currently hardcoded to be a state
    variable itself, so the user can just filter it and display only those cars within
    the price range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure is simple and involves pure JavaScript to accomplish the task
    of displaying an array of cars satisfying the condition that their price is less
    than or equal to your budget. Hint: Use JavaScript filtering arrays as shown in
    bold in the following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can dive into the excellent React.js documentation and learn
    more about the `useState` Hook and its sibling, the `useReducer` Hook ([https://react.dev/reference/react/useState](https://react.dev/reference/react/useState)).
    This is a Hook that might be thought of as a generalization of the `useState`
    Hook. It is best suited when you have to deal with numerous pieces of state that
    are interconnected, so managing them with many simple `useState` Hooks could end
    up being tedious and difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have seen how the `useState` Hook enables you to add a
    stateful variable in a very simple and straightforward way and how to manipulate
    the state through regular events.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will learn how you can get your data from your efficient FastAPI backend
    into your React.js frontend. You will get to know another Hook called `useEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with APIs and the outside world using useEffect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, you can use a free mock REST API. However, you do need to address the
    problem of accessing external data and the management of external events. External
    to what, you might wonder?
  prefs: []
  type: TYPE_NORMAL
- en: You have seen that React and its mighty Hooks are centered around the task of
    synchronizing the UI to the state and the data. Components can contain other components,
    and together, they form what is known as a **component tree**, which is then constantly
    compared to the current state. React does all of this coordination work, to determine
    what should be rendered, updated, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Events that are outside of the React data flow process are called **side effects**.
    Notable examples of React side effects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing API calls—sending or receiving data from an external server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to external data sources via websockets or streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting or getting data values to and from the local storage or session storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event listeners and their cleanup functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that React works in a continuous data flow, with an underlying system
    constantly scanning for updates and ready to re-render components that it deems
    in need of an update. The following example will illustrate this.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that you are working on your *Car Sales* application and you need to
    list all the users that have registered an account. The task at hand is a simple
    and common one. You have a dedicated page—it will live in a URL called `/users`
    or something similar, and it should be populated with the data (think of a JavaScript
    array of objects) from an external API. This API will be powered by FastAPI, but
    for now, you will use a readymade mock solution called Jsonplaceholder.
  prefs: []
  type: TYPE_NORMAL
- en: The `GET` call you need to make should be directed toward the URL [https://jsonplaceholder.typicode.com/users/](https://jsonplaceholder.typicode.com/users/).
  prefs: []
  type: TYPE_NORMAL
- en: You already understand how to make components, provide them with props, and
    set their state, so that shouldn’t be a problem. When it comes to loading data
    from an external API, you might just use something such as `Fetch` or `Axios`,
    as if you were using a normal plain JavaScript app. `Fetch` and `Axios` are the
    two most popular JavaScript libraries used for making HTTP requests to servers.
  prefs: []
  type: TYPE_NORMAL
- en: Trying to fetch the data in a React component and then setting the state to
    the resulting JSON would start an **infinite loop**. Bear in mind that React came
    before the server component with async code existed.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the state of a component changes and the component is re-rendered,
    the new render again triggers a `fetch` call to the API, the state changes again
    to be set to the list of users, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this component’s data flow, the fetching of the data is considered external—not
    part of the main component life cycle. It is executed after the component has
    been executed.
  prefs: []
  type: TYPE_NORMAL
- en: To deal with this problem, React has a very elegant solution—the `useEffect`
    Hook. You can create a new application by editing the `App.jsx` main component,
    and then display a list of users from your API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can implement a possible solution using the `useEffect` Hook. Paste the
    following code into your `App.jsx` file (refer `App3.jsx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the `App.jsx` file, import `useState` and `useEffect` and then
    you can begin creating your sole state variable—the `users` array—initializing
    it to an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchUsers` function is simple—it makes a call to the API and returns data
    in JSON format, using promises. It could also have been an `async`/`await` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useEffect` Hook, as with all Hooks, is executed inside the component function.
    It does not return a value, however, and it accepts two arguments: the function
    to be executed (in this case, `fetchUsers`), and a dependency array, an array
    of values whose change in value will trigger a new execution of the effect. If
    the function should trigger only once, the array should be empty. If you want
    to fetch other users from the next API URL, you must add the URL to the array.'
  prefs: []
  type: TYPE_NORMAL
- en: As with `useState`, there are many more subtleties involved. For example, you
    can provide a cleanup function at the bottom of the `useEffect` body to make sure
    that any long-lasting effects are removed, but this should give you a basic idea
    of how to handle actions that reach out to an external API.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, `useContext` allows React to cover an entire area of components
    and pass values directly without having to pass them through several components
    that might not actually need it, a procedure called prop drilling. You can even
    create your own Hooks and abstract functionality that can be reused in several
    places of the app, ensuring better maintainability and less repetition.
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of Hooks, the whole ecosystem becomes much clearer and
    cleaner, and the mapping of business logic to UIs is much more streamlined and
    logical.
  prefs: []
  type: TYPE_NORMAL
- en: You now have the knowledge that is necessary to set and get states in your components
    or apps and to communicate with external API services in a predictable and controllable
    way, while crafting clean and simple code. Just using React and its Hooks can
    give you web developer proficiency, but there is a whole ecosystem of packages
    and modules built around React that can be just as important and useful as the
    core libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring React Router and other useful packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have only created a couple of single-page apps, but you haven’t
    touched some advanced functionalities. However, single-page apps are not limited
    to a single URL. For example, if you navigate to your Gmail account, you will
    see that the URL changes with every action that you might take.
  prefs: []
  type: TYPE_NORMAL
- en: While there are several solutions that enable you to achieve routing in SPAs,
    React Router is the standard solution, and it is a well-tested, mature package.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying idea of a frontend page router is that it should enable rendering
    different components on the same page depending on the route that is loaded. For
    instance, the `/about` route would cause the app to load a component called `About.jsx`
    in the main `App` component, removing other previously loaded components. The
    package provides a basic structure, within the `BrowserRouter` class, which can
    be used to wrap an entire root `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: React is such a popular framework that there is a diverse ecosystem of tools
    and integrations that you can learn about. As you’ve already seen earlier, besides
    Tailwind, you can use virtually any UI or CSS framework either directly or through
    some optimized React version, such as Bootstrap, or more tightly coupled with
    React, such as Ant Design. You can enhance your user experience with subtle animations
    through Framer Motion, and you can speed up the development of forms with some
    excellent form libraries such as React Hook Form. For complex state problems,
    Redux is the most popular and widely adopted industry standard, but there are
    many smaller or specialized libraries for local and global state management, such
    as **Recoil**, **Zustand**, or **React Query**.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a short introduction to the world’s most popular user
    interface library—React.js.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also detailed what JSX is and why it’s so convenient for developers.
    It explored the basic building blocks of React, functional components, and the
    basic rules that must be followed when designing them. It also introduced two
    fundamental React Hooks that, when combined, allow you to begin building basic
    user interfaces, maintain and change the state of the components, and interact
    with external APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the chapter covered the implementation of some of the React libraries
    that will make your life easier when developing custom applications. These libraries
    all have excellent documentation and are updated frequently.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will use some of this basic knowledge and React to create a
    simple but fully functional and dynamic application.
  prefs: []
  type: TYPE_NORMAL
