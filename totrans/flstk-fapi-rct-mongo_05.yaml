- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Setting Up a React Workflow
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置React工作流程
- en: This chapter focuses on the React library and discusses the important topics
    and features that you should be aware of so that you can create a very simple
    React app, really just a frontend. In this chapter, you will learn about the main
    features and the most salient concepts of React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍React库，并讨论了您应该了解的重要主题和功能，以便您能够创建一个非常简单的React应用，实际上只是一个前端。在本章中，您将了解React的主要功能和最显著的概念。
- en: You will begin with the prerequisites and tools, such as Node.js, some Visual
    Studio Code extensions, and more. You will also learn how to use the new standard
    and recommended build tool called **Vite**. Compared to **Create React App**,
    Vite is more efficient and allows for fast **hot module replacement** (**HMR**)
    and on-demand file serving, without the need for bundling. Bundling is the process
    of combining and joining multiple JavaScript files into a single file, reducing
    the number of HTTP requests needed to load the page. HMR, on the other hand, allows
    for the updating of single modules while the application is running, in real time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从先决条件和工具开始，例如Node.js、一些Visual Studio Code扩展等。您还将学习如何使用名为**Vite**的新标准和推荐构建工具。与**Create
    React App**相比，Vite更高效，允许快速**热模块替换**（**HMR**）和按需文件服务，无需捆绑。捆绑是将多个JavaScript文件组合并连接成一个文件的过程，减少了加载页面所需的HTTP请求数量。另一方面，**HMR**允许在应用程序运行时实时更新单个模块。
- en: You will design a simple application with a few components and see how decoupling
    helps you write modular and maintainable code. This chapter covers two of the
    most important React Hooks and how they solve some common web development problems.
    However, the main objective of this chapter is to discuss the tools needed to
    be able to explore React and its various functionalities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您将设计一个包含几个组件的简单应用，并了解解耦如何帮助您编写模块化和可维护的代码。本章涵盖了两个最重要的React钩子以及它们如何解决一些常见的Web开发问题。然而，本章的主要目标是讨论探索React及其各种功能所需的工具。
- en: By the end of this chapter, you will have a simple but fully functional React
    web app. The concepts in this chapter will prepare you to be a frontend developer
    who values relatively simple tools to be able to achieve complex functionalities,
    without being confined within a strict framework.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个简单但功能齐全的React网络应用。本章中的概念将使您准备好成为一个重视相对简单工具以实现复杂功能，而不受严格框架限制的前端开发者。
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to React and how to use Vite to create React apps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React简介以及如何使用Vite创建React应用
- en: Styling techniques with Tailwind CSS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Tailwind CSS进行样式技术
- en: The functional components and JSX, the language of React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组件和JSX，React的语言
- en: How to use the `useState` and `useEffect` Hooks for state management and API
    communication
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`useState`和`useEffect`钩子进行状态管理和API通信
- en: Features of React Router and other packages within the React ecosystem
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Router和其他React生态系统内包的功能
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Creating a React-based application involves several steps, including setting
    up a build system and a transpiler, creating a directory structure, and more.
    You must install the following tools before you start developing your application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于React的应用涉及多个步骤，包括设置构建系统和转换器、创建目录结构等。在您开始开发应用程序之前，您必须安装以下工具：
- en: '**Vite**: Vite requires Node.js versions 18+ or 20+ in order to run, but you
    can always check the documentation at [https://vitejs.dev](https://vitejs.dev)
    for updates.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vite**：Vite需要Node.js版本18+或20+才能运行，但您始终可以查看[https://vitejs.dev](https://vitejs.dev)上的文档以获取更新。'
- en: '**Node.js**:You can download Node.js for your operating system from[https://nodejs.org/en/download/](https://nodejs.org/en/download/).
    When installing, check all the boxes – you want **npm** (**Node.js’ package manager**)
    and optional additional command-line tools if you are on a Windows machine.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**：您可以从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)下载适用于您操作系统的Node.js。在安装时，请勾选所有选项——如果您使用的是Windows机器，您希望安装**npm**（**Node.js的包管理器**）以及可选的额外命令行工具。'
- en: '**Visual Studio Code**: Install a React extension called **ES7+ React/Redux/React-Native
    snippets** to help speed up the creation of components of a React app.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：安装一个名为**ES7+ React/Redux/React-Native snippets**的React扩展，以帮助加快React应用组件的创建。'
- en: '**React Developer Tools** : Install the React Developer Tools browser extension
    ([https://react.dev/learn/react-developer-tools](https://react.dev/learn/react-developer-tools)).
    This enables debugging your React apps quicker and spotting potential problems
    easily.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**React 开发者工具**：安装 React 开发者工具浏览器扩展（[https://react.dev/learn/react-developer-tools](https://react.dev/learn/react-developer-tools)）。这使你能够更快地调试你的
    React 应用程序并轻松发现潜在问题。'
- en: Creating a React app using Vite
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vite 创建 React 应用程序
- en: React is a JavaScript library for building **user interfaces** (**UIs**), particularly
    for **single-page applications** (**SPAs**) but also for traditional server-side-rendered
    applications. It offers reusable UI components that are able to manage their own
    state, allowing for the creation of complex and dynamic web applications with
    simplicity and high scalability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个用于构建 **用户界面** (**UI**) 的 JavaScript 库，尤其是用于 **单页应用程序** (**SPAs**)，但也适用于传统的服务器端渲染应用程序。它提供了可重用的
    UI 组件，能够管理自己的状态，允许以简单和高可扩展性的方式创建复杂和动态的 Web 应用程序。
- en: React is based on the virtual **document object model** (**DOM**). It minimizes
    manipulations of the actual DOM, improving performance. As stated in the introduction,
    React’s robust ecosystem includes libraries, tools, and frameworks such as **Next.js**,
    **Remix.js**, mobile-centric **React Native**, and numerous Hooks. These features
    enable developers to build versatile and high-performance applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: React 是基于虚拟 **文档对象模型** (**DOM**) 的。它最小化了实际 DOM 的操作，从而提高了性能。正如介绍中所述，React 的强大生态系统包括
    **Next.js**、**Remix.js**、以移动为中心的 **React Native** 以及众多 Hooks。这些功能使开发者能够构建灵活且高性能的应用程序。
- en: Vite is a modern build tool designed to simplify and speed up the development
    of web applications with React, but also with Vue.js, Svelte, and other frameworks
    and libraries. It offers a fast development server that supports features such
    as hot module replacement, ensuring quick updates without losing the application’s
    current state. Unlike traditional setups, Vite separates app modules into dependencies
    and source code, employing `esbuild` for fast dependency bundling and serving
    source code using native **ECMAScript Modules** (**ESMs**). This approach results
    in faster server start and update times, enhancing productivity during development.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 是一个现代构建工具，旨在简化并加快使用 React（以及 Vue.js、Svelte 和其他框架和库）开发 Web 应用程序的速度。它提供了一个快速的开发服务器，支持热模块替换等特性，确保快速更新而不会丢失应用程序的当前状态。与传统设置不同，Vite
    将应用程序模块分离为依赖项和源代码，使用 `esbuild` 进行快速依赖项捆绑，并使用原生 **ECMAScript 模块** (**ESMs**) 提供源代码。这种方法导致服务器启动和更新时间更快，从而提高了开发过程中的生产力。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Vite supports the scaffolding of numerous types of projects, such as Svelte,
    Preact, Solid.js, and more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 支持多种类型项目的脚手架搭建，如 Svelte、Preact、Solid.js 等。
- en: 'Let''s start by creating a simple app that you will be building upon in this
    introduction:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的应用程序开始，你将在本介绍中在此基础上构建：
- en: 'Pick a folder of your choice, for example, `chapter5`. Set it to the working
    directory with `cd`, and from your terminal of choice, run the following command
    to create a React template:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个你喜欢的文件夹，例如 `chapter5`。使用 `cd` 将其设置为工作目录，然后从你选择的终端运行以下命令以创建一个 React 模板：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unlike the Create React App tool, Vite requires manual installation of all
    the Node.js dependencies. Change the working directory into your `/``frontend`
    directory:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 Create React App 工具不同，Vite 需要手动安装所有 Node.js 依赖项。将工作目录更改为你的 `/frontend` 目录：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you can install the dependencies by running the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以通过运行以下命令来安装依赖项：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once this process is complete, you will have a properly initiated React project
    ready to be developed.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦这个过程完成，你将拥有一个正确初始化的 React 项目，准备进行开发。
- en: 'Although you can start your project with a simple command (`npm run dev`),
    this is the opportunity to install your CSS framework, **Tailwind CSS**, as it
    is easier to begin with the Tailwind CSS setup and not have to deal with the few
    bundled Vite-specific CSS styles. Run the following commands to install the CSS
    framework in order to install the Tailwind framework and initialize its configuration
    file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然你可以通过简单的命令 (`npm run dev`) 开始你的项目，但这正是安装你的 CSS 框架 **Tailwind CSS** 的机会，因为它使用
    Tailwind CSS 设置更容易开始，而且不需要处理少量捆绑的 Vite 特定的 CSS 样式。运行以下命令以安装 CSS 框架，以便安装 Tailwind
    框架并初始化其配置文件：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While the first command installs Tailwind itself and a couple of needed packages
    as development dependencies, the second creates a `tailwind.config.js` file, the
    file that you will be using for fine-tuning and configuring your instance of Tailwind.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然第一个命令安装了 Tailwind 本身以及一些需要的开发依赖包，但第二个命令创建了一个 `tailwind.config.js` 文件，这是你将用于微调和配置
    Tailwind 实例的文件。
- en: 'It is useful to set up a simple project to showcase basic React concepts. Configure
    your newly created `tailwind.config.js` file by replacing the contents of the
    file with the following code. The configuration of Tailwind for React is the following:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个简单的项目来展示基本的 React 概念是有用的。通过替换文件内容来配置你新创建的 `tailwind.config.js` 文件，如下所示。Tailwind
    为 React 的配置如下：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, edit the `src/index.css` file that Vite created and populated with
    some default styles. Delete everything, and insert the `tailwind` directives instead:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑 Vite 创建并填充了一些默认样式的 `src/index.css` 文件。删除所有内容，并插入 `tailwind` 指令：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, you have a basic React application with a Tailwind setup.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你有一个基本的 React 应用程序，并已设置 Tailwind。
- en: The latest documentation of this process is usually available on the excellent
    Tailwind CSS website ([https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite))
    along with similar documents for Next.js, Remix.js, and other frameworks.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个过程的最新文档通常可以在优秀的 Tailwind CSS 网站上找到（[https://tailwindcss.com/docs/guides/vite](https://tailwindcss.com/docs/guides/vite)），以及
    Next.js、Remix.js 和其他框架的类似文档。
- en: Delete the `App.css` file since you will not be using it, and then perform the
    following steps to populate the landing page of your application.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 删除 `App.css` 文件，因为你不会使用它，然后按照以下步骤填充你应用程序的着陆页。
- en: 'Replace the contents of `App.jsx` by pasting the following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换 `App.jsx` 的内容：
- en: '[PRE6]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Back in the terminal, start your React project with the following command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端，使用以下命令启动你的 React 项目：
- en: '[PRE7]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you open a browser tab on port `5173` (`http://localhost:5173/`), which is
    the default for Vite, you will be greeted by a purple screen and the title *Hello
    FARM stack!* in the middle of the page. However, behind this page, there is some
    code and many packages, and you can examine this generated code by looking inside
    the frontend folder that the Vite build tool built for you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开端口 `5173`（`http://localhost:5173/`）的浏览器标签页，这是 Vite 的默认端口，你会看到一个紫色的屏幕，页面中间有标题
    *Hello FARM stack!*。然而，在这个页面背后，有一些代码和许多包，你可以通过查看 Vite 为你构建的前端文件夹来检查这个生成的代码。
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In your project, there is a `node_modules` directory that contains all the project
    dependencies. You don’t need to touch this folder except for extreme debugging
    operations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，有一个包含所有项目依赖项的 `node_modules` 目录。除非进行极端的调试操作，否则你不需要触摸这个文件夹。
- en: In the `public` folder, there are a couple of generic files that you will not
    use in this project, such as the png logos and the `favicon.ico` file. This folder
    will contain static assets that Vite will not process, such as images, fonts and
    so on. You can leave it as is or use it later for files that will be served to
    users without any Vite modification.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `public` 文件夹中，有一些你在这个项目中不会使用的通用文件，例如 png 标志和 `favicon.ico` 文件。这个文件夹将包含 Vite
    不会处理的静态资产，例如图片、字体等。你可以保持原样，或者稍后用于需要用户接收且未经 Vite 修改的文件。
- en: In the `/src` directory there is an important HTML file called `index.html`.
    This bare-bones file contains a `div` element with the `id` parameter of the root.
    This `div` element is the place where React will load your entire application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/src` 目录中有一个重要的 HTML 文件，名为 `index.html`。这个裸骨文件包含一个具有 `id` 参数的 `div` 元素，这是
    React 加载你整个应用程序的地方。
- en: You will be creating most of the application in the `/src` directory. The `App.jsx`
    file that represents your entire application will be living inside this file,
    which, in turn, will be rendered in your single `div` element with the `id` parameter
    of the root in the `index.html` file. This complexity is necessary for the declarative
    approach that React will be able to provide us with while developing, in just
    a few more steps. At this point, different approaches are possible depending on
    your use case, so you might want to create additional folders for components or
    pages or group functionalities by features.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 `/src` 目录下创建大部分应用程序。代表你整个应用程序的 `App.jsx` 文件将位于此文件中，而这个文件反过来将在 `index.html`
    文件中根元素的 `id` 参数指定的单个 `div` 元素中渲染。这种复杂性对于 React 在开发过程中仅通过几个额外步骤就能提供的声明式方法来说是必要的。在这个阶段，不同的方法取决于你的用例，因此你可能需要为组件或页面创建额外的文件夹，或者按功能分组功能。
- en: React enables you to style applications in a myriad of ways. You can use classic
    CSS style sheets or **syntactically awesome style sheets** (**SASS**), you can
    opt for JavaScript-style objects, or you can choose a modern but efficient solution
    such as **styled-components**. Additionally, all the major UI/CSS frameworks have
    a React version, for example, Material UI, Bootstrap, and Semantic UI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: React 允许你以无数种方式为应用程序设置样式。你可以使用经典的 CSS 样式表或 **语法优美的样式表**（**SASS**），你可以选择 JavaScript
    风格的对象，或者你可以选择一个现代且高效的解决方案，如 **styled-components**。此外，所有主要的 UI/CSS 框架都有 React 版本，例如
    Material UI、Bootstrap 和 Semantic UI。
- en: Throughout this book, you will be using Tailwind CSS, which has an atypical
    approach that busy developers tend to like, as it doesn’t get in the way. It is
    excellent for defining basic, simple styles that make the page look simple and
    clean, but it is also good for achieving pixel-perfect designs from Figma or Adobe
    XD files if needed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你将使用 Tailwind CSS，它采用了一种典型的开发者喜欢的非典型方法，因为它不会妨碍你。它非常适合定义基本的简单样式，使页面看起来简单整洁，但如果有需要，它也能很好地实现来自
    Figma 或 Adobe XD 文件的像素级设计。
- en: Tailwind CSS and installation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tailwind CSS 和安装
- en: Tailwind CSS is a utility-first framework that translates CSS into classes that
    can be used directly in the markup and enables you to achieve complex designs.
    Just by adding classes to your HTML elements, you will be able to create completely
    styled documents. Check out the Tailwind documentation at [https://tailwindcss.com/](https://tailwindcss.com/),
    as you will be using it for all your React styling needs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Tailwind CSS 是一个以实用工具为首要的框架，它将 CSS 转换为可以直接在标记中使用的类，并使你能够实现复杂的设计。只需向你的 HTML 元素添加类，你就能创建完全样式的文档。查看
    Tailwind 文档 [https://tailwindcss.com/](https://tailwindcss.com/)，因为你会用它来满足所有你的
    React 样式需求。
- en: 'Your `App.jsx` file has a `div` element with the following list of classes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `App.jsx` 文件有一个具有以下类列表的 `div` 元素：
- en: '`bg-purple-800`: To make the background purple'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bg-purple-800`：使背景为紫色'
- en: '`text-white`: To make the text white'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text-white`：使文本为白色'
- en: '`min-h-screen`: To make the height full-screen'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min-h-screen`：使高度全屏'
- en: '`p-4`: To add padding'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p-4`：添加填充'
- en: '`flex`: To display a flex container'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex`：显示一个 flex 容器'
- en: '`flex-col`: To set the flex direction to a vertical one'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flex-col`：将 flex 方向设置为垂直'
- en: '`justify-center`: To justify the item’s center'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`justify-center`：使项目居中'
- en: '`items-center`: To center the items across the secondary axis'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`items-center`：在次轴上居中项目'
- en: '`className` is from **JavaScript Syntax Extension** (**JSX**), React’s language
    for creating HTML. Visual Studio Code does some autocompletion as soon as you
    type in the first quote.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`className` 来自 **JavaScript 语法扩展**（**JSX**），这是 React 创建 HTML 的语言。Visual Studio
    Code 会在你输入第一个引号时提供一些自动完成。'
- en: This is a basic **React + Tailwind** setup. If you want to practice Tailwind
    CSS a bit, try creating a full-height page with some dashed borders and some titles.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的 **React + Tailwind** 设置。如果你想练习 Tailwind CSS，尝试创建一个全高页面，带有一些虚线边框和一些标题。
- en: The next section will tackle the most fundamental parts of React by using JSX.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将通过使用 JSX 来探讨 React 最基本的部分。
- en: Components and building blocks of JSX
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSX 的组件和构建块
- en: According to the latest Stack Overflow Developer Survey from 2023[1](B22406_05.xhtml#footnote-002),
    React is the developers’ top choice, and still the most popular frontend JavaScript
    library by a large margin. Like FastAPI, React boasts an incredibly well-written
    and structured documentation website ([https://react.dev/](https://react.dev/)),
    so starting from there and making your way up is one of the best things you can
    do when starting your React journey and even when you have become a seasoned developer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 2023 年最新的 Stack Overflow 开发者调查[1](B22406_05.xhtml#footnote-002)，React 是开发者的首选，并且仍然是最受欢迎的前端
    JavaScript 库。像 FastAPI 一样，React 拥有一个写得非常好且结构化的文档网站 ([https://react.dev/](https://react.dev/))，因此从那里开始并一路向上是你在开始
    React 之旅时以及成为资深开发者时能做的最好的事情之一。
- en: '[1](B22406_05.xhtml#footnote-002-backlink) [https://survey.stackoverflow.co/2023/#most-popular-technologies-webframe](https://survey.stackoverflow.co/2023/#most-popular-technologies-webframe)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](B22406_05.xhtml#footnote-002-backlink) [https://survey.stackoverflow.co/2023/#most-popular-technologies-webframe](https://survey.stackoverflow.co/2023/#most-popular-technologies-webframe)'
- en: To put it simply, React enables you to craft UIs using a much simpler and more
    efficient way compared to plain JavaScript or first-generation JavaScript libraries
    such as jQuery, as it takes care of operations that would prove to be very tedious
    and error-prone if performed with plain JavaScript. React achieves this with the
    help of JSX, which is an enhanced JavaScript and HTML mix that React compiles
    into JavaScript.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，React 允许你以一种比纯 JavaScript 或第一代 JavaScript 库（如 jQuery）更简单、更高效的方式构建 UI，因为它处理了如果用纯
    JavaScript 执行将会非常繁琐且容易出错的操作。React 通过 JSX 实现这一点，JSX 是一种增强的 JavaScript 和 HTML 混合，React
    会将其编译成 JavaScript。
- en: To be more precise, JSX is a JavaScript extension used in React to build interactive
    functionalities and UIs in a visually intuitive way. It allows you to write HTML-like
    code within JavaScript, making the code easier to understand and maintain.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，JSX 是 React 中用于以直观方式构建交互功能和 UI 的 JavaScript 扩展。它允许你在 JavaScript 中编写类似
    HTML 的代码，使代码更容易理解和维护。
- en: React performs two essential functions, which are visible in the `main.jsx`
    file of your newly created Vite project. If you open and inspect the file, you
    will see two packages imported. React is responsible for using features such as
    JSX, while ReactDOM performs operations on the DOM.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: React 执行两个基本功能，这在你的新创建的 Vite 项目的 `main.jsx` 文件中是可见的。如果你打开并检查该文件，你会看到导入了两个包。React
    负责使用 JSX 等功能，而 ReactDOM 则在 DOM 上执行操作。
- en: The keyword in every React description is **declarative,** so you, as a developer,
    can describe (declare) the UI and the associated data flow and actions. Then,
    React will figure out how to achieve the desired functionality through its mechanisms
    and optimizations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 React 描述中的关键词是 **声明式**，因此作为开发者，你可以描述（声明）UI 以及相关的数据流和操作。然后，React 将通过其机制和优化来确定如何实现所需的功能。
- en: 'JSX is the glue that holds the whole React concept together. The smallest building
    blocks of a React page or app are **React elements**. A simple element might be
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JSX 是将整个 React 概念粘合在一起的内聚力。React 页面或应用的最小构建块是 **React 元素**。一个简单的元素可能如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code looks like an `h1 HTML` element, but it also looks like JavaScript.
    Both observations are valid, because JSX enables you to create React elements
    that can be inserted into React’s virtual DOM tree, which is different from the
    actual HTML. React takes care of the tedious job of updating the DOM to match
    the virtual DOM through a process called **diffing**, and then compiles the JSX
    elements (through a tool called Babel) into actual HTML elements.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来像 `h1 HTML` 元素，但它也看起来像 JavaScript。这两个观察都是有效的，因为 JSX 允许你创建可以插入到 React
    的虚拟 DOM 树中的 React 元素，这与实际的 HTML 不同。React 通过一个称为 **diffing** 的过程来处理更新 DOM 以匹配虚拟
    DOM 的繁琐工作，然后通过一个名为 Babel 的工具将 JSX 元素编译成实际的 HTML 元素。
- en: React elements are immutable, which means that once you create them, you cannot
    change them, and as the React website states, they are like single frames in a
    movie. However, they can be replaced with new elements or frames.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: React 元素是不可变的，这意味着一旦你创建了它们，就无法更改它们，正如 React 网站所述，它们就像电影中的单个帧。然而，它们可以被新的元素或帧所替换。
- en: 'It is important to note that every React component, including your `App.jsx`
    file, which is currently the only component that you have, must return only one
    element—a `div` element or a fragment (essentially, an empty tag, `<>`) and all
    the React elements enclosed in it. The following examples will show you how to
    craft some components:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，每个React组件，包括你当前的唯一组件`App.jsx`文件，都必须只返回一个元素——一个`div`元素或一个片段（本质上，一个空标签`<>`）以及其中包含的所有React元素。以下示例将展示如何构建一些组件：
- en: 'Create some simple elements in your `App.jsx` file by pasting the following
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`App.jsx`文件中创建一些简单的元素，通过粘贴以下代码：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run your web app, you should see the following page rendered:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行你的Web应用时，你应该看到以下页面被渲染：
- en: '![](img/B22406_05_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22406_05_01.jpg)'
- en: 'Figure 4.1: A simple page generated by using React'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：使用React生成的简单页面
- en: Recap
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'Let us review what you created in your React app:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下你在React应用中创建的内容：
- en: First, you declared some data, a simple list of car brands in an array. For
    now, the data is hard-coded, but this data might be loaded from an external API.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你声明了一些数据，一个简单的汽车品牌列表数组。目前，这些数据是硬编码的，但这个数据可能来自外部API。
- en: Then, in the `return` statement, you map over this array by using the JavaScript
    `map` function, iterating by referencing each element of the array as `el`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`return`语句中，你通过使用JavaScript的`map`函数映射这个数组，通过引用数组的每个元素作为`el`来迭代。
- en: 'Finally, you return these elements. In this case, they are strings, and you
    wrap them in `div` element. Since `className` keyword, and you can see how it
    was used quite a bit since Tailwind is very verbose. Finally, there’s a little
    addition to the `App.jsx` file, so React doesn’t complain in the console—a key
    property so React can handle our list even when it changes. You can read about
    the purpose and need for this key in the documentation here: [https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要返回这些元素。在这种情况下，它们是字符串，并且你将它们包裹在`div`元素中。由于`className`关键字，你可以看到Tailwind非常详尽地使用了它。最后，在`App.jsx`文件中添加了一些小的改动，这样React就不会在控制台抱怨——这是一个关键属性，这样React才能处理我们的列表，即使它发生变化。你可以在文档中阅读有关此键的用途和需求：[https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key)。
- en: The key is a unique identifier that React needs anytime it creates arrays of
    DOM elements, so it knows which one to replace, keep, or remove. This is a rather
    simplistic example, but it shows the basics of the power of JSX. An important
    thing to remember is that you must return *exactly one element*, such as a `div`
    element, a title, or a React fragment. Functional components are, after all, functions
    (and you will only be working with functional components).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 键是一个React在创建DOM元素数组时需要的唯一标识符，这样它就知道哪个要替换、保留或删除。这是一个相当简单的例子，但它展示了JSX的基本功能。需要记住的一个重要事情是，你必须返回*恰好一个元素*，例如一个`div`元素、一个标题或一个React片段。毕竟，函数组件是函数（你将只使用函数组件）。
- en: React does not have a dedicated templating language with a special syntax for
    looping over arrays of objects or `if-else` constructs. Instead, you can rely
    on the full power of JavaScript and use the standard language features such as
    `map` for iterating through arrays, `filter` for filtering data, ternary operators
    for `if-else` constructs, template literals for string interpolations, and more.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: React没有为遍历对象数组或`if-else`结构提供专门的模板语言和特殊语法。相反，你可以依赖JavaScript的全部功能，并使用标准语言特性，如`map`用于遍历数组，`filter`用于过滤数据，三元运算符用于`if-else`结构，模板字符串用于字符串插值，等等。
- en: The next section will discuss React components.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将讨论React组件。
- en: Components
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件
- en: Components are reusable pieces of the UI. They are the functions returning pieces
    or units of UI written in JSX. They are the building blocks of UI in React, allowing
    you to create modular, reusable pieces of code that can be composed to form the
    desired output of the user interface.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 组件是UI的可重用部分。它们是返回UI片段或单元的函数，这些片段或单元是用JSX编写的。它们是React中UI的构建块，允许你创建模块化、可重用的代码片段，这些代码片段可以组合成用户界面的所需输出。
- en: '*Figure 4**.2* shows an application user interface that is visually broken
    into separate components. Each rectangle represents an independent component that
    is imported into the main app component. Some might be repeated several times,
    while others, such as the header and the footer, might be present with only one
    instance:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.2* 展示了一个用户界面应用，该界面在视觉上被拆分为独立的组件。每个矩形代表一个导入到主应用组件中的独立组件。有些可能被重复多次，而其他组件，如页眉和页脚，可能只有一个实例：'
- en: '![](img/B22406_05_02.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22406_05_02.jpg)'
- en: 'Figure 4.2: Breaking an app into components'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：将应用拆分为组件
- en: One of the first stages of planning the development of a React site is the identification
    of areas, or pieces, that could be abstracted into components and reused in some
    way or at least abstracted into separate units.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 规划 React 网站开发的第一阶段之一是识别可以抽象为组件并以某种方式重用或至少抽象为单独单元的区域或部分。
- en: 'Next, we will create a minimal component for displaying the header on a page.
    The component should have an easy task: to display the header, in your case, the
    title of the page.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个用于在页面上显示页眉的最小组件。该组件的任务很简单：显示页眉，在你的情况下，是页面的标题。
- en: 'Functional components in React.js are defined as files with `.jsx` or `.js`
    extensions, and like your `App.jsx` file (the root component), they must return
    a single JSX element. The filenames should be capitalized. This is a great moment
    in which to use your previously installed React extension for Visual Studio Code
    as it provides useful snippets for creating standard components. Follow these
    steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 React.js 中的函数组件定义为具有 `.jsx` 或 `.js` 扩展名的文件，并且像你的 `App.jsx` 文件（根组件）一样，它们必须返回一个单一的
    JSX 元素。文件名应该大写。这是一个使用你之前安装的 Visual Studio Code React 扩展的绝佳时刻，因为它提供了创建标准组件的有用代码片段。按照以下步骤操作：
- en: Create a folder and name it `components` in your `/src` folder along with a
    new file called `Header.jsx` in it.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/src` 文件夹中创建一个文件夹，命名为 `components`，并在其中创建一个名为 `Header.jsx` 的新文件。
- en: Now, open the newly created file and type in `rafce`. The editor should suggest
    creating a component shell called `reactArrowFunctionExportComponent`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开新创建的文件，输入 `rafce`。编辑器应该建议创建一个名为 `reactArrowFunctionExportComponent` 的组件外壳。
- en: 'Select this entry from the suggestion list and you will see your file filled
    with a typical ES6 arrow function component exported:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从建议列表中选择此条目，你会看到你的文件被填充了一个典型的 ES6 箭头函数组件导出：
- en: '[PRE10]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This file defines a single JSX topmost element—called `Header`—and exports it
    at the bottom.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此文件定义了一个单一的 JSX 最顶层元素——称为 `Header`——并在底部导出它。
- en: 'Make some edits to this file, making use of our Tailwind CSS framework classes
    to make a `div` element. At this point, don’t worry about responsiveness or fancy
    coloring. Replace the `Header` element with the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对此文件进行一些编辑，使用我们的 Tailwind CSS 框架类来创建一个 `div` 元素。在此阶段，不必担心响应式或花哨的配色。用以下代码替换 `Header`
    元素：
- en: '[PRE11]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After these edits, which are purely Tailwind-related, import the first component
    to our `App.jsx` file. Imports are handled in terms of the relative path—remember
    that the dot denotes the current directory of the file (`/src`, in your case),
    while `/components` is the folder in which you are keeping your components. The
    `App.jsx` file should also include an instance of the `Header` component. Replace
    the contents of the `App.jsx` file with the following code:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些编辑（纯粹与 Tailwind 相关）之后，将第一个组件导入到我们的 `App.jsx` 文件中。导入以相对路径处理——记住，点表示文件的当前目录（在你的情况下是
    `/src`），而 `/components` 是你存放组件的文件夹。`App.jsx` 文件还应包含一个 `Header` 组件的实例。用以下代码替换 `App.jsx`
    文件的内容：
- en: '[PRE12]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Vite should automatically reload the app for you if you haven’t stopped the
    `npm run` `dev` process.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你没有停止 `npm run dev` 进程，Vite 应该会自动为你重新加载应用。
- en: You will see that your simple web page now has a simple header component. It
    is an `H1` element and has some basic formatting, as it is purple, centered, and
    has a yellow border. You imported the component as a self-closing tag. It is worth
    noting that components can be self-closing or (like an `H1` tag, for instance)
    enclose the data provided via children.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到你的简单网页现在有一个简单的页眉组件。它是一个 `H1` 元素，并有一些基本的格式化，因为它呈紫色，居中，并带有黄色边框。你以自闭合标签的形式导入了组件。值得注意的是，组件可以是自闭合的，或者（例如，`H1`
    标签）可以包含通过子元素提供的数据。
- en: 'You just made your first, very simple, React functional component. In this
    way, you can break down the functionality of your entire website. You can add
    a footer, some navigation, and more. The process of breaking an app down into
    components and deciding what should constitute a single component is so important
    that the React documentation has an excellent page dedicated to the process: [https://reactjs.org/docs/thinking-in-react.html](https://reactjs.org/docs/thinking-in-react.html).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚制作了第一个非常简单的React函数组件。通过这种方式，你可以将整个网站的功能分解开来。你可以添加页脚、一些导航等。将应用程序分解成组件并决定什么应该构成一个单独的组件的过程非常重要，React文档有一个专门的页面介绍了这个过程：[https://reactjs.org/docs/thinking-in-react.html](https://reactjs.org/docs/thinking-in-react.html)。
- en: Creating dynamic components
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动态组件
- en: Crafting components like this is nice and quick, but it can become tedious if
    the output is fixed. Fortunately, React components are functions, and functions
    can take arguments then do something useful with those arguments. Suppose you
    want to create a component that will replace your plain list of car brands and
    display the information in a more pleasing and informative way. You can pass the
    data for each car in your data array (an object) and have it formatted in a specified
    way.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 制作这样的组件既方便又快捷，但如果输出是固定的，可能会变得繁琐。幸运的是，React组件是函数，函数可以接受参数，然后对这些参数进行有用的操作。假设你想创建一个组件，用它来替换你的普通汽车品牌列表，并以更令人愉悦和更有信息量的方式显示信息。你可以传递数据数组中每个汽车的数据（一个对象），并按指定方式格式化。
- en: 'To redo your procedure for displaying the list, follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新执行显示列表的流程，请按照以下步骤操作：
- en: 'Create a new file in the `components` folder, name it `Card.jsx`, and type
    `rafce` in order to get the correct component template. Replace the `Card` component
    with the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中创建一个新文件，命名为`Card.jsx`，并输入`rafce`以获取正确的组件模板。用以下代码替换`Card`组件：
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This component, unlike the `Header` component that you made earlier, accepts
    props, or properties that define the component behavior. The `Card` component
    is a simple reusable abstraction that is repeated across the page wherever needed.
    You also made use of ES7 object *destructuring* to make the component a bit easier
    on the eyes and not have to repeat `props.name`, `props.model`, and so on.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与你之前制作的`Header`组件不同，这个组件接受props，即定义组件行为的属性。`Card`组件是一个简单的可重复使用的抽象，在需要的地方重复出现在页面上。你还使用了ES7对象*解构*，使组件看起来更易于阅读，并且不必重复`props.name`、`props.model`等。
- en: 'Update the `App.jsx` main file to make proper use of `Card`. Replace the contents
    of `App.jsx` with the following code:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`App.jsx`主文件，以正确使用`Card`。用以下代码替换`App.jsx`的内容：
- en: '[PRE14]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, the goal is to use the newly created `Card` component and pass it all
    the needed data. Update `Card.jsx` with the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，目标是使用新创建的`Card`组件，并传递所有所需的数据。用以下代码更新`Card.jsx`：
- en: '[PRE15]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, instead of returning the `div` elements when mapping through your data,
    you are returning your `Card` component and passing it the key—that is, the ID
    of the `car` object. Note that the ID has to be unique or React will throw warnings
    in the console indicating that we haven’t specified it. Additionally, you’re passing
    something that you can refer to as `el` and set to the element—the `car` object
    from your data array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在通过数据映射时，你不再返回`div`元素，而是返回你的`Card`组件，并传递给它键——即`car`对象的ID。请注意，ID必须是唯一的，否则React将在控制台抛出警告，表明我们没有指定它。此外，你传递了一个可以称为`el`的东西，并将其设置为元素——即来自你的数据数组的`car`对象。
- en: Your `Card` component is now able to display data related to the cars—each card
    holds the data of a single car. You passed data through props (short for properties)
    to each card. You just have to accept it in the component.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的`Card`组件现在能够显示与汽车相关的数据——每张卡片都包含一辆汽车的数据。你通过props（简称属性）将数据传递给每张卡片。你只需在组件中接受它即可。
- en: It is easy to pass props to components, but since props provide one-way communication,
    in most apps, you will have to deal with the **state** as well, which is discussed
    in the next section
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 向组件传递props很容易，但由于props提供单向通信，在大多数应用程序中，你还将不得不处理**状态**，这将在下一节讨论。
- en: Events and state
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件和状态
- en: React exposes and wraps all the standard DOM events—button and link clicks,
    form submissions, mouse hovers, keyups and keydowns, and more. Handling these
    events in React is relatively intuitive. A click event will be handled by a synthetic
    event called `onClick`; events are named by using the **camelCase naming convention**.
    In React, **event handlers** are functions that are triggered when an interaction
    occurs. These functions accept function handlers, which are other functions, as
    props. The simplest possible case would be clicking a button (although it could
    be any DOM element).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供并包装了所有标准的 DOM 事件——按钮和链接点击、表单提交、鼠标悬停、按键和键释放，等等。在 React 中处理这些事件相对直观。一个点击事件将由一个名为
    `onClick` 的合成事件来处理；事件命名使用 **驼峰命名法**。在 React 中，**事件处理程序**是在发生交互时被触发的函数。这些函数接受函数处理程序作为属性，这些处理程序是其他函数。最简单的情况是点击一个按钮（尽管它可以是任何
    DOM 元素）。
- en: 'Create a simple component in a file called `Button.jsx` in the `/components`
    directory that contains a button that, when clicked, displays a message in the
    console:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/components` 目录中创建一个名为 `Button.jsx` 的文件，其中包含一个按钮，当点击时，会在控制台中显示一条消息：
- en: 'Paste the following code into your `Button.jsx` file after performing the `racfe`
    action:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行 `racfe` 操作后，将以下代码粘贴到你的 `Button.jsx` 文件中：
- en: '[PRE16]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a simple example and it showcases the underlying mechanism; `onClick`
    is React’s way of knowing what event it should listen to and the `handleClick`
    function executes your (rather simple) business logic. If you import the button
    into the `App.jsx` file and click the button, you should see the messages in the
    console.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，它展示了底层机制；`onClick` 是 React 知道它应该监听什么事件的反应方式，而 `handleClick` 函数执行你的（相当简单）业务逻辑。如果你将按钮导入
    `App.jsx` 文件并点击按钮，你应该在控制台中看到消息。
- en: 'The implementation is very simple; update the `App.jsx` component with the
    following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现非常简单；更新 `App.jsx` 组件，如下所示：
- en: '[PRE17]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: React Hooks with events and state
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有事件和状态的 React 钩子
- en: The components of React are essentially functions that convert a state to a
    user interface. A React component isa function that takes props as arguments.
    It can be thought of as an updatable data structure responsible for the component
    behavior. The output of the function, the component, is a JSX element. Essentially,
    React Hooks are functional constructs that enable you to tap into the life cycle
    of a component and change its state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: React 的组件本质上是将状态转换为用户界面的函数。一个 React 组件是一个接受 props 作为参数的函数。它可以被视为一个可更新的数据结构，负责组件的行为。函数的输出，即组件，是一个
    JSX 元素。本质上，React 钩子是功能结构，它使你能够访问组件的生命周期并改变其状态。
- en: 'While there are many standard React Hooks and numerous external ones, you will
    work with only two, which are the most fundamental for React comprehension: `useState`
    and `useEffect`. These two Hooks will remain in the forthcoming React version
    19, while others, such as `useMemo`, `useCallback`, and some others, will be gradually
    deprecated. It is also true that while mastering React takes some time, much of
    standard UI functionality can be achieved through clever combinations of these
    two Hooks.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多标准的 React 钩子和许多外部的钩子，但你将只使用两个，这两个是最基本的 React 理解：`useState` 和 `useEffect`。这两个钩子将保留在即将到来的
    React 版本 19 中，而其他如 `useMemo`、`useCallback` 以及一些其他钩子将被逐渐弃用。同样，掌握 React 需要一些时间，但许多标准的
    UI 功能可以通过这两个钩子的巧妙组合来实现。
- en: Creating stateful variables with useState
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `useState` 创建有状态变量
- en: The `useState` Hook allows you to maintain a certain state throughout your component.
    For example, you might want to maintain some kind of state in your SPA, so the
    website doesn’t show you any cars that are too expensive based on your specified
    budget. You can make a simple textbox, set it to display just numeric values,
    and hook it up with a state variable that you can name `budget`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`useState` 钩子允许你在组件中维护某种状态。例如，你可能想在你的单页应用（SPA）中维护某种状态，这样网站就不会根据你指定的预算显示任何太贵的汽车。你可以创建一个简单的文本框，将其设置为仅显示数值，并将其与名为
    `budget` 的状态变量连接起来。'
- en: 'Replace the contents of the `App.jsx` file with the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `App.jsx` 文件的内容替换为以下代码：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding example, you first import the `useState` Hook from React.
    The `useState` Hook returns two values:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你首先从 React 中导入 `useState` 钩子。`useState` 钩子返回两个值：
- en: A variable, which can be anything you want—an array or an object, a simple number,
    or a string
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量，可以是任何你想要的东西——一个数组或一个对象，一个简单的数字，或一个字符串
- en: A function that sets the value for this state variable
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个设置此状态变量值的函数
- en: 'Although you can use any legal JavaScript name, it is a good convention to
    use the name of the variable—in your case, `budget`—and the same name prepended
    with `set`: `setBudget`. With this simple line of code, you have told React to
    set up a state unit called `budget` and to set up a setter. The argument of the
    `useState()` call is the initial value. In the following case, you have set it
    to 20,000 dollars.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用任何合法的JavaScript名称，但使用变量的名称——在你的情况下，`budget`——以及以相同名称前缀的名称是一个好习惯：`setBudget`。通过这一行简单的代码，你已经告诉React设置一个名为`budget`的状态单元，并设置一个设置器。`useState()`调用的参数是初始值。在以下情况下，你将其设置为20,000美元。
- en: 'The following image shows the updated web app with the updateable budget box:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了带有可更新预算框的更新后的Web应用：
- en: '![](img/B22406_05_03.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22406_05_03.jpg)'
- en: 'Figure 4.3: Listing cars'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：列出汽车
- en: 'Now, you are free to use this state variable across the page. Here, you placed
    the `useState` call inside the `App` functional component—if you try to place
    it elsewhere, it will not work: Hooks tap into the lifecycle of components from
    the inside of the bodies of the functions defining the components themselves!'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在整个页面上自由使用这个状态变量。在这里，你将`useState`调用放在了`App`函数组件内部——如果你尝试将其放在其他地方，它将不会工作：钩子从定义组件本身的函数体内部访问组件的生命周期！
- en: Moving down to the bottom of the component, you added a simple textbox. You
    can set it to display only numeric values with HTML and a step of `1000` and add
    an `onChange` handler.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一直向下到组件的底部，你添加了一个简单的文本框。你可以使用HTML将其设置为仅显示数值，步长为`1000`，并添加一个`onChange`处理程序。
- en: This is a good moment to emphasize yet again that React uses the so-called **synthetic
    event**, a wrapper around the browser’s native events that enables React to achieve
    cross-browser compatibility. Once you have remembered a couple of differences
    (that the events are using camelCase rather than lowercase, and you must pass
    them a function in JSX), you will be writing event handlers in no time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个再次强调的好时机，即React使用所谓的**合成事件**，它是浏览器原生事件的一个包装器，使React能够实现跨浏览器兼容性。一旦你记住了几个差异（事件使用的是camelCase而不是小写，你必须将它们传递给JSX中的函数），你将很快就能编写事件处理程序。
- en: In your app, you added an `onChange` event to the textbox and set it to handle
    the state, then you set the new value of the budget. Every time you change the
    value, the `setBudget` function fires, and, as a consequence, the budget updates
    and different `Card` instances are displayed that match your budget constraints.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中，你向文本框添加了一个`onChange`事件，并设置它来处理状态，然后你设置了预算的新值。每次你更改值时，`setBudget`函数都会触发，因此预算更新，并显示符合你的预算约束条件的不同`Card`实例。
- en: This `onChange` event takes the current value of the textbox (`target.value`,
    just like the original DOM events, as it’s just a wrapper) and sets your budget
    state to this value using our `useState` call defined just above the function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`onChange`事件获取文本框的当前值（`target.value`，就像原始DOM事件一样，因为它只是一个包装器），并使用我们定义在函数上方刚刚的`useState`调用将你的预算状态设置为这个值。
- en: Finally, you’ve added a `div` element component that uses this budget value
    and displays it. You have added a state variable to your app’s root component.
    You can set it, get it, and display it on the page.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你添加了一个使用此预算值并显示它的`div`元素组件。你已经在你的应用根组件中添加了一个状态变量。你可以设置它、获取它，并在页面上显示它。
- en: Now, you have accomplished another task typical for developing React apps. You
    have allowed the user to enter their budget and you are displaying it on the page.
    If you want to differentiate between cars that fit said budget and those that
    do not, you will make use of some simple JavaScript and component state. To get
    this to work, set your small data sample that is currently hardcoded to be a state
    variable itself, so the user can just filter it and display only those cars within
    the price range.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经完成了开发React应用时典型的另一个任务。你允许用户输入他们的预算，并在页面上显示它。如果你想区分符合该预算的汽车和不符合的汽车，你可以使用一些简单的JavaScript和组件状态。为了使这生效，将当前硬编码的小数据样本设置为状态变量本身，这样用户就可以过滤它并仅显示那些在价格范围内的汽车。
- en: 'The procedure is simple and involves pure JavaScript to accomplish the task
    of displaying an array of cars satisfying the condition that their price is less
    than or equal to your budget. Hint: Use JavaScript filtering arrays as shown in
    bold in the following code sample:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程很简单，涉及到纯JavaScript来完成显示满足价格小于或等于你的预算条件的汽车数组的任务。提示：使用以下代码示例中加粗显示的JavaScript过滤数组：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, you can dive into the excellent React.js documentation and learn
    more about the `useState` Hook and its sibling, the `useReducer` Hook ([https://react.dev/reference/react/useState](https://react.dev/reference/react/useState)).
    This is a Hook that might be thought of as a generalization of the `useState`
    Hook. It is best suited when you have to deal with numerous pieces of state that
    are interconnected, so managing them with many simple `useState` Hooks could end
    up being tedious and difficult to maintain.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以深入研究优秀的React.js文档，了解更多关于`useState`Hook及其兄弟Hook `useReducer`的信息（[https://react.dev/reference/react/useState](https://react.dev/reference/react/useState)）。这是一个可能被视为`useState`Hook泛化的Hook。它最适合当你必须处理多个相互关联的状态时，使用多个简单的`useState`Hook来管理它们可能会变得繁琐且难以维护。
- en: In this section, you have seen how the `useState` Hook enables you to add a
    stateful variable in a very simple and straightforward way and how to manipulate
    the state through regular events.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你看到了如何通过`useState`Hook以非常简单直接的方式添加一个有状态的变量，以及如何通过常规事件来操作状态。
- en: Next, you will learn how you can get your data from your efficient FastAPI backend
    into your React.js frontend. You will get to know another Hook called `useEffect`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何将你的数据从高效的FastAPI后端传输到你的React.js前端。你将了解另一个名为`useEffect`的Hook。
- en: Communicating with APIs and the outside world using useEffect
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`useEffect`与API和外部世界进行通信
- en: Here, you can use a free mock REST API. However, you do need to address the
    problem of accessing external data and the management of external events. External
    to what, you might wonder?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用免费的模拟REST API。然而，你确实需要解决访问外部数据以及管理外部事件的问题。外部指的是什么，你可能想知道？
- en: You have seen that React and its mighty Hooks are centered around the task of
    synchronizing the UI to the state and the data. Components can contain other components,
    and together, they form what is known as a **component tree**, which is then constantly
    compared to the current state. React does all of this coordination work, to determine
    what should be rendered, updated, and more.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到，React及其强大的Hooks围绕着同步UI到状态和数据这一任务。组件可以包含其他组件，它们共同构成了所谓的**组件树**，然后这个组件树会不断与当前状态进行比较。React负责所有这些协调工作，以确定应该渲染、更新以及更多。
- en: 'Events that are outside of the React data flow process are called **side effects**.
    Notable examples of React side effects are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在React数据流过程之外的事件被称为**副作用**。以下是一些显著的React副作用示例：
- en: Performing API calls—sending or receiving data from an external server
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行API调用——从外部服务器发送或接收数据
- en: Subscribing to external data sources via websockets or streams
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WebSockets或流订阅外部数据源
- en: Setting or getting data values to and from the local storage or session storage
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地存储或会话存储中设置或获取数据值
- en: Event listeners and their cleanup functions
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件监听器和它们的清理函数
- en: Remember that React works in a continuous data flow, with an underlying system
    constantly scanning for updates and ready to re-render components that it deems
    in need of an update. The following example will illustrate this.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，React在一个持续的数据流中工作，其底层系统不断扫描更新，并准备好重新渲染它认为需要更新的组件。以下示例将说明这一点。
- en: Consider that you are working on your *Car Sales* application and you need to
    list all the users that have registered an account. The task at hand is a simple
    and common one. You have a dedicated page—it will live in a URL called `/users`
    or something similar, and it should be populated with the data (think of a JavaScript
    array of objects) from an external API. This API will be powered by FastAPI, but
    for now, you will use a readymade mock solution called Jsonplaceholder.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开发你的*汽车销售*应用程序，并且你需要列出所有注册了账户的用户。当前的任务既简单又常见。你有一个专门的页面——它将存在于一个名为`/users`或类似URL上，并且应该用来自外部API的数据（想象一下一个包含对象的JavaScript数组）填充。这个API将由FastAPI提供支持，但就目前而言，你将使用一个现成的模拟解决方案，称为Jsonplaceholder。
- en: The `GET` call you need to make should be directed toward the URL [https://jsonplaceholder.typicode.com/users/](https://jsonplaceholder.typicode.com/users/).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要发出的`GET`请求应指向URL [https://jsonplaceholder.typicode.com/users/](https://jsonplaceholder.typicode.com/users/)。
- en: You already understand how to make components, provide them with props, and
    set their state, so that shouldn’t be a problem. When it comes to loading data
    from an external API, you might just use something such as `Fetch` or `Axios`,
    as if you were using a normal plain JavaScript app. `Fetch` and `Axios` are the
    two most popular JavaScript libraries used for making HTTP requests to servers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了如何创建组件，为它们提供 props 并设置状态，所以这不应该是个问题。当涉及到从外部 API 加载数据时，你可能只是使用像 `Fetch`
    或 `Axios` 这样的工具，就像你在使用一个普通的纯 JavaScript 应用程序一样。`Fetch` 和 `Axios` 是用于向服务器发起 HTTP
    请求的最流行的两个 JavaScript 库。
- en: Trying to fetch the data in a React component and then setting the state to
    the resulting JSON would start an **infinite loop**. Bear in mind that React came
    before the server component with async code existed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 React 组件中获取数据并将状态设置为结果 JSON 将会启动一个**无限循环**。记住，React 在异步代码存在的服务器组件之前就已经存在了。
- en: Whenever the state of a component changes and the component is re-rendered,
    the new render again triggers a `fetch` call to the API, the state changes again
    to be set to the list of users, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每当组件的状态发生变化并且组件被重新渲染时，新的渲染会再次触发对 API 的 `fetch` 调用，状态再次改变以设置为用户列表，等等。
- en: In this component’s data flow, the fetching of the data is considered external—not
    part of the main component life cycle. It is executed after the component has
    been executed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组件的数据流中，数据的获取被认为是外部的——不是主组件生命周期的一部分。它是在组件执行之后执行的。
- en: To deal with this problem, React has a very elegant solution—the `useEffect`
    Hook. You can create a new application by editing the `App.jsx` main component,
    and then display a list of users from your API endpoint.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，React 有一个非常优雅的解决方案——`useEffect` 钩子。你可以通过编辑 `App.jsx` 主组件来创建一个新的应用程序，然后从你的
    API 端点显示用户列表。
- en: 'You can implement a possible solution using the `useEffect` Hook. Paste the
    following code into your `App.jsx` file (refer `App3.jsx`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `useEffect` 钩子实现一个可能的解决方案。将以下代码粘贴到你的 `App.jsx` 文件中（参考 `App3.jsx`）：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At the top of the `App.jsx` file, import `useState` and `useEffect` and then
    you can begin creating your sole state variable—the `users` array—initializing
    it to an empty array.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.jsx` 文件顶部，导入 `useState` 和 `useEffect`，然后你可以开始创建你的唯一状态变量——`users` 数组，将其初始化为空数组。
- en: The `fetchUsers` function is simple—it makes a call to the API and returns data
    in JSON format, using promises. It could also have been an `async`/`await` function.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchUsers` 函数很简单——它调用 API 并使用承诺返回 JSON 格式的数据，也可以是一个 `async`/`await` 函数。'
- en: 'The `useEffect` Hook, as with all Hooks, is executed inside the component function.
    It does not return a value, however, and it accepts two arguments: the function
    to be executed (in this case, `fetchUsers`), and a dependency array, an array
    of values whose change in value will trigger a new execution of the effect. If
    the function should trigger only once, the array should be empty. If you want
    to fetch other users from the next API URL, you must add the URL to the array.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`useEffect` 钩子，就像所有钩子一样，是在组件函数内部执行的。然而，它不返回任何值，它接受两个参数：要执行的功能（在这种情况下，`fetchUsers`），以及一个依赖数组，一个值数组的改变将触发效果的重新执行。如果函数应该只触发一次，则数组应为空。如果你想从下一个
    API URL 获取其他用户，你必须将 URL 添加到数组中。'
- en: As with `useState`, there are many more subtleties involved. For example, you
    can provide a cleanup function at the bottom of the `useEffect` body to make sure
    that any long-lasting effects are removed, but this should give you a basic idea
    of how to handle actions that reach out to an external API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `useState` 一样，其中还涉及许多细微之处。例如，你可以在 `useEffect` 体的底部提供一个清理函数，以确保任何长期效果都被移除，但这应该能给你一个如何处理调用外部
    API 的动作的基本概念。
- en: Additionally, `useContext` allows React to cover an entire area of components
    and pass values directly without having to pass them through several components
    that might not actually need it, a procedure called prop drilling. You can even
    create your own Hooks and abstract functionality that can be reused in several
    places of the app, ensuring better maintainability and less repetition.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`useContext` 允许 React 覆盖整个组件区域并直接传递值，而无需通过可能实际上不需要它的几个组件传递，这个过程被称为属性钻取。你甚至可以创建自己的钩子并抽象出可以在应用程序的多个地方重用的功能，确保更好的可维护性和减少重复。
- en: With the introduction of Hooks, the whole ecosystem becomes much clearer and
    cleaner, and the mapping of business logic to UIs is much more streamlined and
    logical.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Hooks 的引入，整个生态系统变得更加清晰和简洁，将业务逻辑映射到 UI 的过程也变得更加流畅和逻辑化。
- en: You now have the knowledge that is necessary to set and get states in your components
    or apps and to communicate with external API services in a predictable and controllable
    way, while crafting clean and simple code. Just using React and its Hooks can
    give you web developer proficiency, but there is a whole ecosystem of packages
    and modules built around React that can be just as important and useful as the
    core libraries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了在组件或应用中设置和获取状态，以及以可预测和可控的方式与外部 API 服务通信所需的知识，同时编写干净和简单的代码。仅仅使用 React 和其
    Hooks 就可以让你获得网络开发的专业技能，但围绕 React 构建的整个生态系统中的包和模块同样重要和有用，就像核心库一样。
- en: Exploring React Router and other useful packages
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 React Router 和其他有用的包
- en: So far, you have only created a couple of single-page apps, but you haven’t
    touched some advanced functionalities. However, single-page apps are not limited
    to a single URL. For example, if you navigate to your Gmail account, you will
    see that the URL changes with every action that you might take.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只创建了一些单页应用，但还没有接触一些高级功能。然而，单页应用并不局限于单个 URL。例如，当你导航到你的 Gmail 账户时，你会看到
    URL 会随着你可能采取的每个动作而改变。
- en: While there are several solutions that enable you to achieve routing in SPAs,
    React Router is the standard solution, and it is a well-tested, mature package.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有几种解决方案可以实现单页应用中的路由，但 React Router 是标准解决方案，它是一个经过充分测试的成熟包。
- en: The underlying idea of a frontend page router is that it should enable rendering
    different components on the same page depending on the route that is loaded. For
    instance, the `/about` route would cause the app to load a component called `About.jsx`
    in the main `App` component, removing other previously loaded components. The
    package provides a basic structure, within the `BrowserRouter` class, which can
    be used to wrap an entire root `App` component.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前端页面路由的底层理念是它应该能够根据加载的路由在同一个页面上渲染不同的组件。例如，`/about` 路由会导致应用在主 `App` 组件中加载一个名为
    `About.jsx` 的组件，移除之前加载的其他组件。该包提供了一个基本结构，在 `BrowserRouter` 类中，可以用来包装整个根 `App` 组件。
- en: React is such a popular framework that there is a diverse ecosystem of tools
    and integrations that you can learn about. As you’ve already seen earlier, besides
    Tailwind, you can use virtually any UI or CSS framework either directly or through
    some optimized React version, such as Bootstrap, or more tightly coupled with
    React, such as Ant Design. You can enhance your user experience with subtle animations
    through Framer Motion, and you can speed up the development of forms with some
    excellent form libraries such as React Hook Form. For complex state problems,
    Redux is the most popular and widely adopted industry standard, but there are
    many smaller or specialized libraries for local and global state management, such
    as **Recoil**, **Zustand**, or **React Query**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: React 是如此受欢迎的框架，以至于有一个多样化的工具和集成生态系统，你可以了解。正如你之前已经看到的，除了 Tailwind，你几乎可以使用任何 UI
    或 CSS 框架，无论是直接使用还是通过一些优化的 React 版本，如 Bootstrap，或者更紧密地与 React 结合，如 Ant Design。你可以通过
    Framer Motion 的微妙动画来增强用户体验，也可以通过一些优秀的表单库如 React Hook Form 来加速表单的开发。对于复杂的状态问题，Redux
    是最受欢迎和最广泛采用的行业标准，但还有许多针对本地和全局状态管理的较小或专用库，如 **Recoil**、**Zustand** 或 **React Query**。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided a short introduction to the world’s most popular user
    interface library—React.js.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 本章简要介绍了世界上最受欢迎的用户界面库——React.js。
- en: This chapter also detailed what JSX is and why it’s so convenient for developers.
    It explored the basic building blocks of React, functional components, and the
    basic rules that must be followed when designing them. It also introduced two
    fundamental React Hooks that, when combined, allow you to begin building basic
    user interfaces, maintain and change the state of the components, and interact
    with external APIs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还详细介绍了 JSX 是什么以及为什么它对开发者来说如此方便。它探讨了 React 的基本构建块——函数组件，以及在设计它们时必须遵循的基本规则。它还介绍了两个基本的
    React Hooks，当结合使用时，允许你开始构建基本的用户界面，维护和更改组件的状态，以及与外部 API 交互。
- en: Finally, the chapter covered the implementation of some of the React libraries
    that will make your life easier when developing custom applications. These libraries
    all have excellent documentation and are updated frequently.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章介绍了实现一些可以使开发自定义应用时生活更轻松的React库。这些库都拥有优秀的文档，并且经常更新。
- en: The next chapter will use some of this basic knowledge and React to create a
    simple but fully functional and dynamic application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将利用这些基础知识以及React来创建一个简单但功能齐全且动态的应用程序。
