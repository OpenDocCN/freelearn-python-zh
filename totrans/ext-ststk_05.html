<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Rendering Data" id="VF2I1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Rendering Data</h1></div></div></div><p class="calibre8">Having the ability to write your own execution and state modules is powerful from a developer's point of view, but you cannot overlook being able to provide that kind of power to users who do not have the ability to provide modules of their own.</p><p class="calibre8">Renderers allow users to <a id="id151" class="calibre1"/>provide data to various parts of Salt using different kinds of data input formats. The handful of renderers that ship with Salt cover the majority of use cases, but what if your users need to apply data in a specialized format? Or even a more common one that is not yet supported, such as XML? In this chapter, we'll discuss:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Writing renderers</li><li class="listitem">Troubleshooting renderers</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Rendering Data" id="VF2I1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Understanding file formats"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec26" class="calibre1"/>Understanding file formats</h1></div></div></div><p class="calibre8">By default, Salt uses <a id="id152" class="calibre1"/>YAML for its various files. There are two primary reasons for this:</p><div class="book"><ul class="itemizedlist"><li class="listitem">YAML is easily converted into Python data structures</li><li class="listitem">YAML is easy for humans to read and modify</li></ul></div><p class="calibre8">Salt configuration files must be in YAML as well (or JSON, which can be read by YAML parsers), but other files such as states, pillars, reactors, and so on can use other formats. A data serialization format is the most common, but any format that can be translated into a Python dictionary will do just fine.</p><p class="calibre8">For example, there are three different Python renderers that ship with Salt: <code class="email">py</code>, <code class="email">pyobjects</code>, and <code class="email">pydsl</code>. Each has its strengths and weaknesses, but the end result is the same: they execute Python code that results in a dictionary, which is then passed into Salt.</p><p class="calibre8">Generally speaking, you will find two types of renderers inside of Salt. The first returns data in a Python data structure. Both serializers and code-based modules fit into this category. The second is for managing text formatting and templating. Let's talk about each in turn, and then build our own renderers later on in the chapter.</p></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Rendering Data" id="VF2I1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Understanding file formats">
<div class="book" title="Serializing data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec48" class="calibre1"/>Serializing data</h2></div></div></div><p class="calibre8">Data <a id="id153" class="calibre1"/>can be stored in any number of formats, but in the end, that data must be something that can be turned into instructions. Formats such as YAML and JSON are obvious choices, because they are easy to modify and mirror the resulting data structures in the program that uses them. Binary formats such as Message Pack aren't as easily modified by humans, but they still result in the same data structures.</p><p class="calibre8">Other formats, such as XML, are more difficult because they don't directly resemble the internal data structures of programs like Salt. They're great for modeling code that makes heavy use of classes, but Salt doesn't make much use of such code. However, when you know how such a format can be converted into a data structure that Salt can use, then building a renderer for it is not difficult.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Rendering Data" id="VF2I1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Understanding file formats">
<div class="book" title="Working with templates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec49" class="calibre1"/>Working with templates</h2></div></div></div><p class="calibre8">Templates<a id="id154" class="calibre1"/> are important because they allow end users to use certain programmatic elements without having to write actual modules. Variables are certainly one of the most critical elements of a templating engine, but other constructs such as loops and branching can also give a lot of power to the user.</p><p class="calibre8">Templating renderers differ from data-serializing renderers in that instead of returning data in a dictionary format, which is then ingested by Salt, they return data that must be converted at least one more time, using a data-serialization renderer.</p><p class="calibre8">This may seem counterintuitive on some levels, but the use of render pipes brings these two elements together.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Rendering Data" id="VF2I1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Understanding file formats">
<div class="book" title="Using render pipes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec50" class="calibre1"/>Using render pipes</h2></div></div></div><p class="calibre8">Render pipes <a id="id155" class="calibre1"/>are based on Unix pipes; data can be passed from module to module through a series of pipes, in order to arrive at the final data structure. You may not realize it, but if you've ever written an SLS file, you've used a render pipe.</p><p class="calibre8">To set up a render pipe, you add a line to the top of the file to be rendered, which contains the classic Unix hashbang, followed by the renderers to be used, in the order to be used, separated by the pipe character. The default rendering sequence is effectively:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">#!jinja|yaml</strong></span>
</pre></div><p class="calibre8">This means that the file in question will be first parsed by Jinja2, and compiled into a format that can be read by the YAML library.</p><p class="calibre8">It's generally not reasonable or necessary to pipe more than two different renderers together; the more that are used, the more complicated the resulting file is to understand by humans, and <a id="id156" class="calibre1"/>the greater the chance for errors. Generally, a templating engine that adds programmatic shortcuts, and a data serializer, is plenty. One notable exception is the <code class="email">gpg</code> renderer, which can be used for encryption-at-rest scenarios. The hashbang for this would look like:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">#!jinja|yaml|gpg</strong></span>
</pre></div></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Building a serializing renderer" id="10DJ41-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec27" class="calibre1"/>Building a serializing renderer</h1></div></div></div><p class="calibre8">Renderers <a id="id157" class="calibre1"/>are reasonably easy to build, because they typically do little more than import a library, shove data through it, and then return the result. Our example renderer will make use of Python's own Pickle format.</p></div>

<div class="book" title="Building a serializing renderer" id="10DJ41-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="The basic structure"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec51" class="calibre1"/>The basic structure</h2></div></div></div><p class="calibre8">Outside <a id="id158" class="calibre1"/>of any necessary imports, a renderer requires only a <code class="email">render()</code> function. The most important argument is the first. As with other modules, the name of this argument is not important to Salt, so long as it is defined. Because our example uses the <code class="email">pickle</code> library, we'll use <code class="email">pickle_data</code> as our argument name.</p><p class="calibre8">Other arguments are also passed into renderers, but in our case we'll only use them for troubleshooting. In particular, we need to accept <code class="email">saltenv</code> and <code class="email">sls</code>, with the defaults shown later. We'll cover those in the <span class="strong"><em class="calibre9">Troubleshooting Renderers</em></span> section, but for now we'll just use <code class="email">kwargs</code> to cover them.</p><p class="calibre8">We also need to start with a special kind of <code class="email">import</code>, called <code class="email">absolute_import</code>, that allows us to import the <code class="email">pickle</code> library from a file that's also called <code class="email">pickle</code>.</p><p class="calibre8">Let's go ahead and lay out the module, and then talk about the components in the <code class="email">render()</code> function:</p><div class="informalexample"><pre class="programlisting">'''
Render Pickle files.

This file should be saved as salt/renderers/pickle.py
'''
from __future__ import absolute_import
import pickle
from salt.ext.six import string_types


def render(pickle_data, saltenv='base', sls='', **kwargs):
    '''
    Accepts a pickle, and renders said data back to a python dict.
    '''
    if not isinstance(pickle_data, string_types):
        pickle_data = pickle_data.read()

    if pickle_data.startswith('#!'):
        pickle_data = pickle_data[(pickle_data.find('\n') + 1):]
    if not pickle_data.strip():
        return {}
    return pickle.loads(pickle_data)</pre></div><p class="calibre8">This function does not do much, other than:</p><div class="book"><ul class="itemizedlist"><li class="listitem">First, check to see whether the data being passed in is a string, and if not, treat it as a file-like object.</li><li class="listitem">Check for the existence of a <code class="email">#!</code>, indicating the use of an explicit render pipe. Because that pipe is handled elsewhere, and it will cause errors with the <code class="email">pickle</code> library, discard it.</li><li class="listitem">Check to see whether the resulting content is empty. If so, return an empty dictionary.</li><li class="listitem">Run the data through the <code class="email">pickle</code> library, and return the result.</li></ul></div><p class="calibre8">If you start <a id="id159" class="calibre1"/>comparing this code with the renderers that ship with Salt, you'll find that many of them are almost identical. This is in part because so many data serialization libraries in Python use exactly the same methods.</p><p class="calibre8">Let's put together a file that can be used. The example data that we'll use is:</p><div class="informalexample"><pre class="programlisting">apache:
  pkg:
    - installed
    - refresh: True</pre></div><p class="calibre8">The best way to create this file is with Python itself. Go ahead and open up a Python shell and type the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; import pickle</strong></span>
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; data = {'apache': {'pkg': ['installed', {'refresh': True}]}}</strong></span>
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; out = open('/srv/salt/pickle.sls', 'w')</strong></span>
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; pickle.dump(data, out)</strong></span>
<span class="strong"><strong class="calibre2">&gt;&gt;&gt; out.close()</strong></span>
</pre></div><p class="calibre8">When you exit out of the Python shell, you should be able to open this file in your favorite text editor. When you add a hashbang line to the top that specifies the <code class="email">pickle</code> renderer, your file will probably look like this:</p><div class="informalexample"><pre class="programlisting">#!pickle
(dp0
S'apache'
p1
(dp2
S'pkg'
p3
(lp4
S'installed'
p5
a(dp6
S'refresh'
p7
I01
sass.</pre></div><p class="calibre8">Save the file, and <a id="id160" class="calibre1"/>use <code class="email">salt-call</code> to test out your renderer. This time, we'll tell Salt to dump out the resulting SLS, as Salt sees it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-call --local state.show_sls pickle --out=yaml</strong></span>
<span class="strong"><strong class="calibre2">local:</strong></span>
<span class="strong"><strong class="calibre2">  apache:</strong></span>
<span class="strong"><strong class="calibre2">    __env__: base</strong></span>
<span class="strong"><strong class="calibre2">    __sls__: !!python/unicode pickle</strong></span>
<span class="strong"><strong class="calibre2">    pkg:</strong></span>
<span class="strong"><strong class="calibre2">    - installed</strong></span>
<span class="strong"><strong class="calibre2">    - refresh: true</strong></span>
<span class="strong"><strong class="calibre2">    - order: 10000</strong></span>
</pre></div><p class="calibre8">Salt's state compiler adds some extra information that it uses internally, but we can see that the basics of what we requested are there.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Building a templating renderer" id="11C3M1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec28" class="calibre1"/>Building a templating renderer</h1></div></div></div><p class="calibre8">Building a<a id="id161" class="calibre1"/> renderer that handles templating files is not that different from one that does serialization. In fact, the renderer itself is pretty much the same, outside of the library-specific code. This time, we'll use a Python library called <code class="email">tenjin</code>. You may need to install it using pip:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># pip install tenjin</strong></span>
</pre></div></div>

<div class="book" title="Building a templating renderer" id="11C3M1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Templating with Tenjin"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec52" class="calibre1"/>Templating with Tenjin</h2></div></div></div><p class="calibre8">This module <a id="id162" class="calibre1"/>makes use of a third-party library, so there will be a <code class="email">__virtual__()</code> function to make sure it's installed:</p><div class="informalexample"><pre class="programlisting">'''
Conver a file using the Tenjin templating engine

This file should be saved as salt/renderers/tenjin.py
'''
from __future__ import absolute_import
try:
    import tenjin
    from tenjin.helpers import *
    HAS_LIBS = True
except ImportError:
    HAS_LIBS = False
from salt.ext.six import string_types


def __virtual__():
    '''
    Only load if Tenjin is installed
    '''
    return HAS_LIBS


def render(tenjin_data, saltenv='base', sls='', **kwargs):
    '''
    Accepts a tenjin, and renders said data back to a python dict.
    '''
    if not isinstance(tenjin_data, string_types):
        tenjin_data = tenjin_data.read()

    if tenjin_data.startswith('#!'):
        tenjin_data = tenjin_data[(tenjin_data.find('\n') + 1):]
    if not tenjin_data.strip():
        return {}

    template = tenjin.Template(input=tenjin_data)
    return template.render(kwargs)</pre></div><p class="calibre8">The <code class="email">render()</code> function <a id="id163" class="calibre1"/>itself is fundamentally identical to the one that we used for <code class="email">pickle</code>, except for the last two lines, which handles the templating engine slightly differently.</p><p class="calibre8">Take note of the <code class="email">kwargs</code> that are passed into this function. Templating engines generally have the ability to merge in an external data structure, which can be used with the various data structures in the templating engine itself. Salt will make some data available inside kwargs, so we'll pass that in for Tenjin to use.</p></div></div>

<div class="book" title="Building a templating renderer" id="11C3M1-d9976ffc65994572ad672a3ef48f1135">
<div class="book" title="Using a templating renderer"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec53" class="calibre1"/>Using a templating renderer</h2></div></div></div><p class="calibre8">Of course, you'll need <a id="id164" class="calibre1"/>a hashbang line in your SLS files as before, but since our Tenjin renderer isn't set up to return straight data, you will need to add the name of the desired data-serialization renderer to your render pipe. We'll use the same actual SLS data as before, but with a couple of Tenjin-specific elements added:</p><div class="informalexample"><pre class="programlisting">#!tenjin|yaml
&lt;?py pkg = 'apache'?&gt;
&lt;?py refresh = True?&gt;
#{pkg}:
  pkg:
    - installed
    - refresh: #{refresh}</pre></div><p class="calibre8">We haven't done anything special here, just set a couple of variables, and then used them. The resulting content will be in YAML format, so we've added <code class="email">yaml</code> to our render pipe.</p><p class="calibre8">A number of templating engines, including Tenjin, have the ability to process templates that output either strings (as we've done in our example), or an actual data structure, such as what a data serializer would return. When using such a library, take a moment to consider how much of it you plan to use, and whether it makes sense to create two distinct renderers for it: one for data and one for strings.</p><p class="calibre8">Testing is much the same as before:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre2"># salt-call --local state.show_sls tenjin --out yaml</strong></span>
<span class="strong"><strong class="calibre2">local:</strong></span>
<span class="strong"><strong class="calibre2">  apache:</strong></span>
<span class="strong"><strong class="calibre2">    pkg:</strong></span>
<span class="strong"><strong class="calibre2">    - installed</strong></span>
<span class="strong"><strong class="calibre2">    - refresh: true</strong></span>
<span class="strong"><strong class="calibre2">    - order: 10000</strong></span>
<span class="strong"><strong class="calibre2">    __sls__: !!python/unicode tenjin</strong></span>
<span class="strong"><strong class="calibre2">    __env__: base</strong></span>
</pre></div><p class="calibre8">We can see slight differences between our first example and our second, but those differences just show which module was used to render the data.</p></div></div>
<div class="book" title="Troubleshooting renderers" id="12AK81-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec29" class="calibre1"/>Troubleshooting renderers</h1></div></div></div><p class="calibre8">Because <a id="id165" class="calibre1"/>renderers are so often used to manage SLS files, it is often easiest to troubleshoot them using the state compiler, as we have been doing already in this chapter.</p><p class="calibre8">First, generate a small SLS file that contains the specific elements which you need to test. This will either be a data file in the format that a serialization engine uses, or a text-based file that results in a data-serialization file format. If you are writing a templating renderer, it is often easiest to just use YAML.</p><p class="calibre8">The <code class="email">state</code> execution module <a id="id166" class="calibre1"/>contains a number of functions that exist primarily for troubleshooting. We used <code class="email">state.show_sls</code> in our examples, with <code class="email">--out yaml</code>, because it displays the output in a format that we're already used to in our SLS files. However, some other useful functions are:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">state.show_low_sls</code><a id="id167" class="calibre1"/>: Shows data from a single SLS file, after it has been converted to low data by the State compiler. Low data is often easier to visualize when writing state modules.</li><li class="listitem"><code class="email">state.show_highstate</code>: Shows <a id="id168" class="calibre1"/>all of the states, as they would be applied to a Minion, according to the <code class="email">top.sls</code> file. The output from this will look as if all of the SLS files have been shoved together. This can be useful when troubleshooting rendering issues that you believe span across multiple SLS files.</li><li class="listitem"><code class="email">state.show_lowstate</code>: The data<a id="id169" class="calibre1"/> returned from this function is the same as what <code class="email">state.show_highstate</code> returns, but after being processed by the state compiler. Again, this is like a long version of <code class="email">state.show_low_sls</code>.</li></ul></div></div>
<div class="book" title="Summary" id="1394Q1-d9976ffc65994572ad672a3ef48f1135"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec30" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Renderers are used to convert various file formats into a data structure that is usable internally by Salt. Data-serialization renderers return data in a dictionary format, whereas templating renderers return data that can be processed by a data serializer. Both types of renderer look the same, and require a <code class="email">render()</code> function.</p><p class="calibre8">Now that we know how to handle the data going into Salt, it's time to look at the data coming back out of Salt. Next up: handling return data.</p></div></body></html>