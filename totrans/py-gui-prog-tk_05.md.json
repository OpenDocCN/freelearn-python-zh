["```py\nFunctional Requirements:\n  (...)\n  * have inputs that:\n    - ignore meaningless keystrokes\n    - display an error if the value is invalid on focusout\n    - display an error if a required field is empty on focusout\n  * prevent saving the record when errors are present \n```", "```py\n# validate_demo.py\nimport tkinter as tk\nroot = tk.Tk()\nentry = tk.Entry(root)\nentry.grid()\ndef always_good():\n  return True\nvalidate_ref = root.register(always_good)\nentry.configure(\n  validate='all',\n  validatecommand=(validate_ref,)\n)\nroot.mainloop() \n```", "```py\n# validate_demo.py\n# Place just before root.mainloop()\nentry2 = tk.Entry(root)\nentry2.grid(pady=10)\ndef no_t_for_me(proposed):\n  return 't' not in proposed\nvalidate2_ref = root.register(no_t_for_me)\nentry2.configure(\n  validate='all',\n  validatecommand=(validate2_ref, '%P')\n) \n```", "```py\nentry3 = tk.Entry(root)\nentry3.grid()\nentry3_error = tk.Label(root, fg='red')\nentry3_error.grid()\ndef only_five_chars(proposed):\n  return len(proposed) < 6\ndef only_five_chars_error(proposed):\n  entry3_error.configure(\n  text=f'{proposed} is too long, only 5 chars allowed.'\n  )\nvalidate3_ref = root.register(only_five_chars)\ninvalid3_ref = root.register(only_five_chars_error)\nentry3.configure(\n  validate='all',\n  validatecommand=(validate3_ref, '%P'),\n  invalidcommand=(invalid3_ref, '%P')\n) \n```", "```py\n# five_char_entry_class.py\nclass FiveCharEntry(ttk.Entry):\n  \"\"\"An Entry that truncates to five characters on exit.\"\"\"\n  def __init__(self, parent, *args, **kwargs):\n    super().__init__(parent, *args, **kwargs)\n    self.error = tk.StringVar()\n    self.configure(\n      validate='all',\n      validatecommand=(self.register(self._validate), '%P'),\n      invalidcommand=(self.register(self._on_invalid), '%P')\n    )\n  def _validate(self, proposed):\n    return len(proposed) <= 5\n  def _on_invalid(self, proposed):\n    self.error.set(\n      f'{proposed} is too long, only 5 chars allowed!'\n    ) \n```", "```py\nroot = tk.Tk()\nentry = FiveCharEntry(root)\nerror_label = ttk.Label(\n  root, textvariable=entry.error, foreground='red'\n)\nentry.grid()\nerror_label.grid()\nroot.mainloop() \n```", "```py\n# DateEntry.py\nimport tkinter as tk\nfrom tkinter import ttk\nfrom datetime import datetime\nclass DateEntry(ttk.Entry):\n  \"\"\"An Entry for ISO-style dates (Year-month-day)\"\"\"\n  def __init__(self, parent, *args, **kwargs):\n    super().__init__(parent, *args, **kwargs)\n    self.configure(\n      validate='all',\n      validatecommand=(\n        self.register(self._validate),\n        '%S', '%i', '%V', '%d'\n      ),\n      invalidcommand=(self.register(self._on_invalid), '%V')\n    )\n    self.error = tk.StringVar() \n```", "```py\n def _toggle_error(self, error=''):\n    self.error.set(error)\n    **self.config(foreground=****'red'****if** **error** **else****'black'****)** \n```", "```py\n def _validate(self, char, index, event, action):\n    # reset error state\n    self._toggle_error()\n    valid = True\n    # ISO dates only need digits and hyphens\n    if event == 'key':\n      if action == '0':\n        valid = True\n      elif index in ('0', '1', '2', '3', '5', '6', '8', '9'):\n        valid = char.isdigit()\n      elif index in ('4', '7'):\n        valid = char == '-'\n      else:\n        valid = False \n```", "```py\n# still in DateEntry._validate()\n    elif event == 'focusout':\n      try:\n        datetime.strptime(self.get(), '%Y-%m-%d')\n      except ValueError:\n        valid = False\n    return valid \n```", "```py\n def _on_invalid(self, event):\n    if event != 'key':\n      self._toggle_error('Not a valid date') \n```", "```py\nif __name__ == '__main__':\n  root = tk.Tk()\n  entry = DateEntry(root)\n  entry.pack()\n  ttk.Label(\n    textvariable=entry.error, foreground='red'\n  ).pack()\n  # add this so we can unfocus the DateEntry\n  ttk.Entry(root).pack()\n  root.mainloop() \n```", "```py\nclass Fruit():\n  _taste = 'sweet'\n  def taste(self):\n    print(f'It tastes {self._taste}')\nclass PeelableMixin():\n  def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self._peeled = False\n  def peel(self):\n    self._peeled = True\n  def taste(self):\n    if not self._peeled:\n      print('I will peel it first')\n      self.peel()\n    super().taste() \n```", "```py\nclass Plantain(PeelableMixin, Fruit):\n  _taste = 'starchy'\n  def peel(self):\n    print('It has a tough peel!')\n    super().peel() \n```", "```py\nplantain = Plantain()\nplantain.taste() \n```", "```py\n# data_entry_app.py\nclass ValidatedMixin:\n  \"\"\"Adds a validation functionality to an input widget\"\"\"\n  def __init__(self, *args, error_var=None, **kwargs):\n    self.error = error_var or tk.StringVar()\n    super().__init__(*args, **kwargs) \n```", "```py\n vcmd = self.register(self._validate)\n    invcmd = self.register(self._invalid)\n    self.configure(\n      validate='all',\n      validatecommand=(vcmd, '%P', '%s', '%S', '%V', '%i', '%d'),\n      invalidcommand=(invcmd, '%P', '%s', '%S', '%V', '%i', '%d')\n    ) \n```", "```py\n def _toggle_error(self, on=False):\n    self.configure(foreground=('red' if on else 'black')) \n```", "```py\n def _validate(self, proposed, current, char, event, index, action):\n    self.error.set('')\n    self._toggle_error()\n    valid = True\n    # if the widget is disabled, don't validate\n    state = str(self.configure('state')[-1])\n    if state == tk.DISABLED:\n      return valid\n    if event == 'focusout':\n      valid = self._focusout_validate(event=event)\n    elif event == 'key':\n      valid = self._key_validate(\n      proposed=proposed,\n      current=current,\n      char=char,\n      event=event,\n      index=index,\n      action=action\n    )\n    return valid \n```", "```py\n def _focusout_validate(self, **kwargs):\n    return True\n  def _key_validate(self, **kwargs):\n    return True \n```", "```py\n def _invalid(self, proposed, current, char, event, index, action):\n    if event == 'focusout':\n      self._focusout_invalid(event=event)\n    elif event == 'key':\n      self._key_invalid(\n        proposed=proposed,\n        current=current,\n        char=char,\n        event=event,\n        index=index,\n        action=action\n      )\n  def _focusout_invalid(self, **kwargs):\n    \"\"\"Handle invalid data on a focus event\"\"\"\n    self._toggle_error(True)\n  def _key_invalid(self, **kwargs):\n    \"\"\"Handle invalid data on a key event.  \n    By default we want to do nothing\"\"\"\n    pass \n```", "```py\n def trigger_focusout_validation(self):\n    valid = self._validate('', '', '', 'focusout', '', '')\n    if not valid:\n      self._focusout_invalid(event='focusout')\n    return valid \n```", "```py\n# data_entry_app.py\nclass RequiredEntry(ValidatedMixin, ttk.Entry):\n  \"\"\"An Entry that requires a value\"\"\"\n  def _focusout_validate(self, event):\n    valid = True\n    if not self.get():\n      valid = False\n      self.error.set('A value is required')\n    return valid \n```", "```py\nclass DateEntry(ValidatedMixin, ttk.Entry):\n  \"\"\"An Entry that only accepts ISO Date strings\"\"\"\n  def _key_validate(self, action, index, char, **kwargs):\n    valid = True\n    if action == '0':  # This is a delete action\n      valid = True\n    elif index in ('0', '1', '2', '3', '5', '6', '8', '9'):\n      valid = char.isdigit()\n    elif index in ('4', '7'):\n      valid = char == '-'\n    else:\n      valid = False\n    return valid\n  def _focusout_validate(self, event):\n    valid = True\n    if not self.get():\n      self.error.set('A value is required')\n      valid = False\n    try:\n      datetime.strptime(self.get(), '%Y-%m-%d')\n    except ValueError:\n      self.error.set('Invalid date')\n      valid = False\n    return valid \n```", "```py\nclass ValidatedCombobox(ValidatedMixin, ttk.Combobox):\n  \"\"\"A combobox that only takes values from its string list\"\"\"\n  def _key_validate(self, proposed, action, **kwargs):\n    valid = True\n    if action == '0':\n      self.set('')\n      return True \n```", "```py\n values = self.cget('values')\n    # Do a case-insensitive match against the entered text\n    matching = [\n      x for x in values\n      if x.lower().startswith(proposed.lower())\n    ]\n    if len(matching) == 0:\n      valid = False\n    elif len(matching) == 1:\n      self.set(matching[0])\n      self.icursor(tk.END)\n      valid = False\n    return valid \n```", "```py\n def _focusout_validate(self, **kwargs):\n    valid = True\n    if not self.get():\n      valid = False\n      self.error.set('A value is required')\n    return valid \n```", "```py\nfrom decimal import Decimal, InvalidOperation \n```", "```py\n**class****ValidatedSpinbox****(ValidatedMixin, ttk.Spinbox):**\n  def __init__(\n    self, *args, from_='-Infinity', to='Infinity', **kwargs\n  ):\n    super().__init__(*args, from_=from_, to=to, **kwargs)\n    increment = Decimal(str(kwargs.get('increment', '1.0')))\n    self.precision = increment.normalize().as_tuple().exponent \n```", "```py\n def _key_validate(\n    self, char, index, current, proposed, action, **kwargs\n  ):\n    if action == '0':\n      return True\n    valid = True\n    min_val = self.cget('from')\n    max_val = self.cget('to')\n    no_negative = min_val >= 0\n    no_decimal = self.precision >= 0 \n```", "```py\n if any([\n      (char not in '-1234567890.'),\n      (char == '-' and (no_negative or index != '0')),\n      (char == '.' and (no_decimal or '.' in current))\n    ]):\n      return False \n```", "```py\n if proposed in '-.':\n      return True \n```", "```py\n proposed = Decimal(proposed)\n    proposed_precision = proposed.as_tuple().exponent\n    if any([\n      (proposed > max_val),\n      (proposed_precision < self.precision)\n    ]):\n      return False\n    return valid \n```", "```py\n def _focusout_validate(self, **kwargs):\n    valid = True\n    value = self.get()\n    min_val = self.cget('from')\n    max_val = self.cget('to')\n    try:\n      d_value = Decimal(value)\n    except InvalidOperation:\n      self.error.set(f'Invalid number string: {value}')\n      return False\n    if d_value < min_val:\n      self.error.set(f'Value is too low (min {min_val})')\n      valid = False\n    if d_value > max_val:\n      self.error.set(f'Value is too high (max {max_val})')\n      valid = False\n    return valid \n```", "```py\n# data_entry_app.py \nclass ValidatedRadioGroup(ttk.Frame):\n  \"\"\"A validated radio button group\"\"\"\n  def __init__(\n    self, *args, variable=None, error_var=None,\n    values=None, button_args=None, **kwargs\n  ):\n    super().__init__(*args, **kwargs)\n    self.variable = variable or tk.StringVar()\n    self.error = error_var or tk.StringVar()\n    self.values = values or list()\n    self.button_args = button_args or dict() \n```", "```py\n for v in self.values:\n      button = ttk.Radiobutton(\n        self, value=v, text=v,\n        variable=self.variable, **self.button_args\n      )\n      button.pack(\n        side=tk.LEFT, ipadx=10, ipady=2, expand=True, fill='x'\n      ) \n```", "```py\n self.bind('<FocusOut>', self.trigger_focusout_validation) \n```", "```py\n def trigger_focusout_validation(self, *_):\n    self.error.set('')\n    if not self.variable.get():\n      self.error.set('A value is required') \n```", "```py\n# data_entry_app, in LabelInput.__init__()\n    if input_class in (\n      ttk.Checkbutton, ttk.Button,\n      ttk.Radiobutton, **ValidatedRadioGroup**\n    ):\n      input_args[\"variable\"] = self.variable\n    else:\n      input_args[\"textvariable\"] = self.variable \n```", "```py\n LabelInput(\n      r_info, \"Date\", var=self._vars['Date'], input_class=**DateEntry**\n    ).grid(row=0, column=0)\n    LabelInput(\n      r_info, \"Time\", input_class=**ValidatedCombobox**,\n      var=self._vars['Time'],\n      input_args={\"values\": [\"8:00\", \"12:00\", \"16:00\", \"20:00\"]}\n    ).grid(row=0, column=1)\n    LabelInput(\n      r_info, \"Technician\",  var=self._vars['Technician'],\n      input_class=**RequiredEntry**\n    ).grid(row=0, column=2) \n```", "```py\n LabelInput(\n      r_info, \"Lab\", input_class=**ValidatedRadioGroup**,\n      var=self._vars['Lab'], input_args={\"values\": [\"A\", \"B\", \"C\"]}\n    ).grid(row=1, column=0)\n    LabelInput(\n      r_info, \"Plot\", input_class=ValidatedCombobox,\n      var=self._vars['Plot'], \n      input_args={\"values\": list(range(1, 21))}\n    ).grid(row=1, column=1)\n    LabelInput(\n      r_info, \"Seed Sample\",  var=self._vars['Seed Sample'],\n      input_class=RequiredEntry\n    ).grid(row=1, column=2) \n```", "```py\n LabelInput(\n      e_info, \"Humidity (g/m³)\",\n      input_class=ValidatedSpinbox,  var=self._vars['Humidity'],\n      input_args={\"from_\": 0.5, \"to\": 52.0, \"increment\": .01}\n    ).grid(row=0, column=0)\n    LabelInput(\n      e_info, \"Light (klx)\", input_class=ValidatedSpinbox,\n      var=self._vars['Light'],\n      input_args={\"from_\": 0, \"to\": 100, \"increment\": .01}\n    ).grid(row=0, column=1)\n    LabelInput(\n      e_info, \"Temperature (°C)\",\n      input_class=ValidatedSpinbox,  var=self._vars['Temperature'],\n      input_args={\"from_\": 4, \"to\": 40, \"increment\": .01}\n    ).grid(row=0, column=2) \n```", "```py\n LabelInput(\n      p_info, \"Plants\", input_class=ValidatedSpinbox,\n      var=self._vars['Plants'], input_args={\"from_\": 0, \"to\": 20}\n    ).grid(row=0, column=0)\n    LabelInput(\n      p_info, \"Blossoms\", input_class=ValidatedSpinbox,\n      var=self._vars['Blossoms'], input_args={\"from_\": 0, \"to\": 1000}\n    ).grid(row=0, column=1)\n    LabelInput(\n      p_info, \"Fruit\", input_class=ValidatedSpinbox,\n      var=self._vars['Fruit'], input_args={\"from_\": 0, \"to\": 1000}\n    ).grid(row=0, column=2) \n```", "```py\n def __init__(self, *args, min_var=None, max_var=None,\n    focus_update_var=None, from_='-Infinity', to='Infinity', **kwargs\n  ): \n```", "```py\n self.variable = kwargs.get('textvariable')\n    if not self.variable:\n      self.variable = tk.DoubleVar()\n      self.configure(textvariable=self.variable) \n```", "```py\n if min_var:\n      self.min_var = min_var\n      self.min_var.trace_add('write', self._set_minimum)\n    if max_var:\n      self.max_var = max_var\n      self.max_var.trace_add('write', self._set_maximum) \n```", "```py\n self.focus_update_var = focus_update_var\n    self.bind('<FocusOut>', self._set_focus_update_var) \n```", "```py\n def _set_focus_update_var(self, event):\n    value = self.get()\n    if self.focus_update_var and not self.error.get():\n      self.focus_update_var.set(value) \n```", "```py\n def _set_minimum(self, *_):\n    current = self.get() \n```", "```py\n try:\n      new_min = self.min_var.get()\n      self.config(from_=new_min)\n    except (tk.TclError, ValueError):\n      pass \n```", "```py\n if not current:\n      self.delete(0, tk.END)\n    else:\n      self.variable.set(current) \n```", "```py\n self.trigger_focusout_validation() \n```", "```py\n def _set_maximum(self, *_):\n    current = self.get()\n    try:\n      new_max = self.max_var.get()\n      self.config(to=new_max)\n    except (tk.TclError, ValueError):\n      pass\n    if not current:\n      self.delete(0, tk.END)\n    else:\n      self.variable.set(current)\n    self.trigger_focusout_validation() \n```", "```py\n min_height_var = tk.DoubleVar(value='-infinity')\n    max_height_var = tk.DoubleVar(value='infinity') \n```", "```py\n LabelInput(\n      p_info, \"Min Height (cm)\",\n      input_class=**ValidatedSpinbox**,  var=self._vars['Min Height'],\n      input_args={\n        \"from_\": 0, \"to\": 1000, \"increment\": .01,\n        **\"max_var\"****: max_height_var,** **\"focus_update_var\"****: min_height_var**\n      }\n    ).grid(row=1, column=0) \n```", "```py\n LabelInput(\n      p_info, \"Max Height (cm)\",\n      input_class=**ValidatedSpinbox**,  var=self._vars['Max Height'],\n      input_args={\n        \"from_\": 0, \"to\": 1000, \"increment\": .01,\n        **\"min_var\"****: min_height_var,** **\"focus_update_var\"****: max_height_var**\n      }\n    ).grid(row=1, column=1) \n```", "```py\n LabelInput(\n      p_info, \"Median Height (cm)\",\n      input_class=ValidatedSpinbox,  var=self._vars['Med Height'],\n      input_args={\n        \"from_\": 0, \"to\": 1000, \"increment\": .01,\n        \"min_var\": min_height_var, \"max_var\": max_height_var\n      }\n    ).grid(row=1, column=2) \n```", "```py\nclass LabelInput(tk.Frame):\n  \"\"\"A widget containing a label and input together.\"\"\"\n  def __init__(\n    self, parent, label, var, input_class=ttk.Entry,\n      input_args=None, label_args=None, **disable_var=None**,\n      **kwargs\n  ): \n```", "```py\n if disable_var:\n      self.disable_var = disable_var\n      self.disable_var.trace_add('write', self._check_disable) \n```", "```py\n def _check_disable(self, *_):\n    if not hasattr(self, 'disable_var'):\n      return\n    if self.disable_var.get():\n      self.input.configure(state=tk.DISABLED)\n      self.variable.set('')\n    else:\n      self.input.configure(state=tk.NORMAL) \n```", "```py\n LabelInput(\n      e_info, \"Humidity (g/m³)\",\n      input_class=ValidatedSpinbox,  var=self._vars['Humidity'],\n      input_args={\"from_\": 0.5, \"to\": 52.0, \"increment\": .01},\n      **disable_var=self._****vars****[****'Equipment Fault'****]**\n    ).grid(row=0, column=0)\n    LabelInput(\n      e_info, \"Light (klx)\", input_class=ValidatedSpinbox,\n      var=self._vars['Light'],\n      input_args={\"from_\": 0, \"to\": 100, \"increment\": .01},\n      **disable_var=self._****vars****[****'Equipment Fault'****]**\n    ).grid(row=0, column=1)\n    LabelInput(\n      e_info, \"Temperature (°C)\",\n      input_class=ValidatedSpinbox,  **var=self._****vars****[****'Temperature'****],**\n      input_args={\"from_\": 4, \"to\": 40, \"increment\": .01},\n      **disable_var=self._****vars****[****'Equipment Fault'****]**\n    ).grid(row=0, column=2) \n```", "```py\n self.error = getattr(self.input, 'error', tk.StringVar())\n    ttk.Label(self, textvariable=self.error, **label_args).grid(\n      row=2, column=0, sticky=(tk.W + tk.E)\n    ) \n```", "```py\n if self.disable_var.get():\n      self.input.configure(state=tk.DISABLED)\n      self.variable.set('')\n      self.error.set('') \n```", "```py\n def get_errors(self):\n    \"\"\"Get a list of field errors in the form\"\"\"\n    errors = {}\n    for key, var in self._vars.items():\n      inp = var.label_widget.input\n      error = var.label_widget.error\n      if hasattr(inp, 'trigger_focusout_validation'):\n        inp.trigger_focusout_validation()\n      if error.get():\n        errors[key] = error.get()\n    return errors \n```", "```py\n errors = self.recordform.get_errors()\n    if errors:\n      self.status.set(\n        \"Cannot save, error in fields: {}\"\n        .format(', '.join(errors.keys()))\n      )\n      return \n```", "```py\n def reset(self):\n    \"\"\"Resets the form entries\"\"\"\n    for var in self._vars.values():\n      if isinstance(var, tk.BooleanVar):\n        var.set(False)\n      else:\n        var.set('')\n    current_date = datetime.today().strftime('%Y-%m-%d')\n    self._vars['Date'].set(current_date)\n    self._vars['Time'].label_widget.input.focus() \n```", "```py\n def reset(self):\n    \"\"\"Resets the form entries\"\"\"\n    lab = self._vars['Lab'].get()\n    time = self._vars['Time'].get()\n    technician = self._vars['Technician'].get()\n    try:\n      plot = self._vars['Plot'].get()\n    except tk.TclError:\n      plot = ''\n    plot_values = (\n      self._vars['Plot'].label_widget.input.cget('values')\n    ) \n```", "```py\n if plot not in ('', 0, plot_values[-1]):\n      self._vars['Lab'].set(lab)\n      self._vars['Time'].set(time)\n      self._vars['Technician'].set(technician)\n      next_plot_index = plot_values.index(str(plot)) + 1\n      self._vars['Plot'].set(plot_values[next_plot_index])\n      self._vars['Seed Sample'].label_widget.input.focus() \n```"]