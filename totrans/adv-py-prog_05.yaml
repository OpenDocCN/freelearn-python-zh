- en: '*Chapter 4*: C Performance with Cython'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython is a language that extends Python by supporting the declaration of types
    for functions, variables, and classes. These typed declarations enable Cython
    to compile Python scripts to efficient C code. Cython can also act as a bridge
    between Python and C as it provides easy-to-use constructs to write interfaces
    to external C and C++ routines.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Cython extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding static types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a particle simulator in Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling Cython
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cython with Jupyter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through this chapter, we will learn how to leverage Cython to improve the efficiency
    of our programs. While a minimum knowledge of C is helpful, this chapter focuses
    only on Cython in the context of Python optimization. Therefore, it doesn't require
    any C background.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can access the code used in this chapter on GitHub at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Compiling Cython extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cython syntax is, by design, a superset of Python. Cython can compile, with
    a few exceptions, most Python modules without requiring any change. Cython source
    files have the `.pyx` extension and can be compiled to produce a C file using
    the `cython` command.
  prefs: []
  type: TYPE_NORMAL
- en: All that is required to convert Python code to Cython is some syntactic modifications
    that we will see throughout this chapter (such as when declaring variables and
    functions) as well as compilation. While this procedure may seem intimidating
    at first, Cython will more than make up for itself via the computational benefits
    that it offers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, to install Cython, we can simply run the `pip` command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the documentation at [https://pypi.org/project/Cython/](https://pypi.org/project/Cython/)
    for more details. Our first Cython script will contain a simple function that
    prints `Hello, World!` as the output. Follow these next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `hello.pyx` file containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `cython` command will read `hello.pyx` and generate a `hello.c` file, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compile `hello.c` to a Python extension module, we will use the `/usr/include/python3.5/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To find your Python `include` directory, you can use the `distutils` utility
    and run `sysconfig.get_python_inc`. To execute it, you can simply issue the following
    command: `python -c "from distutils import sysconfig;` `print(sysconfig.get_python_inc())"`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This will produce a file called `hello.so`, a C extension module that is directly
    importable into a Python session. The code is illustrated in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Cython accepts both Python 2 and Python 3 as `hello.pyx` file using the `-3`
    option, as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The generated `hello.c` file can be compiled without any changes to Python
    2 and Python 3 by including the corresponding headers with the `-I` option, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A Cython program can be compiled in a more straightforward way using `distutils`,
    the standard Python packaging tool. By writing a `setup.py` script, we can compile
    the `.pyx` file directly to an extension module. To compile our `hello.pyx` example,
    we can write a minimal `setup.py` script containing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the first two lines of the preceding code snippet, we import the `setup`
    function and the `cythonize` helper. The `setup` function contains a few key-value
    pairs that specify the name of the application and the extensions that need to
    be built.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cythonize` helper takes either a string or a list of strings containing
    the Cython modules we want to compile. You can also use glob patterns by running
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compile our extension module using `distutils`, you can execute the `setup.py`
    script using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `build_ext` option tells the script to build the extension modules indicated
    in `ext_modules`, while the `--inplace` option tells the script to place the `hello.so`
    output file in the same location as the source file (instead of a build directory).
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython modules can also be automatically compiled using `pyximport`. All that''s
    needed is a call to `pyximport.install()` at the beginning of your script (or
    you need to issue the command in your interpreter), as illustrated in the following
    code snippet. After doing that, you can import `.pyx` files directly and `pyximport`
    will transparently compile the corresponding Cython modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unfortunately, `pyximport` will not work for all kinds of configurations (for
    example, when they involve a combination of C and Cython files), but it comes
    in handy for testing simple scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since version 0.13, IPython includes the `cythonmagic` extension to interactively
    write and test a series of Cython statements. You can load the extensions in an
    IPython shell using `load_ext`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the extension is loaded, you can use the `%%cython` *cell magic* to write
    a multiline Cython snippet. In the following example, we define a `hello_snippet`
    function that will be compiled and added to the IPython session namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It is that simple to work with Cython source code. In the next section, we will
    see how we can add static types to our program, getting it closer to C code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding static types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, a variable can be associated with objects of different types during
    the execution of the program. While this feature is desirable as it makes the
    language flexible and dynamic, it also adds significant overhead to the interpreter
    as it needs to look up the type and methods of the variables at runtime, making
    it difficult to perform various optimizations. Cython extends the Python language
    with explicit type declarations so that it can generate efficient C extensions
    through compilation.
  prefs: []
  type: TYPE_NORMAL
- en: The main way to declare data types in Cython is through `cdef` statements. The
    `cdef` keyword can be used in multiple contexts, such as variables, functions,
    and extension types (statically typed classes). We will see how to do this in
    the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Cython, you can declare the type of a variable by prepending the variable
    with `cdef` and its respective type. For example, we can declare the `i` variable
    as a 16-bit integer in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cdef` statement supports multiple variable names on the same line along
    with optional initialization, as seen in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Typed variables are treated differently from regular variables. In Python,
    variables are often described as *labels* that refer to objects in memory. For
    example, we could assign the value `''hello''` to the `a` variable at any point
    in the program without restriction, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `a` variable holds a reference to the `''hello''` string. We can also freely
    assign another value (for example, the integer `1`) to the same variable later
    in the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Python will assign the integer `1` to the `a` variable without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typed variables behave quite differently and are usually described as *data
    containers*: we can only store values that fit into the container that is determined
    by its data type. For example, if we declare the `a` variable as `int`, and then
    we try to assign it to a `double` data type, Cython will trigger an error, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Static typing makes it easy for the compiler to perform useful optimizations.
    For example, if we declare a loop index as `int`, Cython will rewrite the loop
    in pure C without needing to step into the Python interpreter. The typing declaration
    guarantees that the type of the index will always be `int` and cannot be overwritten
    at runtime so that the compiler is free to perform optimizations without compromising
    the program's correctness.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can assess the speed gain in this case with a small test case. In the following
    example, we implement a simple loop that increments a variable `100` times. With
    Cython, the `example` function can be coded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compare the speed of an analogous, untyped, pure Python loop, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The speedup obtained by implementing this simple type declaration is a whopping
    100 times! This works because the Cython loop has first been converted to pure
    C and then to efficient machine code, while the Python loop still relies on the
    slow interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: In Cython, it is possible to declare a variable to be of any standard C type,
    and it is also possible to define custom types using classic C constructs, such
    as `struct`, `enum`, and `typedef`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting example is that if we declare a variable to be of the `object`
    type, the variable will accept any kind of Python object, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that declaring a variable as `object` has no performance benefits, as accessing
    and operating on the object will still require the interpreter to look up the
    underlying type of the variable and its attributes and methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, certain data types (such as `float` and `int` numbers) are compatible
    in the sense that they can be converted into each other. In Cython, it is possible
    to convert (*cast*) between types by surrounding the destination type with pointy
    brackets, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Together with static types for variables, we can provide information about functions,
    which we will learn how to do next.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can add type information to the arguments of a Python function by specifying
    the type in front of each of the argument names. Functions specified in this way
    will work and perform like regular Python functions, but their arguments will
    be type-checked. We can write a `max_python` function that returns the greater
    value between two integers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A function specified in this way will perform type checking and treat the arguments
    as typed variables, just as in `cdef` definitions. However, the function will
    still be a Python function, and calling it multiple times will still need to switch
    back to the interpreter. To allow Cython for function call optimizations, we should
    declare the type of the return type using a `cdef` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Functions declared in this way are translated to native C functions and have
    much less overhead compared to Python functions. A substantial drawback is that
    they can't be used from Python but only from Cython, and their scope is restricted
    to the same Cython file unless they're exposed in a definition file (refer to
    the *Sharing declarations* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Cython allows you to define functions that are both callable from
    Python and translatable to performant C functions. If you declare a function with
    a `cpdef` statement, Cython will generate two versions of the function: a Python
    version available to the interpreter, and a fast C function usable from Cython.
    The `cpdef` syntax is equivalent to `cdef`, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, the call overhead can be a performance issue even with C functions,
    especially when the same function is called many times in a critical loop. When
    the function body is small, it is convenient to add the `inline` keyword in front
    of the function definition; the function call will be replaced by the function
    body itself. Our `max` function is a good candidate for *inlining*, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will see how to work with class types next.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can define an extension type using the `cdef class` statement and declare
    its attributes in the class body. For example, we can create a `Point` extension
    type, as shown in the following code snippet, which stores two coordinates (`x`,
    `y`) of the `double` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the declared attributes in the class methods allows Cython to bypass
    expensive Python attribute lookups by direct access to the given fields in the
    underlying C struct. For this reason, attribute access in typed classes is an
    extremely fast operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `cdef class` statement in your code, you need to explicitly declare
    the type of the variables you intend to use at compile time. You can use the extension
    type name (such as `Point`) in any context where you will use a standard type
    (such as `double`, `float`, and `int`). For example, if we want a Cython function
    that calculates the distance from the origin (in the example, the function is
    called `norm`) of a `Point`, we have to declare the input variable as `Point`,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with typed functions, typed classes have some limitations. If you try
    to access an extension type attribute from Python, you will get an `AttributeError`
    warning, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to access attributes from Python code, you have to use the `public`
    (for read/write access) or `readonly` specifiers in the attribute declaration,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, methods can be declared with the `cpdef` statement, just as with
    regular functions.
  prefs: []
  type: TYPE_NORMAL
- en: Extension types do not support the addition of extra attributes at runtime.
    To do that, a solution is defining a Python class that is a subclass of the typed
    class and extends its attributes and methods in pure Python.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we have seen how to add static types to various objects in Cython.
    In the next section, we will begin our discussion regarding declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing your Cython modules, you may want to reorganize your most-used
    functions and classes declaration in a separate file so that they can be reused
    in different modules. Cython allows you to put these components in a *definition
    file* and access them with `cimport` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say that we have a module with the `max` and `min` functions, and we want
    to reuse those functions in multiple Cython programs. If we simply write a bunch
    of functions in a `.pyx` file, the declarations will be confined to the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Definition files are also used to interface Cython with external C code. The
    idea is to copy (or, more accurately, translate) the types and function prototypes
    in the definition file and leave the implementation in the external C code that
    will be compiled and linked in a separate step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To share the `max` and `min` functions, we need to write a definition file
    with a `.pxd` extension. Such a file only contains the types and function prototypes
    that we want to share with other modules—a *public* interface. We can declare
    the prototypes of our `max` and `min` functions in a file named `mathlib.pxd`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we only write the function name and arguments without implementing
    the function body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function implementation goes into the implementation file with the same
    base name but the `.pyx` extension `mathlib.pyx`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `mathlib` module is now importable from another Cython module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our new Cython module, we will create a file named `distance.pyx` containing
    a function named `chebyshev`. The function will calculate the Chebyshev distance
    between two points, as shown in the following code snippet. The Chebyshev distance
    between two coordinates—`(x1,` `y1)` and `(x2, y2`—is defined as the maximum value
    of the difference between each coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement the `chebyshev` function, we will use the `max` function declared
    in `mathlib.pxd` by importing it with the `cimport` statement, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `cimport` statement will read `mathlib.pxd` and the `max` definition will
    be used to generate a `distance.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: Along with static types and declarations, one factor that allows C to be generally
    faster than Python is its highly optimized array operations, which we will examine
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numerical and high-performance calculations often make use of arrays. Cython
    provides an easy way to interact with different types of arrays, using directly
    low-level C arrays, or the more general *typed memoryviews*. We will see how to
    do this in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: C arrays and pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C arrays are a collection of items of the same type, stored contiguously in
    memory. Before digging into the details, it is helpful to understand (or review)
    how memory is managed in C.
  prefs: []
  type: TYPE_NORMAL
- en: Variables in C are like containers. When creating a variable, a space in memory
    is reserved to store its value. For example, if we create a variable containing
    a 64-bit floating-point number (`double`), the program will allocate 64 bits (16
    bytes) of memory. This portion of memory can be accessed through an address to
    that memory location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain the address of a variable, we can use the *address operator* denoted
    by the `&` symbol. We can also use the `printf` function, as follows, available
    in the `libc.stdio` Cython module to print the address of this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The output will only be generated when the code is run from a standard Python
    terminal. This limitation of IPython is detailed at [https://github.com/ipython/ipython/issues/1230](https://github.com/ipython/ipython/issues/1230).
  prefs: []
  type: TYPE_NORMAL
- en: 'Memory addresses can be stored in special variables, *pointers*, that can be
    declared by putting a `*` prefix in front of the variable name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a pointer and we want to grab the value contained in the address
    it''s pointing at, we can use the zero-index notation shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When declaring a C array, the program allocates enough space to accommodate
    all the elements requested. For instance, to create an array that has 10 `double`
    values (16 bytes each), the program will reserve *16* * *10* = *160* bytes of
    contiguous space in memory. In Cython, we can declare such arrays using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare a multidimensional array, such as an array with `5` rows
    and `2` columns, using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory will be allocated in a single block of memory, row after row. This
    order is commonly referred to as *row-major* and is depicted in the following
    screenshot. Arrays can also be *column-major* ordered, as is the case for the
    Fortran programming language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Row-major order ](img/B17499_Figure_4.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Row-major order
  prefs: []
  type: TYPE_NORMAL
- en: Array ordering has important consequences. When iterating a C array over the
    last dimension, we access contiguous memory blocks (in our example, 0, 1, 2, 3
    ...), while when we iterate on the first dimension, we skip a few positions (0,
    2, 4, 6, 8, 1 ... ). You should always try to access memory sequentially as this
    optimizes cache and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store and retrieve elements from the array using standard indexing,
    as shown here; C arrays don''t support fancy indexing or slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'C arrays have many of the same behaviors as pointers. The `arr` variable, in
    fact, points to the memory location of the first element of the array. We can
    verify that the address of the first element of the array is the same as the address
    contained in the `arr` variable using the dereference operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The output will only be generated when the aforementioned code is run from a
    standard Python terminal. This limitation of IPython is detailed at [https://github.com/ipython/ipython/issues/1230](https://github.com/ipython/ipython/issues/1230).
  prefs: []
  type: TYPE_NORMAL
- en: You should use C arrays and pointers when interfacing with existing C libraries
    or when you need fine control over the memory (also, they are very performant).
    This level of fine control is also prone to mistakes as it doesn't prevent you
    from accessing the wrong memory locations. For more common use cases and improved
    safety, you can use NumPy arrays or typed memoryviews.
  prefs: []
  type: TYPE_NORMAL
- en: Working with NumPy arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy arrays can be used as normal Python objects in Cython, using their already
    optimized broadcasted operations. However, Cython provides a `numpy` module with
    better support for direct iteration.
  prefs: []
  type: TYPE_NORMAL
- en: When we normally access an element of a NumPy array, a few other operations
    take place at the interpreter level, causing a major overhead. Cython can bypass
    those operations and checks by acting directly on the underlying memory area used
    by NumPy arrays, thus obtaining impressive performance gains.
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy arrays can be declared as the `ndarray` data type. To use the data type
    in our code, we first need to `cimport` the `numpy` Cython module (which is not
    the same as the Python `numpy` module). We will bind the module to the `c_np`
    variable to make the difference with the Python `numpy` module more explicit,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now declare a NumPy array by specifying its type and the number of dimensions
    between square brackets (this is called *buffer syntax*). To declare a `double`,
    we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Access to this array will be performed by directly operating on the underlying
    memory area; the operation will avoid stepping into the interpreter, giving us
    a tremendous speed boost.
  prefs: []
  type: TYPE_NORMAL
- en: In the next example, we will show the usage of typed NumPy arrays and compare
    them with the normal Python version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first write a `numpy_bench_py` function that increments each element of
    `py_arr`. We declare the `i` index as an integer so that we avoid the `for` loop
    overhead, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we write the same function using the `ndarray` type. Note that after
    we define the `c_arr` variable using `c_np.ndarray`, we can assign to it an array
    from the `numpy` Python module. The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can time the results using `timeit`, and we can see here how the typed version
    is 50 times faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a significant speedup from the Python code!
  prefs: []
  type: TYPE_NORMAL
- en: Working with typed memoryviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C and NumPy arrays, as well as the built-in `bytes`, `bytearray`, and `array.array`
    objects, are similar in the sense that they all operate on a contiguous memory
    area (also called a memory *buffer*). Cython provides a universal interface—a
    *typed memoryview*—that unifies and simplifies access to all these data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `int` and a 2D memoryview of `double` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The same syntax applies to the declaration of any type in variables, function
    definitions, class attributes, and so on. Any object that exposes a buffer interface
    (for example, NumPy arrays, `bytes`, and `array.array` objects) will be bound
    to the memoryview automatically. For example, we can bind the memoryview to a
    NumPy array using a simple variable assignment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that the memoryview does not *own* the data, but it
    only provides a way to *access* and *change* the data it is bound to; the ownership,
    in this case, is left to the NumPy array. As you can see in the following example,
    changes made through the memoryview will act on the underlying memory area and
    will be reflected in the original NumPy structure (and vice versa):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In a certain sense, the mechanism behind memoryviews is similar to what NumPy
    produces when we slice an array. As we have seen in [*Chapter 3*](B17499_03_Final_SS_ePub.xhtml#_idTextAnchor047),
    *Fast Array Operations with NumPy, Pandas, and Xarray*, slicing a NumPy array
    does not copy the data but returns a view on the same memory area, and changes
    to the view will reflect on the original array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Memoryviews also support array slicing with the standard NumPy syntax, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To copy data between one memoryview and another, you can use syntax similar
    to slice assignment, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will use typed memoryviews to declare types for the
    arrays in our particle simulator.
  prefs: []
  type: TYPE_NORMAL
- en: Using a particle simulator in Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how Cython works, we can rewrite the
    `ParticleSimulator.evolve` method. Thanks to Cython, we can convert our loops
    in C, thus removing the overhead introduced by the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B17499_03_Final_SS_ePub.xhtml#_idTextAnchor047), *Fast Array
    Operations with NumPy, Pandas, and Xarray*, we wrote a fairly efficient version
    of the `evolve` method using NumPy. We can rename the old version `evolve_numpy`
    to differentiate it from the new version. The code is illustrated in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We want to convert this code to Cython. Our strategy will be to take advantage
    of the fast indexing operations by removing the NumPy array broadcasting, thus
    reverting to an indexing-based algorithm. Since Cython generates efficient C code,
    we are free to use as many loops as we like without any performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: As a design choice, we can decide to encapsulate the loop in a function that
    we will rewrite in a Cython module called `cevolve.pyx`. The module will contain
    a single Python function, `c_evolve`, that will take the particle positions, angular
    velocities, timestep, and the number of steps as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first, we are not adding typing information; we just want to isolate the
    function and ensure that we can compile our module without errors. The code is
    illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we don''t need a return value for `c_evolve` as values are updated
    in place in the `r_i` array. We can benchmark the untyped Cython version against
    the old NumPy version by slightly changing our `benchmark` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can time the different versions in an IPython shell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The two versions have the same speed. Compiling the Cython module without static
    typing doesn't have any advantage over pure Python. The next step is to declare
    the type of all the important variables so that Cython can perform its optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start adding types to the function arguments and see how the performance
    changes. We can declare the arrays as typed memoryviews containing `double` values.
    It''s worth mentioning that if we pass an array of the `int` or `float32` type,
    the casting won''t happen automatically and we will get an error. The code is
    illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can rewrite the loops over the particles and timesteps. We
    can declare the `i` and `j` iteration indices and the `nparticles` particle number
    as `int`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithm is very similar to the pure Python version; we iterate over the
    particles and timesteps, and we compute the velocity and displacement vectors
    for each particle coordinate using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we added the `x`, `y`, `ang_speed`, `norm`,
    `vx`, `vy`, `dx`, and `dy` variables. To avoid the Python interpreter overhead,
    we have to declare them with their corresponding types at the beginning of the
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We also used a function called `sqrt` to calculate the norm. If we use the
    `sqrt` function present in the `math` module or the one in `numpy`, we will again
    include a slow Python function in our critical loop, thus killing our performance.
    A fast `sqrt` function is available in the standard C library, already wrapped
    in the `libc.math` Cython module. Run the following code to import it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rerun our benchmark to assess our improvements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'For small particle numbers, the speedup is massive as we obtained a 40 times
    faster performance over the previous version. However, we should also try to test
    the performance scaling with a larger number of particles, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As we increase the number of particles, the two versions get closer in speed.
    By increasing the particle size to `1000`, we already decreased our speedup to
    a more modest 6 times. This is likely because, as we increase the number of particles,
    the Python `for` loop overhead becomes less and less significant compared to the
    speed of other operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topic of benchmarking naturally transitions us to our next section: profiling.'
  prefs: []
  type: TYPE_NORMAL
- en: Profiling Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cython provides a feature called *annotated view* that helps find which lines
    are executed in the Python interpreter and which are good candidates for ulterior
    optimizations. We can turn this feature on by compiling a Cython file with the
    `-a` option. In this way, Cython will generate a `-a` option is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML file displayed in the following screenshot shows our Cython file line
    by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Generated HTML containing annotated code ](img/B17499_Figure_4.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Generated HTML containing annotated code
  prefs: []
  type: TYPE_NORMAL
- en: Each line in the source code can appear in different shades of yellow. A more
    intense color corresponds to more interpreter-related calls, while white lines
    are translated to regular C code. Since interpreter calls substantially slow down
    execution, the objective is to make the function body as white as possible. By
    clicking on any of the lines, we can inspect the code generated by the Cython
    compiler. For example, the `v_y = x/norm` line checks that the norm is not `0`
    and raises a `ZeroDivisionError` error if the condition is not verified. The `x
    = r_i[j, 0]` line shows that Cython checks whether the indexes are within the
    bounds of the array. You may have noted that the last line is of a very intense
    color; by inspecting the code, we can see that this is actually a glitch—the code
    refers to a boilerplate related to the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cython can shut down checks such as division by zero so that it can remove
    those extra interpreter-related calls; this is usually accomplished through compiler
    directives. There are a few different ways to add compiler directives, as outlined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a decorator or a context manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a comment at the beginning of the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Cython command-line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a complete list of the Cython compiler directives, you can refer to the
    official documentation at [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to disable bounds checking for arrays, it is sufficient to decorate
    a function with `cython.boundscheck`, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use `cython.boundscheck` to wrap a block of code into
    a context manager, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to disable bounds checking for a whole module, we can add the following
    line of code at the beginning of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To alter the directives with the command-line options, you can use the `-X`
    option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the extra checks in our `c_evolve` function, we can disable the
    `boundscheck` directive and enable `cdivision` (this prevents checks for `ZeroDivisionError`),
    as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the annotated view again, the loop body has become completely
    white—we removed all traces of the interpreter from the inner loop. In order to
    recompile, just type `python setup.py build_ext --inplace` again. By running the
    benchmark, however, we note that we didn''t obtain a performance improvement,
    suggesting that those checks are not part of the bottleneck, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to profile Cython code is using the `cProfile` module. As an example,
    we can write a simple function that calculates the Chebyshev distance between
    coordinate arrays. Create a `cheb.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try profiling this script as-is, we won''t get any statistics regarding
    the functions that we implemented in Cython. If we want to collect profiling information
    for the `max` and `min` functions, we need to add the `profile=True` option to
    the `mathlib.pyx` file, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now profile our script with `%prun` using IPython, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: From the output, we can see that the `max` function is present and is not a
    bottleneck. Most of the time seems to be spent in the `benchmark` function, meaning
    that the bottleneck is likely a pure Python `for` loop. In this case, the best
    strategy will be rewriting the loop in NumPy or porting the code to Cython.
  prefs: []
  type: TYPE_NORMAL
- en: One feature in Python that many users enjoy is the ability to work with Jupyter
    Notebooks. When working with Cython, you don't have to give up on this feature.
    In the next and last section of this chapter, we will see how we can use Cython
    with Jupyter.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cython with Jupyter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimizing Cython code requires substantial trial and error. Fortunately, Cython
    tools can be conveniently accessed through Jupyter Notebooks for a more streamlined
    and integrated experience.
  prefs: []
  type: TYPE_NORMAL
- en: You can launch a notebook session by typing `jupyter notebook` in the command
    line, and you can load the Cython magic by typing `%load_ext cython` in a cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the `%%cython` magic can be used to compile and load
    the Cython code inside the current session. As an example, we may copy the contents
    of the `cheb.py` file into a notebook cell, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful feature of the `%%cython` magic is the `-a` option that will compile
    the code and produce an annotated view (just as with the `-a` command-line option)
    of the source code directly in the notebook, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Generated annotated code ](img/B17499_Figure_4.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Generated annotated code
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you to quickly test different versions of your code and use the
    other integrated tools available in Jupyter. For example, we can time and profile
    the code (provided that we activate the profile directive in the cell) in the
    same session using tools such as `%prun` and `%timeit`. We can also inspect the
    profiling results by taking advantage of the `%prun` magic, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Profiling output ](img/B17499_Figure_4.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Profiling output
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use the `line_profiler` tool we discussed in [*Chapter
    1*](B17499_01_Final_SS_ePub.xhtml#_idTextAnchor015), *Benchmarking and Profiling*,
    directly in the notebook. To support line annotations, it is necessary to do the
    following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the `linetrace=True` and `binding=True` compiler directives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the `CYTHON_TRACE=1` flag at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be easily accomplished by adding the respective arguments to the `%%cython`
    magic and by setting the compiler directives, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the code is instrumented, we can install the `line_profiler` package via
    `pip install line_profiler` and profile using the `%lprun` magic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a good chunk of time is spent in *line 16*, which is a pure
    Python loop and a good candidate for further optimization.
  prefs: []
  type: TYPE_NORMAL
- en: The tools available in Jupyter Notebook allow for a fast edit-compile-test cycle
    so that you can quickly prototype and save time when testing different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cython is a tool that bridges the convenience of Python with the speed of C.
    Compared to C bindings, Cython programs are much easier to maintain and debug,
    thanks to the tight integration and compatibility with Python and the availability
    of excellent tools.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduced the basics of the Cython language and how to
    make our programs faster by adding static types to our variables and functions.
    We also learned how to work with C arrays, NumPy arrays, and memoryviews.
  prefs: []
  type: TYPE_NORMAL
- en: We optimized our particle simulator by rewriting the critical `evolve` function,
    obtaining a tremendous speed gain. Finally, we learned how to use the annotated
    view to spot hard-to-find interpreter-related calls and how to enable `cProfile`
    support in Cython. Also, we learned how to take advantage of the Jupyter Notebook
    for integrated profiling and analysis of Cython code.
  prefs: []
  type: TYPE_NORMAL
- en: All these tasks provide us with the high level of flexibility, which we already
    enjoy with Python, when working with Cython, while allowing our programs to be
    more optimized with low-level C code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore other tools that can generate fast machine
    code on the fly, without requiring the compilation of our code to C **ahead of
    time** (**AOT**).
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the benefit of implementing static types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of a memoryview?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which tools for profiling Cython were introduced in this chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
