- en: '*Chapter 4*: C Performance with Cython'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 4 章*：使用 Cython 的 C 性能'
- en: Cython is a language that extends Python by supporting the declaration of types
    for functions, variables, and classes. These typed declarations enable Cython
    to compile Python scripts to efficient C code. Cython can also act as a bridge
    between Python and C as it provides easy-to-use constructs to write interfaces
    to external C and C++ routines.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一种扩展 Python 的语言，它通过支持函数、变量和类的类型声明来扩展 Python。这些类型声明使 Cython 能够将 Python
    脚本编译成高效的 C 代码。Cython 还可以作为 Python 和 C 之间的桥梁，因为它提供了易于使用的结构来编写对外部 C 和 C++ 例程的接口。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Compiling Cython extensions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译 Cython 扩展
- en: Adding static types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加静态类型
- en: Sharing declarations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分享声明
- en: Working with arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Using a particle simulator in Cython
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Cython 中使用粒子模拟器
- en: Profiling Cython
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析 Cython
- en: Using Cython with Jupyter
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Jupyter 中使用 Cython
- en: Through this chapter, we will learn how to leverage Cython to improve the efficiency
    of our programs. While a minimum knowledge of C is helpful, this chapter focuses
    only on Cython in the context of Python optimization. Therefore, it doesn't require
    any C background.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们将学习如何利用 Cython 提高我们程序的效率。虽然对 C 的基本了解有帮助，但本章仅关注 Python 优化背景下的 Cython。因此，它不需要任何
    C 背景。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can access the code used in this chapter on GitHub at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter04).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上访问本章使用的代码，地址为 [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter04)。
- en: Compiling Cython extensions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Cython 扩展
- en: The Cython syntax is, by design, a superset of Python. Cython can compile, with
    a few exceptions, most Python modules without requiring any change. Cython source
    files have the `.pyx` extension and can be compiled to produce a C file using
    the `cython` command.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 按照设计，Cython 语法是 Python 的超集。Cython 可以编译大多数 Python 模块，只有少数例外，而无需任何更改。Cython 源文件具有
    `.pyx` 扩展名，可以使用 `cython` 命令编译成 C 文件。
- en: All that is required to convert Python code to Cython is some syntactic modifications
    that we will see throughout this chapter (such as when declaring variables and
    functions) as well as compilation. While this procedure may seem intimidating
    at first, Cython will more than make up for itself via the computational benefits
    that it offers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Python 代码转换为 Cython 所需的只是对语法的一些修改，我们将在本章中看到这些修改（例如在声明变量和函数时），以及编译。虽然这个程序一开始可能看起来令人畏惧，但
    Cython 通过它提供的计算优势将远远弥补这一点。
- en: 'First off, to install Cython, we can simply run the `pip` command, like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要安装 Cython，我们可以简单地运行 `pip` 命令，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Refer to the documentation at [https://pypi.org/project/Cython/](https://pypi.org/project/Cython/)
    for more details. Our first Cython script will contain a simple function that
    prints `Hello, World!` as the output. Follow these next steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅 [https://pypi.org/project/Cython/](https://pypi.org/project/Cython/)
    上的文档。我们的第一个 Cython 脚本将包含一个简单的函数，该函数将输出 `Hello, World!`。按照以下步骤操作：
- en: 'Create a new `hello.pyx` file containing the following code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下代码的新 `hello.pyx` 文件：
- en: '[PRE1]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `cython` command will read `hello.pyx` and generate a `hello.c` file, as
    follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cython` 命令将读取 `hello.pyx` 并生成一个 `hello.c` 文件，如下所示：'
- en: '[PRE2]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To compile `hello.c` to a Python extension module, we will use the `/usr/include/python3.5/`:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 `hello.c` 编译成 Python 扩展模块，我们将使用 `/usr/include/python3.5/`：
- en: '[PRE3]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'To find your Python `include` directory, you can use the `distutils` utility
    and run `sysconfig.get_python_inc`. To execute it, you can simply issue the following
    command: `python -c "from distutils import sysconfig;` `print(sysconfig.get_python_inc())"`.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要找到你的 Python `include` 目录，你可以使用 `distutils` 工具并运行 `sysconfig.get_python_inc`。要执行它，你可以简单地发出以下命令：`python
    -c "from distutils import sysconfig; print(sysconfig.get_python_inc())"`。
- en: 'This will produce a file called `hello.so`, a C extension module that is directly
    importable into a Python session. The code is illustrated in the following snippet:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `hello.so` 的文件，这是一个可以直接导入 Python 会话的 C 扩展模块。代码在下面的代码片段中展示：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Cython accepts both Python 2 and Python 3 as `hello.pyx` file using the `-3`
    option, as illustrated in the following code snippet:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cython 既可以接受 Python 2，也可以接受 Python 3 作为 `hello.pyx` 文件，使用 `-3` 选项，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The generated `hello.c` file can be compiled without any changes to Python
    2 and Python 3 by including the corresponding headers with the `-I` option, as
    follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成的`hello.c`文件可以通过包含相应的头文件（使用`-I`选项）来编译，无需对Python 2和Python 3进行任何更改，如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A Cython program can be compiled in a more straightforward way using `distutils`,
    the standard Python packaging tool. By writing a `setup.py` script, we can compile
    the `.pyx` file directly to an extension module. To compile our `hello.pyx` example,
    we can write a minimal `setup.py` script containing the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`distutils`，Python的标准打包工具，可以更直接地编译Cython程序。通过编写`setup.py`脚本，我们可以直接将`.pyx`文件编译为扩展模块。要编译我们的`hello.pyx`示例，我们可以编写一个包含以下代码的最小`setup.py`脚本：
- en: '[PRE7]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the first two lines of the preceding code snippet, we import the `setup`
    function and the `cythonize` helper. The `setup` function contains a few key-value
    pairs that specify the name of the application and the extensions that need to
    be built.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段的前两行中，我们导入了`setup`函数和`cythonize`辅助函数。`setup`函数包含一些键值对，指定了应用程序的名称和需要构建的扩展。
- en: 'The `cythonize` helper takes either a string or a list of strings containing
    the Cython modules we want to compile. You can also use glob patterns by running
    the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cythonize`辅助函数接受一个字符串或字符串列表，其中包含我们想要编译的Cython模块。你也可以通过运行以下代码使用glob模式：'
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To compile our extension module using `distutils`, you can execute the `setup.py`
    script using the following code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`distutils`编译我们的扩展模块，你可以使用以下代码执行`setup.py`脚本：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `build_ext` option tells the script to build the extension modules indicated
    in `ext_modules`, while the `--inplace` option tells the script to place the `hello.so`
    output file in the same location as the source file (instead of a build directory).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_ext`选项告诉脚本构建`ext_modules`中指示的扩展模块，而`--inplace`选项告诉脚本将`hello.so`输出文件放置在源文件相同的目录中（而不是构建目录）。'
- en: 'Cython modules can also be automatically compiled using `pyximport`. All that''s
    needed is a call to `pyximport.install()` at the beginning of your script (or
    you need to issue the command in your interpreter), as illustrated in the following
    code snippet. After doing that, you can import `.pyx` files directly and `pyximport`
    will transparently compile the corresponding Cython modules:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cython模块也可以使用`pyximport`自动编译。你所需要做的只是在脚本开头调用`pyximport.install()`（或者你需要在解释器中发出该命令），如下面的代码片段所示。完成之后，你可以直接导入`.pyx`文件，`pyximport`将透明地编译相应的Cython模块：
- en: '[PRE10]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unfortunately, `pyximport` will not work for all kinds of configurations (for
    example, when they involve a combination of C and Cython files), but it comes
    in handy for testing simple scripts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`pyximport`并不适用于所有类型的配置（例如，当它们涉及C和Cython文件的组合时），但它对于测试简单的脚本来说很有用。
- en: 'Since version 0.13, IPython includes the `cythonmagic` extension to interactively
    write and test a series of Cython statements. You can load the extensions in an
    IPython shell using `load_ext`, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自从版本0.13起，IPython包含了`cythonmagic`扩展，可以交互式地编写和测试一系列Cython语句。你可以使用`load_ext`在IPython
    shell中加载扩展，如下所示：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the extension is loaded, you can use the `%%cython` *cell magic* to write
    a multiline Cython snippet. In the following example, we define a `hello_snippet`
    function that will be compiled and added to the IPython session namespace:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦扩展被加载，你可以使用`%%cython` *cell magic*来编写多行Cython代码片段。在下面的示例中，我们定义了一个`hello_snippet`函数，该函数将被编译并添加到IPython会话命名空间中：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is that simple to work with Cython source code. In the next section, we will
    see how we can add static types to our program, getting it closer to C code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与Cython源代码一起工作非常简单。在下一节中，我们将看到如何将静态类型添加到我们的程序中，使其更接近C代码。
- en: Adding static types
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加静态类型
- en: In Python, a variable can be associated with objects of different types during
    the execution of the program. While this feature is desirable as it makes the
    language flexible and dynamic, it also adds significant overhead to the interpreter
    as it needs to look up the type and methods of the variables at runtime, making
    it difficult to perform various optimizations. Cython extends the Python language
    with explicit type declarations so that it can generate efficient C extensions
    through compilation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一个变量可以在程序执行期间与不同类型的对象关联。虽然这个特性使得语言更加灵活和动态，但它也给解释器带来了显著的开销，因为它需要在运行时查找变量的类型和方法，这使得执行各种优化变得困难。Cython通过编译扩展Python语言，以显式类型声明，从而可以生成高效的C扩展。
- en: The main way to declare data types in Cython is through `cdef` statements. The
    `cdef` keyword can be used in multiple contexts, such as variables, functions,
    and extension types (statically typed classes). We will see how to do this in
    the following subsections.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中声明数据类型的主要方式是通过 `cdef` 语句。`cdef` 关键字可以在多个上下文中使用，例如变量、函数和扩展类型（静态类型类）。我们将在以下小节中看到如何做到这一点。
- en: Declaring variables
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'In Cython, you can declare the type of a variable by prepending the variable
    with `cdef` and its respective type. For example, we can declare the `i` variable
    as a 16-bit integer in the following way:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，可以通过在变量前加上 `cdef` 和相应的类型来声明变量的类型。例如，我们可以以下这种方式声明 `i` 变量为 16 位整数：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `cdef` statement supports multiple variable names on the same line along
    with optional initialization, as seen in the following line of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdef` 语句支持在同一行上声明多个变量名，以及可选的初始化，如下面的代码行所示：'
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Typed variables are treated differently from regular variables. In Python,
    variables are often described as *labels* that refer to objects in memory. For
    example, we could assign the value `''hello''` to the `a` variable at any point
    in the program without restriction, as illustrated here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 带类型的变量与普通变量处理方式不同。在 Python 中，变量通常被描述为 *标签*，它们指向内存中的对象。例如，我们可以在程序的任何位置将值 `'hello'`
    赋给 `a` 变量，而不受限制，如下所示：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `a` variable holds a reference to the `''hello''` string. We can also freely
    assign another value (for example, the integer `1`) to the same variable later
    in the code, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 变量持有 `''hello''` 字符串的引用。我们还可以在代码的后面自由地将另一个值（例如整数 `1`）赋给同一个变量，如下所示：'
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Python will assign the integer `1` to the `a` variable without any problem.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会将整数 `1` 无任何问题地赋值给 `a` 变量。
- en: 'Typed variables behave quite differently and are usually described as *data
    containers*: we can only store values that fit into the container that is determined
    by its data type. For example, if we declare the `a` variable as `int`, and then
    we try to assign it to a `double` data type, Cython will trigger an error, as
    shown in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 带类型的变量表现得很不同，通常被描述为 *数据容器*：我们只能存储适合容器中值的类型。例如，如果我们将 `a` 变量声明为 `int`，然后我们尝试将其赋值为
    `double` 数据类型，Cython 将会触发错误，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Static typing makes it easy for the compiler to perform useful optimizations.
    For example, if we declare a loop index as `int`, Cython will rewrite the loop
    in pure C without needing to step into the Python interpreter. The typing declaration
    guarantees that the type of the index will always be `int` and cannot be overwritten
    at runtime so that the compiler is free to perform optimizations without compromising
    the program's correctness.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型使得编译器能够执行有用的优化。例如，如果我们将循环索引声明为 `int`，Cython 将会重写循环为纯 C 代码，而无需进入 Python 解释器。类型声明保证了索引的类型始终是
    `int`，并且在运行时不能被覆盖，这样编译器就可以自由地进行优化，而不会损害程序的正确性。
- en: 'We can assess the speed gain in this case with a small test case. In the following
    example, we implement a simple loop that increments a variable `100` times. With
    Cython, the `example` function can be coded as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个小测试用例来评估这种情况下的速度提升。在以下示例中，我们实现了一个简单的循环，该循环将变量 `100` 次自增。使用 Cython，`example`
    函数可以编写如下：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can compare the speed of an analogous, untyped, pure Python loop, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比较类似的无类型、纯 Python 循环的速度，如下所示：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The speedup obtained by implementing this simple type declaration is a whopping
    100 times! This works because the Cython loop has first been converted to pure
    C and then to efficient machine code, while the Python loop still relies on the
    slow interpreter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现这种简单的类型声明获得的加速效果是惊人的 100 倍！这是因为 Cython 循环首先被转换为纯 C 代码，然后转换为高效的机器代码，而 Python
    循环仍然依赖于缓慢的解释器。
- en: In Cython, it is possible to declare a variable to be of any standard C type,
    and it is also possible to define custom types using classic C constructs, such
    as `struct`, `enum`, and `typedef`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，可以声明变量为任何标准 C 类型，也可以使用经典的 C 构造定义自定义类型，例如 `struct`、`enum` 和 `typedef`。
- en: 'An interesting example is that if we declare a variable to be of the `object`
    type, the variable will accept any kind of Python object, as illustrated in the
    following code snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的例子是，如果我们声明一个变量为 `object` 类型，该变量将接受任何类型的 Python 对象，如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that declaring a variable as `object` has no performance benefits, as accessing
    and operating on the object will still require the interpreter to look up the
    underlying type of the variable and its attributes and methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，将变量声明为`object`没有性能优势，因为访问和操作该对象仍然需要解释器查找变量的底层类型及其属性和方法。
- en: 'Sometimes, certain data types (such as `float` and `int` numbers) are compatible
    in the sense that they can be converted into each other. In Cython, it is possible
    to convert (*cast*) between types by surrounding the destination type with pointy
    brackets, as shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些数据类型（如`float`和`int`数字）在某种意义上是兼容的，即它们可以相互转换。在Cython中，可以通过在目标类型周围放置尖括号来在类型之间进行转换（*cast*），如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Together with static types for variables, we can provide information about functions,
    which we will learn how to do next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了变量的静态类型外，我们还可以提供有关函数的信息，我们将在下一节学习如何做到这一点。
- en: Declaring functions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明函数
- en: 'You can add type information to the arguments of a Python function by specifying
    the type in front of each of the argument names. Functions specified in this way
    will work and perform like regular Python functions, but their arguments will
    be type-checked. We can write a `max_python` function that returns the greater
    value between two integers, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在每个参数名称前指定类型来向Python函数的参数添加类型信息。以这种方式指定的函数将像常规Python函数一样工作并执行，但它们的参数将进行类型检查。我们可以编写一个`max_python`函数，返回两个整数之间的较大值，如下所示：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A function specified in this way will perform type checking and treat the arguments
    as typed variables, just as in `cdef` definitions. However, the function will
    still be a Python function, and calling it multiple times will still need to switch
    back to the interpreter. To allow Cython for function call optimizations, we should
    declare the type of the return type using a `cdef` statement, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式指定的函数将执行类型检查并将参数视为类型化变量，就像在`cdef`定义中一样。然而，该函数仍然是一个Python函数，多次调用它仍然需要切换回解释器。为了允许Cython对函数调用进行优化，我们应该使用`cdef`语句声明返回类型的类型，如下所示：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Functions declared in this way are translated to native C functions and have
    much less overhead compared to Python functions. A substantial drawback is that
    they can't be used from Python but only from Cython, and their scope is restricted
    to the same Cython file unless they're exposed in a definition file (refer to
    the *Sharing declarations* section).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式声明的函数被转换为本地C函数，与Python函数相比，开销要小得多。一个显著的缺点是它们不能从Python中使用，而只能从Cython中使用，并且它们的范围限制在相同的Cython文件中，除非它们在定义文件中公开（参考*共享声明*部分）。
- en: 'Fortunately, Cython allows you to define functions that are both callable from
    Python and translatable to performant C functions. If you declare a function with
    a `cpdef` statement, Cython will generate two versions of the function: a Python
    version available to the interpreter, and a fast C function usable from Cython.
    The `cpdef` syntax is equivalent to `cdef`, shown as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Cython允许您定义既可以从Python调用又可转换为高性能C函数的函数。如果您使用`cpdef`语句声明函数，Cython将生成函数的两个版本：一个可供解释器使用的Python版本，以及一个从Cython可用的快速C函数。`cpdef`语法与`cdef`等效，如下所示：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Sometimes, the call overhead can be a performance issue even with C functions,
    especially when the same function is called many times in a critical loop. When
    the function body is small, it is convenient to add the `inline` keyword in front
    of the function definition; the function call will be replaced by the function
    body itself. Our `max` function is a good candidate for *inlining*, as illustrated
    in the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使使用C函数，调用开销也可能成为性能问题，尤其是在关键循环中多次调用同一函数时。当函数体较小时，在函数定义前添加`inline`关键字是很方便的；函数调用将被函数体本身替换。我们的`max`函数是进行内联的好候选，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we will see how to work with class types next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到如何处理类类型。
- en: Declaring classes
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类
- en: 'We can define an extension type using the `cdef class` statement and declare
    its attributes in the class body. For example, we can create a `Point` extension
    type, as shown in the following code snippet, which stores two coordinates (`x`,
    `y`) of the `double` type:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`cdef class`语句定义扩展类型，并在类体中声明其属性。例如，我们可以创建一个`Point`扩展类型，如下面的代码片段所示，它存储两个`double`类型的坐标（`x`，`y`）：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Accessing the declared attributes in the class methods allows Cython to bypass
    expensive Python attribute lookups by direct access to the given fields in the
    underlying C struct. For this reason, attribute access in typed classes is an
    extremely fast operation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法中访问声明的属性允许Cython通过直接访问底层C结构中的给定字段来绕过昂贵的Python属性查找。因此，类型化类中的属性访问是一个极快的操作。
- en: 'To use the `cdef class` statement in your code, you need to explicitly declare
    the type of the variables you intend to use at compile time. You can use the extension
    type name (such as `Point`) in any context where you will use a standard type
    (such as `double`, `float`, and `int`). For example, if we want a Cython function
    that calculates the distance from the origin (in the example, the function is
    called `norm`) of a `Point`, we have to declare the input variable as `Point`,
    as shown in the following code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中使用`cdef class`语句，您需要在编译时显式声明您打算使用的变量的类型。您可以在任何您将使用标准类型（如`double`、`float`和`int`）的上下文中使用扩展类型名称（如`Point`）。例如，如果我们想要一个Cython函数来计算从原点（在示例中，该函数称为`norm`）到`Point`的距离，我们必须将输入变量声明为`Point`，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Just as with typed functions, typed classes have some limitations. If you try
    to access an extension type attribute from Python, you will get an `AttributeError`
    warning, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如类型化函数一样，类型化类也有一些限制。如果您尝试从Python访问扩展类型属性，您将收到一个`AttributeError`警告，如下所示：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In order to access attributes from Python code, you have to use the `public`
    (for read/write access) or `readonly` specifiers in the attribute declaration,
    as shown in the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Python代码中访问属性，您必须在属性声明中使用`public`（用于读写访问）或`readonly`指定符，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Additionally, methods can be declared with the `cpdef` statement, just as with
    regular functions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用`cpdef`语句声明方法，就像常规函数一样。
- en: Extension types do not support the addition of extra attributes at runtime.
    To do that, a solution is defining a Python class that is a subclass of the typed
    class and extends its attributes and methods in pure Python.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展类型不支持在运行时添加额外的属性。为了实现这一点，可以通过定义一个Python类，使其成为类型化类的子类，并在纯Python中扩展其属性和方法来解决这个问题。
- en: And with that, we have seen how to add static types to various objects in Cython.
    In the next section, we will begin our discussion regarding declarations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经看到了如何在Cython中向各种对象添加静态类型。在下一节中，我们将开始讨论声明。
- en: Sharing declarations
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明共享
- en: When writing your Cython modules, you may want to reorganize your most-used
    functions and classes declaration in a separate file so that they can be reused
    in different modules. Cython allows you to put these components in a *definition
    file* and access them with `cimport` statements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写您的Cython模块时，您可能希望将最常用的函数和类声明重新组织到一个单独的文件中，以便它们可以在不同的模块中重用。Cython允许您将这些组件放入一个*定义文件*中，并通过`cimport`语句访问它们。
- en: Let's say that we have a module with the `max` and `min` functions, and we want
    to reuse those functions in multiple Cython programs. If we simply write a bunch
    of functions in a `.pyx` file, the declarations will be confined to the same file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含`max`和`min`函数的模块，并且我们想在多个Cython程序中重用这些函数。如果我们简单地在`.pyx`文件中编写一些函数，声明将仅限于同一文件。
- en: Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Definition files are also used to interface Cython with external C code. The
    idea is to copy (or, more accurately, translate) the types and function prototypes
    in the definition file and leave the implementation in the external C code that
    will be compiled and linked in a separate step.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '定义文件也用于将Cython与外部C代码接口。想法是将定义文件中的类型和函数原型复制（或更准确地说，翻译）到外部C代码中，该代码将在单独的步骤中编译和链接。 '
- en: 'To share the `max` and `min` functions, we need to write a definition file
    with a `.pxd` extension. Such a file only contains the types and function prototypes
    that we want to share with other modules—a *public* interface. We can declare
    the prototypes of our `max` and `min` functions in a file named `mathlib.pxd`,
    as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了共享`max`和`min`函数，我们需要编写一个具有`.pxd`扩展名的定义文件。这样的文件只包含我们想要与其他模块共享的类型和函数原型——一个*公共*接口。我们可以在名为`mathlib.pxd`的文件中声明我们的`max`和`min`函数的原型，如下所示：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, we only write the function name and arguments without implementing
    the function body.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只编写了函数名和参数，而没有实现函数体。
- en: 'The function implementation goes into the implementation file with the same
    base name but the `.pyx` extension `mathlib.pyx`, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数实现将放入与基本名称相同但扩展名为 `.pyx` 的实现文件 `mathlib.pyx` 中，如下所示：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `mathlib` module is now importable from another Cython module.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`mathlib` 模块现在可以从另一个 Cython 模块导入。'
- en: 'To test our new Cython module, we will create a file named `distance.pyx` containing
    a function named `chebyshev`. The function will calculate the Chebyshev distance
    between two points, as shown in the following code snippet. The Chebyshev distance
    between two coordinates—`(x1,` `y1)` and `(x2, y2`—is defined as the maximum value
    of the difference between each coordinate:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们新的 Cython 模块，我们将创建一个名为 `distance.pyx` 的文件，其中包含一个名为 `chebyshev` 的函数。该函数将计算两点之间的
    Chebyshev 距离，如下所示。两点坐标——`(x1, y1)` 和 `(x2, y2)` 之间的 Chebyshev 距离定义为每个坐标之间差异的最大值：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To implement the `chebyshev` function, we will use the `max` function declared
    in `mathlib.pxd` by importing it with the `cimport` statement, as shown in the
    following code snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 `chebyshev` 函数，我们将使用在 `mathlib.pxd` 中声明的 `max` 函数，通过 `cimport` 语句导入，如下所示：
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `cimport` statement will read `mathlib.pxd` and the `max` definition will
    be used to generate a `distance.c` file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`cimport` 语句将读取 `mathlib.pxd`，并将 `max` 定义用于生成 `distance.c` 文件。'
- en: Along with static types and declarations, one factor that allows C to be generally
    faster than Python is its highly optimized array operations, which we will examine
    in the next section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态类型和声明之外，C 通常比 Python 快的一个因素是其高度优化的数组操作，我们将在下一节中探讨。
- en: Working with arrays
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数组一起工作
- en: Numerical and high-performance calculations often make use of arrays. Cython
    provides an easy way to interact with different types of arrays, using directly
    low-level C arrays, or the more general *typed memoryviews*. We will see how to
    do this in the following subsections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 数值和高性能计算通常使用数组。Cython 提供了一种简单的方法来与不同类型的数组交互，可以直接使用低级 C 数组，或者更通用的 *类型内存视图*。我们将在以下小节中看到如何做到这一点。
- en: C arrays and pointers
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C 数组和指针
- en: C arrays are a collection of items of the same type, stored contiguously in
    memory. Before digging into the details, it is helpful to understand (or review)
    how memory is managed in C.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: C 数组是相同类型项的集合，在内存中连续存储。在深入细节之前，了解（或复习）C 中内存的管理方式是有帮助的。
- en: Variables in C are like containers. When creating a variable, a space in memory
    is reserved to store its value. For example, if we create a variable containing
    a 64-bit floating-point number (`double`), the program will allocate 64 bits (16
    bytes) of memory. This portion of memory can be accessed through an address to
    that memory location.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: C 中的变量就像容器。在创建变量时，会在内存中预留空间以存储其值。例如，如果我们创建一个包含 64 位浮点数（`double`）的变量，程序将分配 64
    位（16 字节）的内存。可以通过访问该内存位置的地址来访问这部分内存。
- en: 'To obtain the address of a variable, we can use the *address operator* denoted
    by the `&` symbol. We can also use the `printf` function, as follows, available
    in the `libc.stdio` Cython module to print the address of this variable:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取变量的地址，我们可以使用表示为 `&` 符号的 *地址运算符*。我们还可以使用 `printf` 函数，如下所示，这在 `libc.stdio`
    Cython 模块中可用，用于打印该变量的地址：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output will only be generated when the code is run from a standard Python
    terminal. This limitation of IPython is detailed at [https://github.com/ipython/ipython/issues/1230](https://github.com/ipython/ipython/issues/1230).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当代码从标准 Python 终端运行时，才会生成输出。IPython 的这个限制在 [https://github.com/ipython/ipython/issues/1230](https://github.com/ipython/ipython/issues/1230)
    中有详细说明。
- en: 'Memory addresses can be stored in special variables, *pointers*, that can be
    declared by putting a `*` prefix in front of the variable name, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 内存地址可以存储在特殊的变量中，即 *指针*，可以通过在变量名前放置一个 `*` 前缀来声明，如下所示：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we have a pointer and we want to grab the value contained in the address
    it''s pointing at, we can use the zero-index notation shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个指针，并且想要获取它指向的地址中包含的值，我们可以使用这里显示的零索引表示法：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When declaring a C array, the program allocates enough space to accommodate
    all the elements requested. For instance, to create an array that has 10 `double`
    values (16 bytes each), the program will reserve *16* * *10* = *160* bytes of
    contiguous space in memory. In Cython, we can declare such arrays using the following
    syntax:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明 C 数组时，程序会分配足够的空间来容纳请求的所有元素。例如，为了创建一个包含 10 个 `double` 值（每个 16 字节）的数组，程序将在内存中预留
    *16* * *10* = *160* 字节的连续空间。在 Cython 中，我们可以使用以下语法声明此类数组：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also declare a multidimensional array, such as an array with `5` rows
    and `2` columns, using the following syntax:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下语法声明一个多维数组，例如具有`5`行和`2`列的数组：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The memory will be allocated in a single block of memory, row after row. This
    order is commonly referred to as *row-major* and is depicted in the following
    screenshot. Arrays can also be *column-major* ordered, as is the case for the
    Fortran programming language:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 内存将在单个内存块中分配，行后行。这种顺序通常被称为*行主序*，如下面的截图所示。数组也可以按*列主序*排序，这是Fortran编程语言的情况：
- en: '![Figure 4.1 – Row-major order ](img/B17499_Figure_4.1.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 行主序](img/B17499_Figure_4.1.jpg)'
- en: Figure 4.1 – Row-major order
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 行主序
- en: Array ordering has important consequences. When iterating a C array over the
    last dimension, we access contiguous memory blocks (in our example, 0, 1, 2, 3
    ...), while when we iterate on the first dimension, we skip a few positions (0,
    2, 4, 6, 8, 1 ... ). You should always try to access memory sequentially as this
    optimizes cache and memory usage.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组排序有重要的后果。当我们按最后一个维度迭代C数组时，我们访问连续的内存块（在我们的例子中，0, 1, 2, 3 ...），而当我们按第一个维度迭代时，我们会跳过一些位置（0,
    2, 4, 6, 8, 1 ...）。你应该始终尝试按顺序访问内存，因为这优化了缓存和内存使用。
- en: 'We can store and retrieve elements from the array using standard indexing,
    as shown here; C arrays don''t support fancy indexing or slices:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准索引来存储和检索数组中的元素，如下所示；C数组不支持复杂索引或切片：
- en: '[PRE39]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'C arrays have many of the same behaviors as pointers. The `arr` variable, in
    fact, points to the memory location of the first element of the array. We can
    verify that the address of the first element of the array is the same as the address
    contained in the `arr` variable using the dereference operator, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: C数组具有与指针许多相同的行为。实际上，`arr`变量指向数组的第一个元素的内存位置。我们可以使用解引用操作符来验证数组第一个元素的地址与`arr`变量中包含的地址相同，如下所示：
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The output will only be generated when the aforementioned code is run from a
    standard Python terminal. This limitation of IPython is detailed at [https://github.com/ipython/ipython/issues/1230](https://github.com/ipython/ipython/issues/1230).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当从标准Python终端运行上述代码时，才会生成输出。IPython的这个限制在[https://github.com/ipython/ipython/issues/1230](https://github.com/ipython/ipython/issues/1230)中详细说明。
- en: You should use C arrays and pointers when interfacing with existing C libraries
    or when you need fine control over the memory (also, they are very performant).
    This level of fine control is also prone to mistakes as it doesn't prevent you
    from accessing the wrong memory locations. For more common use cases and improved
    safety, you can use NumPy arrays or typed memoryviews.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在与现有的C库接口或需要精细控制内存时（此外，它们性能也非常出色），你应该使用C数组和指针。这种精细控制水平也容易出错，因为它不能阻止你访问错误的内存位置。对于更常见的用例和改进的安全性，你可以使用NumPy数组或类型化内存视图。
- en: Working with NumPy arrays
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用NumPy数组
- en: NumPy arrays can be used as normal Python objects in Cython, using their already
    optimized broadcasted operations. However, Cython provides a `numpy` module with
    better support for direct iteration.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组可以在Cython中用作普通Python对象，使用它们已经优化的广播操作。然而，Cython提供了一个`numpy`模块，它提供了更好的直接迭代支持。
- en: When we normally access an element of a NumPy array, a few other operations
    take place at the interpreter level, causing a major overhead. Cython can bypass
    those operations and checks by acting directly on the underlying memory area used
    by NumPy arrays, thus obtaining impressive performance gains.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通常访问NumPy数组的一个元素时，解释器级别会执行一些其他操作，这导致大量开销。Cython可以通过直接作用于NumPy数组使用的底层内存区域来绕过这些操作和检查，从而获得令人印象深刻的性能提升。
- en: 'NumPy arrays can be declared as the `ndarray` data type. To use the data type
    in our code, we first need to `cimport` the `numpy` Cython module (which is not
    the same as the Python `numpy` module). We will bind the module to the `c_np`
    variable to make the difference with the Python `numpy` module more explicit,
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组可以声明为`ndarray`数据类型。要在我们的代码中使用该数据类型，我们首先需要`cimport` `numpy` Cython模块（它与Python的`numpy`模块不同）。我们将该模块绑定到`c_np`变量，以使与Python
    `numpy`模块的差异更加明确，如下所示：
- en: '[PRE41]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now declare a NumPy array by specifying its type and the number of dimensions
    between square brackets (this is called *buffer syntax*). To declare a `double`,
    we can use the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过指定其类型和方括号之间的维度数来声明NumPy数组（这称为*缓冲区语法*）。要声明`double`，我们可以使用以下代码：
- en: '[PRE42]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Access to this array will be performed by directly operating on the underlying
    memory area; the operation will avoid stepping into the interpreter, giving us
    a tremendous speed boost.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个数组的访问将通过直接操作底层内存区域来完成；这种操作将避免进入解释器，给我们带来巨大的速度提升。
- en: In the next example, we will show the usage of typed NumPy arrays and compare
    them with the normal Python version.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将展示类型化NumPy数组的用法，并将其与常规Python版本进行比较。
- en: 'We first write a `numpy_bench_py` function that increments each element of
    `py_arr`. We declare the `i` index as an integer so that we avoid the `for` loop
    overhead, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写一个`numpy_bench_py`函数，该函数递增`py_arr`中的每个元素。我们将`i`索引声明为整数，这样我们就可以避免`for`循环的开销，如下所示：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we write the same function using the `ndarray` type. Note that after
    we define the `c_arr` variable using `c_np.ndarray`, we can assign to it an array
    from the `numpy` Python module. The code is illustrated in the following snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ndarray`类型编写相同的函数。请注意，在定义`c_arr`变量使用`c_np.ndarray`之后，我们可以从`numpy`Python模块分配一个数组给它。代码如下所示：
- en: '[PRE44]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can time the results using `timeit`, and we can see here how the typed version
    is 50 times faster:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`timeit`来计时结果，并且我们可以看到这里，类型化的版本要快50倍：
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This gives us a significant speedup from the Python code!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们从Python代码中获得了显著的加速效果！
- en: Working with typed memoryviews
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型化的内存视图
- en: C and NumPy arrays, as well as the built-in `bytes`, `bytearray`, and `array.array`
    objects, are similar in the sense that they all operate on a contiguous memory
    area (also called a memory *buffer*). Cython provides a universal interface—a
    *typed memoryview*—that unifies and simplifies access to all these data types.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: C和NumPy数组，以及内置的`bytes`、`bytearray`和`array.array`对象，在某种意义上是相似的，因为它们都在连续的内存区域（也称为内存*缓冲区*）上操作。Cython提供了一个通用接口——*类型化的内存视图*——它统一并简化了对所有这些数据类型的访问。
- en: 'A `int` and a 2D memoryview of `double` in the following way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是以这种方式声明一个`int`和一个`double`的二维内存视图：
- en: '[PRE46]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The same syntax applies to the declaration of any type in variables, function
    definitions, class attributes, and so on. Any object that exposes a buffer interface
    (for example, NumPy arrays, `bytes`, and `array.array` objects) will be bound
    to the memoryview automatically. For example, we can bind the memoryview to a
    NumPy array using a simple variable assignment, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的语法也适用于变量、函数定义、类属性等的类型声明。任何暴露缓冲区接口的对象（例如，NumPy数组、`bytes`和`array.array`对象）都将自动绑定到内存视图。例如，我们可以通过简单的变量赋值将内存视图绑定到NumPy数组，如下所示：
- en: '[PRE47]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It is important to note that the memoryview does not *own* the data, but it
    only provides a way to *access* and *change* the data it is bound to; the ownership,
    in this case, is left to the NumPy array. As you can see in the following example,
    changes made through the memoryview will act on the underlying memory area and
    will be reflected in the original NumPy structure (and vice versa):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，内存视图并不*拥有*数据，它只提供了一种*访问*和*更改*它所绑定数据的途径；在这种情况下，所有权留给了NumPy数组。正如你在下面的示例中可以看到的，通过内存视图所做的更改将作用于底层内存区域，并将反映在原始NumPy结构中（反之亦然）：
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In a certain sense, the mechanism behind memoryviews is similar to what NumPy
    produces when we slice an array. As we have seen in [*Chapter 3*](B17499_03_Final_SS_ePub.xhtml#_idTextAnchor047),
    *Fast Array Operations with NumPy, Pandas, and Xarray*, slicing a NumPy array
    does not copy the data but returns a view on the same memory area, and changes
    to the view will reflect on the original array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，内存视图背后的机制与NumPy在切片数组时产生的机制相似。正如我们在[*第3章*](B17499_03_Final_SS_ePub.xhtml#_idTextAnchor047)中看到的，“使用NumPy、Pandas和Xarray进行快速数组操作”，切片NumPy数组不会复制数据，而是返回对同一内存区域的视图，对视图的更改将反映在原始数组中。
- en: 'Memoryviews also support array slicing with the standard NumPy syntax, as illustrated
    in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 内存视图也支持使用标准的NumPy语法进行数组切片，如下面的代码片段所示：
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To copy data between one memoryview and another, you can use syntax similar
    to slice assignment, as shown in the following code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个内存视图之间复制数据，你可以使用类似于切片赋值的语法，如下面的代码片段所示：
- en: '[PRE50]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the next section, we will use typed memoryviews to declare types for the
    arrays in our particle simulator.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用类型化的内存视图来为粒子模拟器中的数组声明类型。
- en: Using a particle simulator in Cython
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Cython中使用粒子模拟器
- en: Now that we have a basic understanding of how Cython works, we can rewrite the
    `ParticleSimulator.evolve` method. Thanks to Cython, we can convert our loops
    in C, thus removing the overhead introduced by the Python interpreter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Cython的工作原理有了基本的了解，我们可以重写`ParticleSimulator.evolve`方法。多亏了Cython，我们可以将我们的循环转换为C语言，从而消除Python解释器引入的开销。
- en: 'In [*Chapter 3*](B17499_03_Final_SS_ePub.xhtml#_idTextAnchor047), *Fast Array
    Operations with NumPy, Pandas, and Xarray*, we wrote a fairly efficient version
    of the `evolve` method using NumPy. We can rename the old version `evolve_numpy`
    to differentiate it from the new version. The code is illustrated in the following
    snippet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B17499_03_Final_SS_ePub.xhtml#_idTextAnchor047)《使用NumPy、Pandas和Xarray进行快速数组操作》中，我们使用NumPy编写了一个相当高效的`evolve`方法版本。我们可以将旧版本重命名为`evolve_numpy`以区分新旧版本。代码如下所示：
- en: '[PRE51]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We want to convert this code to Cython. Our strategy will be to take advantage
    of the fast indexing operations by removing the NumPy array broadcasting, thus
    reverting to an indexing-based algorithm. Since Cython generates efficient C code,
    we are free to use as many loops as we like without any performance penalty.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将此代码转换为Cython。我们的策略将是利用快速的索引操作，通过移除NumPy数组广播，从而回到基于索引的算法。由于Cython生成高效的C代码，我们可以自由地使用尽可能多的循环而不会产生任何性能惩罚。
- en: As a design choice, we can decide to encapsulate the loop in a function that
    we will rewrite in a Cython module called `cevolve.pyx`. The module will contain
    a single Python function, `c_evolve`, that will take the particle positions, angular
    velocities, timestep, and the number of steps as input.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计选择，我们可以决定将循环封装在一个函数中，我们将用Cython模块`cevolve.pyx`重写这个函数。该模块将包含一个单一的Python函数`c_evolve`，它将接受粒子位置、角速度、时间步长和步数作为输入。
- en: 'At first, we are not adding typing information; we just want to isolate the
    function and ensure that we can compile our module without errors. The code is
    illustrated in the following snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们并没有添加类型信息；我们只想隔离函数并确保我们可以无错误地编译我们的模块。代码如下所示：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that we don''t need a return value for `c_evolve` as values are updated
    in place in the `r_i` array. We can benchmark the untyped Cython version against
    the old NumPy version by slightly changing our `benchmark` function, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为`c_evolve`返回值，因为值是在`r_i`数组中就地更新的。我们可以通过稍微修改我们的`benchmark`函数来将无类型Cython版本与旧的NumPy版本进行基准测试，如下所示：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can time the different versions in an IPython shell, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在IPython shell中计时不同的版本，如下所示：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The two versions have the same speed. Compiling the Cython module without static
    typing doesn't have any advantage over pure Python. The next step is to declare
    the type of all the important variables so that Cython can perform its optimizations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本的速度相同。在纯Python版本中，不使用静态类型编译Cython模块没有任何优势。下一步是声明所有重要变量的类型，以便Cython可以执行其优化。
- en: 'We can start adding types to the function arguments and see how the performance
    changes. We can declare the arrays as typed memoryviews containing `double` values.
    It''s worth mentioning that if we pass an array of the `int` or `float32` type,
    the casting won''t happen automatically and we will get an error. The code is
    illustrated in the following snippet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始向函数参数添加类型，并查看性能如何变化。我们可以声明数组为包含`double`值的类型化内存视图。值得一提的是，如果我们传递`int`或`float32`类型的数组，类型转换不会自动发生，我们将得到一个错误。代码如下所示：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At this point, we can rewrite the loops over the particles and timesteps. We
    can declare the `i` and `j` iteration indices and the `nparticles` particle number
    as `int`, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以重写粒子和时间步长的循环。我们可以声明`i`和`j`迭代索引以及`nparticles`粒子数为`int`，如下所示：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The algorithm is very similar to the pure Python version; we iterate over the
    particles and timesteps, and we compute the velocity and displacement vectors
    for each particle coordinate using the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 算法与纯Python版本非常相似；我们遍历粒子和时间步长，并使用以下代码计算每个粒子坐标的速度和位移向量：
- en: '[PRE57]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code snippet, we added the `x`, `y`, `ang_speed`, `norm`,
    `vx`, `vy`, `dx`, and `dy` variables. To avoid the Python interpreter overhead,
    we have to declare them with their corresponding types at the beginning of the
    function, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们添加了`x`、`y`、`ang_speed`、`norm`、`vx`、`vy`、`dx`和`dy`变量。为了避免Python解释器的开销，我们不得不在函数开始处声明它们对应的类型，如下所示：
- en: '[PRE58]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We also used a function called `sqrt` to calculate the norm. If we use the
    `sqrt` function present in the `math` module or the one in `numpy`, we will again
    include a slow Python function in our critical loop, thus killing our performance.
    A fast `sqrt` function is available in the standard C library, already wrapped
    in the `libc.math` Cython module. Run the following code to import it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个名为`sqrt`的函数来计算范数。如果我们使用`math`模块或`numpy`中的`sqrt`函数，我们将在关键循环中再次包含一个慢速的Python函数，从而降低我们的性能。标准C库中有一个快速的`sqrt`函数，已经包装在`libc.math`
    Cython模块中。运行以下代码来导入它：
- en: '[PRE59]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can rerun our benchmark to assess our improvements, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新运行基准测试来评估我们的改进，如下所示：
- en: '[PRE60]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For small particle numbers, the speedup is massive as we obtained a 40 times
    faster performance over the previous version. However, we should also try to test
    the performance scaling with a larger number of particles, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小粒子数量，速度提升非常显著，因为我们获得了比上一个版本快40倍的性能。然而，我们也应该尝试用更多的粒子数量来测试性能缩放，如下所示：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we increase the number of particles, the two versions get closer in speed.
    By increasing the particle size to `1000`, we already decreased our speedup to
    a more modest 6 times. This is likely because, as we increase the number of particles,
    the Python `for` loop overhead becomes less and less significant compared to the
    speed of other operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 随着粒子数量的增加，两个版本的速度越来越接近。通过将粒子大小增加到`1000`，我们已经将我们的速度提升降低到更适度的6倍。这可能是由于随着粒子数量的增加，Python
    `for`循环的开销与其他操作的速度相比变得越来越不显著。
- en: 'The topic of benchmarking naturally transitions us to our next section: profiling.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的主题自然地过渡到我们下一个部分：分析。
- en: Profiling Cython
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Cython
- en: 'Cython provides a feature called *annotated view* that helps find which lines
    are executed in the Python interpreter and which are good candidates for ulterior
    optimizations. We can turn this feature on by compiling a Cython file with the
    `-a` option. In this way, Cython will generate a `-a` option is shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Cython提供了一个名为*注释视图*的功能，有助于找到在Python解释器中执行的哪些行，以及哪些是后续优化的良好候选者。我们可以通过使用带有`-a`选项编译Cython文件来启用此功能。这样，Cython将生成以下所示的内容：
- en: '[PRE62]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The HTML file displayed in the following screenshot shows our Cython file line
    by line:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示的HTML文件显示了我们的Cython文件逐行：
- en: '![Figure 4.2 – Generated HTML containing annotated code ](img/B17499_Figure_4.2.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 包含注释代码的生成HTML](img/B17499_Figure_4.2.jpg)'
- en: Figure 4.2 – Generated HTML containing annotated code
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 包含注释代码的生成HTML
- en: Each line in the source code can appear in different shades of yellow. A more
    intense color corresponds to more interpreter-related calls, while white lines
    are translated to regular C code. Since interpreter calls substantially slow down
    execution, the objective is to make the function body as white as possible. By
    clicking on any of the lines, we can inspect the code generated by the Cython
    compiler. For example, the `v_y = x/norm` line checks that the norm is not `0`
    and raises a `ZeroDivisionError` error if the condition is not verified. The `x
    = r_i[j, 0]` line shows that Cython checks whether the indexes are within the
    bounds of the array. You may have noted that the last line is of a very intense
    color; by inspecting the code, we can see that this is actually a glitch—the code
    refers to a boilerplate related to the end of the function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码中的每一行都可以显示为不同的黄色阴影。颜色越深，与解释器相关的调用就越多，而白色行则被转换为常规的C代码。由于解释器调用会显著减慢执行速度，目标是将函数体尽可能变为白色。通过点击任何一行，我们可以检查Cython编译器生成的代码。例如，`v_y
    = x/norm`这一行检查范数是否不为`0`，如果条件未验证，则抛出`ZeroDivisionError`错误。`x = r_i[j, 0]`这一行显示Cython检查索引是否在数组的范围内。你可能已经注意到最后一行颜色非常深；通过检查代码，我们可以看到这实际上是一个错误——代码引用了与函数结束相关的样板代码。
- en: 'Cython can shut down checks such as division by zero so that it can remove
    those extra interpreter-related calls; this is usually accomplished through compiler
    directives. There are a few different ways to add compiler directives, as outlined
    here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Cython可以关闭如除以零等检查，以便它可以移除那些额外的解释器相关调用；这通常通过编译器指令完成。有几种不同的方法可以添加编译器指令，如下所述：
- en: Using a decorator or a context manager
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器或上下文管理器
- en: Using a comment at the beginning of the file
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件开头使用注释
- en: Using the Cython command-line options
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cython命令行选项
- en: For a complete list of the Cython compiler directives, you can refer to the
    official documentation at [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Cython 编译器指令的完整列表，你可以参考官方文档在 [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives)。
- en: 'For example, to disable bounds checking for arrays, it is sufficient to decorate
    a function with `cython.boundscheck`, in the following way:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要禁用数组的边界检查，只需用 `cython.boundscheck` 装饰一个函数，如下所示：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Alternatively, we can use `cython.boundscheck` to wrap a block of code into
    a context manager, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 `cython.boundscheck` 将代码块包装成上下文管理器，如下所示：
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If we want to disable bounds checking for a whole module, we can add the following
    line of code at the beginning of the file:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想禁用整个模块的边界检查，我们可以在文件开头添加以下代码行：
- en: '[PRE65]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To alter the directives with the command-line options, you can use the `-X`
    option, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行选项更改指令，你可以使用 `-X` 选项，如下所示：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To disable the extra checks in our `c_evolve` function, we can disable the
    `boundscheck` directive and enable `cdivision` (this prevents checks for `ZeroDivisionError`),
    as in the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用 `c_evolve` 函数中的额外检查，我们可以禁用 `boundscheck` 指令并启用 `cdivision`（这防止了 `ZeroDivisionError`
    的检查），如下面的代码片段所示：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we look at the annotated view again, the loop body has become completely
    white—we removed all traces of the interpreter from the inner loop. In order to
    recompile, just type `python setup.py build_ext --inplace` again. By running the
    benchmark, however, we note that we didn''t obtain a performance improvement,
    suggesting that those checks are not part of the bottleneck, as we can see here:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看注释视图，循环体已经完全变为白色——我们从内部循环中移除了所有解释器的痕迹。为了重新编译，只需再次输入 `python setup.py
    build_ext --inplace`。然而，通过运行基准测试，我们注意到我们没有获得性能提升，这表明这些检查不是瓶颈的一部分，正如我们在这里可以看到的：
- en: '[PRE68]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Another way to profile Cython code is using the `cProfile` module. As an example,
    we can write a simple function that calculates the Chebyshev distance between
    coordinate arrays. Create a `cheb.py` file, as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 Cython 代码的另一种方法是使用 `cProfile` 模块。例如，我们可以编写一个简单的函数来计算坐标数组之间的 Chebyshev 距离。创建一个
    `cheb.py` 文件，如下所示：
- en: '[PRE69]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If we try profiling this script as-is, we won''t get any statistics regarding
    the functions that we implemented in Cython. If we want to collect profiling information
    for the `max` and `min` functions, we need to add the `profile=True` option to
    the `mathlib.pyx` file, as shown in the following code snippet:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试以当前状态分析这个脚本，我们将不会得到关于我们在 Cython 中实现的函数的任何统计信息。如果我们想收集 `max` 和 `min` 函数的配置文件信息，我们需要在
    `mathlib.pyx` 文件中添加 `profile=True` 选项，如下面的代码片段所示：
- en: '[PRE70]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can now profile our script with `%prun` using IPython, as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 IPython 的 `%prun` 来对脚本进行性能分析，如下所示：
- en: '[PRE71]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: From the output, we can see that the `max` function is present and is not a
    bottleneck. Most of the time seems to be spent in the `benchmark` function, meaning
    that the bottleneck is likely a pure Python `for` loop. In this case, the best
    strategy will be rewriting the loop in NumPy or porting the code to Cython.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到 `max` 函数存在并且不是瓶颈。大部分时间似乎都花在了 `benchmark` 函数上，这意味着瓶颈很可能是纯 Python
    的 `for` 循环。在这种情况下，最佳策略将是将循环重写为 NumPy 或将代码移植到 Cython。
- en: One feature in Python that many users enjoy is the ability to work with Jupyter
    Notebooks. When working with Cython, you don't have to give up on this feature.
    In the next and last section of this chapter, we will see how we can use Cython
    with Jupyter.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中许多用户都喜欢的特性之一是能够与 Jupyter 笔记本一起工作。当使用 Cython 时，你不必放弃这个特性。在本章的下一节和最后一节中，我们将看到如何使用
    Cython 与 Jupyter 一起使用。
- en: Using Cython with Jupyter
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cython 与 Jupyter
- en: Optimizing Cython code requires substantial trial and error. Fortunately, Cython
    tools can be conveniently accessed through Jupyter Notebooks for a more streamlined
    and integrated experience.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 优化 Cython 代码需要大量的尝试和错误。幸运的是，Cython 工具可以通过 Jupyter 笔记本方便地访问，以获得更流畅和集成的体验。
- en: You can launch a notebook session by typing `jupyter notebook` in the command
    line, and you can load the Cython magic by typing `%load_ext cython` in a cell.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在命令行中输入 `jupyter notebook` 来启动笔记本会话，你可以在一个单元中输入 `%load_ext cython` 来加载
    Cython 魔法。
- en: 'As mentioned earlier, the `%%cython` magic can be used to compile and load
    the Cython code inside the current session. As an example, we may copy the contents
    of the `cheb.py` file into a notebook cell, like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`%%cython` 魔法可以用于在当前会话中编译和加载 Cython 代码。例如，我们可以将 `cheb.py` 文件的内容复制到一个笔记本单元格中，如下所示：
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A useful feature of the `%%cython` magic is the `-a` option that will compile
    the code and produce an annotated view (just as with the `-a` command-line option)
    of the source code directly in the notebook, as shown in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`%%cython` 魔法的有用特性是 `-a` 选项，它将编译代码并直接在笔记本中生成源代码的注释视图（就像 `-a` 命令行选项一样），如下面的截图所示：'
- en: '![Figure 4.3 – Generated annotated code ](img/B17499_Figure_4.3.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 生成的注释代码](img/B17499_Figure_4.3.jpg)'
- en: Figure 4.3 – Generated annotated code
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 生成的注释代码
- en: 'This allows you to quickly test different versions of your code and use the
    other integrated tools available in Jupyter. For example, we can time and profile
    the code (provided that we activate the profile directive in the cell) in the
    same session using tools such as `%prun` and `%timeit`. We can also inspect the
    profiling results by taking advantage of the `%prun` magic, as shown in the following
    screenshot:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您快速测试代码的不同版本，并使用 Jupyter 中可用的其他集成工具。例如，我们可以使用 `%prun` 和 `%timeit` 等工具在同一会话中计时和性能分析代码（前提是我们激活了单元格中的性能分析指令）。我们还可以通过利用
    `%prun` 魔法来检查性能分析结果，如下面的截图所示：
- en: '![Figure 4.4 – Profiling output ](img/B17499_Figure_4.4.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 性能分析输出](img/B17499_Figure_4.4.jpg)'
- en: Figure 4.4 – Profiling output
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 性能分析输出
- en: 'It is also possible to use the `line_profiler` tool we discussed in [*Chapter
    1*](B17499_01_Final_SS_ePub.xhtml#_idTextAnchor015), *Benchmarking and Profiling*,
    directly in the notebook. To support line annotations, it is necessary to do the
    following things:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以直接在笔记本中使用我们之前在 [*第 1 章*](B17499_01_Final_SS_ePub.xhtml#_idTextAnchor015)
    中讨论的 `line_profiler` 工具，即 *基准测试和性能分析*。为了支持行注释，需要执行以下操作：
- en: Enable the `linetrace=True` and `binding=True` compiler directives.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 `linetrace=True` 和 `binding=True` 编译器指令。
- en: Enable the `CYTHON_TRACE=1` flag at compile time.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编译时启用 `CYTHON_TRACE=1` 标志。
- en: 'This can be easily accomplished by adding the respective arguments to the `%%cython`
    magic and by setting the compiler directives, as shown in the following code snippet:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过向 `%%cython` 魔法添加相应的参数以及设置编译器指令来实现，如下面的代码片段所示：
- en: '[PRE73]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Once the code is instrumented, we can install the `line_profiler` package via
    `pip install line_profiler` and profile using the `%lprun` magic, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代码被调试，我们就可以通过 `pip install line_profiler` 命令安装 `line_profiler` 包，并使用 `%lprun`
    魔法进行性能分析，如下所示：
- en: '[PRE74]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As you can see, a good chunk of time is spent in *line 16*, which is a pure
    Python loop and a good candidate for further optimization.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，大部分时间都花在了 *第 16 行*，这是一个纯 Python 循环，是进一步优化的良好候选。
- en: The tools available in Jupyter Notebook allow for a fast edit-compile-test cycle
    so that you can quickly prototype and save time when testing different solutions.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Jupyter Notebook 中的工具允许快速编辑-编译-测试周期，以便您可以快速原型设计并在测试不同解决方案时节省时间。
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Cython is a tool that bridges the convenience of Python with the speed of C.
    Compared to C bindings, Cython programs are much easier to maintain and debug,
    thanks to the tight integration and compatibility with Python and the availability
    of excellent tools.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一个工具，它将 Python 的便利性与 C 的速度相结合。与 C 绑定相比，Cython 程序更容易维护和调试，这得益于与 Python
    的紧密集成和兼容性，以及优秀工具的可用性。
- en: In this chapter, we introduced the basics of the Cython language and how to
    make our programs faster by adding static types to our variables and functions.
    We also learned how to work with C arrays, NumPy arrays, and memoryviews.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Cython 语言的基础知识以及如何通过给变量和函数添加静态类型来使我们的程序运行更快。我们还学习了如何与 C 数组、NumPy
    数组和 memoryviews 一起工作。
- en: We optimized our particle simulator by rewriting the critical `evolve` function,
    obtaining a tremendous speed gain. Finally, we learned how to use the annotated
    view to spot hard-to-find interpreter-related calls and how to enable `cProfile`
    support in Cython. Also, we learned how to take advantage of the Jupyter Notebook
    for integrated profiling and analysis of Cython code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过重写关键的 `evolve` 函数来优化我们的粒子模拟器，获得了巨大的速度提升。最后，我们学习了如何使用注释视图来查找难以发现的与解释器相关的调用，以及如何在
    Cython 中启用 `cProfile` 支持。此外，我们还学习了如何利用 Jupyter Notebook 对 Cython 代码进行集成分析和性能分析。
- en: All these tasks provide us with the high level of flexibility, which we already
    enjoy with Python, when working with Cython, while allowing our programs to be
    more optimized with low-level C code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都为我们提供了与使用 Python 时相同的高级别灵活性，同时允许我们的程序通过低级 C 代码进行更优化的操作。
- en: In the next chapter, we will explore other tools that can generate fast machine
    code on the fly, without requiring the compilation of our code to C **ahead of
    time** (**AOT**).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨其他可以在不要求将我们的代码编译为 C 的情况下即时生成快速机器代码的工具（**AOT**）。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the benefit of implementing static types?
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现静态类型有什么好处？
- en: What is the benefit of a memoryview?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: memoryview 有什么好处？
- en: Which tools for profiling Cython were introduced in this chapter?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本章介绍了哪些用于分析 Cython 的工具？
