- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conditionals and Iteration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”Would you tell me, please, which way I ought to go from here?”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “That depends a good deal on where you want to get to.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Lewis Carroll, from Alice’s Adventures in Wonderland
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at Python’s built-in data types. Now that
    you are familiar with data in its many forms and shapes, it is time to start looking
    at how a program can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, **control flow** (or **flow of control** ) is the order
    in which individual statements, instructions, or function calls of an imperative
    program are executed or evaluated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The two main ways of controlling the flow of a program are **conditional programming**
    (also known as **branching** ) and **looping** . These techniques can be combined
    to produce an endless variety of programs. Rather than attempting to document
    all the ways of combining looping and branching, we will give you an overview
    of the flow control constructs available in Python. Then, we will walk you through
    a couple of example programs. This way, you should get a better feeling of how
    conditional programming and looping can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick peek at the `itertools` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditional programming, or branching, is something you do every moment of
    every day. Essentially, it consists of evaluating conditions and deciding what
    action to take: *if the light is green, then I can cross* ; *if it is raining,
    then I am taking the umbrella* ; and *if I am late for work, then I will call
    my manager* .'
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main tool for conditional programming in Python is the `if` statement.
    Its function is to evaluate an expression and, based on the result, choose which
    part of the code to execute. As usual, let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest example possible: the `if` statement evaluates the expression
    `late` in a Boolean context (exactly as if we were calling `bool(late)` ). If
    the result of the evaluation is `True` , then we enter the body of the code immediately
    after the `if` statement. Notice that the `print` instruction is indented, which
    means that it belongs to a scope defined by the `if` clause. Execution of this
    code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since `late` is `True` , the `print()` statement was executed. We can expand
    on the basic `if` statement, by adding an `else` clause. This provides an alternative
    set of instructions to execute when the expression in the `if` clause evaluates
    to `False` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we set `late = False` , so when we execute the code, the result
    is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the result of evaluating `late` , we can either enter block `#
    1` or block `# 2` , *but not both* . Block `# 1` is executed when `late` evaluates
    to `True` , while block `# 2` is executed when `late` evaluates to `False` . Try
    assigning `False` / `True` values to `late` and see how the output changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A specialized else: elif'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we have seen so far is sufficient when you have only one condition to evaluate
    and, at most, two alternative paths to take (the `if` and `else` clauses). Sometimes,
    however, there are situations where you have to evaluate more than one condition
    to choose from among multiple paths. To demonstrate this, we will need an example
    with a few more options to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we will create a simple tax calculator. Suppose that taxes are determined
    as follows: if your income is less than $10,000, you do not need to pay any taxes.
    If it is between $10,000 and $30,000, you must pay 20% in taxes. If it is between
    $30,000 and $100,000, you pay 35% in taxes, and if you are fortunate enough to
    earn over $100,000, you must pay 45% in taxes. Let us translate this into Python
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let us go through the example one line at a time. We start by setting up the
    income value. In the example, your income is $15,000. We enter the `if` statement.
    Notice that, this time, we also introduced the `elif` clause, which is a contraction
    of `else-if.` It differs from a plain `else` clause in that it also has its own
    condition. The `if` expression of `income < 10000` evaluates to `False` ; therefore,
    block `# 1` is not executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The control passes to the next condition: `elif income < 30000` . This one
    evaluates to `True` ; therefore, block `# 2` is executed, and because of this,
    Python then resumes execution after the whole `if` / `elif` / `elif` / `else`
    construct (which we can just call the `if` statement from now on). There is only
    one instruction after the `if` statement: the `print()` call, which produces output
    telling us that we will pay `$3000.0` in taxes this year ( *15,000 * 20%* ). Notice
    that the order is mandatory: `if` comes first, then (optionally) as many `elif`
    clauses as you may need, and then (optionally) a single `else` clause.'
  prefs: []
  type: TYPE_NORMAL
- en: No matter how many lines of code you may have within each block, when one of
    the conditions evaluates to `True` , the associated block is executed, and then
    execution resumes after the whole clause. If none of the conditions evaluates
    to `True` (for example, `income = 200000` ), then the body of the `else` clause
    would be executed (block `# 4` ). This example expands our understanding of the
    behavior of the `else` clause. Its block of code is executed when none of the
    preceding `if` / `elif` /.../ `elif` expressions have evaluated to `True` .
  prefs: []
  type: TYPE_NORMAL
- en: Try to modify the value of `income` until you can comfortably execute any of
    the blocks at will. Also, test the behavior at the **boundaries** where the values
    of the Boolean expressions in the `if` and `elif` clauses change. It is crucial
    to test boundaries thoroughly to ensure the correctness of your code. Should we
    allow you to drive at 18 or 17? Are we checking your age with `age < 18` or `age
    <= 18` ? You cannot imagine how many times we have had to fix subtle bugs that
    stemmed from using the wrong operator, so go ahead and experiment with the code.
    Change some instances of `<` to `<=` , and set `income` to be one of the boundary
    values (10,000, 30,000, or 100,000), as well as any value in between. See how
    the result changes, and get a good understanding of it before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also nest `if` statements. Let us look at another example to show you
    how. Let us say, for example, that your program encounters an error. If the alert
    system is the console, we print the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the alert system is an email, the severity of the error determines which
    address we should send the alert to. If the alert system is anything other than
    the console or email, we do not know what to do, so we do nothing. Let us put
    this into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have an *inner* `if` statement nested within the body of the `elif`
    clause of an *outer* `if` statement. Notice that the nesting is achieved by indenting
    the inner `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Let us step through the code and see what happens. We start by assigning values
    to `alert_system` , `error_severity` , and `error_message` . When we enter the
    outer `if` statement, if `alert_system == "console"` evaluates to `True` , body
    `# 1` is executed, and nothing else happens. On the other hand, if `alert_system
    == "email"` evaluates to `True` , then we enter the inner `if` statement. In the
    inner `if` statement, the `error_severity` determines whether we send an email
    to an admin, first-level support, or second-level support (blocks `# 2` , `# 3`
    , and `# 4` ). The `send_email()` function is not defined in this example, so
    trying to run it would give you an error. In the `errorsalert.py` module, which
    you can find in the source code of this book, we included a trick to redirect
    that call to a regular `print()` function, just so you can experiment on the console
    without actually sending an email. Try changing the values and see how it all
    works.
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing we would like to show you is the **ternary operator.** In Python,
    this is also known as a **conditional expression** . It looks and behaves like
    a short, in-line version of an `if` statement. When you just want to choose between
    two values, depending on some condition, it is sometimes easier and more readable
    to use the ternary operator instead of a full `if` statement. For example, instead
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For simple cases like this, we find it convenient to be able to express that
    logic in one line instead of four. Remember that, as a coder, you spend much more
    time reading code than writing it, so Python’s conciseness is invaluable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some languages (like C or JavaScript), the ternary operator is even more
    concise. For example, the above could be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although Python’s version is slightly more verbose, we think it more than makes
    up for that by being easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: Are you clear on how the ternary operator works? It is quite simple; `something
    if condition else something-else` evaluates to something `if` condition evaluates
    to `True` . Otherwise, if `condition` is `False` , the expression evaluates to
    `something-else` .
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Structural pattern matching** , often just called **pattern matching** ,
    is a relatively new feature that was introduced in Python 3.10 via PEP 634 ( [https://peps.python.org/pep-0634](https://peps.python.org/pep-0634)
    ). It was partly inspired by the pattern matching capabilities of languages like
    Haskel, Erlang, Scala, Elixir, and Ruby.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, the `match` statement compares a value against one or more *patterns*
    , and then it executes the code block associated with the first pattern that matches.
    Let us see a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We start by initializing `day_number` before entering the `match` statement.
    The `match` statement will attempt to match the value of `day_number` against
    a series of patterns, each of which is introduced by the **case** keyword. In
    our example, we have four patterns. The first `1 | 2 | 3 | 4 | 5` will match any
    of the values `1` , `2` , `3` , `4` , or `5` . This is known as an **OR pattern**
    ; it consists of a number of sub-patterns separated by `|` . It matches when any
    of the sub-patterns (in this case, the literal values `1` , `2` , `3` , `4` ,
    and `5` ) match. The second and third patterns in our example just consist of
    the integer literals `6` and `7` , respectively. The final pattern, `_` , is a
    **wildcard pattern** ; it is a catch-all that matches any value. A `match` statement
    can have at most one catch-all pattern, and if one is present, it must be the
    last pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The body of the first case block whose pattern matches will be executed. Afterward,
    execution resumes below the `match` statement without evaluating any of the remaining
    patterns. If none of the patterns match, execution resumes below the `match` statement
    without executing any of the case bodies. In our example, the first pattern matches,
    so `print("Weekday")` is executed. Take some time to experiment with this example.
    Try changing the value of `day_number` and see what happens when you run it.
  prefs: []
  type: TYPE_NORMAL
- en: The `match` statement resembles the `switch` / `case` statements of languages
    like C++ and JavaScript. However, it is much more powerful than that. The variety
    of different kinds of patterns available and the ability to compose patterns allow
    you to do much more than a simple C++ `switch` statement. For example, Python
    allows you to match sequences, dictionaries, or even custom classes. You can also
    capture and assign values to names in patterns. We do not have space here to cover
    everything you can do with pattern matching, but we encourage you to study the
    tutorial in PEP 636 ( [https://peps.python.org/pep-0636](https://peps.python.org/pep-0636)
    ) to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know everything about controlling the path of the code, let us
    move on to the next subject: *looping* .'
  prefs: []
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any experience with looping in other programming languages, you
    will find Python’s way of looping a bit different. First of all, what is looping?
    **Looping** means being able to repeat the execution of a code block more than
    once, according to the loop parameters given. There are different looping constructs
    that serve different purposes, and Python has distilled all of them down to just
    two, which you can use to achieve everything you need. These are the `for` and
    `while` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is technically possible to use either of them for any task that
    requires looping, they do serve different purposes. We will explore this difference
    thoroughly in this chapter. By the end of it, you will know when to use a `for`
    loop and when to use a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop is used when looping over a sequence, such as a list, tuple,
    or collection of objects. Let us start with a simple example and expand on the
    concept to see what the Python syntax allows us to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This simple snippet of code, when executed, prints all numbers from `0` to `4`
    . The body of the `for` loop (the `print()` line) is executed once for each value
    in the list `[0, 1, 2, 3, 4]` . In the first iteration, `number` is assigned the
    first value from the sequence; in the second iteration, `number` takes the second
    value; and so on. After the last item in the sequence, the loop terminates, and
    execution resumes normally with the code after the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We often need to iterate over a range of numbers, and it would be quite tedious
    to have to do so by hard coding the list somewhere. In such cases, the `range()`
    function comes to the rescue. Let us see the equivalent of the previous snippet
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `range()` function is used extensively to create sequences in Python programs.
    You can call it with a single value, which acts as `stop` (counting will start
    from `0` ). You can also pass two values ( `start` and `stop` ), or even three
    ( `start` , `stop` , and `step` ). Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For the moment, ignore that we need to wrap `range(...)` within a list. We
    will explain the reasons for this in *Chapter 5* , *Comprehensions and Generators*
    . You can see that the behavior is analogous to slicing (which we described in
    the previous chapter): `start` is included, `stop` is excluded, and you can add
    an optional `step` parameter, which by default is `1` .'
  prefs: []
  type: TYPE_NORMAL
- en: Try modifying the parameters of the `range()` call in our `simple.for.py` code
    and see what it prints.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have all the tools to iterate over a sequence, so let us build on that
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds a little bit of complexity to the game. Execution will
    show this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us use the **inside-out** technique to break it down. We start from the
    innermost part of what we are trying to understand, and we expand outward. So
    `len(surnames)` is the length of the surnames list: `3` . Therefore, `range(len(surnames))`
    is actually transformed into `range(3)` . This gives us the range `[0, 3)` , which
    is the sequence `(0, 1, 2)` . This means that the `for` loop will run for three
    iterations. In the first one, `position` will take the value `0` , while in the
    second one, it will take the value `1` , and the value `2` in the third and final
    iteration. Here, `(0, 1, 2)` represents the possible indexing positions for the
    `surnames` list. At position `0` , we find `"Rivest"` ; at position `1` , `"Shamir"`
    ; and at position `2` , `"Adleman"` . If you are curious about what these three
    men created together, change `print(position, surnames[position])` to `print(surnames[position][0],
    end="")` , add a final `print()` outside of the loop, and run the code again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this style of looping is much closer to languages such as Java or C. In
    Python, it is quite rare to see code like this. You can just iterate over any
    sequence or collection, so there is no need to get the list of positions and retrieve
    elements from a sequence at each iteration. Let us change the example into a more
    Pythonic form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop can iterate over the `surnames` list, and it gives back each
    element in order at each iteration. Running this code will print the three surnames,
    one at a time, which is much easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, what if you wanted to print the position as well? Or what if you needed
    it? Should you go back to the `range(len(...))` form? No. You can use the `enumerate()`
    built-in function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code is quite interesting as well. Notice that `enumerate()` gives back
    a two-tuple `(position, surname)` at each iteration, but still, it is more readable
    (and more efficient) than the `range(len(...))` example. You can call `enumerate()`
    with a `start` parameter, such as `enumerate(iterable, start)` , and it will start
    from `start` , rather than `0` . Just another little thing that shows you how
    much thought has been given to designing Python so that it makes your life easier.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a `for` loop to iterate over lists, tuples, and, in general, anything
    that Python calls **iterable** . This is an important concept, so let us discuss
    it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators and iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the Python documentation ( [https://docs.python.org/3.12/glossary.html#term-iterable](https://docs.python.org/3.12/glossary.html#term-iterable)
    ), an **iterable** is:'
  prefs: []
  type: TYPE_NORMAL
- en: An object capable of returning its members one at a time. Examples of iterables
    include all sequence types (such as list, str, and tuple) and some non-sequence
    types like dict, file objects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Simply put, what happens when you write `for k in sequence: ... body ...` is
    that the `for` loop asks `sequence` for the next element, gets something back,
    calls that something `k` , and then executes its body. Then, once again, the `for`
    loop asks `sequence` for the next element, calls it `k` again, executes the body
    again, and so on, until the sequence is exhausted. Empty sequences will result
    in zero executions of the body.'
  prefs: []
  type: TYPE_NORMAL
- en: Some data structures, when iterated over, produce their elements in order, such
    as lists, tuples, dictionaries, and strings, while others, such as sets, do not.
    Python gives us the ability to iterate over iterables, using a type of object
    called an **iterator** , which is an object that represents a stream of data.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the whole iterable/iterator mechanism is hidden behind the code.
    Unless you need to code your own iterable or iterator for some reason, you will
    not have to worry about this too much. However, it is important to understand
    how Python handles this key aspect of control flow because it shapes the way in
    which we write code.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to cover iteration in more detail in *Chapter 5* , *Comprehensions
    and Generators* , and *Chapter 6* , *OOP, Decorators, and Iterators* .
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over multiple sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us see another example of how to iterate over two sequences of the same
    length and work on their respective elements in pairs. Say we have a list of people’s
    names and a second list of numbers representing their ages. We want to print the
    pair person/age on one line for each of them. Let us start with an example, which
    we will refine gradually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, this code should be straightforward. We iterate over the list of positions
    ( `0` , `1` , `2` , `3` ) because we want to retrieve elements from two different
    lists. Executing it, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The code works, but it is not very Pythonic. It is cumbersome to have to get
    the length of `people` , construct a `range` , and then iterate over that. For
    some data structures, it may also be expensive to retrieve items by their position.
    It would be better if we could iterate over the sequences directly, as we do for
    a single sequence. Let us try to improve it by using `enumerate()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That is better, but still not perfect. We are iterating properly on `people`
    , but we are still fetching `age` using positional indexing, which we want to
    lose as well. We can achieve that by using the `zip()` function, which we encountered
    in the previous chapter. Let us use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That is much more elegant than the original version. When the `for` loop asks
    `zip(sequenceA, sequenceB)` for the next element, it gets back a tuple, which
    is unpacked into `person` and `age` . The tuple will have as many elements as
    the number of sequences we feed to the `zip()` function. Let us expand a little
    on the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added the `instruments` list. Now that we feed three
    sequences to the `zip()` function, the `for` loop gets back a *three-tuple* at
    each iteration. The elements of the tuple are unpacked and assigned to `person`
    , `age` , and `instrument` . Notice that the position of the elements in the tuple
    respects the position of the sequences in the `zip()` call. Executing the code
    will yield the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that it is not necessary to unpack the tuples when iterating over multiple
    sequences like this. You may need to operate on the tuple as a whole within the
    body of the `for` loop. It is, of course, perfectly possible to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is almost identical to the previous example. The difference is that instead
    of unpacking the tuple we get from `zip(...)` , we assign the entire tuple to
    `data` .
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding pages, we saw the `for` loop in action. It is useful when you
    need to loop over a sequence or a collection. The key point to keep in mind when
    you need to decide which looping construct to use is that the `for` loop is best
    suited in cases where you have to iterate over the elements of a container object
    or other iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are other cases when you just need to loop until some condition
    is satisfied, or even loop indefinitely until the application is stopped. In such
    cases, we do not have something to iterate on, so the `for` loop would be a poor
    choice. For situations like this, the `while` loop is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop is similar to the `for` loop in that both repeatedly execute
    a body of instructions. The difference is that the `while` loop does not loop
    over a sequence. Instead, it loops as long as a certain condition is satisfied.
    When the condition is no longer satisfied, the loop ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, let us see an example that will clarify everything for us. We want
    to print the binary representation of a positive number. To do so, we can use
    a simple algorithm that divides by two until we reach zero and collects the remainders.
    When we reverse the list of remainders we collected, we get the binary representation
    of the number we started with. For example, if we want a binary representation
    of the decimal number 6, the steps would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*6 / 2 = 3* with remainder *0* .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*3 / 2 = 1* with remainder *1* .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*1 / 2 = 0* with remainder *1* .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list of remainders is *0, 1, 1* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reversing this, we get *1, 1, 0* , which is also the binary representation
    of *6* : *110* .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let us translate this into Python code. We will calculate the binary representation
    of the number 39, which is 100111:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we highlighted `n > 0` , which is the condition to keep
    looping. Notice how the code matches the algorithm we described: as long as `n`
    is greater than `0` , we divide by `2` and add the remainder to a list. At the
    end (when `n` has reached `0` ), we reverse the list of remainders to get the
    binary representation of the original value of `n` .'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `divmod()` function to make the code a little shorter (and more
    Pythonic). The `divmod()` function takes a number and a divisor and returns a
    tuple, with the result of the integer division and its remainder. For example,
    `divmod(13, 5)` would return `(2, 3)` and, indeed, *5 * 2 + 3 = 13* .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we reassign `n` to the result of the division by `2` and remainder to the
    list of remainders in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in function `bin()` returns a binary representation of a number. So,
    apart from examples, or as an exercise, there is no need to implement this yourself
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the condition in a `while` loop is a condition to continue looping.
    If it evaluates to `True` , then the body is executed, another evaluation follows,
    and so on, until the condition evaluates to `False` . When that happens, the loop
    stops immediately without executing its body. If the condition never evaluates
    to `False` , the loop becomes a so-called **infinite loop** . Infinite loops are
    used, for example, when polling from network devices: you ask the socket whether
    there is any data, you do something with it if there is any, then you sleep for
    a small amount of time, and then you ask the socket again, over and over, without
    ever stopping.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To better illustrate the differences between for and while loops, let us adapt
    one of the previous examples ( `multiple.sequences.py` ) using a `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have highlighted the *initialization* , *condition*
    , and *update* of the `position` variable, which makes it possible to simulate
    the equivalent `for` loop code by handling the iteration manually. Everything
    that can be done with a `for` loop can also be done with a `while` loop, even
    though you can see there is a bit of boilerplate you have to go through to achieve
    the same result. The opposite is also true, but unless you have a reason to do
    so, you ought to use the right tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, use a `for` loop when you need to iterate over an iterable, and use
    a `while` loop when you need to loop according to whether a condition is satisfied
    or not. If you keep in mind the difference between the two purposes, you will
    never choose the wrong looping construct.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see how to alter the normal flow of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: The break and continue statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are scenarios where you will need to alter the regular flow of a loop.
    You can either skip a single iteration (as many times as you want), or you can
    break out of the loop entirely. A common use case for skipping iterations is,
    for example, when you are iterating over a list of items, but you only need to
    work on those that satisfy some condition. On the other hand, if you are iterating
    over a collection to search for an item that meets some requirement, you may want
    to break out of the loop as soon as you find what you are looking for. There are
    countless possible scenarios; let us work through a couple of examples together
    to show you how this works in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to apply a 20% discount on all products that have an
    expiration date of today. You can achieve this by using the `continue` statement,
    which tells the looping construct ( `for` or `while` ) to stop executing the body
    immediately and go to the next iteration, if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by importing the `date` and `timedelta` objects, and then we set up
    our products. Those with `sku` `1` and `3` have an expiration date of `today`
    , which means that we want to apply a 20% discount on them. We loop over each
    `product` and inspect the expiration date. If the expiration date does not match
    `today` , we do not want to execute the rest of the body, so we execute the `continue`
    statement. Execution of the loop body stops and goes on to the next iteration.
    If we run the `discount.py` module, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the last two lines of the body have not been executed for `sku`
    number `2` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see an example of breaking out of a loop. Say we want to tell whether
    at least one of the elements in a list evaluates to `True` when fed to the `bool()`
    function. Given that we need to know whether there is at least one, when we find
    it, we do not need to keep scanning the list any further. In Python code, this
    translates to using the `break` statement. Let us write this down into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code makes use of a common programming pattern; you set up a
    **flag** variable before starting the inspection of the items. If you find an
    element that matches your criteria (in this example, that evaluates to `True`
    ), you update the flag and stop iterating. After iteration, you inspect the flag
    and act accordingly. Execution yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See how execution stopped after `True` was found? The `break` statement is similar
    to `continue` , in that it immediately stops executing the body of the loop, but
    it also prevents any further iterations from running, effectively breaking out
    of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to write code to detect whether there is at least one element
    in a sequence that evaluates to `True` , as the built-in function `any()` does
    exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: You can use as many `continue` or `break` statements as you need, anywhere in
    a loop body ( `for` or `while` ). You can even use both in the same loop.
  prefs: []
  type: TYPE_NORMAL
- en: A special else clause
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the features we have seen only in the Python language is the ability
    to have an `else` clause after a loop. It is very rarely used, but it is useful
    to have. If the loop ends normally, because of exhaustion of the iterator ( `for`
    loop) or because the condition is finally not met ( `while` loop), then the `else`
    suite (if present) is executed. If execution is interrupted by a `break` statement,
    the `else` clause is not executed.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take an example of a `for` loop that iterates over a group of items,
    looking for one that would match some condition. If we do not find at least one
    that satisfies the condition, we want to raise an **exception** . This means that
    we want to arrest the regular execution of the program and signal that there was
    an error, or exception. Exceptions will be the subject of *Chapter 7* , *Exceptions
    and Context Managers* , so do not worry if you do not fully understand them for
    now. Just bear in mind that they alter the regular flow of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us first see how we would do this without the `for...else` syntax. Say
    that we want to find, among a collection of people, one that could drive a car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice the *flag* pattern again. We set the driver to be `None` , and then if
    we find one, we update the `driver` flag. At the end of the loop, we inspect it
    to see whether one was found. Notice that if a driver is not found, `DriverException`
    is raised, signaling to the program that execution cannot continue (we are lacking
    the driver).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us see how to do this with an `else` clause on the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we no longer need the *flag* pattern. The exception is raised as
    part of the loop logic, which makes good sense because the loop checks for some
    condition. All we need to do is set up a `driver` object in case we find one;
    this way the rest of the code uses the `driver` object for further processing.
    Notice that the code is shorter and more elegant because the logic is now correctly
    grouped together, where it belongs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his *Transforming Code into Beautiful, Idiomatic Python* video, Raymond
    Hettinger suggests a much better name for the `else` statement associated with
    a `for` loop: `nobreak` . If you struggle with remembering how the `else` works
    for a `for` loop, simply remembering this fact should help you.'
  prefs: []
  type: TYPE_NORMAL
- en: Assignment expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at some more complicated examples, we would like to briefly introduce
    you to a feature that was added to the language in Python 3.8, via PEP 572 ( [https://peps.python.org/pep-0572](https://peps.python.org/pep-0572)
    ). Assignment expressions allow us to bind a value to a name in places where normal
    assignment statements are not allowed. Instead of the normal assignment operator
    `=` , assignment expressions use `:=` (known as the **walrus operator** because
    it resembles the eyes and tusks of a walrus).
  prefs: []
  type: TYPE_NORMAL
- en: Statements and expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the difference between normal assignments and assignment expressions,
    we need to understand the difference between statements and expressions. According
    to the Python documentation ( [https://docs.python.org/3.12/glossary.html#term-statement](https://docs.python.org/3.12/glossary.html#term-statement)
    ), a **statement** is:'
  prefs: []
  type: TYPE_NORMAL
- en: …part of a suite (a “block” of code). A statement is either an expression or
    one of several constructs with a keyword, such as `if` , `while` or `for` .
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An **expression** , on the other hand, is:'
  prefs: []
  type: TYPE_NORMAL
- en: A piece of syntax which can be evaluated to some value. In other words, an expression
    is an accumulation of expression elements like literals, names, attribute access,
    operators or function calls which all return a value.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key distinguishing feature of an expression is that it has a value. Notice
    that an expression can be a statement, but not all statements are expressions.
    In particular, assignments like `name = "heinrich"` are not expressions, so they
    do not have a value. This means that you cannot use an assignment statement in
    the condition expression of a `while` loop or `if` statement (or any other place
    where a value is required).
  prefs: []
  type: TYPE_NORMAL
- en: 'This explains why the Python console does not print a value when you assign
    a value to a name. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: is a statement, which does not have a return value to print.
  prefs: []
  type: TYPE_NORMAL
- en: Using the walrus operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without assignment expressions, you would have to use two separate statements
    if you wanted to bind a value to a name and use that value in an expression. For
    example, it is quite common to see code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With assignment expressions, we could rewrite this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Assignment expressions allow us to write fewer lines of code. Used with care,
    they can also lead to cleaner, more understandable code. Let us look at a slightly
    bigger example to see how an assignment expression can simplify a `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'In interactive scripts, we often need to ask a user to choose between a number
    of options. For example, suppose we are writing an interactive script that allows
    customers at an ice cream shop to choose what flavor they want. To avoid confusion
    when preparing orders, we want to ensure that the user chooses one of the available
    flavors. Without assignment expressions, we might write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a moment to read this code carefully. Note the condition on the loop:
    `while True` means “loop forever,” which is not what we want. We want to stop
    the loop when the user inputs a valid flavor ( `choice in flavors` ). To achieve
    that, we have an `if` statement and a `break` inside the loop. The logic to control
    the loop is not immediately obvious. Despite that, this is actually quite a common
    pattern when the value needed to control the loop can only be obtained inside
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: The `input()` function is very useful in interactive scripts. It prompts the
    user for input and returns it as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we improve on this? Let us try to use an assignment expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, the loop conditional says exactly what we want. That is much easier to
    understand. The code is also three lines shorter.
  prefs: []
  type: TYPE_NORMAL
- en: We need parentheses around the assignment expression in this example because
    the `:=` operator has lower precedence than the `not in` operator. Try removing
    them and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen examples of using assignment expressions in `if` and `while` statements.
    Besides these use cases, assignment expressions are also useful in *lambda expressions*
    (which you will meet in *Chapter 4* , *Functions, the Building Blocks of Code*
    ), as well as *comprehensions* and *generators* (which you will learn about in
    *Chapter 5* , *Comprehensions and Generators* ).
  prefs: []
  type: TYPE_NORMAL
- en: A word of warning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of the walrus operator in Python was somewhat controversial.
    Some people feared that it would make it too easy to write ugly, non-Pythonic
    code. We think that these fears are not entirely justified. As you saw above,
    the walrus operator can *improve* code and make it easier to read. Like any powerful
    feature, it can, however, be abused to write *obfuscated* code. We would advise
    you to use it sparingly. Always think carefully about how it impacts the readability
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Putting all this together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered the basics of conditionals and loops, we can move on
    to the example programs we promised at the beginning of this chapter. We will
    mix and match here so that you can see how you can use all these concepts together.
  prefs: []
  type: TYPE_NORMAL
- en: A prime generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us start by writing some code to generate a list of prime numbers up to
    (and including) some limit. Please bear in mind that we are going to write a very
    inefficient and rudimentary algorithm to find prime numbers. The important thing
    is to concentrate on those bits in the code that belong to this chapter’s subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to Wolfram MathWorld:'
  prefs: []
  type: TYPE_NORMAL
- en: A **prime number** (or prime integer, often simply called a “ **prime** ” for
    short) is a positive integer p>1 that has no positive integer divisors other than
    1 and p itself. More concisely, a prime number p is a positive integer having
    exactly one positive divisor other than 1, meaning it is a number that cannot
    be factored.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Based on this definition, if we consider the first 10 natural numbers, we can
    see that 2, 3, 5, and 7 are primes, while 1, 4, 6, 8, 9, and 10 are not. To determine
    whether a number, *N* , is prime, you can divide it by each of the natural numbers
    in the range *[2, N)* . If the remainder of any division is zero, then the number
    is not a prime.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate the sequence of prime numbers, we will consider each natural number,
    starting from two, up to the limit, and test whether it is a prime. We will write
    two versions of this, the second of which will exploit the `for...else` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a lot happening in this code. We start by setting up an empty
    `primes` list, which will contain the primes at the end. We set the limit to `100`
    , and because we want it to be inclusive, we have to iterate over `range(2, upto
    + 1)` in our outer `for` loop (remember that `range(2, upto)` *would stop at upto
    - 1* ). The outer loop iterates over the candidate primes—that is, all natural
    numbers from `2` to `upto` . Each iteration of this loop tests one number to determine
    whether it is a prime. In each iteration of the outer loop, we set up a flag (which
    is set to `True` at each iteration), and then start dividing the current value
    of `n` by all numbers from `2` to `n - 1` . If we find a proper divisor for `n`
    , it means `n` is composite, so we set the flag to `False` and break the loop.
    Notice that when we break the inner loop, the outer one keeps on going as normal.
    The reason we break after having found a proper divisor for `n` is that we do
    not need any further information to be able to tell that `n` is not a prime.
  prefs: []
  type: TYPE_NORMAL
- en: When we check the `is_prime` flag after the inner loop, if it is still `True`
    , it means we could not find any number in *[2, n)* that is a proper divisor for
    `n` ; therefore, `n` is a prime. We append `n` to the `primes` list and proceed
    to the next iteration, until `n` equals `100` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Before proceeding, we will pose the following question: one of the iterations
    of the outer loop is different from the rest. Can you tell which iteration this
    is—and why? Think about it for a moment, go back to the code, try to work it out
    for yourself, and then keep reading.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you find the answer? Do not feel bad if you did not, the skill to understand
    what the code does by simply looking at it takes time and experience to learn.
    It is an important skill to have as a programmer though, so try to exercise it
    whenever you can. We will tell you the answer now: the first iteration behaves
    differently from all the others. The reason is that in the first iteration, `n`
    is `2` . Therefore, the innermost `for` loop will not run at all because it is
    a `for` loop that iterates over `range(2, 2)` , which is an empty range. Try it
    yourself, write a simple `for` loop with that iterable, put a `print` in the body,
    and see what happens when you run it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not going to try to make this code more efficient from an algorithmic
    point of view. But let us use some of what we learned in this chapter to at least
    make it easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using an `else` clause on the inner loop allows us to get rid of the `is_prime`
    flag. Instead, we append `n` to the `primes` list when we know that the inner
    loop has not encountered any `break` statements. It is only two lines shorter,
    but the code is simpler, cleaner, and reads better. This is important, as simplicity
    and readability count for a lot in programming. Always look for ways to simplify
    your code and make it easier to read. You will thank yourself when you return
    to it months later and have to try to understand what you did before.
  prefs: []
  type: TYPE_NORMAL
- en: Applying discounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we want to show you a technique called a **lookup table**
    , which we are very fond of. We will start by simply writing some code that assigns
    a discount to customers based on their coupon value. We will keep the logic down
    to a minimum here—remember that all we really care about is understanding conditionals
    and loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by setting up some customers. They have an order total, a coupon code,
    and an ID. We made up four types of coupons: two are for fixed amounts and two
    are percentage-based. We use a `match` statement, with a `case` for each coupon
    code and a wildcard to handle invalid coupons. We compute the discount and set
    it as the `"discount"` key in the `customer` dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we just print out part of the data to see whether our code works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is simple to understand, but all those `match` cases are cluttering
    the logic. Adding more coupon codes requires adding additional cases and implementing
    the discount calculation for each case. The discount calculation is very similar
    in most cases, which makes the code repetitive and violates the **Don’t Repeat
    Yourself** ( **DRY** ) principle. In cases like this, you can use a dictionary
    to your advantage, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Running the preceding code produces exactly the same output as the snippet before
    it. The code is two lines shorter, but more importantly, we gained a lot in readability,
    as the body of the `for` loop is now just three lines long and easy to understand.
    The key idea here is to use a dictionary as a **lookup table** . In other words,
    we try to fetch something (the parameters for the discount calculation) from the
    dictionary based on a code (our `coupon_code` ). We use `dict.get(key, default)`
    to ensure that we can handle codes that are not in the dictionary, by supplying
    a default value.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from readability, another major advantage of this approach is that we
    can easily add new coupon codes (or remove old ones) without changing the implementation;
    we only need to change the *data* in the lookup table. In a real-world application,
    we could even store the lookup table in a database and provide an interface for
    users to add or remove coupon codes at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we had to apply some simple linear algebra to calculate the discount.
    Each discount has a percentage and fixed part in the dictionary, represented by
    a two-tuple. By applying `percent * total + fixed` , we get the correct discount.
    When `percent` is `0` , the formula just gives the fixed amount, and it gives
    `percent * total` when `fixed` is `0` .
  prefs: []
  type: TYPE_NORMAL
- en: This technique is closely related to **dispatch tables** , which store functions
    as values in a table. This allows for even greater flexibility. Some object-oriented
    programming languages use this technique internally to implement features such
    as virtual methods.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still unclear as to how this works, we suggest you take your time
    and experiment with it. Change values and add `print()` statements to see what
    is going on while the program is running.
  prefs: []
  type: TYPE_NORMAL
- en: A quick peek at the itertools module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A chapter about iterables, iterators, conditional logic, and looping would
    not be complete without a few words about the `itertools` module. According to
    the Python official documentation ( [https://docs.python.org/3.12/library/itertools.html](https://docs.python.org/3.12/library/itertools.html)
    ), the `itertools` module:'
  prefs: []
  type: TYPE_NORMAL
- en: …implements a number of iterator building blocks inspired by constructs from
    APL, Haskell, and SML. Each has been recast in a form suitable for Python.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The module standardizes a core set of fast, memory efficient tools that are
    useful by themselves or in combination. Together, they form an “iterator algebra”
    making it possible to construct specialized tools succinctly and efficiently in
    pure Python.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We do not have room here to show you everything this module has to offer, so
    we encourage you to explore it further for yourself. However, we can promise that
    you will enjoy it. It provides you with three broad categories of iterators. As
    an introduction, we shall give you a small example of one iterator taken from
    each category.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Infinite iterators allow you to use a `for` loop as an infinite loop, iterating
    over a sequence that never ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `count` factory class makes an iterator that simply goes on and on counting.
    In this example, it starts from `5` and keeps adding `3` at every iteration. We
    need to break it manually if we do not want to get stuck in an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators terminating on the shortest input sequence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This category is quite interesting. It allows you to create an iterator based
    on multiple iterators, combining their values according to some logic. The key
    point here is that the resulting iterator will not break if one of the input iterators
    is shorter than the rest. It will simply stop as soon as the shortest iterator
    is exhausted. This may seem rather abstract, so let us give you an example using
    `compress()` . This iterator takes a sequence of *data* and a sequence of *selectors*
    , yielding only those values from the data sequence that correspond to `True`
    values in the selectors sequence. For example, `compress("ABC", (1, 0, 1))` would
    give back `"A"` and `"C"` because they correspond to `1` . Let us see a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `odd_selector` and `even_selector` are 20 elements in length, while
    `data` is only 10. `compress()` will stop as soon as `data` has yielded its last
    element. Running this code produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It is a fast and convenient way of selecting elements out of an iterable. The
    code is simple, but notice that instead of using a `for` loop to iterate over
    each value that is given back by the `compress()` calls, we used `list()` , which
    does the same, but instead of executing a body of instructions, it puts all the
    values into a list and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Combinatoric generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third category of iterators from `itertools` is combinatoric generators.
    Let us look at a simple example of permutations. According to Wolfram MathWorld:'
  prefs: []
  type: TYPE_NORMAL
- en: A permutation, also called an “arrangement number” or “order,” is a rearrangement
    of the elements of an ordered list S into a one-to-one correspondence with S itself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For example, there are six permutations of `ABC` : `ABC` , `ACB` , `BAC` ,
    `BCA` , `CAB` , and `CBA` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a set has *N* elements, then the number of permutations of them is *N!*
    ( *N* factorial). For example, the string `ABC` has *3! = 3 * 2 * 1 = 6* permutations.
    Let us see this in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This short snippet of code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when you play with permutations. Their number grows at a rate that
    is proportional to the factorial of the number of elements you are permuting,
    and that number can get really big, really fast.
  prefs: []
  type: TYPE_NORMAL
- en: There is a third-party library that expands on the `itertools` module, called
    `more-itertools` . You can find its documentation at [https://more-itertools.readthedocs.io/](https://more-itertools.readthedocs.io/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken another step toward expanding our Python vocabulary.
    We have seen how to drive the execution of code by evaluating conditions, along
    with how to loop and iterate over sequences and collections of objects. This gives
    us the power to control what happens when our code is run, which means we get
    an idea of how to shape it so that it does what we want, having it react to data
    that changes dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: We have also seen how to combine everything together in a couple of simple examples,
    and finally, we took a brief look at the `itertools` module, which is full of
    interesting iterators that can enrich our abilities with Python to a greater degree.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to switch gears, take another step forward, and talk about functions.
    The next chapter is all about them, and they are extremely important. Make sure
    you are comfortable with what has been covered so far. We want to provide you
    with interesting examples, so let’s go.
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_3.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code119001106417026468.png)'
  prefs: []
  type: TYPE_IMG
